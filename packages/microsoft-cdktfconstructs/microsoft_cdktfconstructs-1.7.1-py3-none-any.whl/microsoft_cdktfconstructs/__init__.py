r'''
# Azure Terraform CDK Constructs

Welcome to the Azure Terraform CDK Constructs project! This library offers Azure L2 Constructs using the AZAPI provider for direct Azure REST API access, providing immediate access to new Azure features and API versions.

## ðŸš€ Version 1.0.0 - AZAPI Provider Migration

**Breaking Change Notice:** Version 1.0.0 represents a major architectural shift from AzureRM provider to AZAPI provider. This migration provides:

* **Direct Azure REST API Access**: No dependency on AzureRM provider
* **Immediate Feature Access**: Get new Azure features as soon as they're available in Azure APIs
* **Version-Specific Implementations**: Multiple API versions supported for each service
* **Enhanced Type Safety**: Improved IDE support and compile-time validation
* **Included Provider Bindings**: AZAPI provider classes are included - no need to generate bindings

## Benefits of Using AZAPI L2 Constructs

With AZAPI L2 Constructs, you get the following benefits:

* **Direct API Access**: Bypass provider limitations and access Azure REST APIs directly
* **Version Flexibility**: Choose specific API versions for your resources
* **Rapid Feature Adoption**: Access new Azure features immediately without waiting for provider updates
* **Enhanced Abstraction**: Higher-level abstractions over Azure resources with type safety
* **Built-in Monitoring**: One-line setup for comprehensive monitoring with customizable alerts and diagnostic settings
* **Schema Validation**: Automatic validation of properties against Azure API schemas
* **Reusability**: Encapsulate common patterns and best practices in your infrastructure code
* **Testing Utilities**: Helper functions for integration tests including naming conventions, metadata, and resource cleanup
* **Direct IDE Integration**: Access detailed documentation directly within your IDE
* **Zero Provider Setup**: AZAPI provider bindings included in the package

## Currently Supported Services

### Compute

| Service | API Versions | Monitoring Support | Status |
|---------|-------------|-------------------|--------|
| [Virtual Machines](./src/azure-virtualmachine/README.md) | 2024-07-01, 2024-11-01, 2025-04-01 | âœ… Built-in | âœ… Available |
| [AKS Clusters](./src/azure-aks/README.md) | 2025-05-01, 2025-07-01, 2025-08-01 | âœ… Built-in | âœ… Available |
| [Virtual Machine Scale Sets](./src/azure-vmss/README.md) | 2025-01-02, 2025-02-01, 2025-04-01 | âœ… Built-in | âœ… Available |

### Networking

| Service | API Versions | Status |
|---------|-------------|--------|
| [Virtual Networks](./src/azure-virtualnetwork/README.md) | 2024-07-01, 2024-10-01, 2025-01-01 | âœ… Available |
| [Subnets](./src/azure-subnet/README.md) | 2024-07-01, 2024-10-01, 2025-01-01 | âœ… Available |
| [Network Interfaces](./src/azure-networkinterface/README.md) | 2024-07-01, 2024-10-01, 2025-01-01 | âœ… Available |
| [Network Security Groups](./src/azure-networksecuritygroup/README.md) | 2024-07-01, 2024-10-01, 2025-01-01 | âœ… Available |
| [Public IP Addresses](./src/azure-publicipaddress/README.md) | 2024-07-01, 2024-10-01, 2025-01-01 | âœ… Available |

### Monitoring & Alerting

| Service | API Versions | Status |
|---------|-------------|--------|
| [Action Groups](./src/azure-actiongroup/README.md) | 2021-09-01 | âœ… Available |
| [Metric Alerts](./src/azure-metricalert/README.md) | 2018-03-01 | âœ… Available |
| [Activity Log Alerts](./src/azure-activitylogalert/README.md) | 2020-10-01 | âœ… Available |
| [Diagnostic Settings](./src/azure-diagnosticsettings/README.md) | 2016-09-01, 2021-05-01-preview | âœ… Available |

### Foundation

| Service | API Versions | Status |
|---------|-------------|--------|
| [Resource Groups](./src/azure-resourcegroup/README.md) | 2024-11-01, 2025-01-01, 2025-03-01 | âœ… Available |
| [Storage Accounts](./src/azure-storageaccount/README.md) | 2023-01-01, 2023-05-01, 2024-01-01 | âœ… Available |

## Quick Example

Create Azure resources using AZAPI provider:

```python
import * as azcdk from "@microsoft/terraform-cdk-constructs";
import { Construct } from 'constructs';
import { App, TerraformStack } from 'cdktf';

class AzureAppInfra extends TerraformStack {
  constructor(scope: Construct, name: string) {
    super(scope, name);

    // Create a new Azure Resource Group using AZAPI
    const rg = new azcdk.azure_resourcegroup.ResourceGroup(this, "resourcegroup", {
      name: "rg-myapp-prod",
      location: "eastus",
      tags: {
        environment: "production",
        project: "myapp"
      }
    });

    // Create a Storage Account
    new azcdk.azure_storageaccount.StorageAccount(this, "storage", {
      name: "mystorageaccount",
      location: "eastus",
      resourceGroupId: rg.id,
      sku: { name: "Standard_LRS" }
    });
  }
}

const app = new App();
new AzureAppInfra(app, 'cdk');
app.synth();
```

## Getting Started

### Prerequisites

* Node.js and npm installed (for TypeScript/JavaScript)
* Azure CLI configured with appropriate permissions

### Installation

Install the CDK for Terraform CLI globally:

```sh
npm install -g cdktf-cli
```

Initialize a new CDK for Terraform project:

```sh
cdktf init --template="TypeScript" --local
```

Install the Microsoft Terraform CDK constructs (includes AZAPI provider bindings):

```sh
npm install @microsoft/terraform-cdk-constructs
```

That's it! The AZAPI provider classes are included in the package, so you don't need to configure additional providers or generate bindings.

## Built-in Monitoring & Alerting

Azure L2 Constructs include comprehensive monitoring capabilities that can be enabled with a single method call. The monitoring framework automatically creates metric alerts, diagnostic settings, and activity log alerts for supported resources.

### Quick Example

```python
import { VirtualMachine } from "@microsoft/terraform-cdk-constructs/azure-virtualmachine";
import { ActionGroup } from "@microsoft/terraform-cdk-constructs/azure-actiongroup";

// Enable monitoring with one line
const vm = new VirtualMachine(this, "vm", {
  name: "my-vm",
  // ... VM configuration ...
  monitoring: VirtualMachine.defaultMonitoring(actionGroup.id, workspaceId),
});
```

### Supported Resources

| Resource | Monitoring Documentation |
|----------|-------------------------|
| Virtual Machines | [VM Monitoring Guide](./src/azure-virtualmachine/README.md#monitoring) |
| AKS Clusters | [AKS Monitoring Guide](./src/azure-aks/README.md#monitoring) |
| Virtual Machine Scale Sets | [VMSS Monitoring Guide](./src/azure-vmss/README.md#monitoring) |
| Storage Accounts | [Storage Monitoring Guide](./src/azure-storageaccount/README.md#monitoring) |

See the [Monitoring Guide](./docs/monitoring-guide.md) for comprehensive documentation on monitoring capabilities, customization options, and best practices.

## Networking Constructs

Build complete Azure networking infrastructure with type-safe constructs that provide automatic validation and version management.

### Available Components

| Component | Documentation |
|-----------|--------------|
| [Virtual Networks](./src/azure-virtualnetwork/README.md) | Define address spaces and network isolation with custom DNS and DDoS protection |
| [Subnets](./src/azure-subnet/README.md) | Segment networks with service endpoints, delegations, and NSG association |
| [Network Interfaces](./src/azure-networkinterface/README.md) | Attach to VMs with static/dynamic IPs and accelerated networking |
| [Network Security Groups](./src/azure-networksecuritygroup/README.md) | Control traffic with inbound/outbound security rules |
| [Public IP Addresses](./src/azure-publicipaddress/README.md) | Expose resources with static/dynamic allocation |

See individual service documentation for detailed configuration examples and best practices.

## Version-Specific Usage

You can use specific API versions for fine-grained control:

```python
// Use latest version (recommended) - automatically resolves to newest API version
import { ResourceGroup } from "@microsoft/terraform-cdk-constructs/azure-resourcegroup";
import { StorageAccount } from "@microsoft/terraform-cdk-constructs/azure-storageaccount";

// Or specify explicit API version for version pinning
const rg = new ResourceGroup(this, "rg", {
  name: "my-resource-group",
  location: "eastus",
  apiVersion: "2025-03-01"  // Pin to specific version
});

const storage = new StorageAccount(this, "storage", {
  name: "mystorageaccount",
  location: "eastus",
  resourceGroupId: rg.id,
  sku: { name: "Standard_LRS" },
  apiVersion: "2024-01-01"  // Pin to specific version
});
```

## Migration from v0.x

If you're migrating from version 0.x (AzureRM-based), please see our [Versioning and Migrations User Guide](./docs/versioning-and-migrations-user-guide.md) for detailed instructions.

## Deployment

Generate Terraform configuration:

```sh
cdktf synth
```

Deploy your infrastructure:

```sh
cdktf deploy
```

## Supported Languages

Thanks to JSII, this library is available in multiple programming languages:

| Language   | Package | Status |
|------------|---------|--------|
| TypeScript/JavaScript | [`@microsoft/terraform-cdk-constructs`](https://www.npmjs.com/package/@microsoft/terraform-cdk-constructs) | âœ… Available |
| Python     | [`microsoft-cdktfconstructs`](https://pypi.org/project/microsoft-cdktfconstructs/) | âœ… Available |
| Java       | [`com.microsoft.terraformcdkconstructs`](https://search.maven.org/artifact/com.microsoft.terraformcdkconstructs/cdktf-azure-constructs) | âœ… Available |
| C#/.NET    | [`Microsoft.Cdktf.Azure.TFConstructs`](https://www.nuget.org/packages/Microsoft.Cdktf.Azure.TFConstructs) | âœ… Available |

## Contributing

This project welcomes contributions and suggestions. Most contributions require you to agree to a
Contributor License Agreement (CLA) declaring that you have the right to, and actually do, grant us
the rights to use your contribution. For details, visit https://cla.opensource.microsoft.com.

When you submit a pull request, a CLA bot will automatically determine whether you need to provide
a CLA and decorate the PR appropriately (e.g., status check, comment). Simply follow the instructions
provided by the bot. You will only need to do this once across all repos using our CLA.

This project has adopted the [Microsoft Open Source Code of Conduct](https://opensource.microsoft.com/codeofconduct/).
For more information see the [Code of Conduct FAQ](https://opensource.microsoft.com/codeofconduct/faq/) or
contact [opencode@microsoft.com](mailto:opencode@microsoft.com) with any additional questions or comments.

We welcome contributions to this project! See our documentation on [how to get started contributing](./CONTRIBUTING.md).

## Documentation

* [Architecture Documentation](./docs/ARCHITECTURE.md) - High-level architecture and design patterns
* [Monitoring Guide](./docs/monitoring-guide.md) - Comprehensive monitoring and alerting documentation
* [Versioning and Migrations User Guide](./docs/versioning-and-migrations-user-guide.md) - API version management and migration guidance
* [Testing Guide](./docs/testing.md) - Testing practices and utilities
* [Design Guide](./docs/design_guide.md) - Module design guidelines
* [API Documentation](./API.md) - Complete API reference

## Code Spaces

[![Open in GitHub Codespaces](https://img.shields.io/badge/Open%20in%20GitHub%20Codespaces-blue?logo=github)](https://github.com/Azure/terraform-cdk-constructs/codespaces)

## Trademarks

This project may contain trademarks or logos for projects, products, or services. Authorized use of Microsoft
trademarks or logos is subject to and must follow
[Microsoft's Trademark & Brand Guidelines](https://www.microsoft.com/en-us/legal/intellectualproperty/trademarks/usage/general).
Use of Microsoft trademarks or logos in modified versions of this project must not cause confusion or imply Microsoft sponsorship.
Any use of third-party trademarks or logos are subject to those third-party's policies.
'''
from pkgutil import extend_path
__path__ = extend_path(__path__, __name__)

import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

import typeguard
from importlib.metadata import version as _metadata_package_version
TYPEGUARD_MAJOR_VERSION = int(_metadata_package_version('typeguard').split('.')[0])

def check_type(argname: str, value: object, expected_type: typing.Any) -> typing.Any:
    if TYPEGUARD_MAJOR_VERSION <= 2:
        return typeguard.check_type(argname=argname, value=value, expected_type=expected_type) # type:ignore
    else:
        if isinstance(value, jsii._reference_map.InterfaceDynamicProxy): # pyright: ignore [reportAttributeAccessIssue]
           pass
        else:
            if TYPEGUARD_MAJOR_VERSION == 3:
                typeguard.config.collection_check_strategy = typeguard.CollectionCheckStrategy.ALL_ITEMS # type:ignore
                typeguard.check_type(value=value, expected_type=expected_type) # type:ignore
            else:
                typeguard.check_type(value=value, expected_type=expected_type, collection_check_strategy=typeguard.CollectionCheckStrategy.ALL_ITEMS) # type:ignore

from ._jsii import *

import cdktf as _cdktf_9a9027ec
import constructs as _constructs_77d1e7e8
from .azure_actiongroup import (
    ActionGroupBodyProperties as _ActionGroupBodyProperties_73f4a4cb,
    ActionGroupProps as _ActionGroupProps_572d2b68,
    AzureFunctionReceiver as _AzureFunctionReceiver_dfacaeac,
    EmailReceiver as _EmailReceiver_32579ca3,
    LogicAppReceiver as _LogicAppReceiver_bcf80983,
    SmsReceiver as _SmsReceiver_8bf8dc4d,
    VoiceReceiver as _VoiceReceiver_17e05799,
    WebhookReceiver as _WebhookReceiver_fdbf2c51,
)
from .azure_activitylogalert import (
    ActivityLogAlertActionGroup as _ActivityLogAlertActionGroup_7db22b2a,
    ActivityLogAlertActions as _ActivityLogAlertActions_efbd1a87,
    ActivityLogAlertBodyProperties as _ActivityLogAlertBodyProperties_652af2f5,
    ActivityLogAlertCondition as _ActivityLogAlertCondition_dfb706a4,
    ActivityLogAlertLeafCondition as _ActivityLogAlertLeafCondition_3bceda39,
    ActivityLogAlertProps as _ActivityLogAlertProps_f1779054,
)
from .azure_aks import (
    AksClusterAadProfile as _AksClusterAadProfile_cbb39e4e,
    AksClusterAddonProfile as _AksClusterAddonProfile_75e5bc97,
    AksClusterAgentPoolProfile as _AksClusterAgentPoolProfile_19702e0d,
    AksClusterApiServerAccessProfile as _AksClusterApiServerAccessProfile_a245e705,
    AksClusterAutoScalerProfile as _AksClusterAutoScalerProfile_15ae7fd0,
    AksClusterAzureKeyVaultKms as _AksClusterAzureKeyVaultKms_91079d0f,
    AksClusterBlobCSIDriver as _AksClusterBlobCSIDriver_ad59fbc0,
    AksClusterBodyProperties as _AksClusterBodyProperties_ba40e5e9,
    AksClusterDefenderSecurityMonitoring as _AksClusterDefenderSecurityMonitoring_5f628d72,
    AksClusterDiskCSIDriver as _AksClusterDiskCSIDriver_f506f2f6,
    AksClusterEffectiveOutboundIP as _AksClusterEffectiveOutboundIP_a56a4ba3,
    AksClusterFileCSIDriver as _AksClusterFileCSIDriver_5ce3ba90,
    AksClusterGmsaProfile as _AksClusterGmsaProfile_c0e9a445,
    AksClusterHttpProxyConfig as _AksClusterHttpProxyConfig_41bff94e,
    AksClusterIdentity as _AksClusterIdentity_92ed97a4,
    AksClusterImageCleaner as _AksClusterImageCleaner_eb3f0d8f,
    AksClusterKeda as _AksClusterKeda_9143ef79,
    AksClusterKubeletConfig as _AksClusterKubeletConfig_b1842d3f,
    AksClusterLinuxOSConfig as _AksClusterLinuxOSConfig_c1e15359,
    AksClusterLinuxProfile as _AksClusterLinuxProfile_516beb3b,
    AksClusterLoadBalancerProfile as _AksClusterLoadBalancerProfile_67c2ac62,
    AksClusterManagedOutboundIPProfile as _AksClusterManagedOutboundIPProfile_ce484d83,
    AksClusterManagedOutboundIPs as _AksClusterManagedOutboundIPs_7800bd02,
    AksClusterMonitoringOptions as _AksClusterMonitoringOptions_3f2d05a9,
    AksClusterNatGatewayProfile as _AksClusterNatGatewayProfile_b267c658,
    AksClusterNetworkProfile as _AksClusterNetworkProfile_ec57fbab,
    AksClusterOidcIssuerProfile as _AksClusterOidcIssuerProfile_55bd4791,
    AksClusterOutboundIPPrefixes as _AksClusterOutboundIPPrefixes_998c4e88,
    AksClusterOutboundIPs as _AksClusterOutboundIPs_fa40a921,
    AksClusterProps as _AksClusterProps_df15bce7,
    AksClusterResourceReference as _AksClusterResourceReference_66302c1f,
    AksClusterSecurityProfile as _AksClusterSecurityProfile_6e20ee0b,
    AksClusterServicePrincipalProfile as _AksClusterServicePrincipalProfile_5638b9c4,
    AksClusterSku as _AksClusterSku_746ad049,
    AksClusterSnapshotController as _AksClusterSnapshotController_1593a1b6,
    AksClusterSshConfiguration as _AksClusterSshConfiguration_a24a3e25,
    AksClusterSshPublicKey as _AksClusterSshPublicKey_6ec15741,
    AksClusterStorageProfile as _AksClusterStorageProfile_cc359e1f,
    AksClusterSysctlConfig as _AksClusterSysctlConfig_ebc83aec,
    AksClusterVerticalPodAutoscaler as _AksClusterVerticalPodAutoscaler_9805c99b,
    AksClusterWindowsProfile as _AksClusterWindowsProfile_bf96f6e4,
    AksClusterWorkloadAutoScalerProfile as _AksClusterWorkloadAutoScalerProfile_ec94d7bc,
    AksClusterWorkloadIdentity as _AksClusterWorkloadIdentity_98ca3ec0,
)
from .azure_diagnosticsettings import (
    DiagnosticSettingsBodyProperties as _DiagnosticSettingsBodyProperties_ed65245b,
    DiagnosticSettingsProps as _DiagnosticSettingsProps_cc0fa615,
)
from .azure_dnsforwardingruleset import (
    DnsForwardingRulesetProperties as _DnsForwardingRulesetProperties_2e4f976e,
    DnsForwardingRulesetProps as _DnsForwardingRulesetProps_a40699d5,
    DnsForwardingRulesetVirtualNetworkLinkProperties as _DnsForwardingRulesetVirtualNetworkLinkProperties_c0ccbf67,
    DnsForwardingRulesetVirtualNetworkLinkProps as _DnsForwardingRulesetVirtualNetworkLinkProps_7096eaf4,
    DnsForwardingRulesetVirtualNetworkReference as _DnsForwardingRulesetVirtualNetworkReference_4806dc52,
    DnsResolverOutboundEndpointReference as _DnsResolverOutboundEndpointReference_c6bd5513,
    ForwardingRuleProperties as _ForwardingRuleProperties_244c500c,
    ForwardingRuleProps as _ForwardingRuleProps_2d00d2ca,
    TargetDnsServer as _TargetDnsServer_14a5d2e0,
)
from .azure_dnsresolver import (
    DnsResolverInboundEndpointProps as _DnsResolverInboundEndpointProps_cae29fa2,
    DnsResolverOutboundEndpointProps as _DnsResolverOutboundEndpointProps_a59b4be2,
    DnsResolverProps as _DnsResolverProps_cee95b5b,
)
from .azure_dnszone import (
    DnsZoneProps as _DnsZoneProps_90137124,
    VirtualNetworkReference as _VirtualNetworkReference_d6a6c338,
)
from .azure_metricalert import (
    DynamicThresholdCriteria as _DynamicThresholdCriteria_a75d1b26,
    MetricAlertAction as _MetricAlertAction_2c2527f4,
    MetricAlertBodyProperties as _MetricAlertBodyProperties_8cfa84e9,
    MetricAlertFailingPeriods as _MetricAlertFailingPeriods_93398eb2,
    MetricAlertProps as _MetricAlertProps_a18d777f,
    MetricDimension as _MetricDimension_8611b872,
    StaticThresholdCriteria as _StaticThresholdCriteria_e446085b,
)
from .azure_networkinterface import (
    NetworkInterfaceBodyProperties as _NetworkInterfaceBodyProperties_1ebf3a2a,
    NetworkInterfaceDnsSettings as _NetworkInterfaceDnsSettings_c9406208,
    NetworkInterfaceIPConfiguration as _NetworkInterfaceIPConfiguration_c63cf7d5,
    NetworkInterfaceNSGReference as _NetworkInterfaceNSGReference_c2c81f03,
    NetworkInterfaceProps as _NetworkInterfaceProps_e944bdac,
    NetworkInterfacePublicIPReference as _NetworkInterfacePublicIPReference_3c09f670,
    NetworkInterfaceSubnetReference as _NetworkInterfaceSubnetReference_12eff6ea,
)
from .azure_networksecuritygroup import (
    NetworkSecurityGroupProps as _NetworkSecurityGroupProps_b07981a4,
    SecurityRule as _SecurityRule_e3229718,
    SecurityRuleProperties as _SecurityRuleProperties_74ae9ffc,
)
from .azure_policyassignment import (
    PolicyAssignmentIdentity as _PolicyAssignmentIdentity_49ed2b2a,
    PolicyAssignmentNonComplianceMessage as _PolicyAssignmentNonComplianceMessage_4bb37598,
    PolicyAssignmentProperties as _PolicyAssignmentProperties_59266900,
    PolicyAssignmentProps as _PolicyAssignmentProps_ed0fd29f,
)
from .azure_policydefinition import (
    PolicyDefinitionProperties as _PolicyDefinitionProperties_ff703616,
    PolicyDefinitionProps as _PolicyDefinitionProps_10bc74fd,
)
from .azure_privatednszone import PrivateDnsZoneProps as _PrivateDnsZoneProps_5abbb1b8
from .azure_publicipaddress import (
    PublicIPAddressDnsSettings as _PublicIPAddressDnsSettings_d3ef5a04,
    PublicIPAddressProps as _PublicIPAddressProps_ec145bdf,
    PublicIPAddressSku as _PublicIPAddressSku_00870b2b,
)
from .azure_resourcegroup import ResourceGroupProps as _ResourceGroupProps_2bf9437d
from .azure_roleassignment import (
    RoleAssignmentProperties as _RoleAssignmentProperties_d993b254,
    RoleAssignmentProps as _RoleAssignmentProps_ee8daa82,
)
from .azure_roledefinition import (
    RoleDefinitionPermission as _RoleDefinitionPermission_5623a628,
    RoleDefinitionProperties as _RoleDefinitionProperties_f78101b5,
    RoleDefinitionProps as _RoleDefinitionProps_4196e132,
)
from .azure_storageaccount import (
    StorageAccountBodyProperties as _StorageAccountBodyProperties_4d550b33,
    StorageAccountEncryption as _StorageAccountEncryption_77d27837,
    StorageAccountEncryptionService as _StorageAccountEncryptionService_aaadb7be,
    StorageAccountEncryptionServices as _StorageAccountEncryptionServices_8a1bf271,
    StorageAccountIdentity as _StorageAccountIdentity_d6b6a344,
    StorageAccountIpRule as _StorageAccountIpRule_83a6da4e,
    StorageAccountMonitoringOptions as _StorageAccountMonitoringOptions_a7efe8e5,
    StorageAccountNetworkAcls as _StorageAccountNetworkAcls_768fda36,
    StorageAccountProps as _StorageAccountProps_0b7b5bac,
    StorageAccountSku as _StorageAccountSku_fa953b33,
    StorageAccountVirtualNetworkRule as _StorageAccountVirtualNetworkRule_825a3860,
)
from .azure_subnet import (
    SubnetDelegation as _SubnetDelegation_c6136dfd,
    SubnetNATGatewayReference as _SubnetNATGatewayReference_cf82a70c,
    SubnetNSGReference as _SubnetNSGReference_02d94a8f,
    SubnetProps as _SubnetProps_b86f39ca,
    SubnetRouteTableReference as _SubnetRouteTableReference_5c30e955,
    SubnetServiceEndpoint as _SubnetServiceEndpoint_ada81b5d,
)
from .azure_virtualmachine import (
    VirtualMachineAdditionalCapabilities as _VirtualMachineAdditionalCapabilities_22a84ae8,
    VirtualMachineAvailabilitySetReference as _VirtualMachineAvailabilitySetReference_639f580a,
    VirtualMachineBillingProfile as _VirtualMachineBillingProfile_b57d8936,
    VirtualMachineBodyProperties as _VirtualMachineBodyProperties_b30829f2,
    VirtualMachineBootDiagnostics as _VirtualMachineBootDiagnostics_51400f7e,
    VirtualMachineDataDisk as _VirtualMachineDataDisk_839db3b6,
    VirtualMachineDiagnosticsProfile as _VirtualMachineDiagnosticsProfile_05cee027,
    VirtualMachineDiskEncryptionSetParameters as _VirtualMachineDiskEncryptionSetParameters_804f37ce,
    VirtualMachineHardwareProfile as _VirtualMachineHardwareProfile_cb34f918,
    VirtualMachineHostReference as _VirtualMachineHostReference_f551629f,
    VirtualMachineIdentity as _VirtualMachineIdentity_dc7decb0,
    VirtualMachineImageReference as _VirtualMachineImageReference_f5fa193e,
    VirtualMachineLinuxConfiguration as _VirtualMachineLinuxConfiguration_5f791d4c,
    VirtualMachineLinuxPatchSettings as _VirtualMachineLinuxPatchSettings_171efe8f,
    VirtualMachineManagedDiskParameters as _VirtualMachineManagedDiskParameters_0c76a786,
    VirtualMachineMonitoringOptions as _VirtualMachineMonitoringOptions_083b4c57,
    VirtualMachineNetworkInterfaceProperties as _VirtualMachineNetworkInterfaceProperties_d2a4bcfa,
    VirtualMachineNetworkInterfaceReference as _VirtualMachineNetworkInterfaceReference_67cea400,
    VirtualMachineNetworkProfile as _VirtualMachineNetworkProfile_42959f1d,
    VirtualMachineOSDisk as _VirtualMachineOSDisk_582a6f94,
    VirtualMachineOSProfile as _VirtualMachineOSProfile_6980e298,
    VirtualMachinePlan as _VirtualMachinePlan_2ca6c6de,
    VirtualMachineProps as _VirtualMachineProps_9011059a,
    VirtualMachineProximityPlacementGroupReference as _VirtualMachineProximityPlacementGroupReference_b821dec8,
    VirtualMachineScaleSetReference as _VirtualMachineScaleSetReference_c6dfc840,
    VirtualMachineSecret as _VirtualMachineSecret_47d96616,
    VirtualMachineSecurityProfile as _VirtualMachineSecurityProfile_59175751,
    VirtualMachineSshConfiguration as _VirtualMachineSshConfiguration_7da21948,
    VirtualMachineSshPublicKey as _VirtualMachineSshPublicKey_6551d0b0,
    VirtualMachineStorageProfile as _VirtualMachineStorageProfile_793daa4a,
    VirtualMachineSubResource as _VirtualMachineSubResource_f7a6c8fb,
    VirtualMachineUefiSettings as _VirtualMachineUefiSettings_ba93462d,
    VirtualMachineVaultCertificate as _VirtualMachineVaultCertificate_60841248,
    VirtualMachineWinRMConfiguration as _VirtualMachineWinRMConfiguration_1df9a9c3,
    VirtualMachineWinRMListener as _VirtualMachineWinRMListener_85e51ce5,
    VirtualMachineWindowsConfiguration as _VirtualMachineWindowsConfiguration_31cdebe5,
    VirtualMachineWindowsPatchSettings as _VirtualMachineWindowsPatchSettings_18b61ab1,
)
from .azure_virtualnetwork import (
    VirtualNetworkAddressSpace as _VirtualNetworkAddressSpace_f881cca1,
    VirtualNetworkDhcpOptions as _VirtualNetworkDhcpOptions_da8e9a61,
    VirtualNetworkProps as _VirtualNetworkProps_b95b42ef,
)
from .azure_virtualnetworkgateway import (
    VirtualNetworkGatewayBgpSettings as _VirtualNetworkGatewayBgpSettings_63ddc7c4,
    VirtualNetworkGatewayCustomRoutes as _VirtualNetworkGatewayCustomRoutes_7b9fea86,
    VirtualNetworkGatewayDefaultSite as _VirtualNetworkGatewayDefaultSite_7b6991ba,
    VirtualNetworkGatewayIpConfiguration as _VirtualNetworkGatewayIpConfiguration_853eed86,
    VirtualNetworkGatewayProps as _VirtualNetworkGatewayProps_451d4fab,
    VirtualNetworkGatewaySku as _VirtualNetworkGatewaySku_46d6411c,
    VirtualNetworkGatewayVpnClientAddressPool as _VirtualNetworkGatewayVpnClientAddressPool_99253f78,
    VirtualNetworkGatewayVpnClientConfiguration as _VirtualNetworkGatewayVpnClientConfiguration_861b9698,
)
from .azure_virtualnetworkgatewayconnection import (
    GatewayReference as _GatewayReference_be6ddc95,
    IpsecPolicy as _IpsecPolicy_1ea4f1e2,
    NatRuleReference as _NatRuleReference_233246a9,
    PeerReference as _PeerReference_619b2bd0,
    VirtualNetworkGatewayConnectionProps as _VirtualNetworkGatewayConnectionProps_887ddc7c,
)
from .azure_virtualnetworkmanager import (
    AddConnectivityConfigurationProps as _AddConnectivityConfigurationProps_bd7d736a,
    AddIpamPoolProps as _AddIpamPoolProps_73020ba0,
    AddNetworkGroupProps as _AddNetworkGroupProps_b54cf2f3,
    AddSecurityAdminConfigurationProps as _AddSecurityAdminConfigurationProps_e1caa5ba,
    AddressPrefixItem as _AddressPrefixItem_ccd8b167,
    ConnectivityConfiguration as _ConnectivityConfiguration_d2d778e4,
    ConnectivityConfigurationProperties as _ConnectivityConfigurationProperties_87ca695a,
    ConnectivityConfigurationProps as _ConnectivityConfigurationProps_38bdc7ac,
    ConnectivityGroupItem as _ConnectivityGroupItem_d310024f,
    Hub as _Hub_d4efdd65,
    IpamPool as _IpamPool_7cd9567e,
    IpamPoolProperties as _IpamPoolProperties_2b6465ac,
    IpamPoolProps as _IpamPoolProps_d9986f49,
    IpamPoolStaticCidrProperties as _IpamPoolStaticCidrProperties_794c371f,
    IpamPoolStaticCidrProps as _IpamPoolStaticCidrProps_f7b282ba,
    NetworkGroup as _NetworkGroup_2f776cdc,
    NetworkGroupProperties as _NetworkGroupProperties_c6b41db0,
    NetworkGroupProps as _NetworkGroupProps_81c3604d,
    NetworkGroupStaticMemberProperties as _NetworkGroupStaticMemberProperties_808adefa,
    NetworkGroupStaticMemberProps as _NetworkGroupStaticMemberProps_fdd03072,
    NetworkManagerScopes as _NetworkManagerScopes_d6035bf8,
    SecurityAdminConfiguration as _SecurityAdminConfiguration_f3492edd,
    SecurityAdminConfigurationProperties as _SecurityAdminConfigurationProperties_fd4a713c,
    SecurityAdminConfigurationProps as _SecurityAdminConfigurationProps_a2d487cb,
    SecurityAdminConfigurationRuleGroupItem as _SecurityAdminConfigurationRuleGroupItem_29d670e4,
    SecurityAdminRuleCollectionProperties as _SecurityAdminRuleCollectionProperties_40adae7c,
    SecurityAdminRuleCollectionProps as _SecurityAdminRuleCollectionProps_7f0467b9,
    SecurityAdminRuleProperties as _SecurityAdminRuleProperties_239a5478,
    SecurityAdminRuleProps as _SecurityAdminRuleProps_cb122363,
    VirtualNetworkManagerProperties as _VirtualNetworkManagerProperties_794596ca,
    VirtualNetworkManagerProps as _VirtualNetworkManagerProps_3038f7e4,
)
from .azure_vmss import (
    AdditionalCapabilities as _AdditionalCapabilities_a2950776,
    AutomaticOSUpgradePolicy as _AutomaticOSUpgradePolicy_11c86d38,
    AutomaticRepairsPolicy as _AutomaticRepairsPolicy_6d70e54f,
    ExtensionProfile as _ExtensionProfile_ec55a00c,
    HealthProbeReference as _HealthProbeReference_1eac48d7,
    HostGroupReference as _HostGroupReference_3690e1b0,
    IPConfiguration as _IPConfiguration_3c957377,
    IPConfigurationProperties as _IPConfigurationProperties_1aaf4cca,
    IPConfigurationSubnet as _IPConfigurationSubnet_5df9d616,
    NetworkInterfaceConfiguration as _NetworkInterfaceConfiguration_c5773a40,
    NetworkInterfaceConfigurationProperties as _NetworkInterfaceConfigurationProperties_5b8d6a5d,
    NetworkSecurityGroupReference as _NetworkSecurityGroupReference_681673f0,
    ProximityPlacementGroupReference as _ProximityPlacementGroupReference_c34e9a6e,
    PublicIPAddressConfiguration as _PublicIPAddressConfiguration_b1ff4aec,
    PublicIPAddressConfigurationProperties as _PublicIPAddressConfigurationProperties_2d1f2680,
    PublicIPDnsSettings as _PublicIPDnsSettings_cb1a7a4f,
    ResourceReference as _ResourceReference_d41d8a5a,
    RollingUpgradePolicy as _RollingUpgradePolicy_9ee9233f,
    ScheduledEventsProfile as _ScheduledEventsProfile_f4e5611c,
    TerminateNotificationProfile as _TerminateNotificationProfile_f8017676,
    VMExtension as _VMExtension_034783ba,
    VMExtensionProperties as _VMExtensionProperties_a1e3e947,
    VirtualMachineScaleSetBodyProperties as _VirtualMachineScaleSetBodyProperties_4f71389b,
    VirtualMachineScaleSetNetworkProfile as _VirtualMachineScaleSetNetworkProfile_e3604858,
    VirtualMachineScaleSetOSProfile as _VirtualMachineScaleSetOSProfile_320ebb42,
    VirtualMachineScaleSetProps as _VirtualMachineScaleSetProps_1daecaa8,
    VirtualMachineScaleSetScaleInPolicy as _VirtualMachineScaleSetScaleInPolicy_08264334,
    VirtualMachineScaleSetSku as _VirtualMachineScaleSetSku_34577b48,
    VirtualMachineScaleSetUpgradePolicy as _VirtualMachineScaleSetUpgradePolicy_ff7653fe,
    VirtualMachineScaleSetVMProfile as _VirtualMachineScaleSetVMProfile_ec8f7867,
    VmssMonitoringOptions as _VmssMonitoringOptions_d4afc1e8,
)
from .core_azure import (
    ApiSchema as _ApiSchema_5ce0490e,
    ApiVersionManager as _ApiVersionManager_76b80279,
    AzapiResource as _AzapiResource_7e7f5b39,
    AzapiResourceProps as _AzapiResourceProps_141a2340,
    AzapiRoleAssignmentProps as _AzapiRoleAssignmentProps_d153e00c,
    BreakingChange as _BreakingChange_5dc94c31,
    DiagnosticLogConfig as _DiagnosticLogConfig_990fcbff,
    DiagnosticMetricConfig as _DiagnosticMetricConfig_29c0add1,
    MigrationAnalysis as _MigrationAnalysis_aa719f40,
    MonitoringConfig as _MonitoringConfig_7c28df74,
    PropertyDefinition as _PropertyDefinition_2a5c46ac,
    PropertyTransformer as _PropertyTransformer_9b876b7f,
    PropertyValidation as _PropertyValidation_bb241cd7,
    RetentionPolicyConfig as _RetentionPolicyConfig_13c42ec6,
    SchemaMapper as _SchemaMapper_cf4ebcd7,
    ValidationResult as _ValidationResult_87269226,
    ValidationRule as _ValidationRule_f1913ed6,
    VersionChangeLog as _VersionChangeLog_3bfd366b,
    VersionConfig as _VersionConfig_ddf991d0,
    VersionLifecycle as _VersionLifecycle_d648b2ea,
)
from .testing import BaseTestStackOptions as _BaseTestStackOptions_431240be


class ActionGroup(
    _AzapiResource_7e7f5b39,
    metaclass=jsii.JSIIMeta,
    jsii_type="@microsoft/terraform-cdk-constructs.ActionGroup",
):
    '''Unified Azure Action Group implementation.

    This class provides a single, version-aware implementation that automatically handles version
    resolution, schema validation, and property transformation while maintaining full JSII compliance.

    Action Groups serve as the central notification hub for Azure Monitor alerts, supporting
    multiple receiver types including email, SMS, webhook, Azure Functions, Logic Apps, and voice calls.

    Example::

        // Action group with multiple receiver types:
        const actionGroup = new ActionGroup(this, "critical-alerts", {
          name: "critical-action-group",
          groupShortName: "Critical",
          resourceGroupId: resourceGroup.id,
          emailReceivers: [{
            name: "oncall-email",
            emailAddress: "oncall@company.com",
            useCommonAlertSchema: true
          }],
          smsReceivers: [{
            name: "oncall-sms",
            countryCode: "1",
            phoneNumber: "5551234567"
          }],
          webhookReceivers: [{
            name: "pagerduty-webhook",
            serviceUri: "https://events.pagerduty.com/...",
            useCommonAlertSchema: true
          }]
        });
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        group_short_name: builtins.str,
        azure_function_receivers: typing.Optional[typing.Sequence[typing.Union[_AzureFunctionReceiver_dfacaeac, typing.Dict[builtins.str, typing.Any]]]] = None,
        email_receivers: typing.Optional[typing.Sequence[typing.Union[_EmailReceiver_32579ca3, typing.Dict[builtins.str, typing.Any]]]] = None,
        enabled: typing.Optional[builtins.bool] = None,
        logic_app_receivers: typing.Optional[typing.Sequence[typing.Union[_LogicAppReceiver_bcf80983, typing.Dict[builtins.str, typing.Any]]]] = None,
        resource_group_id: typing.Optional[builtins.str] = None,
        sms_receivers: typing.Optional[typing.Sequence[typing.Union[_SmsReceiver_8bf8dc4d, typing.Dict[builtins.str, typing.Any]]]] = None,
        voice_receivers: typing.Optional[typing.Sequence[typing.Union[_VoiceReceiver_17e05799, typing.Dict[builtins.str, typing.Any]]]] = None,
        webhook_receivers: typing.Optional[typing.Sequence[typing.Union[_WebhookReceiver_fdbf2c51, typing.Dict[builtins.str, typing.Any]]]] = None,
        api_version: typing.Optional[builtins.str] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        location: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> None:
        '''Creates a new Azure Action Group using the AzapiResource framework.

        The constructor automatically handles version resolution, schema registration,
        validation, and resource creation.

        :param scope: - The scope in which to define this construct.
        :param id: - The unique identifier for this instance.
        :param group_short_name: Short name for SMS notifications (max 12 chars).
        :param azure_function_receivers: Azure Function receivers.
        :param email_receivers: Email notification receivers.
        :param enabled: Whether the action group is enabled. Default: true
        :param logic_app_receivers: Logic App receivers.
        :param resource_group_id: Resource group ID where the action group will be created.
        :param sms_receivers: SMS notification receivers.
        :param voice_receivers: Voice call receivers.
        :param webhook_receivers: Webhook notification receivers.
        :param api_version: Explicit API version to use for this resource. If not specified, the latest active version will be automatically resolved. Use this for version pinning when stability is required over latest features. Default: Latest active version from ApiVersionManager
        :param enable_migration_analysis: Whether to enable migration analysis warnings. When true, the framework will analyze the current version for deprecation status and provide migration recommendations in the deployment output. Default: true
        :param enable_transformation: Whether to apply property transformations automatically. When true, properties will be automatically transformed according to the target schema's transformation rules. This enables backward compatibility. Default: true
        :param enable_validation: Whether to validate properties against the schema. When true, all properties will be validated against the API schema before resource creation. Validation errors will cause deployment failures. Default: true
        :param location: The location where the resource should be created. Default: Varies by resource type - see specific resource documentation
        :param monitoring: Monitoring configuration for this resource. Enables integrated monitoring with diagnostic settings, metric alerts, and activity log alerts. All monitoring is optional and disabled by default.
        :param name: The name of the resource.
        :param tags: Tags to apply to the resource.
        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__249937df8388d0f3383cae5aaced42b029e907237e640c240dc9531e63bea72c)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = _ActionGroupProps_572d2b68(
            group_short_name=group_short_name,
            azure_function_receivers=azure_function_receivers,
            email_receivers=email_receivers,
            enabled=enabled,
            logic_app_receivers=logic_app_receivers,
            resource_group_id=resource_group_id,
            sms_receivers=sms_receivers,
            voice_receivers=voice_receivers,
            webhook_receivers=webhook_receivers,
            api_version=api_version,
            enable_migration_analysis=enable_migration_analysis,
            enable_transformation=enable_transformation,
            enable_validation=enable_validation,
            location=location,
            monitoring=monitoring,
            name=name,
            tags=tags,
            connection=connection,
            count=count,
            depends_on=depends_on,
            for_each=for_each,
            lifecycle=lifecycle,
            provider=provider,
            provisioners=provisioners,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="addTag")
    def add_tag(self, key: builtins.str, value: builtins.str) -> None:
        '''Add a tag to the Action Group Note: This modifies the construct props but requires a new deployment to take effect.

        :param key: -
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5d07dde9ff7d0e69ded5ecf9d92980ca44ec19064d24b030bf4ef482beb7bbab)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "addTag", [key, value]))

    @jsii.member(jsii_name="apiSchema")
    def _api_schema(self) -> _ApiSchema_5ce0490e:
        '''Gets the API schema for the resolved version Uses the framework's schema resolution to get the appropriate schema.'''
        return typing.cast(_ApiSchema_5ce0490e, jsii.invoke(self, "apiSchema", []))

    @jsii.member(jsii_name="createResourceBody")
    def _create_resource_body(self, props: typing.Any) -> typing.Any:
        '''Creates the resource body for the Azure API call Transforms the input properties into the JSON format expected by Azure REST API.

        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1406ce58f83af730c81e74b0ae6da9e4f63d6a8bd43c115bbdaea458cd69f33b)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Any, jsii.invoke(self, "createResourceBody", [props]))

    @jsii.member(jsii_name="defaultVersion")
    def _default_version(self) -> builtins.str:
        '''Gets the default API version to use when no explicit version is specified Returns the most recent stable version as the default.'''
        return typing.cast(builtins.str, jsii.invoke(self, "defaultVersion", []))

    @jsii.member(jsii_name="removeTag")
    def remove_tag(self, key: builtins.str) -> None:
        '''Remove a tag from the Action Group Note: This modifies the construct props but requires a new deployment to take effect.

        :param key: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__667549f3eb2f0a685123920033149c0647dbe958ddadb2116fefb236c813559b)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
        return typing.cast(None, jsii.invoke(self, "removeTag", [key]))

    @jsii.member(jsii_name="resourceType")
    def _resource_type(self) -> builtins.str:
        '''Gets the Azure resource type for Action Groups.'''
        return typing.cast(builtins.str, jsii.invoke(self, "resourceType", []))

    @builtins.property
    @jsii.member(jsii_name="idOutput")
    def id_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "idOutput"))

    @builtins.property
    @jsii.member(jsii_name="nameOutput")
    def name_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "nameOutput"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def props(self) -> _ActionGroupProps_572d2b68:
        '''The input properties for this Action Group instance.'''
        return typing.cast(_ActionGroupProps_572d2b68, jsii.get(self, "props"))


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.ActionGroupBody",
    jsii_struct_bases=[],
    name_mapping={"location": "location", "properties": "properties", "tags": "tags"},
)
class ActionGroupBody:
    def __init__(
        self,
        *,
        location: builtins.str,
        properties: typing.Union[_ActionGroupBodyProperties_73f4a4cb, typing.Dict[builtins.str, typing.Any]],
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''The resource body interface for Azure Action Group API calls.

        :param location: 
        :param properties: 
        :param tags: 
        '''
        if isinstance(properties, dict):
            properties = _ActionGroupBodyProperties_73f4a4cb(**properties)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1d1250349f995235808b9dc59ea485a519402582d11eb9f947ec422ec1d693e2)
            check_type(argname="argument location", value=location, expected_type=type_hints["location"])
            check_type(argname="argument properties", value=properties, expected_type=type_hints["properties"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "location": location,
            "properties": properties,
        }
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def location(self) -> builtins.str:
        result = self._values.get("location")
        assert result is not None, "Required property 'location' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def properties(self) -> _ActionGroupBodyProperties_73f4a4cb:
        result = self._values.get("properties")
        assert result is not None, "Required property 'properties' is missing"
        return typing.cast(_ActionGroupBodyProperties_73f4a4cb, result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ActionGroupBody(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.ActionGroupBodyProperties",
    jsii_struct_bases=[],
    name_mapping={
        "enabled": "enabled",
        "group_short_name": "groupShortName",
        "azure_function_receivers": "azureFunctionReceivers",
        "email_receivers": "emailReceivers",
        "logic_app_receivers": "logicAppReceivers",
        "sms_receivers": "smsReceivers",
        "voice_receivers": "voiceReceivers",
        "webhook_receivers": "webhookReceivers",
    },
)
class ActionGroupBodyProperties:
    def __init__(
        self,
        *,
        enabled: builtins.bool,
        group_short_name: builtins.str,
        azure_function_receivers: typing.Optional[typing.Sequence[typing.Union[_AzureFunctionReceiver_dfacaeac, typing.Dict[builtins.str, typing.Any]]]] = None,
        email_receivers: typing.Optional[typing.Sequence[typing.Union[_EmailReceiver_32579ca3, typing.Dict[builtins.str, typing.Any]]]] = None,
        logic_app_receivers: typing.Optional[typing.Sequence[typing.Union[_LogicAppReceiver_bcf80983, typing.Dict[builtins.str, typing.Any]]]] = None,
        sms_receivers: typing.Optional[typing.Sequence[typing.Union[_SmsReceiver_8bf8dc4d, typing.Dict[builtins.str, typing.Any]]]] = None,
        voice_receivers: typing.Optional[typing.Sequence[typing.Union[_VoiceReceiver_17e05799, typing.Dict[builtins.str, typing.Any]]]] = None,
        webhook_receivers: typing.Optional[typing.Sequence[typing.Union[_WebhookReceiver_fdbf2c51, typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Action Group properties for the request body.

        :param enabled: 
        :param group_short_name: 
        :param azure_function_receivers: 
        :param email_receivers: 
        :param logic_app_receivers: 
        :param sms_receivers: 
        :param voice_receivers: 
        :param webhook_receivers: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1087478ac591cb32806ce7240269443763f0aa8b24d653f0a31beb856521142f)
            check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
            check_type(argname="argument group_short_name", value=group_short_name, expected_type=type_hints["group_short_name"])
            check_type(argname="argument azure_function_receivers", value=azure_function_receivers, expected_type=type_hints["azure_function_receivers"])
            check_type(argname="argument email_receivers", value=email_receivers, expected_type=type_hints["email_receivers"])
            check_type(argname="argument logic_app_receivers", value=logic_app_receivers, expected_type=type_hints["logic_app_receivers"])
            check_type(argname="argument sms_receivers", value=sms_receivers, expected_type=type_hints["sms_receivers"])
            check_type(argname="argument voice_receivers", value=voice_receivers, expected_type=type_hints["voice_receivers"])
            check_type(argname="argument webhook_receivers", value=webhook_receivers, expected_type=type_hints["webhook_receivers"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "enabled": enabled,
            "group_short_name": group_short_name,
        }
        if azure_function_receivers is not None:
            self._values["azure_function_receivers"] = azure_function_receivers
        if email_receivers is not None:
            self._values["email_receivers"] = email_receivers
        if logic_app_receivers is not None:
            self._values["logic_app_receivers"] = logic_app_receivers
        if sms_receivers is not None:
            self._values["sms_receivers"] = sms_receivers
        if voice_receivers is not None:
            self._values["voice_receivers"] = voice_receivers
        if webhook_receivers is not None:
            self._values["webhook_receivers"] = webhook_receivers

    @builtins.property
    def enabled(self) -> builtins.bool:
        result = self._values.get("enabled")
        assert result is not None, "Required property 'enabled' is missing"
        return typing.cast(builtins.bool, result)

    @builtins.property
    def group_short_name(self) -> builtins.str:
        result = self._values.get("group_short_name")
        assert result is not None, "Required property 'group_short_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def azure_function_receivers(
        self,
    ) -> typing.Optional[typing.List[_AzureFunctionReceiver_dfacaeac]]:
        result = self._values.get("azure_function_receivers")
        return typing.cast(typing.Optional[typing.List[_AzureFunctionReceiver_dfacaeac]], result)

    @builtins.property
    def email_receivers(self) -> typing.Optional[typing.List[_EmailReceiver_32579ca3]]:
        result = self._values.get("email_receivers")
        return typing.cast(typing.Optional[typing.List[_EmailReceiver_32579ca3]], result)

    @builtins.property
    def logic_app_receivers(
        self,
    ) -> typing.Optional[typing.List[_LogicAppReceiver_bcf80983]]:
        result = self._values.get("logic_app_receivers")
        return typing.cast(typing.Optional[typing.List[_LogicAppReceiver_bcf80983]], result)

    @builtins.property
    def sms_receivers(self) -> typing.Optional[typing.List[_SmsReceiver_8bf8dc4d]]:
        result = self._values.get("sms_receivers")
        return typing.cast(typing.Optional[typing.List[_SmsReceiver_8bf8dc4d]], result)

    @builtins.property
    def voice_receivers(self) -> typing.Optional[typing.List[_VoiceReceiver_17e05799]]:
        result = self._values.get("voice_receivers")
        return typing.cast(typing.Optional[typing.List[_VoiceReceiver_17e05799]], result)

    @builtins.property
    def webhook_receivers(
        self,
    ) -> typing.Optional[typing.List[_WebhookReceiver_fdbf2c51]]:
        result = self._values.get("webhook_receivers")
        return typing.cast(typing.Optional[typing.List[_WebhookReceiver_fdbf2c51]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ActionGroupBodyProperties(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.ActionGroupProps",
    jsii_struct_bases=[_AzapiResourceProps_141a2340],
    name_mapping={
        "connection": "connection",
        "count": "count",
        "depends_on": "dependsOn",
        "for_each": "forEach",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "provisioners": "provisioners",
        "api_version": "apiVersion",
        "enable_migration_analysis": "enableMigrationAnalysis",
        "enable_transformation": "enableTransformation",
        "enable_validation": "enableValidation",
        "location": "location",
        "monitoring": "monitoring",
        "name": "name",
        "tags": "tags",
        "group_short_name": "groupShortName",
        "azure_function_receivers": "azureFunctionReceivers",
        "email_receivers": "emailReceivers",
        "enabled": "enabled",
        "logic_app_receivers": "logicAppReceivers",
        "resource_group_id": "resourceGroupId",
        "sms_receivers": "smsReceivers",
        "voice_receivers": "voiceReceivers",
        "webhook_receivers": "webhookReceivers",
    },
)
class ActionGroupProps(_AzapiResourceProps_141a2340):
    def __init__(
        self,
        *,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
        api_version: typing.Optional[builtins.str] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        location: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        group_short_name: builtins.str,
        azure_function_receivers: typing.Optional[typing.Sequence[typing.Union[_AzureFunctionReceiver_dfacaeac, typing.Dict[builtins.str, typing.Any]]]] = None,
        email_receivers: typing.Optional[typing.Sequence[typing.Union[_EmailReceiver_32579ca3, typing.Dict[builtins.str, typing.Any]]]] = None,
        enabled: typing.Optional[builtins.bool] = None,
        logic_app_receivers: typing.Optional[typing.Sequence[typing.Union[_LogicAppReceiver_bcf80983, typing.Dict[builtins.str, typing.Any]]]] = None,
        resource_group_id: typing.Optional[builtins.str] = None,
        sms_receivers: typing.Optional[typing.Sequence[typing.Union[_SmsReceiver_8bf8dc4d, typing.Dict[builtins.str, typing.Any]]]] = None,
        voice_receivers: typing.Optional[typing.Sequence[typing.Union[_VoiceReceiver_17e05799, typing.Dict[builtins.str, typing.Any]]]] = None,
        webhook_receivers: typing.Optional[typing.Sequence[typing.Union[_WebhookReceiver_fdbf2c51, typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Properties for the unified Azure Action Group.

        Extends AzapiResourceProps with Action Group specific properties

        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        :param api_version: Explicit API version to use for this resource. If not specified, the latest active version will be automatically resolved. Use this for version pinning when stability is required over latest features. Default: Latest active version from ApiVersionManager
        :param enable_migration_analysis: Whether to enable migration analysis warnings. When true, the framework will analyze the current version for deprecation status and provide migration recommendations in the deployment output. Default: true
        :param enable_transformation: Whether to apply property transformations automatically. When true, properties will be automatically transformed according to the target schema's transformation rules. This enables backward compatibility. Default: true
        :param enable_validation: Whether to validate properties against the schema. When true, all properties will be validated against the API schema before resource creation. Validation errors will cause deployment failures. Default: true
        :param location: The location where the resource should be created. Default: Varies by resource type - see specific resource documentation
        :param monitoring: Monitoring configuration for this resource. Enables integrated monitoring with diagnostic settings, metric alerts, and activity log alerts. All monitoring is optional and disabled by default.
        :param name: The name of the resource.
        :param tags: Tags to apply to the resource.
        :param group_short_name: Short name for SMS notifications (max 12 chars).
        :param azure_function_receivers: Azure Function receivers.
        :param email_receivers: Email notification receivers.
        :param enabled: Whether the action group is enabled. Default: true
        :param logic_app_receivers: Logic App receivers.
        :param resource_group_id: Resource group ID where the action group will be created.
        :param sms_receivers: SMS notification receivers.
        :param voice_receivers: Voice call receivers.
        :param webhook_receivers: Webhook notification receivers.
        '''
        if isinstance(lifecycle, dict):
            lifecycle = _cdktf_9a9027ec.TerraformResourceLifecycle(**lifecycle)
        if isinstance(monitoring, dict):
            monitoring = _MonitoringConfig_7c28df74(**monitoring)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bc6ad9d7acb5e9615808f8eb1ccdfb802c1f5a0f463e890828b905f9ed033d11)
            check_type(argname="argument connection", value=connection, expected_type=type_hints["connection"])
            check_type(argname="argument count", value=count, expected_type=type_hints["count"])
            check_type(argname="argument depends_on", value=depends_on, expected_type=type_hints["depends_on"])
            check_type(argname="argument for_each", value=for_each, expected_type=type_hints["for_each"])
            check_type(argname="argument lifecycle", value=lifecycle, expected_type=type_hints["lifecycle"])
            check_type(argname="argument provider", value=provider, expected_type=type_hints["provider"])
            check_type(argname="argument provisioners", value=provisioners, expected_type=type_hints["provisioners"])
            check_type(argname="argument api_version", value=api_version, expected_type=type_hints["api_version"])
            check_type(argname="argument enable_migration_analysis", value=enable_migration_analysis, expected_type=type_hints["enable_migration_analysis"])
            check_type(argname="argument enable_transformation", value=enable_transformation, expected_type=type_hints["enable_transformation"])
            check_type(argname="argument enable_validation", value=enable_validation, expected_type=type_hints["enable_validation"])
            check_type(argname="argument location", value=location, expected_type=type_hints["location"])
            check_type(argname="argument monitoring", value=monitoring, expected_type=type_hints["monitoring"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument group_short_name", value=group_short_name, expected_type=type_hints["group_short_name"])
            check_type(argname="argument azure_function_receivers", value=azure_function_receivers, expected_type=type_hints["azure_function_receivers"])
            check_type(argname="argument email_receivers", value=email_receivers, expected_type=type_hints["email_receivers"])
            check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
            check_type(argname="argument logic_app_receivers", value=logic_app_receivers, expected_type=type_hints["logic_app_receivers"])
            check_type(argname="argument resource_group_id", value=resource_group_id, expected_type=type_hints["resource_group_id"])
            check_type(argname="argument sms_receivers", value=sms_receivers, expected_type=type_hints["sms_receivers"])
            check_type(argname="argument voice_receivers", value=voice_receivers, expected_type=type_hints["voice_receivers"])
            check_type(argname="argument webhook_receivers", value=webhook_receivers, expected_type=type_hints["webhook_receivers"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "group_short_name": group_short_name,
        }
        if connection is not None:
            self._values["connection"] = connection
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if for_each is not None:
            self._values["for_each"] = for_each
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider
        if provisioners is not None:
            self._values["provisioners"] = provisioners
        if api_version is not None:
            self._values["api_version"] = api_version
        if enable_migration_analysis is not None:
            self._values["enable_migration_analysis"] = enable_migration_analysis
        if enable_transformation is not None:
            self._values["enable_transformation"] = enable_transformation
        if enable_validation is not None:
            self._values["enable_validation"] = enable_validation
        if location is not None:
            self._values["location"] = location
        if monitoring is not None:
            self._values["monitoring"] = monitoring
        if name is not None:
            self._values["name"] = name
        if tags is not None:
            self._values["tags"] = tags
        if azure_function_receivers is not None:
            self._values["azure_function_receivers"] = azure_function_receivers
        if email_receivers is not None:
            self._values["email_receivers"] = email_receivers
        if enabled is not None:
            self._values["enabled"] = enabled
        if logic_app_receivers is not None:
            self._values["logic_app_receivers"] = logic_app_receivers
        if resource_group_id is not None:
            self._values["resource_group_id"] = resource_group_id
        if sms_receivers is not None:
            self._values["sms_receivers"] = sms_receivers
        if voice_receivers is not None:
            self._values["voice_receivers"] = voice_receivers
        if webhook_receivers is not None:
            self._values["webhook_receivers"] = webhook_receivers

    @builtins.property
    def connection(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("connection")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]], result)

    @builtins.property
    def count(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]], result)

    @builtins.property
    def depends_on(
        self,
    ) -> typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]], result)

    @builtins.property
    def for_each(self) -> typing.Optional[_cdktf_9a9027ec.ITerraformIterator]:
        '''
        :stability: experimental
        '''
        result = self._values.get("for_each")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.ITerraformIterator], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[_cdktf_9a9027ec.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformProvider], result)

    @builtins.property
    def provisioners(
        self,
    ) -> typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provisioners")
        return typing.cast(typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]], result)

    @builtins.property
    def api_version(self) -> typing.Optional[builtins.str]:
        '''Explicit API version to use for this resource.

        If not specified, the latest active version will be automatically resolved.
        Use this for version pinning when stability is required over latest features.

        :default: Latest active version from ApiVersionManager

        Example::

            "2024-11-01"
        '''
        result = self._values.get("api_version")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def enable_migration_analysis(self) -> typing.Optional[builtins.bool]:
        '''Whether to enable migration analysis warnings.

        When true, the framework will analyze the current version for deprecation
        status and provide migration recommendations in the deployment output.

        :default: true
        '''
        result = self._values.get("enable_migration_analysis")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_transformation(self) -> typing.Optional[builtins.bool]:
        '''Whether to apply property transformations automatically.

        When true, properties will be automatically transformed according to the
        target schema's transformation rules. This enables backward compatibility.

        :default: true
        '''
        result = self._values.get("enable_transformation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_validation(self) -> typing.Optional[builtins.bool]:
        '''Whether to validate properties against the schema.

        When true, all properties will be validated against the API schema before
        resource creation. Validation errors will cause deployment failures.

        :default: true
        '''
        result = self._values.get("enable_validation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def location(self) -> typing.Optional[builtins.str]:
        '''The location where the resource should be created.

        :default: Varies by resource type - see specific resource documentation

        :remarks:

        Location handling varies by resource type:

        - **Top-level resources**: Most require an explicit location (e.g., "eastus", "westus")
        - **Global resources**: Some use "global" as location (e.g., Private DNS Zones)
        - **Child resources**: Inherit location from parent and should NOT set this property

        Each resource type may provide its own default through the ``resolveLocation()`` method.
        If no location is specified and no default exists, resource creation may fail.

        Example::

            // Child resource (Subnet) - do not set location
            // location: undefined (inherited from parent Virtual Network)
        '''
        result = self._values.get("location")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def monitoring(self) -> typing.Optional[_MonitoringConfig_7c28df74]:
        '''Monitoring configuration for this resource.

        Enables integrated monitoring with diagnostic settings, metric alerts,
        and activity log alerts. All monitoring is optional and disabled by default.

        Example::

            monitoring: {
              enabled: true,
              diagnosticSettings: {
                workspaceId: logAnalytics.id,
                metrics: ['AllMetrics'],
                logs: ['AuditLogs']
              },
              metricAlerts: [{
                name: 'high-cpu-alert',
                severity: 2,
                scopes: [], // Automatically set to this resource
                criteria: { ... },
                actions: [{ actionGroupId: actionGroup.id }]
              }]
            }
        '''
        result = self._values.get("monitoring")
        return typing.cast(typing.Optional[_MonitoringConfig_7c28df74], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the resource.'''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Tags to apply to the resource.'''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def group_short_name(self) -> builtins.str:
        '''Short name for SMS notifications (max 12 chars).

        Example::

            "OpsTeam"
        '''
        result = self._values.get("group_short_name")
        assert result is not None, "Required property 'group_short_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def azure_function_receivers(
        self,
    ) -> typing.Optional[typing.List[_AzureFunctionReceiver_dfacaeac]]:
        '''Azure Function receivers.'''
        result = self._values.get("azure_function_receivers")
        return typing.cast(typing.Optional[typing.List[_AzureFunctionReceiver_dfacaeac]], result)

    @builtins.property
    def email_receivers(self) -> typing.Optional[typing.List[_EmailReceiver_32579ca3]]:
        '''Email notification receivers.'''
        result = self._values.get("email_receivers")
        return typing.cast(typing.Optional[typing.List[_EmailReceiver_32579ca3]], result)

    @builtins.property
    def enabled(self) -> typing.Optional[builtins.bool]:
        '''Whether the action group is enabled.

        :default: true
        '''
        result = self._values.get("enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def logic_app_receivers(
        self,
    ) -> typing.Optional[typing.List[_LogicAppReceiver_bcf80983]]:
        '''Logic App receivers.'''
        result = self._values.get("logic_app_receivers")
        return typing.cast(typing.Optional[typing.List[_LogicAppReceiver_bcf80983]], result)

    @builtins.property
    def resource_group_id(self) -> typing.Optional[builtins.str]:
        '''Resource group ID where the action group will be created.'''
        result = self._values.get("resource_group_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def sms_receivers(self) -> typing.Optional[typing.List[_SmsReceiver_8bf8dc4d]]:
        '''SMS notification receivers.'''
        result = self._values.get("sms_receivers")
        return typing.cast(typing.Optional[typing.List[_SmsReceiver_8bf8dc4d]], result)

    @builtins.property
    def voice_receivers(self) -> typing.Optional[typing.List[_VoiceReceiver_17e05799]]:
        '''Voice call receivers.'''
        result = self._values.get("voice_receivers")
        return typing.cast(typing.Optional[typing.List[_VoiceReceiver_17e05799]], result)

    @builtins.property
    def webhook_receivers(
        self,
    ) -> typing.Optional[typing.List[_WebhookReceiver_fdbf2c51]]:
        '''Webhook notification receivers.'''
        result = self._values.get("webhook_receivers")
        return typing.cast(typing.Optional[typing.List[_WebhookReceiver_fdbf2c51]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ActionGroupProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ActivityLogAlert(
    _AzapiResource_7e7f5b39,
    metaclass=jsii.JSIIMeta,
    jsii_type="@microsoft/terraform-cdk-constructs.ActivityLogAlert",
):
    '''Unified Azure Activity Log Alert implementation.

    This class provides a single, version-aware implementation that automatically handles version
    resolution, schema validation, and property transformation while maintaining full JSII compliance.

    Activity Log Alerts monitor Azure Activity Log events and trigger notifications when specific
    operations occur, such as resource deletions, configuration changes, or service health events.

    Example::

        // Alert on service health events:
        const serviceHealthAlert = new ActivityLogAlert(this, "service-health", {
          name: "service-health-alert",
          description: "Alert on Azure service health events",
          resourceGroupId: resourceGroup.id,
          scopes: ["/subscriptions/00000000-0000-0000-0000-000000000000"],
          condition: {
            allOf: [
              { field: "category", equalsValue: "ServiceHealth" },
              { field: "properties.incidentType", equalsValue: "Incident" }
            ]
          },
          actions: {
            actionGroups: [{
              actionGroupId: actionGroup.id,
              webhookProperties: {
                severity: "critical"
              }
            }]
          }
        });
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        condition: typing.Union[_ActivityLogAlertCondition_dfb706a4, typing.Dict[builtins.str, typing.Any]],
        scopes: typing.Sequence[builtins.str],
        actions: typing.Optional[typing.Union[_ActivityLogAlertActions_efbd1a87, typing.Dict[builtins.str, typing.Any]]] = None,
        description: typing.Optional[builtins.str] = None,
        enabled: typing.Optional[builtins.bool] = None,
        resource_group_id: typing.Optional[builtins.str] = None,
        api_version: typing.Optional[builtins.str] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        location: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> None:
        '''Creates a new Azure Activity Log Alert using the AzapiResource framework.

        The constructor automatically handles version resolution, schema registration,
        validation, and resource creation.

        :param scope: - The scope in which to define this construct.
        :param id: - The unique identifier for this instance.
        :param condition: Alert condition with field-value pairs All conditions are combined with AND logic.
        :param scopes: Resource IDs that this alert is scoped to Can be subscription, resource group, or specific resource IDs.
        :param actions: Action groups to notify.
        :param description: Description of the alert rule.
        :param enabled: Whether the alert rule is enabled. Default: true
        :param resource_group_id: Resource group ID where the activity log alert will be created.
        :param api_version: Explicit API version to use for this resource. If not specified, the latest active version will be automatically resolved. Use this for version pinning when stability is required over latest features. Default: Latest active version from ApiVersionManager
        :param enable_migration_analysis: Whether to enable migration analysis warnings. When true, the framework will analyze the current version for deprecation status and provide migration recommendations in the deployment output. Default: true
        :param enable_transformation: Whether to apply property transformations automatically. When true, properties will be automatically transformed according to the target schema's transformation rules. This enables backward compatibility. Default: true
        :param enable_validation: Whether to validate properties against the schema. When true, all properties will be validated against the API schema before resource creation. Validation errors will cause deployment failures. Default: true
        :param location: The location where the resource should be created. Default: Varies by resource type - see specific resource documentation
        :param monitoring: Monitoring configuration for this resource. Enables integrated monitoring with diagnostic settings, metric alerts, and activity log alerts. All monitoring is optional and disabled by default.
        :param name: The name of the resource.
        :param tags: Tags to apply to the resource.
        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3bb8f46d40f436e312e40ef0125cffd24ad8fbf161aaedc30c69d58499255c98)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = _ActivityLogAlertProps_f1779054(
            condition=condition,
            scopes=scopes,
            actions=actions,
            description=description,
            enabled=enabled,
            resource_group_id=resource_group_id,
            api_version=api_version,
            enable_migration_analysis=enable_migration_analysis,
            enable_transformation=enable_transformation,
            enable_validation=enable_validation,
            location=location,
            monitoring=monitoring,
            name=name,
            tags=tags,
            connection=connection,
            count=count,
            depends_on=depends_on,
            for_each=for_each,
            lifecycle=lifecycle,
            provider=provider,
            provisioners=provisioners,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="addTag")
    def add_tag(self, key: builtins.str, value: builtins.str) -> None:
        '''Add a tag to the Activity Log Alert Note: This modifies the construct props but requires a new deployment to take effect.

        :param key: -
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f0410b149c4327db9619c6a629a6cc812d7450c8e909239c527d8ba4faebcf62)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "addTag", [key, value]))

    @jsii.member(jsii_name="apiSchema")
    def _api_schema(self) -> _ApiSchema_5ce0490e:
        '''Gets the API schema for the resolved version Uses the framework's schema resolution to get the appropriate schema.'''
        return typing.cast(_ApiSchema_5ce0490e, jsii.invoke(self, "apiSchema", []))

    @jsii.member(jsii_name="createResourceBody")
    def _create_resource_body(self, props: typing.Any) -> typing.Any:
        '''Creates the resource body for the Azure API call Transforms the input properties into the JSON format expected by Azure REST API.

        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1f74bd619a63fb28dbe8fd5986da981a8861217daf67d3a8307446c8a0ff382d)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Any, jsii.invoke(self, "createResourceBody", [props]))

    @jsii.member(jsii_name="defaultVersion")
    def _default_version(self) -> builtins.str:
        '''Gets the default API version to use when no explicit version is specified Returns the most recent stable version as the default.'''
        return typing.cast(builtins.str, jsii.invoke(self, "defaultVersion", []))

    @jsii.member(jsii_name="removeTag")
    def remove_tag(self, key: builtins.str) -> None:
        '''Remove a tag from the Activity Log Alert Note: This modifies the construct props but requires a new deployment to take effect.

        :param key: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ade89bb9fbbf06aca46dcdb9e99f618cc5f8598104ee9684b27a9eaaf01d4aff)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
        return typing.cast(None, jsii.invoke(self, "removeTag", [key]))

    @jsii.member(jsii_name="resourceType")
    def _resource_type(self) -> builtins.str:
        '''Gets the Azure resource type for Activity Log Alerts.'''
        return typing.cast(builtins.str, jsii.invoke(self, "resourceType", []))

    @builtins.property
    @jsii.member(jsii_name="idOutput")
    def id_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "idOutput"))

    @builtins.property
    @jsii.member(jsii_name="nameOutput")
    def name_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "nameOutput"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def props(self) -> _ActivityLogAlertProps_f1779054:
        '''The input properties for this Activity Log Alert instance.'''
        return typing.cast(_ActivityLogAlertProps_f1779054, jsii.get(self, "props"))


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.ActivityLogAlertActionGroup",
    jsii_struct_bases=[],
    name_mapping={
        "action_group_id": "actionGroupId",
        "webhook_properties": "webhookProperties",
    },
)
class ActivityLogAlertActionGroup:
    def __init__(
        self,
        *,
        action_group_id: builtins.str,
        webhook_properties: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''Activity log alert action group reference.

        :param action_group_id: The action group resource ID.
        :param webhook_properties: Webhook properties (optional).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a01a232e09eb7a38d3d3a28f0b418510ae7f13f1b6f01394c9070ed8101e3455)
            check_type(argname="argument action_group_id", value=action_group_id, expected_type=type_hints["action_group_id"])
            check_type(argname="argument webhook_properties", value=webhook_properties, expected_type=type_hints["webhook_properties"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "action_group_id": action_group_id,
        }
        if webhook_properties is not None:
            self._values["webhook_properties"] = webhook_properties

    @builtins.property
    def action_group_id(self) -> builtins.str:
        '''The action group resource ID.'''
        result = self._values.get("action_group_id")
        assert result is not None, "Required property 'action_group_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def webhook_properties(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Webhook properties (optional).'''
        result = self._values.get("webhook_properties")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ActivityLogAlertActionGroup(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.ActivityLogAlertActions",
    jsii_struct_bases=[],
    name_mapping={"action_groups": "actionGroups"},
)
class ActivityLogAlertActions:
    def __init__(
        self,
        *,
        action_groups: typing.Optional[typing.Sequence[typing.Union[_ActivityLogAlertActionGroup_7db22b2a, typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Activity log alert actions configuration.

        :param action_groups: Action groups to trigger.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f58bbd3ea50947d39bf236958069c1af6c99a6cf9043a563b09fa3c020e21d71)
            check_type(argname="argument action_groups", value=action_groups, expected_type=type_hints["action_groups"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if action_groups is not None:
            self._values["action_groups"] = action_groups

    @builtins.property
    def action_groups(
        self,
    ) -> typing.Optional[typing.List[_ActivityLogAlertActionGroup_7db22b2a]]:
        '''Action groups to trigger.'''
        result = self._values.get("action_groups")
        return typing.cast(typing.Optional[typing.List[_ActivityLogAlertActionGroup_7db22b2a]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ActivityLogAlertActions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.ActivityLogAlertBody",
    jsii_struct_bases=[],
    name_mapping={"location": "location", "properties": "properties", "tags": "tags"},
)
class ActivityLogAlertBody:
    def __init__(
        self,
        *,
        location: builtins.str,
        properties: typing.Union[_ActivityLogAlertBodyProperties_652af2f5, typing.Dict[builtins.str, typing.Any]],
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''The resource body interface for Azure Activity Log Alert API calls.

        :param location: 
        :param properties: 
        :param tags: 
        '''
        if isinstance(properties, dict):
            properties = _ActivityLogAlertBodyProperties_652af2f5(**properties)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d6bb4f8b0989e5a12d5fa7dd7c010098640e9ca3201e1eb16360f6ee582e6cfe)
            check_type(argname="argument location", value=location, expected_type=type_hints["location"])
            check_type(argname="argument properties", value=properties, expected_type=type_hints["properties"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "location": location,
            "properties": properties,
        }
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def location(self) -> builtins.str:
        result = self._values.get("location")
        assert result is not None, "Required property 'location' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def properties(self) -> _ActivityLogAlertBodyProperties_652af2f5:
        result = self._values.get("properties")
        assert result is not None, "Required property 'properties' is missing"
        return typing.cast(_ActivityLogAlertBodyProperties_652af2f5, result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ActivityLogAlertBody(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.ActivityLogAlertBodyProperties",
    jsii_struct_bases=[],
    name_mapping={
        "condition": "condition",
        "enabled": "enabled",
        "scopes": "scopes",
        "actions": "actions",
        "description": "description",
    },
)
class ActivityLogAlertBodyProperties:
    def __init__(
        self,
        *,
        condition: typing.Union[_ActivityLogAlertCondition_dfb706a4, typing.Dict[builtins.str, typing.Any]],
        enabled: builtins.bool,
        scopes: typing.Sequence[builtins.str],
        actions: typing.Optional[typing.Union[_ActivityLogAlertActions_efbd1a87, typing.Dict[builtins.str, typing.Any]]] = None,
        description: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Activity Log Alert properties for the request body.

        :param condition: 
        :param enabled: 
        :param scopes: 
        :param actions: 
        :param description: 
        '''
        if isinstance(condition, dict):
            condition = _ActivityLogAlertCondition_dfb706a4(**condition)
        if isinstance(actions, dict):
            actions = _ActivityLogAlertActions_efbd1a87(**actions)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__52b543ddc96263d647e85abbca37acc72dbf371bb42995e507b16a01b3306541)
            check_type(argname="argument condition", value=condition, expected_type=type_hints["condition"])
            check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
            check_type(argname="argument scopes", value=scopes, expected_type=type_hints["scopes"])
            check_type(argname="argument actions", value=actions, expected_type=type_hints["actions"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "condition": condition,
            "enabled": enabled,
            "scopes": scopes,
        }
        if actions is not None:
            self._values["actions"] = actions
        if description is not None:
            self._values["description"] = description

    @builtins.property
    def condition(self) -> _ActivityLogAlertCondition_dfb706a4:
        result = self._values.get("condition")
        assert result is not None, "Required property 'condition' is missing"
        return typing.cast(_ActivityLogAlertCondition_dfb706a4, result)

    @builtins.property
    def enabled(self) -> builtins.bool:
        result = self._values.get("enabled")
        assert result is not None, "Required property 'enabled' is missing"
        return typing.cast(builtins.bool, result)

    @builtins.property
    def scopes(self) -> typing.List[builtins.str]:
        result = self._values.get("scopes")
        assert result is not None, "Required property 'scopes' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def actions(self) -> typing.Optional[_ActivityLogAlertActions_efbd1a87]:
        result = self._values.get("actions")
        return typing.cast(typing.Optional[_ActivityLogAlertActions_efbd1a87], result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ActivityLogAlertBodyProperties(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.ActivityLogAlertCondition",
    jsii_struct_bases=[],
    name_mapping={"all_of": "allOf"},
)
class ActivityLogAlertCondition:
    def __init__(
        self,
        *,
        all_of: typing.Sequence[typing.Union[_ActivityLogAlertLeafCondition_3bceda39, typing.Dict[builtins.str, typing.Any]]],
    ) -> None:
        '''Activity log alert condition.

        :param all_of: All conditions that must be met (AND logic).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cb94868f108b893ba16e051709509d6ce15c0b2ef7e633a4bfdb80856920b8f5)
            check_type(argname="argument all_of", value=all_of, expected_type=type_hints["all_of"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "all_of": all_of,
        }

    @builtins.property
    def all_of(self) -> typing.List[_ActivityLogAlertLeafCondition_3bceda39]:
        '''All conditions that must be met (AND logic).'''
        result = self._values.get("all_of")
        assert result is not None, "Required property 'all_of' is missing"
        return typing.cast(typing.List[_ActivityLogAlertLeafCondition_3bceda39], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ActivityLogAlertCondition(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.ActivityLogAlertLeafCondition",
    jsii_struct_bases=[],
    name_mapping={"equals_value": "equalsValue", "field": "field"},
)
class ActivityLogAlertLeafCondition:
    def __init__(self, *, equals_value: builtins.str, field: builtins.str) -> None:
        '''Activity log alert leaf condition.

        :param equals_value: The value to match.
        :param field: The field name to filter on Common values: category, operationName, resourceType, status, subStatus, resourceGroup.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__92db1924b1ffb3e3d5bd8b50c24344162cff6edd637dce2ae736c361fda9559e)
            check_type(argname="argument equals_value", value=equals_value, expected_type=type_hints["equals_value"])
            check_type(argname="argument field", value=field, expected_type=type_hints["field"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "equals_value": equals_value,
            "field": field,
        }

    @builtins.property
    def equals_value(self) -> builtins.str:
        '''The value to match.'''
        result = self._values.get("equals_value")
        assert result is not None, "Required property 'equals_value' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def field(self) -> builtins.str:
        '''The field name to filter on Common values: category, operationName, resourceType, status, subStatus, resourceGroup.'''
        result = self._values.get("field")
        assert result is not None, "Required property 'field' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ActivityLogAlertLeafCondition(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.ActivityLogAlertProps",
    jsii_struct_bases=[_AzapiResourceProps_141a2340],
    name_mapping={
        "connection": "connection",
        "count": "count",
        "depends_on": "dependsOn",
        "for_each": "forEach",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "provisioners": "provisioners",
        "api_version": "apiVersion",
        "enable_migration_analysis": "enableMigrationAnalysis",
        "enable_transformation": "enableTransformation",
        "enable_validation": "enableValidation",
        "location": "location",
        "monitoring": "monitoring",
        "name": "name",
        "tags": "tags",
        "condition": "condition",
        "scopes": "scopes",
        "actions": "actions",
        "description": "description",
        "enabled": "enabled",
        "resource_group_id": "resourceGroupId",
    },
)
class ActivityLogAlertProps(_AzapiResourceProps_141a2340):
    def __init__(
        self,
        *,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
        api_version: typing.Optional[builtins.str] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        location: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        condition: typing.Union[_ActivityLogAlertCondition_dfb706a4, typing.Dict[builtins.str, typing.Any]],
        scopes: typing.Sequence[builtins.str],
        actions: typing.Optional[typing.Union[_ActivityLogAlertActions_efbd1a87, typing.Dict[builtins.str, typing.Any]]] = None,
        description: typing.Optional[builtins.str] = None,
        enabled: typing.Optional[builtins.bool] = None,
        resource_group_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for the unified Azure Activity Log Alert.

        Extends AzapiResourceProps with Activity Log Alert specific properties

        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        :param api_version: Explicit API version to use for this resource. If not specified, the latest active version will be automatically resolved. Use this for version pinning when stability is required over latest features. Default: Latest active version from ApiVersionManager
        :param enable_migration_analysis: Whether to enable migration analysis warnings. When true, the framework will analyze the current version for deprecation status and provide migration recommendations in the deployment output. Default: true
        :param enable_transformation: Whether to apply property transformations automatically. When true, properties will be automatically transformed according to the target schema's transformation rules. This enables backward compatibility. Default: true
        :param enable_validation: Whether to validate properties against the schema. When true, all properties will be validated against the API schema before resource creation. Validation errors will cause deployment failures. Default: true
        :param location: The location where the resource should be created. Default: Varies by resource type - see specific resource documentation
        :param monitoring: Monitoring configuration for this resource. Enables integrated monitoring with diagnostic settings, metric alerts, and activity log alerts. All monitoring is optional and disabled by default.
        :param name: The name of the resource.
        :param tags: Tags to apply to the resource.
        :param condition: Alert condition with field-value pairs All conditions are combined with AND logic.
        :param scopes: Resource IDs that this alert is scoped to Can be subscription, resource group, or specific resource IDs.
        :param actions: Action groups to notify.
        :param description: Description of the alert rule.
        :param enabled: Whether the alert rule is enabled. Default: true
        :param resource_group_id: Resource group ID where the activity log alert will be created.
        '''
        if isinstance(lifecycle, dict):
            lifecycle = _cdktf_9a9027ec.TerraformResourceLifecycle(**lifecycle)
        if isinstance(monitoring, dict):
            monitoring = _MonitoringConfig_7c28df74(**monitoring)
        if isinstance(condition, dict):
            condition = _ActivityLogAlertCondition_dfb706a4(**condition)
        if isinstance(actions, dict):
            actions = _ActivityLogAlertActions_efbd1a87(**actions)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bbee578b252c14e639e21d81ba9e93309d8014338e2f9b57c88b22cbfe599dc2)
            check_type(argname="argument connection", value=connection, expected_type=type_hints["connection"])
            check_type(argname="argument count", value=count, expected_type=type_hints["count"])
            check_type(argname="argument depends_on", value=depends_on, expected_type=type_hints["depends_on"])
            check_type(argname="argument for_each", value=for_each, expected_type=type_hints["for_each"])
            check_type(argname="argument lifecycle", value=lifecycle, expected_type=type_hints["lifecycle"])
            check_type(argname="argument provider", value=provider, expected_type=type_hints["provider"])
            check_type(argname="argument provisioners", value=provisioners, expected_type=type_hints["provisioners"])
            check_type(argname="argument api_version", value=api_version, expected_type=type_hints["api_version"])
            check_type(argname="argument enable_migration_analysis", value=enable_migration_analysis, expected_type=type_hints["enable_migration_analysis"])
            check_type(argname="argument enable_transformation", value=enable_transformation, expected_type=type_hints["enable_transformation"])
            check_type(argname="argument enable_validation", value=enable_validation, expected_type=type_hints["enable_validation"])
            check_type(argname="argument location", value=location, expected_type=type_hints["location"])
            check_type(argname="argument monitoring", value=monitoring, expected_type=type_hints["monitoring"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument condition", value=condition, expected_type=type_hints["condition"])
            check_type(argname="argument scopes", value=scopes, expected_type=type_hints["scopes"])
            check_type(argname="argument actions", value=actions, expected_type=type_hints["actions"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
            check_type(argname="argument resource_group_id", value=resource_group_id, expected_type=type_hints["resource_group_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "condition": condition,
            "scopes": scopes,
        }
        if connection is not None:
            self._values["connection"] = connection
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if for_each is not None:
            self._values["for_each"] = for_each
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider
        if provisioners is not None:
            self._values["provisioners"] = provisioners
        if api_version is not None:
            self._values["api_version"] = api_version
        if enable_migration_analysis is not None:
            self._values["enable_migration_analysis"] = enable_migration_analysis
        if enable_transformation is not None:
            self._values["enable_transformation"] = enable_transformation
        if enable_validation is not None:
            self._values["enable_validation"] = enable_validation
        if location is not None:
            self._values["location"] = location
        if monitoring is not None:
            self._values["monitoring"] = monitoring
        if name is not None:
            self._values["name"] = name
        if tags is not None:
            self._values["tags"] = tags
        if actions is not None:
            self._values["actions"] = actions
        if description is not None:
            self._values["description"] = description
        if enabled is not None:
            self._values["enabled"] = enabled
        if resource_group_id is not None:
            self._values["resource_group_id"] = resource_group_id

    @builtins.property
    def connection(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("connection")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]], result)

    @builtins.property
    def count(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]], result)

    @builtins.property
    def depends_on(
        self,
    ) -> typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]], result)

    @builtins.property
    def for_each(self) -> typing.Optional[_cdktf_9a9027ec.ITerraformIterator]:
        '''
        :stability: experimental
        '''
        result = self._values.get("for_each")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.ITerraformIterator], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[_cdktf_9a9027ec.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformProvider], result)

    @builtins.property
    def provisioners(
        self,
    ) -> typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provisioners")
        return typing.cast(typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]], result)

    @builtins.property
    def api_version(self) -> typing.Optional[builtins.str]:
        '''Explicit API version to use for this resource.

        If not specified, the latest active version will be automatically resolved.
        Use this for version pinning when stability is required over latest features.

        :default: Latest active version from ApiVersionManager

        Example::

            "2024-11-01"
        '''
        result = self._values.get("api_version")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def enable_migration_analysis(self) -> typing.Optional[builtins.bool]:
        '''Whether to enable migration analysis warnings.

        When true, the framework will analyze the current version for deprecation
        status and provide migration recommendations in the deployment output.

        :default: true
        '''
        result = self._values.get("enable_migration_analysis")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_transformation(self) -> typing.Optional[builtins.bool]:
        '''Whether to apply property transformations automatically.

        When true, properties will be automatically transformed according to the
        target schema's transformation rules. This enables backward compatibility.

        :default: true
        '''
        result = self._values.get("enable_transformation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_validation(self) -> typing.Optional[builtins.bool]:
        '''Whether to validate properties against the schema.

        When true, all properties will be validated against the API schema before
        resource creation. Validation errors will cause deployment failures.

        :default: true
        '''
        result = self._values.get("enable_validation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def location(self) -> typing.Optional[builtins.str]:
        '''The location where the resource should be created.

        :default: Varies by resource type - see specific resource documentation

        :remarks:

        Location handling varies by resource type:

        - **Top-level resources**: Most require an explicit location (e.g., "eastus", "westus")
        - **Global resources**: Some use "global" as location (e.g., Private DNS Zones)
        - **Child resources**: Inherit location from parent and should NOT set this property

        Each resource type may provide its own default through the ``resolveLocation()`` method.
        If no location is specified and no default exists, resource creation may fail.

        Example::

            // Child resource (Subnet) - do not set location
            // location: undefined (inherited from parent Virtual Network)
        '''
        result = self._values.get("location")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def monitoring(self) -> typing.Optional[_MonitoringConfig_7c28df74]:
        '''Monitoring configuration for this resource.

        Enables integrated monitoring with diagnostic settings, metric alerts,
        and activity log alerts. All monitoring is optional and disabled by default.

        Example::

            monitoring: {
              enabled: true,
              diagnosticSettings: {
                workspaceId: logAnalytics.id,
                metrics: ['AllMetrics'],
                logs: ['AuditLogs']
              },
              metricAlerts: [{
                name: 'high-cpu-alert',
                severity: 2,
                scopes: [], // Automatically set to this resource
                criteria: { ... },
                actions: [{ actionGroupId: actionGroup.id }]
              }]
            }
        '''
        result = self._values.get("monitoring")
        return typing.cast(typing.Optional[_MonitoringConfig_7c28df74], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the resource.'''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Tags to apply to the resource.'''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def condition(self) -> _ActivityLogAlertCondition_dfb706a4:
        '''Alert condition with field-value pairs All conditions are combined with AND logic.'''
        result = self._values.get("condition")
        assert result is not None, "Required property 'condition' is missing"
        return typing.cast(_ActivityLogAlertCondition_dfb706a4, result)

    @builtins.property
    def scopes(self) -> typing.List[builtins.str]:
        '''Resource IDs that this alert is scoped to Can be subscription, resource group, or specific resource IDs.

        Example::

            ["/subscriptions/.../resourceGroups/my-rg"]
        '''
        result = self._values.get("scopes")
        assert result is not None, "Required property 'scopes' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def actions(self) -> typing.Optional[_ActivityLogAlertActions_efbd1a87]:
        '''Action groups to notify.'''
        result = self._values.get("actions")
        return typing.cast(typing.Optional[_ActivityLogAlertActions_efbd1a87], result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''Description of the alert rule.'''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def enabled(self) -> typing.Optional[builtins.bool]:
        '''Whether the alert rule is enabled.

        :default: true
        '''
        result = self._values.get("enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def resource_group_id(self) -> typing.Optional[builtins.str]:
        '''Resource group ID where the activity log alert will be created.'''
        result = self._values.get("resource_group_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ActivityLogAlertProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.AddConnectivityConfigurationProps",
    jsii_struct_bases=[_AzapiResourceProps_141a2340],
    name_mapping={
        "connection": "connection",
        "count": "count",
        "depends_on": "dependsOn",
        "for_each": "forEach",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "provisioners": "provisioners",
        "api_version": "apiVersion",
        "enable_migration_analysis": "enableMigrationAnalysis",
        "enable_transformation": "enableTransformation",
        "enable_validation": "enableValidation",
        "location": "location",
        "monitoring": "monitoring",
        "name": "name",
        "tags": "tags",
        "applies_to_groups": "appliesToGroups",
        "connectivity_topology": "connectivityTopology",
        "delete_existing_peering": "deleteExistingPeering",
        "description": "description",
        "hubs": "hubs",
        "ignore_changes": "ignoreChanges",
        "is_global": "isGlobal",
    },
)
class AddConnectivityConfigurationProps(_AzapiResourceProps_141a2340):
    def __init__(
        self,
        *,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
        api_version: typing.Optional[builtins.str] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        location: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        applies_to_groups: typing.Sequence[typing.Union[_ConnectivityGroupItem_d310024f, typing.Dict[builtins.str, typing.Any]]],
        connectivity_topology: builtins.str,
        delete_existing_peering: typing.Optional[builtins.bool] = None,
        description: typing.Optional[builtins.str] = None,
        hubs: typing.Optional[typing.Sequence[typing.Union[_Hub_d4efdd65, typing.Dict[builtins.str, typing.Any]]]] = None,
        ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
        is_global: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Properties for adding a ConnectivityConfiguration via the convenience method This interface excludes networkManagerId as it's automatically set.

        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        :param api_version: Explicit API version to use for this resource. If not specified, the latest active version will be automatically resolved. Use this for version pinning when stability is required over latest features. Default: Latest active version from ApiVersionManager
        :param enable_migration_analysis: Whether to enable migration analysis warnings. When true, the framework will analyze the current version for deprecation status and provide migration recommendations in the deployment output. Default: true
        :param enable_transformation: Whether to apply property transformations automatically. When true, properties will be automatically transformed according to the target schema's transformation rules. This enables backward compatibility. Default: true
        :param enable_validation: Whether to validate properties against the schema. When true, all properties will be validated against the API schema before resource creation. Validation errors will cause deployment failures. Default: true
        :param location: The location where the resource should be created. Default: Varies by resource type - see specific resource documentation
        :param monitoring: Monitoring configuration for this resource. Enables integrated monitoring with diagnostic settings, metric alerts, and activity log alerts. All monitoring is optional and disabled by default.
        :param name: The name of the resource.
        :param tags: Tags to apply to the resource.
        :param applies_to_groups: Network groups to apply this configuration to Each item specifies a network group and how it should connect.
        :param connectivity_topology: Connectivity topology type - HubAndSpoke: Central hub with spoke VNets - Mesh: All VNets can communicate directly.
        :param delete_existing_peering: Delete existing peerings when applying this configuration. Default: false
        :param description: Optional description of the connectivity configuration.
        :param hubs: Hub VNets for hub-and-spoke topology Required when connectivityTopology is "HubAndSpoke".
        :param ignore_changes: The lifecycle rules to ignore changes.
        :param is_global: Enable global mesh connectivity Allows mesh connectivity across regions. Default: false
        '''
        if isinstance(lifecycle, dict):
            lifecycle = _cdktf_9a9027ec.TerraformResourceLifecycle(**lifecycle)
        if isinstance(monitoring, dict):
            monitoring = _MonitoringConfig_7c28df74(**monitoring)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__232fd1352be84d611a018a6e4dff6fef8ed28a1e7db0c824a7cc0c1b13f534cd)
            check_type(argname="argument connection", value=connection, expected_type=type_hints["connection"])
            check_type(argname="argument count", value=count, expected_type=type_hints["count"])
            check_type(argname="argument depends_on", value=depends_on, expected_type=type_hints["depends_on"])
            check_type(argname="argument for_each", value=for_each, expected_type=type_hints["for_each"])
            check_type(argname="argument lifecycle", value=lifecycle, expected_type=type_hints["lifecycle"])
            check_type(argname="argument provider", value=provider, expected_type=type_hints["provider"])
            check_type(argname="argument provisioners", value=provisioners, expected_type=type_hints["provisioners"])
            check_type(argname="argument api_version", value=api_version, expected_type=type_hints["api_version"])
            check_type(argname="argument enable_migration_analysis", value=enable_migration_analysis, expected_type=type_hints["enable_migration_analysis"])
            check_type(argname="argument enable_transformation", value=enable_transformation, expected_type=type_hints["enable_transformation"])
            check_type(argname="argument enable_validation", value=enable_validation, expected_type=type_hints["enable_validation"])
            check_type(argname="argument location", value=location, expected_type=type_hints["location"])
            check_type(argname="argument monitoring", value=monitoring, expected_type=type_hints["monitoring"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument applies_to_groups", value=applies_to_groups, expected_type=type_hints["applies_to_groups"])
            check_type(argname="argument connectivity_topology", value=connectivity_topology, expected_type=type_hints["connectivity_topology"])
            check_type(argname="argument delete_existing_peering", value=delete_existing_peering, expected_type=type_hints["delete_existing_peering"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument hubs", value=hubs, expected_type=type_hints["hubs"])
            check_type(argname="argument ignore_changes", value=ignore_changes, expected_type=type_hints["ignore_changes"])
            check_type(argname="argument is_global", value=is_global, expected_type=type_hints["is_global"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "applies_to_groups": applies_to_groups,
            "connectivity_topology": connectivity_topology,
        }
        if connection is not None:
            self._values["connection"] = connection
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if for_each is not None:
            self._values["for_each"] = for_each
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider
        if provisioners is not None:
            self._values["provisioners"] = provisioners
        if api_version is not None:
            self._values["api_version"] = api_version
        if enable_migration_analysis is not None:
            self._values["enable_migration_analysis"] = enable_migration_analysis
        if enable_transformation is not None:
            self._values["enable_transformation"] = enable_transformation
        if enable_validation is not None:
            self._values["enable_validation"] = enable_validation
        if location is not None:
            self._values["location"] = location
        if monitoring is not None:
            self._values["monitoring"] = monitoring
        if name is not None:
            self._values["name"] = name
        if tags is not None:
            self._values["tags"] = tags
        if delete_existing_peering is not None:
            self._values["delete_existing_peering"] = delete_existing_peering
        if description is not None:
            self._values["description"] = description
        if hubs is not None:
            self._values["hubs"] = hubs
        if ignore_changes is not None:
            self._values["ignore_changes"] = ignore_changes
        if is_global is not None:
            self._values["is_global"] = is_global

    @builtins.property
    def connection(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("connection")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]], result)

    @builtins.property
    def count(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]], result)

    @builtins.property
    def depends_on(
        self,
    ) -> typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]], result)

    @builtins.property
    def for_each(self) -> typing.Optional[_cdktf_9a9027ec.ITerraformIterator]:
        '''
        :stability: experimental
        '''
        result = self._values.get("for_each")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.ITerraformIterator], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[_cdktf_9a9027ec.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformProvider], result)

    @builtins.property
    def provisioners(
        self,
    ) -> typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provisioners")
        return typing.cast(typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]], result)

    @builtins.property
    def api_version(self) -> typing.Optional[builtins.str]:
        '''Explicit API version to use for this resource.

        If not specified, the latest active version will be automatically resolved.
        Use this for version pinning when stability is required over latest features.

        :default: Latest active version from ApiVersionManager

        Example::

            "2024-11-01"
        '''
        result = self._values.get("api_version")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def enable_migration_analysis(self) -> typing.Optional[builtins.bool]:
        '''Whether to enable migration analysis warnings.

        When true, the framework will analyze the current version for deprecation
        status and provide migration recommendations in the deployment output.

        :default: true
        '''
        result = self._values.get("enable_migration_analysis")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_transformation(self) -> typing.Optional[builtins.bool]:
        '''Whether to apply property transformations automatically.

        When true, properties will be automatically transformed according to the
        target schema's transformation rules. This enables backward compatibility.

        :default: true
        '''
        result = self._values.get("enable_transformation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_validation(self) -> typing.Optional[builtins.bool]:
        '''Whether to validate properties against the schema.

        When true, all properties will be validated against the API schema before
        resource creation. Validation errors will cause deployment failures.

        :default: true
        '''
        result = self._values.get("enable_validation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def location(self) -> typing.Optional[builtins.str]:
        '''The location where the resource should be created.

        :default: Varies by resource type - see specific resource documentation

        :remarks:

        Location handling varies by resource type:

        - **Top-level resources**: Most require an explicit location (e.g., "eastus", "westus")
        - **Global resources**: Some use "global" as location (e.g., Private DNS Zones)
        - **Child resources**: Inherit location from parent and should NOT set this property

        Each resource type may provide its own default through the ``resolveLocation()`` method.
        If no location is specified and no default exists, resource creation may fail.

        Example::

            // Child resource (Subnet) - do not set location
            // location: undefined (inherited from parent Virtual Network)
        '''
        result = self._values.get("location")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def monitoring(self) -> typing.Optional[_MonitoringConfig_7c28df74]:
        '''Monitoring configuration for this resource.

        Enables integrated monitoring with diagnostic settings, metric alerts,
        and activity log alerts. All monitoring is optional and disabled by default.

        Example::

            monitoring: {
              enabled: true,
              diagnosticSettings: {
                workspaceId: logAnalytics.id,
                metrics: ['AllMetrics'],
                logs: ['AuditLogs']
              },
              metricAlerts: [{
                name: 'high-cpu-alert',
                severity: 2,
                scopes: [], // Automatically set to this resource
                criteria: { ... },
                actions: [{ actionGroupId: actionGroup.id }]
              }]
            }
        '''
        result = self._values.get("monitoring")
        return typing.cast(typing.Optional[_MonitoringConfig_7c28df74], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the resource.'''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Tags to apply to the resource.'''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def applies_to_groups(self) -> typing.List[_ConnectivityGroupItem_d310024f]:
        '''Network groups to apply this configuration to Each item specifies a network group and how it should connect.'''
        result = self._values.get("applies_to_groups")
        assert result is not None, "Required property 'applies_to_groups' is missing"
        return typing.cast(typing.List[_ConnectivityGroupItem_d310024f], result)

    @builtins.property
    def connectivity_topology(self) -> builtins.str:
        '''Connectivity topology type - HubAndSpoke: Central hub with spoke VNets - Mesh: All VNets can communicate directly.

        Example::

            "Mesh"
        '''
        result = self._values.get("connectivity_topology")
        assert result is not None, "Required property 'connectivity_topology' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def delete_existing_peering(self) -> typing.Optional[builtins.bool]:
        '''Delete existing peerings when applying this configuration.

        :default: false
        '''
        result = self._values.get("delete_existing_peering")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''Optional description of the connectivity configuration.

        Example::

            "Hub-and-spoke topology for production workloads"
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def hubs(self) -> typing.Optional[typing.List[_Hub_d4efdd65]]:
        '''Hub VNets for hub-and-spoke topology Required when connectivityTopology is "HubAndSpoke".

        Example::

            [{ resourceId: "/subscriptions/.../virtualNetworks/hub-vnet", resourceType: "Microsoft.Network/virtualNetworks" }]
        '''
        result = self._values.get("hubs")
        return typing.cast(typing.Optional[typing.List[_Hub_d4efdd65]], result)

    @builtins.property
    def ignore_changes(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The lifecycle rules to ignore changes.

        Example::

            ["tags"]
        '''
        result = self._values.get("ignore_changes")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def is_global(self) -> typing.Optional[builtins.bool]:
        '''Enable global mesh connectivity Allows mesh connectivity across regions.

        :default: false
        '''
        result = self._values.get("is_global")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AddConnectivityConfigurationProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.AddIpamPoolProps",
    jsii_struct_bases=[_AzapiResourceProps_141a2340],
    name_mapping={
        "connection": "connection",
        "count": "count",
        "depends_on": "dependsOn",
        "for_each": "forEach",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "provisioners": "provisioners",
        "api_version": "apiVersion",
        "enable_migration_analysis": "enableMigrationAnalysis",
        "enable_transformation": "enableTransformation",
        "enable_validation": "enableValidation",
        "location": "location",
        "monitoring": "monitoring",
        "name": "name",
        "tags": "tags",
        "address_prefixes": "addressPrefixes",
        "description": "description",
        "display_name": "displayName",
        "ignore_changes": "ignoreChanges",
        "parent_pool_name": "parentPoolName",
    },
)
class AddIpamPoolProps(_AzapiResourceProps_141a2340):
    def __init__(
        self,
        *,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
        api_version: typing.Optional[builtins.str] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        location: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        address_prefixes: typing.Sequence[builtins.str],
        description: typing.Optional[builtins.str] = None,
        display_name: typing.Optional[builtins.str] = None,
        ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
        parent_pool_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for adding an IpamPool via the convenience method This interface excludes networkManagerId as it's automatically set.

        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        :param api_version: Explicit API version to use for this resource. If not specified, the latest active version will be automatically resolved. Use this for version pinning when stability is required over latest features. Default: Latest active version from ApiVersionManager
        :param enable_migration_analysis: Whether to enable migration analysis warnings. When true, the framework will analyze the current version for deprecation status and provide migration recommendations in the deployment output. Default: true
        :param enable_transformation: Whether to apply property transformations automatically. When true, properties will be automatically transformed according to the target schema's transformation rules. This enables backward compatibility. Default: true
        :param enable_validation: Whether to validate properties against the schema. When true, all properties will be validated against the API schema before resource creation. Validation errors will cause deployment failures. Default: true
        :param location: The location where the resource should be created. Default: Varies by resource type - see specific resource documentation
        :param monitoring: Monitoring configuration for this resource. Enables integrated monitoring with diagnostic settings, metric alerts, and activity log alerts. All monitoring is optional and disabled by default.
        :param name: The name of the resource.
        :param tags: Tags to apply to the resource.
        :param address_prefixes: IP address prefixes for the pool Must be valid CIDR notation (e.g., "10.0.0.0/8") Multiple prefixes must not overlap.
        :param description: Optional description of the IPAM pool.
        :param display_name: Optional friendly display name.
        :param ignore_changes: The lifecycle rules to ignore changes.
        :param parent_pool_name: Name of parent pool for hierarchical pools Leave empty/undefined for root pools.
        '''
        if isinstance(lifecycle, dict):
            lifecycle = _cdktf_9a9027ec.TerraformResourceLifecycle(**lifecycle)
        if isinstance(monitoring, dict):
            monitoring = _MonitoringConfig_7c28df74(**monitoring)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5410170048287adae6d87e4f4720db146c8c61501365c21dead7e8f689d505be)
            check_type(argname="argument connection", value=connection, expected_type=type_hints["connection"])
            check_type(argname="argument count", value=count, expected_type=type_hints["count"])
            check_type(argname="argument depends_on", value=depends_on, expected_type=type_hints["depends_on"])
            check_type(argname="argument for_each", value=for_each, expected_type=type_hints["for_each"])
            check_type(argname="argument lifecycle", value=lifecycle, expected_type=type_hints["lifecycle"])
            check_type(argname="argument provider", value=provider, expected_type=type_hints["provider"])
            check_type(argname="argument provisioners", value=provisioners, expected_type=type_hints["provisioners"])
            check_type(argname="argument api_version", value=api_version, expected_type=type_hints["api_version"])
            check_type(argname="argument enable_migration_analysis", value=enable_migration_analysis, expected_type=type_hints["enable_migration_analysis"])
            check_type(argname="argument enable_transformation", value=enable_transformation, expected_type=type_hints["enable_transformation"])
            check_type(argname="argument enable_validation", value=enable_validation, expected_type=type_hints["enable_validation"])
            check_type(argname="argument location", value=location, expected_type=type_hints["location"])
            check_type(argname="argument monitoring", value=monitoring, expected_type=type_hints["monitoring"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument address_prefixes", value=address_prefixes, expected_type=type_hints["address_prefixes"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument display_name", value=display_name, expected_type=type_hints["display_name"])
            check_type(argname="argument ignore_changes", value=ignore_changes, expected_type=type_hints["ignore_changes"])
            check_type(argname="argument parent_pool_name", value=parent_pool_name, expected_type=type_hints["parent_pool_name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "address_prefixes": address_prefixes,
        }
        if connection is not None:
            self._values["connection"] = connection
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if for_each is not None:
            self._values["for_each"] = for_each
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider
        if provisioners is not None:
            self._values["provisioners"] = provisioners
        if api_version is not None:
            self._values["api_version"] = api_version
        if enable_migration_analysis is not None:
            self._values["enable_migration_analysis"] = enable_migration_analysis
        if enable_transformation is not None:
            self._values["enable_transformation"] = enable_transformation
        if enable_validation is not None:
            self._values["enable_validation"] = enable_validation
        if location is not None:
            self._values["location"] = location
        if monitoring is not None:
            self._values["monitoring"] = monitoring
        if name is not None:
            self._values["name"] = name
        if tags is not None:
            self._values["tags"] = tags
        if description is not None:
            self._values["description"] = description
        if display_name is not None:
            self._values["display_name"] = display_name
        if ignore_changes is not None:
            self._values["ignore_changes"] = ignore_changes
        if parent_pool_name is not None:
            self._values["parent_pool_name"] = parent_pool_name

    @builtins.property
    def connection(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("connection")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]], result)

    @builtins.property
    def count(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]], result)

    @builtins.property
    def depends_on(
        self,
    ) -> typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]], result)

    @builtins.property
    def for_each(self) -> typing.Optional[_cdktf_9a9027ec.ITerraformIterator]:
        '''
        :stability: experimental
        '''
        result = self._values.get("for_each")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.ITerraformIterator], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[_cdktf_9a9027ec.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformProvider], result)

    @builtins.property
    def provisioners(
        self,
    ) -> typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provisioners")
        return typing.cast(typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]], result)

    @builtins.property
    def api_version(self) -> typing.Optional[builtins.str]:
        '''Explicit API version to use for this resource.

        If not specified, the latest active version will be automatically resolved.
        Use this for version pinning when stability is required over latest features.

        :default: Latest active version from ApiVersionManager

        Example::

            "2024-11-01"
        '''
        result = self._values.get("api_version")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def enable_migration_analysis(self) -> typing.Optional[builtins.bool]:
        '''Whether to enable migration analysis warnings.

        When true, the framework will analyze the current version for deprecation
        status and provide migration recommendations in the deployment output.

        :default: true
        '''
        result = self._values.get("enable_migration_analysis")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_transformation(self) -> typing.Optional[builtins.bool]:
        '''Whether to apply property transformations automatically.

        When true, properties will be automatically transformed according to the
        target schema's transformation rules. This enables backward compatibility.

        :default: true
        '''
        result = self._values.get("enable_transformation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_validation(self) -> typing.Optional[builtins.bool]:
        '''Whether to validate properties against the schema.

        When true, all properties will be validated against the API schema before
        resource creation. Validation errors will cause deployment failures.

        :default: true
        '''
        result = self._values.get("enable_validation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def location(self) -> typing.Optional[builtins.str]:
        '''The location where the resource should be created.

        :default: Varies by resource type - see specific resource documentation

        :remarks:

        Location handling varies by resource type:

        - **Top-level resources**: Most require an explicit location (e.g., "eastus", "westus")
        - **Global resources**: Some use "global" as location (e.g., Private DNS Zones)
        - **Child resources**: Inherit location from parent and should NOT set this property

        Each resource type may provide its own default through the ``resolveLocation()`` method.
        If no location is specified and no default exists, resource creation may fail.

        Example::

            // Child resource (Subnet) - do not set location
            // location: undefined (inherited from parent Virtual Network)
        '''
        result = self._values.get("location")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def monitoring(self) -> typing.Optional[_MonitoringConfig_7c28df74]:
        '''Monitoring configuration for this resource.

        Enables integrated monitoring with diagnostic settings, metric alerts,
        and activity log alerts. All monitoring is optional and disabled by default.

        Example::

            monitoring: {
              enabled: true,
              diagnosticSettings: {
                workspaceId: logAnalytics.id,
                metrics: ['AllMetrics'],
                logs: ['AuditLogs']
              },
              metricAlerts: [{
                name: 'high-cpu-alert',
                severity: 2,
                scopes: [], // Automatically set to this resource
                criteria: { ... },
                actions: [{ actionGroupId: actionGroup.id }]
              }]
            }
        '''
        result = self._values.get("monitoring")
        return typing.cast(typing.Optional[_MonitoringConfig_7c28df74], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the resource.'''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Tags to apply to the resource.'''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def address_prefixes(self) -> typing.List[builtins.str]:
        '''IP address prefixes for the pool Must be valid CIDR notation (e.g., "10.0.0.0/8") Multiple prefixes must not overlap.

        Example::

            ["10.0.0.0/8", "172.16.0.0/12"]
        '''
        result = self._values.get("address_prefixes")
        assert result is not None, "Required property 'address_prefixes' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''Optional description of the IPAM pool.

        Example::

            "Production IP address pool for East US region"
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def display_name(self) -> typing.Optional[builtins.str]:
        '''Optional friendly display name.

        Example::

            "East US Production Pool"
        '''
        result = self._values.get("display_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ignore_changes(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The lifecycle rules to ignore changes.

        Example::

            ["tags"]
        '''
        result = self._values.get("ignore_changes")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def parent_pool_name(self) -> typing.Optional[builtins.str]:
        '''Name of parent pool for hierarchical pools Leave empty/undefined for root pools.

        Example::

            "root-pool"
        '''
        result = self._values.get("parent_pool_name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AddIpamPoolProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.AddNetworkGroupProps",
    jsii_struct_bases=[_AzapiResourceProps_141a2340],
    name_mapping={
        "connection": "connection",
        "count": "count",
        "depends_on": "dependsOn",
        "for_each": "forEach",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "provisioners": "provisioners",
        "api_version": "apiVersion",
        "enable_migration_analysis": "enableMigrationAnalysis",
        "enable_transformation": "enableTransformation",
        "enable_validation": "enableValidation",
        "location": "location",
        "monitoring": "monitoring",
        "name": "name",
        "tags": "tags",
        "description": "description",
        "ignore_changes": "ignoreChanges",
        "member_type": "memberType",
    },
)
class AddNetworkGroupProps(_AzapiResourceProps_141a2340):
    def __init__(
        self,
        *,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
        api_version: typing.Optional[builtins.str] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        location: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        description: typing.Optional[builtins.str] = None,
        ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
        member_type: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for adding a NetworkGroup via the convenience method This interface excludes networkManagerId as it's automatically set.

        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        :param api_version: Explicit API version to use for this resource. If not specified, the latest active version will be automatically resolved. Use this for version pinning when stability is required over latest features. Default: Latest active version from ApiVersionManager
        :param enable_migration_analysis: Whether to enable migration analysis warnings. When true, the framework will analyze the current version for deprecation status and provide migration recommendations in the deployment output. Default: true
        :param enable_transformation: Whether to apply property transformations automatically. When true, properties will be automatically transformed according to the target schema's transformation rules. This enables backward compatibility. Default: true
        :param enable_validation: Whether to validate properties against the schema. When true, all properties will be validated against the API schema before resource creation. Validation errors will cause deployment failures. Default: true
        :param location: The location where the resource should be created. Default: Varies by resource type - see specific resource documentation
        :param monitoring: Monitoring configuration for this resource. Enables integrated monitoring with diagnostic settings, metric alerts, and activity log alerts. All monitoring is optional and disabled by default.
        :param name: The name of the resource.
        :param tags: Tags to apply to the resource.
        :param description: Optional description of the network group.
        :param ignore_changes: The lifecycle rules to ignore changes.
        :param member_type: Type of members in this network group. Default: undefined (can contain both VirtualNetwork and Subnet members)
        '''
        if isinstance(lifecycle, dict):
            lifecycle = _cdktf_9a9027ec.TerraformResourceLifecycle(**lifecycle)
        if isinstance(monitoring, dict):
            monitoring = _MonitoringConfig_7c28df74(**monitoring)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c5d16e7ab8b61bb6aed807ae8dec1eac59749acb0f94b13c5528b7f32178bdf3)
            check_type(argname="argument connection", value=connection, expected_type=type_hints["connection"])
            check_type(argname="argument count", value=count, expected_type=type_hints["count"])
            check_type(argname="argument depends_on", value=depends_on, expected_type=type_hints["depends_on"])
            check_type(argname="argument for_each", value=for_each, expected_type=type_hints["for_each"])
            check_type(argname="argument lifecycle", value=lifecycle, expected_type=type_hints["lifecycle"])
            check_type(argname="argument provider", value=provider, expected_type=type_hints["provider"])
            check_type(argname="argument provisioners", value=provisioners, expected_type=type_hints["provisioners"])
            check_type(argname="argument api_version", value=api_version, expected_type=type_hints["api_version"])
            check_type(argname="argument enable_migration_analysis", value=enable_migration_analysis, expected_type=type_hints["enable_migration_analysis"])
            check_type(argname="argument enable_transformation", value=enable_transformation, expected_type=type_hints["enable_transformation"])
            check_type(argname="argument enable_validation", value=enable_validation, expected_type=type_hints["enable_validation"])
            check_type(argname="argument location", value=location, expected_type=type_hints["location"])
            check_type(argname="argument monitoring", value=monitoring, expected_type=type_hints["monitoring"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument ignore_changes", value=ignore_changes, expected_type=type_hints["ignore_changes"])
            check_type(argname="argument member_type", value=member_type, expected_type=type_hints["member_type"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if connection is not None:
            self._values["connection"] = connection
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if for_each is not None:
            self._values["for_each"] = for_each
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider
        if provisioners is not None:
            self._values["provisioners"] = provisioners
        if api_version is not None:
            self._values["api_version"] = api_version
        if enable_migration_analysis is not None:
            self._values["enable_migration_analysis"] = enable_migration_analysis
        if enable_transformation is not None:
            self._values["enable_transformation"] = enable_transformation
        if enable_validation is not None:
            self._values["enable_validation"] = enable_validation
        if location is not None:
            self._values["location"] = location
        if monitoring is not None:
            self._values["monitoring"] = monitoring
        if name is not None:
            self._values["name"] = name
        if tags is not None:
            self._values["tags"] = tags
        if description is not None:
            self._values["description"] = description
        if ignore_changes is not None:
            self._values["ignore_changes"] = ignore_changes
        if member_type is not None:
            self._values["member_type"] = member_type

    @builtins.property
    def connection(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("connection")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]], result)

    @builtins.property
    def count(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]], result)

    @builtins.property
    def depends_on(
        self,
    ) -> typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]], result)

    @builtins.property
    def for_each(self) -> typing.Optional[_cdktf_9a9027ec.ITerraformIterator]:
        '''
        :stability: experimental
        '''
        result = self._values.get("for_each")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.ITerraformIterator], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[_cdktf_9a9027ec.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformProvider], result)

    @builtins.property
    def provisioners(
        self,
    ) -> typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provisioners")
        return typing.cast(typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]], result)

    @builtins.property
    def api_version(self) -> typing.Optional[builtins.str]:
        '''Explicit API version to use for this resource.

        If not specified, the latest active version will be automatically resolved.
        Use this for version pinning when stability is required over latest features.

        :default: Latest active version from ApiVersionManager

        Example::

            "2024-11-01"
        '''
        result = self._values.get("api_version")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def enable_migration_analysis(self) -> typing.Optional[builtins.bool]:
        '''Whether to enable migration analysis warnings.

        When true, the framework will analyze the current version for deprecation
        status and provide migration recommendations in the deployment output.

        :default: true
        '''
        result = self._values.get("enable_migration_analysis")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_transformation(self) -> typing.Optional[builtins.bool]:
        '''Whether to apply property transformations automatically.

        When true, properties will be automatically transformed according to the
        target schema's transformation rules. This enables backward compatibility.

        :default: true
        '''
        result = self._values.get("enable_transformation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_validation(self) -> typing.Optional[builtins.bool]:
        '''Whether to validate properties against the schema.

        When true, all properties will be validated against the API schema before
        resource creation. Validation errors will cause deployment failures.

        :default: true
        '''
        result = self._values.get("enable_validation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def location(self) -> typing.Optional[builtins.str]:
        '''The location where the resource should be created.

        :default: Varies by resource type - see specific resource documentation

        :remarks:

        Location handling varies by resource type:

        - **Top-level resources**: Most require an explicit location (e.g., "eastus", "westus")
        - **Global resources**: Some use "global" as location (e.g., Private DNS Zones)
        - **Child resources**: Inherit location from parent and should NOT set this property

        Each resource type may provide its own default through the ``resolveLocation()`` method.
        If no location is specified and no default exists, resource creation may fail.

        Example::

            // Child resource (Subnet) - do not set location
            // location: undefined (inherited from parent Virtual Network)
        '''
        result = self._values.get("location")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def monitoring(self) -> typing.Optional[_MonitoringConfig_7c28df74]:
        '''Monitoring configuration for this resource.

        Enables integrated monitoring with diagnostic settings, metric alerts,
        and activity log alerts. All monitoring is optional and disabled by default.

        Example::

            monitoring: {
              enabled: true,
              diagnosticSettings: {
                workspaceId: logAnalytics.id,
                metrics: ['AllMetrics'],
                logs: ['AuditLogs']
              },
              metricAlerts: [{
                name: 'high-cpu-alert',
                severity: 2,
                scopes: [], // Automatically set to this resource
                criteria: { ... },
                actions: [{ actionGroupId: actionGroup.id }]
              }]
            }
        '''
        result = self._values.get("monitoring")
        return typing.cast(typing.Optional[_MonitoringConfig_7c28df74], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the resource.'''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Tags to apply to the resource.'''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''Optional description of the network group.

        Example::

            "Production virtual networks for region East US"
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ignore_changes(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The lifecycle rules to ignore changes.

        Example::

            ["tags"]
        '''
        result = self._values.get("ignore_changes")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def member_type(self) -> typing.Optional[builtins.str]:
        '''Type of members in this network group.

        :default: undefined (can contain both VirtualNetwork and Subnet members)

        Example::

            "Subnet"
        '''
        result = self._values.get("member_type")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AddNetworkGroupProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.AddSecurityAdminConfigurationProps",
    jsii_struct_bases=[_AzapiResourceProps_141a2340],
    name_mapping={
        "connection": "connection",
        "count": "count",
        "depends_on": "dependsOn",
        "for_each": "forEach",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "provisioners": "provisioners",
        "api_version": "apiVersion",
        "enable_migration_analysis": "enableMigrationAnalysis",
        "enable_transformation": "enableTransformation",
        "enable_validation": "enableValidation",
        "location": "location",
        "monitoring": "monitoring",
        "name": "name",
        "tags": "tags",
        "apply_on_network_intent_policy_based_services": "applyOnNetworkIntentPolicyBasedServices",
        "description": "description",
        "ignore_changes": "ignoreChanges",
    },
)
class AddSecurityAdminConfigurationProps(_AzapiResourceProps_141a2340):
    def __init__(
        self,
        *,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
        api_version: typing.Optional[builtins.str] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        location: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        apply_on_network_intent_policy_based_services: typing.Optional[typing.Sequence[builtins.str]] = None,
        description: typing.Optional[builtins.str] = None,
        ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''Properties for adding a SecurityAdminConfiguration via the convenience method This interface excludes networkManagerId as it's automatically set.

        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        :param api_version: Explicit API version to use for this resource. If not specified, the latest active version will be automatically resolved. Use this for version pinning when stability is required over latest features. Default: Latest active version from ApiVersionManager
        :param enable_migration_analysis: Whether to enable migration analysis warnings. When true, the framework will analyze the current version for deprecation status and provide migration recommendations in the deployment output. Default: true
        :param enable_transformation: Whether to apply property transformations automatically. When true, properties will be automatically transformed according to the target schema's transformation rules. This enables backward compatibility. Default: true
        :param enable_validation: Whether to validate properties against the schema. When true, all properties will be validated against the API schema before resource creation. Validation errors will cause deployment failures. Default: true
        :param location: The location where the resource should be created. Default: Varies by resource type - see specific resource documentation
        :param monitoring: Monitoring configuration for this resource. Enables integrated monitoring with diagnostic settings, metric alerts, and activity log alerts. All monitoring is optional and disabled by default.
        :param name: The name of the resource.
        :param tags: Tags to apply to the resource.
        :param apply_on_network_intent_policy_based_services: Services to apply the security admin configuration on.
        :param description: Optional description of the security admin configuration.
        :param ignore_changes: The lifecycle rules to ignore changes.
        '''
        if isinstance(lifecycle, dict):
            lifecycle = _cdktf_9a9027ec.TerraformResourceLifecycle(**lifecycle)
        if isinstance(monitoring, dict):
            monitoring = _MonitoringConfig_7c28df74(**monitoring)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f16cc7d0e77b8cbbea46ce83463363cdad94bc01634f0724b8fdf216531cfb57)
            check_type(argname="argument connection", value=connection, expected_type=type_hints["connection"])
            check_type(argname="argument count", value=count, expected_type=type_hints["count"])
            check_type(argname="argument depends_on", value=depends_on, expected_type=type_hints["depends_on"])
            check_type(argname="argument for_each", value=for_each, expected_type=type_hints["for_each"])
            check_type(argname="argument lifecycle", value=lifecycle, expected_type=type_hints["lifecycle"])
            check_type(argname="argument provider", value=provider, expected_type=type_hints["provider"])
            check_type(argname="argument provisioners", value=provisioners, expected_type=type_hints["provisioners"])
            check_type(argname="argument api_version", value=api_version, expected_type=type_hints["api_version"])
            check_type(argname="argument enable_migration_analysis", value=enable_migration_analysis, expected_type=type_hints["enable_migration_analysis"])
            check_type(argname="argument enable_transformation", value=enable_transformation, expected_type=type_hints["enable_transformation"])
            check_type(argname="argument enable_validation", value=enable_validation, expected_type=type_hints["enable_validation"])
            check_type(argname="argument location", value=location, expected_type=type_hints["location"])
            check_type(argname="argument monitoring", value=monitoring, expected_type=type_hints["monitoring"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument apply_on_network_intent_policy_based_services", value=apply_on_network_intent_policy_based_services, expected_type=type_hints["apply_on_network_intent_policy_based_services"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument ignore_changes", value=ignore_changes, expected_type=type_hints["ignore_changes"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if connection is not None:
            self._values["connection"] = connection
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if for_each is not None:
            self._values["for_each"] = for_each
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider
        if provisioners is not None:
            self._values["provisioners"] = provisioners
        if api_version is not None:
            self._values["api_version"] = api_version
        if enable_migration_analysis is not None:
            self._values["enable_migration_analysis"] = enable_migration_analysis
        if enable_transformation is not None:
            self._values["enable_transformation"] = enable_transformation
        if enable_validation is not None:
            self._values["enable_validation"] = enable_validation
        if location is not None:
            self._values["location"] = location
        if monitoring is not None:
            self._values["monitoring"] = monitoring
        if name is not None:
            self._values["name"] = name
        if tags is not None:
            self._values["tags"] = tags
        if apply_on_network_intent_policy_based_services is not None:
            self._values["apply_on_network_intent_policy_based_services"] = apply_on_network_intent_policy_based_services
        if description is not None:
            self._values["description"] = description
        if ignore_changes is not None:
            self._values["ignore_changes"] = ignore_changes

    @builtins.property
    def connection(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("connection")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]], result)

    @builtins.property
    def count(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]], result)

    @builtins.property
    def depends_on(
        self,
    ) -> typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]], result)

    @builtins.property
    def for_each(self) -> typing.Optional[_cdktf_9a9027ec.ITerraformIterator]:
        '''
        :stability: experimental
        '''
        result = self._values.get("for_each")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.ITerraformIterator], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[_cdktf_9a9027ec.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformProvider], result)

    @builtins.property
    def provisioners(
        self,
    ) -> typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provisioners")
        return typing.cast(typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]], result)

    @builtins.property
    def api_version(self) -> typing.Optional[builtins.str]:
        '''Explicit API version to use for this resource.

        If not specified, the latest active version will be automatically resolved.
        Use this for version pinning when stability is required over latest features.

        :default: Latest active version from ApiVersionManager

        Example::

            "2024-11-01"
        '''
        result = self._values.get("api_version")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def enable_migration_analysis(self) -> typing.Optional[builtins.bool]:
        '''Whether to enable migration analysis warnings.

        When true, the framework will analyze the current version for deprecation
        status and provide migration recommendations in the deployment output.

        :default: true
        '''
        result = self._values.get("enable_migration_analysis")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_transformation(self) -> typing.Optional[builtins.bool]:
        '''Whether to apply property transformations automatically.

        When true, properties will be automatically transformed according to the
        target schema's transformation rules. This enables backward compatibility.

        :default: true
        '''
        result = self._values.get("enable_transformation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_validation(self) -> typing.Optional[builtins.bool]:
        '''Whether to validate properties against the schema.

        When true, all properties will be validated against the API schema before
        resource creation. Validation errors will cause deployment failures.

        :default: true
        '''
        result = self._values.get("enable_validation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def location(self) -> typing.Optional[builtins.str]:
        '''The location where the resource should be created.

        :default: Varies by resource type - see specific resource documentation

        :remarks:

        Location handling varies by resource type:

        - **Top-level resources**: Most require an explicit location (e.g., "eastus", "westus")
        - **Global resources**: Some use "global" as location (e.g., Private DNS Zones)
        - **Child resources**: Inherit location from parent and should NOT set this property

        Each resource type may provide its own default through the ``resolveLocation()`` method.
        If no location is specified and no default exists, resource creation may fail.

        Example::

            // Child resource (Subnet) - do not set location
            // location: undefined (inherited from parent Virtual Network)
        '''
        result = self._values.get("location")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def monitoring(self) -> typing.Optional[_MonitoringConfig_7c28df74]:
        '''Monitoring configuration for this resource.

        Enables integrated monitoring with diagnostic settings, metric alerts,
        and activity log alerts. All monitoring is optional and disabled by default.

        Example::

            monitoring: {
              enabled: true,
              diagnosticSettings: {
                workspaceId: logAnalytics.id,
                metrics: ['AllMetrics'],
                logs: ['AuditLogs']
              },
              metricAlerts: [{
                name: 'high-cpu-alert',
                severity: 2,
                scopes: [], // Automatically set to this resource
                criteria: { ... },
                actions: [{ actionGroupId: actionGroup.id }]
              }]
            }
        '''
        result = self._values.get("monitoring")
        return typing.cast(typing.Optional[_MonitoringConfig_7c28df74], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the resource.'''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Tags to apply to the resource.'''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def apply_on_network_intent_policy_based_services(
        self,
    ) -> typing.Optional[typing.List[builtins.str]]:
        '''Services to apply the security admin configuration on.

        Example::

            ["All"]
        '''
        result = self._values.get("apply_on_network_intent_policy_based_services")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''Optional description of the security admin configuration.

        Example::

            "Organization-wide security rules for production workloads"
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ignore_changes(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The lifecycle rules to ignore changes.

        Example::

            ["tags"]
        '''
        result = self._values.get("ignore_changes")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AddSecurityAdminConfigurationProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.AdditionalCapabilities",
    jsii_struct_bases=[],
    name_mapping={"ultra_ssd_enabled": "ultraSSDEnabled"},
)
class AdditionalCapabilities:
    def __init__(
        self,
        *,
        ultra_ssd_enabled: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Additional capabilities.

        :param ultra_ssd_enabled: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f816e901bbfded4a49ce09cd8fd0e150065b5a1d0e043823f7f1e6574252676c)
            check_type(argname="argument ultra_ssd_enabled", value=ultra_ssd_enabled, expected_type=type_hints["ultra_ssd_enabled"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if ultra_ssd_enabled is not None:
            self._values["ultra_ssd_enabled"] = ultra_ssd_enabled

    @builtins.property
    def ultra_ssd_enabled(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("ultra_ssd_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AdditionalCapabilities(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.AddressPrefixItem",
    jsii_struct_bases=[],
    name_mapping={
        "address_prefix": "addressPrefix",
        "address_prefix_type": "addressPrefixType",
    },
)
class AddressPrefixItem:
    def __init__(
        self,
        *,
        address_prefix: typing.Optional[builtins.str] = None,
        address_prefix_type: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Address prefix item for sources or destinations.

        :param address_prefix: 
        :param address_prefix_type: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__48f9a631ccdd74bc042be8767da59f1e6cdd6c5f5a73d7bdaf35e74d1a3e69ae)
            check_type(argname="argument address_prefix", value=address_prefix, expected_type=type_hints["address_prefix"])
            check_type(argname="argument address_prefix_type", value=address_prefix_type, expected_type=type_hints["address_prefix_type"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if address_prefix is not None:
            self._values["address_prefix"] = address_prefix
        if address_prefix_type is not None:
            self._values["address_prefix_type"] = address_prefix_type

    @builtins.property
    def address_prefix(self) -> typing.Optional[builtins.str]:
        result = self._values.get("address_prefix")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def address_prefix_type(self) -> typing.Optional[builtins.str]:
        result = self._values.get("address_prefix_type")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AddressPrefixItem(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AksCluster(
    _AzapiResource_7e7f5b39,
    metaclass=jsii.JSIIMeta,
    jsii_type="@microsoft/terraform-cdk-constructs.AksCluster",
):
    '''Unified Azure Kubernetes Service cluster implementation.

    This class provides a single, version-aware implementation that automatically handles version
    resolution, schema validation, and property transformation while maintaining full JSII compliance.

    The class uses the VersionedAzapiResource framework to provide:

    - Automatic latest version resolution (2025-07-01 as of this implementation)
    - Support for explicit version pinning when stability is required
    - Schema-driven property validation and transformation
    - Migration analysis and deprecation warnings
    - Full JSII compliance for multi-language support

    Example::

        // AKS cluster with explicit version pinning and advanced networking:
        const aksCluster = new AksCluster(this, "aks", {
          name: "my-aks-cluster",
          location: "eastus",
          resourceGroupId: resourceGroup.id,
          apiVersion: "2025-07-01",
          dnsPrefix: "myaks",
          kubernetesVersion: "1.28.3",
          agentPoolProfiles: [{
            name: "system",
            count: 3,
            vmSize: "Standard_D2s_v3",
            mode: "System",
            vnetSubnetID: subnet.id
          }],
          identity: {
            type: "SystemAssigned"
          },
          networkProfile: {
            networkPlugin: "azure",
            serviceCidr: "10.0.0.0/16",
            dnsServiceIP: "10.0.0.10"
          },
          enableRBAC: true
        });
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        agent_pool_profiles: typing.Sequence[typing.Union[_AksClusterAgentPoolProfile_19702e0d, typing.Dict[builtins.str, typing.Any]]],
        dns_prefix: builtins.str,
        aad_profile: typing.Optional[typing.Union[_AksClusterAadProfile_cbb39e4e, typing.Dict[builtins.str, typing.Any]]] = None,
        addon_profiles: typing.Optional[typing.Mapping[builtins.str, typing.Union[_AksClusterAddonProfile_75e5bc97, typing.Dict[builtins.str, typing.Any]]]] = None,
        api_server_access_profile: typing.Optional[typing.Union[_AksClusterApiServerAccessProfile_a245e705, typing.Dict[builtins.str, typing.Any]]] = None,
        auto_scaler_profile: typing.Optional[typing.Union[_AksClusterAutoScalerProfile_15ae7fd0, typing.Dict[builtins.str, typing.Any]]] = None,
        disable_local_accounts: typing.Optional[builtins.bool] = None,
        disk_encryption_set_id: typing.Optional[builtins.str] = None,
        enable_rbac: typing.Optional[builtins.bool] = None,
        fqdn: typing.Optional[builtins.str] = None,
        http_proxy_config: typing.Optional[typing.Union[_AksClusterHttpProxyConfig_41bff94e, typing.Dict[builtins.str, typing.Any]]] = None,
        identity: typing.Optional[typing.Union[_AksClusterIdentity_92ed97a4, typing.Dict[builtins.str, typing.Any]]] = None,
        ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
        kubernetes_version: typing.Optional[builtins.str] = None,
        linux_profile: typing.Optional[typing.Union[_AksClusterLinuxProfile_516beb3b, typing.Dict[builtins.str, typing.Any]]] = None,
        network_profile: typing.Optional[typing.Union[_AksClusterNetworkProfile_ec57fbab, typing.Dict[builtins.str, typing.Any]]] = None,
        node_resource_group: typing.Optional[builtins.str] = None,
        oidc_issuer_profile: typing.Optional[typing.Union[_AksClusterOidcIssuerProfile_55bd4791, typing.Dict[builtins.str, typing.Any]]] = None,
        private_fqdn: typing.Optional[builtins.str] = None,
        public_network_access: typing.Optional[builtins.str] = None,
        resource_group_id: typing.Optional[builtins.str] = None,
        security_profile: typing.Optional[typing.Union[_AksClusterSecurityProfile_6e20ee0b, typing.Dict[builtins.str, typing.Any]]] = None,
        service_principal_profile: typing.Optional[typing.Union[_AksClusterServicePrincipalProfile_5638b9c4, typing.Dict[builtins.str, typing.Any]]] = None,
        sku: typing.Optional[typing.Union[_AksClusterSku_746ad049, typing.Dict[builtins.str, typing.Any]]] = None,
        storage_profile: typing.Optional[typing.Union[_AksClusterStorageProfile_cc359e1f, typing.Dict[builtins.str, typing.Any]]] = None,
        support_plan: typing.Optional[builtins.str] = None,
        windows_profile: typing.Optional[typing.Union[_AksClusterWindowsProfile_bf96f6e4, typing.Dict[builtins.str, typing.Any]]] = None,
        workload_auto_scaler_profile: typing.Optional[typing.Union[_AksClusterWorkloadAutoScalerProfile_ec94d7bc, typing.Dict[builtins.str, typing.Any]]] = None,
        api_version: typing.Optional[builtins.str] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        location: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> None:
        '''Creates a new Azure Kubernetes Service cluster using the VersionedAzapiResource framework.

        The constructor automatically handles version resolution, schema registration,
        validation, and resource creation.

        :param scope: - The scope in which to define this construct.
        :param id: - The unique identifier for this instance.
        :param agent_pool_profiles: The agent pool profiles for the cluster node pools At least one agent pool is required.
        :param dns_prefix: DNS prefix for the cluster.
        :param aad_profile: The Azure Active Directory integration configuration.
        :param addon_profiles: The addon profiles for cluster addons.
        :param api_server_access_profile: The API server access configuration.
        :param auto_scaler_profile: The auto-scaler configuration for the cluster.
        :param disable_local_accounts: Whether to disable local accounts. Default: false
        :param disk_encryption_set_id: The resource ID of the disk encryption set for encrypting disks.
        :param enable_rbac: Whether to enable Kubernetes Role-Based Access Control. Default: true
        :param fqdn: The FQDN for the cluster (read-only).
        :param http_proxy_config: The HTTP proxy configuration.
        :param identity: The identity configuration for the AKS cluster.
        :param ignore_changes: The lifecycle rules to ignore changes Useful for properties that are externally managed or should not trigger updates.
        :param kubernetes_version: The Kubernetes version for the cluster.
        :param linux_profile: The Linux profile for SSH access.
        :param network_profile: The network configuration for the cluster.
        :param node_resource_group: The name of the resource group for cluster nodes If not specified, Azure will auto-generate the name.
        :param oidc_issuer_profile: The OIDC issuer profile for workload identity.
        :param private_fqdn: The private FQDN for the cluster (read-only).
        :param public_network_access: Whether the cluster is accessible from the public internet.
        :param resource_group_id: Resource group ID where the AKS cluster will be created.
        :param security_profile: The security profile for the cluster.
        :param service_principal_profile: The service principal profile for the cluster.
        :param sku: The SKU (pricing tier) for the AKS cluster.
        :param storage_profile: The storage profile for CSI drivers.
        :param support_plan: The support plan for the cluster.
        :param windows_profile: The Windows profile for Windows node pools.
        :param workload_auto_scaler_profile: The workload auto-scaler profile.
        :param api_version: Explicit API version to use for this resource. If not specified, the latest active version will be automatically resolved. Use this for version pinning when stability is required over latest features. Default: Latest active version from ApiVersionManager
        :param enable_migration_analysis: Whether to enable migration analysis warnings. When true, the framework will analyze the current version for deprecation status and provide migration recommendations in the deployment output. Default: true
        :param enable_transformation: Whether to apply property transformations automatically. When true, properties will be automatically transformed according to the target schema's transformation rules. This enables backward compatibility. Default: true
        :param enable_validation: Whether to validate properties against the schema. When true, all properties will be validated against the API schema before resource creation. Validation errors will cause deployment failures. Default: true
        :param location: The location where the resource should be created. Default: Varies by resource type - see specific resource documentation
        :param monitoring: Monitoring configuration for this resource. Enables integrated monitoring with diagnostic settings, metric alerts, and activity log alerts. All monitoring is optional and disabled by default.
        :param name: The name of the resource.
        :param tags: Tags to apply to the resource.
        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f33daf590e0847316d33f2ebe263228803db7110e8d816623c976f158816696a)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = _AksClusterProps_df15bce7(
            agent_pool_profiles=agent_pool_profiles,
            dns_prefix=dns_prefix,
            aad_profile=aad_profile,
            addon_profiles=addon_profiles,
            api_server_access_profile=api_server_access_profile,
            auto_scaler_profile=auto_scaler_profile,
            disable_local_accounts=disable_local_accounts,
            disk_encryption_set_id=disk_encryption_set_id,
            enable_rbac=enable_rbac,
            fqdn=fqdn,
            http_proxy_config=http_proxy_config,
            identity=identity,
            ignore_changes=ignore_changes,
            kubernetes_version=kubernetes_version,
            linux_profile=linux_profile,
            network_profile=network_profile,
            node_resource_group=node_resource_group,
            oidc_issuer_profile=oidc_issuer_profile,
            private_fqdn=private_fqdn,
            public_network_access=public_network_access,
            resource_group_id=resource_group_id,
            security_profile=security_profile,
            service_principal_profile=service_principal_profile,
            sku=sku,
            storage_profile=storage_profile,
            support_plan=support_plan,
            windows_profile=windows_profile,
            workload_auto_scaler_profile=workload_auto_scaler_profile,
            api_version=api_version,
            enable_migration_analysis=enable_migration_analysis,
            enable_transformation=enable_transformation,
            enable_validation=enable_validation,
            location=location,
            monitoring=monitoring,
            name=name,
            tags=tags,
            connection=connection,
            count=count,
            depends_on=depends_on,
            for_each=for_each,
            lifecycle=lifecycle,
            provider=provider,
            provisioners=provisioners,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="defaultMonitoring")
    @builtins.classmethod
    def default_monitoring(
        cls,
        action_group_id: builtins.str,
        workspace_id: typing.Optional[builtins.str] = None,
        *,
        enable_deletion_alert: typing.Optional[builtins.bool] = None,
        enable_failed_pod_alert: typing.Optional[builtins.bool] = None,
        enable_node_cpu_alert: typing.Optional[builtins.bool] = None,
        enable_node_memory_alert: typing.Optional[builtins.bool] = None,
        failed_pod_alert_severity: typing.Optional[jsii.Number] = None,
        failed_pod_threshold: typing.Optional[jsii.Number] = None,
        node_cpu_alert_severity: typing.Optional[jsii.Number] = None,
        node_cpu_threshold: typing.Optional[jsii.Number] = None,
        node_memory_alert_severity: typing.Optional[jsii.Number] = None,
        node_memory_threshold: typing.Optional[jsii.Number] = None,
    ) -> _MonitoringConfig_7c28df74:
        '''Returns a production-ready monitoring configuration for AKS Clusters.

        This static factory method provides a complete MonitoringConfig with sensible defaults
        for AKS monitoring including node CPU, node memory, failed pod alerts, and deletion tracking.

        :param action_group_id: - The resource ID of the action group for alert notifications.
        :param workspace_id: - Optional Log Analytics workspace ID for diagnostic settings.
        :param enable_deletion_alert: Whether to enable AKS cluster deletion alert. Default: true
        :param enable_failed_pod_alert: Whether to enable failed pod alert. Default: true
        :param enable_node_cpu_alert: Whether to enable node CPU usage alert. Default: true
        :param enable_node_memory_alert: Whether to enable node memory usage alert. Default: true
        :param failed_pod_alert_severity: Severity level for failed pod alert (0=Critical, 1=Error, 2=Warning, 3=Informational, 4=Verbose). Default: 1
        :param failed_pod_threshold: Threshold for failed pod count. Default: 0
        :param node_cpu_alert_severity: Severity level for node CPU alert (0=Critical, 1=Error, 2=Warning, 3=Informational, 4=Verbose). Default: 2
        :param node_cpu_threshold: Threshold for node CPU usage percentage (0-100). Default: 80
        :param node_memory_alert_severity: Severity level for node memory alert (0=Critical, 1=Error, 2=Warning, 3=Informational, 4=Verbose). Default: 2
        :param node_memory_threshold: Threshold for node memory usage percentage (0-100). Default: 80

        :return: A complete MonitoringConfig object ready to use in AksCluster props

        Example::

            // Custom thresholds and severities
            const aksCluster = new AksCluster(this, "aks", {
              // ... other properties ...
              monitoring: AksCluster.defaultMonitoring(
                actionGroup.id,
                workspace.id,
                {
                  nodeCpuThreshold: 90,
                  nodeMemoryThreshold: 90,
                  enableFailedPodAlert: false
                }
              )
            });
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__46b10b26cc64577f7e85914bec65b8bf51daa122e1c3307b6844e52aaf855112)
            check_type(argname="argument action_group_id", value=action_group_id, expected_type=type_hints["action_group_id"])
            check_type(argname="argument workspace_id", value=workspace_id, expected_type=type_hints["workspace_id"])
        options = _AksClusterMonitoringOptions_3f2d05a9(
            enable_deletion_alert=enable_deletion_alert,
            enable_failed_pod_alert=enable_failed_pod_alert,
            enable_node_cpu_alert=enable_node_cpu_alert,
            enable_node_memory_alert=enable_node_memory_alert,
            failed_pod_alert_severity=failed_pod_alert_severity,
            failed_pod_threshold=failed_pod_threshold,
            node_cpu_alert_severity=node_cpu_alert_severity,
            node_cpu_threshold=node_cpu_threshold,
            node_memory_alert_severity=node_memory_alert_severity,
            node_memory_threshold=node_memory_threshold,
        )

        return typing.cast(_MonitoringConfig_7c28df74, jsii.sinvoke(cls, "defaultMonitoring", [action_group_id, workspace_id, options]))

    @jsii.member(jsii_name="addTag")
    def add_tag(self, key: builtins.str, value: builtins.str) -> None:
        '''Add a tag to the AKS Cluster Note: This modifies the construct props but requires a new deployment to take effect.

        :param key: -
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e89f76fd8d364f429beb2a9e81ab74f5fc48ec61651e4cd34370af716f4a1601)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "addTag", [key, value]))

    @jsii.member(jsii_name="apiSchema")
    def _api_schema(self) -> _ApiSchema_5ce0490e:
        '''Gets the API schema for the resolved version Uses the framework's schema resolution to get the appropriate schema.'''
        return typing.cast(_ApiSchema_5ce0490e, jsii.invoke(self, "apiSchema", []))

    @jsii.member(jsii_name="createResourceBody")
    def _create_resource_body(self, props: typing.Any) -> typing.Any:
        '''Creates the resource body for the Azure API call Transforms the input properties into the JSON format expected by Azure REST API.

        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__914408e7b4492bb143cc0ce341d6ed178a8e79996e50e44b9e7b76f8e0be2339)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Any, jsii.invoke(self, "createResourceBody", [props]))

    @jsii.member(jsii_name="defaultVersion")
    def _default_version(self) -> builtins.str:
        '''Gets the default API version to use when no explicit version is specified Returns the most recent stable version as the default.'''
        return typing.cast(builtins.str, jsii.invoke(self, "defaultVersion", []))

    @jsii.member(jsii_name="removeTag")
    def remove_tag(self, key: builtins.str) -> None:
        '''Remove a tag from the AKS Cluster Note: This modifies the construct props but requires a new deployment to take effect.

        :param key: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7e362cc4e1ceb23d2c6011b2917cb1b83c6cb3ac3099e4ca3b5258d8a28c17de)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
        return typing.cast(None, jsii.invoke(self, "removeTag", [key]))

    @jsii.member(jsii_name="requiresLocation")
    def _requires_location(self) -> builtins.bool:
        '''Indicates that this resource requires a location.'''
        return typing.cast(builtins.bool, jsii.invoke(self, "requiresLocation", []))

    @jsii.member(jsii_name="resourceType")
    def _resource_type(self) -> builtins.str:
        '''Gets the Azure resource type for AKS Clusters.'''
        return typing.cast(builtins.str, jsii.invoke(self, "resourceType", []))

    @builtins.property
    @jsii.member(jsii_name="currentKubernetesVersion")
    def current_kubernetes_version(self) -> builtins.str:
        '''Get the current Kubernetes version running on the cluster.'''
        return typing.cast(builtins.str, jsii.get(self, "currentKubernetesVersion"))

    @builtins.property
    @jsii.member(jsii_name="fqdn")
    def fqdn(self) -> builtins.str:
        '''Get the FQDN of the cluster.'''
        return typing.cast(builtins.str, jsii.get(self, "fqdn"))

    @builtins.property
    @jsii.member(jsii_name="fqdnOutput")
    def fqdn_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "fqdnOutput"))

    @builtins.property
    @jsii.member(jsii_name="idOutput")
    def id_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "idOutput"))

    @builtins.property
    @jsii.member(jsii_name="kubeConfig")
    def kube_config(self) -> builtins.str:
        '''Get the Kubernetes configuration for the cluster.

        This retrieves the cluster admin credentials using an azapi_resource_action.
        The kubeConfig is base64 encoded and contains the full kubectl configuration.
        '''
        return typing.cast(builtins.str, jsii.get(self, "kubeConfig"))

    @builtins.property
    @jsii.member(jsii_name="locationOutput")
    def location_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "locationOutput"))

    @builtins.property
    @jsii.member(jsii_name="nameOutput")
    def name_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "nameOutput"))

    @builtins.property
    @jsii.member(jsii_name="nodeResourceGroupName")
    def node_resource_group_name(self) -> builtins.str:
        '''Get the node resource group name.'''
        return typing.cast(builtins.str, jsii.get(self, "nodeResourceGroupName"))

    @builtins.property
    @jsii.member(jsii_name="privateFqdn")
    def private_fqdn(self) -> builtins.str:
        '''Get the private FQDN of the cluster (if private cluster is enabled).'''
        return typing.cast(builtins.str, jsii.get(self, "privateFqdn"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def props(self) -> _AksClusterProps_df15bce7:
        '''The input properties for this AKS Cluster instance.'''
        return typing.cast(_AksClusterProps_df15bce7, jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="tagsOutput")
    def tags_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "tagsOutput"))


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.AksClusterAadProfile",
    jsii_struct_bases=[],
    name_mapping={
        "admin_group_object_i_ds": "adminGroupObjectIDs",
        "client_app_id": "clientAppID",
        "enable_azure_rbac": "enableAzureRBAC",
        "managed": "managed",
        "server_app_id": "serverAppID",
        "server_app_secret": "serverAppSecret",
        "tenant_id": "tenantID",
    },
)
class AksClusterAadProfile:
    def __init__(
        self,
        *,
        admin_group_object_i_ds: typing.Optional[typing.Sequence[builtins.str]] = None,
        client_app_id: typing.Optional[builtins.str] = None,
        enable_azure_rbac: typing.Optional[builtins.bool] = None,
        managed: typing.Optional[builtins.bool] = None,
        server_app_id: typing.Optional[builtins.str] = None,
        server_app_secret: typing.Optional[builtins.str] = None,
        tenant_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''AAD (Azure Active Directory) profile.

        :param admin_group_object_i_ds: 
        :param client_app_id: 
        :param enable_azure_rbac: 
        :param managed: 
        :param server_app_id: 
        :param server_app_secret: 
        :param tenant_id: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6dab5a457ca1a76fb41c7e089a6b600f5e8fda479824f671d11be22df9f72bb1)
            check_type(argname="argument admin_group_object_i_ds", value=admin_group_object_i_ds, expected_type=type_hints["admin_group_object_i_ds"])
            check_type(argname="argument client_app_id", value=client_app_id, expected_type=type_hints["client_app_id"])
            check_type(argname="argument enable_azure_rbac", value=enable_azure_rbac, expected_type=type_hints["enable_azure_rbac"])
            check_type(argname="argument managed", value=managed, expected_type=type_hints["managed"])
            check_type(argname="argument server_app_id", value=server_app_id, expected_type=type_hints["server_app_id"])
            check_type(argname="argument server_app_secret", value=server_app_secret, expected_type=type_hints["server_app_secret"])
            check_type(argname="argument tenant_id", value=tenant_id, expected_type=type_hints["tenant_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if admin_group_object_i_ds is not None:
            self._values["admin_group_object_i_ds"] = admin_group_object_i_ds
        if client_app_id is not None:
            self._values["client_app_id"] = client_app_id
        if enable_azure_rbac is not None:
            self._values["enable_azure_rbac"] = enable_azure_rbac
        if managed is not None:
            self._values["managed"] = managed
        if server_app_id is not None:
            self._values["server_app_id"] = server_app_id
        if server_app_secret is not None:
            self._values["server_app_secret"] = server_app_secret
        if tenant_id is not None:
            self._values["tenant_id"] = tenant_id

    @builtins.property
    def admin_group_object_i_ds(self) -> typing.Optional[typing.List[builtins.str]]:
        result = self._values.get("admin_group_object_i_ds")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def client_app_id(self) -> typing.Optional[builtins.str]:
        result = self._values.get("client_app_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def enable_azure_rbac(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("enable_azure_rbac")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def managed(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("managed")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def server_app_id(self) -> typing.Optional[builtins.str]:
        result = self._values.get("server_app_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def server_app_secret(self) -> typing.Optional[builtins.str]:
        result = self._values.get("server_app_secret")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tenant_id(self) -> typing.Optional[builtins.str]:
        result = self._values.get("tenant_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AksClusterAadProfile(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.AksClusterAddonProfile",
    jsii_struct_bases=[],
    name_mapping={"enabled": "enabled", "config": "config"},
)
class AksClusterAddonProfile:
    def __init__(
        self,
        *,
        enabled: builtins.bool,
        config: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''Individual addon profile.

        :param enabled: 
        :param config: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__64c09473f2c1532767f020b17c88a71b930b2460ff7081c98b807d7f0a6e5a1c)
            check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
            check_type(argname="argument config", value=config, expected_type=type_hints["config"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "enabled": enabled,
        }
        if config is not None:
            self._values["config"] = config

    @builtins.property
    def enabled(self) -> builtins.bool:
        result = self._values.get("enabled")
        assert result is not None, "Required property 'enabled' is missing"
        return typing.cast(builtins.bool, result)

    @builtins.property
    def config(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        result = self._values.get("config")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AksClusterAddonProfile(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.AksClusterAgentPoolProfile",
    jsii_struct_bases=[],
    name_mapping={
        "name": "name",
        "vm_size": "vmSize",
        "availability_zones": "availabilityZones",
        "count": "count",
        "enable_auto_scaling": "enableAutoScaling",
        "enable_encryption_at_host": "enableEncryptionAtHost",
        "enable_fips": "enableFIPS",
        "enable_node_public_ip": "enableNodePublicIP",
        "enable_ultra_ssd": "enableUltraSSD",
        "kubelet_config": "kubeletConfig",
        "linux_os_config": "linuxOSConfig",
        "max_count": "maxCount",
        "max_pods": "maxPods",
        "min_count": "minCount",
        "mode": "mode",
        "node_labels": "nodeLabels",
        "node_public_ip_prefix_id": "nodePublicIPPrefixID",
        "node_taints": "nodeTaints",
        "os_disk_size_gb": "osDiskSizeGB",
        "os_disk_type": "osDiskType",
        "os_type": "osType",
        "pod_subnet_id": "podSubnetID",
        "scale_set_eviction_policy": "scaleSetEvictionPolicy",
        "scale_set_priority": "scaleSetPriority",
        "spot_max_price": "spotMaxPrice",
        "type": "type",
        "vnet_subnet_id": "vnetSubnetID",
    },
)
class AksClusterAgentPoolProfile:
    def __init__(
        self,
        *,
        name: builtins.str,
        vm_size: builtins.str,
        availability_zones: typing.Optional[typing.Sequence[builtins.str]] = None,
        count: typing.Optional[jsii.Number] = None,
        enable_auto_scaling: typing.Optional[builtins.bool] = None,
        enable_encryption_at_host: typing.Optional[builtins.bool] = None,
        enable_fips: typing.Optional[builtins.bool] = None,
        enable_node_public_ip: typing.Optional[builtins.bool] = None,
        enable_ultra_ssd: typing.Optional[builtins.bool] = None,
        kubelet_config: typing.Optional[typing.Union[_AksClusterKubeletConfig_b1842d3f, typing.Dict[builtins.str, typing.Any]]] = None,
        linux_os_config: typing.Optional[typing.Union[_AksClusterLinuxOSConfig_c1e15359, typing.Dict[builtins.str, typing.Any]]] = None,
        max_count: typing.Optional[jsii.Number] = None,
        max_pods: typing.Optional[jsii.Number] = None,
        min_count: typing.Optional[jsii.Number] = None,
        mode: typing.Optional[builtins.str] = None,
        node_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        node_public_ip_prefix_id: typing.Optional[builtins.str] = None,
        node_taints: typing.Optional[typing.Sequence[builtins.str]] = None,
        os_disk_size_gb: typing.Optional[jsii.Number] = None,
        os_disk_type: typing.Optional[builtins.str] = None,
        os_type: typing.Optional[builtins.str] = None,
        pod_subnet_id: typing.Optional[builtins.str] = None,
        scale_set_eviction_policy: typing.Optional[builtins.str] = None,
        scale_set_priority: typing.Optional[builtins.str] = None,
        spot_max_price: typing.Optional[jsii.Number] = None,
        type: typing.Optional[builtins.str] = None,
        vnet_subnet_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Agent pool profile for AKS node pools.

        :param name: 
        :param vm_size: 
        :param availability_zones: 
        :param count: 
        :param enable_auto_scaling: 
        :param enable_encryption_at_host: 
        :param enable_fips: 
        :param enable_node_public_ip: 
        :param enable_ultra_ssd: 
        :param kubelet_config: 
        :param linux_os_config: 
        :param max_count: 
        :param max_pods: 
        :param min_count: 
        :param mode: 
        :param node_labels: 
        :param node_public_ip_prefix_id: 
        :param node_taints: 
        :param os_disk_size_gb: 
        :param os_disk_type: 
        :param os_type: 
        :param pod_subnet_id: 
        :param scale_set_eviction_policy: 
        :param scale_set_priority: 
        :param spot_max_price: 
        :param type: 
        :param vnet_subnet_id: 
        '''
        if isinstance(kubelet_config, dict):
            kubelet_config = _AksClusterKubeletConfig_b1842d3f(**kubelet_config)
        if isinstance(linux_os_config, dict):
            linux_os_config = _AksClusterLinuxOSConfig_c1e15359(**linux_os_config)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a537a7b05f8178e87b5d86b3e5f623ef8bb89ab52bf6408326036e738f9a971a)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument vm_size", value=vm_size, expected_type=type_hints["vm_size"])
            check_type(argname="argument availability_zones", value=availability_zones, expected_type=type_hints["availability_zones"])
            check_type(argname="argument count", value=count, expected_type=type_hints["count"])
            check_type(argname="argument enable_auto_scaling", value=enable_auto_scaling, expected_type=type_hints["enable_auto_scaling"])
            check_type(argname="argument enable_encryption_at_host", value=enable_encryption_at_host, expected_type=type_hints["enable_encryption_at_host"])
            check_type(argname="argument enable_fips", value=enable_fips, expected_type=type_hints["enable_fips"])
            check_type(argname="argument enable_node_public_ip", value=enable_node_public_ip, expected_type=type_hints["enable_node_public_ip"])
            check_type(argname="argument enable_ultra_ssd", value=enable_ultra_ssd, expected_type=type_hints["enable_ultra_ssd"])
            check_type(argname="argument kubelet_config", value=kubelet_config, expected_type=type_hints["kubelet_config"])
            check_type(argname="argument linux_os_config", value=linux_os_config, expected_type=type_hints["linux_os_config"])
            check_type(argname="argument max_count", value=max_count, expected_type=type_hints["max_count"])
            check_type(argname="argument max_pods", value=max_pods, expected_type=type_hints["max_pods"])
            check_type(argname="argument min_count", value=min_count, expected_type=type_hints["min_count"])
            check_type(argname="argument mode", value=mode, expected_type=type_hints["mode"])
            check_type(argname="argument node_labels", value=node_labels, expected_type=type_hints["node_labels"])
            check_type(argname="argument node_public_ip_prefix_id", value=node_public_ip_prefix_id, expected_type=type_hints["node_public_ip_prefix_id"])
            check_type(argname="argument node_taints", value=node_taints, expected_type=type_hints["node_taints"])
            check_type(argname="argument os_disk_size_gb", value=os_disk_size_gb, expected_type=type_hints["os_disk_size_gb"])
            check_type(argname="argument os_disk_type", value=os_disk_type, expected_type=type_hints["os_disk_type"])
            check_type(argname="argument os_type", value=os_type, expected_type=type_hints["os_type"])
            check_type(argname="argument pod_subnet_id", value=pod_subnet_id, expected_type=type_hints["pod_subnet_id"])
            check_type(argname="argument scale_set_eviction_policy", value=scale_set_eviction_policy, expected_type=type_hints["scale_set_eviction_policy"])
            check_type(argname="argument scale_set_priority", value=scale_set_priority, expected_type=type_hints["scale_set_priority"])
            check_type(argname="argument spot_max_price", value=spot_max_price, expected_type=type_hints["spot_max_price"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument vnet_subnet_id", value=vnet_subnet_id, expected_type=type_hints["vnet_subnet_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
            "vm_size": vm_size,
        }
        if availability_zones is not None:
            self._values["availability_zones"] = availability_zones
        if count is not None:
            self._values["count"] = count
        if enable_auto_scaling is not None:
            self._values["enable_auto_scaling"] = enable_auto_scaling
        if enable_encryption_at_host is not None:
            self._values["enable_encryption_at_host"] = enable_encryption_at_host
        if enable_fips is not None:
            self._values["enable_fips"] = enable_fips
        if enable_node_public_ip is not None:
            self._values["enable_node_public_ip"] = enable_node_public_ip
        if enable_ultra_ssd is not None:
            self._values["enable_ultra_ssd"] = enable_ultra_ssd
        if kubelet_config is not None:
            self._values["kubelet_config"] = kubelet_config
        if linux_os_config is not None:
            self._values["linux_os_config"] = linux_os_config
        if max_count is not None:
            self._values["max_count"] = max_count
        if max_pods is not None:
            self._values["max_pods"] = max_pods
        if min_count is not None:
            self._values["min_count"] = min_count
        if mode is not None:
            self._values["mode"] = mode
        if node_labels is not None:
            self._values["node_labels"] = node_labels
        if node_public_ip_prefix_id is not None:
            self._values["node_public_ip_prefix_id"] = node_public_ip_prefix_id
        if node_taints is not None:
            self._values["node_taints"] = node_taints
        if os_disk_size_gb is not None:
            self._values["os_disk_size_gb"] = os_disk_size_gb
        if os_disk_type is not None:
            self._values["os_disk_type"] = os_disk_type
        if os_type is not None:
            self._values["os_type"] = os_type
        if pod_subnet_id is not None:
            self._values["pod_subnet_id"] = pod_subnet_id
        if scale_set_eviction_policy is not None:
            self._values["scale_set_eviction_policy"] = scale_set_eviction_policy
        if scale_set_priority is not None:
            self._values["scale_set_priority"] = scale_set_priority
        if spot_max_price is not None:
            self._values["spot_max_price"] = spot_max_price
        if type is not None:
            self._values["type"] = type
        if vnet_subnet_id is not None:
            self._values["vnet_subnet_id"] = vnet_subnet_id

    @builtins.property
    def name(self) -> builtins.str:
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def vm_size(self) -> builtins.str:
        result = self._values.get("vm_size")
        assert result is not None, "Required property 'vm_size' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def availability_zones(self) -> typing.Optional[typing.List[builtins.str]]:
        result = self._values.get("availability_zones")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def count(self) -> typing.Optional[jsii.Number]:
        result = self._values.get("count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def enable_auto_scaling(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("enable_auto_scaling")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_encryption_at_host(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("enable_encryption_at_host")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_fips(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("enable_fips")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_node_public_ip(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("enable_node_public_ip")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_ultra_ssd(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("enable_ultra_ssd")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def kubelet_config(self) -> typing.Optional[_AksClusterKubeletConfig_b1842d3f]:
        result = self._values.get("kubelet_config")
        return typing.cast(typing.Optional[_AksClusterKubeletConfig_b1842d3f], result)

    @builtins.property
    def linux_os_config(self) -> typing.Optional[_AksClusterLinuxOSConfig_c1e15359]:
        result = self._values.get("linux_os_config")
        return typing.cast(typing.Optional[_AksClusterLinuxOSConfig_c1e15359], result)

    @builtins.property
    def max_count(self) -> typing.Optional[jsii.Number]:
        result = self._values.get("max_count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def max_pods(self) -> typing.Optional[jsii.Number]:
        result = self._values.get("max_pods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def min_count(self) -> typing.Optional[jsii.Number]:
        result = self._values.get("min_count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def mode(self) -> typing.Optional[builtins.str]:
        result = self._values.get("mode")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def node_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        result = self._values.get("node_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def node_public_ip_prefix_id(self) -> typing.Optional[builtins.str]:
        result = self._values.get("node_public_ip_prefix_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def node_taints(self) -> typing.Optional[typing.List[builtins.str]]:
        result = self._values.get("node_taints")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def os_disk_size_gb(self) -> typing.Optional[jsii.Number]:
        result = self._values.get("os_disk_size_gb")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def os_disk_type(self) -> typing.Optional[builtins.str]:
        result = self._values.get("os_disk_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def os_type(self) -> typing.Optional[builtins.str]:
        result = self._values.get("os_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def pod_subnet_id(self) -> typing.Optional[builtins.str]:
        result = self._values.get("pod_subnet_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def scale_set_eviction_policy(self) -> typing.Optional[builtins.str]:
        result = self._values.get("scale_set_eviction_policy")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def scale_set_priority(self) -> typing.Optional[builtins.str]:
        result = self._values.get("scale_set_priority")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def spot_max_price(self) -> typing.Optional[jsii.Number]:
        result = self._values.get("spot_max_price")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def type(self) -> typing.Optional[builtins.str]:
        result = self._values.get("type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def vnet_subnet_id(self) -> typing.Optional[builtins.str]:
        result = self._values.get("vnet_subnet_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AksClusterAgentPoolProfile(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.AksClusterApiServerAccessProfile",
    jsii_struct_bases=[],
    name_mapping={
        "authorized_ip_ranges": "authorizedIPRanges",
        "disable_run_command": "disableRunCommand",
        "enable_private_cluster": "enablePrivateCluster",
        "enable_private_cluster_public_fqdn": "enablePrivateClusterPublicFQDN",
        "enable_vnet_integration": "enableVnetIntegration",
        "private_dns_zone": "privateDNSZone",
        "subnet_id": "subnetId",
    },
)
class AksClusterApiServerAccessProfile:
    def __init__(
        self,
        *,
        authorized_ip_ranges: typing.Optional[typing.Sequence[builtins.str]] = None,
        disable_run_command: typing.Optional[builtins.bool] = None,
        enable_private_cluster: typing.Optional[builtins.bool] = None,
        enable_private_cluster_public_fqdn: typing.Optional[builtins.bool] = None,
        enable_vnet_integration: typing.Optional[builtins.bool] = None,
        private_dns_zone: typing.Optional[builtins.str] = None,
        subnet_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''API server access profile.

        :param authorized_ip_ranges: 
        :param disable_run_command: 
        :param enable_private_cluster: 
        :param enable_private_cluster_public_fqdn: 
        :param enable_vnet_integration: 
        :param private_dns_zone: 
        :param subnet_id: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c52a67f1465078a2e392f0027207382c4bcaeafbfa02bb3f3ca6b868bdf54136)
            check_type(argname="argument authorized_ip_ranges", value=authorized_ip_ranges, expected_type=type_hints["authorized_ip_ranges"])
            check_type(argname="argument disable_run_command", value=disable_run_command, expected_type=type_hints["disable_run_command"])
            check_type(argname="argument enable_private_cluster", value=enable_private_cluster, expected_type=type_hints["enable_private_cluster"])
            check_type(argname="argument enable_private_cluster_public_fqdn", value=enable_private_cluster_public_fqdn, expected_type=type_hints["enable_private_cluster_public_fqdn"])
            check_type(argname="argument enable_vnet_integration", value=enable_vnet_integration, expected_type=type_hints["enable_vnet_integration"])
            check_type(argname="argument private_dns_zone", value=private_dns_zone, expected_type=type_hints["private_dns_zone"])
            check_type(argname="argument subnet_id", value=subnet_id, expected_type=type_hints["subnet_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if authorized_ip_ranges is not None:
            self._values["authorized_ip_ranges"] = authorized_ip_ranges
        if disable_run_command is not None:
            self._values["disable_run_command"] = disable_run_command
        if enable_private_cluster is not None:
            self._values["enable_private_cluster"] = enable_private_cluster
        if enable_private_cluster_public_fqdn is not None:
            self._values["enable_private_cluster_public_fqdn"] = enable_private_cluster_public_fqdn
        if enable_vnet_integration is not None:
            self._values["enable_vnet_integration"] = enable_vnet_integration
        if private_dns_zone is not None:
            self._values["private_dns_zone"] = private_dns_zone
        if subnet_id is not None:
            self._values["subnet_id"] = subnet_id

    @builtins.property
    def authorized_ip_ranges(self) -> typing.Optional[typing.List[builtins.str]]:
        result = self._values.get("authorized_ip_ranges")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def disable_run_command(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("disable_run_command")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_private_cluster(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("enable_private_cluster")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_private_cluster_public_fqdn(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("enable_private_cluster_public_fqdn")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_vnet_integration(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("enable_vnet_integration")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def private_dns_zone(self) -> typing.Optional[builtins.str]:
        result = self._values.get("private_dns_zone")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def subnet_id(self) -> typing.Optional[builtins.str]:
        result = self._values.get("subnet_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AksClusterApiServerAccessProfile(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.AksClusterAutoScalerProfile",
    jsii_struct_bases=[],
    name_mapping={
        "balance_similar_node_groups": "balanceSimilarNodeGroups",
        "expander": "expander",
        "max_empty_bulk_delete": "maxEmptyBulkDelete",
        "max_graceful_termination_sec": "maxGracefulTerminationSec",
        "max_node_provision_time": "maxNodeProvisionTime",
        "max_total_unready_percentage": "maxTotalUnreadyPercentage",
        "new_pod_scale_up_delay": "newPodScaleUpDelay",
        "ok_total_unready_count": "okTotalUnreadyCount",
        "scale_down_delay_after_add": "scaleDownDelayAfterAdd",
        "scale_down_delay_after_delete": "scaleDownDelayAfterDelete",
        "scale_down_delay_after_failure": "scaleDownDelayAfterFailure",
        "scale_down_unneeded_time": "scaleDownUnneededTime",
        "scale_down_unready_time": "scaleDownUnreadyTime",
        "scale_down_utilization_threshold": "scaleDownUtilizationThreshold",
        "scan_interval": "scanInterval",
        "skip_nodes_with_local_storage": "skipNodesWithLocalStorage",
        "skip_nodes_with_system_pods": "skipNodesWithSystemPods",
    },
)
class AksClusterAutoScalerProfile:
    def __init__(
        self,
        *,
        balance_similar_node_groups: typing.Optional[builtins.str] = None,
        expander: typing.Optional[builtins.str] = None,
        max_empty_bulk_delete: typing.Optional[builtins.str] = None,
        max_graceful_termination_sec: typing.Optional[builtins.str] = None,
        max_node_provision_time: typing.Optional[builtins.str] = None,
        max_total_unready_percentage: typing.Optional[builtins.str] = None,
        new_pod_scale_up_delay: typing.Optional[builtins.str] = None,
        ok_total_unready_count: typing.Optional[builtins.str] = None,
        scale_down_delay_after_add: typing.Optional[builtins.str] = None,
        scale_down_delay_after_delete: typing.Optional[builtins.str] = None,
        scale_down_delay_after_failure: typing.Optional[builtins.str] = None,
        scale_down_unneeded_time: typing.Optional[builtins.str] = None,
        scale_down_unready_time: typing.Optional[builtins.str] = None,
        scale_down_utilization_threshold: typing.Optional[builtins.str] = None,
        scan_interval: typing.Optional[builtins.str] = None,
        skip_nodes_with_local_storage: typing.Optional[builtins.str] = None,
        skip_nodes_with_system_pods: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Auto-scaler profile.

        :param balance_similar_node_groups: 
        :param expander: 
        :param max_empty_bulk_delete: 
        :param max_graceful_termination_sec: 
        :param max_node_provision_time: 
        :param max_total_unready_percentage: 
        :param new_pod_scale_up_delay: 
        :param ok_total_unready_count: 
        :param scale_down_delay_after_add: 
        :param scale_down_delay_after_delete: 
        :param scale_down_delay_after_failure: 
        :param scale_down_unneeded_time: 
        :param scale_down_unready_time: 
        :param scale_down_utilization_threshold: 
        :param scan_interval: 
        :param skip_nodes_with_local_storage: 
        :param skip_nodes_with_system_pods: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__27d44cd231d1581bf04ba0c78d68d733df318083d72d37dbb667a88cdd672265)
            check_type(argname="argument balance_similar_node_groups", value=balance_similar_node_groups, expected_type=type_hints["balance_similar_node_groups"])
            check_type(argname="argument expander", value=expander, expected_type=type_hints["expander"])
            check_type(argname="argument max_empty_bulk_delete", value=max_empty_bulk_delete, expected_type=type_hints["max_empty_bulk_delete"])
            check_type(argname="argument max_graceful_termination_sec", value=max_graceful_termination_sec, expected_type=type_hints["max_graceful_termination_sec"])
            check_type(argname="argument max_node_provision_time", value=max_node_provision_time, expected_type=type_hints["max_node_provision_time"])
            check_type(argname="argument max_total_unready_percentage", value=max_total_unready_percentage, expected_type=type_hints["max_total_unready_percentage"])
            check_type(argname="argument new_pod_scale_up_delay", value=new_pod_scale_up_delay, expected_type=type_hints["new_pod_scale_up_delay"])
            check_type(argname="argument ok_total_unready_count", value=ok_total_unready_count, expected_type=type_hints["ok_total_unready_count"])
            check_type(argname="argument scale_down_delay_after_add", value=scale_down_delay_after_add, expected_type=type_hints["scale_down_delay_after_add"])
            check_type(argname="argument scale_down_delay_after_delete", value=scale_down_delay_after_delete, expected_type=type_hints["scale_down_delay_after_delete"])
            check_type(argname="argument scale_down_delay_after_failure", value=scale_down_delay_after_failure, expected_type=type_hints["scale_down_delay_after_failure"])
            check_type(argname="argument scale_down_unneeded_time", value=scale_down_unneeded_time, expected_type=type_hints["scale_down_unneeded_time"])
            check_type(argname="argument scale_down_unready_time", value=scale_down_unready_time, expected_type=type_hints["scale_down_unready_time"])
            check_type(argname="argument scale_down_utilization_threshold", value=scale_down_utilization_threshold, expected_type=type_hints["scale_down_utilization_threshold"])
            check_type(argname="argument scan_interval", value=scan_interval, expected_type=type_hints["scan_interval"])
            check_type(argname="argument skip_nodes_with_local_storage", value=skip_nodes_with_local_storage, expected_type=type_hints["skip_nodes_with_local_storage"])
            check_type(argname="argument skip_nodes_with_system_pods", value=skip_nodes_with_system_pods, expected_type=type_hints["skip_nodes_with_system_pods"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if balance_similar_node_groups is not None:
            self._values["balance_similar_node_groups"] = balance_similar_node_groups
        if expander is not None:
            self._values["expander"] = expander
        if max_empty_bulk_delete is not None:
            self._values["max_empty_bulk_delete"] = max_empty_bulk_delete
        if max_graceful_termination_sec is not None:
            self._values["max_graceful_termination_sec"] = max_graceful_termination_sec
        if max_node_provision_time is not None:
            self._values["max_node_provision_time"] = max_node_provision_time
        if max_total_unready_percentage is not None:
            self._values["max_total_unready_percentage"] = max_total_unready_percentage
        if new_pod_scale_up_delay is not None:
            self._values["new_pod_scale_up_delay"] = new_pod_scale_up_delay
        if ok_total_unready_count is not None:
            self._values["ok_total_unready_count"] = ok_total_unready_count
        if scale_down_delay_after_add is not None:
            self._values["scale_down_delay_after_add"] = scale_down_delay_after_add
        if scale_down_delay_after_delete is not None:
            self._values["scale_down_delay_after_delete"] = scale_down_delay_after_delete
        if scale_down_delay_after_failure is not None:
            self._values["scale_down_delay_after_failure"] = scale_down_delay_after_failure
        if scale_down_unneeded_time is not None:
            self._values["scale_down_unneeded_time"] = scale_down_unneeded_time
        if scale_down_unready_time is not None:
            self._values["scale_down_unready_time"] = scale_down_unready_time
        if scale_down_utilization_threshold is not None:
            self._values["scale_down_utilization_threshold"] = scale_down_utilization_threshold
        if scan_interval is not None:
            self._values["scan_interval"] = scan_interval
        if skip_nodes_with_local_storage is not None:
            self._values["skip_nodes_with_local_storage"] = skip_nodes_with_local_storage
        if skip_nodes_with_system_pods is not None:
            self._values["skip_nodes_with_system_pods"] = skip_nodes_with_system_pods

    @builtins.property
    def balance_similar_node_groups(self) -> typing.Optional[builtins.str]:
        result = self._values.get("balance_similar_node_groups")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def expander(self) -> typing.Optional[builtins.str]:
        result = self._values.get("expander")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def max_empty_bulk_delete(self) -> typing.Optional[builtins.str]:
        result = self._values.get("max_empty_bulk_delete")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def max_graceful_termination_sec(self) -> typing.Optional[builtins.str]:
        result = self._values.get("max_graceful_termination_sec")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def max_node_provision_time(self) -> typing.Optional[builtins.str]:
        result = self._values.get("max_node_provision_time")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def max_total_unready_percentage(self) -> typing.Optional[builtins.str]:
        result = self._values.get("max_total_unready_percentage")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def new_pod_scale_up_delay(self) -> typing.Optional[builtins.str]:
        result = self._values.get("new_pod_scale_up_delay")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ok_total_unready_count(self) -> typing.Optional[builtins.str]:
        result = self._values.get("ok_total_unready_count")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def scale_down_delay_after_add(self) -> typing.Optional[builtins.str]:
        result = self._values.get("scale_down_delay_after_add")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def scale_down_delay_after_delete(self) -> typing.Optional[builtins.str]:
        result = self._values.get("scale_down_delay_after_delete")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def scale_down_delay_after_failure(self) -> typing.Optional[builtins.str]:
        result = self._values.get("scale_down_delay_after_failure")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def scale_down_unneeded_time(self) -> typing.Optional[builtins.str]:
        result = self._values.get("scale_down_unneeded_time")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def scale_down_unready_time(self) -> typing.Optional[builtins.str]:
        result = self._values.get("scale_down_unready_time")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def scale_down_utilization_threshold(self) -> typing.Optional[builtins.str]:
        result = self._values.get("scale_down_utilization_threshold")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def scan_interval(self) -> typing.Optional[builtins.str]:
        result = self._values.get("scan_interval")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def skip_nodes_with_local_storage(self) -> typing.Optional[builtins.str]:
        result = self._values.get("skip_nodes_with_local_storage")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def skip_nodes_with_system_pods(self) -> typing.Optional[builtins.str]:
        result = self._values.get("skip_nodes_with_system_pods")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AksClusterAutoScalerProfile(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.AksClusterAzureKeyVaultKms",
    jsii_struct_bases=[],
    name_mapping={
        "enabled": "enabled",
        "key_id": "keyId",
        "key_vault_network_access": "keyVaultNetworkAccess",
        "key_vault_resource_id": "keyVaultResourceId",
    },
)
class AksClusterAzureKeyVaultKms:
    def __init__(
        self,
        *,
        enabled: typing.Optional[builtins.bool] = None,
        key_id: typing.Optional[builtins.str] = None,
        key_vault_network_access: typing.Optional[builtins.str] = None,
        key_vault_resource_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Azure Key Vault KMS configuration.

        :param enabled: 
        :param key_id: 
        :param key_vault_network_access: 
        :param key_vault_resource_id: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__35c1a80cd984ed49f9ef34d1ef9ffba7d83c37059888c8cdd57e29a03eff8621)
            check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
            check_type(argname="argument key_id", value=key_id, expected_type=type_hints["key_id"])
            check_type(argname="argument key_vault_network_access", value=key_vault_network_access, expected_type=type_hints["key_vault_network_access"])
            check_type(argname="argument key_vault_resource_id", value=key_vault_resource_id, expected_type=type_hints["key_vault_resource_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if enabled is not None:
            self._values["enabled"] = enabled
        if key_id is not None:
            self._values["key_id"] = key_id
        if key_vault_network_access is not None:
            self._values["key_vault_network_access"] = key_vault_network_access
        if key_vault_resource_id is not None:
            self._values["key_vault_resource_id"] = key_vault_resource_id

    @builtins.property
    def enabled(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def key_id(self) -> typing.Optional[builtins.str]:
        result = self._values.get("key_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def key_vault_network_access(self) -> typing.Optional[builtins.str]:
        result = self._values.get("key_vault_network_access")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def key_vault_resource_id(self) -> typing.Optional[builtins.str]:
        result = self._values.get("key_vault_resource_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AksClusterAzureKeyVaultKms(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.AksClusterBlobCSIDriver",
    jsii_struct_bases=[],
    name_mapping={"enabled": "enabled"},
)
class AksClusterBlobCSIDriver:
    def __init__(self, *, enabled: typing.Optional[builtins.bool] = None) -> None:
        '''Blob CSI driver.

        :param enabled: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__68f72dd3c4005788434cd0b5f90061523421acfc118adba70877c587d489a350)
            check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if enabled is not None:
            self._values["enabled"] = enabled

    @builtins.property
    def enabled(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AksClusterBlobCSIDriver(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.AksClusterBody",
    jsii_struct_bases=[],
    name_mapping={
        "location": "location",
        "properties": "properties",
        "identity": "identity",
        "sku": "sku",
        "tags": "tags",
    },
)
class AksClusterBody:
    def __init__(
        self,
        *,
        location: builtins.str,
        properties: typing.Union[_AksClusterBodyProperties_ba40e5e9, typing.Dict[builtins.str, typing.Any]],
        identity: typing.Optional[typing.Union[_AksClusterIdentity_92ed97a4, typing.Dict[builtins.str, typing.Any]]] = None,
        sku: typing.Optional[typing.Union[_AksClusterSku_746ad049, typing.Dict[builtins.str, typing.Any]]] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''The resource body interface for Azure AKS API calls.

        :param location: 
        :param properties: 
        :param identity: 
        :param sku: 
        :param tags: 
        '''
        if isinstance(properties, dict):
            properties = _AksClusterBodyProperties_ba40e5e9(**properties)
        if isinstance(identity, dict):
            identity = _AksClusterIdentity_92ed97a4(**identity)
        if isinstance(sku, dict):
            sku = _AksClusterSku_746ad049(**sku)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f3b56b82118e0e0a86a210d8472a2228a98e7ce4084a46dc2d71d51d48114e51)
            check_type(argname="argument location", value=location, expected_type=type_hints["location"])
            check_type(argname="argument properties", value=properties, expected_type=type_hints["properties"])
            check_type(argname="argument identity", value=identity, expected_type=type_hints["identity"])
            check_type(argname="argument sku", value=sku, expected_type=type_hints["sku"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "location": location,
            "properties": properties,
        }
        if identity is not None:
            self._values["identity"] = identity
        if sku is not None:
            self._values["sku"] = sku
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def location(self) -> builtins.str:
        result = self._values.get("location")
        assert result is not None, "Required property 'location' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def properties(self) -> _AksClusterBodyProperties_ba40e5e9:
        result = self._values.get("properties")
        assert result is not None, "Required property 'properties' is missing"
        return typing.cast(_AksClusterBodyProperties_ba40e5e9, result)

    @builtins.property
    def identity(self) -> typing.Optional[_AksClusterIdentity_92ed97a4]:
        result = self._values.get("identity")
        return typing.cast(typing.Optional[_AksClusterIdentity_92ed97a4], result)

    @builtins.property
    def sku(self) -> typing.Optional[_AksClusterSku_746ad049]:
        result = self._values.get("sku")
        return typing.cast(typing.Optional[_AksClusterSku_746ad049], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AksClusterBody(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.AksClusterBodyProperties",
    jsii_struct_bases=[],
    name_mapping={
        "agent_pool_profiles": "agentPoolProfiles",
        "dns_prefix": "dnsPrefix",
        "aad_profile": "aadProfile",
        "addon_profiles": "addonProfiles",
        "api_server_access_profile": "apiServerAccessProfile",
        "auto_scaler_profile": "autoScalerProfile",
        "disable_local_accounts": "disableLocalAccounts",
        "disk_encryption_set_id": "diskEncryptionSetID",
        "enable_rbac": "enableRBAC",
        "fqdn": "fqdn",
        "http_proxy_config": "httpProxyConfig",
        "kubernetes_version": "kubernetesVersion",
        "linux_profile": "linuxProfile",
        "network_profile": "networkProfile",
        "node_resource_group": "nodeResourceGroup",
        "oidc_issuer_profile": "oidcIssuerProfile",
        "private_fqdn": "privateFQDN",
        "public_network_access": "publicNetworkAccess",
        "security_profile": "securityProfile",
        "service_principal_profile": "servicePrincipalProfile",
        "storage_profile": "storageProfile",
        "support_plan": "supportPlan",
        "windows_profile": "windowsProfile",
        "workload_auto_scaler_profile": "workloadAutoScalerProfile",
    },
)
class AksClusterBodyProperties:
    def __init__(
        self,
        *,
        agent_pool_profiles: typing.Sequence[typing.Union[_AksClusterAgentPoolProfile_19702e0d, typing.Dict[builtins.str, typing.Any]]],
        dns_prefix: builtins.str,
        aad_profile: typing.Optional[typing.Union[_AksClusterAadProfile_cbb39e4e, typing.Dict[builtins.str, typing.Any]]] = None,
        addon_profiles: typing.Optional[typing.Mapping[builtins.str, typing.Union[_AksClusterAddonProfile_75e5bc97, typing.Dict[builtins.str, typing.Any]]]] = None,
        api_server_access_profile: typing.Optional[typing.Union[_AksClusterApiServerAccessProfile_a245e705, typing.Dict[builtins.str, typing.Any]]] = None,
        auto_scaler_profile: typing.Optional[typing.Union[_AksClusterAutoScalerProfile_15ae7fd0, typing.Dict[builtins.str, typing.Any]]] = None,
        disable_local_accounts: typing.Optional[builtins.bool] = None,
        disk_encryption_set_id: typing.Optional[builtins.str] = None,
        enable_rbac: typing.Optional[builtins.bool] = None,
        fqdn: typing.Optional[builtins.str] = None,
        http_proxy_config: typing.Optional[typing.Union[_AksClusterHttpProxyConfig_41bff94e, typing.Dict[builtins.str, typing.Any]]] = None,
        kubernetes_version: typing.Optional[builtins.str] = None,
        linux_profile: typing.Optional[typing.Union[_AksClusterLinuxProfile_516beb3b, typing.Dict[builtins.str, typing.Any]]] = None,
        network_profile: typing.Optional[typing.Union[_AksClusterNetworkProfile_ec57fbab, typing.Dict[builtins.str, typing.Any]]] = None,
        node_resource_group: typing.Optional[builtins.str] = None,
        oidc_issuer_profile: typing.Optional[typing.Union[_AksClusterOidcIssuerProfile_55bd4791, typing.Dict[builtins.str, typing.Any]]] = None,
        private_fqdn: typing.Optional[builtins.str] = None,
        public_network_access: typing.Optional[builtins.str] = None,
        security_profile: typing.Optional[typing.Union[_AksClusterSecurityProfile_6e20ee0b, typing.Dict[builtins.str, typing.Any]]] = None,
        service_principal_profile: typing.Optional[typing.Union[_AksClusterServicePrincipalProfile_5638b9c4, typing.Dict[builtins.str, typing.Any]]] = None,
        storage_profile: typing.Optional[typing.Union[_AksClusterStorageProfile_cc359e1f, typing.Dict[builtins.str, typing.Any]]] = None,
        support_plan: typing.Optional[builtins.str] = None,
        windows_profile: typing.Optional[typing.Union[_AksClusterWindowsProfile_bf96f6e4, typing.Dict[builtins.str, typing.Any]]] = None,
        workload_auto_scaler_profile: typing.Optional[typing.Union[_AksClusterWorkloadAutoScalerProfile_ec94d7bc, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''AKS Cluster properties for the request body.

        :param agent_pool_profiles: 
        :param dns_prefix: 
        :param aad_profile: 
        :param addon_profiles: 
        :param api_server_access_profile: 
        :param auto_scaler_profile: 
        :param disable_local_accounts: 
        :param disk_encryption_set_id: 
        :param enable_rbac: 
        :param fqdn: 
        :param http_proxy_config: 
        :param kubernetes_version: 
        :param linux_profile: 
        :param network_profile: 
        :param node_resource_group: 
        :param oidc_issuer_profile: 
        :param private_fqdn: 
        :param public_network_access: 
        :param security_profile: 
        :param service_principal_profile: 
        :param storage_profile: 
        :param support_plan: 
        :param windows_profile: 
        :param workload_auto_scaler_profile: 
        '''
        if isinstance(aad_profile, dict):
            aad_profile = _AksClusterAadProfile_cbb39e4e(**aad_profile)
        if isinstance(api_server_access_profile, dict):
            api_server_access_profile = _AksClusterApiServerAccessProfile_a245e705(**api_server_access_profile)
        if isinstance(auto_scaler_profile, dict):
            auto_scaler_profile = _AksClusterAutoScalerProfile_15ae7fd0(**auto_scaler_profile)
        if isinstance(http_proxy_config, dict):
            http_proxy_config = _AksClusterHttpProxyConfig_41bff94e(**http_proxy_config)
        if isinstance(linux_profile, dict):
            linux_profile = _AksClusterLinuxProfile_516beb3b(**linux_profile)
        if isinstance(network_profile, dict):
            network_profile = _AksClusterNetworkProfile_ec57fbab(**network_profile)
        if isinstance(oidc_issuer_profile, dict):
            oidc_issuer_profile = _AksClusterOidcIssuerProfile_55bd4791(**oidc_issuer_profile)
        if isinstance(security_profile, dict):
            security_profile = _AksClusterSecurityProfile_6e20ee0b(**security_profile)
        if isinstance(service_principal_profile, dict):
            service_principal_profile = _AksClusterServicePrincipalProfile_5638b9c4(**service_principal_profile)
        if isinstance(storage_profile, dict):
            storage_profile = _AksClusterStorageProfile_cc359e1f(**storage_profile)
        if isinstance(windows_profile, dict):
            windows_profile = _AksClusterWindowsProfile_bf96f6e4(**windows_profile)
        if isinstance(workload_auto_scaler_profile, dict):
            workload_auto_scaler_profile = _AksClusterWorkloadAutoScalerProfile_ec94d7bc(**workload_auto_scaler_profile)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4e106b503aa414d1dfd91bba7d4a82f01848d7d4717f25b951e74ff27b8e39d6)
            check_type(argname="argument agent_pool_profiles", value=agent_pool_profiles, expected_type=type_hints["agent_pool_profiles"])
            check_type(argname="argument dns_prefix", value=dns_prefix, expected_type=type_hints["dns_prefix"])
            check_type(argname="argument aad_profile", value=aad_profile, expected_type=type_hints["aad_profile"])
            check_type(argname="argument addon_profiles", value=addon_profiles, expected_type=type_hints["addon_profiles"])
            check_type(argname="argument api_server_access_profile", value=api_server_access_profile, expected_type=type_hints["api_server_access_profile"])
            check_type(argname="argument auto_scaler_profile", value=auto_scaler_profile, expected_type=type_hints["auto_scaler_profile"])
            check_type(argname="argument disable_local_accounts", value=disable_local_accounts, expected_type=type_hints["disable_local_accounts"])
            check_type(argname="argument disk_encryption_set_id", value=disk_encryption_set_id, expected_type=type_hints["disk_encryption_set_id"])
            check_type(argname="argument enable_rbac", value=enable_rbac, expected_type=type_hints["enable_rbac"])
            check_type(argname="argument fqdn", value=fqdn, expected_type=type_hints["fqdn"])
            check_type(argname="argument http_proxy_config", value=http_proxy_config, expected_type=type_hints["http_proxy_config"])
            check_type(argname="argument kubernetes_version", value=kubernetes_version, expected_type=type_hints["kubernetes_version"])
            check_type(argname="argument linux_profile", value=linux_profile, expected_type=type_hints["linux_profile"])
            check_type(argname="argument network_profile", value=network_profile, expected_type=type_hints["network_profile"])
            check_type(argname="argument node_resource_group", value=node_resource_group, expected_type=type_hints["node_resource_group"])
            check_type(argname="argument oidc_issuer_profile", value=oidc_issuer_profile, expected_type=type_hints["oidc_issuer_profile"])
            check_type(argname="argument private_fqdn", value=private_fqdn, expected_type=type_hints["private_fqdn"])
            check_type(argname="argument public_network_access", value=public_network_access, expected_type=type_hints["public_network_access"])
            check_type(argname="argument security_profile", value=security_profile, expected_type=type_hints["security_profile"])
            check_type(argname="argument service_principal_profile", value=service_principal_profile, expected_type=type_hints["service_principal_profile"])
            check_type(argname="argument storage_profile", value=storage_profile, expected_type=type_hints["storage_profile"])
            check_type(argname="argument support_plan", value=support_plan, expected_type=type_hints["support_plan"])
            check_type(argname="argument windows_profile", value=windows_profile, expected_type=type_hints["windows_profile"])
            check_type(argname="argument workload_auto_scaler_profile", value=workload_auto_scaler_profile, expected_type=type_hints["workload_auto_scaler_profile"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "agent_pool_profiles": agent_pool_profiles,
            "dns_prefix": dns_prefix,
        }
        if aad_profile is not None:
            self._values["aad_profile"] = aad_profile
        if addon_profiles is not None:
            self._values["addon_profiles"] = addon_profiles
        if api_server_access_profile is not None:
            self._values["api_server_access_profile"] = api_server_access_profile
        if auto_scaler_profile is not None:
            self._values["auto_scaler_profile"] = auto_scaler_profile
        if disable_local_accounts is not None:
            self._values["disable_local_accounts"] = disable_local_accounts
        if disk_encryption_set_id is not None:
            self._values["disk_encryption_set_id"] = disk_encryption_set_id
        if enable_rbac is not None:
            self._values["enable_rbac"] = enable_rbac
        if fqdn is not None:
            self._values["fqdn"] = fqdn
        if http_proxy_config is not None:
            self._values["http_proxy_config"] = http_proxy_config
        if kubernetes_version is not None:
            self._values["kubernetes_version"] = kubernetes_version
        if linux_profile is not None:
            self._values["linux_profile"] = linux_profile
        if network_profile is not None:
            self._values["network_profile"] = network_profile
        if node_resource_group is not None:
            self._values["node_resource_group"] = node_resource_group
        if oidc_issuer_profile is not None:
            self._values["oidc_issuer_profile"] = oidc_issuer_profile
        if private_fqdn is not None:
            self._values["private_fqdn"] = private_fqdn
        if public_network_access is not None:
            self._values["public_network_access"] = public_network_access
        if security_profile is not None:
            self._values["security_profile"] = security_profile
        if service_principal_profile is not None:
            self._values["service_principal_profile"] = service_principal_profile
        if storage_profile is not None:
            self._values["storage_profile"] = storage_profile
        if support_plan is not None:
            self._values["support_plan"] = support_plan
        if windows_profile is not None:
            self._values["windows_profile"] = windows_profile
        if workload_auto_scaler_profile is not None:
            self._values["workload_auto_scaler_profile"] = workload_auto_scaler_profile

    @builtins.property
    def agent_pool_profiles(self) -> typing.List[_AksClusterAgentPoolProfile_19702e0d]:
        result = self._values.get("agent_pool_profiles")
        assert result is not None, "Required property 'agent_pool_profiles' is missing"
        return typing.cast(typing.List[_AksClusterAgentPoolProfile_19702e0d], result)

    @builtins.property
    def dns_prefix(self) -> builtins.str:
        result = self._values.get("dns_prefix")
        assert result is not None, "Required property 'dns_prefix' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def aad_profile(self) -> typing.Optional[_AksClusterAadProfile_cbb39e4e]:
        result = self._values.get("aad_profile")
        return typing.cast(typing.Optional[_AksClusterAadProfile_cbb39e4e], result)

    @builtins.property
    def addon_profiles(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, _AksClusterAddonProfile_75e5bc97]]:
        result = self._values.get("addon_profiles")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, _AksClusterAddonProfile_75e5bc97]], result)

    @builtins.property
    def api_server_access_profile(
        self,
    ) -> typing.Optional[_AksClusterApiServerAccessProfile_a245e705]:
        result = self._values.get("api_server_access_profile")
        return typing.cast(typing.Optional[_AksClusterApiServerAccessProfile_a245e705], result)

    @builtins.property
    def auto_scaler_profile(
        self,
    ) -> typing.Optional[_AksClusterAutoScalerProfile_15ae7fd0]:
        result = self._values.get("auto_scaler_profile")
        return typing.cast(typing.Optional[_AksClusterAutoScalerProfile_15ae7fd0], result)

    @builtins.property
    def disable_local_accounts(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("disable_local_accounts")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def disk_encryption_set_id(self) -> typing.Optional[builtins.str]:
        result = self._values.get("disk_encryption_set_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def enable_rbac(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("enable_rbac")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def fqdn(self) -> typing.Optional[builtins.str]:
        result = self._values.get("fqdn")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def http_proxy_config(self) -> typing.Optional[_AksClusterHttpProxyConfig_41bff94e]:
        result = self._values.get("http_proxy_config")
        return typing.cast(typing.Optional[_AksClusterHttpProxyConfig_41bff94e], result)

    @builtins.property
    def kubernetes_version(self) -> typing.Optional[builtins.str]:
        result = self._values.get("kubernetes_version")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def linux_profile(self) -> typing.Optional[_AksClusterLinuxProfile_516beb3b]:
        result = self._values.get("linux_profile")
        return typing.cast(typing.Optional[_AksClusterLinuxProfile_516beb3b], result)

    @builtins.property
    def network_profile(self) -> typing.Optional[_AksClusterNetworkProfile_ec57fbab]:
        result = self._values.get("network_profile")
        return typing.cast(typing.Optional[_AksClusterNetworkProfile_ec57fbab], result)

    @builtins.property
    def node_resource_group(self) -> typing.Optional[builtins.str]:
        result = self._values.get("node_resource_group")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def oidc_issuer_profile(
        self,
    ) -> typing.Optional[_AksClusterOidcIssuerProfile_55bd4791]:
        result = self._values.get("oidc_issuer_profile")
        return typing.cast(typing.Optional[_AksClusterOidcIssuerProfile_55bd4791], result)

    @builtins.property
    def private_fqdn(self) -> typing.Optional[builtins.str]:
        result = self._values.get("private_fqdn")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def public_network_access(self) -> typing.Optional[builtins.str]:
        result = self._values.get("public_network_access")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def security_profile(self) -> typing.Optional[_AksClusterSecurityProfile_6e20ee0b]:
        result = self._values.get("security_profile")
        return typing.cast(typing.Optional[_AksClusterSecurityProfile_6e20ee0b], result)

    @builtins.property
    def service_principal_profile(
        self,
    ) -> typing.Optional[_AksClusterServicePrincipalProfile_5638b9c4]:
        result = self._values.get("service_principal_profile")
        return typing.cast(typing.Optional[_AksClusterServicePrincipalProfile_5638b9c4], result)

    @builtins.property
    def storage_profile(self) -> typing.Optional[_AksClusterStorageProfile_cc359e1f]:
        result = self._values.get("storage_profile")
        return typing.cast(typing.Optional[_AksClusterStorageProfile_cc359e1f], result)

    @builtins.property
    def support_plan(self) -> typing.Optional[builtins.str]:
        result = self._values.get("support_plan")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def windows_profile(self) -> typing.Optional[_AksClusterWindowsProfile_bf96f6e4]:
        result = self._values.get("windows_profile")
        return typing.cast(typing.Optional[_AksClusterWindowsProfile_bf96f6e4], result)

    @builtins.property
    def workload_auto_scaler_profile(
        self,
    ) -> typing.Optional[_AksClusterWorkloadAutoScalerProfile_ec94d7bc]:
        result = self._values.get("workload_auto_scaler_profile")
        return typing.cast(typing.Optional[_AksClusterWorkloadAutoScalerProfile_ec94d7bc], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AksClusterBodyProperties(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.AksClusterDefenderSecurityMonitoring",
    jsii_struct_bases=[],
    name_mapping={
        "enabled": "enabled",
        "log_analytics_workspace_resource_id": "logAnalyticsWorkspaceResourceId",
    },
)
class AksClusterDefenderSecurityMonitoring:
    def __init__(
        self,
        *,
        enabled: typing.Optional[builtins.bool] = None,
        log_analytics_workspace_resource_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Defender security monitoring.

        :param enabled: 
        :param log_analytics_workspace_resource_id: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__db582d372bda5b0c4f6541f71249900e793083bb7f2fa3b05314b109bf16d8d0)
            check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
            check_type(argname="argument log_analytics_workspace_resource_id", value=log_analytics_workspace_resource_id, expected_type=type_hints["log_analytics_workspace_resource_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if enabled is not None:
            self._values["enabled"] = enabled
        if log_analytics_workspace_resource_id is not None:
            self._values["log_analytics_workspace_resource_id"] = log_analytics_workspace_resource_id

    @builtins.property
    def enabled(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def log_analytics_workspace_resource_id(self) -> typing.Optional[builtins.str]:
        result = self._values.get("log_analytics_workspace_resource_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AksClusterDefenderSecurityMonitoring(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.AksClusterDiskCSIDriver",
    jsii_struct_bases=[],
    name_mapping={"enabled": "enabled", "version": "version"},
)
class AksClusterDiskCSIDriver:
    def __init__(
        self,
        *,
        enabled: typing.Optional[builtins.bool] = None,
        version: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Disk CSI driver.

        :param enabled: 
        :param version: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4f37cc0750c8590721b86f6d19449762d6d47f31af07525869406189468411d4)
            check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
            check_type(argname="argument version", value=version, expected_type=type_hints["version"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if enabled is not None:
            self._values["enabled"] = enabled
        if version is not None:
            self._values["version"] = version

    @builtins.property
    def enabled(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def version(self) -> typing.Optional[builtins.str]:
        result = self._values.get("version")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AksClusterDiskCSIDriver(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.AksClusterEffectiveOutboundIP",
    jsii_struct_bases=[],
    name_mapping={"id": "id"},
)
class AksClusterEffectiveOutboundIP:
    def __init__(self, *, id: typing.Optional[builtins.str] = None) -> None:
        '''Effective outbound IP.

        :param id: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__494f0c110da03b74452556f1df84417a06ed9cbb2cc4a06f0586adf10cec2217)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if id is not None:
            self._values["id"] = id

    @builtins.property
    def id(self) -> typing.Optional[builtins.str]:
        result = self._values.get("id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AksClusterEffectiveOutboundIP(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.AksClusterFileCSIDriver",
    jsii_struct_bases=[],
    name_mapping={"enabled": "enabled"},
)
class AksClusterFileCSIDriver:
    def __init__(self, *, enabled: typing.Optional[builtins.bool] = None) -> None:
        '''File CSI driver.

        :param enabled: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bc0cf1b74d10fda0180174f32f6a71b2b8c08bdcb08239636ca4a8aebb0c9ca1)
            check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if enabled is not None:
            self._values["enabled"] = enabled

    @builtins.property
    def enabled(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AksClusterFileCSIDriver(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.AksClusterGmsaProfile",
    jsii_struct_bases=[],
    name_mapping={
        "dns_server": "dnsServer",
        "enabled": "enabled",
        "root_domain_name": "rootDomainName",
    },
)
class AksClusterGmsaProfile:
    def __init__(
        self,
        *,
        dns_server: typing.Optional[builtins.str] = None,
        enabled: typing.Optional[builtins.bool] = None,
        root_domain_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''GMSA profile for Windows.

        :param dns_server: 
        :param enabled: 
        :param root_domain_name: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d4b142213bb017b49581f4edeec068878730471cc7b1af7a8ae90c660537ca59)
            check_type(argname="argument dns_server", value=dns_server, expected_type=type_hints["dns_server"])
            check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
            check_type(argname="argument root_domain_name", value=root_domain_name, expected_type=type_hints["root_domain_name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if dns_server is not None:
            self._values["dns_server"] = dns_server
        if enabled is not None:
            self._values["enabled"] = enabled
        if root_domain_name is not None:
            self._values["root_domain_name"] = root_domain_name

    @builtins.property
    def dns_server(self) -> typing.Optional[builtins.str]:
        result = self._values.get("dns_server")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def enabled(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def root_domain_name(self) -> typing.Optional[builtins.str]:
        result = self._values.get("root_domain_name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AksClusterGmsaProfile(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.AksClusterHttpProxyConfig",
    jsii_struct_bases=[],
    name_mapping={
        "http_proxy": "httpProxy",
        "https_proxy": "httpsProxy",
        "no_proxy": "noProxy",
        "trusted_ca": "trustedCa",
    },
)
class AksClusterHttpProxyConfig:
    def __init__(
        self,
        *,
        http_proxy: typing.Optional[builtins.str] = None,
        https_proxy: typing.Optional[builtins.str] = None,
        no_proxy: typing.Optional[typing.Sequence[builtins.str]] = None,
        trusted_ca: typing.Optional[builtins.str] = None,
    ) -> None:
        '''HTTP proxy configuration.

        :param http_proxy: 
        :param https_proxy: 
        :param no_proxy: 
        :param trusted_ca: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__837d9d10fa920b0307d1bbefe42cb4e019d1b014646e74b4b2868922e3eb357f)
            check_type(argname="argument http_proxy", value=http_proxy, expected_type=type_hints["http_proxy"])
            check_type(argname="argument https_proxy", value=https_proxy, expected_type=type_hints["https_proxy"])
            check_type(argname="argument no_proxy", value=no_proxy, expected_type=type_hints["no_proxy"])
            check_type(argname="argument trusted_ca", value=trusted_ca, expected_type=type_hints["trusted_ca"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if http_proxy is not None:
            self._values["http_proxy"] = http_proxy
        if https_proxy is not None:
            self._values["https_proxy"] = https_proxy
        if no_proxy is not None:
            self._values["no_proxy"] = no_proxy
        if trusted_ca is not None:
            self._values["trusted_ca"] = trusted_ca

    @builtins.property
    def http_proxy(self) -> typing.Optional[builtins.str]:
        result = self._values.get("http_proxy")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def https_proxy(self) -> typing.Optional[builtins.str]:
        result = self._values.get("https_proxy")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def no_proxy(self) -> typing.Optional[typing.List[builtins.str]]:
        result = self._values.get("no_proxy")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def trusted_ca(self) -> typing.Optional[builtins.str]:
        result = self._values.get("trusted_ca")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AksClusterHttpProxyConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.AksClusterIdentity",
    jsii_struct_bases=[],
    name_mapping={
        "type": "type",
        "user_assigned_identities": "userAssignedIdentities",
    },
)
class AksClusterIdentity:
    def __init__(
        self,
        *,
        type: builtins.str,
        user_assigned_identities: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    ) -> None:
        '''Identity configuration for AKS Cluster.

        :param type: 
        :param user_assigned_identities: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b2f93d602a9db23cffe481bd74d13ad6a787d2fa29a0baf4f7673830cef786c6)
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument user_assigned_identities", value=user_assigned_identities, expected_type=type_hints["user_assigned_identities"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "type": type,
        }
        if user_assigned_identities is not None:
            self._values["user_assigned_identities"] = user_assigned_identities

    @builtins.property
    def type(self) -> builtins.str:
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def user_assigned_identities(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        result = self._values.get("user_assigned_identities")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AksClusterIdentity(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.AksClusterImageCleaner",
    jsii_struct_bases=[],
    name_mapping={"enabled": "enabled", "interval_hours": "intervalHours"},
)
class AksClusterImageCleaner:
    def __init__(
        self,
        *,
        enabled: typing.Optional[builtins.bool] = None,
        interval_hours: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Image cleaner configuration.

        :param enabled: 
        :param interval_hours: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__44117e43999544b2e0024148758296d06ff1b21c7a14361c659e0d12ab330c4c)
            check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
            check_type(argname="argument interval_hours", value=interval_hours, expected_type=type_hints["interval_hours"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if enabled is not None:
            self._values["enabled"] = enabled
        if interval_hours is not None:
            self._values["interval_hours"] = interval_hours

    @builtins.property
    def enabled(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def interval_hours(self) -> typing.Optional[jsii.Number]:
        result = self._values.get("interval_hours")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AksClusterImageCleaner(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.AksClusterKeda",
    jsii_struct_bases=[],
    name_mapping={"enabled": "enabled"},
)
class AksClusterKeda:
    def __init__(self, *, enabled: typing.Optional[builtins.bool] = None) -> None:
        '''KEDA configuration.

        :param enabled: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__230844b390be36756e18465d98e79ccdd11c5d1f1b988f986815e0c45f18f056)
            check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if enabled is not None:
            self._values["enabled"] = enabled

    @builtins.property
    def enabled(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AksClusterKeda(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.AksClusterKubeletConfig",
    jsii_struct_bases=[],
    name_mapping={
        "allowed_unsafe_sysctls": "allowedUnsafeSysctls",
        "container_log_max_files": "containerLogMaxFiles",
        "container_log_max_size_mb": "containerLogMaxSizeMB",
        "cpu_cfs_quota": "cpuCfsQuota",
        "cpu_cfs_quota_period": "cpuCfsQuotaPeriod",
        "cpu_manager_policy": "cpuManagerPolicy",
        "fail_swap_on": "failSwapOn",
        "image_gc_high_threshold": "imageGcHighThreshold",
        "image_gc_low_threshold": "imageGcLowThreshold",
        "pod_max_pids": "podMaxPids",
        "topology_manager_policy": "topologyManagerPolicy",
    },
)
class AksClusterKubeletConfig:
    def __init__(
        self,
        *,
        allowed_unsafe_sysctls: typing.Optional[typing.Sequence[builtins.str]] = None,
        container_log_max_files: typing.Optional[jsii.Number] = None,
        container_log_max_size_mb: typing.Optional[jsii.Number] = None,
        cpu_cfs_quota: typing.Optional[builtins.bool] = None,
        cpu_cfs_quota_period: typing.Optional[builtins.str] = None,
        cpu_manager_policy: typing.Optional[builtins.str] = None,
        fail_swap_on: typing.Optional[builtins.bool] = None,
        image_gc_high_threshold: typing.Optional[jsii.Number] = None,
        image_gc_low_threshold: typing.Optional[jsii.Number] = None,
        pod_max_pids: typing.Optional[jsii.Number] = None,
        topology_manager_policy: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Kubelet configuration.

        :param allowed_unsafe_sysctls: 
        :param container_log_max_files: 
        :param container_log_max_size_mb: 
        :param cpu_cfs_quota: 
        :param cpu_cfs_quota_period: 
        :param cpu_manager_policy: 
        :param fail_swap_on: 
        :param image_gc_high_threshold: 
        :param image_gc_low_threshold: 
        :param pod_max_pids: 
        :param topology_manager_policy: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__52485dadde9b8e33a6ebba2c097ea04238eaa94867e7c1d0871b03974a652ff2)
            check_type(argname="argument allowed_unsafe_sysctls", value=allowed_unsafe_sysctls, expected_type=type_hints["allowed_unsafe_sysctls"])
            check_type(argname="argument container_log_max_files", value=container_log_max_files, expected_type=type_hints["container_log_max_files"])
            check_type(argname="argument container_log_max_size_mb", value=container_log_max_size_mb, expected_type=type_hints["container_log_max_size_mb"])
            check_type(argname="argument cpu_cfs_quota", value=cpu_cfs_quota, expected_type=type_hints["cpu_cfs_quota"])
            check_type(argname="argument cpu_cfs_quota_period", value=cpu_cfs_quota_period, expected_type=type_hints["cpu_cfs_quota_period"])
            check_type(argname="argument cpu_manager_policy", value=cpu_manager_policy, expected_type=type_hints["cpu_manager_policy"])
            check_type(argname="argument fail_swap_on", value=fail_swap_on, expected_type=type_hints["fail_swap_on"])
            check_type(argname="argument image_gc_high_threshold", value=image_gc_high_threshold, expected_type=type_hints["image_gc_high_threshold"])
            check_type(argname="argument image_gc_low_threshold", value=image_gc_low_threshold, expected_type=type_hints["image_gc_low_threshold"])
            check_type(argname="argument pod_max_pids", value=pod_max_pids, expected_type=type_hints["pod_max_pids"])
            check_type(argname="argument topology_manager_policy", value=topology_manager_policy, expected_type=type_hints["topology_manager_policy"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if allowed_unsafe_sysctls is not None:
            self._values["allowed_unsafe_sysctls"] = allowed_unsafe_sysctls
        if container_log_max_files is not None:
            self._values["container_log_max_files"] = container_log_max_files
        if container_log_max_size_mb is not None:
            self._values["container_log_max_size_mb"] = container_log_max_size_mb
        if cpu_cfs_quota is not None:
            self._values["cpu_cfs_quota"] = cpu_cfs_quota
        if cpu_cfs_quota_period is not None:
            self._values["cpu_cfs_quota_period"] = cpu_cfs_quota_period
        if cpu_manager_policy is not None:
            self._values["cpu_manager_policy"] = cpu_manager_policy
        if fail_swap_on is not None:
            self._values["fail_swap_on"] = fail_swap_on
        if image_gc_high_threshold is not None:
            self._values["image_gc_high_threshold"] = image_gc_high_threshold
        if image_gc_low_threshold is not None:
            self._values["image_gc_low_threshold"] = image_gc_low_threshold
        if pod_max_pids is not None:
            self._values["pod_max_pids"] = pod_max_pids
        if topology_manager_policy is not None:
            self._values["topology_manager_policy"] = topology_manager_policy

    @builtins.property
    def allowed_unsafe_sysctls(self) -> typing.Optional[typing.List[builtins.str]]:
        result = self._values.get("allowed_unsafe_sysctls")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def container_log_max_files(self) -> typing.Optional[jsii.Number]:
        result = self._values.get("container_log_max_files")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def container_log_max_size_mb(self) -> typing.Optional[jsii.Number]:
        result = self._values.get("container_log_max_size_mb")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def cpu_cfs_quota(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("cpu_cfs_quota")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def cpu_cfs_quota_period(self) -> typing.Optional[builtins.str]:
        result = self._values.get("cpu_cfs_quota_period")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def cpu_manager_policy(self) -> typing.Optional[builtins.str]:
        result = self._values.get("cpu_manager_policy")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def fail_swap_on(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("fail_swap_on")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def image_gc_high_threshold(self) -> typing.Optional[jsii.Number]:
        result = self._values.get("image_gc_high_threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def image_gc_low_threshold(self) -> typing.Optional[jsii.Number]:
        result = self._values.get("image_gc_low_threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def pod_max_pids(self) -> typing.Optional[jsii.Number]:
        result = self._values.get("pod_max_pids")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def topology_manager_policy(self) -> typing.Optional[builtins.str]:
        result = self._values.get("topology_manager_policy")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AksClusterKubeletConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.AksClusterLinuxOSConfig",
    jsii_struct_bases=[],
    name_mapping={
        "swap_file_size_mb": "swapFileSizeMB",
        "sysctls": "sysctls",
        "transparent_huge_page_defrag": "transparentHugePageDefrag",
        "transparent_huge_page_enabled": "transparentHugePageEnabled",
    },
)
class AksClusterLinuxOSConfig:
    def __init__(
        self,
        *,
        swap_file_size_mb: typing.Optional[jsii.Number] = None,
        sysctls: typing.Optional[typing.Union[_AksClusterSysctlConfig_ebc83aec, typing.Dict[builtins.str, typing.Any]]] = None,
        transparent_huge_page_defrag: typing.Optional[builtins.str] = None,
        transparent_huge_page_enabled: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Linux OS configuration.

        :param swap_file_size_mb: 
        :param sysctls: 
        :param transparent_huge_page_defrag: 
        :param transparent_huge_page_enabled: 
        '''
        if isinstance(sysctls, dict):
            sysctls = _AksClusterSysctlConfig_ebc83aec(**sysctls)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__19c09d66963506efb76580b47de012451709d2d422a0d9b5094a57bbbce7b1d3)
            check_type(argname="argument swap_file_size_mb", value=swap_file_size_mb, expected_type=type_hints["swap_file_size_mb"])
            check_type(argname="argument sysctls", value=sysctls, expected_type=type_hints["sysctls"])
            check_type(argname="argument transparent_huge_page_defrag", value=transparent_huge_page_defrag, expected_type=type_hints["transparent_huge_page_defrag"])
            check_type(argname="argument transparent_huge_page_enabled", value=transparent_huge_page_enabled, expected_type=type_hints["transparent_huge_page_enabled"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if swap_file_size_mb is not None:
            self._values["swap_file_size_mb"] = swap_file_size_mb
        if sysctls is not None:
            self._values["sysctls"] = sysctls
        if transparent_huge_page_defrag is not None:
            self._values["transparent_huge_page_defrag"] = transparent_huge_page_defrag
        if transparent_huge_page_enabled is not None:
            self._values["transparent_huge_page_enabled"] = transparent_huge_page_enabled

    @builtins.property
    def swap_file_size_mb(self) -> typing.Optional[jsii.Number]:
        result = self._values.get("swap_file_size_mb")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sysctls(self) -> typing.Optional[_AksClusterSysctlConfig_ebc83aec]:
        result = self._values.get("sysctls")
        return typing.cast(typing.Optional[_AksClusterSysctlConfig_ebc83aec], result)

    @builtins.property
    def transparent_huge_page_defrag(self) -> typing.Optional[builtins.str]:
        result = self._values.get("transparent_huge_page_defrag")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def transparent_huge_page_enabled(self) -> typing.Optional[builtins.str]:
        result = self._values.get("transparent_huge_page_enabled")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AksClusterLinuxOSConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.AksClusterLinuxProfile",
    jsii_struct_bases=[],
    name_mapping={"admin_username": "adminUsername", "ssh": "ssh"},
)
class AksClusterLinuxProfile:
    def __init__(
        self,
        *,
        admin_username: builtins.str,
        ssh: typing.Union[_AksClusterSshConfiguration_a24a3e25, typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''Linux profile.

        :param admin_username: 
        :param ssh: 
        '''
        if isinstance(ssh, dict):
            ssh = _AksClusterSshConfiguration_a24a3e25(**ssh)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__df72fc4ac06c06da1dd2b4e4f58122da50fc02bf4d23cee82b28e3dcb9d9d02e)
            check_type(argname="argument admin_username", value=admin_username, expected_type=type_hints["admin_username"])
            check_type(argname="argument ssh", value=ssh, expected_type=type_hints["ssh"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "admin_username": admin_username,
            "ssh": ssh,
        }

    @builtins.property
    def admin_username(self) -> builtins.str:
        result = self._values.get("admin_username")
        assert result is not None, "Required property 'admin_username' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def ssh(self) -> _AksClusterSshConfiguration_a24a3e25:
        result = self._values.get("ssh")
        assert result is not None, "Required property 'ssh' is missing"
        return typing.cast(_AksClusterSshConfiguration_a24a3e25, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AksClusterLinuxProfile(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.AksClusterLoadBalancerProfile",
    jsii_struct_bases=[],
    name_mapping={
        "allocated_outbound_ports": "allocatedOutboundPorts",
        "effective_outbound_i_ps": "effectiveOutboundIPs",
        "enable_multiple_standard_load_balancers": "enableMultipleStandardLoadBalancers",
        "idle_timeout_in_minutes": "idleTimeoutInMinutes",
        "managed_outbound_i_ps": "managedOutboundIPs",
        "outbound_ip_prefixes": "outboundIPPrefixes",
        "outbound_i_ps": "outboundIPs",
    },
)
class AksClusterLoadBalancerProfile:
    def __init__(
        self,
        *,
        allocated_outbound_ports: typing.Optional[jsii.Number] = None,
        effective_outbound_i_ps: typing.Optional[typing.Sequence[typing.Union[_AksClusterEffectiveOutboundIP_a56a4ba3, typing.Dict[builtins.str, typing.Any]]]] = None,
        enable_multiple_standard_load_balancers: typing.Optional[builtins.bool] = None,
        idle_timeout_in_minutes: typing.Optional[jsii.Number] = None,
        managed_outbound_i_ps: typing.Optional[typing.Union[_AksClusterManagedOutboundIPs_7800bd02, typing.Dict[builtins.str, typing.Any]]] = None,
        outbound_ip_prefixes: typing.Optional[typing.Union[_AksClusterOutboundIPPrefixes_998c4e88, typing.Dict[builtins.str, typing.Any]]] = None,
        outbound_i_ps: typing.Optional[typing.Union[_AksClusterOutboundIPs_fa40a921, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Load balancer profile.

        :param allocated_outbound_ports: 
        :param effective_outbound_i_ps: 
        :param enable_multiple_standard_load_balancers: 
        :param idle_timeout_in_minutes: 
        :param managed_outbound_i_ps: 
        :param outbound_ip_prefixes: 
        :param outbound_i_ps: 
        '''
        if isinstance(managed_outbound_i_ps, dict):
            managed_outbound_i_ps = _AksClusterManagedOutboundIPs_7800bd02(**managed_outbound_i_ps)
        if isinstance(outbound_ip_prefixes, dict):
            outbound_ip_prefixes = _AksClusterOutboundIPPrefixes_998c4e88(**outbound_ip_prefixes)
        if isinstance(outbound_i_ps, dict):
            outbound_i_ps = _AksClusterOutboundIPs_fa40a921(**outbound_i_ps)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d2e854a0465b530bcaade92e8e9ee5298ad619320c49724c85a4b337d46f667e)
            check_type(argname="argument allocated_outbound_ports", value=allocated_outbound_ports, expected_type=type_hints["allocated_outbound_ports"])
            check_type(argname="argument effective_outbound_i_ps", value=effective_outbound_i_ps, expected_type=type_hints["effective_outbound_i_ps"])
            check_type(argname="argument enable_multiple_standard_load_balancers", value=enable_multiple_standard_load_balancers, expected_type=type_hints["enable_multiple_standard_load_balancers"])
            check_type(argname="argument idle_timeout_in_minutes", value=idle_timeout_in_minutes, expected_type=type_hints["idle_timeout_in_minutes"])
            check_type(argname="argument managed_outbound_i_ps", value=managed_outbound_i_ps, expected_type=type_hints["managed_outbound_i_ps"])
            check_type(argname="argument outbound_ip_prefixes", value=outbound_ip_prefixes, expected_type=type_hints["outbound_ip_prefixes"])
            check_type(argname="argument outbound_i_ps", value=outbound_i_ps, expected_type=type_hints["outbound_i_ps"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if allocated_outbound_ports is not None:
            self._values["allocated_outbound_ports"] = allocated_outbound_ports
        if effective_outbound_i_ps is not None:
            self._values["effective_outbound_i_ps"] = effective_outbound_i_ps
        if enable_multiple_standard_load_balancers is not None:
            self._values["enable_multiple_standard_load_balancers"] = enable_multiple_standard_load_balancers
        if idle_timeout_in_minutes is not None:
            self._values["idle_timeout_in_minutes"] = idle_timeout_in_minutes
        if managed_outbound_i_ps is not None:
            self._values["managed_outbound_i_ps"] = managed_outbound_i_ps
        if outbound_ip_prefixes is not None:
            self._values["outbound_ip_prefixes"] = outbound_ip_prefixes
        if outbound_i_ps is not None:
            self._values["outbound_i_ps"] = outbound_i_ps

    @builtins.property
    def allocated_outbound_ports(self) -> typing.Optional[jsii.Number]:
        result = self._values.get("allocated_outbound_ports")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def effective_outbound_i_ps(
        self,
    ) -> typing.Optional[typing.List[_AksClusterEffectiveOutboundIP_a56a4ba3]]:
        result = self._values.get("effective_outbound_i_ps")
        return typing.cast(typing.Optional[typing.List[_AksClusterEffectiveOutboundIP_a56a4ba3]], result)

    @builtins.property
    def enable_multiple_standard_load_balancers(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("enable_multiple_standard_load_balancers")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def idle_timeout_in_minutes(self) -> typing.Optional[jsii.Number]:
        result = self._values.get("idle_timeout_in_minutes")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def managed_outbound_i_ps(
        self,
    ) -> typing.Optional[_AksClusterManagedOutboundIPs_7800bd02]:
        result = self._values.get("managed_outbound_i_ps")
        return typing.cast(typing.Optional[_AksClusterManagedOutboundIPs_7800bd02], result)

    @builtins.property
    def outbound_ip_prefixes(
        self,
    ) -> typing.Optional[_AksClusterOutboundIPPrefixes_998c4e88]:
        result = self._values.get("outbound_ip_prefixes")
        return typing.cast(typing.Optional[_AksClusterOutboundIPPrefixes_998c4e88], result)

    @builtins.property
    def outbound_i_ps(self) -> typing.Optional[_AksClusterOutboundIPs_fa40a921]:
        result = self._values.get("outbound_i_ps")
        return typing.cast(typing.Optional[_AksClusterOutboundIPs_fa40a921], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AksClusterLoadBalancerProfile(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.AksClusterManagedOutboundIPProfile",
    jsii_struct_bases=[],
    name_mapping={"count": "count"},
)
class AksClusterManagedOutboundIPProfile:
    def __init__(self, *, count: typing.Optional[jsii.Number] = None) -> None:
        '''Managed outbound IP profile.

        :param count: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a6e907b0b416debf597d5de597d32a45533a45129bb7d03d3e24be5af589c948)
            check_type(argname="argument count", value=count, expected_type=type_hints["count"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if count is not None:
            self._values["count"] = count

    @builtins.property
    def count(self) -> typing.Optional[jsii.Number]:
        result = self._values.get("count")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AksClusterManagedOutboundIPProfile(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.AksClusterManagedOutboundIPs",
    jsii_struct_bases=[],
    name_mapping={"count": "count", "count_i_pv6": "countIPv6"},
)
class AksClusterManagedOutboundIPs:
    def __init__(
        self,
        *,
        count: typing.Optional[jsii.Number] = None,
        count_i_pv6: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Managed outbound IPs.

        :param count: 
        :param count_i_pv6: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__86aebe6063e973b1181d8c9a3c2c5bfd9786669fe9abceda19632cc8ce5a4ca8)
            check_type(argname="argument count", value=count, expected_type=type_hints["count"])
            check_type(argname="argument count_i_pv6", value=count_i_pv6, expected_type=type_hints["count_i_pv6"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if count is not None:
            self._values["count"] = count
        if count_i_pv6 is not None:
            self._values["count_i_pv6"] = count_i_pv6

    @builtins.property
    def count(self) -> typing.Optional[jsii.Number]:
        result = self._values.get("count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def count_i_pv6(self) -> typing.Optional[jsii.Number]:
        result = self._values.get("count_i_pv6")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AksClusterManagedOutboundIPs(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.AksClusterMonitoringOptions",
    jsii_struct_bases=[],
    name_mapping={
        "enable_deletion_alert": "enableDeletionAlert",
        "enable_failed_pod_alert": "enableFailedPodAlert",
        "enable_node_cpu_alert": "enableNodeCpuAlert",
        "enable_node_memory_alert": "enableNodeMemoryAlert",
        "failed_pod_alert_severity": "failedPodAlertSeverity",
        "failed_pod_threshold": "failedPodThreshold",
        "node_cpu_alert_severity": "nodeCpuAlertSeverity",
        "node_cpu_threshold": "nodeCpuThreshold",
        "node_memory_alert_severity": "nodeMemoryAlertSeverity",
        "node_memory_threshold": "nodeMemoryThreshold",
    },
)
class AksClusterMonitoringOptions:
    def __init__(
        self,
        *,
        enable_deletion_alert: typing.Optional[builtins.bool] = None,
        enable_failed_pod_alert: typing.Optional[builtins.bool] = None,
        enable_node_cpu_alert: typing.Optional[builtins.bool] = None,
        enable_node_memory_alert: typing.Optional[builtins.bool] = None,
        failed_pod_alert_severity: typing.Optional[jsii.Number] = None,
        failed_pod_threshold: typing.Optional[jsii.Number] = None,
        node_cpu_alert_severity: typing.Optional[jsii.Number] = None,
        node_cpu_threshold: typing.Optional[jsii.Number] = None,
        node_memory_alert_severity: typing.Optional[jsii.Number] = None,
        node_memory_threshold: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Configuration options for AKS Cluster monitoring.

        :param enable_deletion_alert: Whether to enable AKS cluster deletion alert. Default: true
        :param enable_failed_pod_alert: Whether to enable failed pod alert. Default: true
        :param enable_node_cpu_alert: Whether to enable node CPU usage alert. Default: true
        :param enable_node_memory_alert: Whether to enable node memory usage alert. Default: true
        :param failed_pod_alert_severity: Severity level for failed pod alert (0=Critical, 1=Error, 2=Warning, 3=Informational, 4=Verbose). Default: 1
        :param failed_pod_threshold: Threshold for failed pod count. Default: 0
        :param node_cpu_alert_severity: Severity level for node CPU alert (0=Critical, 1=Error, 2=Warning, 3=Informational, 4=Verbose). Default: 2
        :param node_cpu_threshold: Threshold for node CPU usage percentage (0-100). Default: 80
        :param node_memory_alert_severity: Severity level for node memory alert (0=Critical, 1=Error, 2=Warning, 3=Informational, 4=Verbose). Default: 2
        :param node_memory_threshold: Threshold for node memory usage percentage (0-100). Default: 80
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ffe0f30bf33894f524169bd7e08fe716d7753fc93c0a40bec921bab5ec5e17de)
            check_type(argname="argument enable_deletion_alert", value=enable_deletion_alert, expected_type=type_hints["enable_deletion_alert"])
            check_type(argname="argument enable_failed_pod_alert", value=enable_failed_pod_alert, expected_type=type_hints["enable_failed_pod_alert"])
            check_type(argname="argument enable_node_cpu_alert", value=enable_node_cpu_alert, expected_type=type_hints["enable_node_cpu_alert"])
            check_type(argname="argument enable_node_memory_alert", value=enable_node_memory_alert, expected_type=type_hints["enable_node_memory_alert"])
            check_type(argname="argument failed_pod_alert_severity", value=failed_pod_alert_severity, expected_type=type_hints["failed_pod_alert_severity"])
            check_type(argname="argument failed_pod_threshold", value=failed_pod_threshold, expected_type=type_hints["failed_pod_threshold"])
            check_type(argname="argument node_cpu_alert_severity", value=node_cpu_alert_severity, expected_type=type_hints["node_cpu_alert_severity"])
            check_type(argname="argument node_cpu_threshold", value=node_cpu_threshold, expected_type=type_hints["node_cpu_threshold"])
            check_type(argname="argument node_memory_alert_severity", value=node_memory_alert_severity, expected_type=type_hints["node_memory_alert_severity"])
            check_type(argname="argument node_memory_threshold", value=node_memory_threshold, expected_type=type_hints["node_memory_threshold"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if enable_deletion_alert is not None:
            self._values["enable_deletion_alert"] = enable_deletion_alert
        if enable_failed_pod_alert is not None:
            self._values["enable_failed_pod_alert"] = enable_failed_pod_alert
        if enable_node_cpu_alert is not None:
            self._values["enable_node_cpu_alert"] = enable_node_cpu_alert
        if enable_node_memory_alert is not None:
            self._values["enable_node_memory_alert"] = enable_node_memory_alert
        if failed_pod_alert_severity is not None:
            self._values["failed_pod_alert_severity"] = failed_pod_alert_severity
        if failed_pod_threshold is not None:
            self._values["failed_pod_threshold"] = failed_pod_threshold
        if node_cpu_alert_severity is not None:
            self._values["node_cpu_alert_severity"] = node_cpu_alert_severity
        if node_cpu_threshold is not None:
            self._values["node_cpu_threshold"] = node_cpu_threshold
        if node_memory_alert_severity is not None:
            self._values["node_memory_alert_severity"] = node_memory_alert_severity
        if node_memory_threshold is not None:
            self._values["node_memory_threshold"] = node_memory_threshold

    @builtins.property
    def enable_deletion_alert(self) -> typing.Optional[builtins.bool]:
        '''Whether to enable AKS cluster deletion alert.

        :default: true
        '''
        result = self._values.get("enable_deletion_alert")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_failed_pod_alert(self) -> typing.Optional[builtins.bool]:
        '''Whether to enable failed pod alert.

        :default: true
        '''
        result = self._values.get("enable_failed_pod_alert")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_node_cpu_alert(self) -> typing.Optional[builtins.bool]:
        '''Whether to enable node CPU usage alert.

        :default: true
        '''
        result = self._values.get("enable_node_cpu_alert")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_node_memory_alert(self) -> typing.Optional[builtins.bool]:
        '''Whether to enable node memory usage alert.

        :default: true
        '''
        result = self._values.get("enable_node_memory_alert")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def failed_pod_alert_severity(self) -> typing.Optional[jsii.Number]:
        '''Severity level for failed pod alert (0=Critical, 1=Error, 2=Warning, 3=Informational, 4=Verbose).

        :default: 1
        '''
        result = self._values.get("failed_pod_alert_severity")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def failed_pod_threshold(self) -> typing.Optional[jsii.Number]:
        '''Threshold for failed pod count.

        :default: 0
        '''
        result = self._values.get("failed_pod_threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def node_cpu_alert_severity(self) -> typing.Optional[jsii.Number]:
        '''Severity level for node CPU alert (0=Critical, 1=Error, 2=Warning, 3=Informational, 4=Verbose).

        :default: 2
        '''
        result = self._values.get("node_cpu_alert_severity")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def node_cpu_threshold(self) -> typing.Optional[jsii.Number]:
        '''Threshold for node CPU usage percentage (0-100).

        :default: 80
        '''
        result = self._values.get("node_cpu_threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def node_memory_alert_severity(self) -> typing.Optional[jsii.Number]:
        '''Severity level for node memory alert (0=Critical, 1=Error, 2=Warning, 3=Informational, 4=Verbose).

        :default: 2
        '''
        result = self._values.get("node_memory_alert_severity")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def node_memory_threshold(self) -> typing.Optional[jsii.Number]:
        '''Threshold for node memory usage percentage (0-100).

        :default: 80
        '''
        result = self._values.get("node_memory_threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AksClusterMonitoringOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.AksClusterNatGatewayProfile",
    jsii_struct_bases=[],
    name_mapping={
        "effective_outbound_i_ps": "effectiveOutboundIPs",
        "idle_timeout_in_minutes": "idleTimeoutInMinutes",
        "managed_outbound_ip_profile": "managedOutboundIPProfile",
    },
)
class AksClusterNatGatewayProfile:
    def __init__(
        self,
        *,
        effective_outbound_i_ps: typing.Optional[typing.Sequence[typing.Union[_AksClusterEffectiveOutboundIP_a56a4ba3, typing.Dict[builtins.str, typing.Any]]]] = None,
        idle_timeout_in_minutes: typing.Optional[jsii.Number] = None,
        managed_outbound_ip_profile: typing.Optional[typing.Union[_AksClusterManagedOutboundIPProfile_ce484d83, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''NAT Gateway profile.

        :param effective_outbound_i_ps: 
        :param idle_timeout_in_minutes: 
        :param managed_outbound_ip_profile: 
        '''
        if isinstance(managed_outbound_ip_profile, dict):
            managed_outbound_ip_profile = _AksClusterManagedOutboundIPProfile_ce484d83(**managed_outbound_ip_profile)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6ae6562b2cc909ccf6673b41738d4d2f845196ad2c6b459d36d769007dfc8ba7)
            check_type(argname="argument effective_outbound_i_ps", value=effective_outbound_i_ps, expected_type=type_hints["effective_outbound_i_ps"])
            check_type(argname="argument idle_timeout_in_minutes", value=idle_timeout_in_minutes, expected_type=type_hints["idle_timeout_in_minutes"])
            check_type(argname="argument managed_outbound_ip_profile", value=managed_outbound_ip_profile, expected_type=type_hints["managed_outbound_ip_profile"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if effective_outbound_i_ps is not None:
            self._values["effective_outbound_i_ps"] = effective_outbound_i_ps
        if idle_timeout_in_minutes is not None:
            self._values["idle_timeout_in_minutes"] = idle_timeout_in_minutes
        if managed_outbound_ip_profile is not None:
            self._values["managed_outbound_ip_profile"] = managed_outbound_ip_profile

    @builtins.property
    def effective_outbound_i_ps(
        self,
    ) -> typing.Optional[typing.List[_AksClusterEffectiveOutboundIP_a56a4ba3]]:
        result = self._values.get("effective_outbound_i_ps")
        return typing.cast(typing.Optional[typing.List[_AksClusterEffectiveOutboundIP_a56a4ba3]], result)

    @builtins.property
    def idle_timeout_in_minutes(self) -> typing.Optional[jsii.Number]:
        result = self._values.get("idle_timeout_in_minutes")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def managed_outbound_ip_profile(
        self,
    ) -> typing.Optional[_AksClusterManagedOutboundIPProfile_ce484d83]:
        result = self._values.get("managed_outbound_ip_profile")
        return typing.cast(typing.Optional[_AksClusterManagedOutboundIPProfile_ce484d83], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AksClusterNatGatewayProfile(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.AksClusterNetworkProfile",
    jsii_struct_bases=[],
    name_mapping={
        "dns_service_ip": "dnsServiceIP",
        "docker_bridge_cidr": "dockerBridgeCidr",
        "ip_families": "ipFamilies",
        "load_balancer_profile": "loadBalancerProfile",
        "load_balancer_sku": "loadBalancerSku",
        "nat_gateway_profile": "natGatewayProfile",
        "network_mode": "networkMode",
        "network_plugin": "networkPlugin",
        "network_policy": "networkPolicy",
        "outbound_type": "outboundType",
        "pod_cidr": "podCidr",
        "pod_cidrs": "podCidrs",
        "service_cidr": "serviceCidr",
        "service_cidrs": "serviceCidrs",
    },
)
class AksClusterNetworkProfile:
    def __init__(
        self,
        *,
        dns_service_ip: typing.Optional[builtins.str] = None,
        docker_bridge_cidr: typing.Optional[builtins.str] = None,
        ip_families: typing.Optional[typing.Sequence[builtins.str]] = None,
        load_balancer_profile: typing.Optional[typing.Union[_AksClusterLoadBalancerProfile_67c2ac62, typing.Dict[builtins.str, typing.Any]]] = None,
        load_balancer_sku: typing.Optional[builtins.str] = None,
        nat_gateway_profile: typing.Optional[typing.Union[_AksClusterNatGatewayProfile_b267c658, typing.Dict[builtins.str, typing.Any]]] = None,
        network_mode: typing.Optional[builtins.str] = None,
        network_plugin: typing.Optional[builtins.str] = None,
        network_policy: typing.Optional[builtins.str] = None,
        outbound_type: typing.Optional[builtins.str] = None,
        pod_cidr: typing.Optional[builtins.str] = None,
        pod_cidrs: typing.Optional[typing.Sequence[builtins.str]] = None,
        service_cidr: typing.Optional[builtins.str] = None,
        service_cidrs: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''Network profile for AKS cluster.

        :param dns_service_ip: 
        :param docker_bridge_cidr: 
        :param ip_families: 
        :param load_balancer_profile: 
        :param load_balancer_sku: 
        :param nat_gateway_profile: 
        :param network_mode: 
        :param network_plugin: 
        :param network_policy: 
        :param outbound_type: 
        :param pod_cidr: 
        :param pod_cidrs: 
        :param service_cidr: 
        :param service_cidrs: 
        '''
        if isinstance(load_balancer_profile, dict):
            load_balancer_profile = _AksClusterLoadBalancerProfile_67c2ac62(**load_balancer_profile)
        if isinstance(nat_gateway_profile, dict):
            nat_gateway_profile = _AksClusterNatGatewayProfile_b267c658(**nat_gateway_profile)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__35f0ef2e686c0dbc3abebc7ad7fa034827866793fa9bdd6d917e230e6a0d65d1)
            check_type(argname="argument dns_service_ip", value=dns_service_ip, expected_type=type_hints["dns_service_ip"])
            check_type(argname="argument docker_bridge_cidr", value=docker_bridge_cidr, expected_type=type_hints["docker_bridge_cidr"])
            check_type(argname="argument ip_families", value=ip_families, expected_type=type_hints["ip_families"])
            check_type(argname="argument load_balancer_profile", value=load_balancer_profile, expected_type=type_hints["load_balancer_profile"])
            check_type(argname="argument load_balancer_sku", value=load_balancer_sku, expected_type=type_hints["load_balancer_sku"])
            check_type(argname="argument nat_gateway_profile", value=nat_gateway_profile, expected_type=type_hints["nat_gateway_profile"])
            check_type(argname="argument network_mode", value=network_mode, expected_type=type_hints["network_mode"])
            check_type(argname="argument network_plugin", value=network_plugin, expected_type=type_hints["network_plugin"])
            check_type(argname="argument network_policy", value=network_policy, expected_type=type_hints["network_policy"])
            check_type(argname="argument outbound_type", value=outbound_type, expected_type=type_hints["outbound_type"])
            check_type(argname="argument pod_cidr", value=pod_cidr, expected_type=type_hints["pod_cidr"])
            check_type(argname="argument pod_cidrs", value=pod_cidrs, expected_type=type_hints["pod_cidrs"])
            check_type(argname="argument service_cidr", value=service_cidr, expected_type=type_hints["service_cidr"])
            check_type(argname="argument service_cidrs", value=service_cidrs, expected_type=type_hints["service_cidrs"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if dns_service_ip is not None:
            self._values["dns_service_ip"] = dns_service_ip
        if docker_bridge_cidr is not None:
            self._values["docker_bridge_cidr"] = docker_bridge_cidr
        if ip_families is not None:
            self._values["ip_families"] = ip_families
        if load_balancer_profile is not None:
            self._values["load_balancer_profile"] = load_balancer_profile
        if load_balancer_sku is not None:
            self._values["load_balancer_sku"] = load_balancer_sku
        if nat_gateway_profile is not None:
            self._values["nat_gateway_profile"] = nat_gateway_profile
        if network_mode is not None:
            self._values["network_mode"] = network_mode
        if network_plugin is not None:
            self._values["network_plugin"] = network_plugin
        if network_policy is not None:
            self._values["network_policy"] = network_policy
        if outbound_type is not None:
            self._values["outbound_type"] = outbound_type
        if pod_cidr is not None:
            self._values["pod_cidr"] = pod_cidr
        if pod_cidrs is not None:
            self._values["pod_cidrs"] = pod_cidrs
        if service_cidr is not None:
            self._values["service_cidr"] = service_cidr
        if service_cidrs is not None:
            self._values["service_cidrs"] = service_cidrs

    @builtins.property
    def dns_service_ip(self) -> typing.Optional[builtins.str]:
        result = self._values.get("dns_service_ip")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def docker_bridge_cidr(self) -> typing.Optional[builtins.str]:
        result = self._values.get("docker_bridge_cidr")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ip_families(self) -> typing.Optional[typing.List[builtins.str]]:
        result = self._values.get("ip_families")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def load_balancer_profile(
        self,
    ) -> typing.Optional[_AksClusterLoadBalancerProfile_67c2ac62]:
        result = self._values.get("load_balancer_profile")
        return typing.cast(typing.Optional[_AksClusterLoadBalancerProfile_67c2ac62], result)

    @builtins.property
    def load_balancer_sku(self) -> typing.Optional[builtins.str]:
        result = self._values.get("load_balancer_sku")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def nat_gateway_profile(
        self,
    ) -> typing.Optional[_AksClusterNatGatewayProfile_b267c658]:
        result = self._values.get("nat_gateway_profile")
        return typing.cast(typing.Optional[_AksClusterNatGatewayProfile_b267c658], result)

    @builtins.property
    def network_mode(self) -> typing.Optional[builtins.str]:
        result = self._values.get("network_mode")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def network_plugin(self) -> typing.Optional[builtins.str]:
        result = self._values.get("network_plugin")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def network_policy(self) -> typing.Optional[builtins.str]:
        result = self._values.get("network_policy")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def outbound_type(self) -> typing.Optional[builtins.str]:
        result = self._values.get("outbound_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def pod_cidr(self) -> typing.Optional[builtins.str]:
        result = self._values.get("pod_cidr")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def pod_cidrs(self) -> typing.Optional[typing.List[builtins.str]]:
        result = self._values.get("pod_cidrs")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def service_cidr(self) -> typing.Optional[builtins.str]:
        result = self._values.get("service_cidr")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def service_cidrs(self) -> typing.Optional[typing.List[builtins.str]]:
        result = self._values.get("service_cidrs")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AksClusterNetworkProfile(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.AksClusterOidcIssuerProfile",
    jsii_struct_bases=[],
    name_mapping={"enabled": "enabled", "issuer_url": "issuerURL"},
)
class AksClusterOidcIssuerProfile:
    def __init__(
        self,
        *,
        enabled: typing.Optional[builtins.bool] = None,
        issuer_url: typing.Optional[builtins.str] = None,
    ) -> None:
        '''OIDC issuer profile.

        :param enabled: 
        :param issuer_url: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__769e0d4e0354eeca55eb2e3defadfb699662d029c96be3f2163a4185cf3a26f0)
            check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
            check_type(argname="argument issuer_url", value=issuer_url, expected_type=type_hints["issuer_url"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if enabled is not None:
            self._values["enabled"] = enabled
        if issuer_url is not None:
            self._values["issuer_url"] = issuer_url

    @builtins.property
    def enabled(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def issuer_url(self) -> typing.Optional[builtins.str]:
        result = self._values.get("issuer_url")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AksClusterOidcIssuerProfile(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.AksClusterOutboundIPPrefixes",
    jsii_struct_bases=[],
    name_mapping={"public_ip_prefixes": "publicIPPrefixes"},
)
class AksClusterOutboundIPPrefixes:
    def __init__(
        self,
        *,
        public_ip_prefixes: typing.Optional[typing.Sequence[typing.Union[_AksClusterResourceReference_66302c1f, typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Outbound IP prefixes.

        :param public_ip_prefixes: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bb22d6751205fce0489be9a096b51f45af7baa7b2689d8fb9844986440dafc76)
            check_type(argname="argument public_ip_prefixes", value=public_ip_prefixes, expected_type=type_hints["public_ip_prefixes"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if public_ip_prefixes is not None:
            self._values["public_ip_prefixes"] = public_ip_prefixes

    @builtins.property
    def public_ip_prefixes(
        self,
    ) -> typing.Optional[typing.List[_AksClusterResourceReference_66302c1f]]:
        result = self._values.get("public_ip_prefixes")
        return typing.cast(typing.Optional[typing.List[_AksClusterResourceReference_66302c1f]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AksClusterOutboundIPPrefixes(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.AksClusterOutboundIPs",
    jsii_struct_bases=[],
    name_mapping={"public_i_ps": "publicIPs"},
)
class AksClusterOutboundIPs:
    def __init__(
        self,
        *,
        public_i_ps: typing.Optional[typing.Sequence[typing.Union[_AksClusterResourceReference_66302c1f, typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Outbound IPs.

        :param public_i_ps: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__feb2e76618eb7b66e836d8578d30920bef06d943408974d71ffc9c4ef78184a1)
            check_type(argname="argument public_i_ps", value=public_i_ps, expected_type=type_hints["public_i_ps"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if public_i_ps is not None:
            self._values["public_i_ps"] = public_i_ps

    @builtins.property
    def public_i_ps(
        self,
    ) -> typing.Optional[typing.List[_AksClusterResourceReference_66302c1f]]:
        result = self._values.get("public_i_ps")
        return typing.cast(typing.Optional[typing.List[_AksClusterResourceReference_66302c1f]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AksClusterOutboundIPs(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.AksClusterProps",
    jsii_struct_bases=[_AzapiResourceProps_141a2340],
    name_mapping={
        "connection": "connection",
        "count": "count",
        "depends_on": "dependsOn",
        "for_each": "forEach",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "provisioners": "provisioners",
        "api_version": "apiVersion",
        "enable_migration_analysis": "enableMigrationAnalysis",
        "enable_transformation": "enableTransformation",
        "enable_validation": "enableValidation",
        "location": "location",
        "monitoring": "monitoring",
        "name": "name",
        "tags": "tags",
        "agent_pool_profiles": "agentPoolProfiles",
        "dns_prefix": "dnsPrefix",
        "aad_profile": "aadProfile",
        "addon_profiles": "addonProfiles",
        "api_server_access_profile": "apiServerAccessProfile",
        "auto_scaler_profile": "autoScalerProfile",
        "disable_local_accounts": "disableLocalAccounts",
        "disk_encryption_set_id": "diskEncryptionSetID",
        "enable_rbac": "enableRBAC",
        "fqdn": "fqdn",
        "http_proxy_config": "httpProxyConfig",
        "identity": "identity",
        "ignore_changes": "ignoreChanges",
        "kubernetes_version": "kubernetesVersion",
        "linux_profile": "linuxProfile",
        "network_profile": "networkProfile",
        "node_resource_group": "nodeResourceGroup",
        "oidc_issuer_profile": "oidcIssuerProfile",
        "private_fqdn": "privateFQDN",
        "public_network_access": "publicNetworkAccess",
        "resource_group_id": "resourceGroupId",
        "security_profile": "securityProfile",
        "service_principal_profile": "servicePrincipalProfile",
        "sku": "sku",
        "storage_profile": "storageProfile",
        "support_plan": "supportPlan",
        "windows_profile": "windowsProfile",
        "workload_auto_scaler_profile": "workloadAutoScalerProfile",
    },
)
class AksClusterProps(_AzapiResourceProps_141a2340):
    def __init__(
        self,
        *,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
        api_version: typing.Optional[builtins.str] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        location: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        agent_pool_profiles: typing.Sequence[typing.Union[_AksClusterAgentPoolProfile_19702e0d, typing.Dict[builtins.str, typing.Any]]],
        dns_prefix: builtins.str,
        aad_profile: typing.Optional[typing.Union[_AksClusterAadProfile_cbb39e4e, typing.Dict[builtins.str, typing.Any]]] = None,
        addon_profiles: typing.Optional[typing.Mapping[builtins.str, typing.Union[_AksClusterAddonProfile_75e5bc97, typing.Dict[builtins.str, typing.Any]]]] = None,
        api_server_access_profile: typing.Optional[typing.Union[_AksClusterApiServerAccessProfile_a245e705, typing.Dict[builtins.str, typing.Any]]] = None,
        auto_scaler_profile: typing.Optional[typing.Union[_AksClusterAutoScalerProfile_15ae7fd0, typing.Dict[builtins.str, typing.Any]]] = None,
        disable_local_accounts: typing.Optional[builtins.bool] = None,
        disk_encryption_set_id: typing.Optional[builtins.str] = None,
        enable_rbac: typing.Optional[builtins.bool] = None,
        fqdn: typing.Optional[builtins.str] = None,
        http_proxy_config: typing.Optional[typing.Union[_AksClusterHttpProxyConfig_41bff94e, typing.Dict[builtins.str, typing.Any]]] = None,
        identity: typing.Optional[typing.Union[_AksClusterIdentity_92ed97a4, typing.Dict[builtins.str, typing.Any]]] = None,
        ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
        kubernetes_version: typing.Optional[builtins.str] = None,
        linux_profile: typing.Optional[typing.Union[_AksClusterLinuxProfile_516beb3b, typing.Dict[builtins.str, typing.Any]]] = None,
        network_profile: typing.Optional[typing.Union[_AksClusterNetworkProfile_ec57fbab, typing.Dict[builtins.str, typing.Any]]] = None,
        node_resource_group: typing.Optional[builtins.str] = None,
        oidc_issuer_profile: typing.Optional[typing.Union[_AksClusterOidcIssuerProfile_55bd4791, typing.Dict[builtins.str, typing.Any]]] = None,
        private_fqdn: typing.Optional[builtins.str] = None,
        public_network_access: typing.Optional[builtins.str] = None,
        resource_group_id: typing.Optional[builtins.str] = None,
        security_profile: typing.Optional[typing.Union[_AksClusterSecurityProfile_6e20ee0b, typing.Dict[builtins.str, typing.Any]]] = None,
        service_principal_profile: typing.Optional[typing.Union[_AksClusterServicePrincipalProfile_5638b9c4, typing.Dict[builtins.str, typing.Any]]] = None,
        sku: typing.Optional[typing.Union[_AksClusterSku_746ad049, typing.Dict[builtins.str, typing.Any]]] = None,
        storage_profile: typing.Optional[typing.Union[_AksClusterStorageProfile_cc359e1f, typing.Dict[builtins.str, typing.Any]]] = None,
        support_plan: typing.Optional[builtins.str] = None,
        windows_profile: typing.Optional[typing.Union[_AksClusterWindowsProfile_bf96f6e4, typing.Dict[builtins.str, typing.Any]]] = None,
        workload_auto_scaler_profile: typing.Optional[typing.Union[_AksClusterWorkloadAutoScalerProfile_ec94d7bc, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Properties for the unified Azure Kubernetes Service cluster.

        Extends AzapiResourceProps with AKS-specific properties

        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        :param api_version: Explicit API version to use for this resource. If not specified, the latest active version will be automatically resolved. Use this for version pinning when stability is required over latest features. Default: Latest active version from ApiVersionManager
        :param enable_migration_analysis: Whether to enable migration analysis warnings. When true, the framework will analyze the current version for deprecation status and provide migration recommendations in the deployment output. Default: true
        :param enable_transformation: Whether to apply property transformations automatically. When true, properties will be automatically transformed according to the target schema's transformation rules. This enables backward compatibility. Default: true
        :param enable_validation: Whether to validate properties against the schema. When true, all properties will be validated against the API schema before resource creation. Validation errors will cause deployment failures. Default: true
        :param location: The location where the resource should be created. Default: Varies by resource type - see specific resource documentation
        :param monitoring: Monitoring configuration for this resource. Enables integrated monitoring with diagnostic settings, metric alerts, and activity log alerts. All monitoring is optional and disabled by default.
        :param name: The name of the resource.
        :param tags: Tags to apply to the resource.
        :param agent_pool_profiles: The agent pool profiles for the cluster node pools At least one agent pool is required.
        :param dns_prefix: DNS prefix for the cluster.
        :param aad_profile: The Azure Active Directory integration configuration.
        :param addon_profiles: The addon profiles for cluster addons.
        :param api_server_access_profile: The API server access configuration.
        :param auto_scaler_profile: The auto-scaler configuration for the cluster.
        :param disable_local_accounts: Whether to disable local accounts. Default: false
        :param disk_encryption_set_id: The resource ID of the disk encryption set for encrypting disks.
        :param enable_rbac: Whether to enable Kubernetes Role-Based Access Control. Default: true
        :param fqdn: The FQDN for the cluster (read-only).
        :param http_proxy_config: The HTTP proxy configuration.
        :param identity: The identity configuration for the AKS cluster.
        :param ignore_changes: The lifecycle rules to ignore changes Useful for properties that are externally managed or should not trigger updates.
        :param kubernetes_version: The Kubernetes version for the cluster.
        :param linux_profile: The Linux profile for SSH access.
        :param network_profile: The network configuration for the cluster.
        :param node_resource_group: The name of the resource group for cluster nodes If not specified, Azure will auto-generate the name.
        :param oidc_issuer_profile: The OIDC issuer profile for workload identity.
        :param private_fqdn: The private FQDN for the cluster (read-only).
        :param public_network_access: Whether the cluster is accessible from the public internet.
        :param resource_group_id: Resource group ID where the AKS cluster will be created.
        :param security_profile: The security profile for the cluster.
        :param service_principal_profile: The service principal profile for the cluster.
        :param sku: The SKU (pricing tier) for the AKS cluster.
        :param storage_profile: The storage profile for CSI drivers.
        :param support_plan: The support plan for the cluster.
        :param windows_profile: The Windows profile for Windows node pools.
        :param workload_auto_scaler_profile: The workload auto-scaler profile.
        '''
        if isinstance(lifecycle, dict):
            lifecycle = _cdktf_9a9027ec.TerraformResourceLifecycle(**lifecycle)
        if isinstance(monitoring, dict):
            monitoring = _MonitoringConfig_7c28df74(**monitoring)
        if isinstance(aad_profile, dict):
            aad_profile = _AksClusterAadProfile_cbb39e4e(**aad_profile)
        if isinstance(api_server_access_profile, dict):
            api_server_access_profile = _AksClusterApiServerAccessProfile_a245e705(**api_server_access_profile)
        if isinstance(auto_scaler_profile, dict):
            auto_scaler_profile = _AksClusterAutoScalerProfile_15ae7fd0(**auto_scaler_profile)
        if isinstance(http_proxy_config, dict):
            http_proxy_config = _AksClusterHttpProxyConfig_41bff94e(**http_proxy_config)
        if isinstance(identity, dict):
            identity = _AksClusterIdentity_92ed97a4(**identity)
        if isinstance(linux_profile, dict):
            linux_profile = _AksClusterLinuxProfile_516beb3b(**linux_profile)
        if isinstance(network_profile, dict):
            network_profile = _AksClusterNetworkProfile_ec57fbab(**network_profile)
        if isinstance(oidc_issuer_profile, dict):
            oidc_issuer_profile = _AksClusterOidcIssuerProfile_55bd4791(**oidc_issuer_profile)
        if isinstance(security_profile, dict):
            security_profile = _AksClusterSecurityProfile_6e20ee0b(**security_profile)
        if isinstance(service_principal_profile, dict):
            service_principal_profile = _AksClusterServicePrincipalProfile_5638b9c4(**service_principal_profile)
        if isinstance(sku, dict):
            sku = _AksClusterSku_746ad049(**sku)
        if isinstance(storage_profile, dict):
            storage_profile = _AksClusterStorageProfile_cc359e1f(**storage_profile)
        if isinstance(windows_profile, dict):
            windows_profile = _AksClusterWindowsProfile_bf96f6e4(**windows_profile)
        if isinstance(workload_auto_scaler_profile, dict):
            workload_auto_scaler_profile = _AksClusterWorkloadAutoScalerProfile_ec94d7bc(**workload_auto_scaler_profile)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__02cf4290e0f9c8763c64b10ea0a58b46c07cdcf0eeb00d09bc64fa075c3ebfe0)
            check_type(argname="argument connection", value=connection, expected_type=type_hints["connection"])
            check_type(argname="argument count", value=count, expected_type=type_hints["count"])
            check_type(argname="argument depends_on", value=depends_on, expected_type=type_hints["depends_on"])
            check_type(argname="argument for_each", value=for_each, expected_type=type_hints["for_each"])
            check_type(argname="argument lifecycle", value=lifecycle, expected_type=type_hints["lifecycle"])
            check_type(argname="argument provider", value=provider, expected_type=type_hints["provider"])
            check_type(argname="argument provisioners", value=provisioners, expected_type=type_hints["provisioners"])
            check_type(argname="argument api_version", value=api_version, expected_type=type_hints["api_version"])
            check_type(argname="argument enable_migration_analysis", value=enable_migration_analysis, expected_type=type_hints["enable_migration_analysis"])
            check_type(argname="argument enable_transformation", value=enable_transformation, expected_type=type_hints["enable_transformation"])
            check_type(argname="argument enable_validation", value=enable_validation, expected_type=type_hints["enable_validation"])
            check_type(argname="argument location", value=location, expected_type=type_hints["location"])
            check_type(argname="argument monitoring", value=monitoring, expected_type=type_hints["monitoring"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument agent_pool_profiles", value=agent_pool_profiles, expected_type=type_hints["agent_pool_profiles"])
            check_type(argname="argument dns_prefix", value=dns_prefix, expected_type=type_hints["dns_prefix"])
            check_type(argname="argument aad_profile", value=aad_profile, expected_type=type_hints["aad_profile"])
            check_type(argname="argument addon_profiles", value=addon_profiles, expected_type=type_hints["addon_profiles"])
            check_type(argname="argument api_server_access_profile", value=api_server_access_profile, expected_type=type_hints["api_server_access_profile"])
            check_type(argname="argument auto_scaler_profile", value=auto_scaler_profile, expected_type=type_hints["auto_scaler_profile"])
            check_type(argname="argument disable_local_accounts", value=disable_local_accounts, expected_type=type_hints["disable_local_accounts"])
            check_type(argname="argument disk_encryption_set_id", value=disk_encryption_set_id, expected_type=type_hints["disk_encryption_set_id"])
            check_type(argname="argument enable_rbac", value=enable_rbac, expected_type=type_hints["enable_rbac"])
            check_type(argname="argument fqdn", value=fqdn, expected_type=type_hints["fqdn"])
            check_type(argname="argument http_proxy_config", value=http_proxy_config, expected_type=type_hints["http_proxy_config"])
            check_type(argname="argument identity", value=identity, expected_type=type_hints["identity"])
            check_type(argname="argument ignore_changes", value=ignore_changes, expected_type=type_hints["ignore_changes"])
            check_type(argname="argument kubernetes_version", value=kubernetes_version, expected_type=type_hints["kubernetes_version"])
            check_type(argname="argument linux_profile", value=linux_profile, expected_type=type_hints["linux_profile"])
            check_type(argname="argument network_profile", value=network_profile, expected_type=type_hints["network_profile"])
            check_type(argname="argument node_resource_group", value=node_resource_group, expected_type=type_hints["node_resource_group"])
            check_type(argname="argument oidc_issuer_profile", value=oidc_issuer_profile, expected_type=type_hints["oidc_issuer_profile"])
            check_type(argname="argument private_fqdn", value=private_fqdn, expected_type=type_hints["private_fqdn"])
            check_type(argname="argument public_network_access", value=public_network_access, expected_type=type_hints["public_network_access"])
            check_type(argname="argument resource_group_id", value=resource_group_id, expected_type=type_hints["resource_group_id"])
            check_type(argname="argument security_profile", value=security_profile, expected_type=type_hints["security_profile"])
            check_type(argname="argument service_principal_profile", value=service_principal_profile, expected_type=type_hints["service_principal_profile"])
            check_type(argname="argument sku", value=sku, expected_type=type_hints["sku"])
            check_type(argname="argument storage_profile", value=storage_profile, expected_type=type_hints["storage_profile"])
            check_type(argname="argument support_plan", value=support_plan, expected_type=type_hints["support_plan"])
            check_type(argname="argument windows_profile", value=windows_profile, expected_type=type_hints["windows_profile"])
            check_type(argname="argument workload_auto_scaler_profile", value=workload_auto_scaler_profile, expected_type=type_hints["workload_auto_scaler_profile"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "agent_pool_profiles": agent_pool_profiles,
            "dns_prefix": dns_prefix,
        }
        if connection is not None:
            self._values["connection"] = connection
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if for_each is not None:
            self._values["for_each"] = for_each
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider
        if provisioners is not None:
            self._values["provisioners"] = provisioners
        if api_version is not None:
            self._values["api_version"] = api_version
        if enable_migration_analysis is not None:
            self._values["enable_migration_analysis"] = enable_migration_analysis
        if enable_transformation is not None:
            self._values["enable_transformation"] = enable_transformation
        if enable_validation is not None:
            self._values["enable_validation"] = enable_validation
        if location is not None:
            self._values["location"] = location
        if monitoring is not None:
            self._values["monitoring"] = monitoring
        if name is not None:
            self._values["name"] = name
        if tags is not None:
            self._values["tags"] = tags
        if aad_profile is not None:
            self._values["aad_profile"] = aad_profile
        if addon_profiles is not None:
            self._values["addon_profiles"] = addon_profiles
        if api_server_access_profile is not None:
            self._values["api_server_access_profile"] = api_server_access_profile
        if auto_scaler_profile is not None:
            self._values["auto_scaler_profile"] = auto_scaler_profile
        if disable_local_accounts is not None:
            self._values["disable_local_accounts"] = disable_local_accounts
        if disk_encryption_set_id is not None:
            self._values["disk_encryption_set_id"] = disk_encryption_set_id
        if enable_rbac is not None:
            self._values["enable_rbac"] = enable_rbac
        if fqdn is not None:
            self._values["fqdn"] = fqdn
        if http_proxy_config is not None:
            self._values["http_proxy_config"] = http_proxy_config
        if identity is not None:
            self._values["identity"] = identity
        if ignore_changes is not None:
            self._values["ignore_changes"] = ignore_changes
        if kubernetes_version is not None:
            self._values["kubernetes_version"] = kubernetes_version
        if linux_profile is not None:
            self._values["linux_profile"] = linux_profile
        if network_profile is not None:
            self._values["network_profile"] = network_profile
        if node_resource_group is not None:
            self._values["node_resource_group"] = node_resource_group
        if oidc_issuer_profile is not None:
            self._values["oidc_issuer_profile"] = oidc_issuer_profile
        if private_fqdn is not None:
            self._values["private_fqdn"] = private_fqdn
        if public_network_access is not None:
            self._values["public_network_access"] = public_network_access
        if resource_group_id is not None:
            self._values["resource_group_id"] = resource_group_id
        if security_profile is not None:
            self._values["security_profile"] = security_profile
        if service_principal_profile is not None:
            self._values["service_principal_profile"] = service_principal_profile
        if sku is not None:
            self._values["sku"] = sku
        if storage_profile is not None:
            self._values["storage_profile"] = storage_profile
        if support_plan is not None:
            self._values["support_plan"] = support_plan
        if windows_profile is not None:
            self._values["windows_profile"] = windows_profile
        if workload_auto_scaler_profile is not None:
            self._values["workload_auto_scaler_profile"] = workload_auto_scaler_profile

    @builtins.property
    def connection(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("connection")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]], result)

    @builtins.property
    def count(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]], result)

    @builtins.property
    def depends_on(
        self,
    ) -> typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]], result)

    @builtins.property
    def for_each(self) -> typing.Optional[_cdktf_9a9027ec.ITerraformIterator]:
        '''
        :stability: experimental
        '''
        result = self._values.get("for_each")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.ITerraformIterator], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[_cdktf_9a9027ec.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformProvider], result)

    @builtins.property
    def provisioners(
        self,
    ) -> typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provisioners")
        return typing.cast(typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]], result)

    @builtins.property
    def api_version(self) -> typing.Optional[builtins.str]:
        '''Explicit API version to use for this resource.

        If not specified, the latest active version will be automatically resolved.
        Use this for version pinning when stability is required over latest features.

        :default: Latest active version from ApiVersionManager

        Example::

            "2024-11-01"
        '''
        result = self._values.get("api_version")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def enable_migration_analysis(self) -> typing.Optional[builtins.bool]:
        '''Whether to enable migration analysis warnings.

        When true, the framework will analyze the current version for deprecation
        status and provide migration recommendations in the deployment output.

        :default: true
        '''
        result = self._values.get("enable_migration_analysis")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_transformation(self) -> typing.Optional[builtins.bool]:
        '''Whether to apply property transformations automatically.

        When true, properties will be automatically transformed according to the
        target schema's transformation rules. This enables backward compatibility.

        :default: true
        '''
        result = self._values.get("enable_transformation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_validation(self) -> typing.Optional[builtins.bool]:
        '''Whether to validate properties against the schema.

        When true, all properties will be validated against the API schema before
        resource creation. Validation errors will cause deployment failures.

        :default: true
        '''
        result = self._values.get("enable_validation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def location(self) -> typing.Optional[builtins.str]:
        '''The location where the resource should be created.

        :default: Varies by resource type - see specific resource documentation

        :remarks:

        Location handling varies by resource type:

        - **Top-level resources**: Most require an explicit location (e.g., "eastus", "westus")
        - **Global resources**: Some use "global" as location (e.g., Private DNS Zones)
        - **Child resources**: Inherit location from parent and should NOT set this property

        Each resource type may provide its own default through the ``resolveLocation()`` method.
        If no location is specified and no default exists, resource creation may fail.

        Example::

            // Child resource (Subnet) - do not set location
            // location: undefined (inherited from parent Virtual Network)
        '''
        result = self._values.get("location")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def monitoring(self) -> typing.Optional[_MonitoringConfig_7c28df74]:
        '''Monitoring configuration for this resource.

        Enables integrated monitoring with diagnostic settings, metric alerts,
        and activity log alerts. All monitoring is optional and disabled by default.

        Example::

            monitoring: {
              enabled: true,
              diagnosticSettings: {
                workspaceId: logAnalytics.id,
                metrics: ['AllMetrics'],
                logs: ['AuditLogs']
              },
              metricAlerts: [{
                name: 'high-cpu-alert',
                severity: 2,
                scopes: [], // Automatically set to this resource
                criteria: { ... },
                actions: [{ actionGroupId: actionGroup.id }]
              }]
            }
        '''
        result = self._values.get("monitoring")
        return typing.cast(typing.Optional[_MonitoringConfig_7c28df74], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the resource.'''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Tags to apply to the resource.'''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def agent_pool_profiles(self) -> typing.List[_AksClusterAgentPoolProfile_19702e0d]:
        '''The agent pool profiles for the cluster node pools At least one agent pool is required.

        Example::

            [{ name: "default", count: 3, vmSize: "Standard_D2s_v3", mode: "System" }]
        '''
        result = self._values.get("agent_pool_profiles")
        assert result is not None, "Required property 'agent_pool_profiles' is missing"
        return typing.cast(typing.List[_AksClusterAgentPoolProfile_19702e0d], result)

    @builtins.property
    def dns_prefix(self) -> builtins.str:
        '''DNS prefix for the cluster.

        Example::

            "myakscluster"
        '''
        result = self._values.get("dns_prefix")
        assert result is not None, "Required property 'dns_prefix' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def aad_profile(self) -> typing.Optional[_AksClusterAadProfile_cbb39e4e]:
        '''The Azure Active Directory integration configuration.'''
        result = self._values.get("aad_profile")
        return typing.cast(typing.Optional[_AksClusterAadProfile_cbb39e4e], result)

    @builtins.property
    def addon_profiles(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, _AksClusterAddonProfile_75e5bc97]]:
        '''The addon profiles for cluster addons.'''
        result = self._values.get("addon_profiles")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, _AksClusterAddonProfile_75e5bc97]], result)

    @builtins.property
    def api_server_access_profile(
        self,
    ) -> typing.Optional[_AksClusterApiServerAccessProfile_a245e705]:
        '''The API server access configuration.'''
        result = self._values.get("api_server_access_profile")
        return typing.cast(typing.Optional[_AksClusterApiServerAccessProfile_a245e705], result)

    @builtins.property
    def auto_scaler_profile(
        self,
    ) -> typing.Optional[_AksClusterAutoScalerProfile_15ae7fd0]:
        '''The auto-scaler configuration for the cluster.'''
        result = self._values.get("auto_scaler_profile")
        return typing.cast(typing.Optional[_AksClusterAutoScalerProfile_15ae7fd0], result)

    @builtins.property
    def disable_local_accounts(self) -> typing.Optional[builtins.bool]:
        '''Whether to disable local accounts.

        :default: false
        '''
        result = self._values.get("disable_local_accounts")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def disk_encryption_set_id(self) -> typing.Optional[builtins.str]:
        '''The resource ID of the disk encryption set for encrypting disks.'''
        result = self._values.get("disk_encryption_set_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def enable_rbac(self) -> typing.Optional[builtins.bool]:
        '''Whether to enable Kubernetes Role-Based Access Control.

        :default: true
        '''
        result = self._values.get("enable_rbac")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def fqdn(self) -> typing.Optional[builtins.str]:
        '''The FQDN for the cluster (read-only).'''
        result = self._values.get("fqdn")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def http_proxy_config(self) -> typing.Optional[_AksClusterHttpProxyConfig_41bff94e]:
        '''The HTTP proxy configuration.'''
        result = self._values.get("http_proxy_config")
        return typing.cast(typing.Optional[_AksClusterHttpProxyConfig_41bff94e], result)

    @builtins.property
    def identity(self) -> typing.Optional[_AksClusterIdentity_92ed97a4]:
        '''The identity configuration for the AKS cluster.

        Example::

            { type: "UserAssigned", userAssignedIdentities: { "/subscriptions/.../resourceGroups/.../providers/Microsoft.ManagedIdentity/userAssignedIdentities/myIdentity": {} } }
        '''
        result = self._values.get("identity")
        return typing.cast(typing.Optional[_AksClusterIdentity_92ed97a4], result)

    @builtins.property
    def ignore_changes(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The lifecycle rules to ignore changes Useful for properties that are externally managed or should not trigger updates.

        Example::

            ["kubernetesVersion", "agentPoolProfiles"]
        '''
        result = self._values.get("ignore_changes")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def kubernetes_version(self) -> typing.Optional[builtins.str]:
        '''The Kubernetes version for the cluster.

        Example::

            "1.29.0"
        '''
        result = self._values.get("kubernetes_version")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def linux_profile(self) -> typing.Optional[_AksClusterLinuxProfile_516beb3b]:
        '''The Linux profile for SSH access.'''
        result = self._values.get("linux_profile")
        return typing.cast(typing.Optional[_AksClusterLinuxProfile_516beb3b], result)

    @builtins.property
    def network_profile(self) -> typing.Optional[_AksClusterNetworkProfile_ec57fbab]:
        '''The network configuration for the cluster.'''
        result = self._values.get("network_profile")
        return typing.cast(typing.Optional[_AksClusterNetworkProfile_ec57fbab], result)

    @builtins.property
    def node_resource_group(self) -> typing.Optional[builtins.str]:
        '''The name of the resource group for cluster nodes If not specified, Azure will auto-generate the name.'''
        result = self._values.get("node_resource_group")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def oidc_issuer_profile(
        self,
    ) -> typing.Optional[_AksClusterOidcIssuerProfile_55bd4791]:
        '''The OIDC issuer profile for workload identity.'''
        result = self._values.get("oidc_issuer_profile")
        return typing.cast(typing.Optional[_AksClusterOidcIssuerProfile_55bd4791], result)

    @builtins.property
    def private_fqdn(self) -> typing.Optional[builtins.str]:
        '''The private FQDN for the cluster (read-only).'''
        result = self._values.get("private_fqdn")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def public_network_access(self) -> typing.Optional[builtins.str]:
        '''Whether the cluster is accessible from the public internet.

        Example::

            "Disabled"
        '''
        result = self._values.get("public_network_access")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def resource_group_id(self) -> typing.Optional[builtins.str]:
        '''Resource group ID where the AKS cluster will be created.'''
        result = self._values.get("resource_group_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def security_profile(self) -> typing.Optional[_AksClusterSecurityProfile_6e20ee0b]:
        '''The security profile for the cluster.'''
        result = self._values.get("security_profile")
        return typing.cast(typing.Optional[_AksClusterSecurityProfile_6e20ee0b], result)

    @builtins.property
    def service_principal_profile(
        self,
    ) -> typing.Optional[_AksClusterServicePrincipalProfile_5638b9c4]:
        '''The service principal profile for the cluster.'''
        result = self._values.get("service_principal_profile")
        return typing.cast(typing.Optional[_AksClusterServicePrincipalProfile_5638b9c4], result)

    @builtins.property
    def sku(self) -> typing.Optional[_AksClusterSku_746ad049]:
        '''The SKU (pricing tier) for the AKS cluster.

        Example::

            { name: "Standard", tier: "Standard" }
        '''
        result = self._values.get("sku")
        return typing.cast(typing.Optional[_AksClusterSku_746ad049], result)

    @builtins.property
    def storage_profile(self) -> typing.Optional[_AksClusterStorageProfile_cc359e1f]:
        '''The storage profile for CSI drivers.'''
        result = self._values.get("storage_profile")
        return typing.cast(typing.Optional[_AksClusterStorageProfile_cc359e1f], result)

    @builtins.property
    def support_plan(self) -> typing.Optional[builtins.str]:
        '''The support plan for the cluster.

        Example::

            "AKSLongTermSupport"
        '''
        result = self._values.get("support_plan")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def windows_profile(self) -> typing.Optional[_AksClusterWindowsProfile_bf96f6e4]:
        '''The Windows profile for Windows node pools.'''
        result = self._values.get("windows_profile")
        return typing.cast(typing.Optional[_AksClusterWindowsProfile_bf96f6e4], result)

    @builtins.property
    def workload_auto_scaler_profile(
        self,
    ) -> typing.Optional[_AksClusterWorkloadAutoScalerProfile_ec94d7bc]:
        '''The workload auto-scaler profile.'''
        result = self._values.get("workload_auto_scaler_profile")
        return typing.cast(typing.Optional[_AksClusterWorkloadAutoScalerProfile_ec94d7bc], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AksClusterProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.AksClusterResourceReference",
    jsii_struct_bases=[],
    name_mapping={"id": "id"},
)
class AksClusterResourceReference:
    def __init__(self, *, id: typing.Optional[builtins.str] = None) -> None:
        '''Resource reference.

        :param id: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9721a52865abf32be2154b73382db9dfc693c958006565c429853323f86309e3)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if id is not None:
            self._values["id"] = id

    @builtins.property
    def id(self) -> typing.Optional[builtins.str]:
        result = self._values.get("id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AksClusterResourceReference(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.AksClusterSecurityProfile",
    jsii_struct_bases=[],
    name_mapping={
        "azure_key_vault_kms": "azureKeyVaultKms",
        "defender": "defender",
        "image_cleaner": "imageCleaner",
        "workload_identity": "workloadIdentity",
    },
)
class AksClusterSecurityProfile:
    def __init__(
        self,
        *,
        azure_key_vault_kms: typing.Optional[typing.Union[_AksClusterAzureKeyVaultKms_91079d0f, typing.Dict[builtins.str, typing.Any]]] = None,
        defender: typing.Optional[typing.Union[_AksClusterDefenderSecurityMonitoring_5f628d72, typing.Dict[builtins.str, typing.Any]]] = None,
        image_cleaner: typing.Optional[typing.Union[_AksClusterImageCleaner_eb3f0d8f, typing.Dict[builtins.str, typing.Any]]] = None,
        workload_identity: typing.Optional[typing.Union[_AksClusterWorkloadIdentity_98ca3ec0, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Security profile.

        :param azure_key_vault_kms: 
        :param defender: 
        :param image_cleaner: 
        :param workload_identity: 
        '''
        if isinstance(azure_key_vault_kms, dict):
            azure_key_vault_kms = _AksClusterAzureKeyVaultKms_91079d0f(**azure_key_vault_kms)
        if isinstance(defender, dict):
            defender = _AksClusterDefenderSecurityMonitoring_5f628d72(**defender)
        if isinstance(image_cleaner, dict):
            image_cleaner = _AksClusterImageCleaner_eb3f0d8f(**image_cleaner)
        if isinstance(workload_identity, dict):
            workload_identity = _AksClusterWorkloadIdentity_98ca3ec0(**workload_identity)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ebe32299153e5a1cbc70d5fcd6b51487dd08e2d52da35569e0968407e90d3cd0)
            check_type(argname="argument azure_key_vault_kms", value=azure_key_vault_kms, expected_type=type_hints["azure_key_vault_kms"])
            check_type(argname="argument defender", value=defender, expected_type=type_hints["defender"])
            check_type(argname="argument image_cleaner", value=image_cleaner, expected_type=type_hints["image_cleaner"])
            check_type(argname="argument workload_identity", value=workload_identity, expected_type=type_hints["workload_identity"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if azure_key_vault_kms is not None:
            self._values["azure_key_vault_kms"] = azure_key_vault_kms
        if defender is not None:
            self._values["defender"] = defender
        if image_cleaner is not None:
            self._values["image_cleaner"] = image_cleaner
        if workload_identity is not None:
            self._values["workload_identity"] = workload_identity

    @builtins.property
    def azure_key_vault_kms(
        self,
    ) -> typing.Optional[_AksClusterAzureKeyVaultKms_91079d0f]:
        result = self._values.get("azure_key_vault_kms")
        return typing.cast(typing.Optional[_AksClusterAzureKeyVaultKms_91079d0f], result)

    @builtins.property
    def defender(
        self,
    ) -> typing.Optional[_AksClusterDefenderSecurityMonitoring_5f628d72]:
        result = self._values.get("defender")
        return typing.cast(typing.Optional[_AksClusterDefenderSecurityMonitoring_5f628d72], result)

    @builtins.property
    def image_cleaner(self) -> typing.Optional[_AksClusterImageCleaner_eb3f0d8f]:
        result = self._values.get("image_cleaner")
        return typing.cast(typing.Optional[_AksClusterImageCleaner_eb3f0d8f], result)

    @builtins.property
    def workload_identity(
        self,
    ) -> typing.Optional[_AksClusterWorkloadIdentity_98ca3ec0]:
        result = self._values.get("workload_identity")
        return typing.cast(typing.Optional[_AksClusterWorkloadIdentity_98ca3ec0], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AksClusterSecurityProfile(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.AksClusterServicePrincipalProfile",
    jsii_struct_bases=[],
    name_mapping={"client_id": "clientId", "secret": "secret"},
)
class AksClusterServicePrincipalProfile:
    def __init__(
        self,
        *,
        client_id: builtins.str,
        secret: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Service principal profile.

        :param client_id: 
        :param secret: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fdce2e9a78b12aa4d370ec1e8a9a4e2759c41ad9355c41f0a903fffb970769c0)
            check_type(argname="argument client_id", value=client_id, expected_type=type_hints["client_id"])
            check_type(argname="argument secret", value=secret, expected_type=type_hints["secret"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "client_id": client_id,
        }
        if secret is not None:
            self._values["secret"] = secret

    @builtins.property
    def client_id(self) -> builtins.str:
        result = self._values.get("client_id")
        assert result is not None, "Required property 'client_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def secret(self) -> typing.Optional[builtins.str]:
        result = self._values.get("secret")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AksClusterServicePrincipalProfile(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.AksClusterSku",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "tier": "tier"},
)
class AksClusterSku:
    def __init__(
        self,
        *,
        name: typing.Optional[builtins.str] = None,
        tier: typing.Optional[builtins.str] = None,
    ) -> None:
        '''SKU for Azure Kubernetes Service.

        :param name: 
        :param tier: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c0f6196323b6d6ff995c641ccd047b533fd26e6aab9f17e5f3dcbe2f94412f5a)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument tier", value=tier, expected_type=type_hints["tier"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if name is not None:
            self._values["name"] = name
        if tier is not None:
            self._values["tier"] = tier

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tier(self) -> typing.Optional[builtins.str]:
        result = self._values.get("tier")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AksClusterSku(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.AksClusterSnapshotController",
    jsii_struct_bases=[],
    name_mapping={"enabled": "enabled"},
)
class AksClusterSnapshotController:
    def __init__(self, *, enabled: typing.Optional[builtins.bool] = None) -> None:
        '''Snapshot controller.

        :param enabled: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1d74a534a33d0aa51d3b52ce58081a5780e612b609e3ee788dc0934622d710e4)
            check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if enabled is not None:
            self._values["enabled"] = enabled

    @builtins.property
    def enabled(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AksClusterSnapshotController(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.AksClusterSshConfiguration",
    jsii_struct_bases=[],
    name_mapping={"public_keys": "publicKeys"},
)
class AksClusterSshConfiguration:
    def __init__(
        self,
        *,
        public_keys: typing.Sequence[typing.Union[_AksClusterSshPublicKey_6ec15741, typing.Dict[builtins.str, typing.Any]]],
    ) -> None:
        '''SSH configuration.

        :param public_keys: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6eb37030cd5022a3c4cfdc9fae626596d2e3b9717ecc86764ab57e04a3f961e1)
            check_type(argname="argument public_keys", value=public_keys, expected_type=type_hints["public_keys"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "public_keys": public_keys,
        }

    @builtins.property
    def public_keys(self) -> typing.List[_AksClusterSshPublicKey_6ec15741]:
        result = self._values.get("public_keys")
        assert result is not None, "Required property 'public_keys' is missing"
        return typing.cast(typing.List[_AksClusterSshPublicKey_6ec15741], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AksClusterSshConfiguration(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.AksClusterSshPublicKey",
    jsii_struct_bases=[],
    name_mapping={"key_data": "keyData"},
)
class AksClusterSshPublicKey:
    def __init__(self, *, key_data: builtins.str) -> None:
        '''SSH public key.

        :param key_data: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c6686dd9eceb77f35799e000146402f48d0c7112da791d9c684be5d4c4a7baa5)
            check_type(argname="argument key_data", value=key_data, expected_type=type_hints["key_data"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "key_data": key_data,
        }

    @builtins.property
    def key_data(self) -> builtins.str:
        result = self._values.get("key_data")
        assert result is not None, "Required property 'key_data' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AksClusterSshPublicKey(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.AksClusterStorageProfile",
    jsii_struct_bases=[],
    name_mapping={
        "blob_csi_driver": "blobCSIDriver",
        "disk_csi_driver": "diskCSIDriver",
        "file_csi_driver": "fileCSIDriver",
        "snapshot_controller": "snapshotController",
    },
)
class AksClusterStorageProfile:
    def __init__(
        self,
        *,
        blob_csi_driver: typing.Optional[typing.Union[_AksClusterBlobCSIDriver_ad59fbc0, typing.Dict[builtins.str, typing.Any]]] = None,
        disk_csi_driver: typing.Optional[typing.Union[_AksClusterDiskCSIDriver_f506f2f6, typing.Dict[builtins.str, typing.Any]]] = None,
        file_csi_driver: typing.Optional[typing.Union[_AksClusterFileCSIDriver_5ce3ba90, typing.Dict[builtins.str, typing.Any]]] = None,
        snapshot_controller: typing.Optional[typing.Union[_AksClusterSnapshotController_1593a1b6, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Storage profile.

        :param blob_csi_driver: 
        :param disk_csi_driver: 
        :param file_csi_driver: 
        :param snapshot_controller: 
        '''
        if isinstance(blob_csi_driver, dict):
            blob_csi_driver = _AksClusterBlobCSIDriver_ad59fbc0(**blob_csi_driver)
        if isinstance(disk_csi_driver, dict):
            disk_csi_driver = _AksClusterDiskCSIDriver_f506f2f6(**disk_csi_driver)
        if isinstance(file_csi_driver, dict):
            file_csi_driver = _AksClusterFileCSIDriver_5ce3ba90(**file_csi_driver)
        if isinstance(snapshot_controller, dict):
            snapshot_controller = _AksClusterSnapshotController_1593a1b6(**snapshot_controller)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c47115f298723ba199b2f723683ed5b71b9182466cf38ae6992aad1e328df3e4)
            check_type(argname="argument blob_csi_driver", value=blob_csi_driver, expected_type=type_hints["blob_csi_driver"])
            check_type(argname="argument disk_csi_driver", value=disk_csi_driver, expected_type=type_hints["disk_csi_driver"])
            check_type(argname="argument file_csi_driver", value=file_csi_driver, expected_type=type_hints["file_csi_driver"])
            check_type(argname="argument snapshot_controller", value=snapshot_controller, expected_type=type_hints["snapshot_controller"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if blob_csi_driver is not None:
            self._values["blob_csi_driver"] = blob_csi_driver
        if disk_csi_driver is not None:
            self._values["disk_csi_driver"] = disk_csi_driver
        if file_csi_driver is not None:
            self._values["file_csi_driver"] = file_csi_driver
        if snapshot_controller is not None:
            self._values["snapshot_controller"] = snapshot_controller

    @builtins.property
    def blob_csi_driver(self) -> typing.Optional[_AksClusterBlobCSIDriver_ad59fbc0]:
        result = self._values.get("blob_csi_driver")
        return typing.cast(typing.Optional[_AksClusterBlobCSIDriver_ad59fbc0], result)

    @builtins.property
    def disk_csi_driver(self) -> typing.Optional[_AksClusterDiskCSIDriver_f506f2f6]:
        result = self._values.get("disk_csi_driver")
        return typing.cast(typing.Optional[_AksClusterDiskCSIDriver_f506f2f6], result)

    @builtins.property
    def file_csi_driver(self) -> typing.Optional[_AksClusterFileCSIDriver_5ce3ba90]:
        result = self._values.get("file_csi_driver")
        return typing.cast(typing.Optional[_AksClusterFileCSIDriver_5ce3ba90], result)

    @builtins.property
    def snapshot_controller(
        self,
    ) -> typing.Optional[_AksClusterSnapshotController_1593a1b6]:
        result = self._values.get("snapshot_controller")
        return typing.cast(typing.Optional[_AksClusterSnapshotController_1593a1b6], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AksClusterStorageProfile(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.AksClusterSysctlConfig",
    jsii_struct_bases=[],
    name_mapping={
        "fs_aio_max_nr": "fsAioMaxNr",
        "fs_file_max": "fsFileMax",
        "fs_inotify_max_user_watches": "fsInotifyMaxUserWatches",
        "fs_nr_open": "fsNrOpen",
        "kernel_threads_max": "kernelThreadsMax",
        "net_core_netdev_max_backlog": "netCoreNetdevMaxBacklog",
        "net_core_optmem_max": "netCoreOptmemMax",
        "net_core_rmem_default": "netCoreRmemDefault",
        "net_core_rmem_max": "netCoreRmemMax",
        "net_core_somaxconn": "netCoreSomaxconn",
        "net_core_wmem_default": "netCoreWmemDefault",
        "net_core_wmem_max": "netCoreWmemMax",
        "net_ipv4_ip_local_port_range": "netIpv4IpLocalPortRange",
        "net_ipv4_neigh_default_gc_thresh1": "netIpv4NeighDefaultGcThresh1",
        "net_ipv4_neigh_default_gc_thresh2": "netIpv4NeighDefaultGcThresh2",
        "net_ipv4_neigh_default_gc_thresh3": "netIpv4NeighDefaultGcThresh3",
        "net_ipv4_tcp_fin_timeout": "netIpv4TcpFinTimeout",
        "net_ipv4_tcpkeepalive_intvl": "netIpv4TcpkeepaliveIntvl",
        "net_ipv4_tcp_keepalive_probes": "netIpv4TcpKeepaliveProbes",
        "net_ipv4_tcp_keepalive_time": "netIpv4TcpKeepaliveTime",
        "net_ipv4_tcp_max_syn_backlog": "netIpv4TcpMaxSynBacklog",
        "net_ipv4_tcp_tw_reuse": "netIpv4TcpTwReuse",
        "net_netfilter_nf_conntrack_buckets": "netNetfilterNfConntrackBuckets",
        "net_netfilter_nf_conntrack_max": "netNetfilterNfConntrackMax",
        "vm_max_map_count": "vmMaxMapCount",
        "vm_swappiness": "vmSwappiness",
        "vm_vfs_cache_pressure": "vmVfsCachePressure",
    },
)
class AksClusterSysctlConfig:
    def __init__(
        self,
        *,
        fs_aio_max_nr: typing.Optional[jsii.Number] = None,
        fs_file_max: typing.Optional[jsii.Number] = None,
        fs_inotify_max_user_watches: typing.Optional[jsii.Number] = None,
        fs_nr_open: typing.Optional[jsii.Number] = None,
        kernel_threads_max: typing.Optional[jsii.Number] = None,
        net_core_netdev_max_backlog: typing.Optional[jsii.Number] = None,
        net_core_optmem_max: typing.Optional[jsii.Number] = None,
        net_core_rmem_default: typing.Optional[jsii.Number] = None,
        net_core_rmem_max: typing.Optional[jsii.Number] = None,
        net_core_somaxconn: typing.Optional[jsii.Number] = None,
        net_core_wmem_default: typing.Optional[jsii.Number] = None,
        net_core_wmem_max: typing.Optional[jsii.Number] = None,
        net_ipv4_ip_local_port_range: typing.Optional[builtins.str] = None,
        net_ipv4_neigh_default_gc_thresh1: typing.Optional[jsii.Number] = None,
        net_ipv4_neigh_default_gc_thresh2: typing.Optional[jsii.Number] = None,
        net_ipv4_neigh_default_gc_thresh3: typing.Optional[jsii.Number] = None,
        net_ipv4_tcp_fin_timeout: typing.Optional[jsii.Number] = None,
        net_ipv4_tcpkeepalive_intvl: typing.Optional[jsii.Number] = None,
        net_ipv4_tcp_keepalive_probes: typing.Optional[jsii.Number] = None,
        net_ipv4_tcp_keepalive_time: typing.Optional[jsii.Number] = None,
        net_ipv4_tcp_max_syn_backlog: typing.Optional[jsii.Number] = None,
        net_ipv4_tcp_tw_reuse: typing.Optional[builtins.bool] = None,
        net_netfilter_nf_conntrack_buckets: typing.Optional[jsii.Number] = None,
        net_netfilter_nf_conntrack_max: typing.Optional[jsii.Number] = None,
        vm_max_map_count: typing.Optional[jsii.Number] = None,
        vm_swappiness: typing.Optional[jsii.Number] = None,
        vm_vfs_cache_pressure: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Sysctl configuration.

        :param fs_aio_max_nr: 
        :param fs_file_max: 
        :param fs_inotify_max_user_watches: 
        :param fs_nr_open: 
        :param kernel_threads_max: 
        :param net_core_netdev_max_backlog: 
        :param net_core_optmem_max: 
        :param net_core_rmem_default: 
        :param net_core_rmem_max: 
        :param net_core_somaxconn: 
        :param net_core_wmem_default: 
        :param net_core_wmem_max: 
        :param net_ipv4_ip_local_port_range: 
        :param net_ipv4_neigh_default_gc_thresh1: 
        :param net_ipv4_neigh_default_gc_thresh2: 
        :param net_ipv4_neigh_default_gc_thresh3: 
        :param net_ipv4_tcp_fin_timeout: 
        :param net_ipv4_tcpkeepalive_intvl: 
        :param net_ipv4_tcp_keepalive_probes: 
        :param net_ipv4_tcp_keepalive_time: 
        :param net_ipv4_tcp_max_syn_backlog: 
        :param net_ipv4_tcp_tw_reuse: 
        :param net_netfilter_nf_conntrack_buckets: 
        :param net_netfilter_nf_conntrack_max: 
        :param vm_max_map_count: 
        :param vm_swappiness: 
        :param vm_vfs_cache_pressure: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e7be45ea53e0cd0cf3ed6cc2b878bb6829a3962c486093ab39b1eba8eb855f17)
            check_type(argname="argument fs_aio_max_nr", value=fs_aio_max_nr, expected_type=type_hints["fs_aio_max_nr"])
            check_type(argname="argument fs_file_max", value=fs_file_max, expected_type=type_hints["fs_file_max"])
            check_type(argname="argument fs_inotify_max_user_watches", value=fs_inotify_max_user_watches, expected_type=type_hints["fs_inotify_max_user_watches"])
            check_type(argname="argument fs_nr_open", value=fs_nr_open, expected_type=type_hints["fs_nr_open"])
            check_type(argname="argument kernel_threads_max", value=kernel_threads_max, expected_type=type_hints["kernel_threads_max"])
            check_type(argname="argument net_core_netdev_max_backlog", value=net_core_netdev_max_backlog, expected_type=type_hints["net_core_netdev_max_backlog"])
            check_type(argname="argument net_core_optmem_max", value=net_core_optmem_max, expected_type=type_hints["net_core_optmem_max"])
            check_type(argname="argument net_core_rmem_default", value=net_core_rmem_default, expected_type=type_hints["net_core_rmem_default"])
            check_type(argname="argument net_core_rmem_max", value=net_core_rmem_max, expected_type=type_hints["net_core_rmem_max"])
            check_type(argname="argument net_core_somaxconn", value=net_core_somaxconn, expected_type=type_hints["net_core_somaxconn"])
            check_type(argname="argument net_core_wmem_default", value=net_core_wmem_default, expected_type=type_hints["net_core_wmem_default"])
            check_type(argname="argument net_core_wmem_max", value=net_core_wmem_max, expected_type=type_hints["net_core_wmem_max"])
            check_type(argname="argument net_ipv4_ip_local_port_range", value=net_ipv4_ip_local_port_range, expected_type=type_hints["net_ipv4_ip_local_port_range"])
            check_type(argname="argument net_ipv4_neigh_default_gc_thresh1", value=net_ipv4_neigh_default_gc_thresh1, expected_type=type_hints["net_ipv4_neigh_default_gc_thresh1"])
            check_type(argname="argument net_ipv4_neigh_default_gc_thresh2", value=net_ipv4_neigh_default_gc_thresh2, expected_type=type_hints["net_ipv4_neigh_default_gc_thresh2"])
            check_type(argname="argument net_ipv4_neigh_default_gc_thresh3", value=net_ipv4_neigh_default_gc_thresh3, expected_type=type_hints["net_ipv4_neigh_default_gc_thresh3"])
            check_type(argname="argument net_ipv4_tcp_fin_timeout", value=net_ipv4_tcp_fin_timeout, expected_type=type_hints["net_ipv4_tcp_fin_timeout"])
            check_type(argname="argument net_ipv4_tcpkeepalive_intvl", value=net_ipv4_tcpkeepalive_intvl, expected_type=type_hints["net_ipv4_tcpkeepalive_intvl"])
            check_type(argname="argument net_ipv4_tcp_keepalive_probes", value=net_ipv4_tcp_keepalive_probes, expected_type=type_hints["net_ipv4_tcp_keepalive_probes"])
            check_type(argname="argument net_ipv4_tcp_keepalive_time", value=net_ipv4_tcp_keepalive_time, expected_type=type_hints["net_ipv4_tcp_keepalive_time"])
            check_type(argname="argument net_ipv4_tcp_max_syn_backlog", value=net_ipv4_tcp_max_syn_backlog, expected_type=type_hints["net_ipv4_tcp_max_syn_backlog"])
            check_type(argname="argument net_ipv4_tcp_tw_reuse", value=net_ipv4_tcp_tw_reuse, expected_type=type_hints["net_ipv4_tcp_tw_reuse"])
            check_type(argname="argument net_netfilter_nf_conntrack_buckets", value=net_netfilter_nf_conntrack_buckets, expected_type=type_hints["net_netfilter_nf_conntrack_buckets"])
            check_type(argname="argument net_netfilter_nf_conntrack_max", value=net_netfilter_nf_conntrack_max, expected_type=type_hints["net_netfilter_nf_conntrack_max"])
            check_type(argname="argument vm_max_map_count", value=vm_max_map_count, expected_type=type_hints["vm_max_map_count"])
            check_type(argname="argument vm_swappiness", value=vm_swappiness, expected_type=type_hints["vm_swappiness"])
            check_type(argname="argument vm_vfs_cache_pressure", value=vm_vfs_cache_pressure, expected_type=type_hints["vm_vfs_cache_pressure"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if fs_aio_max_nr is not None:
            self._values["fs_aio_max_nr"] = fs_aio_max_nr
        if fs_file_max is not None:
            self._values["fs_file_max"] = fs_file_max
        if fs_inotify_max_user_watches is not None:
            self._values["fs_inotify_max_user_watches"] = fs_inotify_max_user_watches
        if fs_nr_open is not None:
            self._values["fs_nr_open"] = fs_nr_open
        if kernel_threads_max is not None:
            self._values["kernel_threads_max"] = kernel_threads_max
        if net_core_netdev_max_backlog is not None:
            self._values["net_core_netdev_max_backlog"] = net_core_netdev_max_backlog
        if net_core_optmem_max is not None:
            self._values["net_core_optmem_max"] = net_core_optmem_max
        if net_core_rmem_default is not None:
            self._values["net_core_rmem_default"] = net_core_rmem_default
        if net_core_rmem_max is not None:
            self._values["net_core_rmem_max"] = net_core_rmem_max
        if net_core_somaxconn is not None:
            self._values["net_core_somaxconn"] = net_core_somaxconn
        if net_core_wmem_default is not None:
            self._values["net_core_wmem_default"] = net_core_wmem_default
        if net_core_wmem_max is not None:
            self._values["net_core_wmem_max"] = net_core_wmem_max
        if net_ipv4_ip_local_port_range is not None:
            self._values["net_ipv4_ip_local_port_range"] = net_ipv4_ip_local_port_range
        if net_ipv4_neigh_default_gc_thresh1 is not None:
            self._values["net_ipv4_neigh_default_gc_thresh1"] = net_ipv4_neigh_default_gc_thresh1
        if net_ipv4_neigh_default_gc_thresh2 is not None:
            self._values["net_ipv4_neigh_default_gc_thresh2"] = net_ipv4_neigh_default_gc_thresh2
        if net_ipv4_neigh_default_gc_thresh3 is not None:
            self._values["net_ipv4_neigh_default_gc_thresh3"] = net_ipv4_neigh_default_gc_thresh3
        if net_ipv4_tcp_fin_timeout is not None:
            self._values["net_ipv4_tcp_fin_timeout"] = net_ipv4_tcp_fin_timeout
        if net_ipv4_tcpkeepalive_intvl is not None:
            self._values["net_ipv4_tcpkeepalive_intvl"] = net_ipv4_tcpkeepalive_intvl
        if net_ipv4_tcp_keepalive_probes is not None:
            self._values["net_ipv4_tcp_keepalive_probes"] = net_ipv4_tcp_keepalive_probes
        if net_ipv4_tcp_keepalive_time is not None:
            self._values["net_ipv4_tcp_keepalive_time"] = net_ipv4_tcp_keepalive_time
        if net_ipv4_tcp_max_syn_backlog is not None:
            self._values["net_ipv4_tcp_max_syn_backlog"] = net_ipv4_tcp_max_syn_backlog
        if net_ipv4_tcp_tw_reuse is not None:
            self._values["net_ipv4_tcp_tw_reuse"] = net_ipv4_tcp_tw_reuse
        if net_netfilter_nf_conntrack_buckets is not None:
            self._values["net_netfilter_nf_conntrack_buckets"] = net_netfilter_nf_conntrack_buckets
        if net_netfilter_nf_conntrack_max is not None:
            self._values["net_netfilter_nf_conntrack_max"] = net_netfilter_nf_conntrack_max
        if vm_max_map_count is not None:
            self._values["vm_max_map_count"] = vm_max_map_count
        if vm_swappiness is not None:
            self._values["vm_swappiness"] = vm_swappiness
        if vm_vfs_cache_pressure is not None:
            self._values["vm_vfs_cache_pressure"] = vm_vfs_cache_pressure

    @builtins.property
    def fs_aio_max_nr(self) -> typing.Optional[jsii.Number]:
        result = self._values.get("fs_aio_max_nr")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def fs_file_max(self) -> typing.Optional[jsii.Number]:
        result = self._values.get("fs_file_max")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def fs_inotify_max_user_watches(self) -> typing.Optional[jsii.Number]:
        result = self._values.get("fs_inotify_max_user_watches")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def fs_nr_open(self) -> typing.Optional[jsii.Number]:
        result = self._values.get("fs_nr_open")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def kernel_threads_max(self) -> typing.Optional[jsii.Number]:
        result = self._values.get("kernel_threads_max")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def net_core_netdev_max_backlog(self) -> typing.Optional[jsii.Number]:
        result = self._values.get("net_core_netdev_max_backlog")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def net_core_optmem_max(self) -> typing.Optional[jsii.Number]:
        result = self._values.get("net_core_optmem_max")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def net_core_rmem_default(self) -> typing.Optional[jsii.Number]:
        result = self._values.get("net_core_rmem_default")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def net_core_rmem_max(self) -> typing.Optional[jsii.Number]:
        result = self._values.get("net_core_rmem_max")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def net_core_somaxconn(self) -> typing.Optional[jsii.Number]:
        result = self._values.get("net_core_somaxconn")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def net_core_wmem_default(self) -> typing.Optional[jsii.Number]:
        result = self._values.get("net_core_wmem_default")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def net_core_wmem_max(self) -> typing.Optional[jsii.Number]:
        result = self._values.get("net_core_wmem_max")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def net_ipv4_ip_local_port_range(self) -> typing.Optional[builtins.str]:
        result = self._values.get("net_ipv4_ip_local_port_range")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def net_ipv4_neigh_default_gc_thresh1(self) -> typing.Optional[jsii.Number]:
        result = self._values.get("net_ipv4_neigh_default_gc_thresh1")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def net_ipv4_neigh_default_gc_thresh2(self) -> typing.Optional[jsii.Number]:
        result = self._values.get("net_ipv4_neigh_default_gc_thresh2")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def net_ipv4_neigh_default_gc_thresh3(self) -> typing.Optional[jsii.Number]:
        result = self._values.get("net_ipv4_neigh_default_gc_thresh3")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def net_ipv4_tcp_fin_timeout(self) -> typing.Optional[jsii.Number]:
        result = self._values.get("net_ipv4_tcp_fin_timeout")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def net_ipv4_tcpkeepalive_intvl(self) -> typing.Optional[jsii.Number]:
        result = self._values.get("net_ipv4_tcpkeepalive_intvl")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def net_ipv4_tcp_keepalive_probes(self) -> typing.Optional[jsii.Number]:
        result = self._values.get("net_ipv4_tcp_keepalive_probes")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def net_ipv4_tcp_keepalive_time(self) -> typing.Optional[jsii.Number]:
        result = self._values.get("net_ipv4_tcp_keepalive_time")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def net_ipv4_tcp_max_syn_backlog(self) -> typing.Optional[jsii.Number]:
        result = self._values.get("net_ipv4_tcp_max_syn_backlog")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def net_ipv4_tcp_tw_reuse(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("net_ipv4_tcp_tw_reuse")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def net_netfilter_nf_conntrack_buckets(self) -> typing.Optional[jsii.Number]:
        result = self._values.get("net_netfilter_nf_conntrack_buckets")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def net_netfilter_nf_conntrack_max(self) -> typing.Optional[jsii.Number]:
        result = self._values.get("net_netfilter_nf_conntrack_max")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def vm_max_map_count(self) -> typing.Optional[jsii.Number]:
        result = self._values.get("vm_max_map_count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def vm_swappiness(self) -> typing.Optional[jsii.Number]:
        result = self._values.get("vm_swappiness")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def vm_vfs_cache_pressure(self) -> typing.Optional[jsii.Number]:
        result = self._values.get("vm_vfs_cache_pressure")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AksClusterSysctlConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.AksClusterVerticalPodAutoscaler",
    jsii_struct_bases=[],
    name_mapping={"enabled": "enabled"},
)
class AksClusterVerticalPodAutoscaler:
    def __init__(self, *, enabled: typing.Optional[builtins.bool] = None) -> None:
        '''Vertical pod autoscaler.

        :param enabled: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3c83b9bef4e22c8f160596c60b45d9f2a6ee49e5892ff321ddcee8f7e469fbde)
            check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if enabled is not None:
            self._values["enabled"] = enabled

    @builtins.property
    def enabled(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AksClusterVerticalPodAutoscaler(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.AksClusterWindowsProfile",
    jsii_struct_bases=[],
    name_mapping={
        "admin_username": "adminUsername",
        "admin_password": "adminPassword",
        "enable_csi_proxy": "enableCSIProxy",
        "gmsa_profile": "gmsaProfile",
        "license_type": "licenseType",
    },
)
class AksClusterWindowsProfile:
    def __init__(
        self,
        *,
        admin_username: builtins.str,
        admin_password: typing.Optional[builtins.str] = None,
        enable_csi_proxy: typing.Optional[builtins.bool] = None,
        gmsa_profile: typing.Optional[typing.Union[_AksClusterGmsaProfile_c0e9a445, typing.Dict[builtins.str, typing.Any]]] = None,
        license_type: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Windows profile.

        :param admin_username: 
        :param admin_password: 
        :param enable_csi_proxy: 
        :param gmsa_profile: 
        :param license_type: 
        '''
        if isinstance(gmsa_profile, dict):
            gmsa_profile = _AksClusterGmsaProfile_c0e9a445(**gmsa_profile)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__afa95326b68be75a8390f6e0166dd38c57c7aa8347426d8555cac4719e7d21d9)
            check_type(argname="argument admin_username", value=admin_username, expected_type=type_hints["admin_username"])
            check_type(argname="argument admin_password", value=admin_password, expected_type=type_hints["admin_password"])
            check_type(argname="argument enable_csi_proxy", value=enable_csi_proxy, expected_type=type_hints["enable_csi_proxy"])
            check_type(argname="argument gmsa_profile", value=gmsa_profile, expected_type=type_hints["gmsa_profile"])
            check_type(argname="argument license_type", value=license_type, expected_type=type_hints["license_type"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "admin_username": admin_username,
        }
        if admin_password is not None:
            self._values["admin_password"] = admin_password
        if enable_csi_proxy is not None:
            self._values["enable_csi_proxy"] = enable_csi_proxy
        if gmsa_profile is not None:
            self._values["gmsa_profile"] = gmsa_profile
        if license_type is not None:
            self._values["license_type"] = license_type

    @builtins.property
    def admin_username(self) -> builtins.str:
        result = self._values.get("admin_username")
        assert result is not None, "Required property 'admin_username' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def admin_password(self) -> typing.Optional[builtins.str]:
        result = self._values.get("admin_password")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def enable_csi_proxy(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("enable_csi_proxy")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def gmsa_profile(self) -> typing.Optional[_AksClusterGmsaProfile_c0e9a445]:
        result = self._values.get("gmsa_profile")
        return typing.cast(typing.Optional[_AksClusterGmsaProfile_c0e9a445], result)

    @builtins.property
    def license_type(self) -> typing.Optional[builtins.str]:
        result = self._values.get("license_type")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AksClusterWindowsProfile(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.AksClusterWorkloadAutoScalerProfile",
    jsii_struct_bases=[],
    name_mapping={"keda": "keda", "vertical_pod_autoscaler": "verticalPodAutoscaler"},
)
class AksClusterWorkloadAutoScalerProfile:
    def __init__(
        self,
        *,
        keda: typing.Optional[typing.Union[_AksClusterKeda_9143ef79, typing.Dict[builtins.str, typing.Any]]] = None,
        vertical_pod_autoscaler: typing.Optional[typing.Union[_AksClusterVerticalPodAutoscaler_9805c99b, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Workload auto-scaler profile.

        :param keda: 
        :param vertical_pod_autoscaler: 
        '''
        if isinstance(keda, dict):
            keda = _AksClusterKeda_9143ef79(**keda)
        if isinstance(vertical_pod_autoscaler, dict):
            vertical_pod_autoscaler = _AksClusterVerticalPodAutoscaler_9805c99b(**vertical_pod_autoscaler)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a81614dd8aa091d61c534212debd456d85aeb71bcf9f71e9d9a3f9b9374b996b)
            check_type(argname="argument keda", value=keda, expected_type=type_hints["keda"])
            check_type(argname="argument vertical_pod_autoscaler", value=vertical_pod_autoscaler, expected_type=type_hints["vertical_pod_autoscaler"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if keda is not None:
            self._values["keda"] = keda
        if vertical_pod_autoscaler is not None:
            self._values["vertical_pod_autoscaler"] = vertical_pod_autoscaler

    @builtins.property
    def keda(self) -> typing.Optional[_AksClusterKeda_9143ef79]:
        result = self._values.get("keda")
        return typing.cast(typing.Optional[_AksClusterKeda_9143ef79], result)

    @builtins.property
    def vertical_pod_autoscaler(
        self,
    ) -> typing.Optional[_AksClusterVerticalPodAutoscaler_9805c99b]:
        result = self._values.get("vertical_pod_autoscaler")
        return typing.cast(typing.Optional[_AksClusterVerticalPodAutoscaler_9805c99b], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AksClusterWorkloadAutoScalerProfile(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.AksClusterWorkloadIdentity",
    jsii_struct_bases=[],
    name_mapping={"enabled": "enabled"},
)
class AksClusterWorkloadIdentity:
    def __init__(self, *, enabled: typing.Optional[builtins.bool] = None) -> None:
        '''Workload identity configuration.

        :param enabled: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3f707f80d3695339710c710be1293383b3cfb67c195c3198ec03bf5dbb237249)
            check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if enabled is not None:
            self._values["enabled"] = enabled

    @builtins.property
    def enabled(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AksClusterWorkloadIdentity(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.ApiSchema",
    jsii_struct_bases=[],
    name_mapping={
        "properties": "properties",
        "required": "required",
        "resource_type": "resourceType",
        "version": "version",
        "deprecated": "deprecated",
        "optional": "optional",
        "transformation_rules": "transformationRules",
        "validation_rules": "validationRules",
    },
)
class ApiSchema:
    def __init__(
        self,
        *,
        properties: typing.Mapping[builtins.str, typing.Union[_PropertyDefinition_2a5c46ac, typing.Dict[builtins.str, typing.Any]]],
        required: typing.Sequence[builtins.str],
        resource_type: builtins.str,
        version: builtins.str,
        deprecated: typing.Optional[typing.Sequence[builtins.str]] = None,
        optional: typing.Optional[typing.Sequence[builtins.str]] = None,
        transformation_rules: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        validation_rules: typing.Optional[typing.Sequence[typing.Union[_PropertyValidation_bb241cd7, typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''API Schema definition using TypeScript objects.

        Defines the complete schema for an API version including all properties,
        validation rules, and transformation mappings. This schema-driven approach
        enables automatic validation, transformation, and multi-language support.

        :param properties: Dictionary of property definitions keyed by property name Each property defines its type, validation, and metadata.
        :param required: Array of property names that are required Properties listed here must be provided by the user.
        :param resource_type: The Azure resource type this schema applies to.
        :param version: The API version this schema represents.
        :param deprecated: Array of property names that are deprecated Usage of these properties will generate warnings.
        :param optional: Array of property names that are optional Used for documentation and validation optimization.
        :param transformation_rules: Property transformation rules for schema mapping Maps input property names to target property names.
        :param validation_rules: Property-specific validation rules Applied in addition to individual property validation.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__12fabbb87f64a0ee51c6e5006ff938a67747ed83b3a25fa560ecafd1b8899108)
            check_type(argname="argument properties", value=properties, expected_type=type_hints["properties"])
            check_type(argname="argument required", value=required, expected_type=type_hints["required"])
            check_type(argname="argument resource_type", value=resource_type, expected_type=type_hints["resource_type"])
            check_type(argname="argument version", value=version, expected_type=type_hints["version"])
            check_type(argname="argument deprecated", value=deprecated, expected_type=type_hints["deprecated"])
            check_type(argname="argument optional", value=optional, expected_type=type_hints["optional"])
            check_type(argname="argument transformation_rules", value=transformation_rules, expected_type=type_hints["transformation_rules"])
            check_type(argname="argument validation_rules", value=validation_rules, expected_type=type_hints["validation_rules"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "properties": properties,
            "required": required,
            "resource_type": resource_type,
            "version": version,
        }
        if deprecated is not None:
            self._values["deprecated"] = deprecated
        if optional is not None:
            self._values["optional"] = optional
        if transformation_rules is not None:
            self._values["transformation_rules"] = transformation_rules
        if validation_rules is not None:
            self._values["validation_rules"] = validation_rules

    @builtins.property
    def properties(self) -> typing.Mapping[builtins.str, _PropertyDefinition_2a5c46ac]:
        '''Dictionary of property definitions keyed by property name Each property defines its type, validation, and metadata.

        Example::

            { "location": { type: "string", required: true } }
        '''
        result = self._values.get("properties")
        assert result is not None, "Required property 'properties' is missing"
        return typing.cast(typing.Mapping[builtins.str, _PropertyDefinition_2a5c46ac], result)

    @builtins.property
    def required(self) -> typing.List[builtins.str]:
        '''Array of property names that are required Properties listed here must be provided by the user.'''
        result = self._values.get("required")
        assert result is not None, "Required property 'required' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def resource_type(self) -> builtins.str:
        '''The Azure resource type this schema applies to.

        Example::

            "Microsoft.Resources/resourceGroups"
        '''
        result = self._values.get("resource_type")
        assert result is not None, "Required property 'resource_type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def version(self) -> builtins.str:
        '''The API version this schema represents.

        Example::

            "2024-11-01"
        '''
        result = self._values.get("version")
        assert result is not None, "Required property 'version' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def deprecated(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Array of property names that are deprecated Usage of these properties will generate warnings.'''
        result = self._values.get("deprecated")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def optional(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Array of property names that are optional Used for documentation and validation optimization.'''
        result = self._values.get("optional")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def transformation_rules(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Property transformation rules for schema mapping Maps input property names to target property names.

        Example::

            { "oldName": "newName" }
        '''
        result = self._values.get("transformation_rules")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def validation_rules(
        self,
    ) -> typing.Optional[typing.List[_PropertyValidation_bb241cd7]]:
        '''Property-specific validation rules Applied in addition to individual property validation.'''
        result = self._values.get("validation_rules")
        return typing.cast(typing.Optional[typing.List[_PropertyValidation_bb241cd7]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ApiSchema(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ApiVersionManager(
    metaclass=jsii.JSIIMeta,
    jsii_type="@microsoft/terraform-cdk-constructs.ApiVersionManager",
):
    '''ApiVersionManager singleton class for centralized version management.

    This class manages API versions for Azure resources, providing version resolution,
    compatibility analysis, and migration guidance. It implements a JSII-compliant
    singleton pattern for thread-safe operations across multiple language bindings.

    Key Features:

    - Thread-safe singleton implementation
    - Version registry management with full lifecycle support
    - Advanced version resolution with constraint-based selection
    - Comprehensive migration analysis with effort estimation
    - Extensive validation and error handling

    Example::

        const manager = ApiVersionManager.getInstance();
        manager.registerResourceType('Microsoft.Resources/resourceGroups', versions);
        const latest = manager.getLatestVersion('Microsoft.Resources/resourceGroups');
        const analysis = manager.analyzeMigration('Microsoft.Resources/resourceGroups', '2024-01-01', '2024-11-01');
    '''

    @jsii.member(jsii_name="instance")
    @builtins.classmethod
    def instance(cls) -> _ApiVersionManager_76b80279:
        '''Gets the singleton instance of ApiVersionManager.

        This method implements a thread-safe singleton pattern that's compatible
        with JSII multi-language bindings. The instance is lazily created on
        first access and reused for all subsequent calls.

        :return: The singleton ApiVersionManager instance

        Example::

            const manager = ApiVersionManager.instance();
        '''
        return typing.cast(_ApiVersionManager_76b80279, jsii.sinvoke(cls, "instance", []))

    @jsii.member(jsii_name="analyzeMigration")
    def analyze_migration(
        self,
        resource_type: builtins.str,
        from_version: builtins.str,
        to_version: builtins.str,
    ) -> _MigrationAnalysis_aa719f40:
        '''Analyzes migration requirements between two versions.

        Performs comprehensive analysis of the migration path between source and
        target versions, including compatibility assessment, breaking changes
        identification, effort estimation, and upgrade feasibility.

        :param resource_type: - The Azure resource type.
        :param from_version: - The source version to migrate from.
        :param to_version: - The target version to migrate to.

        :return: Detailed migration analysis results

        :throws: Error if resourceType is not registered

        Example::

            const analysis = manager.analyzeMigration(
              'Microsoft.Resources/resourceGroups',
              '2024-01-01',
              '2024-11-01'
            );
            
            console.log(`Compatible: ${analysis.compatible}`);
            console.log(`Effort: ${analysis.estimatedEffort}`);
            console.log(`Breaking changes: ${analysis.breakingChanges.length}`);
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__eae53c766f9143385cfa30da80231b50dafd818f3080b18188f5f0c916ecfc50)
            check_type(argname="argument resource_type", value=resource_type, expected_type=type_hints["resource_type"])
            check_type(argname="argument from_version", value=from_version, expected_type=type_hints["from_version"])
            check_type(argname="argument to_version", value=to_version, expected_type=type_hints["to_version"])
        return typing.cast(_MigrationAnalysis_aa719f40, jsii.invoke(self, "analyzeMigration", [resource_type, from_version, to_version]))

    @jsii.member(jsii_name="latestVersion")
    def latest_version(
        self,
        resource_type: builtins.str,
    ) -> typing.Optional[builtins.str]:
        '''Gets the latest active version for a resource type.

        Returns the most recent version with ACTIVE support level. If no active
        versions are found, returns the most recent version regardless of support level.

        :param resource_type: - The Azure resource type to get the latest version for.

        :return: The latest version string, or undefined if the resource type is not registered

        Example::

            const latest = manager.latestVersion('Microsoft.Resources/resourceGroups');
            // Returns: "2024-11-01"
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__636a56ca751ba2dbf19051f851f23072e2784c7160fa0cf0bc98210f88b6c1b8)
            check_type(argname="argument resource_type", value=resource_type, expected_type=type_hints["resource_type"])
        return typing.cast(typing.Optional[builtins.str], jsii.invoke(self, "latestVersion", [resource_type]))

    @jsii.member(jsii_name="registeredResourceTypes")
    def registered_resource_types(self) -> typing.List[builtins.str]:
        '''Gets all registered resource types.

        Returns an array of all Azure resource types that have been registered
        with the version manager.

        :return: Array of registered resource type strings

        Example::

            const resourceTypes = manager.registeredResourceTypes();
            // Returns: ["Microsoft.Resources/resourceGroups", "Microsoft.Storage/storageAccounts", ...]
        '''
        return typing.cast(typing.List[builtins.str], jsii.invoke(self, "registeredResourceTypes", []))

    @jsii.member(jsii_name="registerResourceType")
    def register_resource_type(
        self,
        resource_type: builtins.str,
        versions: typing.Sequence[typing.Union[_VersionConfig_ddf991d0, typing.Dict[builtins.str, typing.Any]]],
    ) -> None:
        '''Registers a resource type with its version configurations.

        This method stores version metadata for a specific Azure resource type,
        including schemas, lifecycle information, and migration data. It validates
        the input and maintains internal indexes for efficient lookups.

        :param resource_type: - The Azure resource type (e.g., 'Microsoft.Resources/resourceGroups').
        :param versions: - Array of version configurations for the resource type.

        :throws: Error if version configurations are invalid

        Example::

            manager.registerResourceType('Microsoft.Resources/resourceGroups', [
              {
                version: '2024-01-01',
                schema: { resourceType: 'Microsoft.Resources/resourceGroups', version: '2024-01-01', properties: {}, required: [] },
                supportLevel: VersionSupportLevel.ACTIVE,
                releaseDate: '2024-01-01'
              }
            ]);
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5b2e2a21286a265793ba7669b609f098592d5d32196c0618854904f1287e1a21)
            check_type(argname="argument resource_type", value=resource_type, expected_type=type_hints["resource_type"])
            check_type(argname="argument versions", value=versions, expected_type=type_hints["versions"])
        return typing.cast(None, jsii.invoke(self, "registerResourceType", [resource_type, versions]))

    @jsii.member(jsii_name="supportedVersions")
    def supported_versions(
        self,
        resource_type: builtins.str,
    ) -> typing.List[builtins.str]:
        '''Gets all supported versions for a resource type.

        Returns an array of all registered version strings for the specified
        resource type, sorted by release date (newest first).

        :param resource_type: - The Azure resource type.

        :return: Array of supported version strings, empty if resource type not registered

        Example::

            const versions = manager.supportedVersions('Microsoft.Resources/resourceGroups');
            // Returns: ["2024-11-01", "2024-01-01", "2023-07-01"]
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__66ce75bb791d3e413bf8c7023c3badc4380fc73c590dc3961bfe4124188fd11f)
            check_type(argname="argument resource_type", value=resource_type, expected_type=type_hints["resource_type"])
        return typing.cast(typing.List[builtins.str], jsii.invoke(self, "supportedVersions", [resource_type]))

    @jsii.member(jsii_name="validateVersionSupport")
    def validate_version_support(
        self,
        resource_type: builtins.str,
        version: builtins.str,
    ) -> builtins.bool:
        '''Validates whether a version is supported for a resource type.

        Checks if the specified version is registered and available for use
        with the given resource type.

        :param resource_type: - The Azure resource type.
        :param version: - The version to validate.

        :return: True if the version is supported, false otherwise

        Example::

            if (manager.validateVersionSupport('Microsoft.Resources/resourceGroups', '2024-01-01')) {
              // Version is supported, proceed with resource creation
            } else {
              // Handle unsupported version
            }
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c443670bc20deea13ae38f8902750eec74d9107e2b48beda38016054c3dd3672)
            check_type(argname="argument resource_type", value=resource_type, expected_type=type_hints["resource_type"])
            check_type(argname="argument version", value=version, expected_type=type_hints["version"])
        return typing.cast(builtins.bool, jsii.invoke(self, "validateVersionSupport", [resource_type, version]))

    @jsii.member(jsii_name="versionConfig")
    def version_config(
        self,
        resource_type: builtins.str,
        version: builtins.str,
    ) -> typing.Optional[_VersionConfig_ddf991d0]:
        '''Gets the configuration for a specific version of a resource type.

        Retrieves the complete version configuration including schema, lifecycle
        information, breaking changes, and migration metadata.

        :param resource_type: - The Azure resource type.
        :param version: - The specific version to retrieve.

        :return: The version configuration, or undefined if not found

        Example::

            const config = manager.versionConfig('Microsoft.Resources/resourceGroups', '2024-01-01');
            if (config) {
              console.log(`Support level: ${config.supportLevel}`);
              console.log(`Release date: ${config.releaseDate}`);
            }
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__adb294d786c98dfa983d0e38016c245d2dfd857f5389f013bd207654e42e710e)
            check_type(argname="argument resource_type", value=resource_type, expected_type=type_hints["resource_type"])
            check_type(argname="argument version", value=version, expected_type=type_hints["version"])
        return typing.cast(typing.Optional[_VersionConfig_ddf991d0], jsii.invoke(self, "versionConfig", [resource_type, version]))

    @jsii.member(jsii_name="versionLifecycle")
    def version_lifecycle(
        self,
        resource_type: builtins.str,
        version: builtins.str,
    ) -> typing.Optional[_VersionLifecycle_d648b2ea]:
        '''Gets version lifecycle information for a specific version.

        Provides lifecycle metadata including current phase, transition dates,
        and projected sunset timeline.

        :param resource_type: - The Azure resource type.
        :param version: - The version to get lifecycle information for.

        :return: Version lifecycle information, or undefined if not found

        Example::

            const lifecycle = manager.versionLifecycle('Microsoft.Resources/resourceGroups', '2024-01-01');
            if (lifecycle) {
              console.log(`Current phase: ${lifecycle.phase}`);
              console.log(`Sunset date: ${lifecycle.estimatedSunsetDate}`);
            }
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__01628a4957865cbca6342955dff8dba00e1fbcdfa7802c315b2771e4966560df)
            check_type(argname="argument resource_type", value=resource_type, expected_type=type_hints["resource_type"])
            check_type(argname="argument version", value=version, expected_type=type_hints["version"])
        return typing.cast(typing.Optional[_VersionLifecycle_d648b2ea], jsii.invoke(self, "versionLifecycle", [resource_type, version]))


class AssertionReturn(
    metaclass=jsii.JSIIMeta,
    jsii_type="@microsoft/terraform-cdk-constructs.AssertionReturn",
):
    def __init__(self, message: builtins.str, success: builtins.bool) -> None:
        '''Create an AssertionReturn.

        :param message: - String message containing information about the result of the assertion.
        :param success: - Boolean success denoting the success of the assertion.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ae7fe073015cf56686463e87ff5ad30357ed73941be698087bfebc604eadd783)
            check_type(argname="argument message", value=message, expected_type=type_hints["message"])
            check_type(argname="argument success", value=success, expected_type=type_hints["success"])
        jsii.create(self.__class__, self, [message, success])

    @builtins.property
    @jsii.member(jsii_name="message")
    def message(self) -> builtins.str:
        '''- String message containing information about the result of the assertion.'''
        return typing.cast(builtins.str, jsii.get(self, "message"))

    @builtins.property
    @jsii.member(jsii_name="success")
    def success(self) -> builtins.bool:
        '''- Boolean success denoting the success of the assertion.'''
        return typing.cast(builtins.bool, jsii.get(self, "success"))


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.AutomaticOSUpgradePolicy",
    jsii_struct_bases=[],
    name_mapping={
        "disable_automatic_rollback": "disableAutomaticRollback",
        "enable_automatic_os_upgrade": "enableAutomaticOSUpgrade",
        "use_rolling_upgrade_policy": "useRollingUpgradePolicy",
    },
)
class AutomaticOSUpgradePolicy:
    def __init__(
        self,
        *,
        disable_automatic_rollback: typing.Optional[builtins.bool] = None,
        enable_automatic_os_upgrade: typing.Optional[builtins.bool] = None,
        use_rolling_upgrade_policy: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Automatic OS upgrade policy.

        :param disable_automatic_rollback: 
        :param enable_automatic_os_upgrade: 
        :param use_rolling_upgrade_policy: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__194415315dbd09ee2b97f91a9ac98f99fec1d41d8249f48d4aa444a47fcb20ed)
            check_type(argname="argument disable_automatic_rollback", value=disable_automatic_rollback, expected_type=type_hints["disable_automatic_rollback"])
            check_type(argname="argument enable_automatic_os_upgrade", value=enable_automatic_os_upgrade, expected_type=type_hints["enable_automatic_os_upgrade"])
            check_type(argname="argument use_rolling_upgrade_policy", value=use_rolling_upgrade_policy, expected_type=type_hints["use_rolling_upgrade_policy"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if disable_automatic_rollback is not None:
            self._values["disable_automatic_rollback"] = disable_automatic_rollback
        if enable_automatic_os_upgrade is not None:
            self._values["enable_automatic_os_upgrade"] = enable_automatic_os_upgrade
        if use_rolling_upgrade_policy is not None:
            self._values["use_rolling_upgrade_policy"] = use_rolling_upgrade_policy

    @builtins.property
    def disable_automatic_rollback(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("disable_automatic_rollback")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_automatic_os_upgrade(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("enable_automatic_os_upgrade")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def use_rolling_upgrade_policy(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("use_rolling_upgrade_policy")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AutomaticOSUpgradePolicy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.AutomaticRepairsPolicy",
    jsii_struct_bases=[],
    name_mapping={
        "enabled": "enabled",
        "grace_period": "gracePeriod",
        "repair_action": "repairAction",
    },
)
class AutomaticRepairsPolicy:
    def __init__(
        self,
        *,
        enabled: typing.Optional[builtins.bool] = None,
        grace_period: typing.Optional[builtins.str] = None,
        repair_action: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Automatic repairs policy.

        :param enabled: 
        :param grace_period: 
        :param repair_action: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2871bbbebfc2e7a57f303cea5e9e724a0a67630b4a3d4d1da16441dce722006c)
            check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
            check_type(argname="argument grace_period", value=grace_period, expected_type=type_hints["grace_period"])
            check_type(argname="argument repair_action", value=repair_action, expected_type=type_hints["repair_action"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if enabled is not None:
            self._values["enabled"] = enabled
        if grace_period is not None:
            self._values["grace_period"] = grace_period
        if repair_action is not None:
            self._values["repair_action"] = repair_action

    @builtins.property
    def enabled(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def grace_period(self) -> typing.Optional[builtins.str]:
        result = self._values.get("grace_period")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def repair_action(self) -> typing.Optional[builtins.str]:
        result = self._values.get("repair_action")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AutomaticRepairsPolicy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AzapiProvider(
    _cdktf_9a9027ec.TerraformProvider,
    metaclass=jsii.JSIIMeta,
    jsii_type="@microsoft/terraform-cdk-constructs.AzapiProvider",
):
    '''Represents a {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs azapi}.'''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        alias: typing.Optional[builtins.str] = None,
        auxiliary_tenant_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
        client_certificate: typing.Optional[builtins.str] = None,
        client_certificate_password: typing.Optional[builtins.str] = None,
        client_certificate_path: typing.Optional[builtins.str] = None,
        client_id: typing.Optional[builtins.str] = None,
        client_id_file_path: typing.Optional[builtins.str] = None,
        client_secret: typing.Optional[builtins.str] = None,
        client_secret_file_path: typing.Optional[builtins.str] = None,
        custom_correlation_request_id: typing.Optional[builtins.str] = None,
        default_location: typing.Optional[builtins.str] = None,
        default_name: typing.Optional[builtins.str] = None,
        default_tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        disable_correlation_request_id: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        disable_default_output: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        disable_instance_discovery: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        disable_terraform_partner_id: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        enable_preflight: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        endpoint: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["AzapiProviderEndpoint", typing.Dict[builtins.str, typing.Any]]]]] = None,
        environment: typing.Optional[builtins.str] = None,
        ignore_no_op_changes: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        maximum_busy_retry_attempts: typing.Optional[jsii.Number] = None,
        oidc_azure_service_connection_id: typing.Optional[builtins.str] = None,
        oidc_request_token: typing.Optional[builtins.str] = None,
        oidc_request_url: typing.Optional[builtins.str] = None,
        oidc_token: typing.Optional[builtins.str] = None,
        oidc_token_file_path: typing.Optional[builtins.str] = None,
        partner_id: typing.Optional[builtins.str] = None,
        skip_provider_registration: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        subscription_id: typing.Optional[builtins.str] = None,
        tenant_id: typing.Optional[builtins.str] = None,
        use_aks_workload_identity: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        use_cli: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        use_msi: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        use_oidc: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    ) -> None:
        '''Create a new {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs azapi} Resource.

        :param scope: The scope in which to define this construct.
        :param id: The scoped construct ID. Must be unique amongst siblings in the same scope
        :param alias: Alias name. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#alias AzapiProvider#alias}
        :param auxiliary_tenant_ids: List of auxiliary Tenant IDs required for multi-tenancy and cross-tenant scenarios. This can also be sourced from the ``ARM_AUXILIARY_TENANT_IDS`` Environment Variable. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#auxiliary_tenant_ids AzapiProvider#auxiliary_tenant_ids}
        :param client_certificate: A base64-encoded PKCS#12 bundle to be used as the client certificate for authentication. This can also be sourced from the ``ARM_CLIENT_CERTIFICATE`` environment variable. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#client_certificate AzapiProvider#client_certificate}
        :param client_certificate_password: The password associated with the Client Certificate. This can also be sourced from the ``ARM_CLIENT_CERTIFICATE_PASSWORD`` Environment Variable. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#client_certificate_password AzapiProvider#client_certificate_password}
        :param client_certificate_path: The path to the Client Certificate associated with the Service Principal which should be used. This can also be sourced from the ``ARM_CLIENT_CERTIFICATE_PATH`` Environment Variable. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#client_certificate_path AzapiProvider#client_certificate_path}
        :param client_id: The Client ID which should be used. This can also be sourced from the ``ARM_CLIENT_ID``, ``AZURE_CLIENT_ID`` Environment Variable. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#client_id AzapiProvider#client_id}
        :param client_id_file_path: The path to a file containing the Client ID which should be used. This can also be sourced from the ``ARM_CLIENT_ID_FILE_PATH`` Environment Variable. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#client_id_file_path AzapiProvider#client_id_file_path}
        :param client_secret: The Client Secret which should be used. This can also be sourced from the ``ARM_CLIENT_SECRET`` Environment Variable. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#client_secret AzapiProvider#client_secret}
        :param client_secret_file_path: The path to a file containing the Client Secret which should be used. For use When authenticating as a Service Principal using a Client Secret. This can also be sourced from the ``ARM_CLIENT_SECRET_FILE_PATH`` Environment Variable. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#client_secret_file_path AzapiProvider#client_secret_file_path}
        :param custom_correlation_request_id: The value of the ``x-ms-correlation-request-id`` header, otherwise an auto-generated UUID will be used. This can also be sourced from the ``ARM_CORRELATION_REQUEST_ID`` environment variable. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#custom_correlation_request_id AzapiProvider#custom_correlation_request_id}
        :param default_location: The default Azure Region where the azure resource should exist. The ``location`` in each resource block can override the ``default_location``. Changing this forces new resources to be created. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#default_location AzapiProvider#default_location}
        :param default_name: The default name to create the azure resource. The ``name`` in each resource block can override the ``default_name``. Changing this forces new resources to be created. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#default_name AzapiProvider#default_name}
        :param default_tags: A mapping of tags which should be assigned to the azure resource as default tags. The``tags`` in each resource block can override the ``default_tags``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#default_tags AzapiProvider#default_tags}
        :param disable_correlation_request_id: This will disable the x-ms-correlation-request-id header. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#disable_correlation_request_id AzapiProvider#disable_correlation_request_id}
        :param disable_default_output: Disable default output. The default is false. When set to false, the provider will output the read-only properties if ``response_export_values`` is not specified in the resource block. When set to true, the provider will disable this output. This can also be sourced from the ``ARM_DISABLE_DEFAULT_OUTPUT`` Environment Variable. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#disable_default_output AzapiProvider#disable_default_output}
        :param disable_instance_discovery: Disables Instance Discovery, which validates that the Authority is valid and known by the Microsoft Entra instance metadata service at ``https://login.microsoft.com`` before authenticating. This should only be enabled when the configured authority is known to be valid and trustworthy - such as when running against Azure Stack or when ``environment`` is set to ``custom``. This can also be specified via the ``ARM_DISABLE_INSTANCE_DISCOVERY`` environment variable. Defaults to ``false``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#disable_instance_discovery AzapiProvider#disable_instance_discovery}
        :param disable_terraform_partner_id: Disable sending the Terraform Partner ID if a custom ``partner_id`` isn't specified, which allows Microsoft to better understand the usage of Terraform. The Partner ID does not give HashiCorp any direct access to usage information. This can also be sourced from the ``ARM_DISABLE_TERRAFORM_PARTNER_ID`` environment variable. Defaults to ``false``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#disable_terraform_partner_id AzapiProvider#disable_terraform_partner_id}
        :param enable_preflight: Enable Preflight Validation. The default is false. When set to true, the provider will use Preflight to do static validation before really deploying a new resource. When set to false, the provider will disable this validation. This can also be sourced from the ``ARM_ENABLE_PREFLIGHT`` Environment Variable. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#enable_preflight AzapiProvider#enable_preflight}
        :param endpoint: The Azure API Endpoint Configuration. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#endpoint AzapiProvider#endpoint}
        :param environment: The Cloud Environment which should be used. Possible values are ``public``, ``usgovernment``, ``china`` and ``custom``. Defaults to ``public``. This can also be sourced from the ``ARM_ENVIRONMENT`` Environment Variable. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#environment AzapiProvider#environment}
        :param ignore_no_op_changes: Ignore no-op changes for ``azapi_resource``. The default is true. When set to true, the provider will suppress changes in the ``azapi_resource`` if the ``body`` in the new API version still matches the remote state. When set to false, the provider will not suppress these changes. This can also be sourced from the ``ARM_IGNORE_NO_OP_CHANGES`` Environment Variable. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#ignore_no_op_changes AzapiProvider#ignore_no_op_changes}
        :param maximum_busy_retry_attempts: DEPRECATED - The maximum number of retries to attempt if the Azure API returns an HTTP 408, 429, 500, 502, 503, or 504 response. The default is ``32767``, this allows the provider to rely on the resource timeout values rather than a maximum retry count. The resource-specific retry configuration may additionally be used to retry on other errors and conditions. This property will be removed in a future version. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#maximum_busy_retry_attempts AzapiProvider#maximum_busy_retry_attempts}
        :param oidc_azure_service_connection_id: The Azure Pipelines Service Connection ID to use for authentication. This can also be sourced from the ``ARM_ADO_PIPELINE_SERVICE_CONNECTION_ID``, ``ARM_OIDC_AZURE_SERVICE_CONNECTION_ID``, or ``AZURESUBSCRIPTION_SERVICE_CONNECTION_ID`` Environment Variables. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#oidc_azure_service_connection_id AzapiProvider#oidc_azure_service_connection_id}
        :param oidc_request_token: The bearer token for the request to the OIDC provider. This can also be sourced from the ``ARM_OIDC_REQUEST_TOKEN``, ``ACTIONS_ID_TOKEN_REQUEST_TOKEN``, or ``SYSTEM_ACCESSTOKEN`` Environment Variables. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#oidc_request_token AzapiProvider#oidc_request_token}
        :param oidc_request_url: The URL for the OIDC provider from which to request an ID token. This can also be sourced from the ``ARM_OIDC_REQUEST_URL``, ``ACTIONS_ID_TOKEN_REQUEST_URL``, or ``SYSTEM_OIDCREQUESTURI`` Environment Variables. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#oidc_request_url AzapiProvider#oidc_request_url}
        :param oidc_token: The ID token when authenticating using OpenID Connect (OIDC). This can also be sourced from the ``ARM_OIDC_TOKEN`` environment Variable. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#oidc_token AzapiProvider#oidc_token}
        :param oidc_token_file_path: The path to a file containing an ID token when authenticating using OpenID Connect (OIDC). This can also be sourced from the ``ARM_OIDC_TOKEN_FILE_PATH``, ``AZURE_FEDERATED_TOKEN_FILE`` environment Variable. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#oidc_token_file_path AzapiProvider#oidc_token_file_path}
        :param partner_id: A GUID/UUID that is `registered <https://docs.microsoft.com/azure/marketplace/azure-partner-customer-usage-attribution#register-guids-and-offers>`_ with Microsoft to facilitate partner resource usage attribution. This can also be sourced from the ``ARM_PARTNER_ID`` Environment Variable. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#partner_id AzapiProvider#partner_id}
        :param skip_provider_registration: Should the Provider skip registering the Resource Providers it supports? This can also be sourced from the ``ARM_SKIP_PROVIDER_REGISTRATION`` Environment Variable. Defaults to ``false``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#skip_provider_registration AzapiProvider#skip_provider_registration}
        :param subscription_id: The Subscription ID which should be used. This can also be sourced from the ``ARM_SUBSCRIPTION_ID`` Environment Variable. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#subscription_id AzapiProvider#subscription_id}
        :param tenant_id: The Tenant ID should be used. This can also be sourced from the ``ARM_TENANT_ID`` Environment Variable. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#tenant_id AzapiProvider#tenant_id}
        :param use_aks_workload_identity: Should AKS Workload Identity be used for Authentication? This can also be sourced from the ``ARM_USE_AKS_WORKLOAD_IDENTITY`` Environment Variable. Defaults to ``false``. When set, ``client_id``, ``tenant_id`` and ``oidc_token_file_path`` will be detected from the environment and do not need to be specified. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#use_aks_workload_identity AzapiProvider#use_aks_workload_identity}
        :param use_cli: Should Azure CLI be used for authentication? This can also be sourced from the ``ARM_USE_CLI`` environment variable. Defaults to ``true``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#use_cli AzapiProvider#use_cli}
        :param use_msi: Should Managed Identity be used for Authentication? This can also be sourced from the ``ARM_USE_MSI`` Environment Variable. Defaults to ``false``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#use_msi AzapiProvider#use_msi}
        :param use_oidc: Should OIDC be used for Authentication? This can also be sourced from the ``ARM_USE_OIDC`` Environment Variable. Defaults to ``false``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#use_oidc AzapiProvider#use_oidc}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a5f9cea36880d03010cb1b70995ef9fd0e5cedc71505f6aef89623a0725d0876)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        config = AzapiProviderConfig(
            alias=alias,
            auxiliary_tenant_ids=auxiliary_tenant_ids,
            client_certificate=client_certificate,
            client_certificate_password=client_certificate_password,
            client_certificate_path=client_certificate_path,
            client_id=client_id,
            client_id_file_path=client_id_file_path,
            client_secret=client_secret,
            client_secret_file_path=client_secret_file_path,
            custom_correlation_request_id=custom_correlation_request_id,
            default_location=default_location,
            default_name=default_name,
            default_tags=default_tags,
            disable_correlation_request_id=disable_correlation_request_id,
            disable_default_output=disable_default_output,
            disable_instance_discovery=disable_instance_discovery,
            disable_terraform_partner_id=disable_terraform_partner_id,
            enable_preflight=enable_preflight,
            endpoint=endpoint,
            environment=environment,
            ignore_no_op_changes=ignore_no_op_changes,
            maximum_busy_retry_attempts=maximum_busy_retry_attempts,
            oidc_azure_service_connection_id=oidc_azure_service_connection_id,
            oidc_request_token=oidc_request_token,
            oidc_request_url=oidc_request_url,
            oidc_token=oidc_token,
            oidc_token_file_path=oidc_token_file_path,
            partner_id=partner_id,
            skip_provider_registration=skip_provider_registration,
            subscription_id=subscription_id,
            tenant_id=tenant_id,
            use_aks_workload_identity=use_aks_workload_identity,
            use_cli=use_cli,
            use_msi=use_msi,
            use_oidc=use_oidc,
        )

        jsii.create(self.__class__, self, [scope, id, config])

    @jsii.member(jsii_name="generateConfigForImport")
    @builtins.classmethod
    def generate_config_for_import(
        cls,
        scope: _constructs_77d1e7e8.Construct,
        import_to_id: builtins.str,
        import_from_id: builtins.str,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    ) -> _cdktf_9a9027ec.ImportableResource:
        '''Generates CDKTF code for importing a AzapiProvider resource upon running "cdktf plan ".

        :param scope: The scope in which to define this construct.
        :param import_to_id: The construct id used in the generated config for the AzapiProvider to import.
        :param import_from_id: The id of the existing AzapiProvider that should be imported. Refer to the {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#import import section} in the documentation of this resource for the id to use
        :param provider: ? Optional instance of the provider where the AzapiProvider to import is found.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3ba65bc39809a5dcaa18f8aae1d1b9aedcff69a7e24e3f885fba93873889ad49)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument import_to_id", value=import_to_id, expected_type=type_hints["import_to_id"])
            check_type(argname="argument import_from_id", value=import_from_id, expected_type=type_hints["import_from_id"])
            check_type(argname="argument provider", value=provider, expected_type=type_hints["provider"])
        return typing.cast(_cdktf_9a9027ec.ImportableResource, jsii.sinvoke(cls, "generateConfigForImport", [scope, import_to_id, import_from_id, provider]))

    @jsii.member(jsii_name="resetAlias")
    def reset_alias(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAlias", []))

    @jsii.member(jsii_name="resetAuxiliaryTenantIds")
    def reset_auxiliary_tenant_ids(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAuxiliaryTenantIds", []))

    @jsii.member(jsii_name="resetClientCertificate")
    def reset_client_certificate(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetClientCertificate", []))

    @jsii.member(jsii_name="resetClientCertificatePassword")
    def reset_client_certificate_password(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetClientCertificatePassword", []))

    @jsii.member(jsii_name="resetClientCertificatePath")
    def reset_client_certificate_path(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetClientCertificatePath", []))

    @jsii.member(jsii_name="resetClientId")
    def reset_client_id(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetClientId", []))

    @jsii.member(jsii_name="resetClientIdFilePath")
    def reset_client_id_file_path(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetClientIdFilePath", []))

    @jsii.member(jsii_name="resetClientSecret")
    def reset_client_secret(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetClientSecret", []))

    @jsii.member(jsii_name="resetClientSecretFilePath")
    def reset_client_secret_file_path(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetClientSecretFilePath", []))

    @jsii.member(jsii_name="resetCustomCorrelationRequestId")
    def reset_custom_correlation_request_id(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCustomCorrelationRequestId", []))

    @jsii.member(jsii_name="resetDefaultLocation")
    def reset_default_location(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDefaultLocation", []))

    @jsii.member(jsii_name="resetDefaultName")
    def reset_default_name(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDefaultName", []))

    @jsii.member(jsii_name="resetDefaultTags")
    def reset_default_tags(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDefaultTags", []))

    @jsii.member(jsii_name="resetDisableCorrelationRequestId")
    def reset_disable_correlation_request_id(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDisableCorrelationRequestId", []))

    @jsii.member(jsii_name="resetDisableDefaultOutput")
    def reset_disable_default_output(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDisableDefaultOutput", []))

    @jsii.member(jsii_name="resetDisableInstanceDiscovery")
    def reset_disable_instance_discovery(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDisableInstanceDiscovery", []))

    @jsii.member(jsii_name="resetDisableTerraformPartnerId")
    def reset_disable_terraform_partner_id(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDisableTerraformPartnerId", []))

    @jsii.member(jsii_name="resetEnablePreflight")
    def reset_enable_preflight(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEnablePreflight", []))

    @jsii.member(jsii_name="resetEndpoint")
    def reset_endpoint(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEndpoint", []))

    @jsii.member(jsii_name="resetEnvironment")
    def reset_environment(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetEnvironment", []))

    @jsii.member(jsii_name="resetIgnoreNoOpChanges")
    def reset_ignore_no_op_changes(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetIgnoreNoOpChanges", []))

    @jsii.member(jsii_name="resetMaximumBusyRetryAttempts")
    def reset_maximum_busy_retry_attempts(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMaximumBusyRetryAttempts", []))

    @jsii.member(jsii_name="resetOidcAzureServiceConnectionId")
    def reset_oidc_azure_service_connection_id(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetOidcAzureServiceConnectionId", []))

    @jsii.member(jsii_name="resetOidcRequestToken")
    def reset_oidc_request_token(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetOidcRequestToken", []))

    @jsii.member(jsii_name="resetOidcRequestUrl")
    def reset_oidc_request_url(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetOidcRequestUrl", []))

    @jsii.member(jsii_name="resetOidcToken")
    def reset_oidc_token(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetOidcToken", []))

    @jsii.member(jsii_name="resetOidcTokenFilePath")
    def reset_oidc_token_file_path(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetOidcTokenFilePath", []))

    @jsii.member(jsii_name="resetPartnerId")
    def reset_partner_id(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetPartnerId", []))

    @jsii.member(jsii_name="resetSkipProviderRegistration")
    def reset_skip_provider_registration(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSkipProviderRegistration", []))

    @jsii.member(jsii_name="resetSubscriptionId")
    def reset_subscription_id(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSubscriptionId", []))

    @jsii.member(jsii_name="resetTenantId")
    def reset_tenant_id(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTenantId", []))

    @jsii.member(jsii_name="resetUseAksWorkloadIdentity")
    def reset_use_aks_workload_identity(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetUseAksWorkloadIdentity", []))

    @jsii.member(jsii_name="resetUseCli")
    def reset_use_cli(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetUseCli", []))

    @jsii.member(jsii_name="resetUseMsi")
    def reset_use_msi(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetUseMsi", []))

    @jsii.member(jsii_name="resetUseOidc")
    def reset_use_oidc(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetUseOidc", []))

    @jsii.member(jsii_name="synthesizeAttributes")
    def _synthesize_attributes(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "synthesizeAttributes", []))

    @jsii.member(jsii_name="synthesizeHclAttributes")
    def _synthesize_hcl_attributes(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "synthesizeHclAttributes", []))

    @jsii.python.classproperty
    @jsii.member(jsii_name="tfResourceType")
    def TF_RESOURCE_TYPE(cls) -> builtins.str:
        return typing.cast(builtins.str, jsii.sget(cls, "tfResourceType"))

    @builtins.property
    @jsii.member(jsii_name="aliasInput")
    def alias_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "aliasInput"))

    @builtins.property
    @jsii.member(jsii_name="auxiliaryTenantIdsInput")
    def auxiliary_tenant_ids_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "auxiliaryTenantIdsInput"))

    @builtins.property
    @jsii.member(jsii_name="clientCertificateInput")
    def client_certificate_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "clientCertificateInput"))

    @builtins.property
    @jsii.member(jsii_name="clientCertificatePasswordInput")
    def client_certificate_password_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "clientCertificatePasswordInput"))

    @builtins.property
    @jsii.member(jsii_name="clientCertificatePathInput")
    def client_certificate_path_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "clientCertificatePathInput"))

    @builtins.property
    @jsii.member(jsii_name="clientIdFilePathInput")
    def client_id_file_path_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "clientIdFilePathInput"))

    @builtins.property
    @jsii.member(jsii_name="clientIdInput")
    def client_id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "clientIdInput"))

    @builtins.property
    @jsii.member(jsii_name="clientSecretFilePathInput")
    def client_secret_file_path_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "clientSecretFilePathInput"))

    @builtins.property
    @jsii.member(jsii_name="clientSecretInput")
    def client_secret_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "clientSecretInput"))

    @builtins.property
    @jsii.member(jsii_name="customCorrelationRequestIdInput")
    def custom_correlation_request_id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "customCorrelationRequestIdInput"))

    @builtins.property
    @jsii.member(jsii_name="defaultLocationInput")
    def default_location_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "defaultLocationInput"))

    @builtins.property
    @jsii.member(jsii_name="defaultNameInput")
    def default_name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "defaultNameInput"))

    @builtins.property
    @jsii.member(jsii_name="defaultTagsInput")
    def default_tags_input(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], jsii.get(self, "defaultTagsInput"))

    @builtins.property
    @jsii.member(jsii_name="disableCorrelationRequestIdInput")
    def disable_correlation_request_id_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "disableCorrelationRequestIdInput"))

    @builtins.property
    @jsii.member(jsii_name="disableDefaultOutputInput")
    def disable_default_output_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "disableDefaultOutputInput"))

    @builtins.property
    @jsii.member(jsii_name="disableInstanceDiscoveryInput")
    def disable_instance_discovery_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "disableInstanceDiscoveryInput"))

    @builtins.property
    @jsii.member(jsii_name="disableTerraformPartnerIdInput")
    def disable_terraform_partner_id_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "disableTerraformPartnerIdInput"))

    @builtins.property
    @jsii.member(jsii_name="enablePreflightInput")
    def enable_preflight_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "enablePreflightInput"))

    @builtins.property
    @jsii.member(jsii_name="endpointInput")
    def endpoint_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AzapiProviderEndpoint"]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AzapiProviderEndpoint"]]], jsii.get(self, "endpointInput"))

    @builtins.property
    @jsii.member(jsii_name="environmentInput")
    def environment_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "environmentInput"))

    @builtins.property
    @jsii.member(jsii_name="ignoreNoOpChangesInput")
    def ignore_no_op_changes_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "ignoreNoOpChangesInput"))

    @builtins.property
    @jsii.member(jsii_name="maximumBusyRetryAttemptsInput")
    def maximum_busy_retry_attempts_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "maximumBusyRetryAttemptsInput"))

    @builtins.property
    @jsii.member(jsii_name="oidcAzureServiceConnectionIdInput")
    def oidc_azure_service_connection_id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "oidcAzureServiceConnectionIdInput"))

    @builtins.property
    @jsii.member(jsii_name="oidcRequestTokenInput")
    def oidc_request_token_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "oidcRequestTokenInput"))

    @builtins.property
    @jsii.member(jsii_name="oidcRequestUrlInput")
    def oidc_request_url_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "oidcRequestUrlInput"))

    @builtins.property
    @jsii.member(jsii_name="oidcTokenFilePathInput")
    def oidc_token_file_path_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "oidcTokenFilePathInput"))

    @builtins.property
    @jsii.member(jsii_name="oidcTokenInput")
    def oidc_token_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "oidcTokenInput"))

    @builtins.property
    @jsii.member(jsii_name="partnerIdInput")
    def partner_id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "partnerIdInput"))

    @builtins.property
    @jsii.member(jsii_name="skipProviderRegistrationInput")
    def skip_provider_registration_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "skipProviderRegistrationInput"))

    @builtins.property
    @jsii.member(jsii_name="subscriptionIdInput")
    def subscription_id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "subscriptionIdInput"))

    @builtins.property
    @jsii.member(jsii_name="tenantIdInput")
    def tenant_id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "tenantIdInput"))

    @builtins.property
    @jsii.member(jsii_name="useAksWorkloadIdentityInput")
    def use_aks_workload_identity_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "useAksWorkloadIdentityInput"))

    @builtins.property
    @jsii.member(jsii_name="useCliInput")
    def use_cli_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "useCliInput"))

    @builtins.property
    @jsii.member(jsii_name="useMsiInput")
    def use_msi_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "useMsiInput"))

    @builtins.property
    @jsii.member(jsii_name="useOidcInput")
    def use_oidc_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "useOidcInput"))

    @builtins.property
    @jsii.member(jsii_name="alias")
    def alias(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "alias"))

    @alias.setter
    def alias(self, value: typing.Optional[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cbef319cbcdc3b9dfed2873506369c085c58a0826d99821619eda6a00e63d6f3)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "alias", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="auxiliaryTenantIds")
    def auxiliary_tenant_ids(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "auxiliaryTenantIds"))

    @auxiliary_tenant_ids.setter
    def auxiliary_tenant_ids(
        self,
        value: typing.Optional[typing.List[builtins.str]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6f472f50f39b8c5d3dc772e69c963fc12088f62ca8f09c473fdf03761e4673ee)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "auxiliaryTenantIds", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="clientCertificate")
    def client_certificate(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "clientCertificate"))

    @client_certificate.setter
    def client_certificate(self, value: typing.Optional[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3ad1f6fdd24fe8a50dfde5c253049b8d770be9c3fda1ec388d2053c26b903891)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "clientCertificate", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="clientCertificatePassword")
    def client_certificate_password(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "clientCertificatePassword"))

    @client_certificate_password.setter
    def client_certificate_password(self, value: typing.Optional[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4eac6824e9452d947248f9082f53a122107f4981d6de6e80ebfbca26d559937b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "clientCertificatePassword", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="clientCertificatePath")
    def client_certificate_path(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "clientCertificatePath"))

    @client_certificate_path.setter
    def client_certificate_path(self, value: typing.Optional[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__192c91d1a15d7c3aa7cb9ffc3640f29223bf07b18b3bda3c242e234eb61e3cd3)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "clientCertificatePath", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="clientId")
    def client_id(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "clientId"))

    @client_id.setter
    def client_id(self, value: typing.Optional[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__07a96d3b700872ab930bc5bc74d7e95c2a03ac08e4b48ee97104cfdaea9d557c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "clientId", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="clientIdFilePath")
    def client_id_file_path(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "clientIdFilePath"))

    @client_id_file_path.setter
    def client_id_file_path(self, value: typing.Optional[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c1e26b5ab83abea93c12873ad7b4ddc95472bef166758e3566bad231d92039ba)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "clientIdFilePath", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="clientSecret")
    def client_secret(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "clientSecret"))

    @client_secret.setter
    def client_secret(self, value: typing.Optional[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bd283365e4165768209d1912540e5298fe369dd30b0ad23a4541b89b3bb6014f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "clientSecret", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="clientSecretFilePath")
    def client_secret_file_path(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "clientSecretFilePath"))

    @client_secret_file_path.setter
    def client_secret_file_path(self, value: typing.Optional[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d83dc22d1320b596539f411a49de0f7b349627a9f7cac5f8d555a53c37f87fe4)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "clientSecretFilePath", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="customCorrelationRequestId")
    def custom_correlation_request_id(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "customCorrelationRequestId"))

    @custom_correlation_request_id.setter
    def custom_correlation_request_id(
        self,
        value: typing.Optional[builtins.str],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3ae69862791437eeedf34a23931f1fe7f9742c3ef45a1557464e02e38f7c7133)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "customCorrelationRequestId", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="defaultLocation")
    def default_location(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "defaultLocation"))

    @default_location.setter
    def default_location(self, value: typing.Optional[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cc13316d308c9305ce821a04f8475df7362ceaede7807ea85b72c3a6532d3d86)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "defaultLocation", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="defaultName")
    def default_name(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "defaultName"))

    @default_name.setter
    def default_name(self, value: typing.Optional[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c157e91f959779058738f1fded056d71eda2afe7f0174b505e1916c94f9b3a11)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "defaultName", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="defaultTags")
    def default_tags(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], jsii.get(self, "defaultTags"))

    @default_tags.setter
    def default_tags(
        self,
        value: typing.Optional[typing.Mapping[builtins.str, builtins.str]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4bd10e19356173cb75790606ab1aa3649a7c8e9e3e4924fbf255d51acd55af0a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "defaultTags", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="disableCorrelationRequestId")
    def disable_correlation_request_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "disableCorrelationRequestId"))

    @disable_correlation_request_id.setter
    def disable_correlation_request_id(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0046b25253dafd8a4443d551411111e3a1684cf24b68b1dcd027a25b2c354087)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "disableCorrelationRequestId", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="disableDefaultOutput")
    def disable_default_output(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "disableDefaultOutput"))

    @disable_default_output.setter
    def disable_default_output(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3083546a2444fcec43137c39dd049dec6e81c21684000a2478a9be8a0434c63b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "disableDefaultOutput", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="disableInstanceDiscovery")
    def disable_instance_discovery(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "disableInstanceDiscovery"))

    @disable_instance_discovery.setter
    def disable_instance_discovery(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c399e874c1ab99108de9b47f3f1a53991cdd5a0eb3f9202ae6d6cebbfe46ff3c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "disableInstanceDiscovery", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="disableTerraformPartnerId")
    def disable_terraform_partner_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "disableTerraformPartnerId"))

    @disable_terraform_partner_id.setter
    def disable_terraform_partner_id(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dd0d21b3536e3afb9ff76c5ae5585e1628151a0074c2e241bed4ead00ca7b818)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "disableTerraformPartnerId", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="enablePreflight")
    def enable_preflight(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "enablePreflight"))

    @enable_preflight.setter
    def enable_preflight(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__32607907e38170d3c83198fd00249aac8572000e382e2dc0a3334fb8153a9282)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "enablePreflight", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="endpoint")
    def endpoint(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AzapiProviderEndpoint"]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AzapiProviderEndpoint"]]], jsii.get(self, "endpoint"))

    @endpoint.setter
    def endpoint(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AzapiProviderEndpoint"]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__91f6968bc0a4a51723460748c8091fbfc788473f329c4c3ad744a9daf8156751)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "endpoint", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="environment")
    def environment(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "environment"))

    @environment.setter
    def environment(self, value: typing.Optional[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d2585570a5b3332ac856dc8da712d5b32119817dc1eaacd15cc3e29f5b8b9225)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "environment", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="ignoreNoOpChanges")
    def ignore_no_op_changes(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "ignoreNoOpChanges"))

    @ignore_no_op_changes.setter
    def ignore_no_op_changes(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f5e900c1f939f76e9bc5870d4ec316991c06cab7fb9f242e3650f58820592ff8)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "ignoreNoOpChanges", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="maximumBusyRetryAttempts")
    def maximum_busy_retry_attempts(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "maximumBusyRetryAttempts"))

    @maximum_busy_retry_attempts.setter
    def maximum_busy_retry_attempts(self, value: typing.Optional[jsii.Number]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9dd31d3a0f7809f3abfadefd5f8c5542fd03b4c1a17913dcb59e66975fbdd988)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "maximumBusyRetryAttempts", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="oidcAzureServiceConnectionId")
    def oidc_azure_service_connection_id(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "oidcAzureServiceConnectionId"))

    @oidc_azure_service_connection_id.setter
    def oidc_azure_service_connection_id(
        self,
        value: typing.Optional[builtins.str],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6612fee56d135557c55748e3c5c39dba0aaa7b8cf46b0de36c271a6567552c8c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "oidcAzureServiceConnectionId", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="oidcRequestToken")
    def oidc_request_token(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "oidcRequestToken"))

    @oidc_request_token.setter
    def oidc_request_token(self, value: typing.Optional[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a89f375b050cf3e54f1c6b611c1ee8e60258a30a95c449ad98414afcc7a6dda4)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "oidcRequestToken", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="oidcRequestUrl")
    def oidc_request_url(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "oidcRequestUrl"))

    @oidc_request_url.setter
    def oidc_request_url(self, value: typing.Optional[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c356fea0ba2de63e2e00a20fe59cb3f10954316bb48e1d9fd545683f1238fb9b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "oidcRequestUrl", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="oidcToken")
    def oidc_token(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "oidcToken"))

    @oidc_token.setter
    def oidc_token(self, value: typing.Optional[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__de78f75019c74030e70ee1520b66bdd57d3db25e9e003d269b728e0e02bf7206)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "oidcToken", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="oidcTokenFilePath")
    def oidc_token_file_path(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "oidcTokenFilePath"))

    @oidc_token_file_path.setter
    def oidc_token_file_path(self, value: typing.Optional[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ab4379fc35fa0c77469fa8239a886b77d559aee70e7e3ca2bd9525eb7cb236b4)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "oidcTokenFilePath", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="partnerId")
    def partner_id(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "partnerId"))

    @partner_id.setter
    def partner_id(self, value: typing.Optional[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7a65e284b5b33953f3d2ab11b53df3314df9260a2f68e90c3e0fe26af5703f1d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "partnerId", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="skipProviderRegistration")
    def skip_provider_registration(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "skipProviderRegistration"))

    @skip_provider_registration.setter
    def skip_provider_registration(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9683081adbac3650d402b3d5c1a41f67eb0194bece8af01490468efbdf9efe67)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "skipProviderRegistration", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="subscriptionId")
    def subscription_id(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "subscriptionId"))

    @subscription_id.setter
    def subscription_id(self, value: typing.Optional[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c2c1d3492caa78bee03ff6abde16e0e65a42bd2c1d421f8f5bf61d9d6dce9893)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "subscriptionId", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="tenantId")
    def tenant_id(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "tenantId"))

    @tenant_id.setter
    def tenant_id(self, value: typing.Optional[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c7d85fee89293f961ee7e797adfe2d2796df11659432f35596e2eb5ea26897e2)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "tenantId", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="useAksWorkloadIdentity")
    def use_aks_workload_identity(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "useAksWorkloadIdentity"))

    @use_aks_workload_identity.setter
    def use_aks_workload_identity(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ffb44e3f261fb44fb26cf681e3ed1685e8e6268fba092a9e6e4d53408b021dc9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "useAksWorkloadIdentity", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="useCli")
    def use_cli(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "useCli"))

    @use_cli.setter
    def use_cli(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__efc142c4fc0ed9dbe988481a16304ceb12d9ca7056877fc582def8e535d839fc)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "useCli", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="useMsi")
    def use_msi(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "useMsi"))

    @use_msi.setter
    def use_msi(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6970f455abde7e9b23b5245b4ef11346898ab51acc7fe841ae216f3f2c1cb897)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "useMsi", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="useOidc")
    def use_oidc(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "useOidc"))

    @use_oidc.setter
    def use_oidc(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2a96ef46b735f91b71ef9183f55300d732d6eb9d1478ab35e4d31f38bd0bb151)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "useOidc", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.AzapiProviderConfig",
    jsii_struct_bases=[],
    name_mapping={
        "alias": "alias",
        "auxiliary_tenant_ids": "auxiliaryTenantIds",
        "client_certificate": "clientCertificate",
        "client_certificate_password": "clientCertificatePassword",
        "client_certificate_path": "clientCertificatePath",
        "client_id": "clientId",
        "client_id_file_path": "clientIdFilePath",
        "client_secret": "clientSecret",
        "client_secret_file_path": "clientSecretFilePath",
        "custom_correlation_request_id": "customCorrelationRequestId",
        "default_location": "defaultLocation",
        "default_name": "defaultName",
        "default_tags": "defaultTags",
        "disable_correlation_request_id": "disableCorrelationRequestId",
        "disable_default_output": "disableDefaultOutput",
        "disable_instance_discovery": "disableInstanceDiscovery",
        "disable_terraform_partner_id": "disableTerraformPartnerId",
        "enable_preflight": "enablePreflight",
        "endpoint": "endpoint",
        "environment": "environment",
        "ignore_no_op_changes": "ignoreNoOpChanges",
        "maximum_busy_retry_attempts": "maximumBusyRetryAttempts",
        "oidc_azure_service_connection_id": "oidcAzureServiceConnectionId",
        "oidc_request_token": "oidcRequestToken",
        "oidc_request_url": "oidcRequestUrl",
        "oidc_token": "oidcToken",
        "oidc_token_file_path": "oidcTokenFilePath",
        "partner_id": "partnerId",
        "skip_provider_registration": "skipProviderRegistration",
        "subscription_id": "subscriptionId",
        "tenant_id": "tenantId",
        "use_aks_workload_identity": "useAksWorkloadIdentity",
        "use_cli": "useCli",
        "use_msi": "useMsi",
        "use_oidc": "useOidc",
    },
)
class AzapiProviderConfig:
    def __init__(
        self,
        *,
        alias: typing.Optional[builtins.str] = None,
        auxiliary_tenant_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
        client_certificate: typing.Optional[builtins.str] = None,
        client_certificate_password: typing.Optional[builtins.str] = None,
        client_certificate_path: typing.Optional[builtins.str] = None,
        client_id: typing.Optional[builtins.str] = None,
        client_id_file_path: typing.Optional[builtins.str] = None,
        client_secret: typing.Optional[builtins.str] = None,
        client_secret_file_path: typing.Optional[builtins.str] = None,
        custom_correlation_request_id: typing.Optional[builtins.str] = None,
        default_location: typing.Optional[builtins.str] = None,
        default_name: typing.Optional[builtins.str] = None,
        default_tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        disable_correlation_request_id: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        disable_default_output: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        disable_instance_discovery: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        disable_terraform_partner_id: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        enable_preflight: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        endpoint: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["AzapiProviderEndpoint", typing.Dict[builtins.str, typing.Any]]]]] = None,
        environment: typing.Optional[builtins.str] = None,
        ignore_no_op_changes: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        maximum_busy_retry_attempts: typing.Optional[jsii.Number] = None,
        oidc_azure_service_connection_id: typing.Optional[builtins.str] = None,
        oidc_request_token: typing.Optional[builtins.str] = None,
        oidc_request_url: typing.Optional[builtins.str] = None,
        oidc_token: typing.Optional[builtins.str] = None,
        oidc_token_file_path: typing.Optional[builtins.str] = None,
        partner_id: typing.Optional[builtins.str] = None,
        skip_provider_registration: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        subscription_id: typing.Optional[builtins.str] = None,
        tenant_id: typing.Optional[builtins.str] = None,
        use_aks_workload_identity: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        use_cli: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        use_msi: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        use_oidc: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    ) -> None:
        '''
        :param alias: Alias name. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#alias AzapiProvider#alias}
        :param auxiliary_tenant_ids: List of auxiliary Tenant IDs required for multi-tenancy and cross-tenant scenarios. This can also be sourced from the ``ARM_AUXILIARY_TENANT_IDS`` Environment Variable. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#auxiliary_tenant_ids AzapiProvider#auxiliary_tenant_ids}
        :param client_certificate: A base64-encoded PKCS#12 bundle to be used as the client certificate for authentication. This can also be sourced from the ``ARM_CLIENT_CERTIFICATE`` environment variable. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#client_certificate AzapiProvider#client_certificate}
        :param client_certificate_password: The password associated with the Client Certificate. This can also be sourced from the ``ARM_CLIENT_CERTIFICATE_PASSWORD`` Environment Variable. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#client_certificate_password AzapiProvider#client_certificate_password}
        :param client_certificate_path: The path to the Client Certificate associated with the Service Principal which should be used. This can also be sourced from the ``ARM_CLIENT_CERTIFICATE_PATH`` Environment Variable. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#client_certificate_path AzapiProvider#client_certificate_path}
        :param client_id: The Client ID which should be used. This can also be sourced from the ``ARM_CLIENT_ID``, ``AZURE_CLIENT_ID`` Environment Variable. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#client_id AzapiProvider#client_id}
        :param client_id_file_path: The path to a file containing the Client ID which should be used. This can also be sourced from the ``ARM_CLIENT_ID_FILE_PATH`` Environment Variable. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#client_id_file_path AzapiProvider#client_id_file_path}
        :param client_secret: The Client Secret which should be used. This can also be sourced from the ``ARM_CLIENT_SECRET`` Environment Variable. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#client_secret AzapiProvider#client_secret}
        :param client_secret_file_path: The path to a file containing the Client Secret which should be used. For use When authenticating as a Service Principal using a Client Secret. This can also be sourced from the ``ARM_CLIENT_SECRET_FILE_PATH`` Environment Variable. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#client_secret_file_path AzapiProvider#client_secret_file_path}
        :param custom_correlation_request_id: The value of the ``x-ms-correlation-request-id`` header, otherwise an auto-generated UUID will be used. This can also be sourced from the ``ARM_CORRELATION_REQUEST_ID`` environment variable. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#custom_correlation_request_id AzapiProvider#custom_correlation_request_id}
        :param default_location: The default Azure Region where the azure resource should exist. The ``location`` in each resource block can override the ``default_location``. Changing this forces new resources to be created. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#default_location AzapiProvider#default_location}
        :param default_name: The default name to create the azure resource. The ``name`` in each resource block can override the ``default_name``. Changing this forces new resources to be created. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#default_name AzapiProvider#default_name}
        :param default_tags: A mapping of tags which should be assigned to the azure resource as default tags. The``tags`` in each resource block can override the ``default_tags``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#default_tags AzapiProvider#default_tags}
        :param disable_correlation_request_id: This will disable the x-ms-correlation-request-id header. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#disable_correlation_request_id AzapiProvider#disable_correlation_request_id}
        :param disable_default_output: Disable default output. The default is false. When set to false, the provider will output the read-only properties if ``response_export_values`` is not specified in the resource block. When set to true, the provider will disable this output. This can also be sourced from the ``ARM_DISABLE_DEFAULT_OUTPUT`` Environment Variable. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#disable_default_output AzapiProvider#disable_default_output}
        :param disable_instance_discovery: Disables Instance Discovery, which validates that the Authority is valid and known by the Microsoft Entra instance metadata service at ``https://login.microsoft.com`` before authenticating. This should only be enabled when the configured authority is known to be valid and trustworthy - such as when running against Azure Stack or when ``environment`` is set to ``custom``. This can also be specified via the ``ARM_DISABLE_INSTANCE_DISCOVERY`` environment variable. Defaults to ``false``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#disable_instance_discovery AzapiProvider#disable_instance_discovery}
        :param disable_terraform_partner_id: Disable sending the Terraform Partner ID if a custom ``partner_id`` isn't specified, which allows Microsoft to better understand the usage of Terraform. The Partner ID does not give HashiCorp any direct access to usage information. This can also be sourced from the ``ARM_DISABLE_TERRAFORM_PARTNER_ID`` environment variable. Defaults to ``false``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#disable_terraform_partner_id AzapiProvider#disable_terraform_partner_id}
        :param enable_preflight: Enable Preflight Validation. The default is false. When set to true, the provider will use Preflight to do static validation before really deploying a new resource. When set to false, the provider will disable this validation. This can also be sourced from the ``ARM_ENABLE_PREFLIGHT`` Environment Variable. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#enable_preflight AzapiProvider#enable_preflight}
        :param endpoint: The Azure API Endpoint Configuration. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#endpoint AzapiProvider#endpoint}
        :param environment: The Cloud Environment which should be used. Possible values are ``public``, ``usgovernment``, ``china`` and ``custom``. Defaults to ``public``. This can also be sourced from the ``ARM_ENVIRONMENT`` Environment Variable. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#environment AzapiProvider#environment}
        :param ignore_no_op_changes: Ignore no-op changes for ``azapi_resource``. The default is true. When set to true, the provider will suppress changes in the ``azapi_resource`` if the ``body`` in the new API version still matches the remote state. When set to false, the provider will not suppress these changes. This can also be sourced from the ``ARM_IGNORE_NO_OP_CHANGES`` Environment Variable. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#ignore_no_op_changes AzapiProvider#ignore_no_op_changes}
        :param maximum_busy_retry_attempts: DEPRECATED - The maximum number of retries to attempt if the Azure API returns an HTTP 408, 429, 500, 502, 503, or 504 response. The default is ``32767``, this allows the provider to rely on the resource timeout values rather than a maximum retry count. The resource-specific retry configuration may additionally be used to retry on other errors and conditions. This property will be removed in a future version. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#maximum_busy_retry_attempts AzapiProvider#maximum_busy_retry_attempts}
        :param oidc_azure_service_connection_id: The Azure Pipelines Service Connection ID to use for authentication. This can also be sourced from the ``ARM_ADO_PIPELINE_SERVICE_CONNECTION_ID``, ``ARM_OIDC_AZURE_SERVICE_CONNECTION_ID``, or ``AZURESUBSCRIPTION_SERVICE_CONNECTION_ID`` Environment Variables. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#oidc_azure_service_connection_id AzapiProvider#oidc_azure_service_connection_id}
        :param oidc_request_token: The bearer token for the request to the OIDC provider. This can also be sourced from the ``ARM_OIDC_REQUEST_TOKEN``, ``ACTIONS_ID_TOKEN_REQUEST_TOKEN``, or ``SYSTEM_ACCESSTOKEN`` Environment Variables. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#oidc_request_token AzapiProvider#oidc_request_token}
        :param oidc_request_url: The URL for the OIDC provider from which to request an ID token. This can also be sourced from the ``ARM_OIDC_REQUEST_URL``, ``ACTIONS_ID_TOKEN_REQUEST_URL``, or ``SYSTEM_OIDCREQUESTURI`` Environment Variables. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#oidc_request_url AzapiProvider#oidc_request_url}
        :param oidc_token: The ID token when authenticating using OpenID Connect (OIDC). This can also be sourced from the ``ARM_OIDC_TOKEN`` environment Variable. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#oidc_token AzapiProvider#oidc_token}
        :param oidc_token_file_path: The path to a file containing an ID token when authenticating using OpenID Connect (OIDC). This can also be sourced from the ``ARM_OIDC_TOKEN_FILE_PATH``, ``AZURE_FEDERATED_TOKEN_FILE`` environment Variable. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#oidc_token_file_path AzapiProvider#oidc_token_file_path}
        :param partner_id: A GUID/UUID that is `registered <https://docs.microsoft.com/azure/marketplace/azure-partner-customer-usage-attribution#register-guids-and-offers>`_ with Microsoft to facilitate partner resource usage attribution. This can also be sourced from the ``ARM_PARTNER_ID`` Environment Variable. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#partner_id AzapiProvider#partner_id}
        :param skip_provider_registration: Should the Provider skip registering the Resource Providers it supports? This can also be sourced from the ``ARM_SKIP_PROVIDER_REGISTRATION`` Environment Variable. Defaults to ``false``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#skip_provider_registration AzapiProvider#skip_provider_registration}
        :param subscription_id: The Subscription ID which should be used. This can also be sourced from the ``ARM_SUBSCRIPTION_ID`` Environment Variable. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#subscription_id AzapiProvider#subscription_id}
        :param tenant_id: The Tenant ID should be used. This can also be sourced from the ``ARM_TENANT_ID`` Environment Variable. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#tenant_id AzapiProvider#tenant_id}
        :param use_aks_workload_identity: Should AKS Workload Identity be used for Authentication? This can also be sourced from the ``ARM_USE_AKS_WORKLOAD_IDENTITY`` Environment Variable. Defaults to ``false``. When set, ``client_id``, ``tenant_id`` and ``oidc_token_file_path`` will be detected from the environment and do not need to be specified. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#use_aks_workload_identity AzapiProvider#use_aks_workload_identity}
        :param use_cli: Should Azure CLI be used for authentication? This can also be sourced from the ``ARM_USE_CLI`` environment variable. Defaults to ``true``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#use_cli AzapiProvider#use_cli}
        :param use_msi: Should Managed Identity be used for Authentication? This can also be sourced from the ``ARM_USE_MSI`` Environment Variable. Defaults to ``false``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#use_msi AzapiProvider#use_msi}
        :param use_oidc: Should OIDC be used for Authentication? This can also be sourced from the ``ARM_USE_OIDC`` Environment Variable. Defaults to ``false``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#use_oidc AzapiProvider#use_oidc}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e7d692e84c0367b0bd21eafe6eb47edbb4983681b82743ac15b73d3c33c2e11f)
            check_type(argname="argument alias", value=alias, expected_type=type_hints["alias"])
            check_type(argname="argument auxiliary_tenant_ids", value=auxiliary_tenant_ids, expected_type=type_hints["auxiliary_tenant_ids"])
            check_type(argname="argument client_certificate", value=client_certificate, expected_type=type_hints["client_certificate"])
            check_type(argname="argument client_certificate_password", value=client_certificate_password, expected_type=type_hints["client_certificate_password"])
            check_type(argname="argument client_certificate_path", value=client_certificate_path, expected_type=type_hints["client_certificate_path"])
            check_type(argname="argument client_id", value=client_id, expected_type=type_hints["client_id"])
            check_type(argname="argument client_id_file_path", value=client_id_file_path, expected_type=type_hints["client_id_file_path"])
            check_type(argname="argument client_secret", value=client_secret, expected_type=type_hints["client_secret"])
            check_type(argname="argument client_secret_file_path", value=client_secret_file_path, expected_type=type_hints["client_secret_file_path"])
            check_type(argname="argument custom_correlation_request_id", value=custom_correlation_request_id, expected_type=type_hints["custom_correlation_request_id"])
            check_type(argname="argument default_location", value=default_location, expected_type=type_hints["default_location"])
            check_type(argname="argument default_name", value=default_name, expected_type=type_hints["default_name"])
            check_type(argname="argument default_tags", value=default_tags, expected_type=type_hints["default_tags"])
            check_type(argname="argument disable_correlation_request_id", value=disable_correlation_request_id, expected_type=type_hints["disable_correlation_request_id"])
            check_type(argname="argument disable_default_output", value=disable_default_output, expected_type=type_hints["disable_default_output"])
            check_type(argname="argument disable_instance_discovery", value=disable_instance_discovery, expected_type=type_hints["disable_instance_discovery"])
            check_type(argname="argument disable_terraform_partner_id", value=disable_terraform_partner_id, expected_type=type_hints["disable_terraform_partner_id"])
            check_type(argname="argument enable_preflight", value=enable_preflight, expected_type=type_hints["enable_preflight"])
            check_type(argname="argument endpoint", value=endpoint, expected_type=type_hints["endpoint"])
            check_type(argname="argument environment", value=environment, expected_type=type_hints["environment"])
            check_type(argname="argument ignore_no_op_changes", value=ignore_no_op_changes, expected_type=type_hints["ignore_no_op_changes"])
            check_type(argname="argument maximum_busy_retry_attempts", value=maximum_busy_retry_attempts, expected_type=type_hints["maximum_busy_retry_attempts"])
            check_type(argname="argument oidc_azure_service_connection_id", value=oidc_azure_service_connection_id, expected_type=type_hints["oidc_azure_service_connection_id"])
            check_type(argname="argument oidc_request_token", value=oidc_request_token, expected_type=type_hints["oidc_request_token"])
            check_type(argname="argument oidc_request_url", value=oidc_request_url, expected_type=type_hints["oidc_request_url"])
            check_type(argname="argument oidc_token", value=oidc_token, expected_type=type_hints["oidc_token"])
            check_type(argname="argument oidc_token_file_path", value=oidc_token_file_path, expected_type=type_hints["oidc_token_file_path"])
            check_type(argname="argument partner_id", value=partner_id, expected_type=type_hints["partner_id"])
            check_type(argname="argument skip_provider_registration", value=skip_provider_registration, expected_type=type_hints["skip_provider_registration"])
            check_type(argname="argument subscription_id", value=subscription_id, expected_type=type_hints["subscription_id"])
            check_type(argname="argument tenant_id", value=tenant_id, expected_type=type_hints["tenant_id"])
            check_type(argname="argument use_aks_workload_identity", value=use_aks_workload_identity, expected_type=type_hints["use_aks_workload_identity"])
            check_type(argname="argument use_cli", value=use_cli, expected_type=type_hints["use_cli"])
            check_type(argname="argument use_msi", value=use_msi, expected_type=type_hints["use_msi"])
            check_type(argname="argument use_oidc", value=use_oidc, expected_type=type_hints["use_oidc"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if alias is not None:
            self._values["alias"] = alias
        if auxiliary_tenant_ids is not None:
            self._values["auxiliary_tenant_ids"] = auxiliary_tenant_ids
        if client_certificate is not None:
            self._values["client_certificate"] = client_certificate
        if client_certificate_password is not None:
            self._values["client_certificate_password"] = client_certificate_password
        if client_certificate_path is not None:
            self._values["client_certificate_path"] = client_certificate_path
        if client_id is not None:
            self._values["client_id"] = client_id
        if client_id_file_path is not None:
            self._values["client_id_file_path"] = client_id_file_path
        if client_secret is not None:
            self._values["client_secret"] = client_secret
        if client_secret_file_path is not None:
            self._values["client_secret_file_path"] = client_secret_file_path
        if custom_correlation_request_id is not None:
            self._values["custom_correlation_request_id"] = custom_correlation_request_id
        if default_location is not None:
            self._values["default_location"] = default_location
        if default_name is not None:
            self._values["default_name"] = default_name
        if default_tags is not None:
            self._values["default_tags"] = default_tags
        if disable_correlation_request_id is not None:
            self._values["disable_correlation_request_id"] = disable_correlation_request_id
        if disable_default_output is not None:
            self._values["disable_default_output"] = disable_default_output
        if disable_instance_discovery is not None:
            self._values["disable_instance_discovery"] = disable_instance_discovery
        if disable_terraform_partner_id is not None:
            self._values["disable_terraform_partner_id"] = disable_terraform_partner_id
        if enable_preflight is not None:
            self._values["enable_preflight"] = enable_preflight
        if endpoint is not None:
            self._values["endpoint"] = endpoint
        if environment is not None:
            self._values["environment"] = environment
        if ignore_no_op_changes is not None:
            self._values["ignore_no_op_changes"] = ignore_no_op_changes
        if maximum_busy_retry_attempts is not None:
            self._values["maximum_busy_retry_attempts"] = maximum_busy_retry_attempts
        if oidc_azure_service_connection_id is not None:
            self._values["oidc_azure_service_connection_id"] = oidc_azure_service_connection_id
        if oidc_request_token is not None:
            self._values["oidc_request_token"] = oidc_request_token
        if oidc_request_url is not None:
            self._values["oidc_request_url"] = oidc_request_url
        if oidc_token is not None:
            self._values["oidc_token"] = oidc_token
        if oidc_token_file_path is not None:
            self._values["oidc_token_file_path"] = oidc_token_file_path
        if partner_id is not None:
            self._values["partner_id"] = partner_id
        if skip_provider_registration is not None:
            self._values["skip_provider_registration"] = skip_provider_registration
        if subscription_id is not None:
            self._values["subscription_id"] = subscription_id
        if tenant_id is not None:
            self._values["tenant_id"] = tenant_id
        if use_aks_workload_identity is not None:
            self._values["use_aks_workload_identity"] = use_aks_workload_identity
        if use_cli is not None:
            self._values["use_cli"] = use_cli
        if use_msi is not None:
            self._values["use_msi"] = use_msi
        if use_oidc is not None:
            self._values["use_oidc"] = use_oidc

    @builtins.property
    def alias(self) -> typing.Optional[builtins.str]:
        '''Alias name.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#alias AzapiProvider#alias}
        '''
        result = self._values.get("alias")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def auxiliary_tenant_ids(self) -> typing.Optional[typing.List[builtins.str]]:
        '''List of auxiliary Tenant IDs required for multi-tenancy and cross-tenant scenarios.

        This can also be sourced from the ``ARM_AUXILIARY_TENANT_IDS`` Environment Variable.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#auxiliary_tenant_ids AzapiProvider#auxiliary_tenant_ids}
        '''
        result = self._values.get("auxiliary_tenant_ids")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def client_certificate(self) -> typing.Optional[builtins.str]:
        '''A base64-encoded PKCS#12 bundle to be used as the client certificate for authentication.

        This can also be sourced from the ``ARM_CLIENT_CERTIFICATE`` environment variable.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#client_certificate AzapiProvider#client_certificate}
        '''
        result = self._values.get("client_certificate")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def client_certificate_password(self) -> typing.Optional[builtins.str]:
        '''The password associated with the Client Certificate. This can also be sourced from the ``ARM_CLIENT_CERTIFICATE_PASSWORD`` Environment Variable.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#client_certificate_password AzapiProvider#client_certificate_password}
        '''
        result = self._values.get("client_certificate_password")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def client_certificate_path(self) -> typing.Optional[builtins.str]:
        '''The path to the Client Certificate associated with the Service Principal which should be used.

        This can also be sourced from the ``ARM_CLIENT_CERTIFICATE_PATH`` Environment Variable.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#client_certificate_path AzapiProvider#client_certificate_path}
        '''
        result = self._values.get("client_certificate_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def client_id(self) -> typing.Optional[builtins.str]:
        '''The Client ID which should be used. This can also be sourced from the ``ARM_CLIENT_ID``, ``AZURE_CLIENT_ID`` Environment Variable.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#client_id AzapiProvider#client_id}
        '''
        result = self._values.get("client_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def client_id_file_path(self) -> typing.Optional[builtins.str]:
        '''The path to a file containing the Client ID which should be used.

        This can also be sourced from the ``ARM_CLIENT_ID_FILE_PATH`` Environment Variable.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#client_id_file_path AzapiProvider#client_id_file_path}
        '''
        result = self._values.get("client_id_file_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def client_secret(self) -> typing.Optional[builtins.str]:
        '''The Client Secret which should be used. This can also be sourced from the ``ARM_CLIENT_SECRET`` Environment Variable.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#client_secret AzapiProvider#client_secret}
        '''
        result = self._values.get("client_secret")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def client_secret_file_path(self) -> typing.Optional[builtins.str]:
        '''The path to a file containing the Client Secret which should be used.

        For use When authenticating as a Service Principal using a Client Secret. This can also be sourced from the ``ARM_CLIENT_SECRET_FILE_PATH`` Environment Variable.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#client_secret_file_path AzapiProvider#client_secret_file_path}
        '''
        result = self._values.get("client_secret_file_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def custom_correlation_request_id(self) -> typing.Optional[builtins.str]:
        '''The value of the ``x-ms-correlation-request-id`` header, otherwise an auto-generated UUID will be used.

        This can also be sourced from the ``ARM_CORRELATION_REQUEST_ID`` environment variable.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#custom_correlation_request_id AzapiProvider#custom_correlation_request_id}
        '''
        result = self._values.get("custom_correlation_request_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def default_location(self) -> typing.Optional[builtins.str]:
        '''The default Azure Region where the azure resource should exist.

        The ``location`` in each resource block can override the ``default_location``. Changing this forces new resources to be created.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#default_location AzapiProvider#default_location}
        '''
        result = self._values.get("default_location")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def default_name(self) -> typing.Optional[builtins.str]:
        '''The default name to create the azure resource.

        The ``name`` in each resource block can override the ``default_name``. Changing this forces new resources to be created.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#default_name AzapiProvider#default_name}
        '''
        result = self._values.get("default_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def default_tags(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''A mapping of tags which should be assigned to the azure resource as default tags.

        The``tags`` in each resource block can override the ``default_tags``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#default_tags AzapiProvider#default_tags}
        '''
        result = self._values.get("default_tags")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def disable_correlation_request_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''This will disable the x-ms-correlation-request-id header.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#disable_correlation_request_id AzapiProvider#disable_correlation_request_id}
        '''
        result = self._values.get("disable_correlation_request_id")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    @builtins.property
    def disable_default_output(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Disable default output.

        The default is false. When set to false, the provider will output the read-only properties if ``response_export_values`` is not specified in the resource block. When set to true, the provider will disable this output. This can also be sourced from the ``ARM_DISABLE_DEFAULT_OUTPUT`` Environment Variable.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#disable_default_output AzapiProvider#disable_default_output}
        '''
        result = self._values.get("disable_default_output")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    @builtins.property
    def disable_instance_discovery(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Disables Instance Discovery, which validates that the Authority is valid and known by the Microsoft Entra instance metadata service at ``https://login.microsoft.com`` before authenticating. This should only be enabled when the configured authority is known to be valid and trustworthy - such as when running against Azure Stack or when ``environment`` is set to ``custom``. This can also be specified via the ``ARM_DISABLE_INSTANCE_DISCOVERY`` environment variable. Defaults to ``false``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#disable_instance_discovery AzapiProvider#disable_instance_discovery}
        '''
        result = self._values.get("disable_instance_discovery")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    @builtins.property
    def disable_terraform_partner_id(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Disable sending the Terraform Partner ID if a custom ``partner_id`` isn't specified, which allows Microsoft to better understand the usage of Terraform.

        The Partner ID does not give HashiCorp any direct access to usage information. This can also be sourced from the ``ARM_DISABLE_TERRAFORM_PARTNER_ID`` environment variable. Defaults to ``false``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#disable_terraform_partner_id AzapiProvider#disable_terraform_partner_id}
        '''
        result = self._values.get("disable_terraform_partner_id")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    @builtins.property
    def enable_preflight(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Enable Preflight Validation.

        The default is false. When set to true, the provider will use Preflight to do static validation before really deploying a new resource. When set to false, the provider will disable this validation. This can also be sourced from the ``ARM_ENABLE_PREFLIGHT`` Environment Variable.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#enable_preflight AzapiProvider#enable_preflight}
        '''
        result = self._values.get("enable_preflight")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    @builtins.property
    def endpoint(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AzapiProviderEndpoint"]]]:
        '''The Azure API Endpoint Configuration.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#endpoint AzapiProvider#endpoint}
        '''
        result = self._values.get("endpoint")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["AzapiProviderEndpoint"]]], result)

    @builtins.property
    def environment(self) -> typing.Optional[builtins.str]:
        '''The Cloud Environment which should be used.

        Possible values are ``public``, ``usgovernment``, ``china`` and ``custom``. Defaults to ``public``. This can also be sourced from the ``ARM_ENVIRONMENT`` Environment Variable.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#environment AzapiProvider#environment}
        '''
        result = self._values.get("environment")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ignore_no_op_changes(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Ignore no-op changes for ``azapi_resource``.

        The default is true. When set to true, the provider will suppress changes in the ``azapi_resource`` if the ``body`` in the new API version still matches the remote state. When set to false, the provider will not suppress these changes. This can also be sourced from the ``ARM_IGNORE_NO_OP_CHANGES`` Environment Variable.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#ignore_no_op_changes AzapiProvider#ignore_no_op_changes}
        '''
        result = self._values.get("ignore_no_op_changes")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    @builtins.property
    def maximum_busy_retry_attempts(self) -> typing.Optional[jsii.Number]:
        '''DEPRECATED - The maximum number of retries to attempt if the Azure API returns an HTTP 408, 429, 500, 502, 503, or 504 response.

        The default is ``32767``, this allows the provider to rely on the resource timeout values rather than a maximum retry count. The resource-specific retry configuration may additionally be used to retry on other errors and conditions. This property will be removed in a future version.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#maximum_busy_retry_attempts AzapiProvider#maximum_busy_retry_attempts}
        '''
        result = self._values.get("maximum_busy_retry_attempts")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def oidc_azure_service_connection_id(self) -> typing.Optional[builtins.str]:
        '''The Azure Pipelines Service Connection ID to use for authentication.

        This can also be sourced from the ``ARM_ADO_PIPELINE_SERVICE_CONNECTION_ID``, ``ARM_OIDC_AZURE_SERVICE_CONNECTION_ID``, or ``AZURESUBSCRIPTION_SERVICE_CONNECTION_ID`` Environment Variables.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#oidc_azure_service_connection_id AzapiProvider#oidc_azure_service_connection_id}
        '''
        result = self._values.get("oidc_azure_service_connection_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def oidc_request_token(self) -> typing.Optional[builtins.str]:
        '''The bearer token for the request to the OIDC provider.

        This can also be sourced from the ``ARM_OIDC_REQUEST_TOKEN``, ``ACTIONS_ID_TOKEN_REQUEST_TOKEN``, or ``SYSTEM_ACCESSTOKEN`` Environment Variables.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#oidc_request_token AzapiProvider#oidc_request_token}
        '''
        result = self._values.get("oidc_request_token")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def oidc_request_url(self) -> typing.Optional[builtins.str]:
        '''The URL for the OIDC provider from which to request an ID token.

        This can also be sourced from the ``ARM_OIDC_REQUEST_URL``, ``ACTIONS_ID_TOKEN_REQUEST_URL``, or ``SYSTEM_OIDCREQUESTURI`` Environment Variables.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#oidc_request_url AzapiProvider#oidc_request_url}
        '''
        result = self._values.get("oidc_request_url")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def oidc_token(self) -> typing.Optional[builtins.str]:
        '''The ID token when authenticating using OpenID Connect (OIDC). This can also be sourced from the ``ARM_OIDC_TOKEN`` environment Variable.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#oidc_token AzapiProvider#oidc_token}
        '''
        result = self._values.get("oidc_token")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def oidc_token_file_path(self) -> typing.Optional[builtins.str]:
        '''The path to a file containing an ID token when authenticating using OpenID Connect (OIDC).

        This can also be sourced from the ``ARM_OIDC_TOKEN_FILE_PATH``, ``AZURE_FEDERATED_TOKEN_FILE`` environment Variable.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#oidc_token_file_path AzapiProvider#oidc_token_file_path}
        '''
        result = self._values.get("oidc_token_file_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def partner_id(self) -> typing.Optional[builtins.str]:
        '''A GUID/UUID that is `registered <https://docs.microsoft.com/azure/marketplace/azure-partner-customer-usage-attribution#register-guids-and-offers>`_ with Microsoft to facilitate partner resource usage attribution. This can also be sourced from the ``ARM_PARTNER_ID`` Environment Variable.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#partner_id AzapiProvider#partner_id}
        '''
        result = self._values.get("partner_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def skip_provider_registration(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Should the Provider skip registering the Resource Providers it supports?

        This can also be sourced from the ``ARM_SKIP_PROVIDER_REGISTRATION`` Environment Variable. Defaults to ``false``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#skip_provider_registration AzapiProvider#skip_provider_registration}
        '''
        result = self._values.get("skip_provider_registration")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    @builtins.property
    def subscription_id(self) -> typing.Optional[builtins.str]:
        '''The Subscription ID which should be used. This can also be sourced from the ``ARM_SUBSCRIPTION_ID`` Environment Variable.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#subscription_id AzapiProvider#subscription_id}
        '''
        result = self._values.get("subscription_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tenant_id(self) -> typing.Optional[builtins.str]:
        '''The Tenant ID should be used. This can also be sourced from the ``ARM_TENANT_ID`` Environment Variable.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#tenant_id AzapiProvider#tenant_id}
        '''
        result = self._values.get("tenant_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def use_aks_workload_identity(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Should AKS Workload Identity be used for Authentication?

        This can also be sourced from the ``ARM_USE_AKS_WORKLOAD_IDENTITY`` Environment Variable. Defaults to ``false``. When set, ``client_id``, ``tenant_id`` and ``oidc_token_file_path`` will be detected from the environment and do not need to be specified.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#use_aks_workload_identity AzapiProvider#use_aks_workload_identity}
        '''
        result = self._values.get("use_aks_workload_identity")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    @builtins.property
    def use_cli(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Should Azure CLI be used for authentication?

        This can also be sourced from the ``ARM_USE_CLI`` environment variable. Defaults to ``true``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#use_cli AzapiProvider#use_cli}
        '''
        result = self._values.get("use_cli")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    @builtins.property
    def use_msi(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Should Managed Identity be used for Authentication?

        This can also be sourced from the ``ARM_USE_MSI`` Environment Variable. Defaults to ``false``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#use_msi AzapiProvider#use_msi}
        '''
        result = self._values.get("use_msi")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    @builtins.property
    def use_oidc(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Should OIDC be used for Authentication? This can also be sourced from the ``ARM_USE_OIDC`` Environment Variable. Defaults to ``false``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#use_oidc AzapiProvider#use_oidc}
        '''
        result = self._values.get("use_oidc")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AzapiProviderConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.AzapiProviderEndpoint",
    jsii_struct_bases=[],
    name_mapping={
        "active_directory_authority_host": "activeDirectoryAuthorityHost",
        "resource_manager_audience": "resourceManagerAudience",
        "resource_manager_endpoint": "resourceManagerEndpoint",
    },
)
class AzapiProviderEndpoint:
    def __init__(
        self,
        *,
        active_directory_authority_host: typing.Optional[builtins.str] = None,
        resource_manager_audience: typing.Optional[builtins.str] = None,
        resource_manager_endpoint: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param active_directory_authority_host: The Azure Active Directory login endpoint to use. This can also be sourced from the ``ARM_ACTIVE_DIRECTORY_AUTHORITY_HOST`` Environment Variable. Defaults to ``https://login.microsoftonline.com/`` for public cloud. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#active_directory_authority_host AzapiProvider#active_directory_authority_host}
        :param resource_manager_audience: The resource ID to obtain AD tokens for. This can also be sourced from the ``ARM_RESOURCE_MANAGER_AUDIENCE`` Environment Variable. Defaults to ``https://management.core.windows.net/`` for public cloud. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#resource_manager_audience AzapiProvider#resource_manager_audience}
        :param resource_manager_endpoint: The Azure Resource Manager endpoint to use. This can also be sourced from the ``ARM_RESOURCE_MANAGER_ENDPOINT`` Environment Variable. Defaults to ``https://management.azure.com/`` for public cloud. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#resource_manager_endpoint AzapiProvider#resource_manager_endpoint}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__851cbf09da93a2f7da6f5df43609d143ac73c1c5c700dd702e268a8a9655aa6c)
            check_type(argname="argument active_directory_authority_host", value=active_directory_authority_host, expected_type=type_hints["active_directory_authority_host"])
            check_type(argname="argument resource_manager_audience", value=resource_manager_audience, expected_type=type_hints["resource_manager_audience"])
            check_type(argname="argument resource_manager_endpoint", value=resource_manager_endpoint, expected_type=type_hints["resource_manager_endpoint"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if active_directory_authority_host is not None:
            self._values["active_directory_authority_host"] = active_directory_authority_host
        if resource_manager_audience is not None:
            self._values["resource_manager_audience"] = resource_manager_audience
        if resource_manager_endpoint is not None:
            self._values["resource_manager_endpoint"] = resource_manager_endpoint

    @builtins.property
    def active_directory_authority_host(self) -> typing.Optional[builtins.str]:
        '''The Azure Active Directory login endpoint to use.

        This can also be sourced from the ``ARM_ACTIVE_DIRECTORY_AUTHORITY_HOST`` Environment Variable. Defaults to ``https://login.microsoftonline.com/`` for public cloud.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#active_directory_authority_host AzapiProvider#active_directory_authority_host}
        '''
        result = self._values.get("active_directory_authority_host")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def resource_manager_audience(self) -> typing.Optional[builtins.str]:
        '''The resource ID to obtain AD tokens for.

        This can also be sourced from the ``ARM_RESOURCE_MANAGER_AUDIENCE`` Environment Variable. Defaults to ``https://management.core.windows.net/`` for public cloud.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#resource_manager_audience AzapiProvider#resource_manager_audience}
        '''
        result = self._values.get("resource_manager_audience")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def resource_manager_endpoint(self) -> typing.Optional[builtins.str]:
        '''The Azure Resource Manager endpoint to use.

        This can also be sourced from the ``ARM_RESOURCE_MANAGER_ENDPOINT`` Environment Variable. Defaults to ``https://management.azure.com/`` for public cloud.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs#resource_manager_endpoint AzapiProvider#resource_manager_endpoint}
        '''
        result = self._values.get("resource_manager_endpoint")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AzapiProviderEndpoint(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AzapiResource(
    _constructs_77d1e7e8.Construct,
    metaclass=jsii.JSIIAbstractClass,
    jsii_type="@microsoft/terraform-cdk-constructs.AzapiResource",
):
    '''Abstract base class for version-aware Azure resource management.

    AzapiResource provides a unified framework for creating Azure resources
    with automatic version management, schema validation, property transformation,
    and migration analysis. It extends the existing AzapiResource class while
    maintaining full backward compatibility.

    This class implements the core framework that enables:

    - Automatic resolution of the latest API version when none is specified
    - Explicit version pinning for environments requiring stability
    - Schema-driven property validation and transformation
    - Migration analysis with breaking change detection
    - Deprecation warnings and upgrade recommendations

    Subclasses must implement the abstract methods to provide resource-specific
    configuration while the framework handles all version management complexity.

    Example::

        Usage with explicit version pinning:
        new MyResource(this, "resource", {
        name: "my-resource",
        location: "eastus",
        apiVersion: "2024-01-01" // Pin to specific version
        });
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        api_version: typing.Optional[builtins.str] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        location: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> None:
        '''Creates a new AzapiResource instance.

        The constructor handles all framework initialization including version resolution,
        schema loading, property validation, transformation, and migration analysis.
        It maintains full backward compatibility with the AzapiResource constructor.

        :param scope: - The scope in which to define this construct.
        :param id: - The unique identifier for this instance.
        :param api_version: Explicit API version to use for this resource. If not specified, the latest active version will be automatically resolved. Use this for version pinning when stability is required over latest features. Default: Latest active version from ApiVersionManager
        :param enable_migration_analysis: Whether to enable migration analysis warnings. When true, the framework will analyze the current version for deprecation status and provide migration recommendations in the deployment output. Default: true
        :param enable_transformation: Whether to apply property transformations automatically. When true, properties will be automatically transformed according to the target schema's transformation rules. This enables backward compatibility. Default: true
        :param enable_validation: Whether to validate properties against the schema. When true, all properties will be validated against the API schema before resource creation. Validation errors will cause deployment failures. Default: true
        :param location: The location where the resource should be created. Default: Varies by resource type - see specific resource documentation
        :param monitoring: Monitoring configuration for this resource. Enables integrated monitoring with diagnostic settings, metric alerts, and activity log alerts. All monitoring is optional and disabled by default.
        :param name: The name of the resource.
        :param tags: Tags to apply to the resource.
        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a3d3c58c42b41b398803c4efbf0772e4a0c8784d47b74c87dd9ebf23d9d738a1)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = _AzapiResourceProps_141a2340(
            api_version=api_version,
            enable_migration_analysis=enable_migration_analysis,
            enable_transformation=enable_transformation,
            enable_validation=enable_validation,
            location=location,
            monitoring=monitoring,
            name=name,
            tags=tags,
            connection=connection,
            count=count,
            depends_on=depends_on,
            for_each=for_each,
            lifecycle=lifecycle,
            provider=provider,
            provisioners=provisioners,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="registerSchemas")
    @builtins.classmethod
    def register_schemas(
        cls,
        resource_type: builtins.str,
        versions: typing.Sequence[typing.Union[_VersionConfig_ddf991d0, typing.Dict[builtins.str, typing.Any]]],
    ) -> None:
        '''Static helper for child classes to register their schemas in static initializers.

        This method should be called in a static initializer block of each child class
        to register all supported API versions and their schemas with the ApiVersionManager.
        The static block runs once when the class is first loaded, ensuring schemas are
        registered before any instances are created.

        :param resource_type: - The Azure resource type (e.g., "Microsoft.Network/virtualNetworks").
        :param versions: - Array of version configurations containing schemas.

        Example::

            static {
              AzapiResource.registerSchemas(
                "Microsoft.Network/virtualNetworks",
                ALL_VIRTUAL_NETWORK_VERSIONS
              );
            }
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cf9f6337079df9eb970b9ad080311376c6164a0dce9d7c1d809e4636d3c6e000)
            check_type(argname="argument resource_type", value=resource_type, expected_type=type_hints["resource_type"])
            check_type(argname="argument versions", value=versions, expected_type=type_hints["versions"])
        return typing.cast(None, jsii.sinvoke(cls, "registerSchemas", [resource_type, versions]))

    @jsii.member(jsii_name="addAccess")
    def add_access(
        self,
        object_id: builtins.str,
        role_definition_name: builtins.str,
    ) -> None:
        '''Adds an access role assignment for a specified Azure AD object.

        Note: This method creates role assignments using AZAPI instead of AzureRM provider.

        :param object_id: - The unique identifier of the Azure AD object.
        :param role_definition_name: - The name of the Azure RBAC role to be assigned.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f4ceb970ba75ee62b0297d00ddb7ae9f80bbe8dfed04665ca5ac0918f20f697f)
            check_type(argname="argument object_id", value=object_id, expected_type=type_hints["object_id"])
            check_type(argname="argument role_definition_name", value=role_definition_name, expected_type=type_hints["role_definition_name"])
        return typing.cast(None, jsii.invoke(self, "addAccess", [object_id, role_definition_name]))

    @jsii.member(jsii_name="addTag")
    def add_tag(self, key: builtins.str, value: builtins.str) -> None:
        '''Adds a tag to this resource. The tag will be included in the Azure resource.

        This method provides proper immutability by storing tags separately from props.
        Tags added via this method are combined with tags from props and included in
        the deployed Azure resource.

        **Important:** In CDK for Terraform, tags should ideally be set during resource
        construction via props. While this method allows adding tags after construction,
        those tags are only included if added before the Terraform configuration is
        synthesized. For best results, add all tags via props or call addTag() in the
        same scope where the resource is created.

        :param key: - The tag key.
        :param value: - The tag value.

        :throws: Error if the resource type does not support tags
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c68a84cebf10cce28dc776128d9fe29d809c2c82d60fe425d0c70628635e8eb9)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "addTag", [key, value]))

    @jsii.member(jsii_name="allTags")
    def _all_tags(self) -> typing.Mapping[builtins.str, builtins.str]:
        '''Protected method to retrieve all tags for use in createResourceBody implementations.

        Subclasses should use this method when creating resource bodies to ensure
        all tags (from props and addTag()) are included in the Azure resource.
        Uses a non-getter name to avoid JSII conflicts with the tags property.

        :return: Object containing all tags
        '''
        return typing.cast(typing.Mapping[builtins.str, builtins.str], jsii.invoke(self, "allTags", []))

    @jsii.member(jsii_name="analyzeMigrationTo")
    def analyze_migration_to(
        self,
        target_version: builtins.str,
    ) -> _MigrationAnalysis_aa719f40:
        '''Analyzes migration from current version to a target version.

        This method enables external tools to analyze migration requirements
        between versions for planning and automation purposes.

        :param target_version: - The target version to analyze migration to.

        :return: Detailed migration analysis results
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__238050e80b865d80a0d7c8e5a26741c84d5a802fc7496802ec85f097ef48ad07)
            check_type(argname="argument target_version", value=target_version, expected_type=type_hints["target_version"])
        return typing.cast(_MigrationAnalysis_aa719f40, jsii.invoke(self, "analyzeMigrationTo", [target_version]))

    @jsii.member(jsii_name="apiSchema")
    @abc.abstractmethod
    def _api_schema(self) -> _ApiSchema_5ce0490e:
        '''Gets the API schema for the resolved version.

        This method should return the complete API schema for the resolved version,
        including all property definitions, validation rules, and transformation
        mappings. Use the resolveSchema() helper method for standard schema resolution.

        :return: The API schema for the resolved version
        '''
        ...

    @jsii.member(jsii_name="createAzapiDataSource")
    def _create_azapi_data_source(
        self,
        resource_id: builtins.str,
    ) -> _cdktf_9a9027ec.TerraformDataSource:
        '''Creates an AZAPI data source for reading existing resources.

        :param resource_id: - The full resource ID.

        :return: The created Terraform data source
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__83e5393f73b29a9c8e15e27771f790289e23467d98ec01c6de05e6c376dc7035)
            check_type(argname="argument resource_id", value=resource_id, expected_type=type_hints["resource_id"])
        return typing.cast(_cdktf_9a9027ec.TerraformDataSource, jsii.invoke(self, "createAzapiDataSource", [resource_id]))

    @jsii.member(jsii_name="createAzapiResource")
    def _create_azapi_resource(
        self,
        properties: typing.Mapping[builtins.str, typing.Any],
        parent_id: builtins.str,
        name: builtins.str,
        location: typing.Optional[builtins.str] = None,
        parent_resource: typing.Optional[_AzapiResource_7e7f5b39] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> _cdktf_9a9027ec.TerraformResource:
        '''Creates the underlying AZAPI Terraform resource using the generated provider classes.

        :param properties: - The properties object to send to the Azure API (should include location if needed).
        :param parent_id: - The parent resource ID (e.g., subscription or resource group).
        :param name: - The name of the resource.
        :param location: - The location of the resource (optional, only for top-level resources without location in body).
        :param parent_resource: - The parent resource for dependency tracking.
        :param depends_on: - Explicit dependencies for this resource.
        :param tags: - Tags to apply to the resource (passed separately from body for proper idempotency).

        :return: The created AZAPI resource
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a404c6dee43160589c1a592d4c91470f8bc17a406da1d37b670f3f4d7fe00f53)
            check_type(argname="argument properties", value=properties, expected_type=type_hints["properties"])
            check_type(argname="argument parent_id", value=parent_id, expected_type=type_hints["parent_id"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument location", value=location, expected_type=type_hints["location"])
            check_type(argname="argument parent_resource", value=parent_resource, expected_type=type_hints["parent_resource"])
            check_type(argname="argument depends_on", value=depends_on, expected_type=type_hints["depends_on"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        return typing.cast(_cdktf_9a9027ec.TerraformResource, jsii.invoke(self, "createAzapiResource", [properties, parent_id, name, location, parent_resource, depends_on, tags]))

    @jsii.member(jsii_name="createMonitoringResources")
    def _create_monitoring_resources(
        self,
        *,
        action_groups: typing.Optional[typing.Sequence[typing.Union[_ActionGroupProps_572d2b68, typing.Dict[builtins.str, typing.Any]]]] = None,
        activity_log_alerts: typing.Optional[typing.Sequence[typing.Union[_ActivityLogAlertProps_f1779054, typing.Dict[builtins.str, typing.Any]]]] = None,
        diagnostic_settings: typing.Optional[typing.Union[_DiagnosticSettingsProps_cc0fa615, typing.Dict[builtins.str, typing.Any]]] = None,
        enabled: typing.Optional[builtins.bool] = None,
        metric_alerts: typing.Optional[typing.Sequence[typing.Union[_MetricAlertProps_a18d777f, typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Creates monitoring resources based on the monitoring configuration.

        This method is called automatically during construction if monitoring is configured.
        It creates action groups, metric alerts, and activity log alerts as child constructs.

        Protected to allow subclasses to override or extend monitoring behavior.

        :param action_groups: Action groups to create for this resource Creates new ActionGroup instances as child constructs.
        :param activity_log_alerts: Activity log alerts configuration Creates ActivityLogAlert instances for this resource's operations.
        :param diagnostic_settings: Diagnostic settings configuration Uses the full DiagnosticSettings construct for consistency.
        :param enabled: Whether monitoring is enabled. Default: true
        :param metric_alerts: Metric alerts configuration Creates MetricAlert instances scoped to this resource.
        '''
        config = _MonitoringConfig_7c28df74(
            action_groups=action_groups,
            activity_log_alerts=activity_log_alerts,
            diagnostic_settings=diagnostic_settings,
            enabled=enabled,
            metric_alerts=metric_alerts,
        )

        return typing.cast(None, jsii.ainvoke(self, "createMonitoringResources", [config]))

    @jsii.member(jsii_name="createResourceBody")
    @abc.abstractmethod
    def _create_resource_body(self, props: typing.Any) -> typing.Any:
        '''Creates the resource body for the Azure API call.

        This method should transform the input properties into the JSON body format
        expected by the Azure REST API for the resolved version. The framework will
        have already applied any necessary property transformations and validation.

        :param props: - The processed and validated properties for the resource.

        :return: The resource body object to send to Azure API
        '''
        ...

    @jsii.member(jsii_name="customizeResourceConfig")
    def _customize_resource_config(self, config: typing.Any) -> typing.Any:
        '''Allows child classes to customize the ResourceConfig before resource creation.

        Override this method to add resource-specific configuration like:

        - schemaValidationEnabled: false (for resources with complex nested structures)
        - ignoreMissingProperty: true (for resources with dynamic/unknown properties)
        - ignoreNullProperty: true (for resources that should skip null values)

        :param config: - The base ResourceConfig that will be used to create the resource.

        :return: The potentially modified ResourceConfig

        Example::

            protected customizeResourceConfig(config: ResourceConfig): ResourceConfig {
              return {
                ...config,
                schemaValidationEnabled: false,
                ignoreMissingProperty: true,
              };
            }
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cc42b99cf502face5ee1f35101499a4f83e9c4977fc6a3e5290ec43eead5a095)
            check_type(argname="argument config", value=config, expected_type=type_hints["config"])
        return typing.cast(typing.Any, jsii.invoke(self, "customizeResourceConfig", [config]))

    @jsii.member(jsii_name="defaultLocation")
    def _default_location(self) -> typing.Optional[builtins.str]:
        '''Override in child classes to provide default location.

        :return: Default location or undefined
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.invoke(self, "defaultLocation", []))

    @jsii.member(jsii_name="defaultVersion")
    @abc.abstractmethod
    def _default_version(self) -> builtins.str:
        '''Gets the default API version to use when no explicit version is specified.

        This method should return a sensible default version that can be used
        as a fallback if the ApiVersionManager doesn't have any versions registered
        for this resource type.

        :return: The default API version string (e.g., "2024-11-01")
        '''
        ...

    @jsii.member(jsii_name="initialize")
    def _initialize(
        self,
        *,
        api_version: typing.Optional[builtins.str] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        location: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> None:
        '''Protected initialization method called after the constructor completes.

        This method is called at the end of the constructor to perform initialization
        that requires calling abstract methods. Child classes can override this method
        if they need to extend initialization logic, but they MUST call super.initialize(props).

        :param api_version: Explicit API version to use for this resource. If not specified, the latest active version will be automatically resolved. Use this for version pinning when stability is required over latest features. Default: Latest active version from ApiVersionManager
        :param enable_migration_analysis: Whether to enable migration analysis warnings. When true, the framework will analyze the current version for deprecation status and provide migration recommendations in the deployment output. Default: true
        :param enable_transformation: Whether to apply property transformations automatically. When true, properties will be automatically transformed according to the target schema's transformation rules. This enables backward compatibility. Default: true
        :param enable_validation: Whether to validate properties against the schema. When true, all properties will be validated against the API schema before resource creation. Validation errors will cause deployment failures. Default: true
        :param location: The location where the resource should be created. Default: Varies by resource type - see specific resource documentation
        :param monitoring: Monitoring configuration for this resource. Enables integrated monitoring with diagnostic settings, metric alerts, and activity log alerts. All monitoring is optional and disabled by default.
        :param name: The name of the resource.
        :param tags: Tags to apply to the resource.
        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        '''
        props = _AzapiResourceProps_141a2340(
            api_version=api_version,
            enable_migration_analysis=enable_migration_analysis,
            enable_transformation=enable_transformation,
            enable_validation=enable_validation,
            location=location,
            monitoring=monitoring,
            name=name,
            tags=tags,
            connection=connection,
            count=count,
            depends_on=depends_on,
            for_each=for_each,
            lifecycle=lifecycle,
            provider=provider,
            provisioners=provisioners,
        )

        return typing.cast(None, jsii.invoke(self, "initialize", [props]))

    @jsii.member(jsii_name="latestVersion")
    def latest_version(self) -> typing.Optional[builtins.str]:
        '''Gets the latest available version for this resource type.

        This method provides access to the latest version resolution logic
        for use in subclasses or external tooling.

        :return: The latest available version, or undefined if none found
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.invoke(self, "latestVersion", []))

    @jsii.member(jsii_name="parentResourceForLocation")
    def _parent_resource_for_location(self) -> typing.Optional[_AzapiResource_7e7f5b39]:
        '''Override in child classes to specify parent resource for location inheritance.

        :return: Parent resource or undefined
        '''
        return typing.cast(typing.Optional[_AzapiResource_7e7f5b39], jsii.invoke(self, "parentResourceForLocation", []))

    @jsii.member(jsii_name="requiresLocation")
    def _requires_location(self) -> builtins.bool:
        '''Override in child classes to indicate if location is required.

        :return: true if location is mandatory for this resource type
        '''
        return typing.cast(builtins.bool, jsii.invoke(self, "requiresLocation", []))

    @jsii.member(jsii_name="resolveLocation")
    def _resolve_location(
        self,
        *,
        api_version: typing.Optional[builtins.str] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        location: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> typing.Optional[builtins.str]:
        '''Resolves location using template method pattern Priority: props.location > parent location > default location > validation.

        :param api_version: Explicit API version to use for this resource. If not specified, the latest active version will be automatically resolved. Use this for version pinning when stability is required over latest features. Default: Latest active version from ApiVersionManager
        :param enable_migration_analysis: Whether to enable migration analysis warnings. When true, the framework will analyze the current version for deprecation status and provide migration recommendations in the deployment output. Default: true
        :param enable_transformation: Whether to apply property transformations automatically. When true, properties will be automatically transformed according to the target schema's transformation rules. This enables backward compatibility. Default: true
        :param enable_validation: Whether to validate properties against the schema. When true, all properties will be validated against the API schema before resource creation. Validation errors will cause deployment failures. Default: true
        :param location: The location where the resource should be created. Default: Varies by resource type - see specific resource documentation
        :param monitoring: Monitoring configuration for this resource. Enables integrated monitoring with diagnostic settings, metric alerts, and activity log alerts. All monitoring is optional and disabled by default.
        :param name: The name of the resource.
        :param tags: Tags to apply to the resource.
        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        '''
        props = _AzapiResourceProps_141a2340(
            api_version=api_version,
            enable_migration_analysis=enable_migration_analysis,
            enable_transformation=enable_transformation,
            enable_validation=enable_validation,
            location=location,
            monitoring=monitoring,
            name=name,
            tags=tags,
            connection=connection,
            count=count,
            depends_on=depends_on,
            for_each=for_each,
            lifecycle=lifecycle,
            provider=provider,
            provisioners=provisioners,
        )

        return typing.cast(typing.Optional[builtins.str], jsii.invoke(self, "resolveLocation", [props]))

    @jsii.member(jsii_name="resolveName")
    def _resolve_name(
        self,
        *,
        api_version: typing.Optional[builtins.str] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        location: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> builtins.str:
        '''Resolves the name for this resource.

        This method centralizes name resolution logic. By default, it uses the
        provided name or falls back to the construct ID.

        :param api_version: Explicit API version to use for this resource. If not specified, the latest active version will be automatically resolved. Use this for version pinning when stability is required over latest features. Default: Latest active version from ApiVersionManager
        :param enable_migration_analysis: Whether to enable migration analysis warnings. When true, the framework will analyze the current version for deprecation status and provide migration recommendations in the deployment output. Default: true
        :param enable_transformation: Whether to apply property transformations automatically. When true, properties will be automatically transformed according to the target schema's transformation rules. This enables backward compatibility. Default: true
        :param enable_validation: Whether to validate properties against the schema. When true, all properties will be validated against the API schema before resource creation. Validation errors will cause deployment failures. Default: true
        :param location: The location where the resource should be created. Default: Varies by resource type - see specific resource documentation
        :param monitoring: Monitoring configuration for this resource. Enables integrated monitoring with diagnostic settings, metric alerts, and activity log alerts. All monitoring is optional and disabled by default.
        :param name: The name of the resource.
        :param tags: Tags to apply to the resource.
        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 

        :return: The resolved resource name
        '''
        props = _AzapiResourceProps_141a2340(
            api_version=api_version,
            enable_migration_analysis=enable_migration_analysis,
            enable_transformation=enable_transformation,
            enable_validation=enable_validation,
            location=location,
            monitoring=monitoring,
            name=name,
            tags=tags,
            connection=connection,
            count=count,
            depends_on=depends_on,
            for_each=for_each,
            lifecycle=lifecycle,
            provider=provider,
            provisioners=provisioners,
        )

        return typing.cast(builtins.str, jsii.invoke(self, "resolveName", [props]))

    @jsii.member(jsii_name="resolveParentId")
    def _resolve_parent_id(self, props: typing.Any) -> builtins.str:
        '''Resolves the parent resource ID for this resource.

        Override this method in child resource classes (like Subnet) that need
        custom parent ID resolution logic. By default, this delegates to the
        private _determineParentId method which handles standard resource types.

        :param props: - The resource properties.

        :return: The parent resource ID
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0f4da57c858d29cc3485cd8769a7c9c26ad5686c46b8919d7b5cde5a17ff2d4b)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(builtins.str, jsii.invoke(self, "resolveParentId", [props]))

    @jsii.member(jsii_name="resolveSchema")
    def _resolve_schema(self) -> _ApiSchema_5ce0490e:
        '''Helper method for standard schema resolution.

        Subclasses can use this method to resolve the schema for the current version
        from the ApiVersionManager. This provides a standard implementation that
        most resources can use without custom logic.

        :return: The API schema for the resolved version

        :throws: Error if the schema cannot be resolved
        '''
        return typing.cast(_ApiSchema_5ce0490e, jsii.invoke(self, "resolveSchema", []))

    @jsii.member(jsii_name="resourceType")
    @abc.abstractmethod
    def _resource_type(self) -> builtins.str:
        '''Gets the Azure resource type for this resource.

        This method should return the full Azure resource type identifier that
        will be used for API calls and version management.

        :return: The Azure resource type (e.g., "Microsoft.Resources/resourceGroups")
        '''
        ...

    @jsii.member(jsii_name="supportedVersions")
    def supported_versions(self) -> typing.List[builtins.str]:
        '''Gets all supported versions for this resource type.

        This method provides access to the version registry for use in
        subclasses or external tooling.

        :return: Array of supported version strings, sorted by release date
        '''
        return typing.cast(typing.List[builtins.str], jsii.invoke(self, "supportedVersions", []))

    @jsii.member(jsii_name="supportsTags")
    def _supports_tags(self) -> builtins.bool:
        '''Override in child classes to indicate if the resource type supports tags Some Azure resources (e.g., Policy Definitions, Policy Assignments) do not support tags.

        :return: true if the resource supports tags (default), false otherwise
        '''
        return typing.cast(builtins.bool, jsii.invoke(self, "supportsTags", []))

    @jsii.member(jsii_name="updateAzapiResource")
    def _update_azapi_resource(
        self,
        properties: typing.Mapping[builtins.str, typing.Any],
    ) -> None:
        '''Updates the resource with new properties.

        :param properties: - The new properties to apply.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3049a84daed50c8ec29f4ae37b33f5f4495e2a3b712158dcc6f0c7b6bf15dd71)
            check_type(argname="argument properties", value=properties, expected_type=type_hints["properties"])
        return typing.cast(None, jsii.invoke(self, "updateAzapiResource", [properties]))

    @builtins.property
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        '''The Azure resource ID.

        This property is automatically derived from the underlying Terraform resource.
        Child classes no longer need to implement this property.
        '''
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @builtins.property
    @jsii.member(jsii_name="monitoringActionGroups")
    def _monitoring_action_groups(self) -> typing.List[_constructs_77d1e7e8.Construct]:
        return typing.cast(typing.List[_constructs_77d1e7e8.Construct], jsii.get(self, "monitoringActionGroups"))

    @builtins.property
    @jsii.member(jsii_name="monitoringActivityLogAlerts")
    def _monitoring_activity_log_alerts(
        self,
    ) -> typing.List[_constructs_77d1e7e8.Construct]:
        return typing.cast(typing.List[_constructs_77d1e7e8.Construct], jsii.get(self, "monitoringActivityLogAlerts"))

    @builtins.property
    @jsii.member(jsii_name="monitoringMetricAlerts")
    def _monitoring_metric_alerts(self) -> typing.List[_constructs_77d1e7e8.Construct]:
        return typing.cast(typing.List[_constructs_77d1e7e8.Construct], jsii.get(self, "monitoringMetricAlerts"))

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        '''The name of the resource.'''
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @builtins.property
    @jsii.member(jsii_name="output")
    def output(self) -> _cdktf_9a9027ec.TerraformOutput:
        '''Gets the resource as a Terraform output value.'''
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "output"))

    @builtins.property
    @jsii.member(jsii_name="resource")
    def resource(self) -> _cdktf_9a9027ec.TerraformResource:
        '''Gets the underlying Terraform resource for use in dependency declarations This allows explicit dependency management between resources.'''
        return typing.cast(_cdktf_9a9027ec.TerraformResource, jsii.get(self, "resource"))

    @builtins.property
    @jsii.member(jsii_name="resourceId")
    def resource_id(self) -> builtins.str:
        '''Gets the full resource ID.'''
        return typing.cast(builtins.str, jsii.get(self, "resourceId"))

    @builtins.property
    @jsii.member(jsii_name="tags")
    def tags(self) -> typing.Mapping[builtins.str, builtins.str]:
        '''All tags on this resource (readonly view).

        This getter provides convenient access to all tags including those from props
        and those added dynamically via addTag(). Returns a copy to maintain immutability.
        '''
        return typing.cast(typing.Mapping[builtins.str, builtins.str], jsii.get(self, "tags"))

    @builtins.property
    @jsii.member(jsii_name="location")
    def location(self) -> typing.Optional[builtins.str]:
        '''The location of the resource (optional - not all resources have a location) Child resources typically inherit location from their parent.'''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "location"))

    @builtins.property
    @jsii.member(jsii_name="apiVersion")
    def _api_version(self) -> builtins.str:
        '''The API version to use for this resource.'''
        return typing.cast(builtins.str, jsii.get(self, "apiVersion"))

    @_api_version.setter
    def _api_version(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b91a33d29131d7ab402a65df456389e901806e839a3487c32234d121e24540f8)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "apiVersion", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="resolvedApiVersion")
    def resolved_api_version(self) -> builtins.str:
        '''The resolved API version being used for this resource instance.

        This is the actual version that will be used for the Azure API call,
        either explicitly specified in props or automatically resolved to
        the latest active version.
        '''
        return typing.cast(builtins.str, jsii.get(self, "resolvedApiVersion"))

    @resolved_api_version.setter
    def resolved_api_version(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5857bd3dd3c5748437251edd5ba9165c55519b7e27cec8aede95ae6a3a19dbef)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "resolvedApiVersion", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="schema")
    def schema(self) -> _ApiSchema_5ce0490e:
        '''The API schema for the resolved version.

        Contains the complete schema definition including properties, validation
        rules, and transformation mappings for the resolved API version.
        '''
        return typing.cast(_ApiSchema_5ce0490e, jsii.get(self, "schema"))

    @schema.setter
    def schema(self, value: _ApiSchema_5ce0490e) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0fb0f58401a9dff57c19347d990f1c4b67552ebdb9753625690ed1a4809672b8)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "schema", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.TerraformResource:
        '''The underlying AZAPI Terraform resource.'''
        return typing.cast(_cdktf_9a9027ec.TerraformResource, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.TerraformResource) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1fec2795df9e0c4f2b5fa75ff33324d735773ce6d94e46bea101a8717a85e2f2)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="versionConfig")
    def version_config(self) -> _VersionConfig_ddf991d0:
        '''The version configuration for the resolved version.

        Contains lifecycle information, breaking changes, and migration metadata
        for the resolved API version.
        '''
        return typing.cast(_VersionConfig_ddf991d0, jsii.get(self, "versionConfig"))

    @version_config.setter
    def version_config(self, value: _VersionConfig_ddf991d0) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6e58eeb6020167da6a9493fdbd06f3f8eacd108b6ae212570991c11b94a0dc11)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "versionConfig", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="migrationAnalysis")
    def migration_analysis(self) -> typing.Optional[_MigrationAnalysis_aa719f40]:
        '''Migration analysis results.

        Available after construction if migration analysis is enabled and a
        previous version can be determined for comparison.
        '''
        return typing.cast(typing.Optional[_MigrationAnalysis_aa719f40], jsii.get(self, "migrationAnalysis"))

    @migration_analysis.setter
    def migration_analysis(
        self,
        value: typing.Optional[_MigrationAnalysis_aa719f40],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7f528df0ff7249fb6afc5c73601b6f5b16a73c88ac3d27c75173e1cf915a4c34)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "migrationAnalysis", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="validationResult")
    def validation_result(self) -> typing.Optional[_ValidationResult_87269226]:
        '''Validation results for the resource properties.

        Available after construction if validation is enabled. Contains detailed
        information about any validation errors or warnings.
        '''
        return typing.cast(typing.Optional[_ValidationResult_87269226], jsii.get(self, "validationResult"))

    @validation_result.setter
    def validation_result(
        self,
        value: typing.Optional[_ValidationResult_87269226],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f84b4af5084c31757c50d9f1259dfff939670d44a84c39a671aa1ea6f9330ad9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "validationResult", value) # pyright: ignore[reportArgumentType]


class _AzapiResourceProxy(AzapiResource):
    @jsii.member(jsii_name="apiSchema")
    def _api_schema(self) -> _ApiSchema_5ce0490e:
        '''Gets the API schema for the resolved version.

        This method should return the complete API schema for the resolved version,
        including all property definitions, validation rules, and transformation
        mappings. Use the resolveSchema() helper method for standard schema resolution.

        :return: The API schema for the resolved version
        '''
        return typing.cast(_ApiSchema_5ce0490e, jsii.invoke(self, "apiSchema", []))

    @jsii.member(jsii_name="createResourceBody")
    def _create_resource_body(self, props: typing.Any) -> typing.Any:
        '''Creates the resource body for the Azure API call.

        This method should transform the input properties into the JSON body format
        expected by the Azure REST API for the resolved version. The framework will
        have already applied any necessary property transformations and validation.

        :param props: - The processed and validated properties for the resource.

        :return: The resource body object to send to Azure API
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8b528c66806e6c4d819f260a5384e8b851df8221b890e5cb4ff575de78472b1c)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Any, jsii.invoke(self, "createResourceBody", [props]))

    @jsii.member(jsii_name="defaultVersion")
    def _default_version(self) -> builtins.str:
        '''Gets the default API version to use when no explicit version is specified.

        This method should return a sensible default version that can be used
        as a fallback if the ApiVersionManager doesn't have any versions registered
        for this resource type.

        :return: The default API version string (e.g., "2024-11-01")
        '''
        return typing.cast(builtins.str, jsii.invoke(self, "defaultVersion", []))

    @jsii.member(jsii_name="resourceType")
    def _resource_type(self) -> builtins.str:
        '''Gets the Azure resource type for this resource.

        This method should return the full Azure resource type identifier that
        will be used for API calls and version management.

        :return: The Azure resource type (e.g., "Microsoft.Resources/resourceGroups")
        '''
        return typing.cast(builtins.str, jsii.invoke(self, "resourceType", []))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the abstract class
typing.cast(typing.Any, AzapiResource).__jsii_proxy_class__ = lambda : _AzapiResourceProxy


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.AzapiResourceProps",
    jsii_struct_bases=[_cdktf_9a9027ec.TerraformMetaArguments],
    name_mapping={
        "connection": "connection",
        "count": "count",
        "depends_on": "dependsOn",
        "for_each": "forEach",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "provisioners": "provisioners",
        "api_version": "apiVersion",
        "enable_migration_analysis": "enableMigrationAnalysis",
        "enable_transformation": "enableTransformation",
        "enable_validation": "enableValidation",
        "location": "location",
        "monitoring": "monitoring",
        "name": "name",
        "tags": "tags",
    },
)
class AzapiResourceProps(_cdktf_9a9027ec.TerraformMetaArguments):
    def __init__(
        self,
        *,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
        api_version: typing.Optional[builtins.str] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        location: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''Properties for versioned Azure resources.

        Combines base resource properties with version management capabilities
        and advanced configuration options for the unified framework.

        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        :param api_version: Explicit API version to use for this resource. If not specified, the latest active version will be automatically resolved. Use this for version pinning when stability is required over latest features. Default: Latest active version from ApiVersionManager
        :param enable_migration_analysis: Whether to enable migration analysis warnings. When true, the framework will analyze the current version for deprecation status and provide migration recommendations in the deployment output. Default: true
        :param enable_transformation: Whether to apply property transformations automatically. When true, properties will be automatically transformed according to the target schema's transformation rules. This enables backward compatibility. Default: true
        :param enable_validation: Whether to validate properties against the schema. When true, all properties will be validated against the API schema before resource creation. Validation errors will cause deployment failures. Default: true
        :param location: The location where the resource should be created. Default: Varies by resource type - see specific resource documentation
        :param monitoring: Monitoring configuration for this resource. Enables integrated monitoring with diagnostic settings, metric alerts, and activity log alerts. All monitoring is optional and disabled by default.
        :param name: The name of the resource.
        :param tags: Tags to apply to the resource.
        '''
        if isinstance(lifecycle, dict):
            lifecycle = _cdktf_9a9027ec.TerraformResourceLifecycle(**lifecycle)
        if isinstance(monitoring, dict):
            monitoring = _MonitoringConfig_7c28df74(**monitoring)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3d93af01845ca8c4fccb8df898596d1e45bcb9c1695be8e9787e78e62e393dfa)
            check_type(argname="argument connection", value=connection, expected_type=type_hints["connection"])
            check_type(argname="argument count", value=count, expected_type=type_hints["count"])
            check_type(argname="argument depends_on", value=depends_on, expected_type=type_hints["depends_on"])
            check_type(argname="argument for_each", value=for_each, expected_type=type_hints["for_each"])
            check_type(argname="argument lifecycle", value=lifecycle, expected_type=type_hints["lifecycle"])
            check_type(argname="argument provider", value=provider, expected_type=type_hints["provider"])
            check_type(argname="argument provisioners", value=provisioners, expected_type=type_hints["provisioners"])
            check_type(argname="argument api_version", value=api_version, expected_type=type_hints["api_version"])
            check_type(argname="argument enable_migration_analysis", value=enable_migration_analysis, expected_type=type_hints["enable_migration_analysis"])
            check_type(argname="argument enable_transformation", value=enable_transformation, expected_type=type_hints["enable_transformation"])
            check_type(argname="argument enable_validation", value=enable_validation, expected_type=type_hints["enable_validation"])
            check_type(argname="argument location", value=location, expected_type=type_hints["location"])
            check_type(argname="argument monitoring", value=monitoring, expected_type=type_hints["monitoring"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if connection is not None:
            self._values["connection"] = connection
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if for_each is not None:
            self._values["for_each"] = for_each
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider
        if provisioners is not None:
            self._values["provisioners"] = provisioners
        if api_version is not None:
            self._values["api_version"] = api_version
        if enable_migration_analysis is not None:
            self._values["enable_migration_analysis"] = enable_migration_analysis
        if enable_transformation is not None:
            self._values["enable_transformation"] = enable_transformation
        if enable_validation is not None:
            self._values["enable_validation"] = enable_validation
        if location is not None:
            self._values["location"] = location
        if monitoring is not None:
            self._values["monitoring"] = monitoring
        if name is not None:
            self._values["name"] = name
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def connection(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("connection")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]], result)

    @builtins.property
    def count(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]], result)

    @builtins.property
    def depends_on(
        self,
    ) -> typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]], result)

    @builtins.property
    def for_each(self) -> typing.Optional[_cdktf_9a9027ec.ITerraformIterator]:
        '''
        :stability: experimental
        '''
        result = self._values.get("for_each")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.ITerraformIterator], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[_cdktf_9a9027ec.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformProvider], result)

    @builtins.property
    def provisioners(
        self,
    ) -> typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provisioners")
        return typing.cast(typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]], result)

    @builtins.property
    def api_version(self) -> typing.Optional[builtins.str]:
        '''Explicit API version to use for this resource.

        If not specified, the latest active version will be automatically resolved.
        Use this for version pinning when stability is required over latest features.

        :default: Latest active version from ApiVersionManager

        Example::

            "2024-11-01"
        '''
        result = self._values.get("api_version")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def enable_migration_analysis(self) -> typing.Optional[builtins.bool]:
        '''Whether to enable migration analysis warnings.

        When true, the framework will analyze the current version for deprecation
        status and provide migration recommendations in the deployment output.

        :default: true
        '''
        result = self._values.get("enable_migration_analysis")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_transformation(self) -> typing.Optional[builtins.bool]:
        '''Whether to apply property transformations automatically.

        When true, properties will be automatically transformed according to the
        target schema's transformation rules. This enables backward compatibility.

        :default: true
        '''
        result = self._values.get("enable_transformation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_validation(self) -> typing.Optional[builtins.bool]:
        '''Whether to validate properties against the schema.

        When true, all properties will be validated against the API schema before
        resource creation. Validation errors will cause deployment failures.

        :default: true
        '''
        result = self._values.get("enable_validation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def location(self) -> typing.Optional[builtins.str]:
        '''The location where the resource should be created.

        :default: Varies by resource type - see specific resource documentation

        :remarks:

        Location handling varies by resource type:

        - **Top-level resources**: Most require an explicit location (e.g., "eastus", "westus")
        - **Global resources**: Some use "global" as location (e.g., Private DNS Zones)
        - **Child resources**: Inherit location from parent and should NOT set this property

        Each resource type may provide its own default through the ``resolveLocation()`` method.
        If no location is specified and no default exists, resource creation may fail.

        Example::

            // Child resource (Subnet) - do not set location
            // location: undefined (inherited from parent Virtual Network)
        '''
        result = self._values.get("location")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def monitoring(self) -> typing.Optional[_MonitoringConfig_7c28df74]:
        '''Monitoring configuration for this resource.

        Enables integrated monitoring with diagnostic settings, metric alerts,
        and activity log alerts. All monitoring is optional and disabled by default.

        Example::

            monitoring: {
              enabled: true,
              diagnosticSettings: {
                workspaceId: logAnalytics.id,
                metrics: ['AllMetrics'],
                logs: ['AuditLogs']
              },
              metricAlerts: [{
                name: 'high-cpu-alert',
                severity: 2,
                scopes: [], // Automatically set to this resource
                criteria: { ... },
                actions: [{ actionGroupId: actionGroup.id }]
              }]
            }
        '''
        result = self._values.get("monitoring")
        return typing.cast(typing.Optional[_MonitoringConfig_7c28df74], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the resource.'''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Tags to apply to the resource.'''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AzapiResourceProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AzapiRoleAssignment(
    _constructs_77d1e7e8.Construct,
    metaclass=jsii.JSIIMeta,
    jsii_type="@microsoft/terraform-cdk-constructs.AzapiRoleAssignment",
):
    '''AZAPI-based role assignment construct.'''

    def __init__(
        self,
        scope_: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        object_id: builtins.str,
        role_definition_name: builtins.str,
        scope: builtins.str,
    ) -> None:
        '''
        :param scope_: -
        :param id: -
        :param object_id: 
        :param role_definition_name: 
        :param scope: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__89a5f56067301c27b4a88c97c0bd8eb62b4ad952688cae6c4f4430ff1375d4ad)
            check_type(argname="argument scope_", value=scope_, expected_type=type_hints["scope_"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = _AzapiRoleAssignmentProps_d153e00c(
            object_id=object_id, role_definition_name=role_definition_name, scope=scope
        )

        jsii.create(self.__class__, self, [scope_, id, props])


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.AzapiRoleAssignmentProps",
    jsii_struct_bases=[],
    name_mapping={
        "object_id": "objectId",
        "role_definition_name": "roleDefinitionName",
        "scope": "scope",
    },
)
class AzapiRoleAssignmentProps:
    def __init__(
        self,
        *,
        object_id: builtins.str,
        role_definition_name: builtins.str,
        scope: builtins.str,
    ) -> None:
        '''Properties for AZAPI role assignment.

        :param object_id: 
        :param role_definition_name: 
        :param scope: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__333820b506b51590b5eebe73fd9c0f718a72a7642876a758352f5ef516c7e6ba)
            check_type(argname="argument object_id", value=object_id, expected_type=type_hints["object_id"])
            check_type(argname="argument role_definition_name", value=role_definition_name, expected_type=type_hints["role_definition_name"])
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "object_id": object_id,
            "role_definition_name": role_definition_name,
            "scope": scope,
        }

    @builtins.property
    def object_id(self) -> builtins.str:
        result = self._values.get("object_id")
        assert result is not None, "Required property 'object_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def role_definition_name(self) -> builtins.str:
        result = self._values.get("role_definition_name")
        assert result is not None, "Required property 'role_definition_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def scope(self) -> builtins.str:
        result = self._values.get("scope")
        assert result is not None, "Required property 'scope' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AzapiRoleAssignmentProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.AzureFunctionReceiver",
    jsii_struct_bases=[],
    name_mapping={
        "function_app_resource_id": "functionAppResourceId",
        "function_name": "functionName",
        "http_trigger_url": "httpTriggerUrl",
        "name": "name",
        "use_common_alert_schema": "useCommonAlertSchema",
    },
)
class AzureFunctionReceiver:
    def __init__(
        self,
        *,
        function_app_resource_id: builtins.str,
        function_name: builtins.str,
        http_trigger_url: builtins.str,
        name: builtins.str,
        use_common_alert_schema: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Azure Function receiver configuration.

        :param function_app_resource_id: The function app resource ID.
        :param function_name: The function name.
        :param http_trigger_url: The HTTP trigger URL.
        :param name: The name of the Azure Function receiver.
        :param use_common_alert_schema: Whether to use common alert schema. Default: false
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c85861f0d4a940a106186a175c34fae8bc741b46644dcb5be999d94ef7f1c0a8)
            check_type(argname="argument function_app_resource_id", value=function_app_resource_id, expected_type=type_hints["function_app_resource_id"])
            check_type(argname="argument function_name", value=function_name, expected_type=type_hints["function_name"])
            check_type(argname="argument http_trigger_url", value=http_trigger_url, expected_type=type_hints["http_trigger_url"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument use_common_alert_schema", value=use_common_alert_schema, expected_type=type_hints["use_common_alert_schema"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "function_app_resource_id": function_app_resource_id,
            "function_name": function_name,
            "http_trigger_url": http_trigger_url,
            "name": name,
        }
        if use_common_alert_schema is not None:
            self._values["use_common_alert_schema"] = use_common_alert_schema

    @builtins.property
    def function_app_resource_id(self) -> builtins.str:
        '''The function app resource ID.'''
        result = self._values.get("function_app_resource_id")
        assert result is not None, "Required property 'function_app_resource_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def function_name(self) -> builtins.str:
        '''The function name.'''
        result = self._values.get("function_name")
        assert result is not None, "Required property 'function_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def http_trigger_url(self) -> builtins.str:
        '''The HTTP trigger URL.'''
        result = self._values.get("http_trigger_url")
        assert result is not None, "Required property 'http_trigger_url' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the Azure Function receiver.'''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def use_common_alert_schema(self) -> typing.Optional[builtins.bool]:
        '''Whether to use common alert schema.

        :default: false
        '''
        result = self._values.get("use_common_alert_schema")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AzureFunctionReceiver(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class BaseTestStack(
    _cdktf_9a9027ec.TerraformStack,
    metaclass=jsii.JSIIMeta,
    jsii_type="@microsoft/terraform-cdk-constructs.BaseTestStack",
):
    '''Base stack for integration tests with optional metadata support.

    When metadata is enabled, automatically generates unique test run IDs,
    injects system tags, and provides utilities for resource naming.
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        test_run_options: typing.Optional[typing.Union["TestRunOptions", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param test_run_options: Test run configuration options.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__16460280811f9f2724ccd3b87254ebd16f53c2d53bb01bf9756133f158791eb7)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        options = _BaseTestStackOptions_431240be(test_run_options=test_run_options)

        jsii.create(self.__class__, self, [scope, id, options])

    @jsii.member(jsii_name="generateResourceName")
    def generate_resource_name(
        self,
        resource_type: builtins.str,
        custom_identifier: typing.Optional[builtins.str] = None,
    ) -> builtins.str:
        '''Generates a unique resource name with proper Azure compliance.

        :param resource_type: - Azure resource type (e.g., 'Microsoft.Resources/resourceGroups').
        :param custom_identifier: - Optional custom identifier (defaults to test name).

        :return: Unique, Azure-compliant resource name

        :throws: Error if metadata is not initialized

        Example::

            const stack = new BaseTestStack(app, 'test-storage', { testRunOptions: {} });
            const rgName = stack.generateResourceName('Microsoft.Resources/resourceGroups');
            // Returns: 'rg-test-storage-a1b2c3'
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__81e4c9adfc4da93a3c11e11036f4464715cef73d8184d2d1a797db0a9a992aac)
            check_type(argname="argument resource_type", value=resource_type, expected_type=type_hints["resource_type"])
            check_type(argname="argument custom_identifier", value=custom_identifier, expected_type=type_hints["custom_identifier"])
        return typing.cast(builtins.str, jsii.invoke(self, "generateResourceName", [resource_type, custom_identifier]))

    @jsii.member(jsii_name="registeredResources")
    def registered_resources(self) -> typing.List["ResourceMetadata"]:
        '''Retrieves all registered resources.

        :return: Array of registered resource metadata
        '''
        return typing.cast(typing.List["ResourceMetadata"], jsii.invoke(self, "registeredResources", []))

    @jsii.member(jsii_name="registerResource")
    def register_resource(
        self,
        resource_id: builtins.str,
        resource_type: builtins.str,
        name: builtins.str,
        location: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''Registers a resource for tracking and cleanup verification.

        :param resource_id: - Azure resource ID.
        :param resource_type: - Azure resource type.
        :param name: - Resource name.
        :param location: - Optional resource location.
        :param tags: - Optional resource tags.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bcdd0e0aa15b47800d501644be23172374bc8f8b4ab62d39724a9980bd130b34)
            check_type(argname="argument resource_id", value=resource_id, expected_type=type_hints["resource_id"])
            check_type(argname="argument resource_type", value=resource_type, expected_type=type_hints["resource_type"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument location", value=location, expected_type=type_hints["location"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        return typing.cast(None, jsii.invoke(self, "registerResource", [resource_id, resource_type, name, location, tags]))

    @jsii.member(jsii_name="systemTags")
    def system_tags(self) -> typing.Mapping[builtins.str, builtins.str]:
        '''Generates system tags for resources (only available when metadata is present).

        :return: Integration test system tags

        :throws: Error if metadata is not initialized
        '''
        return typing.cast(typing.Mapping[builtins.str, builtins.str], jsii.invoke(self, "systemTags", []))

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @builtins.property
    @jsii.member(jsii_name="metadata")
    def metadata(self) -> typing.Optional["TestRunMetadata"]:
        '''Optional test run metadata (only present when using BaseTestStackOptions).'''
        return typing.cast(typing.Optional["TestRunMetadata"], jsii.get(self, "metadata"))


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.BaseTestStackOptions",
    jsii_struct_bases=[],
    name_mapping={"test_run_options": "testRunOptions"},
)
class BaseTestStackOptions:
    def __init__(
        self,
        *,
        test_run_options: typing.Optional[typing.Union["TestRunOptions", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Options for BaseTestStack constructor.

        :param test_run_options: Test run configuration options.
        '''
        if isinstance(test_run_options, dict):
            test_run_options = TestRunOptions(**test_run_options)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__754523de47175eab260ebc6066f389361a572594eb7c1228e4fac5a665526a3f)
            check_type(argname="argument test_run_options", value=test_run_options, expected_type=type_hints["test_run_options"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if test_run_options is not None:
            self._values["test_run_options"] = test_run_options

    @builtins.property
    def test_run_options(self) -> typing.Optional["TestRunOptions"]:
        '''Test run configuration options.'''
        result = self._values.get("test_run_options")
        return typing.cast(typing.Optional["TestRunOptions"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "BaseTestStackOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.BreakingChange",
    jsii_struct_bases=[],
    name_mapping={
        "change_type": "changeType",
        "description": "description",
        "migration_path": "migrationPath",
        "new_value": "newValue",
        "old_value": "oldValue",
        "property": "property",
    },
)
class BreakingChange:
    def __init__(
        self,
        *,
        change_type: builtins.str,
        description: builtins.str,
        migration_path: typing.Optional[builtins.str] = None,
        new_value: typing.Optional[builtins.str] = None,
        old_value: typing.Optional[builtins.str] = None,
        property: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Breaking change documentation.

        Documents a breaking change between API versions to enable automated
        migration analysis and provide guidance to developers.

        :param change_type: The type of breaking change Must be one of the BreakingChangeType constants.
        :param description: Human-readable description of the breaking change Explains the impact and reasoning behind the change.
        :param migration_path: Guidance on how to migrate from old to new format Should include code examples where applicable.
        :param new_value: The new value or format Shows developers what to change to.
        :param old_value: The old value or format (for reference) Helps developers understand what changed.
        :param property: The property name affected by the breaking change Omit for schema-level changes.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d8294b7173ae32b733a72e6bd891a22906cfb0103b787259df438fea598a74df)
            check_type(argname="argument change_type", value=change_type, expected_type=type_hints["change_type"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument migration_path", value=migration_path, expected_type=type_hints["migration_path"])
            check_type(argname="argument new_value", value=new_value, expected_type=type_hints["new_value"])
            check_type(argname="argument old_value", value=old_value, expected_type=type_hints["old_value"])
            check_type(argname="argument property", value=property, expected_type=type_hints["property"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "change_type": change_type,
            "description": description,
        }
        if migration_path is not None:
            self._values["migration_path"] = migration_path
        if new_value is not None:
            self._values["new_value"] = new_value
        if old_value is not None:
            self._values["old_value"] = old_value
        if property is not None:
            self._values["property"] = property

    @builtins.property
    def change_type(self) -> builtins.str:
        '''The type of breaking change Must be one of the BreakingChangeType constants.'''
        result = self._values.get("change_type")
        assert result is not None, "Required property 'change_type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def description(self) -> builtins.str:
        '''Human-readable description of the breaking change Explains the impact and reasoning behind the change.'''
        result = self._values.get("description")
        assert result is not None, "Required property 'description' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def migration_path(self) -> typing.Optional[builtins.str]:
        '''Guidance on how to migrate from old to new format Should include code examples where applicable.'''
        result = self._values.get("migration_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def new_value(self) -> typing.Optional[builtins.str]:
        '''The new value or format Shows developers what to change to.'''
        result = self._values.get("new_value")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def old_value(self) -> typing.Optional[builtins.str]:
        '''The old value or format (for reference) Helps developers understand what changed.'''
        result = self._values.get("old_value")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def property(self) -> typing.Optional[builtins.str]:
        '''The property name affected by the breaking change Omit for schema-level changes.'''
        result = self._values.get("property")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "BreakingChange(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class BreakingChangeType(
    metaclass=jsii.JSIIMeta,
    jsii_type="@microsoft/terraform-cdk-constructs.BreakingChangeType",
):
    '''Breaking change types for migration analysis.

    Categorizes the types of breaking changes that can occur between API versions
    to enable automated migration analysis and tooling.
    '''

    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.python.classproperty
    @jsii.member(jsii_name="PROPERTY_REMOVED")
    def PROPERTY_REMOVED(cls) -> builtins.str:
        '''Property has been removed from the API.'''
        return typing.cast(builtins.str, jsii.sget(cls, "PROPERTY_REMOVED"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="PROPERTY_RENAMED")
    def PROPERTY_RENAMED(cls) -> builtins.str:
        '''Property has been renamed.'''
        return typing.cast(builtins.str, jsii.sget(cls, "PROPERTY_RENAMED"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="PROPERTY_REQUIRED")
    def PROPERTY_REQUIRED(cls) -> builtins.str:
        '''Previously optional property is now required.'''
        return typing.cast(builtins.str, jsii.sget(cls, "PROPERTY_REQUIRED"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="PROPERTY_TYPE_CHANGED")
    def PROPERTY_TYPE_CHANGED(cls) -> builtins.str:
        '''Property data type has changed.'''
        return typing.cast(builtins.str, jsii.sget(cls, "PROPERTY_TYPE_CHANGED"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="SCHEMA_RESTRUCTURED")
    def SCHEMA_RESTRUCTURED(cls) -> builtins.str:
        '''Overall schema structure has been reorganized.'''
        return typing.cast(builtins.str, jsii.sget(cls, "SCHEMA_RESTRUCTURED"))


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.CIContext",
    jsii_struct_bases=[],
    name_mapping={
        "platform": "platform",
        "branch": "branch",
        "commit_sha": "commitSha",
        "commit_sha_short": "commitShaShort",
        "pipeline_id": "pipelineId",
        "repository": "repository",
        "run_id": "runId",
        "run_number": "runNumber",
    },
)
class CIContext:
    def __init__(
        self,
        *,
        platform: builtins.str,
        branch: typing.Optional[builtins.str] = None,
        commit_sha: typing.Optional[builtins.str] = None,
        commit_sha_short: typing.Optional[builtins.str] = None,
        pipeline_id: typing.Optional[builtins.str] = None,
        repository: typing.Optional[builtins.str] = None,
        run_id: typing.Optional[builtins.str] = None,
        run_number: typing.Optional[builtins.str] = None,
    ) -> None:
        '''CI/CD pipeline context.

        Extracted from environment variables during test execution.
        Enables tracing resources back to specific pipeline runs.

        :param platform: CI platform ('github-actions', 'azure-devops', 'generic-ci', 'local').
        :param branch: Git branch name.
        :param commit_sha: Git commit SHA (full).
        :param commit_sha_short: Git commit SHA (short, 7 chars).
        :param pipeline_id: GitHub Actions workflow ID or equivalent.
        :param repository: Git repository name.
        :param run_id: GitHub Actions run ID or equivalent.
        :param run_number: GitHub Actions run number or equivalent.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1ec023d37c6f1585bf2ba961327d5c12143dbf473919ab5029082cece733b95c)
            check_type(argname="argument platform", value=platform, expected_type=type_hints["platform"])
            check_type(argname="argument branch", value=branch, expected_type=type_hints["branch"])
            check_type(argname="argument commit_sha", value=commit_sha, expected_type=type_hints["commit_sha"])
            check_type(argname="argument commit_sha_short", value=commit_sha_short, expected_type=type_hints["commit_sha_short"])
            check_type(argname="argument pipeline_id", value=pipeline_id, expected_type=type_hints["pipeline_id"])
            check_type(argname="argument repository", value=repository, expected_type=type_hints["repository"])
            check_type(argname="argument run_id", value=run_id, expected_type=type_hints["run_id"])
            check_type(argname="argument run_number", value=run_number, expected_type=type_hints["run_number"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "platform": platform,
        }
        if branch is not None:
            self._values["branch"] = branch
        if commit_sha is not None:
            self._values["commit_sha"] = commit_sha
        if commit_sha_short is not None:
            self._values["commit_sha_short"] = commit_sha_short
        if pipeline_id is not None:
            self._values["pipeline_id"] = pipeline_id
        if repository is not None:
            self._values["repository"] = repository
        if run_id is not None:
            self._values["run_id"] = run_id
        if run_number is not None:
            self._values["run_number"] = run_number

    @builtins.property
    def platform(self) -> builtins.str:
        '''CI platform ('github-actions', 'azure-devops', 'generic-ci', 'local').'''
        result = self._values.get("platform")
        assert result is not None, "Required property 'platform' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def branch(self) -> typing.Optional[builtins.str]:
        '''Git branch name.'''
        result = self._values.get("branch")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def commit_sha(self) -> typing.Optional[builtins.str]:
        '''Git commit SHA (full).'''
        result = self._values.get("commit_sha")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def commit_sha_short(self) -> typing.Optional[builtins.str]:
        '''Git commit SHA (short, 7 chars).'''
        result = self._values.get("commit_sha_short")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def pipeline_id(self) -> typing.Optional[builtins.str]:
        '''GitHub Actions workflow ID or equivalent.'''
        result = self._values.get("pipeline_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def repository(self) -> typing.Optional[builtins.str]:
        '''Git repository name.'''
        result = self._values.get("repository")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def run_id(self) -> typing.Optional[builtins.str]:
        '''GitHub Actions run ID or equivalent.'''
        result = self._values.get("run_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def run_number(self) -> typing.Optional[builtins.str]:
        '''GitHub Actions run number or equivalent.'''
        result = self._values.get("run_number")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CIContext(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.CidrValidationResult",
    jsii_struct_bases=[],
    name_mapping={"errors": "errors", "valid": "valid", "warnings": "warnings"},
)
class CidrValidationResult:
    def __init__(
        self,
        *,
        errors: typing.Sequence[builtins.str],
        valid: builtins.bool,
        warnings: typing.Sequence[builtins.str],
    ) -> None:
        '''Result of CIDR validation operations.

        :param errors: List of validation errors.
        :param valid: Whether the validation passed.
        :param warnings: List of validation warnings.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__55fd44e885c5ef5f1b1e8f2ff314fc705d9474c215a41e2a19022b7597a276bd)
            check_type(argname="argument errors", value=errors, expected_type=type_hints["errors"])
            check_type(argname="argument valid", value=valid, expected_type=type_hints["valid"])
            check_type(argname="argument warnings", value=warnings, expected_type=type_hints["warnings"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "errors": errors,
            "valid": valid,
            "warnings": warnings,
        }

    @builtins.property
    def errors(self) -> typing.List[builtins.str]:
        '''List of validation errors.'''
        result = self._values.get("errors")
        assert result is not None, "Required property 'errors' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def valid(self) -> builtins.bool:
        '''Whether the validation passed.'''
        result = self._values.get("valid")
        assert result is not None, "Required property 'valid' is missing"
        return typing.cast(builtins.bool, result)

    @builtins.property
    def warnings(self) -> typing.List[builtins.str]:
        '''List of validation warnings.'''
        result = self._values.get("warnings")
        assert result is not None, "Required property 'warnings' is missing"
        return typing.cast(typing.List[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CidrValidationResult(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.CleanupOptions",
    jsii_struct_bases=[],
    name_mapping={
        "dry_run": "dryRun",
        "min_age_hours": "minAgeHours",
        "max_resources": "maxResources",
        "resource_groups": "resourceGroups",
        "subscription": "subscription",
    },
)
class CleanupOptions:
    def __init__(
        self,
        *,
        dry_run: builtins.bool,
        min_age_hours: jsii.Number,
        max_resources: typing.Optional[jsii.Number] = None,
        resource_groups: typing.Optional[typing.Sequence[builtins.str]] = None,
        subscription: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Options for cleanup operations.

        :param dry_run: Whether to perform dry-run (no actual deletion).
        :param min_age_hours: Minimum age in hours before resource can be cleaned up Set to 0 to force cleanup of all resources regardless of age (bypasses safety checks).
        :param max_resources: Maximum number of resources to clean up in one operation.
        :param resource_groups: Specific resource groups to target (optional).
        :param subscription: Azure subscription ID to target (optional).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__09c49f049abc2780c902c1a7737c5c054044ade357f6dd9cd8fa6fa4171515aa)
            check_type(argname="argument dry_run", value=dry_run, expected_type=type_hints["dry_run"])
            check_type(argname="argument min_age_hours", value=min_age_hours, expected_type=type_hints["min_age_hours"])
            check_type(argname="argument max_resources", value=max_resources, expected_type=type_hints["max_resources"])
            check_type(argname="argument resource_groups", value=resource_groups, expected_type=type_hints["resource_groups"])
            check_type(argname="argument subscription", value=subscription, expected_type=type_hints["subscription"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "dry_run": dry_run,
            "min_age_hours": min_age_hours,
        }
        if max_resources is not None:
            self._values["max_resources"] = max_resources
        if resource_groups is not None:
            self._values["resource_groups"] = resource_groups
        if subscription is not None:
            self._values["subscription"] = subscription

    @builtins.property
    def dry_run(self) -> builtins.bool:
        '''Whether to perform dry-run (no actual deletion).'''
        result = self._values.get("dry_run")
        assert result is not None, "Required property 'dry_run' is missing"
        return typing.cast(builtins.bool, result)

    @builtins.property
    def min_age_hours(self) -> jsii.Number:
        '''Minimum age in hours before resource can be cleaned up Set to 0 to force cleanup of all resources regardless of age (bypasses safety checks).'''
        result = self._values.get("min_age_hours")
        assert result is not None, "Required property 'min_age_hours' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def max_resources(self) -> typing.Optional[jsii.Number]:
        '''Maximum number of resources to clean up in one operation.'''
        result = self._values.get("max_resources")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def resource_groups(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Specific resource groups to target (optional).'''
        result = self._values.get("resource_groups")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def subscription(self) -> typing.Optional[builtins.str]:
        '''Azure subscription ID to target (optional).'''
        result = self._values.get("subscription")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CleanupOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.CleanupResult",
    jsii_struct_bases=[],
    name_mapping={
        "deleted": "deleted",
        "failed": "failed",
        "skipped": "skipped",
        "errors": "errors",
    },
)
class CleanupResult:
    def __init__(
        self,
        *,
        deleted: jsii.Number,
        failed: jsii.Number,
        skipped: jsii.Number,
        errors: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''Result of cleanup operation.

        :param deleted: Number of resources successfully deleted.
        :param failed: Number of resources that failed to delete.
        :param skipped: Number of resources skipped (e.g., too young).
        :param errors: Detailed error messages for failures.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__eed79dbe42a796f5dca7242cf50bae5f47475cf9b28b985583f004bb4fa04d1e)
            check_type(argname="argument deleted", value=deleted, expected_type=type_hints["deleted"])
            check_type(argname="argument failed", value=failed, expected_type=type_hints["failed"])
            check_type(argname="argument skipped", value=skipped, expected_type=type_hints["skipped"])
            check_type(argname="argument errors", value=errors, expected_type=type_hints["errors"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "deleted": deleted,
            "failed": failed,
            "skipped": skipped,
        }
        if errors is not None:
            self._values["errors"] = errors

    @builtins.property
    def deleted(self) -> jsii.Number:
        '''Number of resources successfully deleted.'''
        result = self._values.get("deleted")
        assert result is not None, "Required property 'deleted' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def failed(self) -> jsii.Number:
        '''Number of resources that failed to delete.'''
        result = self._values.get("failed")
        assert result is not None, "Required property 'failed' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def skipped(self) -> jsii.Number:
        '''Number of resources skipped (e.g., too young).'''
        result = self._values.get("skipped")
        assert result is not None, "Required property 'skipped' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def errors(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Detailed error messages for failures.'''
        result = self._values.get("errors")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CleanupResult(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ConnectivityConfiguration(
    _AzapiResource_7e7f5b39,
    metaclass=jsii.JSIIMeta,
    jsii_type="@microsoft/terraform-cdk-constructs.ConnectivityConfiguration",
):
    '''Azure Virtual Network Manager Connectivity Configuration implementation.

    Connectivity configurations define the network topology (mesh or hub-and-spoke) for
    virtual networks. They enable automated peering management at scale and support both
    regional and global connectivity scenarios.

    Example::

        // Mesh topology:
        const meshConfig = new ConnectivityConfiguration(this, "mesh", {
          name: "development-mesh",
          networkManagerId: networkManager.id,
          description: "Mesh for development VNets",
          connectivityTopology: "Mesh",
          appliesToGroups: [{
            networkGroupId: devGroup.id,
            groupConnectivity: "DirectlyConnected",
            isGlobal: false
          }],
          isGlobal: false
        });
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        applies_to_groups: typing.Sequence[typing.Union[_ConnectivityGroupItem_d310024f, typing.Dict[builtins.str, typing.Any]]],
        connectivity_topology: builtins.str,
        network_manager_id: builtins.str,
        delete_existing_peering: typing.Optional[builtins.bool] = None,
        description: typing.Optional[builtins.str] = None,
        hubs: typing.Optional[typing.Sequence[typing.Union[_Hub_d4efdd65, typing.Dict[builtins.str, typing.Any]]]] = None,
        ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
        is_global: typing.Optional[builtins.bool] = None,
        api_version: typing.Optional[builtins.str] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        location: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> None:
        '''Creates a new Azure Virtual Network Manager Connectivity Configuration using the AzapiResource framework.

        :param scope: - The scope in which to define this construct.
        :param id: - The unique identifier for this instance.
        :param applies_to_groups: Network groups to apply this configuration to Each item specifies a network group and how it should connect.
        :param connectivity_topology: Connectivity topology type - HubAndSpoke: Central hub with spoke VNets - Mesh: All VNets can communicate directly.
        :param network_manager_id: Resource ID of the parent Network Manager.
        :param delete_existing_peering: Delete existing peerings when applying this configuration. Default: false
        :param description: Optional description of the connectivity configuration.
        :param hubs: Hub VNets for hub-and-spoke topology Required when connectivityTopology is "HubAndSpoke".
        :param ignore_changes: The lifecycle rules to ignore changes.
        :param is_global: Enable global mesh connectivity Allows mesh connectivity across regions. Default: false
        :param api_version: Explicit API version to use for this resource. If not specified, the latest active version will be automatically resolved. Use this for version pinning when stability is required over latest features. Default: Latest active version from ApiVersionManager
        :param enable_migration_analysis: Whether to enable migration analysis warnings. When true, the framework will analyze the current version for deprecation status and provide migration recommendations in the deployment output. Default: true
        :param enable_transformation: Whether to apply property transformations automatically. When true, properties will be automatically transformed according to the target schema's transformation rules. This enables backward compatibility. Default: true
        :param enable_validation: Whether to validate properties against the schema. When true, all properties will be validated against the API schema before resource creation. Validation errors will cause deployment failures. Default: true
        :param location: The location where the resource should be created. Default: Varies by resource type - see specific resource documentation
        :param monitoring: Monitoring configuration for this resource. Enables integrated monitoring with diagnostic settings, metric alerts, and activity log alerts. All monitoring is optional and disabled by default.
        :param name: The name of the resource.
        :param tags: Tags to apply to the resource.
        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bb63d7912d498d993295b04451dc117e1e8dbc215978e4ec6945e12fa1d657f4)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = _ConnectivityConfigurationProps_38bdc7ac(
            applies_to_groups=applies_to_groups,
            connectivity_topology=connectivity_topology,
            network_manager_id=network_manager_id,
            delete_existing_peering=delete_existing_peering,
            description=description,
            hubs=hubs,
            ignore_changes=ignore_changes,
            is_global=is_global,
            api_version=api_version,
            enable_migration_analysis=enable_migration_analysis,
            enable_transformation=enable_transformation,
            enable_validation=enable_validation,
            location=location,
            monitoring=monitoring,
            name=name,
            tags=tags,
            connection=connection,
            count=count,
            depends_on=depends_on,
            for_each=for_each,
            lifecycle=lifecycle,
            provider=provider,
            provisioners=provisioners,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="apiSchema")
    def _api_schema(self) -> _ApiSchema_5ce0490e:
        '''Gets the API schema for the resolved version.'''
        return typing.cast(_ApiSchema_5ce0490e, jsii.invoke(self, "apiSchema", []))

    @jsii.member(jsii_name="createResourceBody")
    def _create_resource_body(self, props: typing.Any) -> typing.Any:
        '''Creates the resource body for the Azure API call.

        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0fd68c1eb064a90a196cb1012011da15c432f44082a1a723b4e9fc50a5870862)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Any, jsii.invoke(self, "createResourceBody", [props]))

    @jsii.member(jsii_name="defaultVersion")
    def _default_version(self) -> builtins.str:
        '''Gets the default API version to use when no explicit version is specified.'''
        return typing.cast(builtins.str, jsii.invoke(self, "defaultVersion", []))

    @jsii.member(jsii_name="resolveParentId")
    def _resolve_parent_id(self, props: typing.Any) -> builtins.str:
        '''Resolves the parent resource ID for the Connectivity Configuration Connectivity Configurations are scoped to Network Managers.

        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5c77220258d119867457f1f77fb9d3259949ebfafa74999bcf1bf26a6f3ef207)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(builtins.str, jsii.invoke(self, "resolveParentId", [props]))

    @jsii.member(jsii_name="resourceType")
    def _resource_type(self) -> builtins.str:
        '''Gets the Azure resource type for Connectivity Configurations.'''
        return typing.cast(builtins.str, jsii.invoke(self, "resourceType", []))

    @builtins.property
    @jsii.member(jsii_name="idOutput")
    def id_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "idOutput"))

    @builtins.property
    @jsii.member(jsii_name="nameOutput")
    def name_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "nameOutput"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def props(self) -> _ConnectivityConfigurationProps_38bdc7ac:
        '''The input properties for this Connectivity Configuration instance.'''
        return typing.cast(_ConnectivityConfigurationProps_38bdc7ac, jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        '''Get the provisioning state of the Connectivity Configuration.'''
        return typing.cast(builtins.str, jsii.get(self, "provisioningState"))

    @builtins.property
    @jsii.member(jsii_name="provisioningStateOutput")
    def provisioning_state_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "provisioningStateOutput"))

    @builtins.property
    @jsii.member(jsii_name="resourceName")
    def resource_name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "resourceName"))

    @builtins.property
    @jsii.member(jsii_name="topology")
    def topology(self) -> builtins.str:
        '''Get the connectivity topology type.'''
        return typing.cast(builtins.str, jsii.get(self, "topology"))


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.ConnectivityConfigurationBody",
    jsii_struct_bases=[],
    name_mapping={"properties": "properties"},
)
class ConnectivityConfigurationBody:
    def __init__(
        self,
        *,
        properties: typing.Union[_ConnectivityConfigurationProperties_87ca695a, typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''The resource body interface for Azure Connectivity Configuration API calls.

        :param properties: 
        '''
        if isinstance(properties, dict):
            properties = _ConnectivityConfigurationProperties_87ca695a(**properties)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__32c51cf29761b526ad9e8a1bcb451ace788251bd292bbac46bdd896b3dc5f987)
            check_type(argname="argument properties", value=properties, expected_type=type_hints["properties"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "properties": properties,
        }

    @builtins.property
    def properties(self) -> _ConnectivityConfigurationProperties_87ca695a:
        result = self._values.get("properties")
        assert result is not None, "Required property 'properties' is missing"
        return typing.cast(_ConnectivityConfigurationProperties_87ca695a, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ConnectivityConfigurationBody(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.ConnectivityConfigurationProperties",
    jsii_struct_bases=[],
    name_mapping={
        "applies_to_groups": "appliesToGroups",
        "connectivity_topology": "connectivityTopology",
        "delete_existing_peering": "deleteExistingPeering",
        "description": "description",
        "hubs": "hubs",
        "is_global": "isGlobal",
    },
)
class ConnectivityConfigurationProperties:
    def __init__(
        self,
        *,
        applies_to_groups: typing.Sequence[typing.Union[_ConnectivityGroupItem_d310024f, typing.Dict[builtins.str, typing.Any]]],
        connectivity_topology: builtins.str,
        delete_existing_peering: typing.Optional[builtins.bool] = None,
        description: typing.Optional[builtins.str] = None,
        hubs: typing.Optional[typing.Sequence[typing.Union[_Hub_d4efdd65, typing.Dict[builtins.str, typing.Any]]]] = None,
        is_global: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Properties for Connectivity Configuration body.

        :param applies_to_groups: 
        :param connectivity_topology: 
        :param delete_existing_peering: 
        :param description: 
        :param hubs: 
        :param is_global: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__868c54a4cc2cb6b45f53eb11129356366ce8afe795ffa3503ee6dedcc5b11833)
            check_type(argname="argument applies_to_groups", value=applies_to_groups, expected_type=type_hints["applies_to_groups"])
            check_type(argname="argument connectivity_topology", value=connectivity_topology, expected_type=type_hints["connectivity_topology"])
            check_type(argname="argument delete_existing_peering", value=delete_existing_peering, expected_type=type_hints["delete_existing_peering"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument hubs", value=hubs, expected_type=type_hints["hubs"])
            check_type(argname="argument is_global", value=is_global, expected_type=type_hints["is_global"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "applies_to_groups": applies_to_groups,
            "connectivity_topology": connectivity_topology,
        }
        if delete_existing_peering is not None:
            self._values["delete_existing_peering"] = delete_existing_peering
        if description is not None:
            self._values["description"] = description
        if hubs is not None:
            self._values["hubs"] = hubs
        if is_global is not None:
            self._values["is_global"] = is_global

    @builtins.property
    def applies_to_groups(self) -> typing.List[_ConnectivityGroupItem_d310024f]:
        result = self._values.get("applies_to_groups")
        assert result is not None, "Required property 'applies_to_groups' is missing"
        return typing.cast(typing.List[_ConnectivityGroupItem_d310024f], result)

    @builtins.property
    def connectivity_topology(self) -> builtins.str:
        result = self._values.get("connectivity_topology")
        assert result is not None, "Required property 'connectivity_topology' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def delete_existing_peering(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("delete_existing_peering")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def hubs(self) -> typing.Optional[typing.List[_Hub_d4efdd65]]:
        result = self._values.get("hubs")
        return typing.cast(typing.Optional[typing.List[_Hub_d4efdd65]], result)

    @builtins.property
    def is_global(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("is_global")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ConnectivityConfigurationProperties(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.ConnectivityConfigurationProps",
    jsii_struct_bases=[_AzapiResourceProps_141a2340],
    name_mapping={
        "connection": "connection",
        "count": "count",
        "depends_on": "dependsOn",
        "for_each": "forEach",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "provisioners": "provisioners",
        "api_version": "apiVersion",
        "enable_migration_analysis": "enableMigrationAnalysis",
        "enable_transformation": "enableTransformation",
        "enable_validation": "enableValidation",
        "location": "location",
        "monitoring": "monitoring",
        "name": "name",
        "tags": "tags",
        "applies_to_groups": "appliesToGroups",
        "connectivity_topology": "connectivityTopology",
        "network_manager_id": "networkManagerId",
        "delete_existing_peering": "deleteExistingPeering",
        "description": "description",
        "hubs": "hubs",
        "ignore_changes": "ignoreChanges",
        "is_global": "isGlobal",
    },
)
class ConnectivityConfigurationProps(_AzapiResourceProps_141a2340):
    def __init__(
        self,
        *,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
        api_version: typing.Optional[builtins.str] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        location: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        applies_to_groups: typing.Sequence[typing.Union[_ConnectivityGroupItem_d310024f, typing.Dict[builtins.str, typing.Any]]],
        connectivity_topology: builtins.str,
        network_manager_id: builtins.str,
        delete_existing_peering: typing.Optional[builtins.bool] = None,
        description: typing.Optional[builtins.str] = None,
        hubs: typing.Optional[typing.Sequence[typing.Union[_Hub_d4efdd65, typing.Dict[builtins.str, typing.Any]]]] = None,
        ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
        is_global: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Properties for the Azure Virtual Network Manager Connectivity Configuration.

        Extends AzapiResourceProps with Connectivity Configuration specific properties

        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        :param api_version: Explicit API version to use for this resource. If not specified, the latest active version will be automatically resolved. Use this for version pinning when stability is required over latest features. Default: Latest active version from ApiVersionManager
        :param enable_migration_analysis: Whether to enable migration analysis warnings. When true, the framework will analyze the current version for deprecation status and provide migration recommendations in the deployment output. Default: true
        :param enable_transformation: Whether to apply property transformations automatically. When true, properties will be automatically transformed according to the target schema's transformation rules. This enables backward compatibility. Default: true
        :param enable_validation: Whether to validate properties against the schema. When true, all properties will be validated against the API schema before resource creation. Validation errors will cause deployment failures. Default: true
        :param location: The location where the resource should be created. Default: Varies by resource type - see specific resource documentation
        :param monitoring: Monitoring configuration for this resource. Enables integrated monitoring with diagnostic settings, metric alerts, and activity log alerts. All monitoring is optional and disabled by default.
        :param name: The name of the resource.
        :param tags: Tags to apply to the resource.
        :param applies_to_groups: Network groups to apply this configuration to Each item specifies a network group and how it should connect.
        :param connectivity_topology: Connectivity topology type - HubAndSpoke: Central hub with spoke VNets - Mesh: All VNets can communicate directly.
        :param network_manager_id: Resource ID of the parent Network Manager.
        :param delete_existing_peering: Delete existing peerings when applying this configuration. Default: false
        :param description: Optional description of the connectivity configuration.
        :param hubs: Hub VNets for hub-and-spoke topology Required when connectivityTopology is "HubAndSpoke".
        :param ignore_changes: The lifecycle rules to ignore changes.
        :param is_global: Enable global mesh connectivity Allows mesh connectivity across regions. Default: false
        '''
        if isinstance(lifecycle, dict):
            lifecycle = _cdktf_9a9027ec.TerraformResourceLifecycle(**lifecycle)
        if isinstance(monitoring, dict):
            monitoring = _MonitoringConfig_7c28df74(**monitoring)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e8751f6e357e5fde8ef0a95f373d72e5bba216bde94d30235bbd73e60264acb7)
            check_type(argname="argument connection", value=connection, expected_type=type_hints["connection"])
            check_type(argname="argument count", value=count, expected_type=type_hints["count"])
            check_type(argname="argument depends_on", value=depends_on, expected_type=type_hints["depends_on"])
            check_type(argname="argument for_each", value=for_each, expected_type=type_hints["for_each"])
            check_type(argname="argument lifecycle", value=lifecycle, expected_type=type_hints["lifecycle"])
            check_type(argname="argument provider", value=provider, expected_type=type_hints["provider"])
            check_type(argname="argument provisioners", value=provisioners, expected_type=type_hints["provisioners"])
            check_type(argname="argument api_version", value=api_version, expected_type=type_hints["api_version"])
            check_type(argname="argument enable_migration_analysis", value=enable_migration_analysis, expected_type=type_hints["enable_migration_analysis"])
            check_type(argname="argument enable_transformation", value=enable_transformation, expected_type=type_hints["enable_transformation"])
            check_type(argname="argument enable_validation", value=enable_validation, expected_type=type_hints["enable_validation"])
            check_type(argname="argument location", value=location, expected_type=type_hints["location"])
            check_type(argname="argument monitoring", value=monitoring, expected_type=type_hints["monitoring"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument applies_to_groups", value=applies_to_groups, expected_type=type_hints["applies_to_groups"])
            check_type(argname="argument connectivity_topology", value=connectivity_topology, expected_type=type_hints["connectivity_topology"])
            check_type(argname="argument network_manager_id", value=network_manager_id, expected_type=type_hints["network_manager_id"])
            check_type(argname="argument delete_existing_peering", value=delete_existing_peering, expected_type=type_hints["delete_existing_peering"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument hubs", value=hubs, expected_type=type_hints["hubs"])
            check_type(argname="argument ignore_changes", value=ignore_changes, expected_type=type_hints["ignore_changes"])
            check_type(argname="argument is_global", value=is_global, expected_type=type_hints["is_global"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "applies_to_groups": applies_to_groups,
            "connectivity_topology": connectivity_topology,
            "network_manager_id": network_manager_id,
        }
        if connection is not None:
            self._values["connection"] = connection
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if for_each is not None:
            self._values["for_each"] = for_each
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider
        if provisioners is not None:
            self._values["provisioners"] = provisioners
        if api_version is not None:
            self._values["api_version"] = api_version
        if enable_migration_analysis is not None:
            self._values["enable_migration_analysis"] = enable_migration_analysis
        if enable_transformation is not None:
            self._values["enable_transformation"] = enable_transformation
        if enable_validation is not None:
            self._values["enable_validation"] = enable_validation
        if location is not None:
            self._values["location"] = location
        if monitoring is not None:
            self._values["monitoring"] = monitoring
        if name is not None:
            self._values["name"] = name
        if tags is not None:
            self._values["tags"] = tags
        if delete_existing_peering is not None:
            self._values["delete_existing_peering"] = delete_existing_peering
        if description is not None:
            self._values["description"] = description
        if hubs is not None:
            self._values["hubs"] = hubs
        if ignore_changes is not None:
            self._values["ignore_changes"] = ignore_changes
        if is_global is not None:
            self._values["is_global"] = is_global

    @builtins.property
    def connection(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("connection")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]], result)

    @builtins.property
    def count(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]], result)

    @builtins.property
    def depends_on(
        self,
    ) -> typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]], result)

    @builtins.property
    def for_each(self) -> typing.Optional[_cdktf_9a9027ec.ITerraformIterator]:
        '''
        :stability: experimental
        '''
        result = self._values.get("for_each")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.ITerraformIterator], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[_cdktf_9a9027ec.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformProvider], result)

    @builtins.property
    def provisioners(
        self,
    ) -> typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provisioners")
        return typing.cast(typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]], result)

    @builtins.property
    def api_version(self) -> typing.Optional[builtins.str]:
        '''Explicit API version to use for this resource.

        If not specified, the latest active version will be automatically resolved.
        Use this for version pinning when stability is required over latest features.

        :default: Latest active version from ApiVersionManager

        Example::

            "2024-11-01"
        '''
        result = self._values.get("api_version")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def enable_migration_analysis(self) -> typing.Optional[builtins.bool]:
        '''Whether to enable migration analysis warnings.

        When true, the framework will analyze the current version for deprecation
        status and provide migration recommendations in the deployment output.

        :default: true
        '''
        result = self._values.get("enable_migration_analysis")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_transformation(self) -> typing.Optional[builtins.bool]:
        '''Whether to apply property transformations automatically.

        When true, properties will be automatically transformed according to the
        target schema's transformation rules. This enables backward compatibility.

        :default: true
        '''
        result = self._values.get("enable_transformation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_validation(self) -> typing.Optional[builtins.bool]:
        '''Whether to validate properties against the schema.

        When true, all properties will be validated against the API schema before
        resource creation. Validation errors will cause deployment failures.

        :default: true
        '''
        result = self._values.get("enable_validation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def location(self) -> typing.Optional[builtins.str]:
        '''The location where the resource should be created.

        :default: Varies by resource type - see specific resource documentation

        :remarks:

        Location handling varies by resource type:

        - **Top-level resources**: Most require an explicit location (e.g., "eastus", "westus")
        - **Global resources**: Some use "global" as location (e.g., Private DNS Zones)
        - **Child resources**: Inherit location from parent and should NOT set this property

        Each resource type may provide its own default through the ``resolveLocation()`` method.
        If no location is specified and no default exists, resource creation may fail.

        Example::

            // Child resource (Subnet) - do not set location
            // location: undefined (inherited from parent Virtual Network)
        '''
        result = self._values.get("location")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def monitoring(self) -> typing.Optional[_MonitoringConfig_7c28df74]:
        '''Monitoring configuration for this resource.

        Enables integrated monitoring with diagnostic settings, metric alerts,
        and activity log alerts. All monitoring is optional and disabled by default.

        Example::

            monitoring: {
              enabled: true,
              diagnosticSettings: {
                workspaceId: logAnalytics.id,
                metrics: ['AllMetrics'],
                logs: ['AuditLogs']
              },
              metricAlerts: [{
                name: 'high-cpu-alert',
                severity: 2,
                scopes: [], // Automatically set to this resource
                criteria: { ... },
                actions: [{ actionGroupId: actionGroup.id }]
              }]
            }
        '''
        result = self._values.get("monitoring")
        return typing.cast(typing.Optional[_MonitoringConfig_7c28df74], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the resource.'''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Tags to apply to the resource.'''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def applies_to_groups(self) -> typing.List[_ConnectivityGroupItem_d310024f]:
        '''Network groups to apply this configuration to Each item specifies a network group and how it should connect.'''
        result = self._values.get("applies_to_groups")
        assert result is not None, "Required property 'applies_to_groups' is missing"
        return typing.cast(typing.List[_ConnectivityGroupItem_d310024f], result)

    @builtins.property
    def connectivity_topology(self) -> builtins.str:
        '''Connectivity topology type - HubAndSpoke: Central hub with spoke VNets - Mesh: All VNets can communicate directly.

        Example::

            "Mesh"
        '''
        result = self._values.get("connectivity_topology")
        assert result is not None, "Required property 'connectivity_topology' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def network_manager_id(self) -> builtins.str:
        '''Resource ID of the parent Network Manager.

        Example::

            "/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/rg/providers/Microsoft.Network/networkManagers/vnm"
        '''
        result = self._values.get("network_manager_id")
        assert result is not None, "Required property 'network_manager_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def delete_existing_peering(self) -> typing.Optional[builtins.bool]:
        '''Delete existing peerings when applying this configuration.

        :default: false
        '''
        result = self._values.get("delete_existing_peering")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''Optional description of the connectivity configuration.

        Example::

            "Hub-and-spoke topology for production workloads"
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def hubs(self) -> typing.Optional[typing.List[_Hub_d4efdd65]]:
        '''Hub VNets for hub-and-spoke topology Required when connectivityTopology is "HubAndSpoke".

        Example::

            [{ resourceId: "/subscriptions/.../virtualNetworks/hub-vnet", resourceType: "Microsoft.Network/virtualNetworks" }]
        '''
        result = self._values.get("hubs")
        return typing.cast(typing.Optional[typing.List[_Hub_d4efdd65]], result)

    @builtins.property
    def ignore_changes(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The lifecycle rules to ignore changes.

        Example::

            ["tags"]
        '''
        result = self._values.get("ignore_changes")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def is_global(self) -> typing.Optional[builtins.bool]:
        '''Enable global mesh connectivity Allows mesh connectivity across regions.

        :default: false
        '''
        result = self._values.get("is_global")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ConnectivityConfigurationProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.ConnectivityGroupItem",
    jsii_struct_bases=[],
    name_mapping={
        "network_group_id": "networkGroupId",
        "group_connectivity": "groupConnectivity",
        "is_global": "isGlobal",
        "use_hub_gateway": "useHubGateway",
    },
)
class ConnectivityGroupItem:
    def __init__(
        self,
        *,
        network_group_id: builtins.str,
        group_connectivity: typing.Optional[builtins.str] = None,
        is_global: typing.Optional[builtins.bool] = None,
        use_hub_gateway: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Network group reference for connectivity configuration.

        :param network_group_id: 
        :param group_connectivity: 
        :param is_global: 
        :param use_hub_gateway: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bca2000a633d7e43296ca48227153c939b0cd1b0978ddee28633518123f8dad7)
            check_type(argname="argument network_group_id", value=network_group_id, expected_type=type_hints["network_group_id"])
            check_type(argname="argument group_connectivity", value=group_connectivity, expected_type=type_hints["group_connectivity"])
            check_type(argname="argument is_global", value=is_global, expected_type=type_hints["is_global"])
            check_type(argname="argument use_hub_gateway", value=use_hub_gateway, expected_type=type_hints["use_hub_gateway"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "network_group_id": network_group_id,
        }
        if group_connectivity is not None:
            self._values["group_connectivity"] = group_connectivity
        if is_global is not None:
            self._values["is_global"] = is_global
        if use_hub_gateway is not None:
            self._values["use_hub_gateway"] = use_hub_gateway

    @builtins.property
    def network_group_id(self) -> builtins.str:
        result = self._values.get("network_group_id")
        assert result is not None, "Required property 'network_group_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def group_connectivity(self) -> typing.Optional[builtins.str]:
        result = self._values.get("group_connectivity")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def is_global(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("is_global")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def use_hub_gateway(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("use_hub_gateway")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ConnectivityGroupItem(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DataAzapiClientConfig(
    _cdktf_9a9027ec.TerraformDataSource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@microsoft/terraform-cdk-constructs.DataAzapiClientConfig",
):
    '''Represents a {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/data-sources/client_config azapi_client_config}.'''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        timeouts: typing.Optional[typing.Union["DataAzapiClientConfigTimeouts", typing.Dict[builtins.str, typing.Any]]] = None,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> None:
        '''Create a new {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/data-sources/client_config azapi_client_config} Data Source.

        :param scope: The scope in which to define this construct.
        :param id: The scoped construct ID. Must be unique amongst siblings in the same scope
        :param timeouts: timeouts block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/data-sources/client_config#timeouts DataAzapiClientConfig#timeouts}
        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__34f4021e722333d7f25f2e4702396e5276828ffb21525238dd3c45563e02b6a3)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        config = DataAzapiClientConfigConfig(
            timeouts=timeouts,
            connection=connection,
            count=count,
            depends_on=depends_on,
            for_each=for_each,
            lifecycle=lifecycle,
            provider=provider,
            provisioners=provisioners,
        )

        jsii.create(self.__class__, self, [scope, id, config])

    @jsii.member(jsii_name="generateConfigForImport")
    @builtins.classmethod
    def generate_config_for_import(
        cls,
        scope: _constructs_77d1e7e8.Construct,
        import_to_id: builtins.str,
        import_from_id: builtins.str,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    ) -> _cdktf_9a9027ec.ImportableResource:
        '''Generates CDKTF code for importing a DataAzapiClientConfig resource upon running "cdktf plan ".

        :param scope: The scope in which to define this construct.
        :param import_to_id: The construct id used in the generated config for the DataAzapiClientConfig to import.
        :param import_from_id: The id of the existing DataAzapiClientConfig that should be imported. Refer to the {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/data-sources/client_config#import import section} in the documentation of this resource for the id to use
        :param provider: ? Optional instance of the provider where the DataAzapiClientConfig to import is found.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f43f7445d243271bb445d650158c0a6cd22ba9fd8ea9970670f0cea11d5394fc)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument import_to_id", value=import_to_id, expected_type=type_hints["import_to_id"])
            check_type(argname="argument import_from_id", value=import_from_id, expected_type=type_hints["import_from_id"])
            check_type(argname="argument provider", value=provider, expected_type=type_hints["provider"])
        return typing.cast(_cdktf_9a9027ec.ImportableResource, jsii.sinvoke(cls, "generateConfigForImport", [scope, import_to_id, import_from_id, provider]))

    @jsii.member(jsii_name="putTimeouts")
    def put_timeouts(self, *, read: typing.Optional[builtins.str] = None) -> None:
        '''
        :param read: A string that can be `parsed as a duration <https://pkg.go.dev/time#ParseDuration>`_ consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/data-sources/client_config#read DataAzapiClientConfig#read}
        '''
        value = DataAzapiClientConfigTimeouts(read=read)

        return typing.cast(None, jsii.invoke(self, "putTimeouts", [value]))

    @jsii.member(jsii_name="resetTimeouts")
    def reset_timeouts(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTimeouts", []))

    @jsii.member(jsii_name="synthesizeAttributes")
    def _synthesize_attributes(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "synthesizeAttributes", []))

    @jsii.member(jsii_name="synthesizeHclAttributes")
    def _synthesize_hcl_attributes(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "synthesizeHclAttributes", []))

    @jsii.python.classproperty
    @jsii.member(jsii_name="tfResourceType")
    def TF_RESOURCE_TYPE(cls) -> builtins.str:
        return typing.cast(builtins.str, jsii.sget(cls, "tfResourceType"))

    @builtins.property
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @builtins.property
    @jsii.member(jsii_name="objectId")
    def object_id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "objectId"))

    @builtins.property
    @jsii.member(jsii_name="subscriptionId")
    def subscription_id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "subscriptionId"))

    @builtins.property
    @jsii.member(jsii_name="subscriptionResourceId")
    def subscription_resource_id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "subscriptionResourceId"))

    @builtins.property
    @jsii.member(jsii_name="tenantId")
    def tenant_id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "tenantId"))

    @builtins.property
    @jsii.member(jsii_name="timeouts")
    def timeouts(self) -> "DataAzapiClientConfigTimeoutsOutputReference":
        return typing.cast("DataAzapiClientConfigTimeoutsOutputReference", jsii.get(self, "timeouts"))

    @builtins.property
    @jsii.member(jsii_name="timeoutsInput")
    def timeouts_input(
        self,
    ) -> typing.Optional[typing.Union["DataAzapiClientConfigTimeouts", _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union["DataAzapiClientConfigTimeouts", _cdktf_9a9027ec.IResolvable]], jsii.get(self, "timeoutsInput"))


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.DataAzapiClientConfigConfig",
    jsii_struct_bases=[_cdktf_9a9027ec.TerraformMetaArguments],
    name_mapping={
        "connection": "connection",
        "count": "count",
        "depends_on": "dependsOn",
        "for_each": "forEach",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "provisioners": "provisioners",
        "timeouts": "timeouts",
    },
)
class DataAzapiClientConfigConfig(_cdktf_9a9027ec.TerraformMetaArguments):
    def __init__(
        self,
        *,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
        timeouts: typing.Optional[typing.Union["DataAzapiClientConfigTimeouts", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        :param timeouts: timeouts block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/data-sources/client_config#timeouts DataAzapiClientConfig#timeouts}
        '''
        if isinstance(lifecycle, dict):
            lifecycle = _cdktf_9a9027ec.TerraformResourceLifecycle(**lifecycle)
        if isinstance(timeouts, dict):
            timeouts = DataAzapiClientConfigTimeouts(**timeouts)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3c9f620c2016730f9330066fb5a51d70a38250d6e21a8b8f1ce23836d805be79)
            check_type(argname="argument connection", value=connection, expected_type=type_hints["connection"])
            check_type(argname="argument count", value=count, expected_type=type_hints["count"])
            check_type(argname="argument depends_on", value=depends_on, expected_type=type_hints["depends_on"])
            check_type(argname="argument for_each", value=for_each, expected_type=type_hints["for_each"])
            check_type(argname="argument lifecycle", value=lifecycle, expected_type=type_hints["lifecycle"])
            check_type(argname="argument provider", value=provider, expected_type=type_hints["provider"])
            check_type(argname="argument provisioners", value=provisioners, expected_type=type_hints["provisioners"])
            check_type(argname="argument timeouts", value=timeouts, expected_type=type_hints["timeouts"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if connection is not None:
            self._values["connection"] = connection
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if for_each is not None:
            self._values["for_each"] = for_each
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider
        if provisioners is not None:
            self._values["provisioners"] = provisioners
        if timeouts is not None:
            self._values["timeouts"] = timeouts

    @builtins.property
    def connection(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("connection")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]], result)

    @builtins.property
    def count(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]], result)

    @builtins.property
    def depends_on(
        self,
    ) -> typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]], result)

    @builtins.property
    def for_each(self) -> typing.Optional[_cdktf_9a9027ec.ITerraformIterator]:
        '''
        :stability: experimental
        '''
        result = self._values.get("for_each")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.ITerraformIterator], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[_cdktf_9a9027ec.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformProvider], result)

    @builtins.property
    def provisioners(
        self,
    ) -> typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provisioners")
        return typing.cast(typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]], result)

    @builtins.property
    def timeouts(self) -> typing.Optional["DataAzapiClientConfigTimeouts"]:
        '''timeouts block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/data-sources/client_config#timeouts DataAzapiClientConfig#timeouts}
        '''
        result = self._values.get("timeouts")
        return typing.cast(typing.Optional["DataAzapiClientConfigTimeouts"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DataAzapiClientConfigConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.DataAzapiClientConfigTimeouts",
    jsii_struct_bases=[],
    name_mapping={"read": "read"},
)
class DataAzapiClientConfigTimeouts:
    def __init__(self, *, read: typing.Optional[builtins.str] = None) -> None:
        '''
        :param read: A string that can be `parsed as a duration <https://pkg.go.dev/time#ParseDuration>`_ consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/data-sources/client_config#read DataAzapiClientConfig#read}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__559899a120c7542a83bac439c0c3f3d9e28ae76e687898d3d992b6f5b929a74d)
            check_type(argname="argument read", value=read, expected_type=type_hints["read"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if read is not None:
            self._values["read"] = read

    @builtins.property
    def read(self) -> typing.Optional[builtins.str]:
        '''A string that can be `parsed as a duration <https://pkg.go.dev/time#ParseDuration>`_ consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/data-sources/client_config#read DataAzapiClientConfig#read}
        '''
        result = self._values.get("read")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DataAzapiClientConfigTimeouts(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DataAzapiClientConfigTimeoutsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@microsoft/terraform-cdk-constructs.DataAzapiClientConfigTimeoutsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__74702f390141f764fdf6ec8eb155f7eb2c824e59e3b141fa3196ed4a5350f0c7)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetRead")
    def reset_read(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRead", []))

    @builtins.property
    @jsii.member(jsii_name="readInput")
    def read_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "readInput"))

    @builtins.property
    @jsii.member(jsii_name="read")
    def read(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "read"))

    @read.setter
    def read(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__63da91f92c12e34f842a43a27ea2bc2c2c3df1463eb79efb44c1003d8e44ce93)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "read", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[DataAzapiClientConfigTimeouts, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[DataAzapiClientConfigTimeouts, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[DataAzapiClientConfigTimeouts, _cdktf_9a9027ec.IResolvable]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__58c110e2e7a2d356e44dd596702a266c4aaf9a93226e8ed3699bf16cf421ad08)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class DataAzapiResource(
    _cdktf_9a9027ec.TerraformDataSource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@microsoft/terraform-cdk-constructs.DataAzapiResource",
):
    '''Represents a {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/data-sources/resource azapi_resource}.'''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        type: builtins.str,
        headers: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        ignore_not_found: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        name: typing.Optional[builtins.str] = None,
        parent_id: typing.Optional[builtins.str] = None,
        query_parameters: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.Sequence[builtins.str]]]] = None,
        resource_id: typing.Optional[builtins.str] = None,
        response_export_values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        retry: typing.Optional[typing.Union["DataAzapiResourceRetry", typing.Dict[builtins.str, typing.Any]]] = None,
        timeouts: typing.Optional[typing.Union["DataAzapiResourceTimeouts", typing.Dict[builtins.str, typing.Any]]] = None,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> None:
        '''Create a new {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/data-sources/resource azapi_resource} Data Source.

        :param scope: The scope in which to define this construct.
        :param id: The scoped construct ID. Must be unique amongst siblings in the same scope
        :param type: In a format like ``<resource-type>@<api-version>``. ``<resource-type>`` is the Azure resource type, for example, ``Microsoft.Storage/storageAccounts``. ``<api-version>`` is version of the API used to manage this azure resource. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/data-sources/resource#type DataAzapiResource#type}
        :param headers: A map of headers to include in the request. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/data-sources/resource#headers DataAzapiResource#headers}
        :param ignore_not_found: If set to ``true``, the data source will not fail when the specified resource is not found (HTTP 404). Identifier attributes (``id``, ``name``, ``parent_id``, ``resource_id``) will still be populated based on inputs; other computed attributes (``output``, ``location``, ``identity``, ``tags``) will be null/empty. Defaults to ``false``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/data-sources/resource#ignore_not_found DataAzapiResource#ignore_not_found}
        :param name: Specifies the name of the Azure resource. Exactly one of the arguments ``name`` or ``resource_id`` must be set. It could be omitted if the ``type`` is ``Microsoft.Resources/subscriptions``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/data-sources/resource#name DataAzapiResource#name}
        :param parent_id: The ID of the azure resource in which this resource is created. It supports different kinds of deployment scope for **top level** resources: - resource group scope: ``parent_id`` should be the ID of a resource group, it's recommended to manage a resource group by azurerm_resource_group. - management group scope: ``parent_id`` should be the ID of a management group, it's recommended to manage a management group by azurerm_management_group. - extension scope: ``parent_id`` should be the ID of the resource you're adding the extension to. - subscription scope: ``parent_id`` should be like \\x60/subscriptions/00000000-0000-0000-0000-000000000000\\x60 - tenant scope: ``parent_id`` should be / For child level resources, the ``parent_id`` should be the ID of its parent resource, for example, subnet resource's ``parent_id`` is the ID of the vnet. For type ``Microsoft.Resources/resourceGroups``, the ``parent_id`` could be omitted, it defaults to subscription ID specified in provider or the default subscription (You could check the default subscription by azure cli command: ``az account show``). Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/data-sources/resource#parent_id DataAzapiResource#parent_id}
        :param query_parameters: A map of query parameters to include in the request. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/data-sources/resource#query_parameters DataAzapiResource#query_parameters}
        :param resource_id: The ID of the Azure resource to retrieve. Exactly one of the arguments ``name`` or ``resource_id`` must be set. It could be omitted if the ``type`` is ``Microsoft.Resources/subscriptions``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/data-sources/resource#resource_id DataAzapiResource#resource_id}
        :param response_export_values: The attribute can accept either a list or a map. - **List**: A list of paths that need to be exported from the response body. Setting it to ``["*"]`` will export the full response body. Here's an example. If it sets to ``["properties.loginServer", "properties.policies.quarantinePolicy.status"]``, it will set the following HCL object to the computed property output:: { properties = { loginServer = "registry1.azurecr.io" policies = { quarantinePolicy = { status = "disabled" } } } } - **Map**: A map where the key is the name for the result and the value is a JMESPath query string to filter the response. Here's an example. If it sets to ``{"login_server": "properties.loginServer", "quarantine_status": "properties.policies.quarantinePolicy.status"}``, it will set the following HCL object to the computed property output:: { "login_server" = "registry1.azurecr.io" "quarantine_status" = "disabled" } To learn more about JMESPath, visit `JMESPath <https://jmespath.org/>`_. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/data-sources/resource#response_export_values DataAzapiResource#response_export_values}
        :param retry: The retry object supports the following attributes:. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/data-sources/resource#retry DataAzapiResource#retry}
        :param timeouts: timeouts block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/data-sources/resource#timeouts DataAzapiResource#timeouts}
        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c7adc2f8d37c7c562f56758085ff1ec8beb6d7c11a4cfcb4d36e46f4146dda82)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        config = DataAzapiResourceConfig(
            type=type,
            headers=headers,
            ignore_not_found=ignore_not_found,
            name=name,
            parent_id=parent_id,
            query_parameters=query_parameters,
            resource_id=resource_id,
            response_export_values=response_export_values,
            retry=retry,
            timeouts=timeouts,
            connection=connection,
            count=count,
            depends_on=depends_on,
            for_each=for_each,
            lifecycle=lifecycle,
            provider=provider,
            provisioners=provisioners,
        )

        jsii.create(self.__class__, self, [scope, id, config])

    @jsii.member(jsii_name="generateConfigForImport")
    @builtins.classmethod
    def generate_config_for_import(
        cls,
        scope: _constructs_77d1e7e8.Construct,
        import_to_id: builtins.str,
        import_from_id: builtins.str,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    ) -> _cdktf_9a9027ec.ImportableResource:
        '''Generates CDKTF code for importing a DataAzapiResource resource upon running "cdktf plan ".

        :param scope: The scope in which to define this construct.
        :param import_to_id: The construct id used in the generated config for the DataAzapiResource to import.
        :param import_from_id: The id of the existing DataAzapiResource that should be imported. Refer to the {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/data-sources/resource#import import section} in the documentation of this resource for the id to use
        :param provider: ? Optional instance of the provider where the DataAzapiResource to import is found.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d4c438be36fd54e6c7c284316721e6699fe2e8e9bbba08d512fe1507a1049fef)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument import_to_id", value=import_to_id, expected_type=type_hints["import_to_id"])
            check_type(argname="argument import_from_id", value=import_from_id, expected_type=type_hints["import_from_id"])
            check_type(argname="argument provider", value=provider, expected_type=type_hints["provider"])
        return typing.cast(_cdktf_9a9027ec.ImportableResource, jsii.sinvoke(cls, "generateConfigForImport", [scope, import_to_id, import_from_id, provider]))

    @jsii.member(jsii_name="putRetry")
    def put_retry(
        self,
        *,
        error_message_regex: typing.Sequence[builtins.str],
        interval_seconds: typing.Optional[jsii.Number] = None,
        max_interval_seconds: typing.Optional[jsii.Number] = None,
        multiplier: typing.Optional[jsii.Number] = None,
        randomization_factor: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param error_message_regex: A list of regular expressions to match against error messages. If any of the regular expressions match, the request will be retried. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/data-sources/resource#error_message_regex DataAzapiResource#error_message_regex}
        :param interval_seconds: The base number of seconds to wait between retries. Default is ``10``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/data-sources/resource#interval_seconds DataAzapiResource#interval_seconds}
        :param max_interval_seconds: The maximum number of seconds to wait between retries. Default is ``180``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/data-sources/resource#max_interval_seconds DataAzapiResource#max_interval_seconds}
        :param multiplier: The multiplier to apply to the interval between retries. Default is ``1.5``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/data-sources/resource#multiplier DataAzapiResource#multiplier}
        :param randomization_factor: The randomization factor to apply to the interval between retries. The formula for the randomized interval is: ``RetryInterval * (random value in range [1 - RandomizationFactor, 1 + RandomizationFactor])``. Therefore set to zero ``0.0`` for no randomization. Default is ``0.5``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/data-sources/resource#randomization_factor DataAzapiResource#randomization_factor}
        '''
        value = DataAzapiResourceRetry(
            error_message_regex=error_message_regex,
            interval_seconds=interval_seconds,
            max_interval_seconds=max_interval_seconds,
            multiplier=multiplier,
            randomization_factor=randomization_factor,
        )

        return typing.cast(None, jsii.invoke(self, "putRetry", [value]))

    @jsii.member(jsii_name="putTimeouts")
    def put_timeouts(self, *, read: typing.Optional[builtins.str] = None) -> None:
        '''
        :param read: A string that can be `parsed as a duration <https://pkg.go.dev/time#ParseDuration>`_ consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/data-sources/resource#read DataAzapiResource#read}
        '''
        value = DataAzapiResourceTimeouts(read=read)

        return typing.cast(None, jsii.invoke(self, "putTimeouts", [value]))

    @jsii.member(jsii_name="resetHeaders")
    def reset_headers(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetHeaders", []))

    @jsii.member(jsii_name="resetIgnoreNotFound")
    def reset_ignore_not_found(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetIgnoreNotFound", []))

    @jsii.member(jsii_name="resetName")
    def reset_name(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetName", []))

    @jsii.member(jsii_name="resetParentId")
    def reset_parent_id(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetParentId", []))

    @jsii.member(jsii_name="resetQueryParameters")
    def reset_query_parameters(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetQueryParameters", []))

    @jsii.member(jsii_name="resetResourceId")
    def reset_resource_id(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetResourceId", []))

    @jsii.member(jsii_name="resetResponseExportValues")
    def reset_response_export_values(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetResponseExportValues", []))

    @jsii.member(jsii_name="resetRetry")
    def reset_retry(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRetry", []))

    @jsii.member(jsii_name="resetTimeouts")
    def reset_timeouts(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTimeouts", []))

    @jsii.member(jsii_name="synthesizeAttributes")
    def _synthesize_attributes(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "synthesizeAttributes", []))

    @jsii.member(jsii_name="synthesizeHclAttributes")
    def _synthesize_hcl_attributes(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "synthesizeHclAttributes", []))

    @jsii.python.classproperty
    @jsii.member(jsii_name="tfResourceType")
    def TF_RESOURCE_TYPE(cls) -> builtins.str:
        return typing.cast(builtins.str, jsii.sget(cls, "tfResourceType"))

    @builtins.property
    @jsii.member(jsii_name="exists")
    def exists(self) -> _cdktf_9a9027ec.IResolvable:
        return typing.cast(_cdktf_9a9027ec.IResolvable, jsii.get(self, "exists"))

    @builtins.property
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @builtins.property
    @jsii.member(jsii_name="identity")
    def identity(self) -> "DataAzapiResourceIdentityList":
        return typing.cast("DataAzapiResourceIdentityList", jsii.get(self, "identity"))

    @builtins.property
    @jsii.member(jsii_name="location")
    def location(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "location"))

    @builtins.property
    @jsii.member(jsii_name="output")
    def output(self) -> _cdktf_9a9027ec.AnyMap:
        return typing.cast(_cdktf_9a9027ec.AnyMap, jsii.get(self, "output"))

    @builtins.property
    @jsii.member(jsii_name="retry")
    def retry(self) -> "DataAzapiResourceRetryOutputReference":
        return typing.cast("DataAzapiResourceRetryOutputReference", jsii.get(self, "retry"))

    @builtins.property
    @jsii.member(jsii_name="tags")
    def tags(self) -> _cdktf_9a9027ec.StringMap:
        return typing.cast(_cdktf_9a9027ec.StringMap, jsii.get(self, "tags"))

    @builtins.property
    @jsii.member(jsii_name="timeouts")
    def timeouts(self) -> "DataAzapiResourceTimeoutsOutputReference":
        return typing.cast("DataAzapiResourceTimeoutsOutputReference", jsii.get(self, "timeouts"))

    @builtins.property
    @jsii.member(jsii_name="headersInput")
    def headers_input(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], jsii.get(self, "headersInput"))

    @builtins.property
    @jsii.member(jsii_name="ignoreNotFoundInput")
    def ignore_not_found_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "ignoreNotFoundInput"))

    @builtins.property
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nameInput"))

    @builtins.property
    @jsii.member(jsii_name="parentIdInput")
    def parent_id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "parentIdInput"))

    @builtins.property
    @jsii.member(jsii_name="queryParametersInput")
    def query_parameters_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.List[builtins.str]]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.List[builtins.str]]]], jsii.get(self, "queryParametersInput"))

    @builtins.property
    @jsii.member(jsii_name="resourceIdInput")
    def resource_id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "resourceIdInput"))

    @builtins.property
    @jsii.member(jsii_name="responseExportValuesInput")
    def response_export_values_input(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], jsii.get(self, "responseExportValuesInput"))

    @builtins.property
    @jsii.member(jsii_name="retryInput")
    def retry_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, "DataAzapiResourceRetry"]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, "DataAzapiResourceRetry"]], jsii.get(self, "retryInput"))

    @builtins.property
    @jsii.member(jsii_name="timeoutsInput")
    def timeouts_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, "DataAzapiResourceTimeouts"]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, "DataAzapiResourceTimeouts"]], jsii.get(self, "timeoutsInput"))

    @builtins.property
    @jsii.member(jsii_name="typeInput")
    def type_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "typeInput"))

    @builtins.property
    @jsii.member(jsii_name="headers")
    def headers(self) -> typing.Mapping[builtins.str, builtins.str]:
        return typing.cast(typing.Mapping[builtins.str, builtins.str], jsii.get(self, "headers"))

    @headers.setter
    def headers(self, value: typing.Mapping[builtins.str, builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__532d97aa870529660c4bb38e18637d27a329afd791f69324d29e8c23918feacc)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "headers", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="ignoreNotFound")
    def ignore_not_found(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "ignoreNotFound"))

    @ignore_not_found.setter
    def ignore_not_found(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7c7b6ba90e6525a0888421f65f18cd2160c9ab5bffd8b8ae5840becb3d9c3e33)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "ignoreNotFound", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a49f04a156217b464936ec6285683f722fe2e88d24de4855728301de3368faf2)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "name", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="parentId")
    def parent_id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "parentId"))

    @parent_id.setter
    def parent_id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__33be1f50f28912350c4a22da8b162035af549991b54c487195c8fdb4960586f5)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "parentId", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="queryParameters")
    def query_parameters(
        self,
    ) -> typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.List[builtins.str]]]:
        return typing.cast(typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.List[builtins.str]]], jsii.get(self, "queryParameters"))

    @query_parameters.setter
    def query_parameters(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.List[builtins.str]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0b491d5f9a457e87acb9042e9b853667cbeb9fb2cd21cecef5065a2fb4e71ea7)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "queryParameters", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="resourceId")
    def resource_id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "resourceId"))

    @resource_id.setter
    def resource_id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__356cd5f181512a85cfff66fa3db791df26401c7b2d626de6392f2519ff9c557a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "resourceId", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="responseExportValues")
    def response_export_values(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "responseExportValues"))

    @response_export_values.setter
    def response_export_values(
        self,
        value: typing.Mapping[builtins.str, typing.Any],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f9c01a34e566c6937403b0fafb4a100e3abbcc1db069dd1caf8e855db42bdef5)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "responseExportValues", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="type")
    def type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "type"))

    @type.setter
    def type(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__47046806ff469369bcac6d1865435c667e47641d7c3204ae81407a1285900fdd)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "type", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.DataAzapiResourceConfig",
    jsii_struct_bases=[_cdktf_9a9027ec.TerraformMetaArguments],
    name_mapping={
        "connection": "connection",
        "count": "count",
        "depends_on": "dependsOn",
        "for_each": "forEach",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "provisioners": "provisioners",
        "type": "type",
        "headers": "headers",
        "ignore_not_found": "ignoreNotFound",
        "name": "name",
        "parent_id": "parentId",
        "query_parameters": "queryParameters",
        "resource_id": "resourceId",
        "response_export_values": "responseExportValues",
        "retry": "retry",
        "timeouts": "timeouts",
    },
)
class DataAzapiResourceConfig(_cdktf_9a9027ec.TerraformMetaArguments):
    def __init__(
        self,
        *,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
        type: builtins.str,
        headers: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        ignore_not_found: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        name: typing.Optional[builtins.str] = None,
        parent_id: typing.Optional[builtins.str] = None,
        query_parameters: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.Sequence[builtins.str]]]] = None,
        resource_id: typing.Optional[builtins.str] = None,
        response_export_values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        retry: typing.Optional[typing.Union["DataAzapiResourceRetry", typing.Dict[builtins.str, typing.Any]]] = None,
        timeouts: typing.Optional[typing.Union["DataAzapiResourceTimeouts", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        :param type: In a format like ``<resource-type>@<api-version>``. ``<resource-type>`` is the Azure resource type, for example, ``Microsoft.Storage/storageAccounts``. ``<api-version>`` is version of the API used to manage this azure resource. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/data-sources/resource#type DataAzapiResource#type}
        :param headers: A map of headers to include in the request. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/data-sources/resource#headers DataAzapiResource#headers}
        :param ignore_not_found: If set to ``true``, the data source will not fail when the specified resource is not found (HTTP 404). Identifier attributes (``id``, ``name``, ``parent_id``, ``resource_id``) will still be populated based on inputs; other computed attributes (``output``, ``location``, ``identity``, ``tags``) will be null/empty. Defaults to ``false``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/data-sources/resource#ignore_not_found DataAzapiResource#ignore_not_found}
        :param name: Specifies the name of the Azure resource. Exactly one of the arguments ``name`` or ``resource_id`` must be set. It could be omitted if the ``type`` is ``Microsoft.Resources/subscriptions``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/data-sources/resource#name DataAzapiResource#name}
        :param parent_id: The ID of the azure resource in which this resource is created. It supports different kinds of deployment scope for **top level** resources: - resource group scope: ``parent_id`` should be the ID of a resource group, it's recommended to manage a resource group by azurerm_resource_group. - management group scope: ``parent_id`` should be the ID of a management group, it's recommended to manage a management group by azurerm_management_group. - extension scope: ``parent_id`` should be the ID of the resource you're adding the extension to. - subscription scope: ``parent_id`` should be like \\x60/subscriptions/00000000-0000-0000-0000-000000000000\\x60 - tenant scope: ``parent_id`` should be / For child level resources, the ``parent_id`` should be the ID of its parent resource, for example, subnet resource's ``parent_id`` is the ID of the vnet. For type ``Microsoft.Resources/resourceGroups``, the ``parent_id`` could be omitted, it defaults to subscription ID specified in provider or the default subscription (You could check the default subscription by azure cli command: ``az account show``). Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/data-sources/resource#parent_id DataAzapiResource#parent_id}
        :param query_parameters: A map of query parameters to include in the request. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/data-sources/resource#query_parameters DataAzapiResource#query_parameters}
        :param resource_id: The ID of the Azure resource to retrieve. Exactly one of the arguments ``name`` or ``resource_id`` must be set. It could be omitted if the ``type`` is ``Microsoft.Resources/subscriptions``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/data-sources/resource#resource_id DataAzapiResource#resource_id}
        :param response_export_values: The attribute can accept either a list or a map. - **List**: A list of paths that need to be exported from the response body. Setting it to ``["*"]`` will export the full response body. Here's an example. If it sets to ``["properties.loginServer", "properties.policies.quarantinePolicy.status"]``, it will set the following HCL object to the computed property output:: { properties = { loginServer = "registry1.azurecr.io" policies = { quarantinePolicy = { status = "disabled" } } } } - **Map**: A map where the key is the name for the result and the value is a JMESPath query string to filter the response. Here's an example. If it sets to ``{"login_server": "properties.loginServer", "quarantine_status": "properties.policies.quarantinePolicy.status"}``, it will set the following HCL object to the computed property output:: { "login_server" = "registry1.azurecr.io" "quarantine_status" = "disabled" } To learn more about JMESPath, visit `JMESPath <https://jmespath.org/>`_. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/data-sources/resource#response_export_values DataAzapiResource#response_export_values}
        :param retry: The retry object supports the following attributes:. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/data-sources/resource#retry DataAzapiResource#retry}
        :param timeouts: timeouts block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/data-sources/resource#timeouts DataAzapiResource#timeouts}
        '''
        if isinstance(lifecycle, dict):
            lifecycle = _cdktf_9a9027ec.TerraformResourceLifecycle(**lifecycle)
        if isinstance(retry, dict):
            retry = DataAzapiResourceRetry(**retry)
        if isinstance(timeouts, dict):
            timeouts = DataAzapiResourceTimeouts(**timeouts)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c81d39048b6d0968fcf6fbef1d7ef5bb78330c8ca8858fed7fc798fcffac245b)
            check_type(argname="argument connection", value=connection, expected_type=type_hints["connection"])
            check_type(argname="argument count", value=count, expected_type=type_hints["count"])
            check_type(argname="argument depends_on", value=depends_on, expected_type=type_hints["depends_on"])
            check_type(argname="argument for_each", value=for_each, expected_type=type_hints["for_each"])
            check_type(argname="argument lifecycle", value=lifecycle, expected_type=type_hints["lifecycle"])
            check_type(argname="argument provider", value=provider, expected_type=type_hints["provider"])
            check_type(argname="argument provisioners", value=provisioners, expected_type=type_hints["provisioners"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument headers", value=headers, expected_type=type_hints["headers"])
            check_type(argname="argument ignore_not_found", value=ignore_not_found, expected_type=type_hints["ignore_not_found"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument parent_id", value=parent_id, expected_type=type_hints["parent_id"])
            check_type(argname="argument query_parameters", value=query_parameters, expected_type=type_hints["query_parameters"])
            check_type(argname="argument resource_id", value=resource_id, expected_type=type_hints["resource_id"])
            check_type(argname="argument response_export_values", value=response_export_values, expected_type=type_hints["response_export_values"])
            check_type(argname="argument retry", value=retry, expected_type=type_hints["retry"])
            check_type(argname="argument timeouts", value=timeouts, expected_type=type_hints["timeouts"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "type": type,
        }
        if connection is not None:
            self._values["connection"] = connection
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if for_each is not None:
            self._values["for_each"] = for_each
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider
        if provisioners is not None:
            self._values["provisioners"] = provisioners
        if headers is not None:
            self._values["headers"] = headers
        if ignore_not_found is not None:
            self._values["ignore_not_found"] = ignore_not_found
        if name is not None:
            self._values["name"] = name
        if parent_id is not None:
            self._values["parent_id"] = parent_id
        if query_parameters is not None:
            self._values["query_parameters"] = query_parameters
        if resource_id is not None:
            self._values["resource_id"] = resource_id
        if response_export_values is not None:
            self._values["response_export_values"] = response_export_values
        if retry is not None:
            self._values["retry"] = retry
        if timeouts is not None:
            self._values["timeouts"] = timeouts

    @builtins.property
    def connection(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("connection")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]], result)

    @builtins.property
    def count(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]], result)

    @builtins.property
    def depends_on(
        self,
    ) -> typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]], result)

    @builtins.property
    def for_each(self) -> typing.Optional[_cdktf_9a9027ec.ITerraformIterator]:
        '''
        :stability: experimental
        '''
        result = self._values.get("for_each")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.ITerraformIterator], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[_cdktf_9a9027ec.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformProvider], result)

    @builtins.property
    def provisioners(
        self,
    ) -> typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provisioners")
        return typing.cast(typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]], result)

    @builtins.property
    def type(self) -> builtins.str:
        '''In a format like ``<resource-type>@<api-version>``.

        ``<resource-type>`` is the Azure resource type, for example, ``Microsoft.Storage/storageAccounts``. ``<api-version>`` is version of the API used to manage this azure resource.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/data-sources/resource#type DataAzapiResource#type}
        '''
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def headers(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''A map of headers to include in the request.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/data-sources/resource#headers DataAzapiResource#headers}
        '''
        result = self._values.get("headers")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def ignore_not_found(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''If set to ``true``, the data source will not fail when the specified resource is not found (HTTP 404).

        Identifier attributes (``id``, ``name``, ``parent_id``, ``resource_id``) will still be populated based on inputs; other computed attributes (``output``, ``location``, ``identity``, ``tags``) will be null/empty. Defaults to ``false``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/data-sources/resource#ignore_not_found DataAzapiResource#ignore_not_found}
        '''
        result = self._values.get("ignore_not_found")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''Specifies the name of the Azure resource.

        Exactly one of the arguments ``name`` or ``resource_id`` must be set. It could be omitted if the ``type`` is ``Microsoft.Resources/subscriptions``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/data-sources/resource#name DataAzapiResource#name}
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def parent_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the azure resource in which this resource is created.

        It supports different kinds of deployment scope for **top level** resources:

        - resource group scope: ``parent_id`` should be the ID of a resource group, it's recommended to manage a resource group by azurerm_resource_group.

          - management group scope: ``parent_id`` should be the ID of a management group, it's recommended to manage a management group by azurerm_management_group.
          - extension scope: ``parent_id`` should be the ID of the resource you're adding the extension to.
          - subscription scope: ``parent_id`` should be like \\x60/subscriptions/00000000-0000-0000-0000-000000000000\\x60
          - tenant scope: ``parent_id`` should be /

        For child level resources, the ``parent_id`` should be the ID of its parent resource, for example, subnet resource's ``parent_id`` is the ID of the vnet.

        For type ``Microsoft.Resources/resourceGroups``, the ``parent_id`` could be omitted, it defaults to subscription ID specified in provider or the default subscription (You could check the default subscription by azure cli command: ``az account show``).

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/data-sources/resource#parent_id DataAzapiResource#parent_id}
        '''
        result = self._values.get("parent_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def query_parameters(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.List[builtins.str]]]]:
        '''A map of query parameters to include in the request.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/data-sources/resource#query_parameters DataAzapiResource#query_parameters}
        '''
        result = self._values.get("query_parameters")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.List[builtins.str]]]], result)

    @builtins.property
    def resource_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the Azure resource to retrieve.

        Exactly one of the arguments ``name`` or ``resource_id`` must be set. It could be omitted if the ``type`` is ``Microsoft.Resources/subscriptions``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/data-sources/resource#resource_id DataAzapiResource#resource_id}
        '''
        result = self._values.get("resource_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def response_export_values(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''The attribute can accept either a list or a map.

        - **List**: A list of paths that need to be exported from the response body. Setting it to ``["*"]`` will export the full response body. Here's an example. If it sets to ``["properties.loginServer", "properties.policies.quarantinePolicy.status"]``, it will set the following HCL object to the computed property output::

             {
             	properties = {
             		loginServer = "registry1.azurecr.io"
             		policies = {
             			quarantinePolicy = {
             				status = "disabled"
             			}
             		}
             	}
             }
        - **Map**: A map where the key is the name for the result and the value is a JMESPath query string to filter the response. Here's an example. If it sets to ``{"login_server": "properties.loginServer", "quarantine_status": "properties.policies.quarantinePolicy.status"}``, it will set the following HCL object to the computed property output::

             {
             	"login_server" = "registry1.azurecr.io"
             	"quarantine_status" = "disabled"
             }

        To learn more about JMESPath, visit `JMESPath <https://jmespath.org/>`_.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/data-sources/resource#response_export_values DataAzapiResource#response_export_values}
        '''
        result = self._values.get("response_export_values")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def retry(self) -> typing.Optional["DataAzapiResourceRetry"]:
        '''The retry object supports the following attributes:.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/data-sources/resource#retry DataAzapiResource#retry}
        '''
        result = self._values.get("retry")
        return typing.cast(typing.Optional["DataAzapiResourceRetry"], result)

    @builtins.property
    def timeouts(self) -> typing.Optional["DataAzapiResourceTimeouts"]:
        '''timeouts block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/data-sources/resource#timeouts DataAzapiResource#timeouts}
        '''
        result = self._values.get("timeouts")
        return typing.cast(typing.Optional["DataAzapiResourceTimeouts"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DataAzapiResourceConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.DataAzapiResourceIdentity",
    jsii_struct_bases=[],
    name_mapping={},
)
class DataAzapiResourceIdentity:
    def __init__(self) -> None:
        self._values: typing.Dict[builtins.str, typing.Any] = {}

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DataAzapiResourceIdentity(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DataAzapiResourceIdentityList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@microsoft/terraform-cdk-constructs.DataAzapiResourceIdentityList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1af1f16ee49f8f1eb006892654b067335c5615e2119218c5b463d4cd44423f71)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(self, index: jsii.Number) -> "DataAzapiResourceIdentityOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d73de6bb31eacadea85076048396d22000065823db94ddd1398c0ebc6196b7ae)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("DataAzapiResourceIdentityOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c7755a917cdb6be8ff581071fa397721555e704f38079240354d4f1cc8cf58cd)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e59e0c1efdfe9e360a8b160c99e164413d90aa08c76354ad57231e66646bf5e9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ce708e452384cc56e89d6a8aa944455b4c1097e39e75cafaefe7183c36be1830)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]


class DataAzapiResourceIdentityOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@microsoft/terraform-cdk-constructs.DataAzapiResourceIdentityOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ea14b6293e41393e2fd23f7e4a73431cd1e1137ffb7c53758a4cf2a2fd74affb)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @builtins.property
    @jsii.member(jsii_name="identityIds")
    def identity_ids(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "identityIds"))

    @builtins.property
    @jsii.member(jsii_name="principalId")
    def principal_id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "principalId"))

    @builtins.property
    @jsii.member(jsii_name="tenantId")
    def tenant_id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "tenantId"))

    @builtins.property
    @jsii.member(jsii_name="type")
    def type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "type"))

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(self) -> typing.Optional[DataAzapiResourceIdentity]:
        return typing.cast(typing.Optional[DataAzapiResourceIdentity], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(self, value: typing.Optional[DataAzapiResourceIdentity]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ce9040397215b4f9cc31e4481741d637cc116b2b4aa4a6bedbce6a1f3336c142)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.DataAzapiResourceRetry",
    jsii_struct_bases=[],
    name_mapping={
        "error_message_regex": "errorMessageRegex",
        "interval_seconds": "intervalSeconds",
        "max_interval_seconds": "maxIntervalSeconds",
        "multiplier": "multiplier",
        "randomization_factor": "randomizationFactor",
    },
)
class DataAzapiResourceRetry:
    def __init__(
        self,
        *,
        error_message_regex: typing.Sequence[builtins.str],
        interval_seconds: typing.Optional[jsii.Number] = None,
        max_interval_seconds: typing.Optional[jsii.Number] = None,
        multiplier: typing.Optional[jsii.Number] = None,
        randomization_factor: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param error_message_regex: A list of regular expressions to match against error messages. If any of the regular expressions match, the request will be retried. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/data-sources/resource#error_message_regex DataAzapiResource#error_message_regex}
        :param interval_seconds: The base number of seconds to wait between retries. Default is ``10``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/data-sources/resource#interval_seconds DataAzapiResource#interval_seconds}
        :param max_interval_seconds: The maximum number of seconds to wait between retries. Default is ``180``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/data-sources/resource#max_interval_seconds DataAzapiResource#max_interval_seconds}
        :param multiplier: The multiplier to apply to the interval between retries. Default is ``1.5``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/data-sources/resource#multiplier DataAzapiResource#multiplier}
        :param randomization_factor: The randomization factor to apply to the interval between retries. The formula for the randomized interval is: ``RetryInterval * (random value in range [1 - RandomizationFactor, 1 + RandomizationFactor])``. Therefore set to zero ``0.0`` for no randomization. Default is ``0.5``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/data-sources/resource#randomization_factor DataAzapiResource#randomization_factor}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7df04d06c2cc51fbca413d1c00ad46d2a1231995725232a29cf8c42c404b954e)
            check_type(argname="argument error_message_regex", value=error_message_regex, expected_type=type_hints["error_message_regex"])
            check_type(argname="argument interval_seconds", value=interval_seconds, expected_type=type_hints["interval_seconds"])
            check_type(argname="argument max_interval_seconds", value=max_interval_seconds, expected_type=type_hints["max_interval_seconds"])
            check_type(argname="argument multiplier", value=multiplier, expected_type=type_hints["multiplier"])
            check_type(argname="argument randomization_factor", value=randomization_factor, expected_type=type_hints["randomization_factor"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "error_message_regex": error_message_regex,
        }
        if interval_seconds is not None:
            self._values["interval_seconds"] = interval_seconds
        if max_interval_seconds is not None:
            self._values["max_interval_seconds"] = max_interval_seconds
        if multiplier is not None:
            self._values["multiplier"] = multiplier
        if randomization_factor is not None:
            self._values["randomization_factor"] = randomization_factor

    @builtins.property
    def error_message_regex(self) -> typing.List[builtins.str]:
        '''A list of regular expressions to match against error messages.

        If any of the regular expressions match, the request will be retried.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/data-sources/resource#error_message_regex DataAzapiResource#error_message_regex}
        '''
        result = self._values.get("error_message_regex")
        assert result is not None, "Required property 'error_message_regex' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def interval_seconds(self) -> typing.Optional[jsii.Number]:
        '''The base number of seconds to wait between retries. Default is ``10``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/data-sources/resource#interval_seconds DataAzapiResource#interval_seconds}
        '''
        result = self._values.get("interval_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def max_interval_seconds(self) -> typing.Optional[jsii.Number]:
        '''The maximum number of seconds to wait between retries. Default is ``180``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/data-sources/resource#max_interval_seconds DataAzapiResource#max_interval_seconds}
        '''
        result = self._values.get("max_interval_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def multiplier(self) -> typing.Optional[jsii.Number]:
        '''The multiplier to apply to the interval between retries. Default is ``1.5``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/data-sources/resource#multiplier DataAzapiResource#multiplier}
        '''
        result = self._values.get("multiplier")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def randomization_factor(self) -> typing.Optional[jsii.Number]:
        '''The randomization factor to apply to the interval between retries.

        The formula for the randomized interval is: ``RetryInterval * (random value in range [1 - RandomizationFactor, 1 + RandomizationFactor])``. Therefore set to zero ``0.0`` for no randomization. Default is ``0.5``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/data-sources/resource#randomization_factor DataAzapiResource#randomization_factor}
        '''
        result = self._values.get("randomization_factor")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DataAzapiResourceRetry(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DataAzapiResourceRetryOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@microsoft/terraform-cdk-constructs.DataAzapiResourceRetryOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2093914b52815f6c9f8f992df1e490405d2fb0eb3ed92c9d12ecd78f76c683d0)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetIntervalSeconds")
    def reset_interval_seconds(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetIntervalSeconds", []))

    @jsii.member(jsii_name="resetMaxIntervalSeconds")
    def reset_max_interval_seconds(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMaxIntervalSeconds", []))

    @jsii.member(jsii_name="resetMultiplier")
    def reset_multiplier(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMultiplier", []))

    @jsii.member(jsii_name="resetRandomizationFactor")
    def reset_randomization_factor(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRandomizationFactor", []))

    @builtins.property
    @jsii.member(jsii_name="errorMessageRegexInput")
    def error_message_regex_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "errorMessageRegexInput"))

    @builtins.property
    @jsii.member(jsii_name="intervalSecondsInput")
    def interval_seconds_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "intervalSecondsInput"))

    @builtins.property
    @jsii.member(jsii_name="maxIntervalSecondsInput")
    def max_interval_seconds_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "maxIntervalSecondsInput"))

    @builtins.property
    @jsii.member(jsii_name="multiplierInput")
    def multiplier_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "multiplierInput"))

    @builtins.property
    @jsii.member(jsii_name="randomizationFactorInput")
    def randomization_factor_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "randomizationFactorInput"))

    @builtins.property
    @jsii.member(jsii_name="errorMessageRegex")
    def error_message_regex(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "errorMessageRegex"))

    @error_message_regex.setter
    def error_message_regex(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7a08560fae648b3b5587da5a173b5f7b330ee74ec71188926d8006dd1bc43e84)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "errorMessageRegex", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="intervalSeconds")
    def interval_seconds(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "intervalSeconds"))

    @interval_seconds.setter
    def interval_seconds(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a2813ac3834b9d62cab14b97312422f75191219f69e06ef89e97110a04930650)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "intervalSeconds", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="maxIntervalSeconds")
    def max_interval_seconds(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "maxIntervalSeconds"))

    @max_interval_seconds.setter
    def max_interval_seconds(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5f61a85e616e3222353b76f2e6ba60eb38b06dac1f282e0175f8b23a6ae69827)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "maxIntervalSeconds", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="multiplier")
    def multiplier(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "multiplier"))

    @multiplier.setter
    def multiplier(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1ef580c9234e481bb8cb64902ced476c99a940aa92a2e32553f1b1eb4b7fdd9d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "multiplier", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="randomizationFactor")
    def randomization_factor(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "randomizationFactor"))

    @randomization_factor.setter
    def randomization_factor(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__db016357007f9e31917cffe65e419e26e724e9164b120cb8f4825e4cbc07df46)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "randomizationFactor", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, DataAzapiResourceRetry]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, DataAzapiResourceRetry]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, DataAzapiResourceRetry]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e4f27b8b9a04ee51a1b03e59d5efdc7997eb9cc45d244898d6cc9af1d08e2587)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.DataAzapiResourceTimeouts",
    jsii_struct_bases=[],
    name_mapping={"read": "read"},
)
class DataAzapiResourceTimeouts:
    def __init__(self, *, read: typing.Optional[builtins.str] = None) -> None:
        '''
        :param read: A string that can be `parsed as a duration <https://pkg.go.dev/time#ParseDuration>`_ consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/data-sources/resource#read DataAzapiResource#read}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b14e05c954c1083e933078931799aaca03614921080ec3501a0a4da372188b05)
            check_type(argname="argument read", value=read, expected_type=type_hints["read"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if read is not None:
            self._values["read"] = read

    @builtins.property
    def read(self) -> typing.Optional[builtins.str]:
        '''A string that can be `parsed as a duration <https://pkg.go.dev/time#ParseDuration>`_ consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/data-sources/resource#read DataAzapiResource#read}
        '''
        result = self._values.get("read")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DataAzapiResourceTimeouts(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DataAzapiResourceTimeoutsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@microsoft/terraform-cdk-constructs.DataAzapiResourceTimeoutsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__183f068e9cac6c72ba2e3837cc9bcc89ba93501fd5abf5143b74944927e66735)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetRead")
    def reset_read(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRead", []))

    @builtins.property
    @jsii.member(jsii_name="readInput")
    def read_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "readInput"))

    @builtins.property
    @jsii.member(jsii_name="read")
    def read(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "read"))

    @read.setter
    def read(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__396e5079c2a95967f0c3551f59fb096a3ea2e0a28556d951c2e7f9bf9e3f67e9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "read", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, DataAzapiResourceTimeouts]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, DataAzapiResourceTimeouts]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, DataAzapiResourceTimeouts]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9843de41b9274baf366d7a3297247ff082f08ded71e4a69545bf5833e132cd45)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.DiagnosticLogConfig",
    jsii_struct_bases=[],
    name_mapping={
        "enabled": "enabled",
        "category": "category",
        "category_group": "categoryGroup",
        "retention_policy": "retentionPolicy",
    },
)
class DiagnosticLogConfig:
    def __init__(
        self,
        *,
        enabled: builtins.bool,
        category: typing.Optional[builtins.str] = None,
        category_group: typing.Optional[builtins.str] = None,
        retention_policy: typing.Optional[typing.Union[_RetentionPolicyConfig_13c42ec6, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Log configuration for diagnostic settings.

        :param enabled: 
        :param category: 
        :param category_group: 
        :param retention_policy: 
        '''
        if isinstance(retention_policy, dict):
            retention_policy = _RetentionPolicyConfig_13c42ec6(**retention_policy)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__96fea199b663d9dbe1256ea8303c743d790a1bb46e0ef9a6183d574a3bd2f34b)
            check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
            check_type(argname="argument category", value=category, expected_type=type_hints["category"])
            check_type(argname="argument category_group", value=category_group, expected_type=type_hints["category_group"])
            check_type(argname="argument retention_policy", value=retention_policy, expected_type=type_hints["retention_policy"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "enabled": enabled,
        }
        if category is not None:
            self._values["category"] = category
        if category_group is not None:
            self._values["category_group"] = category_group
        if retention_policy is not None:
            self._values["retention_policy"] = retention_policy

    @builtins.property
    def enabled(self) -> builtins.bool:
        result = self._values.get("enabled")
        assert result is not None, "Required property 'enabled' is missing"
        return typing.cast(builtins.bool, result)

    @builtins.property
    def category(self) -> typing.Optional[builtins.str]:
        result = self._values.get("category")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def category_group(self) -> typing.Optional[builtins.str]:
        result = self._values.get("category_group")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def retention_policy(self) -> typing.Optional[_RetentionPolicyConfig_13c42ec6]:
        result = self._values.get("retention_policy")
        return typing.cast(typing.Optional[_RetentionPolicyConfig_13c42ec6], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DiagnosticLogConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.DiagnosticMetricConfig",
    jsii_struct_bases=[],
    name_mapping={
        "enabled": "enabled",
        "category": "category",
        "retention_policy": "retentionPolicy",
        "time_grain": "timeGrain",
    },
)
class DiagnosticMetricConfig:
    def __init__(
        self,
        *,
        enabled: builtins.bool,
        category: typing.Optional[builtins.str] = None,
        retention_policy: typing.Optional[typing.Union[_RetentionPolicyConfig_13c42ec6, typing.Dict[builtins.str, typing.Any]]] = None,
        time_grain: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Metric configuration for diagnostic settings.

        :param enabled: 
        :param category: Metric category name (used in newer API versions).
        :param retention_policy: 
        :param time_grain: Time grain for metrics in ISO 8601 duration format (used in API version 2016-09-01, e.g., "PT1M").
        '''
        if isinstance(retention_policy, dict):
            retention_policy = _RetentionPolicyConfig_13c42ec6(**retention_policy)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ad20bcfb2d477281861ea968578dce4848dbca7c10255e4d7a1f910c686b0785)
            check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
            check_type(argname="argument category", value=category, expected_type=type_hints["category"])
            check_type(argname="argument retention_policy", value=retention_policy, expected_type=type_hints["retention_policy"])
            check_type(argname="argument time_grain", value=time_grain, expected_type=type_hints["time_grain"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "enabled": enabled,
        }
        if category is not None:
            self._values["category"] = category
        if retention_policy is not None:
            self._values["retention_policy"] = retention_policy
        if time_grain is not None:
            self._values["time_grain"] = time_grain

    @builtins.property
    def enabled(self) -> builtins.bool:
        result = self._values.get("enabled")
        assert result is not None, "Required property 'enabled' is missing"
        return typing.cast(builtins.bool, result)

    @builtins.property
    def category(self) -> typing.Optional[builtins.str]:
        '''Metric category name (used in newer API versions).'''
        result = self._values.get("category")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def retention_policy(self) -> typing.Optional[_RetentionPolicyConfig_13c42ec6]:
        result = self._values.get("retention_policy")
        return typing.cast(typing.Optional[_RetentionPolicyConfig_13c42ec6], result)

    @builtins.property
    def time_grain(self) -> typing.Optional[builtins.str]:
        '''Time grain for metrics in ISO 8601 duration format (used in API version 2016-09-01, e.g., "PT1M").'''
        result = self._values.get("time_grain")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DiagnosticMetricConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DiagnosticSettings(
    _AzapiResource_7e7f5b39,
    metaclass=jsii.JSIIMeta,
    jsii_type="@microsoft/terraform-cdk-constructs.DiagnosticSettings",
):
    '''Unified Azure Diagnostic Settings implementation.

    This class provides a single, version-aware implementation that automatically handles version
    resolution, schema validation, and property transformation while maintaining full JSII compliance.

    Diagnostic Settings enable monitoring and observability by exporting platform logs and metrics
    to one or more destinations including Log Analytics workspaces, Storage accounts, and Event Hubs.

    Example::

        // Diagnostic settings with multiple destinations:
        const diagnostics = new DiagnosticSettings(this, "storage-diagnostics", {
          name: "storage-diagnostics",
          targetResourceId: storageAccount.id,
          workspaceId: logAnalyticsWorkspace.id,
          storageAccountId: archiveStorageAccount.id,
          eventHubAuthorizationRuleId: eventHub.authRuleId,
          eventHubName: "monitoring-hub",
          logs: [{
            category: "StorageRead",
            enabled: true,
            retentionPolicy: {
              enabled: true,
              days: 90
            }
          }],
          metrics: [{
            category: "Transaction",
            enabled: true
          }]
        });
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        target_resource_id: builtins.str,
        event_hub_authorization_rule_id: typing.Optional[builtins.str] = None,
        event_hub_name: typing.Optional[builtins.str] = None,
        log_analytics_destination_type: typing.Optional[builtins.str] = None,
        logs: typing.Optional[typing.Sequence[typing.Union[_DiagnosticLogConfig_990fcbff, typing.Dict[builtins.str, typing.Any]]]] = None,
        metrics: typing.Optional[typing.Sequence[typing.Union[_DiagnosticMetricConfig_29c0add1, typing.Dict[builtins.str, typing.Any]]]] = None,
        storage_account_id: typing.Optional[builtins.str] = None,
        workspace_id: typing.Optional[builtins.str] = None,
        api_version: typing.Optional[builtins.str] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        location: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> None:
        '''Creates a new Azure Diagnostic Settings using the AzapiResource framework.

        The constructor automatically handles version resolution, schema registration,
        validation, and resource creation.

        :param scope: - The scope in which to define this construct.
        :param id: - The unique identifier for this instance.
        :param target_resource_id: Target resource ID to attach diagnostic settings to This is the resource being monitored.
        :param event_hub_authorization_rule_id: Event Hub authorization rule ID for streaming Requires eventHubName to be specified as well.
        :param event_hub_name: Event Hub name for streaming Required when eventHubAuthorizationRuleId is specified.
        :param log_analytics_destination_type: Log Analytics destination type Determines the table structure in Log Analytics. Default: undefined (uses default behavior)
        :param logs: Log categories to enable Defines which log categories should be exported.
        :param metrics: Metric categories to enable Defines which metric categories should be exported.
        :param storage_account_id: Storage account ID for log/metric destination At least one destination (workspace, storage, or event hub) must be specified.
        :param workspace_id: Log Analytics workspace ID for log/metric destination At least one destination (workspace, storage, or event hub) must be specified.
        :param api_version: Explicit API version to use for this resource. If not specified, the latest active version will be automatically resolved. Use this for version pinning when stability is required over latest features. Default: Latest active version from ApiVersionManager
        :param enable_migration_analysis: Whether to enable migration analysis warnings. When true, the framework will analyze the current version for deprecation status and provide migration recommendations in the deployment output. Default: true
        :param enable_transformation: Whether to apply property transformations automatically. When true, properties will be automatically transformed according to the target schema's transformation rules. This enables backward compatibility. Default: true
        :param enable_validation: Whether to validate properties against the schema. When true, all properties will be validated against the API schema before resource creation. Validation errors will cause deployment failures. Default: true
        :param location: The location where the resource should be created. Default: Varies by resource type - see specific resource documentation
        :param monitoring: Monitoring configuration for this resource. Enables integrated monitoring with diagnostic settings, metric alerts, and activity log alerts. All monitoring is optional and disabled by default.
        :param name: The name of the resource.
        :param tags: Tags to apply to the resource.
        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__51d0e5fc2996d16bd2c2198e13321b1d5aff2b2cacfb88f4fc4ca19b1367c9c0)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = _DiagnosticSettingsProps_cc0fa615(
            target_resource_id=target_resource_id,
            event_hub_authorization_rule_id=event_hub_authorization_rule_id,
            event_hub_name=event_hub_name,
            log_analytics_destination_type=log_analytics_destination_type,
            logs=logs,
            metrics=metrics,
            storage_account_id=storage_account_id,
            workspace_id=workspace_id,
            api_version=api_version,
            enable_migration_analysis=enable_migration_analysis,
            enable_transformation=enable_transformation,
            enable_validation=enable_validation,
            location=location,
            monitoring=monitoring,
            name=name,
            tags=tags,
            connection=connection,
            count=count,
            depends_on=depends_on,
            for_each=for_each,
            lifecycle=lifecycle,
            provider=provider,
            provisioners=provisioners,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="apiSchema")
    def _api_schema(self) -> _ApiSchema_5ce0490e:
        '''Gets the API schema for the resolved version Uses the framework's schema resolution to get the appropriate schema.'''
        return typing.cast(_ApiSchema_5ce0490e, jsii.invoke(self, "apiSchema", []))

    @jsii.member(jsii_name="createResourceBody")
    def _create_resource_body(self, props: typing.Any) -> typing.Any:
        '''Creates the resource body for the Azure API call Transforms the input properties into the JSON format expected by Azure REST API.

        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3fe421ace719ca938403552f41dee71478e4ec59c28858c0f7989f45dae22041)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Any, jsii.invoke(self, "createResourceBody", [props]))

    @jsii.member(jsii_name="defaultVersion")
    def _default_version(self) -> builtins.str:
        '''Gets the default API version to use when no explicit version is specified Returns the latest stable (non-preview) version as the default.'''
        return typing.cast(builtins.str, jsii.invoke(self, "defaultVersion", []))

    @jsii.member(jsii_name="resolveParentId")
    def _resolve_parent_id(self, props: typing.Any) -> builtins.str:
        '''Resolves the parent resource ID for Diagnostic Settings Diagnostic Settings are child resources attached to the monitored resource.

        :param props: - The resource properties.

        :return: The parent resource ID (the target resource being monitored)
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e499a0d9d2a8e7aeb996796c4846e409a3e3a5cfc33db36be01c2a6eb5da8156)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(builtins.str, jsii.invoke(self, "resolveParentId", [props]))

    @jsii.member(jsii_name="resourceType")
    def _resource_type(self) -> builtins.str:
        '''Gets the Azure resource type for Diagnostic Settings.'''
        return typing.cast(builtins.str, jsii.invoke(self, "resourceType", []))

    @builtins.property
    @jsii.member(jsii_name="idOutput")
    def id_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "idOutput"))

    @builtins.property
    @jsii.member(jsii_name="nameOutput")
    def name_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "nameOutput"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def props(self) -> _DiagnosticSettingsProps_cc0fa615:
        '''The input properties for this Diagnostic Settings instance.'''
        return typing.cast(_DiagnosticSettingsProps_cc0fa615, jsii.get(self, "props"))


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.DiagnosticSettingsBody",
    jsii_struct_bases=[],
    name_mapping={"properties": "properties"},
)
class DiagnosticSettingsBody:
    def __init__(
        self,
        *,
        properties: typing.Union[_DiagnosticSettingsBodyProperties_ed65245b, typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''The resource body interface for Azure Diagnostic Settings API calls.

        :param properties: 
        '''
        if isinstance(properties, dict):
            properties = _DiagnosticSettingsBodyProperties_ed65245b(**properties)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__70cf2c8bb788e97cd49f2f7be4bcbe9c091d185987c80aafe5fe2d77e826863f)
            check_type(argname="argument properties", value=properties, expected_type=type_hints["properties"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "properties": properties,
        }

    @builtins.property
    def properties(self) -> _DiagnosticSettingsBodyProperties_ed65245b:
        result = self._values.get("properties")
        assert result is not None, "Required property 'properties' is missing"
        return typing.cast(_DiagnosticSettingsBodyProperties_ed65245b, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DiagnosticSettingsBody(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.DiagnosticSettingsBodyProperties",
    jsii_struct_bases=[],
    name_mapping={
        "event_hub_authorization_rule_id": "eventHubAuthorizationRuleId",
        "event_hub_name": "eventHubName",
        "log_analytics_destination_type": "logAnalyticsDestinationType",
        "logs": "logs",
        "metrics": "metrics",
        "storage_account_id": "storageAccountId",
        "workspace_id": "workspaceId",
    },
)
class DiagnosticSettingsBodyProperties:
    def __init__(
        self,
        *,
        event_hub_authorization_rule_id: typing.Optional[builtins.str] = None,
        event_hub_name: typing.Optional[builtins.str] = None,
        log_analytics_destination_type: typing.Optional[builtins.str] = None,
        logs: typing.Optional[typing.Sequence[typing.Union[_DiagnosticLogConfig_990fcbff, typing.Dict[builtins.str, typing.Any]]]] = None,
        metrics: typing.Optional[typing.Sequence[typing.Union[_DiagnosticMetricConfig_29c0add1, typing.Dict[builtins.str, typing.Any]]]] = None,
        storage_account_id: typing.Optional[builtins.str] = None,
        workspace_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Diagnostic Settings properties for the request body.

        :param event_hub_authorization_rule_id: 
        :param event_hub_name: 
        :param log_analytics_destination_type: 
        :param logs: 
        :param metrics: 
        :param storage_account_id: 
        :param workspace_id: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d077af97d422aed9b806a9f1edeecdf9d99b667cd617271f9a12cc4e9ab30479)
            check_type(argname="argument event_hub_authorization_rule_id", value=event_hub_authorization_rule_id, expected_type=type_hints["event_hub_authorization_rule_id"])
            check_type(argname="argument event_hub_name", value=event_hub_name, expected_type=type_hints["event_hub_name"])
            check_type(argname="argument log_analytics_destination_type", value=log_analytics_destination_type, expected_type=type_hints["log_analytics_destination_type"])
            check_type(argname="argument logs", value=logs, expected_type=type_hints["logs"])
            check_type(argname="argument metrics", value=metrics, expected_type=type_hints["metrics"])
            check_type(argname="argument storage_account_id", value=storage_account_id, expected_type=type_hints["storage_account_id"])
            check_type(argname="argument workspace_id", value=workspace_id, expected_type=type_hints["workspace_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if event_hub_authorization_rule_id is not None:
            self._values["event_hub_authorization_rule_id"] = event_hub_authorization_rule_id
        if event_hub_name is not None:
            self._values["event_hub_name"] = event_hub_name
        if log_analytics_destination_type is not None:
            self._values["log_analytics_destination_type"] = log_analytics_destination_type
        if logs is not None:
            self._values["logs"] = logs
        if metrics is not None:
            self._values["metrics"] = metrics
        if storage_account_id is not None:
            self._values["storage_account_id"] = storage_account_id
        if workspace_id is not None:
            self._values["workspace_id"] = workspace_id

    @builtins.property
    def event_hub_authorization_rule_id(self) -> typing.Optional[builtins.str]:
        result = self._values.get("event_hub_authorization_rule_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def event_hub_name(self) -> typing.Optional[builtins.str]:
        result = self._values.get("event_hub_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def log_analytics_destination_type(self) -> typing.Optional[builtins.str]:
        result = self._values.get("log_analytics_destination_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def logs(self) -> typing.Optional[typing.List[_DiagnosticLogConfig_990fcbff]]:
        result = self._values.get("logs")
        return typing.cast(typing.Optional[typing.List[_DiagnosticLogConfig_990fcbff]], result)

    @builtins.property
    def metrics(self) -> typing.Optional[typing.List[_DiagnosticMetricConfig_29c0add1]]:
        result = self._values.get("metrics")
        return typing.cast(typing.Optional[typing.List[_DiagnosticMetricConfig_29c0add1]], result)

    @builtins.property
    def storage_account_id(self) -> typing.Optional[builtins.str]:
        result = self._values.get("storage_account_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def workspace_id(self) -> typing.Optional[builtins.str]:
        result = self._values.get("workspace_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DiagnosticSettingsBodyProperties(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.DiagnosticSettingsProps",
    jsii_struct_bases=[_AzapiResourceProps_141a2340],
    name_mapping={
        "connection": "connection",
        "count": "count",
        "depends_on": "dependsOn",
        "for_each": "forEach",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "provisioners": "provisioners",
        "api_version": "apiVersion",
        "enable_migration_analysis": "enableMigrationAnalysis",
        "enable_transformation": "enableTransformation",
        "enable_validation": "enableValidation",
        "location": "location",
        "monitoring": "monitoring",
        "name": "name",
        "tags": "tags",
        "target_resource_id": "targetResourceId",
        "event_hub_authorization_rule_id": "eventHubAuthorizationRuleId",
        "event_hub_name": "eventHubName",
        "log_analytics_destination_type": "logAnalyticsDestinationType",
        "logs": "logs",
        "metrics": "metrics",
        "storage_account_id": "storageAccountId",
        "workspace_id": "workspaceId",
    },
)
class DiagnosticSettingsProps(_AzapiResourceProps_141a2340):
    def __init__(
        self,
        *,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
        api_version: typing.Optional[builtins.str] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        location: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        target_resource_id: builtins.str,
        event_hub_authorization_rule_id: typing.Optional[builtins.str] = None,
        event_hub_name: typing.Optional[builtins.str] = None,
        log_analytics_destination_type: typing.Optional[builtins.str] = None,
        logs: typing.Optional[typing.Sequence[typing.Union[_DiagnosticLogConfig_990fcbff, typing.Dict[builtins.str, typing.Any]]]] = None,
        metrics: typing.Optional[typing.Sequence[typing.Union[_DiagnosticMetricConfig_29c0add1, typing.Dict[builtins.str, typing.Any]]]] = None,
        storage_account_id: typing.Optional[builtins.str] = None,
        workspace_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for the unified Azure Diagnostic Settings.

        Extends AzapiResourceProps with Diagnostic Settings specific properties

        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        :param api_version: Explicit API version to use for this resource. If not specified, the latest active version will be automatically resolved. Use this for version pinning when stability is required over latest features. Default: Latest active version from ApiVersionManager
        :param enable_migration_analysis: Whether to enable migration analysis warnings. When true, the framework will analyze the current version for deprecation status and provide migration recommendations in the deployment output. Default: true
        :param enable_transformation: Whether to apply property transformations automatically. When true, properties will be automatically transformed according to the target schema's transformation rules. This enables backward compatibility. Default: true
        :param enable_validation: Whether to validate properties against the schema. When true, all properties will be validated against the API schema before resource creation. Validation errors will cause deployment failures. Default: true
        :param location: The location where the resource should be created. Default: Varies by resource type - see specific resource documentation
        :param monitoring: Monitoring configuration for this resource. Enables integrated monitoring with diagnostic settings, metric alerts, and activity log alerts. All monitoring is optional and disabled by default.
        :param name: The name of the resource.
        :param tags: Tags to apply to the resource.
        :param target_resource_id: Target resource ID to attach diagnostic settings to This is the resource being monitored.
        :param event_hub_authorization_rule_id: Event Hub authorization rule ID for streaming Requires eventHubName to be specified as well.
        :param event_hub_name: Event Hub name for streaming Required when eventHubAuthorizationRuleId is specified.
        :param log_analytics_destination_type: Log Analytics destination type Determines the table structure in Log Analytics. Default: undefined (uses default behavior)
        :param logs: Log categories to enable Defines which log categories should be exported.
        :param metrics: Metric categories to enable Defines which metric categories should be exported.
        :param storage_account_id: Storage account ID for log/metric destination At least one destination (workspace, storage, or event hub) must be specified.
        :param workspace_id: Log Analytics workspace ID for log/metric destination At least one destination (workspace, storage, or event hub) must be specified.
        '''
        if isinstance(lifecycle, dict):
            lifecycle = _cdktf_9a9027ec.TerraformResourceLifecycle(**lifecycle)
        if isinstance(monitoring, dict):
            monitoring = _MonitoringConfig_7c28df74(**monitoring)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d6ea315f7f318cca71dba75218c4fcd80970e2821f918caa34dcdc09d2f863ed)
            check_type(argname="argument connection", value=connection, expected_type=type_hints["connection"])
            check_type(argname="argument count", value=count, expected_type=type_hints["count"])
            check_type(argname="argument depends_on", value=depends_on, expected_type=type_hints["depends_on"])
            check_type(argname="argument for_each", value=for_each, expected_type=type_hints["for_each"])
            check_type(argname="argument lifecycle", value=lifecycle, expected_type=type_hints["lifecycle"])
            check_type(argname="argument provider", value=provider, expected_type=type_hints["provider"])
            check_type(argname="argument provisioners", value=provisioners, expected_type=type_hints["provisioners"])
            check_type(argname="argument api_version", value=api_version, expected_type=type_hints["api_version"])
            check_type(argname="argument enable_migration_analysis", value=enable_migration_analysis, expected_type=type_hints["enable_migration_analysis"])
            check_type(argname="argument enable_transformation", value=enable_transformation, expected_type=type_hints["enable_transformation"])
            check_type(argname="argument enable_validation", value=enable_validation, expected_type=type_hints["enable_validation"])
            check_type(argname="argument location", value=location, expected_type=type_hints["location"])
            check_type(argname="argument monitoring", value=monitoring, expected_type=type_hints["monitoring"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument target_resource_id", value=target_resource_id, expected_type=type_hints["target_resource_id"])
            check_type(argname="argument event_hub_authorization_rule_id", value=event_hub_authorization_rule_id, expected_type=type_hints["event_hub_authorization_rule_id"])
            check_type(argname="argument event_hub_name", value=event_hub_name, expected_type=type_hints["event_hub_name"])
            check_type(argname="argument log_analytics_destination_type", value=log_analytics_destination_type, expected_type=type_hints["log_analytics_destination_type"])
            check_type(argname="argument logs", value=logs, expected_type=type_hints["logs"])
            check_type(argname="argument metrics", value=metrics, expected_type=type_hints["metrics"])
            check_type(argname="argument storage_account_id", value=storage_account_id, expected_type=type_hints["storage_account_id"])
            check_type(argname="argument workspace_id", value=workspace_id, expected_type=type_hints["workspace_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "target_resource_id": target_resource_id,
        }
        if connection is not None:
            self._values["connection"] = connection
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if for_each is not None:
            self._values["for_each"] = for_each
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider
        if provisioners is not None:
            self._values["provisioners"] = provisioners
        if api_version is not None:
            self._values["api_version"] = api_version
        if enable_migration_analysis is not None:
            self._values["enable_migration_analysis"] = enable_migration_analysis
        if enable_transformation is not None:
            self._values["enable_transformation"] = enable_transformation
        if enable_validation is not None:
            self._values["enable_validation"] = enable_validation
        if location is not None:
            self._values["location"] = location
        if monitoring is not None:
            self._values["monitoring"] = monitoring
        if name is not None:
            self._values["name"] = name
        if tags is not None:
            self._values["tags"] = tags
        if event_hub_authorization_rule_id is not None:
            self._values["event_hub_authorization_rule_id"] = event_hub_authorization_rule_id
        if event_hub_name is not None:
            self._values["event_hub_name"] = event_hub_name
        if log_analytics_destination_type is not None:
            self._values["log_analytics_destination_type"] = log_analytics_destination_type
        if logs is not None:
            self._values["logs"] = logs
        if metrics is not None:
            self._values["metrics"] = metrics
        if storage_account_id is not None:
            self._values["storage_account_id"] = storage_account_id
        if workspace_id is not None:
            self._values["workspace_id"] = workspace_id

    @builtins.property
    def connection(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("connection")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]], result)

    @builtins.property
    def count(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]], result)

    @builtins.property
    def depends_on(
        self,
    ) -> typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]], result)

    @builtins.property
    def for_each(self) -> typing.Optional[_cdktf_9a9027ec.ITerraformIterator]:
        '''
        :stability: experimental
        '''
        result = self._values.get("for_each")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.ITerraformIterator], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[_cdktf_9a9027ec.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformProvider], result)

    @builtins.property
    def provisioners(
        self,
    ) -> typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provisioners")
        return typing.cast(typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]], result)

    @builtins.property
    def api_version(self) -> typing.Optional[builtins.str]:
        '''Explicit API version to use for this resource.

        If not specified, the latest active version will be automatically resolved.
        Use this for version pinning when stability is required over latest features.

        :default: Latest active version from ApiVersionManager

        Example::

            "2024-11-01"
        '''
        result = self._values.get("api_version")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def enable_migration_analysis(self) -> typing.Optional[builtins.bool]:
        '''Whether to enable migration analysis warnings.

        When true, the framework will analyze the current version for deprecation
        status and provide migration recommendations in the deployment output.

        :default: true
        '''
        result = self._values.get("enable_migration_analysis")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_transformation(self) -> typing.Optional[builtins.bool]:
        '''Whether to apply property transformations automatically.

        When true, properties will be automatically transformed according to the
        target schema's transformation rules. This enables backward compatibility.

        :default: true
        '''
        result = self._values.get("enable_transformation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_validation(self) -> typing.Optional[builtins.bool]:
        '''Whether to validate properties against the schema.

        When true, all properties will be validated against the API schema before
        resource creation. Validation errors will cause deployment failures.

        :default: true
        '''
        result = self._values.get("enable_validation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def location(self) -> typing.Optional[builtins.str]:
        '''The location where the resource should be created.

        :default: Varies by resource type - see specific resource documentation

        :remarks:

        Location handling varies by resource type:

        - **Top-level resources**: Most require an explicit location (e.g., "eastus", "westus")
        - **Global resources**: Some use "global" as location (e.g., Private DNS Zones)
        - **Child resources**: Inherit location from parent and should NOT set this property

        Each resource type may provide its own default through the ``resolveLocation()`` method.
        If no location is specified and no default exists, resource creation may fail.

        Example::

            // Child resource (Subnet) - do not set location
            // location: undefined (inherited from parent Virtual Network)
        '''
        result = self._values.get("location")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def monitoring(self) -> typing.Optional[_MonitoringConfig_7c28df74]:
        '''Monitoring configuration for this resource.

        Enables integrated monitoring with diagnostic settings, metric alerts,
        and activity log alerts. All monitoring is optional and disabled by default.

        Example::

            monitoring: {
              enabled: true,
              diagnosticSettings: {
                workspaceId: logAnalytics.id,
                metrics: ['AllMetrics'],
                logs: ['AuditLogs']
              },
              metricAlerts: [{
                name: 'high-cpu-alert',
                severity: 2,
                scopes: [], // Automatically set to this resource
                criteria: { ... },
                actions: [{ actionGroupId: actionGroup.id }]
              }]
            }
        '''
        result = self._values.get("monitoring")
        return typing.cast(typing.Optional[_MonitoringConfig_7c28df74], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the resource.'''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Tags to apply to the resource.'''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def target_resource_id(self) -> builtins.str:
        '''Target resource ID to attach diagnostic settings to This is the resource being monitored.'''
        result = self._values.get("target_resource_id")
        assert result is not None, "Required property 'target_resource_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def event_hub_authorization_rule_id(self) -> typing.Optional[builtins.str]:
        '''Event Hub authorization rule ID for streaming Requires eventHubName to be specified as well.'''
        result = self._values.get("event_hub_authorization_rule_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def event_hub_name(self) -> typing.Optional[builtins.str]:
        '''Event Hub name for streaming Required when eventHubAuthorizationRuleId is specified.'''
        result = self._values.get("event_hub_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def log_analytics_destination_type(self) -> typing.Optional[builtins.str]:
        '''Log Analytics destination type Determines the table structure in Log Analytics.

        :default: undefined (uses default behavior)
        '''
        result = self._values.get("log_analytics_destination_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def logs(self) -> typing.Optional[typing.List[_DiagnosticLogConfig_990fcbff]]:
        '''Log categories to enable Defines which log categories should be exported.'''
        result = self._values.get("logs")
        return typing.cast(typing.Optional[typing.List[_DiagnosticLogConfig_990fcbff]], result)

    @builtins.property
    def metrics(self) -> typing.Optional[typing.List[_DiagnosticMetricConfig_29c0add1]]:
        '''Metric categories to enable Defines which metric categories should be exported.'''
        result = self._values.get("metrics")
        return typing.cast(typing.Optional[typing.List[_DiagnosticMetricConfig_29c0add1]], result)

    @builtins.property
    def storage_account_id(self) -> typing.Optional[builtins.str]:
        '''Storage account ID for log/metric destination At least one destination (workspace, storage, or event hub) must be specified.'''
        result = self._values.get("storage_account_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def workspace_id(self) -> typing.Optional[builtins.str]:
        '''Log Analytics workspace ID for log/metric destination At least one destination (workspace, storage, or event hub) must be specified.'''
        result = self._values.get("workspace_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DiagnosticSettingsProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DnsForwardingRuleset(
    _AzapiResource_7e7f5b39,
    metaclass=jsii.JSIIMeta,
    jsii_type="@microsoft/terraform-cdk-constructs.DnsForwardingRuleset",
):
    '''Unified Azure DNS Forwarding Ruleset implementation.

    This class provides a unified implementation for creating DNS Forwarding Rulesets
    that enable conditional forwarding of DNS queries. Rulesets work with DNS Resolver
    Outbound Endpoints to route queries to specific target DNS servers based on domain names.

    Key Requirements:

    - Requires at least one DNS Resolver Outbound Endpoint
    - Each ruleset can contain up to 1000 forwarding rules
    - Regional resource (must match outbound endpoint location)
    - Can be linked to multiple virtual networks

    Example::

        // DNS forwarding ruleset with explicit version pinning:
        const ruleset = new DnsForwardingRuleset(this, "ruleset", {
          name: "my-ruleset",
          location: "eastus",
          resourceGroupId: resourceGroup.id,
          dnsResolverOutboundEndpointIds: [outboundEndpoint.id],
          apiVersion: "2022-07-01",
        });
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        dns_resolver_outbound_endpoint_ids: typing.Sequence[builtins.str],
        ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
        resource_group_id: typing.Optional[builtins.str] = None,
        api_version: typing.Optional[builtins.str] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        location: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> None:
        '''Creates a new Azure DNS Forwarding Ruleset using the AzapiResource framework.

        :param scope: - The scope in which to define this construct.
        :param id: - The unique identifier for this instance.
        :param dns_resolver_outbound_endpoint_ids: Array of resource IDs of DNS Resolver Outbound Endpoints The ruleset uses these endpoints to forward DNS queries based on the rules.
        :param ignore_changes: The lifecycle rules to ignore changes.
        :param resource_group_id: Resource group ID where the DNS Forwarding Ruleset will be created.
        :param api_version: Explicit API version to use for this resource. If not specified, the latest active version will be automatically resolved. Use this for version pinning when stability is required over latest features. Default: Latest active version from ApiVersionManager
        :param enable_migration_analysis: Whether to enable migration analysis warnings. When true, the framework will analyze the current version for deprecation status and provide migration recommendations in the deployment output. Default: true
        :param enable_transformation: Whether to apply property transformations automatically. When true, properties will be automatically transformed according to the target schema's transformation rules. This enables backward compatibility. Default: true
        :param enable_validation: Whether to validate properties against the schema. When true, all properties will be validated against the API schema before resource creation. Validation errors will cause deployment failures. Default: true
        :param location: The location where the resource should be created. Default: Varies by resource type - see specific resource documentation
        :param monitoring: Monitoring configuration for this resource. Enables integrated monitoring with diagnostic settings, metric alerts, and activity log alerts. All monitoring is optional and disabled by default.
        :param name: The name of the resource.
        :param tags: Tags to apply to the resource.
        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__caf754a9ba2508d367fa5f31c17d63f6739d53b7908d43004115b31323dc2b23)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = _DnsForwardingRulesetProps_a40699d5(
            dns_resolver_outbound_endpoint_ids=dns_resolver_outbound_endpoint_ids,
            ignore_changes=ignore_changes,
            resource_group_id=resource_group_id,
            api_version=api_version,
            enable_migration_analysis=enable_migration_analysis,
            enable_transformation=enable_transformation,
            enable_validation=enable_validation,
            location=location,
            monitoring=monitoring,
            name=name,
            tags=tags,
            connection=connection,
            count=count,
            depends_on=depends_on,
            for_each=for_each,
            lifecycle=lifecycle,
            provider=provider,
            provisioners=provisioners,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="addTag")
    def add_tag(self, key: builtins.str, value: builtins.str) -> None:
        '''Add a tag to the DNS Forwarding Ruleset.

        :param key: -
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__785dbeb27ef9a99a31c197035a4dd8bda6f7a25f6b5e7ed96b3ed4ccc4d4ea95)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "addTag", [key, value]))

    @jsii.member(jsii_name="apiSchema")
    def _api_schema(self) -> _ApiSchema_5ce0490e:
        '''Gets the API schema for the resolved version.'''
        return typing.cast(_ApiSchema_5ce0490e, jsii.invoke(self, "apiSchema", []))

    @jsii.member(jsii_name="createResourceBody")
    def _create_resource_body(self, props: typing.Any) -> typing.Any:
        '''Creates the resource body for the Azure API call.

        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f2faf5f4cc0bb624cfd8391ae6878eb64ff0e110f40419b7dda5ff15957f58f8)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Any, jsii.invoke(self, "createResourceBody", [props]))

    @jsii.member(jsii_name="defaultVersion")
    def _default_version(self) -> builtins.str:
        '''Gets the default API version to use when no explicit version is specified.'''
        return typing.cast(builtins.str, jsii.invoke(self, "defaultVersion", []))

    @jsii.member(jsii_name="removeTag")
    def remove_tag(self, key: builtins.str) -> None:
        '''Remove a tag from the DNS Forwarding Ruleset.

        :param key: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__231996d50e7742c31611f9f16f2e3d8277579f6cd753ce470a8d9763a4c5536c)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
        return typing.cast(None, jsii.invoke(self, "removeTag", [key]))

    @jsii.member(jsii_name="requiresLocation")
    def _requires_location(self) -> builtins.bool:
        '''Indicates that location is required for DNS Forwarding Rulesets.'''
        return typing.cast(builtins.bool, jsii.invoke(self, "requiresLocation", []))

    @jsii.member(jsii_name="resourceType")
    def _resource_type(self) -> builtins.str:
        '''Gets the Azure resource type for DNS Forwarding Rulesets.'''
        return typing.cast(builtins.str, jsii.invoke(self, "resourceType", []))

    @builtins.property
    @jsii.member(jsii_name="idOutput")
    def id_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "idOutput"))

    @builtins.property
    @jsii.member(jsii_name="locationOutput")
    def location_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "locationOutput"))

    @builtins.property
    @jsii.member(jsii_name="nameOutput")
    def name_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "nameOutput"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def props(self) -> _DnsForwardingRulesetProps_a40699d5:
        return typing.cast(_DnsForwardingRulesetProps_a40699d5, jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        '''Get the provisioning state of the DNS Forwarding Ruleset.'''
        return typing.cast(builtins.str, jsii.get(self, "provisioningState"))

    @builtins.property
    @jsii.member(jsii_name="provisioningStateOutput")
    def provisioning_state_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "provisioningStateOutput"))

    @builtins.property
    @jsii.member(jsii_name="resourceGuid")
    def resource_guid(self) -> builtins.str:
        '''Get the unique identifier for the DNS Forwarding Ruleset resource.'''
        return typing.cast(builtins.str, jsii.get(self, "resourceGuid"))

    @builtins.property
    @jsii.member(jsii_name="resourceGuidOutput")
    def resource_guid_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "resourceGuidOutput"))

    @builtins.property
    @jsii.member(jsii_name="tagsOutput")
    def tags_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "tagsOutput"))


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.DnsForwardingRulesetBody",
    jsii_struct_bases=[],
    name_mapping={"location": "location", "properties": "properties", "tags": "tags"},
)
class DnsForwardingRulesetBody:
    def __init__(
        self,
        *,
        location: builtins.str,
        properties: typing.Union[_DnsForwardingRulesetProperties_2e4f976e, typing.Dict[builtins.str, typing.Any]],
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''The resource body interface for Azure DNS Forwarding Ruleset API calls This matches the Azure REST API schema.

        :param location: 
        :param properties: 
        :param tags: 
        '''
        if isinstance(properties, dict):
            properties = _DnsForwardingRulesetProperties_2e4f976e(**properties)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0a2e2bd51043e438050bea03d411b40c993b7e32ca52f70bee201120f3f568fc)
            check_type(argname="argument location", value=location, expected_type=type_hints["location"])
            check_type(argname="argument properties", value=properties, expected_type=type_hints["properties"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "location": location,
            "properties": properties,
        }
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def location(self) -> builtins.str:
        result = self._values.get("location")
        assert result is not None, "Required property 'location' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def properties(self) -> _DnsForwardingRulesetProperties_2e4f976e:
        result = self._values.get("properties")
        assert result is not None, "Required property 'properties' is missing"
        return typing.cast(_DnsForwardingRulesetProperties_2e4f976e, result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DnsForwardingRulesetBody(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.DnsForwardingRulesetProperties",
    jsii_struct_bases=[],
    name_mapping={"dns_resolver_outbound_endpoints": "dnsResolverOutboundEndpoints"},
)
class DnsForwardingRulesetProperties:
    def __init__(
        self,
        *,
        dns_resolver_outbound_endpoints: typing.Sequence[typing.Union[_DnsResolverOutboundEndpointReference_c6bd5513, typing.Dict[builtins.str, typing.Any]]],
    ) -> None:
        '''Properties for the DNS Forwarding Ruleset body.

        :param dns_resolver_outbound_endpoints: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__14d5a8e161fae5bbcba539b2f92920730ccd6fb5fcde2b9fd060ab335e41be17)
            check_type(argname="argument dns_resolver_outbound_endpoints", value=dns_resolver_outbound_endpoints, expected_type=type_hints["dns_resolver_outbound_endpoints"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "dns_resolver_outbound_endpoints": dns_resolver_outbound_endpoints,
        }

    @builtins.property
    def dns_resolver_outbound_endpoints(
        self,
    ) -> typing.List[_DnsResolverOutboundEndpointReference_c6bd5513]:
        result = self._values.get("dns_resolver_outbound_endpoints")
        assert result is not None, "Required property 'dns_resolver_outbound_endpoints' is missing"
        return typing.cast(typing.List[_DnsResolverOutboundEndpointReference_c6bd5513], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DnsForwardingRulesetProperties(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.DnsForwardingRulesetProps",
    jsii_struct_bases=[_AzapiResourceProps_141a2340],
    name_mapping={
        "connection": "connection",
        "count": "count",
        "depends_on": "dependsOn",
        "for_each": "forEach",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "provisioners": "provisioners",
        "api_version": "apiVersion",
        "enable_migration_analysis": "enableMigrationAnalysis",
        "enable_transformation": "enableTransformation",
        "enable_validation": "enableValidation",
        "location": "location",
        "monitoring": "monitoring",
        "name": "name",
        "tags": "tags",
        "dns_resolver_outbound_endpoint_ids": "dnsResolverOutboundEndpointIds",
        "ignore_changes": "ignoreChanges",
        "resource_group_id": "resourceGroupId",
    },
)
class DnsForwardingRulesetProps(_AzapiResourceProps_141a2340):
    def __init__(
        self,
        *,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
        api_version: typing.Optional[builtins.str] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        location: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        dns_resolver_outbound_endpoint_ids: typing.Sequence[builtins.str],
        ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
        resource_group_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for the unified Azure DNS Forwarding Ruleset.

        Extends AzapiResourceProps with DNS Forwarding Ruleset specific properties

        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        :param api_version: Explicit API version to use for this resource. If not specified, the latest active version will be automatically resolved. Use this for version pinning when stability is required over latest features. Default: Latest active version from ApiVersionManager
        :param enable_migration_analysis: Whether to enable migration analysis warnings. When true, the framework will analyze the current version for deprecation status and provide migration recommendations in the deployment output. Default: true
        :param enable_transformation: Whether to apply property transformations automatically. When true, properties will be automatically transformed according to the target schema's transformation rules. This enables backward compatibility. Default: true
        :param enable_validation: Whether to validate properties against the schema. When true, all properties will be validated against the API schema before resource creation. Validation errors will cause deployment failures. Default: true
        :param location: The location where the resource should be created. Default: Varies by resource type - see specific resource documentation
        :param monitoring: Monitoring configuration for this resource. Enables integrated monitoring with diagnostic settings, metric alerts, and activity log alerts. All monitoring is optional and disabled by default.
        :param name: The name of the resource.
        :param tags: Tags to apply to the resource.
        :param dns_resolver_outbound_endpoint_ids: Array of resource IDs of DNS Resolver Outbound Endpoints The ruleset uses these endpoints to forward DNS queries based on the rules.
        :param ignore_changes: The lifecycle rules to ignore changes.
        :param resource_group_id: Resource group ID where the DNS Forwarding Ruleset will be created.
        '''
        if isinstance(lifecycle, dict):
            lifecycle = _cdktf_9a9027ec.TerraformResourceLifecycle(**lifecycle)
        if isinstance(monitoring, dict):
            monitoring = _MonitoringConfig_7c28df74(**monitoring)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ba211b5061f5f5b0965e8279044a08e05445029ed7ff4e710eaf8c4433936154)
            check_type(argname="argument connection", value=connection, expected_type=type_hints["connection"])
            check_type(argname="argument count", value=count, expected_type=type_hints["count"])
            check_type(argname="argument depends_on", value=depends_on, expected_type=type_hints["depends_on"])
            check_type(argname="argument for_each", value=for_each, expected_type=type_hints["for_each"])
            check_type(argname="argument lifecycle", value=lifecycle, expected_type=type_hints["lifecycle"])
            check_type(argname="argument provider", value=provider, expected_type=type_hints["provider"])
            check_type(argname="argument provisioners", value=provisioners, expected_type=type_hints["provisioners"])
            check_type(argname="argument api_version", value=api_version, expected_type=type_hints["api_version"])
            check_type(argname="argument enable_migration_analysis", value=enable_migration_analysis, expected_type=type_hints["enable_migration_analysis"])
            check_type(argname="argument enable_transformation", value=enable_transformation, expected_type=type_hints["enable_transformation"])
            check_type(argname="argument enable_validation", value=enable_validation, expected_type=type_hints["enable_validation"])
            check_type(argname="argument location", value=location, expected_type=type_hints["location"])
            check_type(argname="argument monitoring", value=monitoring, expected_type=type_hints["monitoring"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument dns_resolver_outbound_endpoint_ids", value=dns_resolver_outbound_endpoint_ids, expected_type=type_hints["dns_resolver_outbound_endpoint_ids"])
            check_type(argname="argument ignore_changes", value=ignore_changes, expected_type=type_hints["ignore_changes"])
            check_type(argname="argument resource_group_id", value=resource_group_id, expected_type=type_hints["resource_group_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "dns_resolver_outbound_endpoint_ids": dns_resolver_outbound_endpoint_ids,
        }
        if connection is not None:
            self._values["connection"] = connection
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if for_each is not None:
            self._values["for_each"] = for_each
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider
        if provisioners is not None:
            self._values["provisioners"] = provisioners
        if api_version is not None:
            self._values["api_version"] = api_version
        if enable_migration_analysis is not None:
            self._values["enable_migration_analysis"] = enable_migration_analysis
        if enable_transformation is not None:
            self._values["enable_transformation"] = enable_transformation
        if enable_validation is not None:
            self._values["enable_validation"] = enable_validation
        if location is not None:
            self._values["location"] = location
        if monitoring is not None:
            self._values["monitoring"] = monitoring
        if name is not None:
            self._values["name"] = name
        if tags is not None:
            self._values["tags"] = tags
        if ignore_changes is not None:
            self._values["ignore_changes"] = ignore_changes
        if resource_group_id is not None:
            self._values["resource_group_id"] = resource_group_id

    @builtins.property
    def connection(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("connection")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]], result)

    @builtins.property
    def count(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]], result)

    @builtins.property
    def depends_on(
        self,
    ) -> typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]], result)

    @builtins.property
    def for_each(self) -> typing.Optional[_cdktf_9a9027ec.ITerraformIterator]:
        '''
        :stability: experimental
        '''
        result = self._values.get("for_each")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.ITerraformIterator], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[_cdktf_9a9027ec.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformProvider], result)

    @builtins.property
    def provisioners(
        self,
    ) -> typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provisioners")
        return typing.cast(typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]], result)

    @builtins.property
    def api_version(self) -> typing.Optional[builtins.str]:
        '''Explicit API version to use for this resource.

        If not specified, the latest active version will be automatically resolved.
        Use this for version pinning when stability is required over latest features.

        :default: Latest active version from ApiVersionManager

        Example::

            "2024-11-01"
        '''
        result = self._values.get("api_version")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def enable_migration_analysis(self) -> typing.Optional[builtins.bool]:
        '''Whether to enable migration analysis warnings.

        When true, the framework will analyze the current version for deprecation
        status and provide migration recommendations in the deployment output.

        :default: true
        '''
        result = self._values.get("enable_migration_analysis")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_transformation(self) -> typing.Optional[builtins.bool]:
        '''Whether to apply property transformations automatically.

        When true, properties will be automatically transformed according to the
        target schema's transformation rules. This enables backward compatibility.

        :default: true
        '''
        result = self._values.get("enable_transformation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_validation(self) -> typing.Optional[builtins.bool]:
        '''Whether to validate properties against the schema.

        When true, all properties will be validated against the API schema before
        resource creation. Validation errors will cause deployment failures.

        :default: true
        '''
        result = self._values.get("enable_validation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def location(self) -> typing.Optional[builtins.str]:
        '''The location where the resource should be created.

        :default: Varies by resource type - see specific resource documentation

        :remarks:

        Location handling varies by resource type:

        - **Top-level resources**: Most require an explicit location (e.g., "eastus", "westus")
        - **Global resources**: Some use "global" as location (e.g., Private DNS Zones)
        - **Child resources**: Inherit location from parent and should NOT set this property

        Each resource type may provide its own default through the ``resolveLocation()`` method.
        If no location is specified and no default exists, resource creation may fail.

        Example::

            // Child resource (Subnet) - do not set location
            // location: undefined (inherited from parent Virtual Network)
        '''
        result = self._values.get("location")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def monitoring(self) -> typing.Optional[_MonitoringConfig_7c28df74]:
        '''Monitoring configuration for this resource.

        Enables integrated monitoring with diagnostic settings, metric alerts,
        and activity log alerts. All monitoring is optional and disabled by default.

        Example::

            monitoring: {
              enabled: true,
              diagnosticSettings: {
                workspaceId: logAnalytics.id,
                metrics: ['AllMetrics'],
                logs: ['AuditLogs']
              },
              metricAlerts: [{
                name: 'high-cpu-alert',
                severity: 2,
                scopes: [], // Automatically set to this resource
                criteria: { ... },
                actions: [{ actionGroupId: actionGroup.id }]
              }]
            }
        '''
        result = self._values.get("monitoring")
        return typing.cast(typing.Optional[_MonitoringConfig_7c28df74], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the resource.'''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Tags to apply to the resource.'''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def dns_resolver_outbound_endpoint_ids(self) -> typing.List[builtins.str]:
        '''Array of resource IDs of DNS Resolver Outbound Endpoints The ruleset uses these endpoints to forward DNS queries based on the rules.

        Example::

            ["/subscriptions/.../dnsResolvers/resolver1/outboundEndpoints/endpoint1"]
        '''
        result = self._values.get("dns_resolver_outbound_endpoint_ids")
        assert result is not None, "Required property 'dns_resolver_outbound_endpoint_ids' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def ignore_changes(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The lifecycle rules to ignore changes.

        Example::

            ["tags"]
        '''
        result = self._values.get("ignore_changes")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def resource_group_id(self) -> typing.Optional[builtins.str]:
        '''Resource group ID where the DNS Forwarding Ruleset will be created.'''
        result = self._values.get("resource_group_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DnsForwardingRulesetProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DnsForwardingRulesetVirtualNetworkLink(
    _AzapiResource_7e7f5b39,
    metaclass=jsii.JSIIMeta,
    jsii_type="@microsoft/terraform-cdk-constructs.DnsForwardingRulesetVirtualNetworkLink",
):
    '''Azure DNS Forwarding Ruleset Virtual Network Link implementation.

    Virtual Network Links connect DNS Forwarding Rulesets to virtual networks,
    enabling those VNets to use the conditional forwarding rules defined in the ruleset.
    This allows VMs and other resources in the linked VNets to resolve domains according
    to the forwarding rules.

    Example::

        // Virtual network link with explicit version:
        const link = new DnsForwardingRulesetVirtualNetworkLink(this, "vnet-link", {
          name: "my-vnet-link",
          dnsForwardingRulesetId: ruleset.id,
          virtualNetworkId: vnet.id,
          apiVersion: "2022-07-01"
        });
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        dns_forwarding_ruleset_id: builtins.str,
        virtual_network_id: builtins.str,
        ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
        metadata: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        api_version: typing.Optional[builtins.str] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        location: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> None:
        '''Creates a new Azure DNS Forwarding Ruleset Virtual Network Link using the AzapiResource framework.

        :param scope: - The scope in which to define this construct.
        :param id: - The unique identifier for this instance.
        :param dns_forwarding_ruleset_id: Resource ID of the parent DNS Forwarding Ruleset.
        :param virtual_network_id: Resource ID of the Virtual Network to link.
        :param ignore_changes: The lifecycle rules to ignore changes.
        :param metadata: Metadata attached to the virtual network link as key-value pairs.
        :param api_version: Explicit API version to use for this resource. If not specified, the latest active version will be automatically resolved. Use this for version pinning when stability is required over latest features. Default: Latest active version from ApiVersionManager
        :param enable_migration_analysis: Whether to enable migration analysis warnings. When true, the framework will analyze the current version for deprecation status and provide migration recommendations in the deployment output. Default: true
        :param enable_transformation: Whether to apply property transformations automatically. When true, properties will be automatically transformed according to the target schema's transformation rules. This enables backward compatibility. Default: true
        :param enable_validation: Whether to validate properties against the schema. When true, all properties will be validated against the API schema before resource creation. Validation errors will cause deployment failures. Default: true
        :param location: The location where the resource should be created. Default: Varies by resource type - see specific resource documentation
        :param monitoring: Monitoring configuration for this resource. Enables integrated monitoring with diagnostic settings, metric alerts, and activity log alerts. All monitoring is optional and disabled by default.
        :param name: The name of the resource.
        :param tags: Tags to apply to the resource.
        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__76c13541401dcdbff5f5f3080526f13d5b1233ab4db741b9cb6770aea3e63abb)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = _DnsForwardingRulesetVirtualNetworkLinkProps_7096eaf4(
            dns_forwarding_ruleset_id=dns_forwarding_ruleset_id,
            virtual_network_id=virtual_network_id,
            ignore_changes=ignore_changes,
            metadata=metadata,
            api_version=api_version,
            enable_migration_analysis=enable_migration_analysis,
            enable_transformation=enable_transformation,
            enable_validation=enable_validation,
            location=location,
            monitoring=monitoring,
            name=name,
            tags=tags,
            connection=connection,
            count=count,
            depends_on=depends_on,
            for_each=for_each,
            lifecycle=lifecycle,
            provider=provider,
            provisioners=provisioners,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="apiSchema")
    def _api_schema(self) -> _ApiSchema_5ce0490e:
        '''Gets the API schema for the resolved version.'''
        return typing.cast(_ApiSchema_5ce0490e, jsii.invoke(self, "apiSchema", []))

    @jsii.member(jsii_name="createResourceBody")
    def _create_resource_body(self, props: typing.Any) -> typing.Any:
        '''Creates the resource body for the Azure API call.

        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__db1ff57177b88b743d765aa8547942d134a9ca001c7b385c2aa809b75d6bf945)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Any, jsii.invoke(self, "createResourceBody", [props]))

    @jsii.member(jsii_name="defaultVersion")
    def _default_version(self) -> builtins.str:
        '''Gets the default API version to use when no explicit version is specified.'''
        return typing.cast(builtins.str, jsii.invoke(self, "defaultVersion", []))

    @jsii.member(jsii_name="resolveParentId")
    def _resolve_parent_id(self, props: typing.Any) -> builtins.str:
        '''Resolves the parent resource ID for the Virtual Network Link Virtual Network Links are child resources of DNS Forwarding Rulesets.

        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__83958202f42de62bdff5a1e508f0c4b1f1f4d975e018eb701b23f0fc47acfdce)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(builtins.str, jsii.invoke(self, "resolveParentId", [props]))

    @jsii.member(jsii_name="resourceType")
    def _resource_type(self) -> builtins.str:
        '''Gets the Azure resource type for Virtual Network Links.'''
        return typing.cast(builtins.str, jsii.invoke(self, "resourceType", []))

    @builtins.property
    @jsii.member(jsii_name="idOutput")
    def id_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "idOutput"))

    @builtins.property
    @jsii.member(jsii_name="metadata")
    def metadata(self) -> builtins.str:
        '''Get the metadata.'''
        return typing.cast(builtins.str, jsii.get(self, "metadata"))

    @builtins.property
    @jsii.member(jsii_name="nameOutput")
    def name_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "nameOutput"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def props(self) -> _DnsForwardingRulesetVirtualNetworkLinkProps_7096eaf4:
        '''The input properties for this Virtual Network Link instance.'''
        return typing.cast(_DnsForwardingRulesetVirtualNetworkLinkProps_7096eaf4, jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        '''Get the provisioning state of the Virtual Network Link.'''
        return typing.cast(builtins.str, jsii.get(self, "provisioningState"))

    @builtins.property
    @jsii.member(jsii_name="provisioningStateOutput")
    def provisioning_state_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "provisioningStateOutput"))

    @builtins.property
    @jsii.member(jsii_name="resourceName")
    def resource_name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "resourceName"))


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.DnsForwardingRulesetVirtualNetworkLinkBody",
    jsii_struct_bases=[],
    name_mapping={"properties": "properties"},
)
class DnsForwardingRulesetVirtualNetworkLinkBody:
    def __init__(
        self,
        *,
        properties: typing.Union[_DnsForwardingRulesetVirtualNetworkLinkProperties_c0ccbf67, typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''The resource body interface for Azure Virtual Network Link API calls.

        :param properties: 
        '''
        if isinstance(properties, dict):
            properties = _DnsForwardingRulesetVirtualNetworkLinkProperties_c0ccbf67(**properties)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3d500bfc608bae79acbf86e8eab9deab9ea3620f597c7b5616a111f49e3c3f09)
            check_type(argname="argument properties", value=properties, expected_type=type_hints["properties"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "properties": properties,
        }

    @builtins.property
    def properties(self) -> _DnsForwardingRulesetVirtualNetworkLinkProperties_c0ccbf67:
        result = self._values.get("properties")
        assert result is not None, "Required property 'properties' is missing"
        return typing.cast(_DnsForwardingRulesetVirtualNetworkLinkProperties_c0ccbf67, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DnsForwardingRulesetVirtualNetworkLinkBody(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.DnsForwardingRulesetVirtualNetworkLinkProperties",
    jsii_struct_bases=[],
    name_mapping={"virtual_network": "virtualNetwork", "metadata": "metadata"},
)
class DnsForwardingRulesetVirtualNetworkLinkProperties:
    def __init__(
        self,
        *,
        virtual_network: typing.Union[_DnsForwardingRulesetVirtualNetworkReference_4806dc52, typing.Dict[builtins.str, typing.Any]],
        metadata: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''Properties for Virtual Network Link body.

        :param virtual_network: 
        :param metadata: 
        '''
        if isinstance(virtual_network, dict):
            virtual_network = _DnsForwardingRulesetVirtualNetworkReference_4806dc52(**virtual_network)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bdad081330f0e605cfc7d3ab115ecc5a6f2d6d6a72a1e4c6f641d136ee5bbb18)
            check_type(argname="argument virtual_network", value=virtual_network, expected_type=type_hints["virtual_network"])
            check_type(argname="argument metadata", value=metadata, expected_type=type_hints["metadata"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "virtual_network": virtual_network,
        }
        if metadata is not None:
            self._values["metadata"] = metadata

    @builtins.property
    def virtual_network(self) -> _DnsForwardingRulesetVirtualNetworkReference_4806dc52:
        result = self._values.get("virtual_network")
        assert result is not None, "Required property 'virtual_network' is missing"
        return typing.cast(_DnsForwardingRulesetVirtualNetworkReference_4806dc52, result)

    @builtins.property
    def metadata(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        result = self._values.get("metadata")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DnsForwardingRulesetVirtualNetworkLinkProperties(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.DnsForwardingRulesetVirtualNetworkLinkProps",
    jsii_struct_bases=[_AzapiResourceProps_141a2340],
    name_mapping={
        "connection": "connection",
        "count": "count",
        "depends_on": "dependsOn",
        "for_each": "forEach",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "provisioners": "provisioners",
        "api_version": "apiVersion",
        "enable_migration_analysis": "enableMigrationAnalysis",
        "enable_transformation": "enableTransformation",
        "enable_validation": "enableValidation",
        "location": "location",
        "monitoring": "monitoring",
        "name": "name",
        "tags": "tags",
        "dns_forwarding_ruleset_id": "dnsForwardingRulesetId",
        "virtual_network_id": "virtualNetworkId",
        "ignore_changes": "ignoreChanges",
        "metadata": "metadata",
    },
)
class DnsForwardingRulesetVirtualNetworkLinkProps(_AzapiResourceProps_141a2340):
    def __init__(
        self,
        *,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
        api_version: typing.Optional[builtins.str] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        location: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        dns_forwarding_ruleset_id: builtins.str,
        virtual_network_id: builtins.str,
        ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
        metadata: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''Properties for the Azure DNS Forwarding Ruleset Virtual Network Link.

        Extends AzapiResourceProps with Virtual Network Link specific properties

        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        :param api_version: Explicit API version to use for this resource. If not specified, the latest active version will be automatically resolved. Use this for version pinning when stability is required over latest features. Default: Latest active version from ApiVersionManager
        :param enable_migration_analysis: Whether to enable migration analysis warnings. When true, the framework will analyze the current version for deprecation status and provide migration recommendations in the deployment output. Default: true
        :param enable_transformation: Whether to apply property transformations automatically. When true, properties will be automatically transformed according to the target schema's transformation rules. This enables backward compatibility. Default: true
        :param enable_validation: Whether to validate properties against the schema. When true, all properties will be validated against the API schema before resource creation. Validation errors will cause deployment failures. Default: true
        :param location: The location where the resource should be created. Default: Varies by resource type - see specific resource documentation
        :param monitoring: Monitoring configuration for this resource. Enables integrated monitoring with diagnostic settings, metric alerts, and activity log alerts. All monitoring is optional and disabled by default.
        :param name: The name of the resource.
        :param tags: Tags to apply to the resource.
        :param dns_forwarding_ruleset_id: Resource ID of the parent DNS Forwarding Ruleset.
        :param virtual_network_id: Resource ID of the Virtual Network to link.
        :param ignore_changes: The lifecycle rules to ignore changes.
        :param metadata: Metadata attached to the virtual network link as key-value pairs.
        '''
        if isinstance(lifecycle, dict):
            lifecycle = _cdktf_9a9027ec.TerraformResourceLifecycle(**lifecycle)
        if isinstance(monitoring, dict):
            monitoring = _MonitoringConfig_7c28df74(**monitoring)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8aaf2aa9cfbcbef306c0fa40dc17e86b12e38dbdcf94d8e6189b8746a639f1d2)
            check_type(argname="argument connection", value=connection, expected_type=type_hints["connection"])
            check_type(argname="argument count", value=count, expected_type=type_hints["count"])
            check_type(argname="argument depends_on", value=depends_on, expected_type=type_hints["depends_on"])
            check_type(argname="argument for_each", value=for_each, expected_type=type_hints["for_each"])
            check_type(argname="argument lifecycle", value=lifecycle, expected_type=type_hints["lifecycle"])
            check_type(argname="argument provider", value=provider, expected_type=type_hints["provider"])
            check_type(argname="argument provisioners", value=provisioners, expected_type=type_hints["provisioners"])
            check_type(argname="argument api_version", value=api_version, expected_type=type_hints["api_version"])
            check_type(argname="argument enable_migration_analysis", value=enable_migration_analysis, expected_type=type_hints["enable_migration_analysis"])
            check_type(argname="argument enable_transformation", value=enable_transformation, expected_type=type_hints["enable_transformation"])
            check_type(argname="argument enable_validation", value=enable_validation, expected_type=type_hints["enable_validation"])
            check_type(argname="argument location", value=location, expected_type=type_hints["location"])
            check_type(argname="argument monitoring", value=monitoring, expected_type=type_hints["monitoring"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument dns_forwarding_ruleset_id", value=dns_forwarding_ruleset_id, expected_type=type_hints["dns_forwarding_ruleset_id"])
            check_type(argname="argument virtual_network_id", value=virtual_network_id, expected_type=type_hints["virtual_network_id"])
            check_type(argname="argument ignore_changes", value=ignore_changes, expected_type=type_hints["ignore_changes"])
            check_type(argname="argument metadata", value=metadata, expected_type=type_hints["metadata"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "dns_forwarding_ruleset_id": dns_forwarding_ruleset_id,
            "virtual_network_id": virtual_network_id,
        }
        if connection is not None:
            self._values["connection"] = connection
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if for_each is not None:
            self._values["for_each"] = for_each
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider
        if provisioners is not None:
            self._values["provisioners"] = provisioners
        if api_version is not None:
            self._values["api_version"] = api_version
        if enable_migration_analysis is not None:
            self._values["enable_migration_analysis"] = enable_migration_analysis
        if enable_transformation is not None:
            self._values["enable_transformation"] = enable_transformation
        if enable_validation is not None:
            self._values["enable_validation"] = enable_validation
        if location is not None:
            self._values["location"] = location
        if monitoring is not None:
            self._values["monitoring"] = monitoring
        if name is not None:
            self._values["name"] = name
        if tags is not None:
            self._values["tags"] = tags
        if ignore_changes is not None:
            self._values["ignore_changes"] = ignore_changes
        if metadata is not None:
            self._values["metadata"] = metadata

    @builtins.property
    def connection(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("connection")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]], result)

    @builtins.property
    def count(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]], result)

    @builtins.property
    def depends_on(
        self,
    ) -> typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]], result)

    @builtins.property
    def for_each(self) -> typing.Optional[_cdktf_9a9027ec.ITerraformIterator]:
        '''
        :stability: experimental
        '''
        result = self._values.get("for_each")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.ITerraformIterator], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[_cdktf_9a9027ec.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformProvider], result)

    @builtins.property
    def provisioners(
        self,
    ) -> typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provisioners")
        return typing.cast(typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]], result)

    @builtins.property
    def api_version(self) -> typing.Optional[builtins.str]:
        '''Explicit API version to use for this resource.

        If not specified, the latest active version will be automatically resolved.
        Use this for version pinning when stability is required over latest features.

        :default: Latest active version from ApiVersionManager

        Example::

            "2024-11-01"
        '''
        result = self._values.get("api_version")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def enable_migration_analysis(self) -> typing.Optional[builtins.bool]:
        '''Whether to enable migration analysis warnings.

        When true, the framework will analyze the current version for deprecation
        status and provide migration recommendations in the deployment output.

        :default: true
        '''
        result = self._values.get("enable_migration_analysis")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_transformation(self) -> typing.Optional[builtins.bool]:
        '''Whether to apply property transformations automatically.

        When true, properties will be automatically transformed according to the
        target schema's transformation rules. This enables backward compatibility.

        :default: true
        '''
        result = self._values.get("enable_transformation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_validation(self) -> typing.Optional[builtins.bool]:
        '''Whether to validate properties against the schema.

        When true, all properties will be validated against the API schema before
        resource creation. Validation errors will cause deployment failures.

        :default: true
        '''
        result = self._values.get("enable_validation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def location(self) -> typing.Optional[builtins.str]:
        '''The location where the resource should be created.

        :default: Varies by resource type - see specific resource documentation

        :remarks:

        Location handling varies by resource type:

        - **Top-level resources**: Most require an explicit location (e.g., "eastus", "westus")
        - **Global resources**: Some use "global" as location (e.g., Private DNS Zones)
        - **Child resources**: Inherit location from parent and should NOT set this property

        Each resource type may provide its own default through the ``resolveLocation()`` method.
        If no location is specified and no default exists, resource creation may fail.

        Example::

            // Child resource (Subnet) - do not set location
            // location: undefined (inherited from parent Virtual Network)
        '''
        result = self._values.get("location")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def monitoring(self) -> typing.Optional[_MonitoringConfig_7c28df74]:
        '''Monitoring configuration for this resource.

        Enables integrated monitoring with diagnostic settings, metric alerts,
        and activity log alerts. All monitoring is optional and disabled by default.

        Example::

            monitoring: {
              enabled: true,
              diagnosticSettings: {
                workspaceId: logAnalytics.id,
                metrics: ['AllMetrics'],
                logs: ['AuditLogs']
              },
              metricAlerts: [{
                name: 'high-cpu-alert',
                severity: 2,
                scopes: [], // Automatically set to this resource
                criteria: { ... },
                actions: [{ actionGroupId: actionGroup.id }]
              }]
            }
        '''
        result = self._values.get("monitoring")
        return typing.cast(typing.Optional[_MonitoringConfig_7c28df74], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the resource.'''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Tags to apply to the resource.'''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def dns_forwarding_ruleset_id(self) -> builtins.str:
        '''Resource ID of the parent DNS Forwarding Ruleset.

        Example::

            "/subscriptions/.../resourceGroups/rg/providers/Microsoft.Network/dnsForwardingRulesets/ruleset1"
        '''
        result = self._values.get("dns_forwarding_ruleset_id")
        assert result is not None, "Required property 'dns_forwarding_ruleset_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def virtual_network_id(self) -> builtins.str:
        '''Resource ID of the Virtual Network to link.

        Example::

            "/subscriptions/.../resourceGroups/rg/providers/Microsoft.Network/virtualNetworks/vnet1"
        '''
        result = self._values.get("virtual_network_id")
        assert result is not None, "Required property 'virtual_network_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def ignore_changes(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The lifecycle rules to ignore changes.

        Example::

            ["metadata"]
        '''
        result = self._values.get("ignore_changes")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def metadata(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Metadata attached to the virtual network link as key-value pairs.'''
        result = self._values.get("metadata")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DnsForwardingRulesetVirtualNetworkLinkProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.DnsForwardingRulesetVirtualNetworkReference",
    jsii_struct_bases=[],
    name_mapping={"id": "id"},
)
class DnsForwardingRulesetVirtualNetworkReference:
    def __init__(self, *, id: builtins.str) -> None:
        '''Virtual Network reference for DNS Forwarding Ruleset link.

        :param id: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__934f8d19affdf51ded32eb6a6a3d795e26529dc5b7faf07f3746eebee302c06a)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "id": id,
        }

    @builtins.property
    def id(self) -> builtins.str:
        result = self._values.get("id")
        assert result is not None, "Required property 'id' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DnsForwardingRulesetVirtualNetworkReference(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DnsResolver(
    _AzapiResource_7e7f5b39,
    metaclass=jsii.JSIIMeta,
    jsii_type="@microsoft/terraform-cdk-constructs.DnsResolver",
):
    '''Unified Azure DNS Resolver implementation.

    This class provides a single, version-aware implementation that replaces all
    version-specific DNS Resolver classes. It automatically handles version
    resolution, schema validation, and property transformation while maintaining
    full backward compatibility.

    Azure DNS Private Resolvers enable hybrid DNS scenarios, allowing conditional
    forwarding between Azure, on-premises, and other cloud providers. They provide
    DNS resolution for resources in Azure virtual networks.

    Key Requirements:

    - Requires a dedicated subnet with delegation to Microsoft.Network/dnsResolvers
    - Subnet must be between /28 and /24 in size
    - Each subscription can have up to 15 DNS resolvers
    - Regional resource (unlike DNS zones which are global)

    Example::

        // DNS resolver with explicit version pinning:
        const dnsResolver = new DnsResolver(this, "resolver", {
          name: "my-dns-resolver",
          location: "eastus",
          resourceGroupId: resourceGroup.id,
          virtualNetworkId: vnet.id,
          apiVersion: "2022-07-01",
        });
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        virtual_network_id: builtins.str,
        ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
        resource_group_id: typing.Optional[builtins.str] = None,
        api_version: typing.Optional[builtins.str] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        location: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> None:
        '''Creates a new Azure DNS Resolver using the VersionedAzapiResource framework.

        :param scope: - The scope in which to define this construct.
        :param id: - The unique identifier for this instance.
        :param virtual_network_id: The resource ID of the virtual network where the DNS Resolver will be deployed The resolver requires a dedicated subnet with delegation to Microsoft.Network/dnsResolvers.
        :param ignore_changes: The lifecycle rules to ignore changes.
        :param resource_group_id: Resource group ID where the DNS Resolver will be created.
        :param api_version: Explicit API version to use for this resource. If not specified, the latest active version will be automatically resolved. Use this for version pinning when stability is required over latest features. Default: Latest active version from ApiVersionManager
        :param enable_migration_analysis: Whether to enable migration analysis warnings. When true, the framework will analyze the current version for deprecation status and provide migration recommendations in the deployment output. Default: true
        :param enable_transformation: Whether to apply property transformations automatically. When true, properties will be automatically transformed according to the target schema's transformation rules. This enables backward compatibility. Default: true
        :param enable_validation: Whether to validate properties against the schema. When true, all properties will be validated against the API schema before resource creation. Validation errors will cause deployment failures. Default: true
        :param location: The location where the resource should be created. Default: Varies by resource type - see specific resource documentation
        :param monitoring: Monitoring configuration for this resource. Enables integrated monitoring with diagnostic settings, metric alerts, and activity log alerts. All monitoring is optional and disabled by default.
        :param name: The name of the resource.
        :param tags: Tags to apply to the resource.
        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3c7442e9510fce65b844fde372cd7cc8a1a8f606ee9e9d3eca4760ff7a6dedc5)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = _DnsResolverProps_cee95b5b(
            virtual_network_id=virtual_network_id,
            ignore_changes=ignore_changes,
            resource_group_id=resource_group_id,
            api_version=api_version,
            enable_migration_analysis=enable_migration_analysis,
            enable_transformation=enable_transformation,
            enable_validation=enable_validation,
            location=location,
            monitoring=monitoring,
            name=name,
            tags=tags,
            connection=connection,
            count=count,
            depends_on=depends_on,
            for_each=for_each,
            lifecycle=lifecycle,
            provider=provider,
            provisioners=provisioners,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="addTag")
    def add_tag(self, key: builtins.str, value: builtins.str) -> None:
        '''Add a tag to the DNS Resolver.

        :param key: -
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__aeaa7c4898193896e5b1d278ad915ecf0c06fa46081241524f9c439652080940)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "addTag", [key, value]))

    @jsii.member(jsii_name="apiSchema")
    def _api_schema(self) -> _ApiSchema_5ce0490e:
        '''Gets the API schema for the resolved version.'''
        return typing.cast(_ApiSchema_5ce0490e, jsii.invoke(self, "apiSchema", []))

    @jsii.member(jsii_name="createResourceBody")
    def _create_resource_body(self, props: typing.Any) -> typing.Any:
        '''Creates the resource body for the Azure API call.

        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ff3c3d5e34bbfa210970579d63ed38b4c926ba97364bcd9cca1e05ef5a231219)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Any, jsii.invoke(self, "createResourceBody", [props]))

    @jsii.member(jsii_name="defaultVersion")
    def _default_version(self) -> builtins.str:
        '''Gets the default API version to use when no explicit version is specified.'''
        return typing.cast(builtins.str, jsii.invoke(self, "defaultVersion", []))

    @jsii.member(jsii_name="removeTag")
    def remove_tag(self, key: builtins.str) -> None:
        '''Remove a tag from the DNS Resolver.

        :param key: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3a0430449fc63d4ec11fe077562024e83fdec71b251b2d4c35eddf0ac4cd9934)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
        return typing.cast(None, jsii.invoke(self, "removeTag", [key]))

    @jsii.member(jsii_name="requiresLocation")
    def _requires_location(self) -> builtins.bool:
        '''Indicates that location is required for DNS Resolvers.'''
        return typing.cast(builtins.bool, jsii.invoke(self, "requiresLocation", []))

    @jsii.member(jsii_name="resourceType")
    def _resource_type(self) -> builtins.str:
        '''Gets the Azure resource type for DNS Resolvers.'''
        return typing.cast(builtins.str, jsii.invoke(self, "resourceType", []))

    @builtins.property
    @jsii.member(jsii_name="dnsResolverState")
    def dns_resolver_state(self) -> builtins.str:
        '''Get the state of the DNS Resolver Returns either "Connected" (resolver operational) or "Disconnected" (resolver not functioning).'''
        return typing.cast(builtins.str, jsii.get(self, "dnsResolverState"))

    @builtins.property
    @jsii.member(jsii_name="dnsResolverStateOutput")
    def dns_resolver_state_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "dnsResolverStateOutput"))

    @builtins.property
    @jsii.member(jsii_name="idOutput")
    def id_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "idOutput"))

    @builtins.property
    @jsii.member(jsii_name="locationOutput")
    def location_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "locationOutput"))

    @builtins.property
    @jsii.member(jsii_name="nameOutput")
    def name_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "nameOutput"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def props(self) -> _DnsResolverProps_cee95b5b:
        return typing.cast(_DnsResolverProps_cee95b5b, jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        '''Get the provisioning state of the DNS Resolver.'''
        return typing.cast(builtins.str, jsii.get(self, "provisioningState"))

    @builtins.property
    @jsii.member(jsii_name="provisioningStateOutput")
    def provisioning_state_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "provisioningStateOutput"))

    @builtins.property
    @jsii.member(jsii_name="resourceGuid")
    def resource_guid(self) -> builtins.str:
        '''Get the unique identifier for the DNS Resolver resource.'''
        return typing.cast(builtins.str, jsii.get(self, "resourceGuid"))

    @builtins.property
    @jsii.member(jsii_name="resourceGuidOutput")
    def resource_guid_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "resourceGuidOutput"))

    @builtins.property
    @jsii.member(jsii_name="tagsOutput")
    def tags_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "tagsOutput"))

    @builtins.property
    @jsii.member(jsii_name="virtualNetworkId")
    def virtual_network_id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "virtualNetworkId"))


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.DnsResolverBody",
    jsii_struct_bases=[],
    name_mapping={"location": "location", "properties": "properties", "tags": "tags"},
)
class DnsResolverBody:
    def __init__(
        self,
        *,
        location: builtins.str,
        properties: typing.Any = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''The resource body interface for Azure DNS Resolver API calls This matches the Azure REST API schema.

        :param location: 
        :param properties: 
        :param tags: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ad5e247fb3984fdc0f371c3ab66b41cfd24998c0f13397a25e48982f3142aec0)
            check_type(argname="argument location", value=location, expected_type=type_hints["location"])
            check_type(argname="argument properties", value=properties, expected_type=type_hints["properties"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "location": location,
        }
        if properties is not None:
            self._values["properties"] = properties
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def location(self) -> builtins.str:
        result = self._values.get("location")
        assert result is not None, "Required property 'location' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def properties(self) -> typing.Any:
        result = self._values.get("properties")
        return typing.cast(typing.Any, result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DnsResolverBody(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DnsResolverInboundEndpoint(
    _AzapiResource_7e7f5b39,
    metaclass=jsii.JSIIMeta,
    jsii_type="@microsoft/terraform-cdk-constructs.DnsResolverInboundEndpoint",
):
    '''Azure DNS Resolver Inbound Endpoint implementation.

    Inbound Endpoints allow external DNS servers (such as on-premises DNS servers)
    to query Azure-hosted DNS zones through the DNS Resolver. This enables hybrid
    DNS scenarios where external networks need to resolve Azure private DNS zones.

    Requirements:

    - Dedicated subnet between /28 and /24
    - Subnet must be delegated to Microsoft.Network/dnsResolvers
    - Must be in the same VNet as the parent DNS Resolver
    - Each DNS Resolver can have multiple inbound endpoints

    Example::

        // Inbound endpoint with tags and version pinning:
        const inboundEndpoint = new DnsResolverInboundEndpoint(this, "inbound-endpoint", {
          name: "my-inbound-endpoint",
          location: "eastus",
          dnsResolverId: dnsResolver.id,
          subnetId: inboundSubnet.id,
          tags: {
            environment: "production",
            purpose: "hybrid-dns"
          },
          apiVersion: "2022-07-01"
        });
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        dns_resolver_id: builtins.str,
        subnet_id: builtins.str,
        ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
        private_ip_address: typing.Optional[builtins.str] = None,
        private_ip_allocation_method: typing.Optional[builtins.str] = None,
        api_version: typing.Optional[builtins.str] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        location: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> None:
        '''Creates a new Azure DNS Resolver Inbound Endpoint using the AzapiResource framework.

        :param scope: - The scope in which to define this construct.
        :param id: - The unique identifier for this instance.
        :param dns_resolver_id: Resource ID of the parent DNS Resolver.
        :param subnet_id: Resource ID of the subnet where the Inbound Endpoint will be deployed Must be a dedicated subnet between /28 and /24 with delegation to Microsoft.Network/dnsResolvers.
        :param ignore_changes: The lifecycle rules to ignore changes.
        :param private_ip_address: The private IP address for DNS queries If not specified, an IP will be allocated dynamically from the subnet.
        :param private_ip_allocation_method: The IP allocation method - "Static": Use the specified privateIpAddress - "Dynamic": Automatically allocate an IP from the subnet. Default: "Dynamic"
        :param api_version: Explicit API version to use for this resource. If not specified, the latest active version will be automatically resolved. Use this for version pinning when stability is required over latest features. Default: Latest active version from ApiVersionManager
        :param enable_migration_analysis: Whether to enable migration analysis warnings. When true, the framework will analyze the current version for deprecation status and provide migration recommendations in the deployment output. Default: true
        :param enable_transformation: Whether to apply property transformations automatically. When true, properties will be automatically transformed according to the target schema's transformation rules. This enables backward compatibility. Default: true
        :param enable_validation: Whether to validate properties against the schema. When true, all properties will be validated against the API schema before resource creation. Validation errors will cause deployment failures. Default: true
        :param location: The location where the resource should be created. Default: Varies by resource type - see specific resource documentation
        :param monitoring: Monitoring configuration for this resource. Enables integrated monitoring with diagnostic settings, metric alerts, and activity log alerts. All monitoring is optional and disabled by default.
        :param name: The name of the resource.
        :param tags: Tags to apply to the resource.
        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9a901647f22f035f96463234e2080c4ee07bdd60bc4810c43ef0ea817f170419)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = _DnsResolverInboundEndpointProps_cae29fa2(
            dns_resolver_id=dns_resolver_id,
            subnet_id=subnet_id,
            ignore_changes=ignore_changes,
            private_ip_address=private_ip_address,
            private_ip_allocation_method=private_ip_allocation_method,
            api_version=api_version,
            enable_migration_analysis=enable_migration_analysis,
            enable_transformation=enable_transformation,
            enable_validation=enable_validation,
            location=location,
            monitoring=monitoring,
            name=name,
            tags=tags,
            connection=connection,
            count=count,
            depends_on=depends_on,
            for_each=for_each,
            lifecycle=lifecycle,
            provider=provider,
            provisioners=provisioners,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="addTag")
    def add_tag(self, key: builtins.str, value: builtins.str) -> None:
        '''Add a tag to the Inbound Endpoint.

        :param key: -
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1c7f9fb1309f6da100e276138cf149a6d8ccd81248180fca8c522a507c35ebb3)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "addTag", [key, value]))

    @jsii.member(jsii_name="apiSchema")
    def _api_schema(self) -> _ApiSchema_5ce0490e:
        '''Gets the API schema for the resolved version.'''
        return typing.cast(_ApiSchema_5ce0490e, jsii.invoke(self, "apiSchema", []))

    @jsii.member(jsii_name="createResourceBody")
    def _create_resource_body(self, props: typing.Any) -> typing.Any:
        '''Creates the resource body for the Azure API call.

        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3283ce810a8da2fbb9d6e3878fb747372871d36b8ec1c6d62c4045f9174852c5)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Any, jsii.invoke(self, "createResourceBody", [props]))

    @jsii.member(jsii_name="defaultVersion")
    def _default_version(self) -> builtins.str:
        '''Gets the default API version to use when no explicit version is specified.'''
        return typing.cast(builtins.str, jsii.invoke(self, "defaultVersion", []))

    @jsii.member(jsii_name="removeTag")
    def remove_tag(self, key: builtins.str) -> None:
        '''Remove a tag from the Inbound Endpoint.

        :param key: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ef97a4822ba45c9cc177ac912041a467e75d3ce4c8cf3dc155eeb25139f1ab15)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
        return typing.cast(None, jsii.invoke(self, "removeTag", [key]))

    @jsii.member(jsii_name="requiresLocation")
    def _requires_location(self) -> builtins.bool:
        '''Indicates that location is required for Inbound Endpoints.'''
        return typing.cast(builtins.bool, jsii.invoke(self, "requiresLocation", []))

    @jsii.member(jsii_name="resolveParentId")
    def _resolve_parent_id(self, props: typing.Any) -> builtins.str:
        '''Resolves the parent resource ID for the Inbound Endpoint Inbound Endpoints are child resources of DNS Resolvers.

        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__66f8a7a71a1bea270ad689eabbb36dca95b84a9d7c5b41fcce2499d0fdc98b0c)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(builtins.str, jsii.invoke(self, "resolveParentId", [props]))

    @jsii.member(jsii_name="resourceType")
    def _resource_type(self) -> builtins.str:
        '''Gets the Azure resource type for Inbound Endpoints.'''
        return typing.cast(builtins.str, jsii.invoke(self, "resourceType", []))

    @builtins.property
    @jsii.member(jsii_name="idOutput")
    def id_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "idOutput"))

    @builtins.property
    @jsii.member(jsii_name="locationOutput")
    def location_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "locationOutput"))

    @builtins.property
    @jsii.member(jsii_name="nameOutput")
    def name_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "nameOutput"))

    @builtins.property
    @jsii.member(jsii_name="privateIpAddress")
    def private_ip_address(self) -> builtins.str:
        '''Get the private IP address Returns the input value for static IPs, or empty string if dynamic.'''
        return typing.cast(builtins.str, jsii.get(self, "privateIpAddress"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def props(self) -> _DnsResolverInboundEndpointProps_cae29fa2:
        '''The input properties for this Inbound Endpoint instance.'''
        return typing.cast(_DnsResolverInboundEndpointProps_cae29fa2, jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        '''Get the provisioning state of the Inbound Endpoint.'''
        return typing.cast(builtins.str, jsii.get(self, "provisioningState"))

    @builtins.property
    @jsii.member(jsii_name="provisioningStateOutput")
    def provisioning_state_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "provisioningStateOutput"))

    @builtins.property
    @jsii.member(jsii_name="subnetId")
    def subnet_id(self) -> builtins.str:
        '''Get the subnet ID Returns the input value as Azure API doesn't return nested subnet structure reliably.'''
        return typing.cast(builtins.str, jsii.get(self, "subnetId"))

    @builtins.property
    @jsii.member(jsii_name="tagsOutput")
    def tags_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "tagsOutput"))


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.DnsResolverInboundEndpointBody",
    jsii_struct_bases=[],
    name_mapping={"location": "location", "properties": "properties", "tags": "tags"},
)
class DnsResolverInboundEndpointBody:
    def __init__(
        self,
        *,
        location: builtins.str,
        properties: typing.Any = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''The resource body interface for Azure Inbound Endpoint API calls This matches the Azure REST API schema.

        :param location: 
        :param properties: 
        :param tags: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__33df3464fcafe1dd8635001f474671d784e4c52fabc025b14c548e939036614b)
            check_type(argname="argument location", value=location, expected_type=type_hints["location"])
            check_type(argname="argument properties", value=properties, expected_type=type_hints["properties"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "location": location,
        }
        if properties is not None:
            self._values["properties"] = properties
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def location(self) -> builtins.str:
        result = self._values.get("location")
        assert result is not None, "Required property 'location' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def properties(self) -> typing.Any:
        result = self._values.get("properties")
        return typing.cast(typing.Any, result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DnsResolverInboundEndpointBody(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.DnsResolverInboundEndpointProps",
    jsii_struct_bases=[_AzapiResourceProps_141a2340],
    name_mapping={
        "connection": "connection",
        "count": "count",
        "depends_on": "dependsOn",
        "for_each": "forEach",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "provisioners": "provisioners",
        "api_version": "apiVersion",
        "enable_migration_analysis": "enableMigrationAnalysis",
        "enable_transformation": "enableTransformation",
        "enable_validation": "enableValidation",
        "location": "location",
        "monitoring": "monitoring",
        "name": "name",
        "tags": "tags",
        "dns_resolver_id": "dnsResolverId",
        "subnet_id": "subnetId",
        "ignore_changes": "ignoreChanges",
        "private_ip_address": "privateIpAddress",
        "private_ip_allocation_method": "privateIpAllocationMethod",
    },
)
class DnsResolverInboundEndpointProps(_AzapiResourceProps_141a2340):
    def __init__(
        self,
        *,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
        api_version: typing.Optional[builtins.str] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        location: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        dns_resolver_id: builtins.str,
        subnet_id: builtins.str,
        ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
        private_ip_address: typing.Optional[builtins.str] = None,
        private_ip_allocation_method: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for the Azure DNS Resolver Inbound Endpoint.

        Extends AzapiResourceProps with Inbound Endpoint specific properties

        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        :param api_version: Explicit API version to use for this resource. If not specified, the latest active version will be automatically resolved. Use this for version pinning when stability is required over latest features. Default: Latest active version from ApiVersionManager
        :param enable_migration_analysis: Whether to enable migration analysis warnings. When true, the framework will analyze the current version for deprecation status and provide migration recommendations in the deployment output. Default: true
        :param enable_transformation: Whether to apply property transformations automatically. When true, properties will be automatically transformed according to the target schema's transformation rules. This enables backward compatibility. Default: true
        :param enable_validation: Whether to validate properties against the schema. When true, all properties will be validated against the API schema before resource creation. Validation errors will cause deployment failures. Default: true
        :param location: The location where the resource should be created. Default: Varies by resource type - see specific resource documentation
        :param monitoring: Monitoring configuration for this resource. Enables integrated monitoring with diagnostic settings, metric alerts, and activity log alerts. All monitoring is optional and disabled by default.
        :param name: The name of the resource.
        :param tags: Tags to apply to the resource.
        :param dns_resolver_id: Resource ID of the parent DNS Resolver.
        :param subnet_id: Resource ID of the subnet where the Inbound Endpoint will be deployed Must be a dedicated subnet between /28 and /24 with delegation to Microsoft.Network/dnsResolvers.
        :param ignore_changes: The lifecycle rules to ignore changes.
        :param private_ip_address: The private IP address for DNS queries If not specified, an IP will be allocated dynamically from the subnet.
        :param private_ip_allocation_method: The IP allocation method - "Static": Use the specified privateIpAddress - "Dynamic": Automatically allocate an IP from the subnet. Default: "Dynamic"
        '''
        if isinstance(lifecycle, dict):
            lifecycle = _cdktf_9a9027ec.TerraformResourceLifecycle(**lifecycle)
        if isinstance(monitoring, dict):
            monitoring = _MonitoringConfig_7c28df74(**monitoring)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a147c7794712e3bc50425e2346ba0cb5ce36bd56cc4f3e09ec9ccfd6bcbfb6b8)
            check_type(argname="argument connection", value=connection, expected_type=type_hints["connection"])
            check_type(argname="argument count", value=count, expected_type=type_hints["count"])
            check_type(argname="argument depends_on", value=depends_on, expected_type=type_hints["depends_on"])
            check_type(argname="argument for_each", value=for_each, expected_type=type_hints["for_each"])
            check_type(argname="argument lifecycle", value=lifecycle, expected_type=type_hints["lifecycle"])
            check_type(argname="argument provider", value=provider, expected_type=type_hints["provider"])
            check_type(argname="argument provisioners", value=provisioners, expected_type=type_hints["provisioners"])
            check_type(argname="argument api_version", value=api_version, expected_type=type_hints["api_version"])
            check_type(argname="argument enable_migration_analysis", value=enable_migration_analysis, expected_type=type_hints["enable_migration_analysis"])
            check_type(argname="argument enable_transformation", value=enable_transformation, expected_type=type_hints["enable_transformation"])
            check_type(argname="argument enable_validation", value=enable_validation, expected_type=type_hints["enable_validation"])
            check_type(argname="argument location", value=location, expected_type=type_hints["location"])
            check_type(argname="argument monitoring", value=monitoring, expected_type=type_hints["monitoring"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument dns_resolver_id", value=dns_resolver_id, expected_type=type_hints["dns_resolver_id"])
            check_type(argname="argument subnet_id", value=subnet_id, expected_type=type_hints["subnet_id"])
            check_type(argname="argument ignore_changes", value=ignore_changes, expected_type=type_hints["ignore_changes"])
            check_type(argname="argument private_ip_address", value=private_ip_address, expected_type=type_hints["private_ip_address"])
            check_type(argname="argument private_ip_allocation_method", value=private_ip_allocation_method, expected_type=type_hints["private_ip_allocation_method"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "dns_resolver_id": dns_resolver_id,
            "subnet_id": subnet_id,
        }
        if connection is not None:
            self._values["connection"] = connection
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if for_each is not None:
            self._values["for_each"] = for_each
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider
        if provisioners is not None:
            self._values["provisioners"] = provisioners
        if api_version is not None:
            self._values["api_version"] = api_version
        if enable_migration_analysis is not None:
            self._values["enable_migration_analysis"] = enable_migration_analysis
        if enable_transformation is not None:
            self._values["enable_transformation"] = enable_transformation
        if enable_validation is not None:
            self._values["enable_validation"] = enable_validation
        if location is not None:
            self._values["location"] = location
        if monitoring is not None:
            self._values["monitoring"] = monitoring
        if name is not None:
            self._values["name"] = name
        if tags is not None:
            self._values["tags"] = tags
        if ignore_changes is not None:
            self._values["ignore_changes"] = ignore_changes
        if private_ip_address is not None:
            self._values["private_ip_address"] = private_ip_address
        if private_ip_allocation_method is not None:
            self._values["private_ip_allocation_method"] = private_ip_allocation_method

    @builtins.property
    def connection(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("connection")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]], result)

    @builtins.property
    def count(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]], result)

    @builtins.property
    def depends_on(
        self,
    ) -> typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]], result)

    @builtins.property
    def for_each(self) -> typing.Optional[_cdktf_9a9027ec.ITerraformIterator]:
        '''
        :stability: experimental
        '''
        result = self._values.get("for_each")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.ITerraformIterator], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[_cdktf_9a9027ec.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformProvider], result)

    @builtins.property
    def provisioners(
        self,
    ) -> typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provisioners")
        return typing.cast(typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]], result)

    @builtins.property
    def api_version(self) -> typing.Optional[builtins.str]:
        '''Explicit API version to use for this resource.

        If not specified, the latest active version will be automatically resolved.
        Use this for version pinning when stability is required over latest features.

        :default: Latest active version from ApiVersionManager

        Example::

            "2024-11-01"
        '''
        result = self._values.get("api_version")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def enable_migration_analysis(self) -> typing.Optional[builtins.bool]:
        '''Whether to enable migration analysis warnings.

        When true, the framework will analyze the current version for deprecation
        status and provide migration recommendations in the deployment output.

        :default: true
        '''
        result = self._values.get("enable_migration_analysis")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_transformation(self) -> typing.Optional[builtins.bool]:
        '''Whether to apply property transformations automatically.

        When true, properties will be automatically transformed according to the
        target schema's transformation rules. This enables backward compatibility.

        :default: true
        '''
        result = self._values.get("enable_transformation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_validation(self) -> typing.Optional[builtins.bool]:
        '''Whether to validate properties against the schema.

        When true, all properties will be validated against the API schema before
        resource creation. Validation errors will cause deployment failures.

        :default: true
        '''
        result = self._values.get("enable_validation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def location(self) -> typing.Optional[builtins.str]:
        '''The location where the resource should be created.

        :default: Varies by resource type - see specific resource documentation

        :remarks:

        Location handling varies by resource type:

        - **Top-level resources**: Most require an explicit location (e.g., "eastus", "westus")
        - **Global resources**: Some use "global" as location (e.g., Private DNS Zones)
        - **Child resources**: Inherit location from parent and should NOT set this property

        Each resource type may provide its own default through the ``resolveLocation()`` method.
        If no location is specified and no default exists, resource creation may fail.

        Example::

            // Child resource (Subnet) - do not set location
            // location: undefined (inherited from parent Virtual Network)
        '''
        result = self._values.get("location")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def monitoring(self) -> typing.Optional[_MonitoringConfig_7c28df74]:
        '''Monitoring configuration for this resource.

        Enables integrated monitoring with diagnostic settings, metric alerts,
        and activity log alerts. All monitoring is optional and disabled by default.

        Example::

            monitoring: {
              enabled: true,
              diagnosticSettings: {
                workspaceId: logAnalytics.id,
                metrics: ['AllMetrics'],
                logs: ['AuditLogs']
              },
              metricAlerts: [{
                name: 'high-cpu-alert',
                severity: 2,
                scopes: [], // Automatically set to this resource
                criteria: { ... },
                actions: [{ actionGroupId: actionGroup.id }]
              }]
            }
        '''
        result = self._values.get("monitoring")
        return typing.cast(typing.Optional[_MonitoringConfig_7c28df74], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the resource.'''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Tags to apply to the resource.'''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def dns_resolver_id(self) -> builtins.str:
        '''Resource ID of the parent DNS Resolver.

        Example::

            "/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/rg/providers/Microsoft.Network/dnsResolvers/my-resolver"
        '''
        result = self._values.get("dns_resolver_id")
        assert result is not None, "Required property 'dns_resolver_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def subnet_id(self) -> builtins.str:
        '''Resource ID of the subnet where the Inbound Endpoint will be deployed Must be a dedicated subnet between /28 and /24 with delegation to Microsoft.Network/dnsResolvers.

        Example::

            "/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/rg/providers/Microsoft.Network/virtualNetworks/vnet/subnets/inbound-subnet"
        '''
        result = self._values.get("subnet_id")
        assert result is not None, "Required property 'subnet_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def ignore_changes(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The lifecycle rules to ignore changes.

        Example::

            ["tags"]
        '''
        result = self._values.get("ignore_changes")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def private_ip_address(self) -> typing.Optional[builtins.str]:
        '''The private IP address for DNS queries If not specified, an IP will be allocated dynamically from the subnet.

        Example::

            "10.0.1.4"
        '''
        result = self._values.get("private_ip_address")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def private_ip_allocation_method(self) -> typing.Optional[builtins.str]:
        '''The IP allocation method - "Static": Use the specified privateIpAddress - "Dynamic": Automatically allocate an IP from the subnet.

        :default: "Dynamic"
        '''
        result = self._values.get("private_ip_allocation_method")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DnsResolverInboundEndpointProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DnsResolverOutboundEndpoint(
    _AzapiResource_7e7f5b39,
    metaclass=jsii.JSIIMeta,
    jsii_type="@microsoft/terraform-cdk-constructs.DnsResolverOutboundEndpoint",
):
    '''Azure DNS Resolver Outbound Endpoint implementation.

    Outbound Endpoints enable Azure resources to forward DNS queries to external DNS servers
    (such as on-premises DNS servers). This enables hybrid DNS scenarios where Azure resources
    need to resolve names from external DNS zones.

    Requirements:

    - Dedicated subnet between /28 and /24
    - Subnet must be delegated to Microsoft.Network/dnsResolvers
    - Must be in the same VNet as the parent DNS Resolver
    - Each DNS Resolver can have multiple outbound endpoints
    - Outbound endpoints are used with forwarding rules to specify which queries to forward

    Example::

        // Outbound endpoint with version pinning:
        const outboundEndpoint = new DnsResolverOutboundEndpoint(this, "outbound-endpoint", {
          name: "my-outbound-endpoint",
          location: "eastus",
          dnsResolverId: dnsResolver.id,
          subnetId: outboundSubnet.id,
          apiVersion: "2022-07-01"
        });
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        dns_resolver_id: builtins.str,
        subnet_id: builtins.str,
        ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
        api_version: typing.Optional[builtins.str] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        location: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> None:
        '''Creates a new Azure DNS Resolver Outbound Endpoint using the AzapiResource framework.

        :param scope: - The scope in which to define this construct.
        :param id: - The unique identifier for this instance.
        :param dns_resolver_id: Resource ID of the parent DNS Resolver.
        :param subnet_id: Resource ID of the subnet where the Outbound Endpoint will be deployed Must be a dedicated subnet between /28 and /24 with delegation to Microsoft.Network/dnsResolvers.
        :param ignore_changes: The lifecycle rules to ignore changes.
        :param api_version: Explicit API version to use for this resource. If not specified, the latest active version will be automatically resolved. Use this for version pinning when stability is required over latest features. Default: Latest active version from ApiVersionManager
        :param enable_migration_analysis: Whether to enable migration analysis warnings. When true, the framework will analyze the current version for deprecation status and provide migration recommendations in the deployment output. Default: true
        :param enable_transformation: Whether to apply property transformations automatically. When true, properties will be automatically transformed according to the target schema's transformation rules. This enables backward compatibility. Default: true
        :param enable_validation: Whether to validate properties against the schema. When true, all properties will be validated against the API schema before resource creation. Validation errors will cause deployment failures. Default: true
        :param location: The location where the resource should be created. Default: Varies by resource type - see specific resource documentation
        :param monitoring: Monitoring configuration for this resource. Enables integrated monitoring with diagnostic settings, metric alerts, and activity log alerts. All monitoring is optional and disabled by default.
        :param name: The name of the resource.
        :param tags: Tags to apply to the resource.
        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5eebe8817bdacd476de7a5fd806dee8b0caeb5eb9524a6581fa3c24168110996)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = _DnsResolverOutboundEndpointProps_a59b4be2(
            dns_resolver_id=dns_resolver_id,
            subnet_id=subnet_id,
            ignore_changes=ignore_changes,
            api_version=api_version,
            enable_migration_analysis=enable_migration_analysis,
            enable_transformation=enable_transformation,
            enable_validation=enable_validation,
            location=location,
            monitoring=monitoring,
            name=name,
            tags=tags,
            connection=connection,
            count=count,
            depends_on=depends_on,
            for_each=for_each,
            lifecycle=lifecycle,
            provider=provider,
            provisioners=provisioners,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="addTag")
    def add_tag(self, key: builtins.str, value: builtins.str) -> None:
        '''Add a tag to the Outbound Endpoint.

        :param key: -
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3d15a3ee5f3ab6164e072033f6111414072eb73b63efc5a8525d5cc886b1bab3)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "addTag", [key, value]))

    @jsii.member(jsii_name="apiSchema")
    def _api_schema(self) -> _ApiSchema_5ce0490e:
        '''Gets the API schema for the resolved version.'''
        return typing.cast(_ApiSchema_5ce0490e, jsii.invoke(self, "apiSchema", []))

    @jsii.member(jsii_name="createResourceBody")
    def _create_resource_body(self, props: typing.Any) -> typing.Any:
        '''Creates the resource body for the Azure API call.

        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__87c147165896c4ecd2ee526f8de682c101bed21b358fd3b32ec2dd06a0226dc2)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Any, jsii.invoke(self, "createResourceBody", [props]))

    @jsii.member(jsii_name="defaultVersion")
    def _default_version(self) -> builtins.str:
        '''Gets the default API version to use when no explicit version is specified.'''
        return typing.cast(builtins.str, jsii.invoke(self, "defaultVersion", []))

    @jsii.member(jsii_name="removeTag")
    def remove_tag(self, key: builtins.str) -> None:
        '''Remove a tag from the Outbound Endpoint.

        :param key: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e6d7455f4f9b9651f6c968ba166fd8ec1476e1eca481cc9133aae4f67c1edb29)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
        return typing.cast(None, jsii.invoke(self, "removeTag", [key]))

    @jsii.member(jsii_name="requiresLocation")
    def _requires_location(self) -> builtins.bool:
        '''Indicates that location is required for Outbound Endpoints.'''
        return typing.cast(builtins.bool, jsii.invoke(self, "requiresLocation", []))

    @jsii.member(jsii_name="resolveParentId")
    def _resolve_parent_id(self, props: typing.Any) -> builtins.str:
        '''Resolves the parent resource ID for the Outbound Endpoint Outbound Endpoints are child resources of DNS Resolvers.

        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c07ed0deadbd7dd61e1f2ff2f2fd4a2622fdaa0a97a4f2dd5e3c5b9e9994c1ea)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(builtins.str, jsii.invoke(self, "resolveParentId", [props]))

    @jsii.member(jsii_name="resourceType")
    def _resource_type(self) -> builtins.str:
        '''Gets the Azure resource type for Outbound Endpoints.'''
        return typing.cast(builtins.str, jsii.invoke(self, "resourceType", []))

    @builtins.property
    @jsii.member(jsii_name="idOutput")
    def id_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "idOutput"))

    @builtins.property
    @jsii.member(jsii_name="locationOutput")
    def location_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "locationOutput"))

    @builtins.property
    @jsii.member(jsii_name="nameOutput")
    def name_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "nameOutput"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def props(self) -> _DnsResolverOutboundEndpointProps_a59b4be2:
        '''The input properties for this Outbound Endpoint instance.'''
        return typing.cast(_DnsResolverOutboundEndpointProps_a59b4be2, jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        '''Get the provisioning state of the Outbound Endpoint.'''
        return typing.cast(builtins.str, jsii.get(self, "provisioningState"))

    @builtins.property
    @jsii.member(jsii_name="provisioningStateOutput")
    def provisioning_state_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "provisioningStateOutput"))

    @builtins.property
    @jsii.member(jsii_name="resourceGuid")
    def resource_guid(self) -> builtins.str:
        '''Get the unique identifier for the Outbound Endpoint.'''
        return typing.cast(builtins.str, jsii.get(self, "resourceGuid"))

    @builtins.property
    @jsii.member(jsii_name="resourceGuidOutput")
    def resource_guid_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "resourceGuidOutput"))

    @builtins.property
    @jsii.member(jsii_name="subnetId")
    def subnet_id(self) -> builtins.str:
        '''Get the subnet ID Returns the input value as Azure API doesn't return nested subnet structure reliably.'''
        return typing.cast(builtins.str, jsii.get(self, "subnetId"))

    @builtins.property
    @jsii.member(jsii_name="tagsOutput")
    def tags_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "tagsOutput"))


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.DnsResolverOutboundEndpointBody",
    jsii_struct_bases=[],
    name_mapping={"location": "location", "properties": "properties", "tags": "tags"},
)
class DnsResolverOutboundEndpointBody:
    def __init__(
        self,
        *,
        location: builtins.str,
        properties: typing.Any = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''The resource body interface for Azure Outbound Endpoint API calls This matches the Azure REST API schema.

        :param location: 
        :param properties: 
        :param tags: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a8cb7b0ca5706826db06ce43de5fa28f9be4f3a3e0e60a7829dbdcd31c732cf2)
            check_type(argname="argument location", value=location, expected_type=type_hints["location"])
            check_type(argname="argument properties", value=properties, expected_type=type_hints["properties"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "location": location,
        }
        if properties is not None:
            self._values["properties"] = properties
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def location(self) -> builtins.str:
        result = self._values.get("location")
        assert result is not None, "Required property 'location' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def properties(self) -> typing.Any:
        result = self._values.get("properties")
        return typing.cast(typing.Any, result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DnsResolverOutboundEndpointBody(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.DnsResolverOutboundEndpointProps",
    jsii_struct_bases=[_AzapiResourceProps_141a2340],
    name_mapping={
        "connection": "connection",
        "count": "count",
        "depends_on": "dependsOn",
        "for_each": "forEach",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "provisioners": "provisioners",
        "api_version": "apiVersion",
        "enable_migration_analysis": "enableMigrationAnalysis",
        "enable_transformation": "enableTransformation",
        "enable_validation": "enableValidation",
        "location": "location",
        "monitoring": "monitoring",
        "name": "name",
        "tags": "tags",
        "dns_resolver_id": "dnsResolverId",
        "subnet_id": "subnetId",
        "ignore_changes": "ignoreChanges",
    },
)
class DnsResolverOutboundEndpointProps(_AzapiResourceProps_141a2340):
    def __init__(
        self,
        *,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
        api_version: typing.Optional[builtins.str] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        location: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        dns_resolver_id: builtins.str,
        subnet_id: builtins.str,
        ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''Properties for the Azure DNS Resolver Outbound Endpoint.

        Extends AzapiResourceProps with Outbound Endpoint specific properties

        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        :param api_version: Explicit API version to use for this resource. If not specified, the latest active version will be automatically resolved. Use this for version pinning when stability is required over latest features. Default: Latest active version from ApiVersionManager
        :param enable_migration_analysis: Whether to enable migration analysis warnings. When true, the framework will analyze the current version for deprecation status and provide migration recommendations in the deployment output. Default: true
        :param enable_transformation: Whether to apply property transformations automatically. When true, properties will be automatically transformed according to the target schema's transformation rules. This enables backward compatibility. Default: true
        :param enable_validation: Whether to validate properties against the schema. When true, all properties will be validated against the API schema before resource creation. Validation errors will cause deployment failures. Default: true
        :param location: The location where the resource should be created. Default: Varies by resource type - see specific resource documentation
        :param monitoring: Monitoring configuration for this resource. Enables integrated monitoring with diagnostic settings, metric alerts, and activity log alerts. All monitoring is optional and disabled by default.
        :param name: The name of the resource.
        :param tags: Tags to apply to the resource.
        :param dns_resolver_id: Resource ID of the parent DNS Resolver.
        :param subnet_id: Resource ID of the subnet where the Outbound Endpoint will be deployed Must be a dedicated subnet between /28 and /24 with delegation to Microsoft.Network/dnsResolvers.
        :param ignore_changes: The lifecycle rules to ignore changes.
        '''
        if isinstance(lifecycle, dict):
            lifecycle = _cdktf_9a9027ec.TerraformResourceLifecycle(**lifecycle)
        if isinstance(monitoring, dict):
            monitoring = _MonitoringConfig_7c28df74(**monitoring)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bc086e7c010bdfc5521087a817616cfd80ee9f96c8b843ee0709104c483b92df)
            check_type(argname="argument connection", value=connection, expected_type=type_hints["connection"])
            check_type(argname="argument count", value=count, expected_type=type_hints["count"])
            check_type(argname="argument depends_on", value=depends_on, expected_type=type_hints["depends_on"])
            check_type(argname="argument for_each", value=for_each, expected_type=type_hints["for_each"])
            check_type(argname="argument lifecycle", value=lifecycle, expected_type=type_hints["lifecycle"])
            check_type(argname="argument provider", value=provider, expected_type=type_hints["provider"])
            check_type(argname="argument provisioners", value=provisioners, expected_type=type_hints["provisioners"])
            check_type(argname="argument api_version", value=api_version, expected_type=type_hints["api_version"])
            check_type(argname="argument enable_migration_analysis", value=enable_migration_analysis, expected_type=type_hints["enable_migration_analysis"])
            check_type(argname="argument enable_transformation", value=enable_transformation, expected_type=type_hints["enable_transformation"])
            check_type(argname="argument enable_validation", value=enable_validation, expected_type=type_hints["enable_validation"])
            check_type(argname="argument location", value=location, expected_type=type_hints["location"])
            check_type(argname="argument monitoring", value=monitoring, expected_type=type_hints["monitoring"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument dns_resolver_id", value=dns_resolver_id, expected_type=type_hints["dns_resolver_id"])
            check_type(argname="argument subnet_id", value=subnet_id, expected_type=type_hints["subnet_id"])
            check_type(argname="argument ignore_changes", value=ignore_changes, expected_type=type_hints["ignore_changes"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "dns_resolver_id": dns_resolver_id,
            "subnet_id": subnet_id,
        }
        if connection is not None:
            self._values["connection"] = connection
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if for_each is not None:
            self._values["for_each"] = for_each
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider
        if provisioners is not None:
            self._values["provisioners"] = provisioners
        if api_version is not None:
            self._values["api_version"] = api_version
        if enable_migration_analysis is not None:
            self._values["enable_migration_analysis"] = enable_migration_analysis
        if enable_transformation is not None:
            self._values["enable_transformation"] = enable_transformation
        if enable_validation is not None:
            self._values["enable_validation"] = enable_validation
        if location is not None:
            self._values["location"] = location
        if monitoring is not None:
            self._values["monitoring"] = monitoring
        if name is not None:
            self._values["name"] = name
        if tags is not None:
            self._values["tags"] = tags
        if ignore_changes is not None:
            self._values["ignore_changes"] = ignore_changes

    @builtins.property
    def connection(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("connection")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]], result)

    @builtins.property
    def count(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]], result)

    @builtins.property
    def depends_on(
        self,
    ) -> typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]], result)

    @builtins.property
    def for_each(self) -> typing.Optional[_cdktf_9a9027ec.ITerraformIterator]:
        '''
        :stability: experimental
        '''
        result = self._values.get("for_each")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.ITerraformIterator], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[_cdktf_9a9027ec.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformProvider], result)

    @builtins.property
    def provisioners(
        self,
    ) -> typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provisioners")
        return typing.cast(typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]], result)

    @builtins.property
    def api_version(self) -> typing.Optional[builtins.str]:
        '''Explicit API version to use for this resource.

        If not specified, the latest active version will be automatically resolved.
        Use this for version pinning when stability is required over latest features.

        :default: Latest active version from ApiVersionManager

        Example::

            "2024-11-01"
        '''
        result = self._values.get("api_version")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def enable_migration_analysis(self) -> typing.Optional[builtins.bool]:
        '''Whether to enable migration analysis warnings.

        When true, the framework will analyze the current version for deprecation
        status and provide migration recommendations in the deployment output.

        :default: true
        '''
        result = self._values.get("enable_migration_analysis")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_transformation(self) -> typing.Optional[builtins.bool]:
        '''Whether to apply property transformations automatically.

        When true, properties will be automatically transformed according to the
        target schema's transformation rules. This enables backward compatibility.

        :default: true
        '''
        result = self._values.get("enable_transformation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_validation(self) -> typing.Optional[builtins.bool]:
        '''Whether to validate properties against the schema.

        When true, all properties will be validated against the API schema before
        resource creation. Validation errors will cause deployment failures.

        :default: true
        '''
        result = self._values.get("enable_validation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def location(self) -> typing.Optional[builtins.str]:
        '''The location where the resource should be created.

        :default: Varies by resource type - see specific resource documentation

        :remarks:

        Location handling varies by resource type:

        - **Top-level resources**: Most require an explicit location (e.g., "eastus", "westus")
        - **Global resources**: Some use "global" as location (e.g., Private DNS Zones)
        - **Child resources**: Inherit location from parent and should NOT set this property

        Each resource type may provide its own default through the ``resolveLocation()`` method.
        If no location is specified and no default exists, resource creation may fail.

        Example::

            // Child resource (Subnet) - do not set location
            // location: undefined (inherited from parent Virtual Network)
        '''
        result = self._values.get("location")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def monitoring(self) -> typing.Optional[_MonitoringConfig_7c28df74]:
        '''Monitoring configuration for this resource.

        Enables integrated monitoring with diagnostic settings, metric alerts,
        and activity log alerts. All monitoring is optional and disabled by default.

        Example::

            monitoring: {
              enabled: true,
              diagnosticSettings: {
                workspaceId: logAnalytics.id,
                metrics: ['AllMetrics'],
                logs: ['AuditLogs']
              },
              metricAlerts: [{
                name: 'high-cpu-alert',
                severity: 2,
                scopes: [], // Automatically set to this resource
                criteria: { ... },
                actions: [{ actionGroupId: actionGroup.id }]
              }]
            }
        '''
        result = self._values.get("monitoring")
        return typing.cast(typing.Optional[_MonitoringConfig_7c28df74], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the resource.'''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Tags to apply to the resource.'''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def dns_resolver_id(self) -> builtins.str:
        '''Resource ID of the parent DNS Resolver.

        Example::

            "/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/rg/providers/Microsoft.Network/dnsResolvers/my-resolver"
        '''
        result = self._values.get("dns_resolver_id")
        assert result is not None, "Required property 'dns_resolver_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def subnet_id(self) -> builtins.str:
        '''Resource ID of the subnet where the Outbound Endpoint will be deployed Must be a dedicated subnet between /28 and /24 with delegation to Microsoft.Network/dnsResolvers.

        Example::

            "/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/rg/providers/Microsoft.Network/virtualNetworks/vnet/subnets/outbound-subnet"
        '''
        result = self._values.get("subnet_id")
        assert result is not None, "Required property 'subnet_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def ignore_changes(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The lifecycle rules to ignore changes.

        Example::

            ["tags"]
        '''
        result = self._values.get("ignore_changes")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DnsResolverOutboundEndpointProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.DnsResolverOutboundEndpointReference",
    jsii_struct_bases=[],
    name_mapping={"id": "id"},
)
class DnsResolverOutboundEndpointReference:
    def __init__(self, *, id: builtins.str) -> None:
        '''DNS Resolver Outbound Endpoint reference.

        :param id: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2c53eca7cf4e5bf300890582b96e0fde622b84dacd342dfc89043c36a9875ac2)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "id": id,
        }

    @builtins.property
    def id(self) -> builtins.str:
        result = self._values.get("id")
        assert result is not None, "Required property 'id' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DnsResolverOutboundEndpointReference(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.DnsResolverProps",
    jsii_struct_bases=[_AzapiResourceProps_141a2340],
    name_mapping={
        "connection": "connection",
        "count": "count",
        "depends_on": "dependsOn",
        "for_each": "forEach",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "provisioners": "provisioners",
        "api_version": "apiVersion",
        "enable_migration_analysis": "enableMigrationAnalysis",
        "enable_transformation": "enableTransformation",
        "enable_validation": "enableValidation",
        "location": "location",
        "monitoring": "monitoring",
        "name": "name",
        "tags": "tags",
        "virtual_network_id": "virtualNetworkId",
        "ignore_changes": "ignoreChanges",
        "resource_group_id": "resourceGroupId",
    },
)
class DnsResolverProps(_AzapiResourceProps_141a2340):
    def __init__(
        self,
        *,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
        api_version: typing.Optional[builtins.str] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        location: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        virtual_network_id: builtins.str,
        ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
        resource_group_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for the unified Azure DNS Resolver.

        Extends AzapiResourceProps with DNS Resolver specific properties

        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        :param api_version: Explicit API version to use for this resource. If not specified, the latest active version will be automatically resolved. Use this for version pinning when stability is required over latest features. Default: Latest active version from ApiVersionManager
        :param enable_migration_analysis: Whether to enable migration analysis warnings. When true, the framework will analyze the current version for deprecation status and provide migration recommendations in the deployment output. Default: true
        :param enable_transformation: Whether to apply property transformations automatically. When true, properties will be automatically transformed according to the target schema's transformation rules. This enables backward compatibility. Default: true
        :param enable_validation: Whether to validate properties against the schema. When true, all properties will be validated against the API schema before resource creation. Validation errors will cause deployment failures. Default: true
        :param location: The location where the resource should be created. Default: Varies by resource type - see specific resource documentation
        :param monitoring: Monitoring configuration for this resource. Enables integrated monitoring with diagnostic settings, metric alerts, and activity log alerts. All monitoring is optional and disabled by default.
        :param name: The name of the resource.
        :param tags: Tags to apply to the resource.
        :param virtual_network_id: The resource ID of the virtual network where the DNS Resolver will be deployed The resolver requires a dedicated subnet with delegation to Microsoft.Network/dnsResolvers.
        :param ignore_changes: The lifecycle rules to ignore changes.
        :param resource_group_id: Resource group ID where the DNS Resolver will be created.
        '''
        if isinstance(lifecycle, dict):
            lifecycle = _cdktf_9a9027ec.TerraformResourceLifecycle(**lifecycle)
        if isinstance(monitoring, dict):
            monitoring = _MonitoringConfig_7c28df74(**monitoring)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8a35108416bae4beb987e0f3d1796ea58ac0e838b7c55fd4432531d9deed926c)
            check_type(argname="argument connection", value=connection, expected_type=type_hints["connection"])
            check_type(argname="argument count", value=count, expected_type=type_hints["count"])
            check_type(argname="argument depends_on", value=depends_on, expected_type=type_hints["depends_on"])
            check_type(argname="argument for_each", value=for_each, expected_type=type_hints["for_each"])
            check_type(argname="argument lifecycle", value=lifecycle, expected_type=type_hints["lifecycle"])
            check_type(argname="argument provider", value=provider, expected_type=type_hints["provider"])
            check_type(argname="argument provisioners", value=provisioners, expected_type=type_hints["provisioners"])
            check_type(argname="argument api_version", value=api_version, expected_type=type_hints["api_version"])
            check_type(argname="argument enable_migration_analysis", value=enable_migration_analysis, expected_type=type_hints["enable_migration_analysis"])
            check_type(argname="argument enable_transformation", value=enable_transformation, expected_type=type_hints["enable_transformation"])
            check_type(argname="argument enable_validation", value=enable_validation, expected_type=type_hints["enable_validation"])
            check_type(argname="argument location", value=location, expected_type=type_hints["location"])
            check_type(argname="argument monitoring", value=monitoring, expected_type=type_hints["monitoring"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument virtual_network_id", value=virtual_network_id, expected_type=type_hints["virtual_network_id"])
            check_type(argname="argument ignore_changes", value=ignore_changes, expected_type=type_hints["ignore_changes"])
            check_type(argname="argument resource_group_id", value=resource_group_id, expected_type=type_hints["resource_group_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "virtual_network_id": virtual_network_id,
        }
        if connection is not None:
            self._values["connection"] = connection
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if for_each is not None:
            self._values["for_each"] = for_each
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider
        if provisioners is not None:
            self._values["provisioners"] = provisioners
        if api_version is not None:
            self._values["api_version"] = api_version
        if enable_migration_analysis is not None:
            self._values["enable_migration_analysis"] = enable_migration_analysis
        if enable_transformation is not None:
            self._values["enable_transformation"] = enable_transformation
        if enable_validation is not None:
            self._values["enable_validation"] = enable_validation
        if location is not None:
            self._values["location"] = location
        if monitoring is not None:
            self._values["monitoring"] = monitoring
        if name is not None:
            self._values["name"] = name
        if tags is not None:
            self._values["tags"] = tags
        if ignore_changes is not None:
            self._values["ignore_changes"] = ignore_changes
        if resource_group_id is not None:
            self._values["resource_group_id"] = resource_group_id

    @builtins.property
    def connection(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("connection")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]], result)

    @builtins.property
    def count(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]], result)

    @builtins.property
    def depends_on(
        self,
    ) -> typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]], result)

    @builtins.property
    def for_each(self) -> typing.Optional[_cdktf_9a9027ec.ITerraformIterator]:
        '''
        :stability: experimental
        '''
        result = self._values.get("for_each")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.ITerraformIterator], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[_cdktf_9a9027ec.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformProvider], result)

    @builtins.property
    def provisioners(
        self,
    ) -> typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provisioners")
        return typing.cast(typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]], result)

    @builtins.property
    def api_version(self) -> typing.Optional[builtins.str]:
        '''Explicit API version to use for this resource.

        If not specified, the latest active version will be automatically resolved.
        Use this for version pinning when stability is required over latest features.

        :default: Latest active version from ApiVersionManager

        Example::

            "2024-11-01"
        '''
        result = self._values.get("api_version")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def enable_migration_analysis(self) -> typing.Optional[builtins.bool]:
        '''Whether to enable migration analysis warnings.

        When true, the framework will analyze the current version for deprecation
        status and provide migration recommendations in the deployment output.

        :default: true
        '''
        result = self._values.get("enable_migration_analysis")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_transformation(self) -> typing.Optional[builtins.bool]:
        '''Whether to apply property transformations automatically.

        When true, properties will be automatically transformed according to the
        target schema's transformation rules. This enables backward compatibility.

        :default: true
        '''
        result = self._values.get("enable_transformation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_validation(self) -> typing.Optional[builtins.bool]:
        '''Whether to validate properties against the schema.

        When true, all properties will be validated against the API schema before
        resource creation. Validation errors will cause deployment failures.

        :default: true
        '''
        result = self._values.get("enable_validation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def location(self) -> typing.Optional[builtins.str]:
        '''The location where the resource should be created.

        :default: Varies by resource type - see specific resource documentation

        :remarks:

        Location handling varies by resource type:

        - **Top-level resources**: Most require an explicit location (e.g., "eastus", "westus")
        - **Global resources**: Some use "global" as location (e.g., Private DNS Zones)
        - **Child resources**: Inherit location from parent and should NOT set this property

        Each resource type may provide its own default through the ``resolveLocation()`` method.
        If no location is specified and no default exists, resource creation may fail.

        Example::

            // Child resource (Subnet) - do not set location
            // location: undefined (inherited from parent Virtual Network)
        '''
        result = self._values.get("location")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def monitoring(self) -> typing.Optional[_MonitoringConfig_7c28df74]:
        '''Monitoring configuration for this resource.

        Enables integrated monitoring with diagnostic settings, metric alerts,
        and activity log alerts. All monitoring is optional and disabled by default.

        Example::

            monitoring: {
              enabled: true,
              diagnosticSettings: {
                workspaceId: logAnalytics.id,
                metrics: ['AllMetrics'],
                logs: ['AuditLogs']
              },
              metricAlerts: [{
                name: 'high-cpu-alert',
                severity: 2,
                scopes: [], // Automatically set to this resource
                criteria: { ... },
                actions: [{ actionGroupId: actionGroup.id }]
              }]
            }
        '''
        result = self._values.get("monitoring")
        return typing.cast(typing.Optional[_MonitoringConfig_7c28df74], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the resource.'''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Tags to apply to the resource.'''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def virtual_network_id(self) -> builtins.str:
        '''The resource ID of the virtual network where the DNS Resolver will be deployed The resolver requires a dedicated subnet with delegation to Microsoft.Network/dnsResolvers.'''
        result = self._values.get("virtual_network_id")
        assert result is not None, "Required property 'virtual_network_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def ignore_changes(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The lifecycle rules to ignore changes.

        Example::

            ["tags"]
        '''
        result = self._values.get("ignore_changes")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def resource_group_id(self) -> typing.Optional[builtins.str]:
        '''Resource group ID where the DNS Resolver will be created.'''
        result = self._values.get("resource_group_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DnsResolverProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DnsZone(
    _AzapiResource_7e7f5b39,
    metaclass=jsii.JSIIMeta,
    jsii_type="@microsoft/terraform-cdk-constructs.DnsZone",
):
    '''Unified Azure DNS Zone implementation.

    This class provides a single, version-aware implementation that replaces all
    version-specific DNS Zone classes. It automatically handles version
    resolution, schema validation, and property transformation while maintaining
    full backward compatibility.

    Azure DNS Zones are global resources used to host DNS records for a domain.
    They can be either Public (Internet-accessible) or Private (accessible only
    from specified virtual networks).

    Example::

        // DNS zone with explicit version pinning:
        const dnsZone = new DnsZone(this, "dns", {
          name: "contoso.com",
          location: "global",
          resourceGroupId: resourceGroup.id,
          apiVersion: "2018-05-01",
        });
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
        registration_virtual_networks: typing.Optional[typing.Sequence[typing.Union[_VirtualNetworkReference_d6a6c338, typing.Dict[builtins.str, typing.Any]]]] = None,
        resolution_virtual_networks: typing.Optional[typing.Sequence[typing.Union[_VirtualNetworkReference_d6a6c338, typing.Dict[builtins.str, typing.Any]]]] = None,
        resource_group_id: typing.Optional[builtins.str] = None,
        zone_type: typing.Optional[builtins.str] = None,
        api_version: typing.Optional[builtins.str] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        location: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> None:
        '''Creates a new Azure DNS Zone using the VersionedAzapiResource framework.

        :param scope: - The scope in which to define this construct.
        :param id: - The unique identifier for this instance.
        :param ignore_changes: The lifecycle rules to ignore changes.
        :param registration_virtual_networks: A list of references to virtual networks that register hostnames in this DNS zone Only valid when zoneType is Private.
        :param resolution_virtual_networks: A list of references to virtual networks that resolve records in this DNS zone Only valid when zoneType is Private.
        :param resource_group_id: Resource group ID where the DNS Zone will be created.
        :param zone_type: The type of this DNS zone (Public or Private). Default: "Public"
        :param api_version: Explicit API version to use for this resource. If not specified, the latest active version will be automatically resolved. Use this for version pinning when stability is required over latest features. Default: Latest active version from ApiVersionManager
        :param enable_migration_analysis: Whether to enable migration analysis warnings. When true, the framework will analyze the current version for deprecation status and provide migration recommendations in the deployment output. Default: true
        :param enable_transformation: Whether to apply property transformations automatically. When true, properties will be automatically transformed according to the target schema's transformation rules. This enables backward compatibility. Default: true
        :param enable_validation: Whether to validate properties against the schema. When true, all properties will be validated against the API schema before resource creation. Validation errors will cause deployment failures. Default: true
        :param location: The location where the resource should be created. Default: Varies by resource type - see specific resource documentation
        :param monitoring: Monitoring configuration for this resource. Enables integrated monitoring with diagnostic settings, metric alerts, and activity log alerts. All monitoring is optional and disabled by default.
        :param name: The name of the resource.
        :param tags: Tags to apply to the resource.
        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5731b0055d9b8a9cf5a27a4def7635cce8511c1a42dafff59886be904488bf5e)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = _DnsZoneProps_90137124(
            ignore_changes=ignore_changes,
            registration_virtual_networks=registration_virtual_networks,
            resolution_virtual_networks=resolution_virtual_networks,
            resource_group_id=resource_group_id,
            zone_type=zone_type,
            api_version=api_version,
            enable_migration_analysis=enable_migration_analysis,
            enable_transformation=enable_transformation,
            enable_validation=enable_validation,
            location=location,
            monitoring=monitoring,
            name=name,
            tags=tags,
            connection=connection,
            count=count,
            depends_on=depends_on,
            for_each=for_each,
            lifecycle=lifecycle,
            provider=provider,
            provisioners=provisioners,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="addTag")
    def add_tag(self, key: builtins.str, value: builtins.str) -> None:
        '''Add a tag to the DNS Zone.

        :param key: -
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__32defd73e514ad305ce83b421d3da4f873a5cd17d26ef93432d61198f9c1f45e)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "addTag", [key, value]))

    @jsii.member(jsii_name="apiSchema")
    def _api_schema(self) -> _ApiSchema_5ce0490e:
        '''Gets the API schema for the resolved version.'''
        return typing.cast(_ApiSchema_5ce0490e, jsii.invoke(self, "apiSchema", []))

    @jsii.member(jsii_name="createResourceBody")
    def _create_resource_body(self, props: typing.Any) -> typing.Any:
        '''Creates the resource body for the Azure API call.

        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__80079bfce735c9fde26ac5b4e3c7856de22766d90f4fb5ead45b08da170a8159)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Any, jsii.invoke(self, "createResourceBody", [props]))

    @jsii.member(jsii_name="defaultLocation")
    def _default_location(self) -> builtins.str:
        '''Provides default location for DNS Zones (global resource).'''
        return typing.cast(builtins.str, jsii.invoke(self, "defaultLocation", []))

    @jsii.member(jsii_name="defaultVersion")
    def _default_version(self) -> builtins.str:
        '''Gets the default API version to use when no explicit version is specified.'''
        return typing.cast(builtins.str, jsii.invoke(self, "defaultVersion", []))

    @jsii.member(jsii_name="removeTag")
    def remove_tag(self, key: builtins.str) -> None:
        '''Remove a tag from the DNS Zone.

        :param key: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c0deb5b00bdc175c517e381205c1b9dacfb45973f693b0547edfe6893ba68a86)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
        return typing.cast(None, jsii.invoke(self, "removeTag", [key]))

    @jsii.member(jsii_name="resourceType")
    def _resource_type(self) -> builtins.str:
        '''Gets the Azure resource type for DNS Zones.'''
        return typing.cast(builtins.str, jsii.invoke(self, "resourceType", []))

    @builtins.property
    @jsii.member(jsii_name="idOutput")
    def id_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "idOutput"))

    @builtins.property
    @jsii.member(jsii_name="locationOutput")
    def location_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "locationOutput"))

    @builtins.property
    @jsii.member(jsii_name="maxNumberOfRecordSets")
    def max_number_of_record_sets(self) -> builtins.str:
        '''Get the maximum number of record sets that can be created in this DNS zone.'''
        return typing.cast(builtins.str, jsii.get(self, "maxNumberOfRecordSets"))

    @builtins.property
    @jsii.member(jsii_name="nameOutput")
    def name_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "nameOutput"))

    @builtins.property
    @jsii.member(jsii_name="nameServers")
    def name_servers(self) -> builtins.str:
        '''Get the name servers for the DNS Zone These are the Azure DNS name servers that should be configured at your domain registrar.'''
        return typing.cast(builtins.str, jsii.get(self, "nameServers"))

    @builtins.property
    @jsii.member(jsii_name="nameServersOutput")
    def name_servers_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "nameServersOutput"))

    @builtins.property
    @jsii.member(jsii_name="numberOfRecordSets")
    def number_of_record_sets(self) -> builtins.str:
        '''Get the current number of record sets in this DNS zone.'''
        return typing.cast(builtins.str, jsii.get(self, "numberOfRecordSets"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def props(self) -> _DnsZoneProps_90137124:
        return typing.cast(_DnsZoneProps_90137124, jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="tagsOutput")
    def tags_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "tagsOutput"))

    @builtins.property
    @jsii.member(jsii_name="zoneType")
    def zone_type(self) -> builtins.str:
        '''Get the zone type (Public or Private).'''
        return typing.cast(builtins.str, jsii.get(self, "zoneType"))


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.DnsZoneBody",
    jsii_struct_bases=[],
    name_mapping={"location": "location", "properties": "properties", "tags": "tags"},
)
class DnsZoneBody:
    def __init__(
        self,
        *,
        location: builtins.str,
        properties: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''The resource body interface for Azure DNS Zone API calls This matches the Azure REST API schema.

        :param location: 
        :param properties: 
        :param tags: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b086c081746a2eb53611ce1a28f9644cba9a7a094ec356b6d1f8a0bf343890dd)
            check_type(argname="argument location", value=location, expected_type=type_hints["location"])
            check_type(argname="argument properties", value=properties, expected_type=type_hints["properties"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "location": location,
        }
        if properties is not None:
            self._values["properties"] = properties
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def location(self) -> builtins.str:
        result = self._values.get("location")
        assert result is not None, "Required property 'location' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def properties(self) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        result = self._values.get("properties")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DnsZoneBody(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.DnsZoneProps",
    jsii_struct_bases=[_AzapiResourceProps_141a2340],
    name_mapping={
        "connection": "connection",
        "count": "count",
        "depends_on": "dependsOn",
        "for_each": "forEach",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "provisioners": "provisioners",
        "api_version": "apiVersion",
        "enable_migration_analysis": "enableMigrationAnalysis",
        "enable_transformation": "enableTransformation",
        "enable_validation": "enableValidation",
        "location": "location",
        "monitoring": "monitoring",
        "name": "name",
        "tags": "tags",
        "ignore_changes": "ignoreChanges",
        "registration_virtual_networks": "registrationVirtualNetworks",
        "resolution_virtual_networks": "resolutionVirtualNetworks",
        "resource_group_id": "resourceGroupId",
        "zone_type": "zoneType",
    },
)
class DnsZoneProps(_AzapiResourceProps_141a2340):
    def __init__(
        self,
        *,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
        api_version: typing.Optional[builtins.str] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        location: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
        registration_virtual_networks: typing.Optional[typing.Sequence[typing.Union[_VirtualNetworkReference_d6a6c338, typing.Dict[builtins.str, typing.Any]]]] = None,
        resolution_virtual_networks: typing.Optional[typing.Sequence[typing.Union[_VirtualNetworkReference_d6a6c338, typing.Dict[builtins.str, typing.Any]]]] = None,
        resource_group_id: typing.Optional[builtins.str] = None,
        zone_type: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for the unified Azure DNS Zone.

        Extends AzapiResourceProps with DNS Zone specific properties

        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        :param api_version: Explicit API version to use for this resource. If not specified, the latest active version will be automatically resolved. Use this for version pinning when stability is required over latest features. Default: Latest active version from ApiVersionManager
        :param enable_migration_analysis: Whether to enable migration analysis warnings. When true, the framework will analyze the current version for deprecation status and provide migration recommendations in the deployment output. Default: true
        :param enable_transformation: Whether to apply property transformations automatically. When true, properties will be automatically transformed according to the target schema's transformation rules. This enables backward compatibility. Default: true
        :param enable_validation: Whether to validate properties against the schema. When true, all properties will be validated against the API schema before resource creation. Validation errors will cause deployment failures. Default: true
        :param location: The location where the resource should be created. Default: Varies by resource type - see specific resource documentation
        :param monitoring: Monitoring configuration for this resource. Enables integrated monitoring with diagnostic settings, metric alerts, and activity log alerts. All monitoring is optional and disabled by default.
        :param name: The name of the resource.
        :param tags: Tags to apply to the resource.
        :param ignore_changes: The lifecycle rules to ignore changes.
        :param registration_virtual_networks: A list of references to virtual networks that register hostnames in this DNS zone Only valid when zoneType is Private.
        :param resolution_virtual_networks: A list of references to virtual networks that resolve records in this DNS zone Only valid when zoneType is Private.
        :param resource_group_id: Resource group ID where the DNS Zone will be created.
        :param zone_type: The type of this DNS zone (Public or Private). Default: "Public"
        '''
        if isinstance(lifecycle, dict):
            lifecycle = _cdktf_9a9027ec.TerraformResourceLifecycle(**lifecycle)
        if isinstance(monitoring, dict):
            monitoring = _MonitoringConfig_7c28df74(**monitoring)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__12a3ad79b351d036f13c3f172408401e66ecb525e64284ba7006bead44d7b279)
            check_type(argname="argument connection", value=connection, expected_type=type_hints["connection"])
            check_type(argname="argument count", value=count, expected_type=type_hints["count"])
            check_type(argname="argument depends_on", value=depends_on, expected_type=type_hints["depends_on"])
            check_type(argname="argument for_each", value=for_each, expected_type=type_hints["for_each"])
            check_type(argname="argument lifecycle", value=lifecycle, expected_type=type_hints["lifecycle"])
            check_type(argname="argument provider", value=provider, expected_type=type_hints["provider"])
            check_type(argname="argument provisioners", value=provisioners, expected_type=type_hints["provisioners"])
            check_type(argname="argument api_version", value=api_version, expected_type=type_hints["api_version"])
            check_type(argname="argument enable_migration_analysis", value=enable_migration_analysis, expected_type=type_hints["enable_migration_analysis"])
            check_type(argname="argument enable_transformation", value=enable_transformation, expected_type=type_hints["enable_transformation"])
            check_type(argname="argument enable_validation", value=enable_validation, expected_type=type_hints["enable_validation"])
            check_type(argname="argument location", value=location, expected_type=type_hints["location"])
            check_type(argname="argument monitoring", value=monitoring, expected_type=type_hints["monitoring"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument ignore_changes", value=ignore_changes, expected_type=type_hints["ignore_changes"])
            check_type(argname="argument registration_virtual_networks", value=registration_virtual_networks, expected_type=type_hints["registration_virtual_networks"])
            check_type(argname="argument resolution_virtual_networks", value=resolution_virtual_networks, expected_type=type_hints["resolution_virtual_networks"])
            check_type(argname="argument resource_group_id", value=resource_group_id, expected_type=type_hints["resource_group_id"])
            check_type(argname="argument zone_type", value=zone_type, expected_type=type_hints["zone_type"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if connection is not None:
            self._values["connection"] = connection
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if for_each is not None:
            self._values["for_each"] = for_each
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider
        if provisioners is not None:
            self._values["provisioners"] = provisioners
        if api_version is not None:
            self._values["api_version"] = api_version
        if enable_migration_analysis is not None:
            self._values["enable_migration_analysis"] = enable_migration_analysis
        if enable_transformation is not None:
            self._values["enable_transformation"] = enable_transformation
        if enable_validation is not None:
            self._values["enable_validation"] = enable_validation
        if location is not None:
            self._values["location"] = location
        if monitoring is not None:
            self._values["monitoring"] = monitoring
        if name is not None:
            self._values["name"] = name
        if tags is not None:
            self._values["tags"] = tags
        if ignore_changes is not None:
            self._values["ignore_changes"] = ignore_changes
        if registration_virtual_networks is not None:
            self._values["registration_virtual_networks"] = registration_virtual_networks
        if resolution_virtual_networks is not None:
            self._values["resolution_virtual_networks"] = resolution_virtual_networks
        if resource_group_id is not None:
            self._values["resource_group_id"] = resource_group_id
        if zone_type is not None:
            self._values["zone_type"] = zone_type

    @builtins.property
    def connection(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("connection")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]], result)

    @builtins.property
    def count(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]], result)

    @builtins.property
    def depends_on(
        self,
    ) -> typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]], result)

    @builtins.property
    def for_each(self) -> typing.Optional[_cdktf_9a9027ec.ITerraformIterator]:
        '''
        :stability: experimental
        '''
        result = self._values.get("for_each")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.ITerraformIterator], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[_cdktf_9a9027ec.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformProvider], result)

    @builtins.property
    def provisioners(
        self,
    ) -> typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provisioners")
        return typing.cast(typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]], result)

    @builtins.property
    def api_version(self) -> typing.Optional[builtins.str]:
        '''Explicit API version to use for this resource.

        If not specified, the latest active version will be automatically resolved.
        Use this for version pinning when stability is required over latest features.

        :default: Latest active version from ApiVersionManager

        Example::

            "2024-11-01"
        '''
        result = self._values.get("api_version")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def enable_migration_analysis(self) -> typing.Optional[builtins.bool]:
        '''Whether to enable migration analysis warnings.

        When true, the framework will analyze the current version for deprecation
        status and provide migration recommendations in the deployment output.

        :default: true
        '''
        result = self._values.get("enable_migration_analysis")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_transformation(self) -> typing.Optional[builtins.bool]:
        '''Whether to apply property transformations automatically.

        When true, properties will be automatically transformed according to the
        target schema's transformation rules. This enables backward compatibility.

        :default: true
        '''
        result = self._values.get("enable_transformation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_validation(self) -> typing.Optional[builtins.bool]:
        '''Whether to validate properties against the schema.

        When true, all properties will be validated against the API schema before
        resource creation. Validation errors will cause deployment failures.

        :default: true
        '''
        result = self._values.get("enable_validation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def location(self) -> typing.Optional[builtins.str]:
        '''The location where the resource should be created.

        :default: Varies by resource type - see specific resource documentation

        :remarks:

        Location handling varies by resource type:

        - **Top-level resources**: Most require an explicit location (e.g., "eastus", "westus")
        - **Global resources**: Some use "global" as location (e.g., Private DNS Zones)
        - **Child resources**: Inherit location from parent and should NOT set this property

        Each resource type may provide its own default through the ``resolveLocation()`` method.
        If no location is specified and no default exists, resource creation may fail.

        Example::

            // Child resource (Subnet) - do not set location
            // location: undefined (inherited from parent Virtual Network)
        '''
        result = self._values.get("location")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def monitoring(self) -> typing.Optional[_MonitoringConfig_7c28df74]:
        '''Monitoring configuration for this resource.

        Enables integrated monitoring with diagnostic settings, metric alerts,
        and activity log alerts. All monitoring is optional and disabled by default.

        Example::

            monitoring: {
              enabled: true,
              diagnosticSettings: {
                workspaceId: logAnalytics.id,
                metrics: ['AllMetrics'],
                logs: ['AuditLogs']
              },
              metricAlerts: [{
                name: 'high-cpu-alert',
                severity: 2,
                scopes: [], // Automatically set to this resource
                criteria: { ... },
                actions: [{ actionGroupId: actionGroup.id }]
              }]
            }
        '''
        result = self._values.get("monitoring")
        return typing.cast(typing.Optional[_MonitoringConfig_7c28df74], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the resource.'''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Tags to apply to the resource.'''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def ignore_changes(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The lifecycle rules to ignore changes.

        Example::

            ["tags"]
        '''
        result = self._values.get("ignore_changes")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def registration_virtual_networks(
        self,
    ) -> typing.Optional[typing.List[_VirtualNetworkReference_d6a6c338]]:
        '''A list of references to virtual networks that register hostnames in this DNS zone Only valid when zoneType is Private.'''
        result = self._values.get("registration_virtual_networks")
        return typing.cast(typing.Optional[typing.List[_VirtualNetworkReference_d6a6c338]], result)

    @builtins.property
    def resolution_virtual_networks(
        self,
    ) -> typing.Optional[typing.List[_VirtualNetworkReference_d6a6c338]]:
        '''A list of references to virtual networks that resolve records in this DNS zone Only valid when zoneType is Private.'''
        result = self._values.get("resolution_virtual_networks")
        return typing.cast(typing.Optional[typing.List[_VirtualNetworkReference_d6a6c338]], result)

    @builtins.property
    def resource_group_id(self) -> typing.Optional[builtins.str]:
        '''Resource group ID where the DNS Zone will be created.'''
        result = self._values.get("resource_group_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def zone_type(self) -> typing.Optional[builtins.str]:
        '''The type of this DNS zone (Public or Private).

        :default: "Public"
        '''
        result = self._values.get("zone_type")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DnsZoneProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.DynamicThresholdCriteria",
    jsii_struct_bases=[],
    name_mapping={
        "alert_sensitivity": "alertSensitivity",
        "failing_periods": "failingPeriods",
        "metric_name": "metricName",
        "operator": "operator",
        "time_aggregation": "timeAggregation",
        "type": "type",
        "dimensions": "dimensions",
        "ignore_data_before": "ignoreDataBefore",
        "metric_namespace": "metricNamespace",
    },
)
class DynamicThresholdCriteria:
    def __init__(
        self,
        *,
        alert_sensitivity: builtins.str,
        failing_periods: typing.Union[_MetricAlertFailingPeriods_93398eb2, typing.Dict[builtins.str, typing.Any]],
        metric_name: builtins.str,
        operator: builtins.str,
        time_aggregation: builtins.str,
        type: builtins.str,
        dimensions: typing.Optional[typing.Sequence[typing.Union[_MetricDimension_8611b872, typing.Dict[builtins.str, typing.Any]]]] = None,
        ignore_data_before: typing.Optional[builtins.str] = None,
        metric_namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Dynamic threshold criteria configuration.

        :param alert_sensitivity: The alert sensitivity (Low, Medium, High).
        :param failing_periods: Failing periods configuration.
        :param metric_name: The metric name.
        :param operator: The comparison operator.
        :param time_aggregation: The time aggregation method.
        :param type: The criteria type.
        :param dimensions: Metric dimensions for filtering (optional).
        :param ignore_data_before: Ignore data before this date (ISO 8601 format).
        :param metric_namespace: The metric namespace (optional).
        '''
        if isinstance(failing_periods, dict):
            failing_periods = _MetricAlertFailingPeriods_93398eb2(**failing_periods)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__907b80e73375e97e11e1927ff5317d693849a47e4ad192ce8c965950ee6f3bac)
            check_type(argname="argument alert_sensitivity", value=alert_sensitivity, expected_type=type_hints["alert_sensitivity"])
            check_type(argname="argument failing_periods", value=failing_periods, expected_type=type_hints["failing_periods"])
            check_type(argname="argument metric_name", value=metric_name, expected_type=type_hints["metric_name"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument time_aggregation", value=time_aggregation, expected_type=type_hints["time_aggregation"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument dimensions", value=dimensions, expected_type=type_hints["dimensions"])
            check_type(argname="argument ignore_data_before", value=ignore_data_before, expected_type=type_hints["ignore_data_before"])
            check_type(argname="argument metric_namespace", value=metric_namespace, expected_type=type_hints["metric_namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "alert_sensitivity": alert_sensitivity,
            "failing_periods": failing_periods,
            "metric_name": metric_name,
            "operator": operator,
            "time_aggregation": time_aggregation,
            "type": type,
        }
        if dimensions is not None:
            self._values["dimensions"] = dimensions
        if ignore_data_before is not None:
            self._values["ignore_data_before"] = ignore_data_before
        if metric_namespace is not None:
            self._values["metric_namespace"] = metric_namespace

    @builtins.property
    def alert_sensitivity(self) -> builtins.str:
        '''The alert sensitivity (Low, Medium, High).'''
        result = self._values.get("alert_sensitivity")
        assert result is not None, "Required property 'alert_sensitivity' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def failing_periods(self) -> _MetricAlertFailingPeriods_93398eb2:
        '''Failing periods configuration.'''
        result = self._values.get("failing_periods")
        assert result is not None, "Required property 'failing_periods' is missing"
        return typing.cast(_MetricAlertFailingPeriods_93398eb2, result)

    @builtins.property
    def metric_name(self) -> builtins.str:
        '''The metric name.'''
        result = self._values.get("metric_name")
        assert result is not None, "Required property 'metric_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''The comparison operator.'''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def time_aggregation(self) -> builtins.str:
        '''The time aggregation method.'''
        result = self._values.get("time_aggregation")
        assert result is not None, "Required property 'time_aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def type(self) -> builtins.str:
        '''The criteria type.'''
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def dimensions(self) -> typing.Optional[typing.List[_MetricDimension_8611b872]]:
        '''Metric dimensions for filtering (optional).'''
        result = self._values.get("dimensions")
        return typing.cast(typing.Optional[typing.List[_MetricDimension_8611b872]], result)

    @builtins.property
    def ignore_data_before(self) -> typing.Optional[builtins.str]:
        '''Ignore data before this date (ISO 8601 format).'''
        result = self._values.get("ignore_data_before")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def metric_namespace(self) -> typing.Optional[builtins.str]:
        '''The metric namespace (optional).'''
        result = self._values.get("metric_namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DynamicThresholdCriteria(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.EmailReceiver",
    jsii_struct_bases=[],
    name_mapping={
        "email_address": "emailAddress",
        "name": "name",
        "use_common_alert_schema": "useCommonAlertSchema",
    },
)
class EmailReceiver:
    def __init__(
        self,
        *,
        email_address: builtins.str,
        name: builtins.str,
        use_common_alert_schema: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Email receiver configuration.

        :param email_address: The email address to send notifications to.
        :param name: The name of the email receiver.
        :param use_common_alert_schema: Whether to use common alert schema. Default: false
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f7216c9d36730b62fc10f9a8f68d553286b25849d4741f71052c712c2c7e1c60)
            check_type(argname="argument email_address", value=email_address, expected_type=type_hints["email_address"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument use_common_alert_schema", value=use_common_alert_schema, expected_type=type_hints["use_common_alert_schema"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "email_address": email_address,
            "name": name,
        }
        if use_common_alert_schema is not None:
            self._values["use_common_alert_schema"] = use_common_alert_schema

    @builtins.property
    def email_address(self) -> builtins.str:
        '''The email address to send notifications to.'''
        result = self._values.get("email_address")
        assert result is not None, "Required property 'email_address' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the email receiver.'''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def use_common_alert_schema(self) -> typing.Optional[builtins.bool]:
        '''Whether to use common alert schema.

        :default: false
        '''
        result = self._values.get("use_common_alert_schema")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "EmailReceiver(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.ExtensionProfile",
    jsii_struct_bases=[],
    name_mapping={"extensions": "extensions"},
)
class ExtensionProfile:
    def __init__(
        self,
        *,
        extensions: typing.Optional[typing.Sequence[typing.Union[_VMExtension_034783ba, typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Extension profile.

        :param extensions: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c6f90bef51087e1fe9c31219de2eb5db10632cdda59e4e403fbc6668bc5fe424)
            check_type(argname="argument extensions", value=extensions, expected_type=type_hints["extensions"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if extensions is not None:
            self._values["extensions"] = extensions

    @builtins.property
    def extensions(self) -> typing.Optional[typing.List[_VMExtension_034783ba]]:
        result = self._values.get("extensions")
        return typing.cast(typing.Optional[typing.List[_VMExtension_034783ba]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ExtensionProfile(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ForwardingRule(
    _AzapiResource_7e7f5b39,
    metaclass=jsii.JSIIMeta,
    jsii_type="@microsoft/terraform-cdk-constructs.ForwardingRule",
):
    '''Azure DNS Forwarding Rule implementation.

    Forwarding rules define conditional DNS forwarding behavior. When a DNS query
    matches the domain name pattern, it's forwarded to the specified target DNS servers.
    Up to 1000 rules can be configured per ruleset, with up to 6 target servers per rule.

    Example::

        // Disabled forwarding rule:
        const rule = new ForwardingRule(this, "rule", {
          name: "temp-rule",
          dnsForwardingRulesetId: ruleset.id,
          domainName: "temp.local.",
          targetDnsServers: [{ ipAddress: "10.0.0.4" }],
          forwardingRuleState: "Disabled"
        });
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        dns_forwarding_ruleset_id: builtins.str,
        domain_name: builtins.str,
        target_dns_servers: typing.Sequence[typing.Union[_TargetDnsServer_14a5d2e0, typing.Dict[builtins.str, typing.Any]]],
        forwarding_rule_state: typing.Optional[builtins.str] = None,
        ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
        metadata: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        api_version: typing.Optional[builtins.str] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        location: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> None:
        '''Creates a new Azure DNS Forwarding Rule using the AzapiResource framework.

        :param scope: - The scope in which to define this construct.
        :param id: - The unique identifier for this instance.
        :param dns_forwarding_ruleset_id: Resource ID of the parent DNS Forwarding Ruleset.
        :param domain_name: The domain name to forward (must end with a dot for FQDN).
        :param target_dns_servers: Array of target DNS servers to forward queries to Maximum of 6 servers per rule.
        :param forwarding_rule_state: The state of the forwarding rule. Default: "Enabled"
        :param ignore_changes: The lifecycle rules to ignore changes.
        :param metadata: Metadata attached to the forwarding rule as key-value pairs.
        :param api_version: Explicit API version to use for this resource. If not specified, the latest active version will be automatically resolved. Use this for version pinning when stability is required over latest features. Default: Latest active version from ApiVersionManager
        :param enable_migration_analysis: Whether to enable migration analysis warnings. When true, the framework will analyze the current version for deprecation status and provide migration recommendations in the deployment output. Default: true
        :param enable_transformation: Whether to apply property transformations automatically. When true, properties will be automatically transformed according to the target schema's transformation rules. This enables backward compatibility. Default: true
        :param enable_validation: Whether to validate properties against the schema. When true, all properties will be validated against the API schema before resource creation. Validation errors will cause deployment failures. Default: true
        :param location: The location where the resource should be created. Default: Varies by resource type - see specific resource documentation
        :param monitoring: Monitoring configuration for this resource. Enables integrated monitoring with diagnostic settings, metric alerts, and activity log alerts. All monitoring is optional and disabled by default.
        :param name: The name of the resource.
        :param tags: Tags to apply to the resource.
        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1fce519bf6849e2756dfb9553796c9a8a5e3bf287f1a97e05e20d38371d1ff51)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = _ForwardingRuleProps_2d00d2ca(
            dns_forwarding_ruleset_id=dns_forwarding_ruleset_id,
            domain_name=domain_name,
            target_dns_servers=target_dns_servers,
            forwarding_rule_state=forwarding_rule_state,
            ignore_changes=ignore_changes,
            metadata=metadata,
            api_version=api_version,
            enable_migration_analysis=enable_migration_analysis,
            enable_transformation=enable_transformation,
            enable_validation=enable_validation,
            location=location,
            monitoring=monitoring,
            name=name,
            tags=tags,
            connection=connection,
            count=count,
            depends_on=depends_on,
            for_each=for_each,
            lifecycle=lifecycle,
            provider=provider,
            provisioners=provisioners,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="apiSchema")
    def _api_schema(self) -> _ApiSchema_5ce0490e:
        '''Gets the API schema for the resolved version.'''
        return typing.cast(_ApiSchema_5ce0490e, jsii.invoke(self, "apiSchema", []))

    @jsii.member(jsii_name="createResourceBody")
    def _create_resource_body(self, props: typing.Any) -> typing.Any:
        '''Creates the resource body for the Azure API call.

        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3cc0fa0354b7e47bb56377d70bd882598239b08db450a33860b57a7b6b645433)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Any, jsii.invoke(self, "createResourceBody", [props]))

    @jsii.member(jsii_name="defaultVersion")
    def _default_version(self) -> builtins.str:
        '''Gets the default API version to use when no explicit version is specified.'''
        return typing.cast(builtins.str, jsii.invoke(self, "defaultVersion", []))

    @jsii.member(jsii_name="resolveParentId")
    def _resolve_parent_id(self, props: typing.Any) -> builtins.str:
        '''Resolves the parent resource ID for the Forwarding Rule Forwarding Rules are child resources of DNS Forwarding Rulesets.

        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bfdf449f0fc3131a540cc61727ca5bad460bf2811910df8c8b87dfbd867fc7d7)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(builtins.str, jsii.invoke(self, "resolveParentId", [props]))

    @jsii.member(jsii_name="resourceType")
    def _resource_type(self) -> builtins.str:
        '''Gets the Azure resource type for Forwarding Rules.'''
        return typing.cast(builtins.str, jsii.invoke(self, "resourceType", []))

    @builtins.property
    @jsii.member(jsii_name="idOutput")
    def id_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "idOutput"))

    @builtins.property
    @jsii.member(jsii_name="metadata")
    def metadata(self) -> builtins.str:
        '''Get the metadata.'''
        return typing.cast(builtins.str, jsii.get(self, "metadata"))

    @builtins.property
    @jsii.member(jsii_name="nameOutput")
    def name_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "nameOutput"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def props(self) -> _ForwardingRuleProps_2d00d2ca:
        '''The input properties for this Forwarding Rule instance.'''
        return typing.cast(_ForwardingRuleProps_2d00d2ca, jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        '''Get the provisioning state of the Forwarding Rule.'''
        return typing.cast(builtins.str, jsii.get(self, "provisioningState"))

    @builtins.property
    @jsii.member(jsii_name="provisioningStateOutput")
    def provisioning_state_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "provisioningStateOutput"))

    @builtins.property
    @jsii.member(jsii_name="resourceName")
    def resource_name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "resourceName"))

    @builtins.property
    @jsii.member(jsii_name="targetDnsServers")
    def target_dns_servers(self) -> builtins.str:
        '''Get the target DNS servers.'''
        return typing.cast(builtins.str, jsii.get(self, "targetDnsServers"))


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.ForwardingRuleBody",
    jsii_struct_bases=[],
    name_mapping={"properties": "properties"},
)
class ForwardingRuleBody:
    def __init__(
        self,
        *,
        properties: typing.Union[_ForwardingRuleProperties_244c500c, typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''The resource body interface for Azure Forwarding Rule API calls.

        :param properties: 
        '''
        if isinstance(properties, dict):
            properties = _ForwardingRuleProperties_244c500c(**properties)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9953dfb08b2641fd5fd501c2e94a6a97134cdcc81fccc466878167faa6b02efa)
            check_type(argname="argument properties", value=properties, expected_type=type_hints["properties"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "properties": properties,
        }

    @builtins.property
    def properties(self) -> _ForwardingRuleProperties_244c500c:
        result = self._values.get("properties")
        assert result is not None, "Required property 'properties' is missing"
        return typing.cast(_ForwardingRuleProperties_244c500c, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ForwardingRuleBody(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.ForwardingRuleProperties",
    jsii_struct_bases=[],
    name_mapping={
        "domain_name": "domainName",
        "target_dns_servers": "targetDnsServers",
        "forwarding_rule_state": "forwardingRuleState",
        "metadata": "metadata",
    },
)
class ForwardingRuleProperties:
    def __init__(
        self,
        *,
        domain_name: builtins.str,
        target_dns_servers: typing.Sequence[typing.Union[_TargetDnsServer_14a5d2e0, typing.Dict[builtins.str, typing.Any]]],
        forwarding_rule_state: typing.Optional[builtins.str] = None,
        metadata: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''Properties for Forwarding Rule body.

        :param domain_name: 
        :param target_dns_servers: 
        :param forwarding_rule_state: 
        :param metadata: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__968984f429d75a718f20e84d37a3d719d928c6cb4d2805f000db4d12447193c9)
            check_type(argname="argument domain_name", value=domain_name, expected_type=type_hints["domain_name"])
            check_type(argname="argument target_dns_servers", value=target_dns_servers, expected_type=type_hints["target_dns_servers"])
            check_type(argname="argument forwarding_rule_state", value=forwarding_rule_state, expected_type=type_hints["forwarding_rule_state"])
            check_type(argname="argument metadata", value=metadata, expected_type=type_hints["metadata"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "domain_name": domain_name,
            "target_dns_servers": target_dns_servers,
        }
        if forwarding_rule_state is not None:
            self._values["forwarding_rule_state"] = forwarding_rule_state
        if metadata is not None:
            self._values["metadata"] = metadata

    @builtins.property
    def domain_name(self) -> builtins.str:
        result = self._values.get("domain_name")
        assert result is not None, "Required property 'domain_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def target_dns_servers(self) -> typing.List[_TargetDnsServer_14a5d2e0]:
        result = self._values.get("target_dns_servers")
        assert result is not None, "Required property 'target_dns_servers' is missing"
        return typing.cast(typing.List[_TargetDnsServer_14a5d2e0], result)

    @builtins.property
    def forwarding_rule_state(self) -> typing.Optional[builtins.str]:
        result = self._values.get("forwarding_rule_state")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def metadata(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        result = self._values.get("metadata")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ForwardingRuleProperties(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.ForwardingRuleProps",
    jsii_struct_bases=[_AzapiResourceProps_141a2340],
    name_mapping={
        "connection": "connection",
        "count": "count",
        "depends_on": "dependsOn",
        "for_each": "forEach",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "provisioners": "provisioners",
        "api_version": "apiVersion",
        "enable_migration_analysis": "enableMigrationAnalysis",
        "enable_transformation": "enableTransformation",
        "enable_validation": "enableValidation",
        "location": "location",
        "monitoring": "monitoring",
        "name": "name",
        "tags": "tags",
        "dns_forwarding_ruleset_id": "dnsForwardingRulesetId",
        "domain_name": "domainName",
        "target_dns_servers": "targetDnsServers",
        "forwarding_rule_state": "forwardingRuleState",
        "ignore_changes": "ignoreChanges",
        "metadata": "metadata",
    },
)
class ForwardingRuleProps(_AzapiResourceProps_141a2340):
    def __init__(
        self,
        *,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
        api_version: typing.Optional[builtins.str] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        location: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        dns_forwarding_ruleset_id: builtins.str,
        domain_name: builtins.str,
        target_dns_servers: typing.Sequence[typing.Union[_TargetDnsServer_14a5d2e0, typing.Dict[builtins.str, typing.Any]]],
        forwarding_rule_state: typing.Optional[builtins.str] = None,
        ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
        metadata: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''Properties for the Azure DNS Forwarding Rule.

        Extends AzapiResourceProps with Forwarding Rule specific properties

        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        :param api_version: Explicit API version to use for this resource. If not specified, the latest active version will be automatically resolved. Use this for version pinning when stability is required over latest features. Default: Latest active version from ApiVersionManager
        :param enable_migration_analysis: Whether to enable migration analysis warnings. When true, the framework will analyze the current version for deprecation status and provide migration recommendations in the deployment output. Default: true
        :param enable_transformation: Whether to apply property transformations automatically. When true, properties will be automatically transformed according to the target schema's transformation rules. This enables backward compatibility. Default: true
        :param enable_validation: Whether to validate properties against the schema. When true, all properties will be validated against the API schema before resource creation. Validation errors will cause deployment failures. Default: true
        :param location: The location where the resource should be created. Default: Varies by resource type - see specific resource documentation
        :param monitoring: Monitoring configuration for this resource. Enables integrated monitoring with diagnostic settings, metric alerts, and activity log alerts. All monitoring is optional and disabled by default.
        :param name: The name of the resource.
        :param tags: Tags to apply to the resource.
        :param dns_forwarding_ruleset_id: Resource ID of the parent DNS Forwarding Ruleset.
        :param domain_name: The domain name to forward (must end with a dot for FQDN).
        :param target_dns_servers: Array of target DNS servers to forward queries to Maximum of 6 servers per rule.
        :param forwarding_rule_state: The state of the forwarding rule. Default: "Enabled"
        :param ignore_changes: The lifecycle rules to ignore changes.
        :param metadata: Metadata attached to the forwarding rule as key-value pairs.
        '''
        if isinstance(lifecycle, dict):
            lifecycle = _cdktf_9a9027ec.TerraformResourceLifecycle(**lifecycle)
        if isinstance(monitoring, dict):
            monitoring = _MonitoringConfig_7c28df74(**monitoring)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__218affeb3062092cb208cc7ddbba6245a5567bbe2538168b70702b8afc390463)
            check_type(argname="argument connection", value=connection, expected_type=type_hints["connection"])
            check_type(argname="argument count", value=count, expected_type=type_hints["count"])
            check_type(argname="argument depends_on", value=depends_on, expected_type=type_hints["depends_on"])
            check_type(argname="argument for_each", value=for_each, expected_type=type_hints["for_each"])
            check_type(argname="argument lifecycle", value=lifecycle, expected_type=type_hints["lifecycle"])
            check_type(argname="argument provider", value=provider, expected_type=type_hints["provider"])
            check_type(argname="argument provisioners", value=provisioners, expected_type=type_hints["provisioners"])
            check_type(argname="argument api_version", value=api_version, expected_type=type_hints["api_version"])
            check_type(argname="argument enable_migration_analysis", value=enable_migration_analysis, expected_type=type_hints["enable_migration_analysis"])
            check_type(argname="argument enable_transformation", value=enable_transformation, expected_type=type_hints["enable_transformation"])
            check_type(argname="argument enable_validation", value=enable_validation, expected_type=type_hints["enable_validation"])
            check_type(argname="argument location", value=location, expected_type=type_hints["location"])
            check_type(argname="argument monitoring", value=monitoring, expected_type=type_hints["monitoring"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument dns_forwarding_ruleset_id", value=dns_forwarding_ruleset_id, expected_type=type_hints["dns_forwarding_ruleset_id"])
            check_type(argname="argument domain_name", value=domain_name, expected_type=type_hints["domain_name"])
            check_type(argname="argument target_dns_servers", value=target_dns_servers, expected_type=type_hints["target_dns_servers"])
            check_type(argname="argument forwarding_rule_state", value=forwarding_rule_state, expected_type=type_hints["forwarding_rule_state"])
            check_type(argname="argument ignore_changes", value=ignore_changes, expected_type=type_hints["ignore_changes"])
            check_type(argname="argument metadata", value=metadata, expected_type=type_hints["metadata"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "dns_forwarding_ruleset_id": dns_forwarding_ruleset_id,
            "domain_name": domain_name,
            "target_dns_servers": target_dns_servers,
        }
        if connection is not None:
            self._values["connection"] = connection
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if for_each is not None:
            self._values["for_each"] = for_each
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider
        if provisioners is not None:
            self._values["provisioners"] = provisioners
        if api_version is not None:
            self._values["api_version"] = api_version
        if enable_migration_analysis is not None:
            self._values["enable_migration_analysis"] = enable_migration_analysis
        if enable_transformation is not None:
            self._values["enable_transformation"] = enable_transformation
        if enable_validation is not None:
            self._values["enable_validation"] = enable_validation
        if location is not None:
            self._values["location"] = location
        if monitoring is not None:
            self._values["monitoring"] = monitoring
        if name is not None:
            self._values["name"] = name
        if tags is not None:
            self._values["tags"] = tags
        if forwarding_rule_state is not None:
            self._values["forwarding_rule_state"] = forwarding_rule_state
        if ignore_changes is not None:
            self._values["ignore_changes"] = ignore_changes
        if metadata is not None:
            self._values["metadata"] = metadata

    @builtins.property
    def connection(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("connection")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]], result)

    @builtins.property
    def count(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]], result)

    @builtins.property
    def depends_on(
        self,
    ) -> typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]], result)

    @builtins.property
    def for_each(self) -> typing.Optional[_cdktf_9a9027ec.ITerraformIterator]:
        '''
        :stability: experimental
        '''
        result = self._values.get("for_each")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.ITerraformIterator], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[_cdktf_9a9027ec.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformProvider], result)

    @builtins.property
    def provisioners(
        self,
    ) -> typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provisioners")
        return typing.cast(typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]], result)

    @builtins.property
    def api_version(self) -> typing.Optional[builtins.str]:
        '''Explicit API version to use for this resource.

        If not specified, the latest active version will be automatically resolved.
        Use this for version pinning when stability is required over latest features.

        :default: Latest active version from ApiVersionManager

        Example::

            "2024-11-01"
        '''
        result = self._values.get("api_version")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def enable_migration_analysis(self) -> typing.Optional[builtins.bool]:
        '''Whether to enable migration analysis warnings.

        When true, the framework will analyze the current version for deprecation
        status and provide migration recommendations in the deployment output.

        :default: true
        '''
        result = self._values.get("enable_migration_analysis")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_transformation(self) -> typing.Optional[builtins.bool]:
        '''Whether to apply property transformations automatically.

        When true, properties will be automatically transformed according to the
        target schema's transformation rules. This enables backward compatibility.

        :default: true
        '''
        result = self._values.get("enable_transformation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_validation(self) -> typing.Optional[builtins.bool]:
        '''Whether to validate properties against the schema.

        When true, all properties will be validated against the API schema before
        resource creation. Validation errors will cause deployment failures.

        :default: true
        '''
        result = self._values.get("enable_validation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def location(self) -> typing.Optional[builtins.str]:
        '''The location where the resource should be created.

        :default: Varies by resource type - see specific resource documentation

        :remarks:

        Location handling varies by resource type:

        - **Top-level resources**: Most require an explicit location (e.g., "eastus", "westus")
        - **Global resources**: Some use "global" as location (e.g., Private DNS Zones)
        - **Child resources**: Inherit location from parent and should NOT set this property

        Each resource type may provide its own default through the ``resolveLocation()`` method.
        If no location is specified and no default exists, resource creation may fail.

        Example::

            // Child resource (Subnet) - do not set location
            // location: undefined (inherited from parent Virtual Network)
        '''
        result = self._values.get("location")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def monitoring(self) -> typing.Optional[_MonitoringConfig_7c28df74]:
        '''Monitoring configuration for this resource.

        Enables integrated monitoring with diagnostic settings, metric alerts,
        and activity log alerts. All monitoring is optional and disabled by default.

        Example::

            monitoring: {
              enabled: true,
              diagnosticSettings: {
                workspaceId: logAnalytics.id,
                metrics: ['AllMetrics'],
                logs: ['AuditLogs']
              },
              metricAlerts: [{
                name: 'high-cpu-alert',
                severity: 2,
                scopes: [], // Automatically set to this resource
                criteria: { ... },
                actions: [{ actionGroupId: actionGroup.id }]
              }]
            }
        '''
        result = self._values.get("monitoring")
        return typing.cast(typing.Optional[_MonitoringConfig_7c28df74], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the resource.'''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Tags to apply to the resource.'''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def dns_forwarding_ruleset_id(self) -> builtins.str:
        '''Resource ID of the parent DNS Forwarding Ruleset.

        Example::

            "/subscriptions/.../resourceGroups/rg/providers/Microsoft.Network/dnsForwardingRulesets/ruleset1"
        '''
        result = self._values.get("dns_forwarding_ruleset_id")
        assert result is not None, "Required property 'dns_forwarding_ruleset_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def domain_name(self) -> builtins.str:
        '''The domain name to forward (must end with a dot for FQDN).

        Example::

            "internal.corp."
        '''
        result = self._values.get("domain_name")
        assert result is not None, "Required property 'domain_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def target_dns_servers(self) -> typing.List[_TargetDnsServer_14a5d2e0]:
        '''Array of target DNS servers to forward queries to Maximum of 6 servers per rule.

        Example::

            [{ ipAddress: "10.0.0.4", port: 53 }, { ipAddress: "10.0.0.5" }]
        '''
        result = self._values.get("target_dns_servers")
        assert result is not None, "Required property 'target_dns_servers' is missing"
        return typing.cast(typing.List[_TargetDnsServer_14a5d2e0], result)

    @builtins.property
    def forwarding_rule_state(self) -> typing.Optional[builtins.str]:
        '''The state of the forwarding rule.

        :default: "Enabled"
        '''
        result = self._values.get("forwarding_rule_state")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ignore_changes(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The lifecycle rules to ignore changes.

        Example::

            ["metadata"]
        '''
        result = self._values.get("ignore_changes")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def metadata(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Metadata attached to the forwarding rule as key-value pairs.'''
        result = self._values.get("metadata")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ForwardingRuleProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.GatewayReference",
    jsii_struct_bases=[],
    name_mapping={"id": "id"},
)
class GatewayReference:
    def __init__(self, *, id: builtins.str) -> None:
        '''Reference to a Virtual Network Gateway.

        :param id: Resource ID of the virtual network gateway.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b57b28498b9ca3bdb3c659218c40effe5ce7f0f460416e863a8a9059c18a1b01)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "id": id,
        }

    @builtins.property
    def id(self) -> builtins.str:
        '''Resource ID of the virtual network gateway.'''
        result = self._values.get("id")
        assert result is not None, "Required property 'id' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "GatewayReference(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.HealthProbeReference",
    jsii_struct_bases=[],
    name_mapping={"id": "id"},
)
class HealthProbeReference:
    def __init__(self, *, id: builtins.str) -> None:
        '''Health probe reference.

        :param id: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f4a8f5a203702a85aaf08f022db1be834fae6ef4e0d0ad501ec4af11d7801c08)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "id": id,
        }

    @builtins.property
    def id(self) -> builtins.str:
        result = self._values.get("id")
        assert result is not None, "Required property 'id' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "HealthProbeReference(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.HostGroupReference",
    jsii_struct_bases=[],
    name_mapping={"id": "id"},
)
class HostGroupReference:
    def __init__(self, *, id: builtins.str) -> None:
        '''Host group reference.

        :param id: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b2bb61df160c5b503673ff36f45ba57832f4d44bcbb2cf9ddd1d7c749a4ab09b)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "id": id,
        }

    @builtins.property
    def id(self) -> builtins.str:
        result = self._values.get("id")
        assert result is not None, "Required property 'id' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "HostGroupReference(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.Hub",
    jsii_struct_bases=[],
    name_mapping={"resource_id": "resourceId", "resource_type": "resourceType"},
)
class Hub:
    def __init__(
        self,
        *,
        resource_id: builtins.str,
        resource_type: builtins.str,
    ) -> None:
        '''Hub configuration for hub-and-spoke topology.

        :param resource_id: 
        :param resource_type: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__29e25e92fadf378f0d69ad0e8105c70dcc60e22faddc3f850957d813f26048b9)
            check_type(argname="argument resource_id", value=resource_id, expected_type=type_hints["resource_id"])
            check_type(argname="argument resource_type", value=resource_type, expected_type=type_hints["resource_type"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "resource_id": resource_id,
            "resource_type": resource_type,
        }

    @builtins.property
    def resource_id(self) -> builtins.str:
        result = self._values.get("resource_id")
        assert result is not None, "Required property 'resource_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def resource_type(self) -> builtins.str:
        result = self._values.get("resource_type")
        assert result is not None, "Required property 'resource_type' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "Hub(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.interface(jsii_type="@microsoft/terraform-cdk-constructs.IPConfiguration")
class IPConfiguration(typing_extensions.Protocol):
    '''Network interface IP configuration.'''

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        ...

    @builtins.property
    @jsii.member(jsii_name="properties")
    def properties(self) -> typing.Optional[_IPConfigurationProperties_1aaf4cca]:
        ...


class _IPConfigurationProxy:
    '''Network interface IP configuration.'''

    __jsii_type__: typing.ClassVar[str] = "@microsoft/terraform-cdk-constructs.IPConfiguration"

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @builtins.property
    @jsii.member(jsii_name="properties")
    def properties(self) -> typing.Optional[_IPConfigurationProperties_1aaf4cca]:
        return typing.cast(typing.Optional[_IPConfigurationProperties_1aaf4cca], jsii.get(self, "properties"))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IPConfiguration).__jsii_proxy_class__ = lambda : _IPConfigurationProxy


@jsii.interface(
    jsii_type="@microsoft/terraform-cdk-constructs.IPConfigurationProperties"
)
class IPConfigurationProperties(typing_extensions.Protocol):
    '''IP configuration properties.'''

    @builtins.property
    @jsii.member(jsii_name="applicationGatewayBackendAddressPools")
    def application_gateway_backend_address_pools(
        self,
    ) -> typing.Optional[typing.List[_ResourceReference_d41d8a5a]]:
        ...

    @builtins.property
    @jsii.member(jsii_name="loadBalancerBackendAddressPools")
    def load_balancer_backend_address_pools(
        self,
    ) -> typing.Optional[typing.List[_ResourceReference_d41d8a5a]]:
        ...

    @builtins.property
    @jsii.member(jsii_name="loadBalancerInboundNatPools")
    def load_balancer_inbound_nat_pools(
        self,
    ) -> typing.Optional[typing.List[_ResourceReference_d41d8a5a]]:
        ...

    @builtins.property
    @jsii.member(jsii_name="primary")
    def primary(self) -> typing.Optional[builtins.bool]:
        ...

    @builtins.property
    @jsii.member(jsii_name="privateIPAddressVersion")
    def private_ip_address_version(self) -> typing.Optional[builtins.str]:
        ...

    @builtins.property
    @jsii.member(jsii_name="publicIPAddressConfiguration")
    def public_ip_address_configuration(
        self,
    ) -> typing.Optional[_PublicIPAddressConfiguration_b1ff4aec]:
        ...

    @builtins.property
    @jsii.member(jsii_name="subnet")
    def subnet(self) -> typing.Optional[_IPConfigurationSubnet_5df9d616]:
        ...


class _IPConfigurationPropertiesProxy:
    '''IP configuration properties.'''

    __jsii_type__: typing.ClassVar[str] = "@microsoft/terraform-cdk-constructs.IPConfigurationProperties"

    @builtins.property
    @jsii.member(jsii_name="applicationGatewayBackendAddressPools")
    def application_gateway_backend_address_pools(
        self,
    ) -> typing.Optional[typing.List[_ResourceReference_d41d8a5a]]:
        return typing.cast(typing.Optional[typing.List[_ResourceReference_d41d8a5a]], jsii.get(self, "applicationGatewayBackendAddressPools"))

    @builtins.property
    @jsii.member(jsii_name="loadBalancerBackendAddressPools")
    def load_balancer_backend_address_pools(
        self,
    ) -> typing.Optional[typing.List[_ResourceReference_d41d8a5a]]:
        return typing.cast(typing.Optional[typing.List[_ResourceReference_d41d8a5a]], jsii.get(self, "loadBalancerBackendAddressPools"))

    @builtins.property
    @jsii.member(jsii_name="loadBalancerInboundNatPools")
    def load_balancer_inbound_nat_pools(
        self,
    ) -> typing.Optional[typing.List[_ResourceReference_d41d8a5a]]:
        return typing.cast(typing.Optional[typing.List[_ResourceReference_d41d8a5a]], jsii.get(self, "loadBalancerInboundNatPools"))

    @builtins.property
    @jsii.member(jsii_name="primary")
    def primary(self) -> typing.Optional[builtins.bool]:
        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "primary"))

    @builtins.property
    @jsii.member(jsii_name="privateIPAddressVersion")
    def private_ip_address_version(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "privateIPAddressVersion"))

    @builtins.property
    @jsii.member(jsii_name="publicIPAddressConfiguration")
    def public_ip_address_configuration(
        self,
    ) -> typing.Optional[_PublicIPAddressConfiguration_b1ff4aec]:
        return typing.cast(typing.Optional[_PublicIPAddressConfiguration_b1ff4aec], jsii.get(self, "publicIPAddressConfiguration"))

    @builtins.property
    @jsii.member(jsii_name="subnet")
    def subnet(self) -> typing.Optional[_IPConfigurationSubnet_5df9d616]:
        return typing.cast(typing.Optional[_IPConfigurationSubnet_5df9d616], jsii.get(self, "subnet"))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IPConfigurationProperties).__jsii_proxy_class__ = lambda : _IPConfigurationPropertiesProxy


@jsii.interface(jsii_type="@microsoft/terraform-cdk-constructs.IPConfigurationSubnet")
class IPConfigurationSubnet(typing_extensions.Protocol):
    '''IP configuration subnet reference.'''

    @builtins.property
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        ...


class _IPConfigurationSubnetProxy:
    '''IP configuration subnet reference.'''

    __jsii_type__: typing.ClassVar[str] = "@microsoft/terraform-cdk-constructs.IPConfigurationSubnet"

    @builtins.property
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IPConfigurationSubnet).__jsii_proxy_class__ = lambda : _IPConfigurationSubnetProxy


class IpamPool(
    _AzapiResource_7e7f5b39,
    metaclass=jsii.JSIIMeta,
    jsii_type="@microsoft/terraform-cdk-constructs.IpamPool",
):
    '''Azure Virtual Network Manager IPAM Pool implementation.

    IPAM Pools provide centralized IP address management for virtual networks,
    enabling automatic CIDR allocation, overlap prevention, and hierarchical
    address space organization. They are essential for managing IP addresses
    at scale across multiple virtual networks and subscriptions.

    Example::

        // Hierarchical pool with parent reference:
        const childPool = new IpamPool(this, "eastus-pool", {
          name: "eastus-pool",
          location: "eastus",
          networkManagerId: networkManager.id,
          addressPrefixes: ["10.1.0.0/16"],
          parentPoolName: "production-pool",
          description: "East US regional pool"
        });
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        address_prefixes: typing.Sequence[builtins.str],
        network_manager_id: builtins.str,
        description: typing.Optional[builtins.str] = None,
        display_name: typing.Optional[builtins.str] = None,
        ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
        parent_pool_name: typing.Optional[builtins.str] = None,
        api_version: typing.Optional[builtins.str] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        location: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> None:
        '''Creates a new Azure Virtual Network Manager IPAM Pool using the AzapiResource framework.

        :param scope: - The scope in which to define this construct.
        :param id: - The unique identifier for this instance.
        :param address_prefixes: IP address prefixes for the pool Must be valid CIDR notation (e.g., "10.0.0.0/8") Multiple prefixes must not overlap.
        :param network_manager_id: Resource ID of the parent Network Manager.
        :param description: Optional description of the IPAM pool.
        :param display_name: Optional friendly display name.
        :param ignore_changes: The lifecycle rules to ignore changes.
        :param parent_pool_name: Name of parent pool for hierarchical pools Leave empty/undefined for root pools.
        :param api_version: Explicit API version to use for this resource. If not specified, the latest active version will be automatically resolved. Use this for version pinning when stability is required over latest features. Default: Latest active version from ApiVersionManager
        :param enable_migration_analysis: Whether to enable migration analysis warnings. When true, the framework will analyze the current version for deprecation status and provide migration recommendations in the deployment output. Default: true
        :param enable_transformation: Whether to apply property transformations automatically. When true, properties will be automatically transformed according to the target schema's transformation rules. This enables backward compatibility. Default: true
        :param enable_validation: Whether to validate properties against the schema. When true, all properties will be validated against the API schema before resource creation. Validation errors will cause deployment failures. Default: true
        :param location: The location where the resource should be created. Default: Varies by resource type - see specific resource documentation
        :param monitoring: Monitoring configuration for this resource. Enables integrated monitoring with diagnostic settings, metric alerts, and activity log alerts. All monitoring is optional and disabled by default.
        :param name: The name of the resource.
        :param tags: Tags to apply to the resource.
        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c9ff9e44b292c2a0bcb84efb870f9059a6295981c4f7315f66b26458d3c3794b)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = _IpamPoolProps_d9986f49(
            address_prefixes=address_prefixes,
            network_manager_id=network_manager_id,
            description=description,
            display_name=display_name,
            ignore_changes=ignore_changes,
            parent_pool_name=parent_pool_name,
            api_version=api_version,
            enable_migration_analysis=enable_migration_analysis,
            enable_transformation=enable_transformation,
            enable_validation=enable_validation,
            location=location,
            monitoring=monitoring,
            name=name,
            tags=tags,
            connection=connection,
            count=count,
            depends_on=depends_on,
            for_each=for_each,
            lifecycle=lifecycle,
            provider=provider,
            provisioners=provisioners,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="apiSchema")
    def _api_schema(self) -> _ApiSchema_5ce0490e:
        '''Gets the API schema for the resolved version.'''
        return typing.cast(_ApiSchema_5ce0490e, jsii.invoke(self, "apiSchema", []))

    @jsii.member(jsii_name="createResourceBody")
    def _create_resource_body(self, props: typing.Any) -> typing.Any:
        '''Creates the resource body for the Azure API call.

        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__803568da2df208fc8b94a8706db225c4e7bc39f9463881e0ff29d7b1cd306ce6)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Any, jsii.invoke(self, "createResourceBody", [props]))

    @jsii.member(jsii_name="defaultVersion")
    def _default_version(self) -> builtins.str:
        '''Gets the default API version to use when no explicit version is specified.'''
        return typing.cast(builtins.str, jsii.invoke(self, "defaultVersion", []))

    @jsii.member(jsii_name="resolveParentId")
    def _resolve_parent_id(self, props: typing.Any) -> builtins.str:
        '''Resolves the parent resource ID for the IPAM Pool IPAM Pools are scoped to Network Managers.

        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4d478d2f961c34ab37a4dbf7a585954365bb7a0fc9cf86611747355957f033e4)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(builtins.str, jsii.invoke(self, "resolveParentId", [props]))

    @jsii.member(jsii_name="resourceType")
    def _resource_type(self) -> builtins.str:
        '''Gets the Azure resource type for IPAM Pools.'''
        return typing.cast(builtins.str, jsii.invoke(self, "resourceType", []))

    @builtins.property
    @jsii.member(jsii_name="idOutput")
    def id_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "idOutput"))

    @builtins.property
    @jsii.member(jsii_name="locationOutput")
    def location_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "locationOutput"))

    @builtins.property
    @jsii.member(jsii_name="nameOutput")
    def name_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "nameOutput"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def props(self) -> _IpamPoolProps_d9986f49:
        '''The input properties for this IPAM Pool instance.'''
        return typing.cast(_IpamPoolProps_d9986f49, jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="resourceName")
    def resource_name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "resourceName"))

    @builtins.property
    @jsii.member(jsii_name="totalAddressCount")
    def total_address_count(self) -> jsii.Number:
        '''Calculate total number of IP addresses in this pool Sums up all addresses from all CIDR blocks.

        :return: Total count of IP addresses across all prefixes

        Example::

            const pool = new IpamPool(this, "pool", {
              addressPrefixes: ["10.0.0.0/24", "10.1.0.0/24"]
            });
            console.log(pool.totalAddressCount); // 512 (256 + 256)
        '''
        return typing.cast(jsii.Number, jsii.get(self, "totalAddressCount"))


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.IpamPoolBody",
    jsii_struct_bases=[],
    name_mapping={"location": "location", "properties": "properties", "tags": "tags"},
)
class IpamPoolBody:
    def __init__(
        self,
        *,
        location: builtins.str,
        properties: typing.Union[_IpamPoolProperties_2b6465ac, typing.Dict[builtins.str, typing.Any]],
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''The resource body interface for Azure IPAM Pool API calls.

        :param location: 
        :param properties: 
        :param tags: 
        '''
        if isinstance(properties, dict):
            properties = _IpamPoolProperties_2b6465ac(**properties)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e3afcf0fef4c03dc600b357d809ccbf5eecad8bb6f1aae3b45f54f4497350428)
            check_type(argname="argument location", value=location, expected_type=type_hints["location"])
            check_type(argname="argument properties", value=properties, expected_type=type_hints["properties"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "location": location,
            "properties": properties,
        }
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def location(self) -> builtins.str:
        result = self._values.get("location")
        assert result is not None, "Required property 'location' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def properties(self) -> _IpamPoolProperties_2b6465ac:
        result = self._values.get("properties")
        assert result is not None, "Required property 'properties' is missing"
        return typing.cast(_IpamPoolProperties_2b6465ac, result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IpamPoolBody(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.IpamPoolProperties",
    jsii_struct_bases=[],
    name_mapping={
        "address_prefixes": "addressPrefixes",
        "description": "description",
        "display_name": "displayName",
        "parent_pool_name": "parentPoolName",
    },
)
class IpamPoolProperties:
    def __init__(
        self,
        *,
        address_prefixes: typing.Sequence[builtins.str],
        description: typing.Optional[builtins.str] = None,
        display_name: typing.Optional[builtins.str] = None,
        parent_pool_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for IPAM Pool body.

        :param address_prefixes: 
        :param description: 
        :param display_name: 
        :param parent_pool_name: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__639153e92ba53b278cc75e424e32ced0bb46aadd2097c2c1f1b5ea69ef9076ef)
            check_type(argname="argument address_prefixes", value=address_prefixes, expected_type=type_hints["address_prefixes"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument display_name", value=display_name, expected_type=type_hints["display_name"])
            check_type(argname="argument parent_pool_name", value=parent_pool_name, expected_type=type_hints["parent_pool_name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "address_prefixes": address_prefixes,
        }
        if description is not None:
            self._values["description"] = description
        if display_name is not None:
            self._values["display_name"] = display_name
        if parent_pool_name is not None:
            self._values["parent_pool_name"] = parent_pool_name

    @builtins.property
    def address_prefixes(self) -> typing.List[builtins.str]:
        result = self._values.get("address_prefixes")
        assert result is not None, "Required property 'address_prefixes' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def display_name(self) -> typing.Optional[builtins.str]:
        result = self._values.get("display_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def parent_pool_name(self) -> typing.Optional[builtins.str]:
        result = self._values.get("parent_pool_name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IpamPoolProperties(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.IpamPoolProps",
    jsii_struct_bases=[_AzapiResourceProps_141a2340],
    name_mapping={
        "connection": "connection",
        "count": "count",
        "depends_on": "dependsOn",
        "for_each": "forEach",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "provisioners": "provisioners",
        "api_version": "apiVersion",
        "enable_migration_analysis": "enableMigrationAnalysis",
        "enable_transformation": "enableTransformation",
        "enable_validation": "enableValidation",
        "location": "location",
        "monitoring": "monitoring",
        "name": "name",
        "tags": "tags",
        "address_prefixes": "addressPrefixes",
        "network_manager_id": "networkManagerId",
        "description": "description",
        "display_name": "displayName",
        "ignore_changes": "ignoreChanges",
        "parent_pool_name": "parentPoolName",
    },
)
class IpamPoolProps(_AzapiResourceProps_141a2340):
    def __init__(
        self,
        *,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
        api_version: typing.Optional[builtins.str] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        location: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        address_prefixes: typing.Sequence[builtins.str],
        network_manager_id: builtins.str,
        description: typing.Optional[builtins.str] = None,
        display_name: typing.Optional[builtins.str] = None,
        ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
        parent_pool_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for the Azure Virtual Network Manager IPAM Pool.

        Extends AzapiResourceProps with IPAM Pool specific properties

        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        :param api_version: Explicit API version to use for this resource. If not specified, the latest active version will be automatically resolved. Use this for version pinning when stability is required over latest features. Default: Latest active version from ApiVersionManager
        :param enable_migration_analysis: Whether to enable migration analysis warnings. When true, the framework will analyze the current version for deprecation status and provide migration recommendations in the deployment output. Default: true
        :param enable_transformation: Whether to apply property transformations automatically. When true, properties will be automatically transformed according to the target schema's transformation rules. This enables backward compatibility. Default: true
        :param enable_validation: Whether to validate properties against the schema. When true, all properties will be validated against the API schema before resource creation. Validation errors will cause deployment failures. Default: true
        :param location: The location where the resource should be created. Default: Varies by resource type - see specific resource documentation
        :param monitoring: Monitoring configuration for this resource. Enables integrated monitoring with diagnostic settings, metric alerts, and activity log alerts. All monitoring is optional and disabled by default.
        :param name: The name of the resource.
        :param tags: Tags to apply to the resource.
        :param address_prefixes: IP address prefixes for the pool Must be valid CIDR notation (e.g., "10.0.0.0/8") Multiple prefixes must not overlap.
        :param network_manager_id: Resource ID of the parent Network Manager.
        :param description: Optional description of the IPAM pool.
        :param display_name: Optional friendly display name.
        :param ignore_changes: The lifecycle rules to ignore changes.
        :param parent_pool_name: Name of parent pool for hierarchical pools Leave empty/undefined for root pools.
        '''
        if isinstance(lifecycle, dict):
            lifecycle = _cdktf_9a9027ec.TerraformResourceLifecycle(**lifecycle)
        if isinstance(monitoring, dict):
            monitoring = _MonitoringConfig_7c28df74(**monitoring)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__28ddcaa274b7ea77249135a293d76cb8001eb985f7b31ea75e84c7f3e7c5b95c)
            check_type(argname="argument connection", value=connection, expected_type=type_hints["connection"])
            check_type(argname="argument count", value=count, expected_type=type_hints["count"])
            check_type(argname="argument depends_on", value=depends_on, expected_type=type_hints["depends_on"])
            check_type(argname="argument for_each", value=for_each, expected_type=type_hints["for_each"])
            check_type(argname="argument lifecycle", value=lifecycle, expected_type=type_hints["lifecycle"])
            check_type(argname="argument provider", value=provider, expected_type=type_hints["provider"])
            check_type(argname="argument provisioners", value=provisioners, expected_type=type_hints["provisioners"])
            check_type(argname="argument api_version", value=api_version, expected_type=type_hints["api_version"])
            check_type(argname="argument enable_migration_analysis", value=enable_migration_analysis, expected_type=type_hints["enable_migration_analysis"])
            check_type(argname="argument enable_transformation", value=enable_transformation, expected_type=type_hints["enable_transformation"])
            check_type(argname="argument enable_validation", value=enable_validation, expected_type=type_hints["enable_validation"])
            check_type(argname="argument location", value=location, expected_type=type_hints["location"])
            check_type(argname="argument monitoring", value=monitoring, expected_type=type_hints["monitoring"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument address_prefixes", value=address_prefixes, expected_type=type_hints["address_prefixes"])
            check_type(argname="argument network_manager_id", value=network_manager_id, expected_type=type_hints["network_manager_id"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument display_name", value=display_name, expected_type=type_hints["display_name"])
            check_type(argname="argument ignore_changes", value=ignore_changes, expected_type=type_hints["ignore_changes"])
            check_type(argname="argument parent_pool_name", value=parent_pool_name, expected_type=type_hints["parent_pool_name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "address_prefixes": address_prefixes,
            "network_manager_id": network_manager_id,
        }
        if connection is not None:
            self._values["connection"] = connection
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if for_each is not None:
            self._values["for_each"] = for_each
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider
        if provisioners is not None:
            self._values["provisioners"] = provisioners
        if api_version is not None:
            self._values["api_version"] = api_version
        if enable_migration_analysis is not None:
            self._values["enable_migration_analysis"] = enable_migration_analysis
        if enable_transformation is not None:
            self._values["enable_transformation"] = enable_transformation
        if enable_validation is not None:
            self._values["enable_validation"] = enable_validation
        if location is not None:
            self._values["location"] = location
        if monitoring is not None:
            self._values["monitoring"] = monitoring
        if name is not None:
            self._values["name"] = name
        if tags is not None:
            self._values["tags"] = tags
        if description is not None:
            self._values["description"] = description
        if display_name is not None:
            self._values["display_name"] = display_name
        if ignore_changes is not None:
            self._values["ignore_changes"] = ignore_changes
        if parent_pool_name is not None:
            self._values["parent_pool_name"] = parent_pool_name

    @builtins.property
    def connection(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("connection")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]], result)

    @builtins.property
    def count(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]], result)

    @builtins.property
    def depends_on(
        self,
    ) -> typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]], result)

    @builtins.property
    def for_each(self) -> typing.Optional[_cdktf_9a9027ec.ITerraformIterator]:
        '''
        :stability: experimental
        '''
        result = self._values.get("for_each")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.ITerraformIterator], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[_cdktf_9a9027ec.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformProvider], result)

    @builtins.property
    def provisioners(
        self,
    ) -> typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provisioners")
        return typing.cast(typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]], result)

    @builtins.property
    def api_version(self) -> typing.Optional[builtins.str]:
        '''Explicit API version to use for this resource.

        If not specified, the latest active version will be automatically resolved.
        Use this for version pinning when stability is required over latest features.

        :default: Latest active version from ApiVersionManager

        Example::

            "2024-11-01"
        '''
        result = self._values.get("api_version")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def enable_migration_analysis(self) -> typing.Optional[builtins.bool]:
        '''Whether to enable migration analysis warnings.

        When true, the framework will analyze the current version for deprecation
        status and provide migration recommendations in the deployment output.

        :default: true
        '''
        result = self._values.get("enable_migration_analysis")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_transformation(self) -> typing.Optional[builtins.bool]:
        '''Whether to apply property transformations automatically.

        When true, properties will be automatically transformed according to the
        target schema's transformation rules. This enables backward compatibility.

        :default: true
        '''
        result = self._values.get("enable_transformation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_validation(self) -> typing.Optional[builtins.bool]:
        '''Whether to validate properties against the schema.

        When true, all properties will be validated against the API schema before
        resource creation. Validation errors will cause deployment failures.

        :default: true
        '''
        result = self._values.get("enable_validation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def location(self) -> typing.Optional[builtins.str]:
        '''The location where the resource should be created.

        :default: Varies by resource type - see specific resource documentation

        :remarks:

        Location handling varies by resource type:

        - **Top-level resources**: Most require an explicit location (e.g., "eastus", "westus")
        - **Global resources**: Some use "global" as location (e.g., Private DNS Zones)
        - **Child resources**: Inherit location from parent and should NOT set this property

        Each resource type may provide its own default through the ``resolveLocation()`` method.
        If no location is specified and no default exists, resource creation may fail.

        Example::

            // Child resource (Subnet) - do not set location
            // location: undefined (inherited from parent Virtual Network)
        '''
        result = self._values.get("location")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def monitoring(self) -> typing.Optional[_MonitoringConfig_7c28df74]:
        '''Monitoring configuration for this resource.

        Enables integrated monitoring with diagnostic settings, metric alerts,
        and activity log alerts. All monitoring is optional and disabled by default.

        Example::

            monitoring: {
              enabled: true,
              diagnosticSettings: {
                workspaceId: logAnalytics.id,
                metrics: ['AllMetrics'],
                logs: ['AuditLogs']
              },
              metricAlerts: [{
                name: 'high-cpu-alert',
                severity: 2,
                scopes: [], // Automatically set to this resource
                criteria: { ... },
                actions: [{ actionGroupId: actionGroup.id }]
              }]
            }
        '''
        result = self._values.get("monitoring")
        return typing.cast(typing.Optional[_MonitoringConfig_7c28df74], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the resource.'''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Tags to apply to the resource.'''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def address_prefixes(self) -> typing.List[builtins.str]:
        '''IP address prefixes for the pool Must be valid CIDR notation (e.g., "10.0.0.0/8") Multiple prefixes must not overlap.

        Example::

            ["10.0.0.0/8", "172.16.0.0/12"]
        '''
        result = self._values.get("address_prefixes")
        assert result is not None, "Required property 'address_prefixes' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def network_manager_id(self) -> builtins.str:
        '''Resource ID of the parent Network Manager.

        Example::

            "/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/rg/providers/Microsoft.Network/networkManagers/vnm"
        '''
        result = self._values.get("network_manager_id")
        assert result is not None, "Required property 'network_manager_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''Optional description of the IPAM pool.

        Example::

            "Production IP address pool for East US region"
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def display_name(self) -> typing.Optional[builtins.str]:
        '''Optional friendly display name.

        Example::

            "East US Production Pool"
        '''
        result = self._values.get("display_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ignore_changes(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The lifecycle rules to ignore changes.

        Example::

            ["tags"]
        '''
        result = self._values.get("ignore_changes")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def parent_pool_name(self) -> typing.Optional[builtins.str]:
        '''Name of parent pool for hierarchical pools Leave empty/undefined for root pools.

        Example::

            "root-pool"
        '''
        result = self._values.get("parent_pool_name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IpamPoolProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class IpamPoolStaticCidr(
    _AzapiResource_7e7f5b39,
    metaclass=jsii.JSIIMeta,
    jsii_type="@microsoft/terraform-cdk-constructs.IpamPoolStaticCidr",
):
    '''Azure Virtual Network Manager IPAM Pool Static CIDR implementation.

    Static CIDRs explicitly allocate IP address blocks within an IPAM pool,
    providing precise control over address space reservations. This is useful
    for manual IP address management or reserving specific ranges for particular
    purposes within the larger pool.

    Example::

        // Allocate with explicit IP count:
        const staticCidr = new IpamPoolStaticCidr(this, "database-servers", {
          name: "db-servers-cidr",
          ipamPoolId: ipamPool.id,
          addressPrefixes: ["10.0.2.0/24"],
          description: "Reserved for database servers",
          apiVersion: "2024-05-01"
        });
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        address_prefixes: typing.Sequence[builtins.str],
        ipam_pool_id: builtins.str,
        description: typing.Optional[builtins.str] = None,
        ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
        api_version: typing.Optional[builtins.str] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        location: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> None:
        '''Creates a new Azure Virtual Network Manager IPAM Pool Static CIDR using the AzapiResource framework.

        :param scope: - The scope in which to define this construct.
        :param id: - The unique identifier for this instance.
        :param address_prefixes: Array of IP address prefixes in CIDR notation Must be valid CIDR format (e.g., ["10.0.0.0/24"]) Must be contained within the parent pool's address space.
        :param ipam_pool_id: Resource ID of the parent IPAM Pool.
        :param description: Optional description of the static CIDR allocation.
        :param ignore_changes: The lifecycle rules to ignore changes.
        :param api_version: Explicit API version to use for this resource. If not specified, the latest active version will be automatically resolved. Use this for version pinning when stability is required over latest features. Default: Latest active version from ApiVersionManager
        :param enable_migration_analysis: Whether to enable migration analysis warnings. When true, the framework will analyze the current version for deprecation status and provide migration recommendations in the deployment output. Default: true
        :param enable_transformation: Whether to apply property transformations automatically. When true, properties will be automatically transformed according to the target schema's transformation rules. This enables backward compatibility. Default: true
        :param enable_validation: Whether to validate properties against the schema. When true, all properties will be validated against the API schema before resource creation. Validation errors will cause deployment failures. Default: true
        :param location: The location where the resource should be created. Default: Varies by resource type - see specific resource documentation
        :param monitoring: Monitoring configuration for this resource. Enables integrated monitoring with diagnostic settings, metric alerts, and activity log alerts. All monitoring is optional and disabled by default.
        :param name: The name of the resource.
        :param tags: Tags to apply to the resource.
        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9bab4767fcd01d506366995b14fafdf805ead5acb7f2e568af9c5399310b19db)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = _IpamPoolStaticCidrProps_f7b282ba(
            address_prefixes=address_prefixes,
            ipam_pool_id=ipam_pool_id,
            description=description,
            ignore_changes=ignore_changes,
            api_version=api_version,
            enable_migration_analysis=enable_migration_analysis,
            enable_transformation=enable_transformation,
            enable_validation=enable_validation,
            location=location,
            monitoring=monitoring,
            name=name,
            tags=tags,
            connection=connection,
            count=count,
            depends_on=depends_on,
            for_each=for_each,
            lifecycle=lifecycle,
            provider=provider,
            provisioners=provisioners,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="apiSchema")
    def _api_schema(self) -> _ApiSchema_5ce0490e:
        '''Gets the API schema for the resolved version.'''
        return typing.cast(_ApiSchema_5ce0490e, jsii.invoke(self, "apiSchema", []))

    @jsii.member(jsii_name="createResourceBody")
    def _create_resource_body(self, props: typing.Any) -> typing.Any:
        '''Creates the resource body for the Azure API call Note: Child resources do not include location or tags.

        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__87e9ae62fe9291aa907de223dbd2bc749dd3a433d23b064970de8e23824b091c)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Any, jsii.invoke(self, "createResourceBody", [props]))

    @jsii.member(jsii_name="defaultVersion")
    def _default_version(self) -> builtins.str:
        '''Gets the default API version to use when no explicit version is specified.'''
        return typing.cast(builtins.str, jsii.invoke(self, "defaultVersion", []))

    @jsii.member(jsii_name="resolveParentId")
    def _resolve_parent_id(self, props: typing.Any) -> builtins.str:
        '''Resolves the parent resource ID for the Static CIDR Static CIDRs are scoped to IPAM Pools.

        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4c05bf7a720831203723b922cfbd29fecf3e6baa05cf6f0f4f1f7107652cfcc8)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(builtins.str, jsii.invoke(self, "resolveParentId", [props]))

    @jsii.member(jsii_name="resourceType")
    def _resource_type(self) -> builtins.str:
        '''Gets the Azure resource type for Static CIDRs.'''
        return typing.cast(builtins.str, jsii.invoke(self, "resourceType", []))

    @builtins.property
    @jsii.member(jsii_name="addressPrefixes")
    def address_prefixes(self) -> typing.List[builtins.str]:
        '''Get the address prefixes of this Static CIDR Returns the input addressPrefixes array.'''
        return typing.cast(typing.List[builtins.str], jsii.get(self, "addressPrefixes"))

    @builtins.property
    @jsii.member(jsii_name="addressPrefixOutput")
    def address_prefix_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "addressPrefixOutput"))

    @builtins.property
    @jsii.member(jsii_name="calculatedAddressCount")
    def calculated_address_count(self) -> jsii.Number:
        '''Get the calculated number of IP addresses in this CIDR block This is automatically calculated from the CIDR prefix at construct creation time.

        :return: Total count of IP addresses in the CIDR block

        Example::

            const staticCidr = new IpamPoolStaticCidr(this, "cidr", {
              addressPrefixes: ["10.0.1.0/24"]
            });
            console.log(staticCidr.calculatedAddressCount); // 256
        '''
        return typing.cast(jsii.Number, jsii.get(self, "calculatedAddressCount"))

    @builtins.property
    @jsii.member(jsii_name="idOutput")
    def id_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "idOutput"))

    @builtins.property
    @jsii.member(jsii_name="nameOutput")
    def name_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "nameOutput"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def props(self) -> _IpamPoolStaticCidrProps_f7b282ba:
        '''The input properties for this Static CIDR instance.'''
        return typing.cast(_IpamPoolStaticCidrProps_f7b282ba, jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        '''Get the provisioning state of the Static CIDR.'''
        return typing.cast(builtins.str, jsii.get(self, "provisioningState"))

    @builtins.property
    @jsii.member(jsii_name="resourceName")
    def resource_name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "resourceName"))


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.IpamPoolStaticCidrBody",
    jsii_struct_bases=[],
    name_mapping={"properties": "properties"},
)
class IpamPoolStaticCidrBody:
    def __init__(
        self,
        *,
        properties: typing.Union[_IpamPoolStaticCidrProperties_794c371f, typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''The resource body interface for Azure Static CIDR API calls.

        :param properties: 
        '''
        if isinstance(properties, dict):
            properties = _IpamPoolStaticCidrProperties_794c371f(**properties)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__54efe4527c56a7805702ecb1579e4cf495ca796ef437d4c744bc0feade4fdaf1)
            check_type(argname="argument properties", value=properties, expected_type=type_hints["properties"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "properties": properties,
        }

    @builtins.property
    def properties(self) -> _IpamPoolStaticCidrProperties_794c371f:
        result = self._values.get("properties")
        assert result is not None, "Required property 'properties' is missing"
        return typing.cast(_IpamPoolStaticCidrProperties_794c371f, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IpamPoolStaticCidrBody(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.IpamPoolStaticCidrProperties",
    jsii_struct_bases=[],
    name_mapping={"address_prefixes": "addressPrefixes", "description": "description"},
)
class IpamPoolStaticCidrProperties:
    def __init__(
        self,
        *,
        address_prefixes: typing.Sequence[builtins.str],
        description: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for Static CIDR body.

        :param address_prefixes: 
        :param description: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9a1afe665cd05cc80be183218566ef30141e797e7be85ea267fb49db1da365f3)
            check_type(argname="argument address_prefixes", value=address_prefixes, expected_type=type_hints["address_prefixes"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "address_prefixes": address_prefixes,
        }
        if description is not None:
            self._values["description"] = description

    @builtins.property
    def address_prefixes(self) -> typing.List[builtins.str]:
        result = self._values.get("address_prefixes")
        assert result is not None, "Required property 'address_prefixes' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IpamPoolStaticCidrProperties(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.IpamPoolStaticCidrProps",
    jsii_struct_bases=[_AzapiResourceProps_141a2340],
    name_mapping={
        "connection": "connection",
        "count": "count",
        "depends_on": "dependsOn",
        "for_each": "forEach",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "provisioners": "provisioners",
        "api_version": "apiVersion",
        "enable_migration_analysis": "enableMigrationAnalysis",
        "enable_transformation": "enableTransformation",
        "enable_validation": "enableValidation",
        "location": "location",
        "monitoring": "monitoring",
        "name": "name",
        "tags": "tags",
        "address_prefixes": "addressPrefixes",
        "ipam_pool_id": "ipamPoolId",
        "description": "description",
        "ignore_changes": "ignoreChanges",
    },
)
class IpamPoolStaticCidrProps(_AzapiResourceProps_141a2340):
    def __init__(
        self,
        *,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
        api_version: typing.Optional[builtins.str] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        location: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        address_prefixes: typing.Sequence[builtins.str],
        ipam_pool_id: builtins.str,
        description: typing.Optional[builtins.str] = None,
        ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''Properties for the Azure Virtual Network Manager IPAM Pool Static CIDR.

        Extends AzapiResourceProps with Static CIDR specific properties

        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        :param api_version: Explicit API version to use for this resource. If not specified, the latest active version will be automatically resolved. Use this for version pinning when stability is required over latest features. Default: Latest active version from ApiVersionManager
        :param enable_migration_analysis: Whether to enable migration analysis warnings. When true, the framework will analyze the current version for deprecation status and provide migration recommendations in the deployment output. Default: true
        :param enable_transformation: Whether to apply property transformations automatically. When true, properties will be automatically transformed according to the target schema's transformation rules. This enables backward compatibility. Default: true
        :param enable_validation: Whether to validate properties against the schema. When true, all properties will be validated against the API schema before resource creation. Validation errors will cause deployment failures. Default: true
        :param location: The location where the resource should be created. Default: Varies by resource type - see specific resource documentation
        :param monitoring: Monitoring configuration for this resource. Enables integrated monitoring with diagnostic settings, metric alerts, and activity log alerts. All monitoring is optional and disabled by default.
        :param name: The name of the resource.
        :param tags: Tags to apply to the resource.
        :param address_prefixes: Array of IP address prefixes in CIDR notation Must be valid CIDR format (e.g., ["10.0.0.0/24"]) Must be contained within the parent pool's address space.
        :param ipam_pool_id: Resource ID of the parent IPAM Pool.
        :param description: Optional description of the static CIDR allocation.
        :param ignore_changes: The lifecycle rules to ignore changes.
        '''
        if isinstance(lifecycle, dict):
            lifecycle = _cdktf_9a9027ec.TerraformResourceLifecycle(**lifecycle)
        if isinstance(monitoring, dict):
            monitoring = _MonitoringConfig_7c28df74(**monitoring)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2875835d0cec8aa2ab6445aaa5455c1d6877789bd85b35f04261345a036121cf)
            check_type(argname="argument connection", value=connection, expected_type=type_hints["connection"])
            check_type(argname="argument count", value=count, expected_type=type_hints["count"])
            check_type(argname="argument depends_on", value=depends_on, expected_type=type_hints["depends_on"])
            check_type(argname="argument for_each", value=for_each, expected_type=type_hints["for_each"])
            check_type(argname="argument lifecycle", value=lifecycle, expected_type=type_hints["lifecycle"])
            check_type(argname="argument provider", value=provider, expected_type=type_hints["provider"])
            check_type(argname="argument provisioners", value=provisioners, expected_type=type_hints["provisioners"])
            check_type(argname="argument api_version", value=api_version, expected_type=type_hints["api_version"])
            check_type(argname="argument enable_migration_analysis", value=enable_migration_analysis, expected_type=type_hints["enable_migration_analysis"])
            check_type(argname="argument enable_transformation", value=enable_transformation, expected_type=type_hints["enable_transformation"])
            check_type(argname="argument enable_validation", value=enable_validation, expected_type=type_hints["enable_validation"])
            check_type(argname="argument location", value=location, expected_type=type_hints["location"])
            check_type(argname="argument monitoring", value=monitoring, expected_type=type_hints["monitoring"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument address_prefixes", value=address_prefixes, expected_type=type_hints["address_prefixes"])
            check_type(argname="argument ipam_pool_id", value=ipam_pool_id, expected_type=type_hints["ipam_pool_id"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument ignore_changes", value=ignore_changes, expected_type=type_hints["ignore_changes"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "address_prefixes": address_prefixes,
            "ipam_pool_id": ipam_pool_id,
        }
        if connection is not None:
            self._values["connection"] = connection
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if for_each is not None:
            self._values["for_each"] = for_each
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider
        if provisioners is not None:
            self._values["provisioners"] = provisioners
        if api_version is not None:
            self._values["api_version"] = api_version
        if enable_migration_analysis is not None:
            self._values["enable_migration_analysis"] = enable_migration_analysis
        if enable_transformation is not None:
            self._values["enable_transformation"] = enable_transformation
        if enable_validation is not None:
            self._values["enable_validation"] = enable_validation
        if location is not None:
            self._values["location"] = location
        if monitoring is not None:
            self._values["monitoring"] = monitoring
        if name is not None:
            self._values["name"] = name
        if tags is not None:
            self._values["tags"] = tags
        if description is not None:
            self._values["description"] = description
        if ignore_changes is not None:
            self._values["ignore_changes"] = ignore_changes

    @builtins.property
    def connection(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("connection")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]], result)

    @builtins.property
    def count(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]], result)

    @builtins.property
    def depends_on(
        self,
    ) -> typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]], result)

    @builtins.property
    def for_each(self) -> typing.Optional[_cdktf_9a9027ec.ITerraformIterator]:
        '''
        :stability: experimental
        '''
        result = self._values.get("for_each")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.ITerraformIterator], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[_cdktf_9a9027ec.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformProvider], result)

    @builtins.property
    def provisioners(
        self,
    ) -> typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provisioners")
        return typing.cast(typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]], result)

    @builtins.property
    def api_version(self) -> typing.Optional[builtins.str]:
        '''Explicit API version to use for this resource.

        If not specified, the latest active version will be automatically resolved.
        Use this for version pinning when stability is required over latest features.

        :default: Latest active version from ApiVersionManager

        Example::

            "2024-11-01"
        '''
        result = self._values.get("api_version")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def enable_migration_analysis(self) -> typing.Optional[builtins.bool]:
        '''Whether to enable migration analysis warnings.

        When true, the framework will analyze the current version for deprecation
        status and provide migration recommendations in the deployment output.

        :default: true
        '''
        result = self._values.get("enable_migration_analysis")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_transformation(self) -> typing.Optional[builtins.bool]:
        '''Whether to apply property transformations automatically.

        When true, properties will be automatically transformed according to the
        target schema's transformation rules. This enables backward compatibility.

        :default: true
        '''
        result = self._values.get("enable_transformation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_validation(self) -> typing.Optional[builtins.bool]:
        '''Whether to validate properties against the schema.

        When true, all properties will be validated against the API schema before
        resource creation. Validation errors will cause deployment failures.

        :default: true
        '''
        result = self._values.get("enable_validation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def location(self) -> typing.Optional[builtins.str]:
        '''The location where the resource should be created.

        :default: Varies by resource type - see specific resource documentation

        :remarks:

        Location handling varies by resource type:

        - **Top-level resources**: Most require an explicit location (e.g., "eastus", "westus")
        - **Global resources**: Some use "global" as location (e.g., Private DNS Zones)
        - **Child resources**: Inherit location from parent and should NOT set this property

        Each resource type may provide its own default through the ``resolveLocation()`` method.
        If no location is specified and no default exists, resource creation may fail.

        Example::

            // Child resource (Subnet) - do not set location
            // location: undefined (inherited from parent Virtual Network)
        '''
        result = self._values.get("location")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def monitoring(self) -> typing.Optional[_MonitoringConfig_7c28df74]:
        '''Monitoring configuration for this resource.

        Enables integrated monitoring with diagnostic settings, metric alerts,
        and activity log alerts. All monitoring is optional and disabled by default.

        Example::

            monitoring: {
              enabled: true,
              diagnosticSettings: {
                workspaceId: logAnalytics.id,
                metrics: ['AllMetrics'],
                logs: ['AuditLogs']
              },
              metricAlerts: [{
                name: 'high-cpu-alert',
                severity: 2,
                scopes: [], // Automatically set to this resource
                criteria: { ... },
                actions: [{ actionGroupId: actionGroup.id }]
              }]
            }
        '''
        result = self._values.get("monitoring")
        return typing.cast(typing.Optional[_MonitoringConfig_7c28df74], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the resource.'''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Tags to apply to the resource.'''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def address_prefixes(self) -> typing.List[builtins.str]:
        '''Array of IP address prefixes in CIDR notation Must be valid CIDR format (e.g., ["10.0.0.0/24"]) Must be contained within the parent pool's address space.

        Example::

            ["10.0.1.0/24"]
        '''
        result = self._values.get("address_prefixes")
        assert result is not None, "Required property 'address_prefixes' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def ipam_pool_id(self) -> builtins.str:
        '''Resource ID of the parent IPAM Pool.

        Example::

            "/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/rg/providers/Microsoft.Network/networkManagers/vnm/ipamPools/prod-pool"
        '''
        result = self._values.get("ipam_pool_id")
        assert result is not None, "Required property 'ipam_pool_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''Optional description of the static CIDR allocation.

        Example::

            "Reserved for production web servers"
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ignore_changes(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The lifecycle rules to ignore changes.

        Example::

            ["tags"]
        '''
        result = self._values.get("ignore_changes")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IpamPoolStaticCidrProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.IpsecPolicy",
    jsii_struct_bases=[],
    name_mapping={
        "dh_group": "dhGroup",
        "ike_encryption": "ikeEncryption",
        "ike_integrity": "ikeIntegrity",
        "ipsec_encryption": "ipsecEncryption",
        "ipsec_integrity": "ipsecIntegrity",
        "pfs_group": "pfsGroup",
        "sa_data_size_kilobytes": "saDataSizeKilobytes",
        "sa_life_time_seconds": "saLifeTimeSeconds",
    },
)
class IpsecPolicy:
    def __init__(
        self,
        *,
        dh_group: builtins.str,
        ike_encryption: builtins.str,
        ike_integrity: builtins.str,
        ipsec_encryption: builtins.str,
        ipsec_integrity: builtins.str,
        pfs_group: builtins.str,
        sa_data_size_kilobytes: jsii.Number,
        sa_life_time_seconds: jsii.Number,
    ) -> None:
        '''IPsec policy configuration.

        :param dh_group: DH Group for IKE Phase 1.
        :param ike_encryption: IKE encryption algorithm.
        :param ike_integrity: IKE integrity algorithm.
        :param ipsec_encryption: IPsec encryption algorithm.
        :param ipsec_integrity: IPsec integrity algorithm.
        :param pfs_group: PFS Group for IKE Phase 2.
        :param sa_data_size_kilobytes: SA data size in kilobytes.
        :param sa_life_time_seconds: SA lifetime in seconds.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__25a6f130c465a86bd30bd551cd74a3c538afc1314acc2c7b3c8491261bd8d8bf)
            check_type(argname="argument dh_group", value=dh_group, expected_type=type_hints["dh_group"])
            check_type(argname="argument ike_encryption", value=ike_encryption, expected_type=type_hints["ike_encryption"])
            check_type(argname="argument ike_integrity", value=ike_integrity, expected_type=type_hints["ike_integrity"])
            check_type(argname="argument ipsec_encryption", value=ipsec_encryption, expected_type=type_hints["ipsec_encryption"])
            check_type(argname="argument ipsec_integrity", value=ipsec_integrity, expected_type=type_hints["ipsec_integrity"])
            check_type(argname="argument pfs_group", value=pfs_group, expected_type=type_hints["pfs_group"])
            check_type(argname="argument sa_data_size_kilobytes", value=sa_data_size_kilobytes, expected_type=type_hints["sa_data_size_kilobytes"])
            check_type(argname="argument sa_life_time_seconds", value=sa_life_time_seconds, expected_type=type_hints["sa_life_time_seconds"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "dh_group": dh_group,
            "ike_encryption": ike_encryption,
            "ike_integrity": ike_integrity,
            "ipsec_encryption": ipsec_encryption,
            "ipsec_integrity": ipsec_integrity,
            "pfs_group": pfs_group,
            "sa_data_size_kilobytes": sa_data_size_kilobytes,
            "sa_life_time_seconds": sa_life_time_seconds,
        }

    @builtins.property
    def dh_group(self) -> builtins.str:
        '''DH Group for IKE Phase 1.

        Example::

            "DHGroup14", "DHGroup2048", "ECP256", "ECP384"
        '''
        result = self._values.get("dh_group")
        assert result is not None, "Required property 'dh_group' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def ike_encryption(self) -> builtins.str:
        '''IKE encryption algorithm.

        Example::

            "AES128", "AES192", "AES256", "GCMAES128", "GCMAES256"
        '''
        result = self._values.get("ike_encryption")
        assert result is not None, "Required property 'ike_encryption' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def ike_integrity(self) -> builtins.str:
        '''IKE integrity algorithm.

        Example::

            "SHA256", "SHA384", "GCMAES128", "GCMAES256"
        '''
        result = self._values.get("ike_integrity")
        assert result is not None, "Required property 'ike_integrity' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def ipsec_encryption(self) -> builtins.str:
        '''IPsec encryption algorithm.

        Example::

            "AES128", "AES192", "AES256", "GCMAES128", "GCMAES192", "GCMAES256"
        '''
        result = self._values.get("ipsec_encryption")
        assert result is not None, "Required property 'ipsec_encryption' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def ipsec_integrity(self) -> builtins.str:
        '''IPsec integrity algorithm.

        Example::

            "SHA256", "GCMAES128", "GCMAES192", "GCMAES256"
        '''
        result = self._values.get("ipsec_integrity")
        assert result is not None, "Required property 'ipsec_integrity' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def pfs_group(self) -> builtins.str:
        '''PFS Group for IKE Phase 2.

        Example::

            "None", "PFS1", "PFS2", "PFS2048", "ECP256", "ECP384", "PFS24", "PFS14", "PFSMM"
        '''
        result = self._values.get("pfs_group")
        assert result is not None, "Required property 'pfs_group' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def sa_data_size_kilobytes(self) -> jsii.Number:
        '''SA data size in kilobytes.

        Example::

            102400000
        '''
        result = self._values.get("sa_data_size_kilobytes")
        assert result is not None, "Required property 'sa_data_size_kilobytes' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def sa_life_time_seconds(self) -> jsii.Number:
        '''SA lifetime in seconds.

        Example::

            3600
        '''
        result = self._values.get("sa_life_time_seconds")
        assert result is not None, "Required property 'sa_life_time_seconds' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "IpsecPolicy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.LogicAppReceiver",
    jsii_struct_bases=[],
    name_mapping={
        "callback_url": "callbackUrl",
        "name": "name",
        "resource_id": "resourceId",
        "use_common_alert_schema": "useCommonAlertSchema",
    },
)
class LogicAppReceiver:
    def __init__(
        self,
        *,
        callback_url: builtins.str,
        name: builtins.str,
        resource_id: builtins.str,
        use_common_alert_schema: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Logic App receiver configuration.

        :param callback_url: The callback URL.
        :param name: The name of the Logic App receiver.
        :param resource_id: The Logic App resource ID.
        :param use_common_alert_schema: Whether to use common alert schema. Default: false
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cb69355060b3fd1d4c8b9b4af26633550be917d50a4589f76912cb7a6f5a56d9)
            check_type(argname="argument callback_url", value=callback_url, expected_type=type_hints["callback_url"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument resource_id", value=resource_id, expected_type=type_hints["resource_id"])
            check_type(argname="argument use_common_alert_schema", value=use_common_alert_schema, expected_type=type_hints["use_common_alert_schema"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "callback_url": callback_url,
            "name": name,
            "resource_id": resource_id,
        }
        if use_common_alert_schema is not None:
            self._values["use_common_alert_schema"] = use_common_alert_schema

    @builtins.property
    def callback_url(self) -> builtins.str:
        '''The callback URL.'''
        result = self._values.get("callback_url")
        assert result is not None, "Required property 'callback_url' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the Logic App receiver.'''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def resource_id(self) -> builtins.str:
        '''The Logic App resource ID.'''
        result = self._values.get("resource_id")
        assert result is not None, "Required property 'resource_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def use_common_alert_schema(self) -> typing.Optional[builtins.bool]:
        '''Whether to use common alert schema.

        :default: false
        '''
        result = self._values.get("use_common_alert_schema")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LogicAppReceiver(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class MetricAlert(
    _AzapiResource_7e7f5b39,
    metaclass=jsii.JSIIMeta,
    jsii_type="@microsoft/terraform-cdk-constructs.MetricAlert",
):
    '''Unified Azure Metric Alert implementation.

    This class provides a single, version-aware implementation that automatically handles version
    resolution, schema validation, and property transformation while maintaining full JSII compliance.

    Metric Alerts monitor Azure resource metrics and trigger notifications when thresholds are breached.
    They support both static thresholds and dynamic thresholds based on machine learning.

    Example::

        // Dynamic threshold alert with machine learning:
        const dynamicAlert = new MetricAlert(this, "dynamic-cpu", {
          name: "vm-dynamic-cpu-alert",
          resourceGroupId: resourceGroup.id,
          severity: 2,
          scopes: [resourceGroup.id],
          targetResourceType: "Microsoft.Compute/virtualMachines",
          targetResourceRegion: "eastus",
          criteria: {
            type: "DynamicThreshold",
            metricName: "Percentage CPU",
            operator: "GreaterThan",
            alertSensitivity: "Medium",
            failingPeriods: {
              numberOfEvaluationPeriods: 4,
              minFailingPeriodsToAlert: 3
            },
            timeAggregation: "Average"
          },
          actions: [{
            actionGroupId: actionGroup.id
          }]
        });
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        criteria: typing.Union[typing.Union[_StaticThresholdCriteria_e446085b, typing.Dict[builtins.str, typing.Any]], typing.Union[_DynamicThresholdCriteria_a75d1b26, typing.Dict[builtins.str, typing.Any]]],
        scopes: typing.Sequence[builtins.str],
        severity: jsii.Number,
        actions: typing.Optional[typing.Sequence[typing.Union[_MetricAlertAction_2c2527f4, typing.Dict[builtins.str, typing.Any]]]] = None,
        auto_mitigate: typing.Optional[builtins.bool] = None,
        description: typing.Optional[builtins.str] = None,
        enabled: typing.Optional[builtins.bool] = None,
        evaluation_frequency: typing.Optional[builtins.str] = None,
        resource_group_id: typing.Optional[builtins.str] = None,
        target_resource_region: typing.Optional[builtins.str] = None,
        target_resource_type: typing.Optional[builtins.str] = None,
        window_size: typing.Optional[builtins.str] = None,
        api_version: typing.Optional[builtins.str] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        location: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> None:
        '''Creates a new Azure Metric Alert using the AzapiResource framework.

        The constructor automatically handles version resolution, schema registration,
        validation, and resource creation.

        :param scope: - The scope in which to define this construct.
        :param id: - The unique identifier for this instance.
        :param criteria: Alert criteria (static or dynamic threshold).
        :param scopes: Resource IDs that this alert is scoped to.
        :param severity: Alert severity (0=Critical, 1=Error, 2=Warning, 3=Informational, 4=Verbose).
        :param actions: Action groups to notify.
        :param auto_mitigate: Auto-resolve alerts when condition is no longer met. Default: true
        :param description: Description of the alert rule.
        :param enabled: Whether the alert rule is enabled. Default: true
        :param evaluation_frequency: How often the alert is evaluated (ISO 8601 duration). Default: "PT5M"
        :param resource_group_id: Resource group ID where the metric alert will be created.
        :param target_resource_region: Region of the target resource (for multi-resource alerts).
        :param target_resource_type: Resource type of the target (for multi-resource alerts).
        :param window_size: Time window for aggregation (ISO 8601 duration). Default: "PT15M"
        :param api_version: Explicit API version to use for this resource. If not specified, the latest active version will be automatically resolved. Use this for version pinning when stability is required over latest features. Default: Latest active version from ApiVersionManager
        :param enable_migration_analysis: Whether to enable migration analysis warnings. When true, the framework will analyze the current version for deprecation status and provide migration recommendations in the deployment output. Default: true
        :param enable_transformation: Whether to apply property transformations automatically. When true, properties will be automatically transformed according to the target schema's transformation rules. This enables backward compatibility. Default: true
        :param enable_validation: Whether to validate properties against the schema. When true, all properties will be validated against the API schema before resource creation. Validation errors will cause deployment failures. Default: true
        :param location: The location where the resource should be created. Default: Varies by resource type - see specific resource documentation
        :param monitoring: Monitoring configuration for this resource. Enables integrated monitoring with diagnostic settings, metric alerts, and activity log alerts. All monitoring is optional and disabled by default.
        :param name: The name of the resource.
        :param tags: Tags to apply to the resource.
        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e1f36654b877ca5dcfe242e3b797b90d182f6fb1dd68d213e3adbba075df654c)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = _MetricAlertProps_a18d777f(
            criteria=criteria,
            scopes=scopes,
            severity=severity,
            actions=actions,
            auto_mitigate=auto_mitigate,
            description=description,
            enabled=enabled,
            evaluation_frequency=evaluation_frequency,
            resource_group_id=resource_group_id,
            target_resource_region=target_resource_region,
            target_resource_type=target_resource_type,
            window_size=window_size,
            api_version=api_version,
            enable_migration_analysis=enable_migration_analysis,
            enable_transformation=enable_transformation,
            enable_validation=enable_validation,
            location=location,
            monitoring=monitoring,
            name=name,
            tags=tags,
            connection=connection,
            count=count,
            depends_on=depends_on,
            for_each=for_each,
            lifecycle=lifecycle,
            provider=provider,
            provisioners=provisioners,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="addTag")
    def add_tag(self, key: builtins.str, value: builtins.str) -> None:
        '''Add a tag to the Metric Alert Note: This modifies the construct props but requires a new deployment to take effect.

        :param key: -
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6ae5d59e661be750b3bc3b0a2531ff2dc2a81ebaf7ed6bb3dd7ed155fd1e3a60)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "addTag", [key, value]))

    @jsii.member(jsii_name="apiSchema")
    def _api_schema(self) -> _ApiSchema_5ce0490e:
        '''Gets the API schema for the resolved version Uses the framework's schema resolution to get the appropriate schema.'''
        return typing.cast(_ApiSchema_5ce0490e, jsii.invoke(self, "apiSchema", []))

    @jsii.member(jsii_name="createResourceBody")
    def _create_resource_body(self, props: typing.Any) -> typing.Any:
        '''Creates the resource body for the Azure API call Transforms the input properties into the JSON format expected by Azure REST API.

        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f12aeebf97e5d729cbfc80b96445383e3a7b07bdd19ab43e2c352aae0ee9b055)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Any, jsii.invoke(self, "createResourceBody", [props]))

    @jsii.member(jsii_name="defaultVersion")
    def _default_version(self) -> builtins.str:
        '''Gets the default API version to use when no explicit version is specified Returns the most recent stable version as the default.'''
        return typing.cast(builtins.str, jsii.invoke(self, "defaultVersion", []))

    @jsii.member(jsii_name="removeTag")
    def remove_tag(self, key: builtins.str) -> None:
        '''Remove a tag from the Metric Alert Note: This modifies the construct props but requires a new deployment to take effect.

        :param key: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dab885a09e266a5d33461ae9e5d4f0f63e616fe37185a3fdd1b284b4416350a5)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
        return typing.cast(None, jsii.invoke(self, "removeTag", [key]))

    @jsii.member(jsii_name="resourceType")
    def _resource_type(self) -> builtins.str:
        '''Gets the Azure resource type for Metric Alerts.'''
        return typing.cast(builtins.str, jsii.invoke(self, "resourceType", []))

    @builtins.property
    @jsii.member(jsii_name="idOutput")
    def id_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "idOutput"))

    @builtins.property
    @jsii.member(jsii_name="nameOutput")
    def name_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "nameOutput"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def props(self) -> _MetricAlertProps_a18d777f:
        '''The input properties for this Metric Alert instance.'''
        return typing.cast(_MetricAlertProps_a18d777f, jsii.get(self, "props"))


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.MetricAlertAction",
    jsii_struct_bases=[],
    name_mapping={
        "action_group_id": "actionGroupId",
        "web_hook_properties": "webHookProperties",
    },
)
class MetricAlertAction:
    def __init__(
        self,
        *,
        action_group_id: builtins.str,
        web_hook_properties: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''Metric alert action configuration.

        :param action_group_id: The action group resource ID.
        :param web_hook_properties: Webhook properties (optional).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2d4a18d552893dfcc3c7437fb5f01775ef561ffe108fc245bc1cba58d068ac67)
            check_type(argname="argument action_group_id", value=action_group_id, expected_type=type_hints["action_group_id"])
            check_type(argname="argument web_hook_properties", value=web_hook_properties, expected_type=type_hints["web_hook_properties"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "action_group_id": action_group_id,
        }
        if web_hook_properties is not None:
            self._values["web_hook_properties"] = web_hook_properties

    @builtins.property
    def action_group_id(self) -> builtins.str:
        '''The action group resource ID.'''
        result = self._values.get("action_group_id")
        assert result is not None, "Required property 'action_group_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def web_hook_properties(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Webhook properties (optional).'''
        result = self._values.get("web_hook_properties")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "MetricAlertAction(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.MetricAlertBody",
    jsii_struct_bases=[],
    name_mapping={"location": "location", "properties": "properties", "tags": "tags"},
)
class MetricAlertBody:
    def __init__(
        self,
        *,
        location: builtins.str,
        properties: typing.Union[_MetricAlertBodyProperties_8cfa84e9, typing.Dict[builtins.str, typing.Any]],
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''The resource body interface for Azure Metric Alert API calls.

        :param location: 
        :param properties: 
        :param tags: 
        '''
        if isinstance(properties, dict):
            properties = _MetricAlertBodyProperties_8cfa84e9(**properties)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9b051cf9c1014315e4a4c0a7276e9c0cc45e28efe6f80bf3b75e727b8978587f)
            check_type(argname="argument location", value=location, expected_type=type_hints["location"])
            check_type(argname="argument properties", value=properties, expected_type=type_hints["properties"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "location": location,
            "properties": properties,
        }
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def location(self) -> builtins.str:
        result = self._values.get("location")
        assert result is not None, "Required property 'location' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def properties(self) -> _MetricAlertBodyProperties_8cfa84e9:
        result = self._values.get("properties")
        assert result is not None, "Required property 'properties' is missing"
        return typing.cast(_MetricAlertBodyProperties_8cfa84e9, result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "MetricAlertBody(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.MetricAlertBodyProperties",
    jsii_struct_bases=[],
    name_mapping={
        "auto_mitigate": "autoMitigate",
        "criteria": "criteria",
        "enabled": "enabled",
        "evaluation_frequency": "evaluationFrequency",
        "scopes": "scopes",
        "severity": "severity",
        "window_size": "windowSize",
        "actions": "actions",
        "description": "description",
        "target_resource_region": "targetResourceRegion",
        "target_resource_type": "targetResourceType",
    },
)
class MetricAlertBodyProperties:
    def __init__(
        self,
        *,
        auto_mitigate: builtins.bool,
        criteria: typing.Any,
        enabled: builtins.bool,
        evaluation_frequency: builtins.str,
        scopes: typing.Sequence[builtins.str],
        severity: jsii.Number,
        window_size: builtins.str,
        actions: typing.Optional[typing.Sequence[typing.Union[_MetricAlertAction_2c2527f4, typing.Dict[builtins.str, typing.Any]]]] = None,
        description: typing.Optional[builtins.str] = None,
        target_resource_region: typing.Optional[builtins.str] = None,
        target_resource_type: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Metric Alert properties for the request body.

        :param auto_mitigate: 
        :param criteria: 
        :param enabled: 
        :param evaluation_frequency: 
        :param scopes: 
        :param severity: 
        :param window_size: 
        :param actions: 
        :param description: 
        :param target_resource_region: 
        :param target_resource_type: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__24b289e0a7554b03b9a72850656c8cd44172bd07569ec7cf1007c97c5562ff80)
            check_type(argname="argument auto_mitigate", value=auto_mitigate, expected_type=type_hints["auto_mitigate"])
            check_type(argname="argument criteria", value=criteria, expected_type=type_hints["criteria"])
            check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
            check_type(argname="argument evaluation_frequency", value=evaluation_frequency, expected_type=type_hints["evaluation_frequency"])
            check_type(argname="argument scopes", value=scopes, expected_type=type_hints["scopes"])
            check_type(argname="argument severity", value=severity, expected_type=type_hints["severity"])
            check_type(argname="argument window_size", value=window_size, expected_type=type_hints["window_size"])
            check_type(argname="argument actions", value=actions, expected_type=type_hints["actions"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument target_resource_region", value=target_resource_region, expected_type=type_hints["target_resource_region"])
            check_type(argname="argument target_resource_type", value=target_resource_type, expected_type=type_hints["target_resource_type"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "auto_mitigate": auto_mitigate,
            "criteria": criteria,
            "enabled": enabled,
            "evaluation_frequency": evaluation_frequency,
            "scopes": scopes,
            "severity": severity,
            "window_size": window_size,
        }
        if actions is not None:
            self._values["actions"] = actions
        if description is not None:
            self._values["description"] = description
        if target_resource_region is not None:
            self._values["target_resource_region"] = target_resource_region
        if target_resource_type is not None:
            self._values["target_resource_type"] = target_resource_type

    @builtins.property
    def auto_mitigate(self) -> builtins.bool:
        result = self._values.get("auto_mitigate")
        assert result is not None, "Required property 'auto_mitigate' is missing"
        return typing.cast(builtins.bool, result)

    @builtins.property
    def criteria(self) -> typing.Any:
        result = self._values.get("criteria")
        assert result is not None, "Required property 'criteria' is missing"
        return typing.cast(typing.Any, result)

    @builtins.property
    def enabled(self) -> builtins.bool:
        result = self._values.get("enabled")
        assert result is not None, "Required property 'enabled' is missing"
        return typing.cast(builtins.bool, result)

    @builtins.property
    def evaluation_frequency(self) -> builtins.str:
        result = self._values.get("evaluation_frequency")
        assert result is not None, "Required property 'evaluation_frequency' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def scopes(self) -> typing.List[builtins.str]:
        result = self._values.get("scopes")
        assert result is not None, "Required property 'scopes' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def severity(self) -> jsii.Number:
        result = self._values.get("severity")
        assert result is not None, "Required property 'severity' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def window_size(self) -> builtins.str:
        result = self._values.get("window_size")
        assert result is not None, "Required property 'window_size' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def actions(self) -> typing.Optional[typing.List[_MetricAlertAction_2c2527f4]]:
        result = self._values.get("actions")
        return typing.cast(typing.Optional[typing.List[_MetricAlertAction_2c2527f4]], result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def target_resource_region(self) -> typing.Optional[builtins.str]:
        result = self._values.get("target_resource_region")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def target_resource_type(self) -> typing.Optional[builtins.str]:
        result = self._values.get("target_resource_type")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "MetricAlertBodyProperties(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.MetricAlertFailingPeriods",
    jsii_struct_bases=[],
    name_mapping={
        "min_failing_periods_to_alert": "minFailingPeriodsToAlert",
        "number_of_evaluation_periods": "numberOfEvaluationPeriods",
    },
)
class MetricAlertFailingPeriods:
    def __init__(
        self,
        *,
        min_failing_periods_to_alert: jsii.Number,
        number_of_evaluation_periods: jsii.Number,
    ) -> None:
        '''Metric alert failing periods configuration.

        :param min_failing_periods_to_alert: Minimum failing periods to trigger alert.
        :param number_of_evaluation_periods: Number of evaluation periods.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a1a00e4a06cd3cf887a51deb7a7a474af9bbb39b9c06925de83bd1a888701465)
            check_type(argname="argument min_failing_periods_to_alert", value=min_failing_periods_to_alert, expected_type=type_hints["min_failing_periods_to_alert"])
            check_type(argname="argument number_of_evaluation_periods", value=number_of_evaluation_periods, expected_type=type_hints["number_of_evaluation_periods"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "min_failing_periods_to_alert": min_failing_periods_to_alert,
            "number_of_evaluation_periods": number_of_evaluation_periods,
        }

    @builtins.property
    def min_failing_periods_to_alert(self) -> jsii.Number:
        '''Minimum failing periods to trigger alert.'''
        result = self._values.get("min_failing_periods_to_alert")
        assert result is not None, "Required property 'min_failing_periods_to_alert' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def number_of_evaluation_periods(self) -> jsii.Number:
        '''Number of evaluation periods.'''
        result = self._values.get("number_of_evaluation_periods")
        assert result is not None, "Required property 'number_of_evaluation_periods' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "MetricAlertFailingPeriods(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.MetricAlertProps",
    jsii_struct_bases=[_AzapiResourceProps_141a2340],
    name_mapping={
        "connection": "connection",
        "count": "count",
        "depends_on": "dependsOn",
        "for_each": "forEach",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "provisioners": "provisioners",
        "api_version": "apiVersion",
        "enable_migration_analysis": "enableMigrationAnalysis",
        "enable_transformation": "enableTransformation",
        "enable_validation": "enableValidation",
        "location": "location",
        "monitoring": "monitoring",
        "name": "name",
        "tags": "tags",
        "criteria": "criteria",
        "scopes": "scopes",
        "severity": "severity",
        "actions": "actions",
        "auto_mitigate": "autoMitigate",
        "description": "description",
        "enabled": "enabled",
        "evaluation_frequency": "evaluationFrequency",
        "resource_group_id": "resourceGroupId",
        "target_resource_region": "targetResourceRegion",
        "target_resource_type": "targetResourceType",
        "window_size": "windowSize",
    },
)
class MetricAlertProps(_AzapiResourceProps_141a2340):
    def __init__(
        self,
        *,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
        api_version: typing.Optional[builtins.str] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        location: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        criteria: typing.Union[typing.Union[_StaticThresholdCriteria_e446085b, typing.Dict[builtins.str, typing.Any]], typing.Union[_DynamicThresholdCriteria_a75d1b26, typing.Dict[builtins.str, typing.Any]]],
        scopes: typing.Sequence[builtins.str],
        severity: jsii.Number,
        actions: typing.Optional[typing.Sequence[typing.Union[_MetricAlertAction_2c2527f4, typing.Dict[builtins.str, typing.Any]]]] = None,
        auto_mitigate: typing.Optional[builtins.bool] = None,
        description: typing.Optional[builtins.str] = None,
        enabled: typing.Optional[builtins.bool] = None,
        evaluation_frequency: typing.Optional[builtins.str] = None,
        resource_group_id: typing.Optional[builtins.str] = None,
        target_resource_region: typing.Optional[builtins.str] = None,
        target_resource_type: typing.Optional[builtins.str] = None,
        window_size: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for the unified Azure Metric Alert.

        Extends AzapiResourceProps with Metric Alert specific properties

        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        :param api_version: Explicit API version to use for this resource. If not specified, the latest active version will be automatically resolved. Use this for version pinning when stability is required over latest features. Default: Latest active version from ApiVersionManager
        :param enable_migration_analysis: Whether to enable migration analysis warnings. When true, the framework will analyze the current version for deprecation status and provide migration recommendations in the deployment output. Default: true
        :param enable_transformation: Whether to apply property transformations automatically. When true, properties will be automatically transformed according to the target schema's transformation rules. This enables backward compatibility. Default: true
        :param enable_validation: Whether to validate properties against the schema. When true, all properties will be validated against the API schema before resource creation. Validation errors will cause deployment failures. Default: true
        :param location: The location where the resource should be created. Default: Varies by resource type - see specific resource documentation
        :param monitoring: Monitoring configuration for this resource. Enables integrated monitoring with diagnostic settings, metric alerts, and activity log alerts. All monitoring is optional and disabled by default.
        :param name: The name of the resource.
        :param tags: Tags to apply to the resource.
        :param criteria: Alert criteria (static or dynamic threshold).
        :param scopes: Resource IDs that this alert is scoped to.
        :param severity: Alert severity (0=Critical, 1=Error, 2=Warning, 3=Informational, 4=Verbose).
        :param actions: Action groups to notify.
        :param auto_mitigate: Auto-resolve alerts when condition is no longer met. Default: true
        :param description: Description of the alert rule.
        :param enabled: Whether the alert rule is enabled. Default: true
        :param evaluation_frequency: How often the alert is evaluated (ISO 8601 duration). Default: "PT5M"
        :param resource_group_id: Resource group ID where the metric alert will be created.
        :param target_resource_region: Region of the target resource (for multi-resource alerts).
        :param target_resource_type: Resource type of the target (for multi-resource alerts).
        :param window_size: Time window for aggregation (ISO 8601 duration). Default: "PT15M"
        '''
        if isinstance(lifecycle, dict):
            lifecycle = _cdktf_9a9027ec.TerraformResourceLifecycle(**lifecycle)
        if isinstance(monitoring, dict):
            monitoring = _MonitoringConfig_7c28df74(**monitoring)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__620e753236b590df8ff25fe95c84a81b8c12d963bd6efc4628e360c2dc42648b)
            check_type(argname="argument connection", value=connection, expected_type=type_hints["connection"])
            check_type(argname="argument count", value=count, expected_type=type_hints["count"])
            check_type(argname="argument depends_on", value=depends_on, expected_type=type_hints["depends_on"])
            check_type(argname="argument for_each", value=for_each, expected_type=type_hints["for_each"])
            check_type(argname="argument lifecycle", value=lifecycle, expected_type=type_hints["lifecycle"])
            check_type(argname="argument provider", value=provider, expected_type=type_hints["provider"])
            check_type(argname="argument provisioners", value=provisioners, expected_type=type_hints["provisioners"])
            check_type(argname="argument api_version", value=api_version, expected_type=type_hints["api_version"])
            check_type(argname="argument enable_migration_analysis", value=enable_migration_analysis, expected_type=type_hints["enable_migration_analysis"])
            check_type(argname="argument enable_transformation", value=enable_transformation, expected_type=type_hints["enable_transformation"])
            check_type(argname="argument enable_validation", value=enable_validation, expected_type=type_hints["enable_validation"])
            check_type(argname="argument location", value=location, expected_type=type_hints["location"])
            check_type(argname="argument monitoring", value=monitoring, expected_type=type_hints["monitoring"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument criteria", value=criteria, expected_type=type_hints["criteria"])
            check_type(argname="argument scopes", value=scopes, expected_type=type_hints["scopes"])
            check_type(argname="argument severity", value=severity, expected_type=type_hints["severity"])
            check_type(argname="argument actions", value=actions, expected_type=type_hints["actions"])
            check_type(argname="argument auto_mitigate", value=auto_mitigate, expected_type=type_hints["auto_mitigate"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
            check_type(argname="argument evaluation_frequency", value=evaluation_frequency, expected_type=type_hints["evaluation_frequency"])
            check_type(argname="argument resource_group_id", value=resource_group_id, expected_type=type_hints["resource_group_id"])
            check_type(argname="argument target_resource_region", value=target_resource_region, expected_type=type_hints["target_resource_region"])
            check_type(argname="argument target_resource_type", value=target_resource_type, expected_type=type_hints["target_resource_type"])
            check_type(argname="argument window_size", value=window_size, expected_type=type_hints["window_size"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "criteria": criteria,
            "scopes": scopes,
            "severity": severity,
        }
        if connection is not None:
            self._values["connection"] = connection
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if for_each is not None:
            self._values["for_each"] = for_each
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider
        if provisioners is not None:
            self._values["provisioners"] = provisioners
        if api_version is not None:
            self._values["api_version"] = api_version
        if enable_migration_analysis is not None:
            self._values["enable_migration_analysis"] = enable_migration_analysis
        if enable_transformation is not None:
            self._values["enable_transformation"] = enable_transformation
        if enable_validation is not None:
            self._values["enable_validation"] = enable_validation
        if location is not None:
            self._values["location"] = location
        if monitoring is not None:
            self._values["monitoring"] = monitoring
        if name is not None:
            self._values["name"] = name
        if tags is not None:
            self._values["tags"] = tags
        if actions is not None:
            self._values["actions"] = actions
        if auto_mitigate is not None:
            self._values["auto_mitigate"] = auto_mitigate
        if description is not None:
            self._values["description"] = description
        if enabled is not None:
            self._values["enabled"] = enabled
        if evaluation_frequency is not None:
            self._values["evaluation_frequency"] = evaluation_frequency
        if resource_group_id is not None:
            self._values["resource_group_id"] = resource_group_id
        if target_resource_region is not None:
            self._values["target_resource_region"] = target_resource_region
        if target_resource_type is not None:
            self._values["target_resource_type"] = target_resource_type
        if window_size is not None:
            self._values["window_size"] = window_size

    @builtins.property
    def connection(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("connection")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]], result)

    @builtins.property
    def count(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]], result)

    @builtins.property
    def depends_on(
        self,
    ) -> typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]], result)

    @builtins.property
    def for_each(self) -> typing.Optional[_cdktf_9a9027ec.ITerraformIterator]:
        '''
        :stability: experimental
        '''
        result = self._values.get("for_each")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.ITerraformIterator], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[_cdktf_9a9027ec.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformProvider], result)

    @builtins.property
    def provisioners(
        self,
    ) -> typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provisioners")
        return typing.cast(typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]], result)

    @builtins.property
    def api_version(self) -> typing.Optional[builtins.str]:
        '''Explicit API version to use for this resource.

        If not specified, the latest active version will be automatically resolved.
        Use this for version pinning when stability is required over latest features.

        :default: Latest active version from ApiVersionManager

        Example::

            "2024-11-01"
        '''
        result = self._values.get("api_version")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def enable_migration_analysis(self) -> typing.Optional[builtins.bool]:
        '''Whether to enable migration analysis warnings.

        When true, the framework will analyze the current version for deprecation
        status and provide migration recommendations in the deployment output.

        :default: true
        '''
        result = self._values.get("enable_migration_analysis")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_transformation(self) -> typing.Optional[builtins.bool]:
        '''Whether to apply property transformations automatically.

        When true, properties will be automatically transformed according to the
        target schema's transformation rules. This enables backward compatibility.

        :default: true
        '''
        result = self._values.get("enable_transformation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_validation(self) -> typing.Optional[builtins.bool]:
        '''Whether to validate properties against the schema.

        When true, all properties will be validated against the API schema before
        resource creation. Validation errors will cause deployment failures.

        :default: true
        '''
        result = self._values.get("enable_validation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def location(self) -> typing.Optional[builtins.str]:
        '''The location where the resource should be created.

        :default: Varies by resource type - see specific resource documentation

        :remarks:

        Location handling varies by resource type:

        - **Top-level resources**: Most require an explicit location (e.g., "eastus", "westus")
        - **Global resources**: Some use "global" as location (e.g., Private DNS Zones)
        - **Child resources**: Inherit location from parent and should NOT set this property

        Each resource type may provide its own default through the ``resolveLocation()`` method.
        If no location is specified and no default exists, resource creation may fail.

        Example::

            // Child resource (Subnet) - do not set location
            // location: undefined (inherited from parent Virtual Network)
        '''
        result = self._values.get("location")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def monitoring(self) -> typing.Optional[_MonitoringConfig_7c28df74]:
        '''Monitoring configuration for this resource.

        Enables integrated monitoring with diagnostic settings, metric alerts,
        and activity log alerts. All monitoring is optional and disabled by default.

        Example::

            monitoring: {
              enabled: true,
              diagnosticSettings: {
                workspaceId: logAnalytics.id,
                metrics: ['AllMetrics'],
                logs: ['AuditLogs']
              },
              metricAlerts: [{
                name: 'high-cpu-alert',
                severity: 2,
                scopes: [], // Automatically set to this resource
                criteria: { ... },
                actions: [{ actionGroupId: actionGroup.id }]
              }]
            }
        '''
        result = self._values.get("monitoring")
        return typing.cast(typing.Optional[_MonitoringConfig_7c28df74], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the resource.'''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Tags to apply to the resource.'''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def criteria(
        self,
    ) -> typing.Union[_StaticThresholdCriteria_e446085b, _DynamicThresholdCriteria_a75d1b26]:
        '''Alert criteria (static or dynamic threshold).'''
        result = self._values.get("criteria")
        assert result is not None, "Required property 'criteria' is missing"
        return typing.cast(typing.Union[_StaticThresholdCriteria_e446085b, _DynamicThresholdCriteria_a75d1b26], result)

    @builtins.property
    def scopes(self) -> typing.List[builtins.str]:
        '''Resource IDs that this alert is scoped to.

        Example::

            ["/subscriptions/.../resourceGroups/.../providers/Microsoft.Compute/virtualMachines/myVM"]
        '''
        result = self._values.get("scopes")
        assert result is not None, "Required property 'scopes' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def severity(self) -> jsii.Number:
        '''Alert severity (0=Critical, 1=Error, 2=Warning, 3=Informational, 4=Verbose).

        Example::

            2
        '''
        result = self._values.get("severity")
        assert result is not None, "Required property 'severity' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def actions(self) -> typing.Optional[typing.List[_MetricAlertAction_2c2527f4]]:
        '''Action groups to notify.'''
        result = self._values.get("actions")
        return typing.cast(typing.Optional[typing.List[_MetricAlertAction_2c2527f4]], result)

    @builtins.property
    def auto_mitigate(self) -> typing.Optional[builtins.bool]:
        '''Auto-resolve alerts when condition is no longer met.

        :default: true
        '''
        result = self._values.get("auto_mitigate")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''Description of the alert rule.'''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def enabled(self) -> typing.Optional[builtins.bool]:
        '''Whether the alert rule is enabled.

        :default: true
        '''
        result = self._values.get("enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def evaluation_frequency(self) -> typing.Optional[builtins.str]:
        '''How often the alert is evaluated (ISO 8601 duration).

        :default: "PT5M"

        Example::

            "PT1M", "PT5M", "PT15M"
        '''
        result = self._values.get("evaluation_frequency")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def resource_group_id(self) -> typing.Optional[builtins.str]:
        '''Resource group ID where the metric alert will be created.'''
        result = self._values.get("resource_group_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def target_resource_region(self) -> typing.Optional[builtins.str]:
        '''Region of the target resource (for multi-resource alerts).

        Example::

            "eastus"
        '''
        result = self._values.get("target_resource_region")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def target_resource_type(self) -> typing.Optional[builtins.str]:
        '''Resource type of the target (for multi-resource alerts).

        Example::

            "Microsoft.Compute/virtualMachines"
        '''
        result = self._values.get("target_resource_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def window_size(self) -> typing.Optional[builtins.str]:
        '''Time window for aggregation (ISO 8601 duration).

        :default: "PT15M"

        Example::

            "PT5M", "PT15M", "PT30M", "PT1H"
        '''
        result = self._values.get("window_size")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "MetricAlertProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.MetricDimension",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "operator": "operator", "values": "values"},
)
class MetricDimension:
    def __init__(
        self,
        *,
        name: builtins.str,
        operator: builtins.str,
        values: typing.Sequence[builtins.str],
    ) -> None:
        '''Metric dimension for filtering.

        :param name: The dimension name.
        :param operator: The operator (Include or Exclude).
        :param values: The dimension values.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fc2ba8b8be11d71526f7ede737d04c11aec98571db06d7a10e26445e3cb14cce)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
            "operator": operator,
            "values": values,
        }

    @builtins.property
    def name(self) -> builtins.str:
        '''The dimension name.'''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''The operator (Include or Exclude).'''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.List[builtins.str]:
        '''The dimension values.'''
        result = self._values.get("values")
        assert result is not None, "Required property 'values' is missing"
        return typing.cast(typing.List[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "MetricDimension(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.MigrationAnalysis",
    jsii_struct_bases=[],
    name_mapping={
        "automatic_upgrade_possible": "automaticUpgradePossible",
        "breaking_changes": "breakingChanges",
        "compatible": "compatible",
        "estimated_effort": "estimatedEffort",
        "from_version": "fromVersion",
        "to_version": "toVersion",
        "warnings": "warnings",
    },
)
class MigrationAnalysis:
    def __init__(
        self,
        *,
        automatic_upgrade_possible: builtins.bool,
        breaking_changes: typing.Sequence[typing.Union[_BreakingChange_5dc94c31, typing.Dict[builtins.str, typing.Any]]],
        compatible: builtins.bool,
        estimated_effort: builtins.str,
        from_version: builtins.str,
        to_version: builtins.str,
        warnings: typing.Sequence[builtins.str],
    ) -> None:
        '''Migration analysis result.

        Results of analyzing the migration path between two API versions.
        Provides compatibility assessment, effort estimation, and detailed
        guidance for version transitions.

        :param automatic_upgrade_possible: Whether automatic upgrade tooling can handle this migration If true, migration can be largely automated.
        :param breaking_changes: Array of breaking changes that affect the migration Each change includes guidance on how to handle it.
        :param compatible: Whether the migration is backward compatible If true, migration should be straightforward.
        :param estimated_effort: Estimated effort required for the migration Must be one of the MigrationEffort constants.
        :param from_version: Source API version being migrated from.
        :param to_version: Target API version being migrated to.
        :param warnings: Array of non-breaking warnings about the migration May include deprecation notices or recommendations.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6f99329161317c6ea230489d13d3b312b6a9a38e9284fb0793d516aea95891c7)
            check_type(argname="argument automatic_upgrade_possible", value=automatic_upgrade_possible, expected_type=type_hints["automatic_upgrade_possible"])
            check_type(argname="argument breaking_changes", value=breaking_changes, expected_type=type_hints["breaking_changes"])
            check_type(argname="argument compatible", value=compatible, expected_type=type_hints["compatible"])
            check_type(argname="argument estimated_effort", value=estimated_effort, expected_type=type_hints["estimated_effort"])
            check_type(argname="argument from_version", value=from_version, expected_type=type_hints["from_version"])
            check_type(argname="argument to_version", value=to_version, expected_type=type_hints["to_version"])
            check_type(argname="argument warnings", value=warnings, expected_type=type_hints["warnings"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "automatic_upgrade_possible": automatic_upgrade_possible,
            "breaking_changes": breaking_changes,
            "compatible": compatible,
            "estimated_effort": estimated_effort,
            "from_version": from_version,
            "to_version": to_version,
            "warnings": warnings,
        }

    @builtins.property
    def automatic_upgrade_possible(self) -> builtins.bool:
        '''Whether automatic upgrade tooling can handle this migration If true, migration can be largely automated.'''
        result = self._values.get("automatic_upgrade_possible")
        assert result is not None, "Required property 'automatic_upgrade_possible' is missing"
        return typing.cast(builtins.bool, result)

    @builtins.property
    def breaking_changes(self) -> typing.List[_BreakingChange_5dc94c31]:
        '''Array of breaking changes that affect the migration Each change includes guidance on how to handle it.'''
        result = self._values.get("breaking_changes")
        assert result is not None, "Required property 'breaking_changes' is missing"
        return typing.cast(typing.List[_BreakingChange_5dc94c31], result)

    @builtins.property
    def compatible(self) -> builtins.bool:
        '''Whether the migration is backward compatible If true, migration should be straightforward.'''
        result = self._values.get("compatible")
        assert result is not None, "Required property 'compatible' is missing"
        return typing.cast(builtins.bool, result)

    @builtins.property
    def estimated_effort(self) -> builtins.str:
        '''Estimated effort required for the migration Must be one of the MigrationEffort constants.'''
        result = self._values.get("estimated_effort")
        assert result is not None, "Required property 'estimated_effort' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def from_version(self) -> builtins.str:
        '''Source API version being migrated from.

        Example::

            "2024-01-01"
        '''
        result = self._values.get("from_version")
        assert result is not None, "Required property 'from_version' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def to_version(self) -> builtins.str:
        '''Target API version being migrated to.

        Example::

            "2024-11-01"
        '''
        result = self._values.get("to_version")
        assert result is not None, "Required property 'to_version' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def warnings(self) -> typing.List[builtins.str]:
        '''Array of non-breaking warnings about the migration May include deprecation notices or recommendations.'''
        result = self._values.get("warnings")
        assert result is not None, "Required property 'warnings' is missing"
        return typing.cast(typing.List[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "MigrationAnalysis(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class MigrationEffort(
    metaclass=jsii.JSIIMeta,
    jsii_type="@microsoft/terraform-cdk-constructs.MigrationEffort",
):
    '''Migration effort estimation for version transitions.

    Helps developers understand the complexity of migrating between versions
    and plan development resources accordingly.
    '''

    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.python.classproperty
    @jsii.member(jsii_name="BREAKING")
    def BREAKING(cls) -> builtins.str:
        '''Breaking changes - major refactoring required Estimated time: > 3 days.'''
        return typing.cast(builtins.str, jsii.sget(cls, "BREAKING"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="HIGH")
    def HIGH(cls) -> builtins.str:
        '''High effort - significant manual changes required Estimated time: 1-3 days.'''
        return typing.cast(builtins.str, jsii.sget(cls, "HIGH"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="LOW")
    def LOW(cls) -> builtins.str:
        '''Low effort - mostly automatic with minimal manual changes Estimated time: < 1 hour.'''
        return typing.cast(builtins.str, jsii.sget(cls, "LOW"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="MEDIUM")
    def MEDIUM(cls) -> builtins.str:
        '''Medium effort - some manual changes required Estimated time: 1-8 hours.'''
        return typing.cast(builtins.str, jsii.sget(cls, "MEDIUM"))


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.MonitoringConfig",
    jsii_struct_bases=[],
    name_mapping={
        "action_groups": "actionGroups",
        "activity_log_alerts": "activityLogAlerts",
        "diagnostic_settings": "diagnosticSettings",
        "enabled": "enabled",
        "metric_alerts": "metricAlerts",
    },
)
class MonitoringConfig:
    def __init__(
        self,
        *,
        action_groups: typing.Optional[typing.Sequence[typing.Union[_ActionGroupProps_572d2b68, typing.Dict[builtins.str, typing.Any]]]] = None,
        activity_log_alerts: typing.Optional[typing.Sequence[typing.Union[_ActivityLogAlertProps_f1779054, typing.Dict[builtins.str, typing.Any]]]] = None,
        diagnostic_settings: typing.Optional[typing.Union[_DiagnosticSettingsProps_cc0fa615, typing.Dict[builtins.str, typing.Any]]] = None,
        enabled: typing.Optional[builtins.bool] = None,
        metric_alerts: typing.Optional[typing.Sequence[typing.Union[_MetricAlertProps_a18d777f, typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Monitoring configuration for Azure resources.

        Provides integrated monitoring capabilities including diagnostic settings,
        metric alerts, and activity log alerts. All monitoring is optional and
        disabled by default.

        :param action_groups: Action groups to create for this resource Creates new ActionGroup instances as child constructs.
        :param activity_log_alerts: Activity log alerts configuration Creates ActivityLogAlert instances for this resource's operations.
        :param diagnostic_settings: Diagnostic settings configuration Uses the full DiagnosticSettings construct for consistency.
        :param enabled: Whether monitoring is enabled. Default: true
        :param metric_alerts: Metric alerts configuration Creates MetricAlert instances scoped to this resource.
        '''
        if isinstance(diagnostic_settings, dict):
            diagnostic_settings = _DiagnosticSettingsProps_cc0fa615(**diagnostic_settings)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__979125830a88d993d06bf79feb8aff88c075ba55b44bd7a5f15d635319dd55ea)
            check_type(argname="argument action_groups", value=action_groups, expected_type=type_hints["action_groups"])
            check_type(argname="argument activity_log_alerts", value=activity_log_alerts, expected_type=type_hints["activity_log_alerts"])
            check_type(argname="argument diagnostic_settings", value=diagnostic_settings, expected_type=type_hints["diagnostic_settings"])
            check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
            check_type(argname="argument metric_alerts", value=metric_alerts, expected_type=type_hints["metric_alerts"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if action_groups is not None:
            self._values["action_groups"] = action_groups
        if activity_log_alerts is not None:
            self._values["activity_log_alerts"] = activity_log_alerts
        if diagnostic_settings is not None:
            self._values["diagnostic_settings"] = diagnostic_settings
        if enabled is not None:
            self._values["enabled"] = enabled
        if metric_alerts is not None:
            self._values["metric_alerts"] = metric_alerts

    @builtins.property
    def action_groups(self) -> typing.Optional[typing.List[_ActionGroupProps_572d2b68]]:
        '''Action groups to create for this resource Creates new ActionGroup instances as child constructs.'''
        result = self._values.get("action_groups")
        return typing.cast(typing.Optional[typing.List[_ActionGroupProps_572d2b68]], result)

    @builtins.property
    def activity_log_alerts(
        self,
    ) -> typing.Optional[typing.List[_ActivityLogAlertProps_f1779054]]:
        '''Activity log alerts configuration Creates ActivityLogAlert instances for this resource's operations.'''
        result = self._values.get("activity_log_alerts")
        return typing.cast(typing.Optional[typing.List[_ActivityLogAlertProps_f1779054]], result)

    @builtins.property
    def diagnostic_settings(self) -> typing.Optional[_DiagnosticSettingsProps_cc0fa615]:
        '''Diagnostic settings configuration Uses the full DiagnosticSettings construct for consistency.'''
        result = self._values.get("diagnostic_settings")
        return typing.cast(typing.Optional[_DiagnosticSettingsProps_cc0fa615], result)

    @builtins.property
    def enabled(self) -> typing.Optional[builtins.bool]:
        '''Whether monitoring is enabled.

        :default: true
        '''
        result = self._values.get("enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def metric_alerts(self) -> typing.Optional[typing.List[_MetricAlertProps_a18d777f]]:
        '''Metric alerts configuration Creates MetricAlert instances scoped to this resource.'''
        result = self._values.get("metric_alerts")
        return typing.cast(typing.Optional[typing.List[_MetricAlertProps_a18d777f]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "MonitoringConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.NatRuleReference",
    jsii_struct_bases=[],
    name_mapping={"id": "id"},
)
class NatRuleReference:
    def __init__(self, *, id: builtins.str) -> None:
        '''NAT rule reference.

        :param id: Resource ID of the NAT rule.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__69f704d3ae38a0287bfb1fe9e4f5d2dfc42c97750aa6df5cc1005951520c041d)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "id": id,
        }

    @builtins.property
    def id(self) -> builtins.str:
        '''Resource ID of the NAT rule.'''
        result = self._values.get("id")
        assert result is not None, "Required property 'id' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "NatRuleReference(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class NetworkGroup(
    _AzapiResource_7e7f5b39,
    metaclass=jsii.JSIIMeta,
    jsii_type="@microsoft/terraform-cdk-constructs.NetworkGroup",
):
    '''Azure Virtual Network Manager Network Group implementation.

    Network Groups are logical containers for virtual networks or subnets that allow you to
    apply connectivity, security, or routing configurations at scale. They are a foundational
    component required by connectivity configurations, security admin configurations, and
    routing configurations.

    Example::

        // Network group with explicit version pinning:
        const devGroup = new NetworkGroup(this, "dev-group", {
          name: "development-vnets",
          networkManagerId: networkManager.id,
          apiVersion: "2024-05-01",
          description: "Development virtual networks"
        });
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        network_manager_id: builtins.str,
        description: typing.Optional[builtins.str] = None,
        ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
        member_type: typing.Optional[builtins.str] = None,
        api_version: typing.Optional[builtins.str] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        location: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> None:
        '''Creates a new Azure Virtual Network Manager Network Group using the AzapiResource framework.

        :param scope: - The scope in which to define this construct.
        :param id: - The unique identifier for this instance.
        :param network_manager_id: Resource ID of the parent Network Manager.
        :param description: Optional description of the network group.
        :param ignore_changes: The lifecycle rules to ignore changes.
        :param member_type: Type of members in this network group. Default: undefined (can contain both VirtualNetwork and Subnet members)
        :param api_version: Explicit API version to use for this resource. If not specified, the latest active version will be automatically resolved. Use this for version pinning when stability is required over latest features. Default: Latest active version from ApiVersionManager
        :param enable_migration_analysis: Whether to enable migration analysis warnings. When true, the framework will analyze the current version for deprecation status and provide migration recommendations in the deployment output. Default: true
        :param enable_transformation: Whether to apply property transformations automatically. When true, properties will be automatically transformed according to the target schema's transformation rules. This enables backward compatibility. Default: true
        :param enable_validation: Whether to validate properties against the schema. When true, all properties will be validated against the API schema before resource creation. Validation errors will cause deployment failures. Default: true
        :param location: The location where the resource should be created. Default: Varies by resource type - see specific resource documentation
        :param monitoring: Monitoring configuration for this resource. Enables integrated monitoring with diagnostic settings, metric alerts, and activity log alerts. All monitoring is optional and disabled by default.
        :param name: The name of the resource.
        :param tags: Tags to apply to the resource.
        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4256e7d6c58d1c573c451d8cf8cbc8446da4a4db7db4d38160829217fd991a35)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = _NetworkGroupProps_81c3604d(
            network_manager_id=network_manager_id,
            description=description,
            ignore_changes=ignore_changes,
            member_type=member_type,
            api_version=api_version,
            enable_migration_analysis=enable_migration_analysis,
            enable_transformation=enable_transformation,
            enable_validation=enable_validation,
            location=location,
            monitoring=monitoring,
            name=name,
            tags=tags,
            connection=connection,
            count=count,
            depends_on=depends_on,
            for_each=for_each,
            lifecycle=lifecycle,
            provider=provider,
            provisioners=provisioners,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="apiSchema")
    def _api_schema(self) -> _ApiSchema_5ce0490e:
        '''Gets the API schema for the resolved version.'''
        return typing.cast(_ApiSchema_5ce0490e, jsii.invoke(self, "apiSchema", []))

    @jsii.member(jsii_name="createResourceBody")
    def _create_resource_body(self, props: typing.Any) -> typing.Any:
        '''Creates the resource body for the Azure API call.

        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__67f389cd02edc28ede599ab958ee2f79cfdd5ab21e18e2bc34e6d00a727e05d2)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Any, jsii.invoke(self, "createResourceBody", [props]))

    @jsii.member(jsii_name="defaultVersion")
    def _default_version(self) -> builtins.str:
        '''Gets the default API version to use when no explicit version is specified.'''
        return typing.cast(builtins.str, jsii.invoke(self, "defaultVersion", []))

    @jsii.member(jsii_name="resolveParentId")
    def _resolve_parent_id(self, props: typing.Any) -> builtins.str:
        '''Resolves the parent resource ID for the Network Group Network Groups are scoped to Network Managers.

        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__44e8f461b4bc88dc5b57a00f404f4615ea7e185838f84a390e3bd754d16ad745)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(builtins.str, jsii.invoke(self, "resolveParentId", [props]))

    @jsii.member(jsii_name="resourceType")
    def _resource_type(self) -> builtins.str:
        '''Gets the Azure resource type for Network Groups.'''
        return typing.cast(builtins.str, jsii.invoke(self, "resourceType", []))

    @builtins.property
    @jsii.member(jsii_name="idOutput")
    def id_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "idOutput"))

    @builtins.property
    @jsii.member(jsii_name="nameOutput")
    def name_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "nameOutput"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def props(self) -> _NetworkGroupProps_81c3604d:
        '''The input properties for this Network Group instance.'''
        return typing.cast(_NetworkGroupProps_81c3604d, jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        '''Get the provisioning state of the Network Group.'''
        return typing.cast(builtins.str, jsii.get(self, "provisioningState"))

    @builtins.property
    @jsii.member(jsii_name="provisioningStateOutput")
    def provisioning_state_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "provisioningStateOutput"))

    @builtins.property
    @jsii.member(jsii_name="resourceName")
    def resource_name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "resourceName"))


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.NetworkGroupBody",
    jsii_struct_bases=[],
    name_mapping={"properties": "properties"},
)
class NetworkGroupBody:
    def __init__(
        self,
        *,
        properties: typing.Optional[typing.Union[_NetworkGroupProperties_c6b41db0, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''The resource body interface for Azure Network Group API calls.

        :param properties: 
        '''
        if isinstance(properties, dict):
            properties = _NetworkGroupProperties_c6b41db0(**properties)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e712f43b52b1ddf2d7095dc5db75e0327cd47cb8a2e23ebef6325a770f153df6)
            check_type(argname="argument properties", value=properties, expected_type=type_hints["properties"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if properties is not None:
            self._values["properties"] = properties

    @builtins.property
    def properties(self) -> typing.Optional[_NetworkGroupProperties_c6b41db0]:
        result = self._values.get("properties")
        return typing.cast(typing.Optional[_NetworkGroupProperties_c6b41db0], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "NetworkGroupBody(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.NetworkGroupProperties",
    jsii_struct_bases=[],
    name_mapping={"description": "description", "member_type": "memberType"},
)
class NetworkGroupProperties:
    def __init__(
        self,
        *,
        description: typing.Optional[builtins.str] = None,
        member_type: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for Network Group body.

        :param description: 
        :param member_type: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c7efd4afff5c4edef2897dd94ecda1d64f847e9ba6a2c6412fa9d6376a76e6f1)
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument member_type", value=member_type, expected_type=type_hints["member_type"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if description is not None:
            self._values["description"] = description
        if member_type is not None:
            self._values["member_type"] = member_type

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def member_type(self) -> typing.Optional[builtins.str]:
        result = self._values.get("member_type")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "NetworkGroupProperties(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.NetworkGroupProps",
    jsii_struct_bases=[_AzapiResourceProps_141a2340],
    name_mapping={
        "connection": "connection",
        "count": "count",
        "depends_on": "dependsOn",
        "for_each": "forEach",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "provisioners": "provisioners",
        "api_version": "apiVersion",
        "enable_migration_analysis": "enableMigrationAnalysis",
        "enable_transformation": "enableTransformation",
        "enable_validation": "enableValidation",
        "location": "location",
        "monitoring": "monitoring",
        "name": "name",
        "tags": "tags",
        "network_manager_id": "networkManagerId",
        "description": "description",
        "ignore_changes": "ignoreChanges",
        "member_type": "memberType",
    },
)
class NetworkGroupProps(_AzapiResourceProps_141a2340):
    def __init__(
        self,
        *,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
        api_version: typing.Optional[builtins.str] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        location: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        network_manager_id: builtins.str,
        description: typing.Optional[builtins.str] = None,
        ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
        member_type: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for the Azure Virtual Network Manager Network Group.

        Extends AzapiResourceProps with Network Group specific properties

        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        :param api_version: Explicit API version to use for this resource. If not specified, the latest active version will be automatically resolved. Use this for version pinning when stability is required over latest features. Default: Latest active version from ApiVersionManager
        :param enable_migration_analysis: Whether to enable migration analysis warnings. When true, the framework will analyze the current version for deprecation status and provide migration recommendations in the deployment output. Default: true
        :param enable_transformation: Whether to apply property transformations automatically. When true, properties will be automatically transformed according to the target schema's transformation rules. This enables backward compatibility. Default: true
        :param enable_validation: Whether to validate properties against the schema. When true, all properties will be validated against the API schema before resource creation. Validation errors will cause deployment failures. Default: true
        :param location: The location where the resource should be created. Default: Varies by resource type - see specific resource documentation
        :param monitoring: Monitoring configuration for this resource. Enables integrated monitoring with diagnostic settings, metric alerts, and activity log alerts. All monitoring is optional and disabled by default.
        :param name: The name of the resource.
        :param tags: Tags to apply to the resource.
        :param network_manager_id: Resource ID of the parent Network Manager.
        :param description: Optional description of the network group.
        :param ignore_changes: The lifecycle rules to ignore changes.
        :param member_type: Type of members in this network group. Default: undefined (can contain both VirtualNetwork and Subnet members)
        '''
        if isinstance(lifecycle, dict):
            lifecycle = _cdktf_9a9027ec.TerraformResourceLifecycle(**lifecycle)
        if isinstance(monitoring, dict):
            monitoring = _MonitoringConfig_7c28df74(**monitoring)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__526d250ad02b55550baba64a45601b0c5e709cb0e11deaae763ede5a94e31830)
            check_type(argname="argument connection", value=connection, expected_type=type_hints["connection"])
            check_type(argname="argument count", value=count, expected_type=type_hints["count"])
            check_type(argname="argument depends_on", value=depends_on, expected_type=type_hints["depends_on"])
            check_type(argname="argument for_each", value=for_each, expected_type=type_hints["for_each"])
            check_type(argname="argument lifecycle", value=lifecycle, expected_type=type_hints["lifecycle"])
            check_type(argname="argument provider", value=provider, expected_type=type_hints["provider"])
            check_type(argname="argument provisioners", value=provisioners, expected_type=type_hints["provisioners"])
            check_type(argname="argument api_version", value=api_version, expected_type=type_hints["api_version"])
            check_type(argname="argument enable_migration_analysis", value=enable_migration_analysis, expected_type=type_hints["enable_migration_analysis"])
            check_type(argname="argument enable_transformation", value=enable_transformation, expected_type=type_hints["enable_transformation"])
            check_type(argname="argument enable_validation", value=enable_validation, expected_type=type_hints["enable_validation"])
            check_type(argname="argument location", value=location, expected_type=type_hints["location"])
            check_type(argname="argument monitoring", value=monitoring, expected_type=type_hints["monitoring"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument network_manager_id", value=network_manager_id, expected_type=type_hints["network_manager_id"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument ignore_changes", value=ignore_changes, expected_type=type_hints["ignore_changes"])
            check_type(argname="argument member_type", value=member_type, expected_type=type_hints["member_type"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "network_manager_id": network_manager_id,
        }
        if connection is not None:
            self._values["connection"] = connection
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if for_each is not None:
            self._values["for_each"] = for_each
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider
        if provisioners is not None:
            self._values["provisioners"] = provisioners
        if api_version is not None:
            self._values["api_version"] = api_version
        if enable_migration_analysis is not None:
            self._values["enable_migration_analysis"] = enable_migration_analysis
        if enable_transformation is not None:
            self._values["enable_transformation"] = enable_transformation
        if enable_validation is not None:
            self._values["enable_validation"] = enable_validation
        if location is not None:
            self._values["location"] = location
        if monitoring is not None:
            self._values["monitoring"] = monitoring
        if name is not None:
            self._values["name"] = name
        if tags is not None:
            self._values["tags"] = tags
        if description is not None:
            self._values["description"] = description
        if ignore_changes is not None:
            self._values["ignore_changes"] = ignore_changes
        if member_type is not None:
            self._values["member_type"] = member_type

    @builtins.property
    def connection(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("connection")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]], result)

    @builtins.property
    def count(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]], result)

    @builtins.property
    def depends_on(
        self,
    ) -> typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]], result)

    @builtins.property
    def for_each(self) -> typing.Optional[_cdktf_9a9027ec.ITerraformIterator]:
        '''
        :stability: experimental
        '''
        result = self._values.get("for_each")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.ITerraformIterator], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[_cdktf_9a9027ec.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformProvider], result)

    @builtins.property
    def provisioners(
        self,
    ) -> typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provisioners")
        return typing.cast(typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]], result)

    @builtins.property
    def api_version(self) -> typing.Optional[builtins.str]:
        '''Explicit API version to use for this resource.

        If not specified, the latest active version will be automatically resolved.
        Use this for version pinning when stability is required over latest features.

        :default: Latest active version from ApiVersionManager

        Example::

            "2024-11-01"
        '''
        result = self._values.get("api_version")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def enable_migration_analysis(self) -> typing.Optional[builtins.bool]:
        '''Whether to enable migration analysis warnings.

        When true, the framework will analyze the current version for deprecation
        status and provide migration recommendations in the deployment output.

        :default: true
        '''
        result = self._values.get("enable_migration_analysis")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_transformation(self) -> typing.Optional[builtins.bool]:
        '''Whether to apply property transformations automatically.

        When true, properties will be automatically transformed according to the
        target schema's transformation rules. This enables backward compatibility.

        :default: true
        '''
        result = self._values.get("enable_transformation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_validation(self) -> typing.Optional[builtins.bool]:
        '''Whether to validate properties against the schema.

        When true, all properties will be validated against the API schema before
        resource creation. Validation errors will cause deployment failures.

        :default: true
        '''
        result = self._values.get("enable_validation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def location(self) -> typing.Optional[builtins.str]:
        '''The location where the resource should be created.

        :default: Varies by resource type - see specific resource documentation

        :remarks:

        Location handling varies by resource type:

        - **Top-level resources**: Most require an explicit location (e.g., "eastus", "westus")
        - **Global resources**: Some use "global" as location (e.g., Private DNS Zones)
        - **Child resources**: Inherit location from parent and should NOT set this property

        Each resource type may provide its own default through the ``resolveLocation()`` method.
        If no location is specified and no default exists, resource creation may fail.

        Example::

            // Child resource (Subnet) - do not set location
            // location: undefined (inherited from parent Virtual Network)
        '''
        result = self._values.get("location")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def monitoring(self) -> typing.Optional[_MonitoringConfig_7c28df74]:
        '''Monitoring configuration for this resource.

        Enables integrated monitoring with diagnostic settings, metric alerts,
        and activity log alerts. All monitoring is optional and disabled by default.

        Example::

            monitoring: {
              enabled: true,
              diagnosticSettings: {
                workspaceId: logAnalytics.id,
                metrics: ['AllMetrics'],
                logs: ['AuditLogs']
              },
              metricAlerts: [{
                name: 'high-cpu-alert',
                severity: 2,
                scopes: [], // Automatically set to this resource
                criteria: { ... },
                actions: [{ actionGroupId: actionGroup.id }]
              }]
            }
        '''
        result = self._values.get("monitoring")
        return typing.cast(typing.Optional[_MonitoringConfig_7c28df74], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the resource.'''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Tags to apply to the resource.'''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def network_manager_id(self) -> builtins.str:
        '''Resource ID of the parent Network Manager.

        Example::

            "/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/rg/providers/Microsoft.Network/networkManagers/vnm"
        '''
        result = self._values.get("network_manager_id")
        assert result is not None, "Required property 'network_manager_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''Optional description of the network group.

        Example::

            "Production virtual networks for region East US"
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ignore_changes(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The lifecycle rules to ignore changes.

        Example::

            ["tags"]
        '''
        result = self._values.get("ignore_changes")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def member_type(self) -> typing.Optional[builtins.str]:
        '''Type of members in this network group.

        :default: undefined (can contain both VirtualNetwork and Subnet members)

        Example::

            "Subnet"
        '''
        result = self._values.get("member_type")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "NetworkGroupProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class NetworkGroupStaticMember(
    _AzapiResource_7e7f5b39,
    metaclass=jsii.JSIIMeta,
    jsii_type="@microsoft/terraform-cdk-constructs.NetworkGroupStaticMember",
):
    '''Azure Virtual Network Manager Network Group Static Member implementation.

    Static members explicitly add virtual networks or subnets to a network group,
    providing precise control over which resources receive configurations applied
    to the network group. This is in contrast to dynamic membership via Azure Policy.

    Example::

        // Add a subnet to a network group:
        const subnetMember = new NetworkGroupStaticMember(this, "subnet-member", {
          name: "prod-subnet1-member",
          networkGroupId: productionGroup.id,
          resourceId: subnet.id,
          apiVersion: "2024-05-01"
        });
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        network_group_id: builtins.str,
        resource_id: builtins.str,
        ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
        api_version: typing.Optional[builtins.str] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        location: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> None:
        '''Creates a new Azure Virtual Network Manager Network Group Static Member using the AzapiResource framework.

        :param scope: - The scope in which to define this construct.
        :param id: - The unique identifier for this instance.
        :param network_group_id: Resource ID of the parent Network Group.
        :param resource_id: Full resource ID of the VNet or Subnet to add to the group.
        :param ignore_changes: The lifecycle rules to ignore changes.
        :param api_version: Explicit API version to use for this resource. If not specified, the latest active version will be automatically resolved. Use this for version pinning when stability is required over latest features. Default: Latest active version from ApiVersionManager
        :param enable_migration_analysis: Whether to enable migration analysis warnings. When true, the framework will analyze the current version for deprecation status and provide migration recommendations in the deployment output. Default: true
        :param enable_transformation: Whether to apply property transformations automatically. When true, properties will be automatically transformed according to the target schema's transformation rules. This enables backward compatibility. Default: true
        :param enable_validation: Whether to validate properties against the schema. When true, all properties will be validated against the API schema before resource creation. Validation errors will cause deployment failures. Default: true
        :param location: The location where the resource should be created. Default: Varies by resource type - see specific resource documentation
        :param monitoring: Monitoring configuration for this resource. Enables integrated monitoring with diagnostic settings, metric alerts, and activity log alerts. All monitoring is optional and disabled by default.
        :param name: The name of the resource.
        :param tags: Tags to apply to the resource.
        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b62375c8cde6d82adab9c55922a655da1cd477202491b11ebf65026966be4843)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = _NetworkGroupStaticMemberProps_fdd03072(
            network_group_id=network_group_id,
            resource_id=resource_id,
            ignore_changes=ignore_changes,
            api_version=api_version,
            enable_migration_analysis=enable_migration_analysis,
            enable_transformation=enable_transformation,
            enable_validation=enable_validation,
            location=location,
            monitoring=monitoring,
            name=name,
            tags=tags,
            connection=connection,
            count=count,
            depends_on=depends_on,
            for_each=for_each,
            lifecycle=lifecycle,
            provider=provider,
            provisioners=provisioners,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="apiSchema")
    def _api_schema(self) -> _ApiSchema_5ce0490e:
        '''Gets the API schema for the resolved version.'''
        return typing.cast(_ApiSchema_5ce0490e, jsii.invoke(self, "apiSchema", []))

    @jsii.member(jsii_name="createResourceBody")
    def _create_resource_body(self, props: typing.Any) -> typing.Any:
        '''Creates the resource body for the Azure API call.

        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ef4de65205598d10b4e9d7f16ce03a6cce62a22b5c2ce24d3bafbe53c0d2f82f)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Any, jsii.invoke(self, "createResourceBody", [props]))

    @jsii.member(jsii_name="defaultVersion")
    def _default_version(self) -> builtins.str:
        '''Gets the default API version to use when no explicit version is specified.'''
        return typing.cast(builtins.str, jsii.invoke(self, "defaultVersion", []))

    @jsii.member(jsii_name="resolveParentId")
    def _resolve_parent_id(self, props: typing.Any) -> builtins.str:
        '''Resolves the parent resource ID for the Static Member Static Members are scoped to Network Groups.

        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cb73bbb60834a00bae2b89bc371d37e30afb4e2aa640588d04b11ba5d8afb5ea)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(builtins.str, jsii.invoke(self, "resolveParentId", [props]))

    @jsii.member(jsii_name="resourceType")
    def _resource_type(self) -> builtins.str:
        '''Gets the Azure resource type for Static Members.'''
        return typing.cast(builtins.str, jsii.invoke(self, "resourceType", []))

    @builtins.property
    @jsii.member(jsii_name="idOutput")
    def id_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "idOutput"))

    @builtins.property
    @jsii.member(jsii_name="memberResourceId")
    def member_resource_id(self) -> builtins.str:
        '''Get the resource ID of the member VNet or Subnet Returns the input resourceId since Azure API doesn't return it in the response.'''
        return typing.cast(builtins.str, jsii.get(self, "memberResourceId"))

    @builtins.property
    @jsii.member(jsii_name="nameOutput")
    def name_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "nameOutput"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def props(self) -> _NetworkGroupStaticMemberProps_fdd03072:
        '''The input properties for this Static Member instance.'''
        return typing.cast(_NetworkGroupStaticMemberProps_fdd03072, jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="region")
    def region(self) -> builtins.str:
        '''Get the region of the member resource.'''
        return typing.cast(builtins.str, jsii.get(self, "region"))

    @builtins.property
    @jsii.member(jsii_name="resourceIdOutput")
    def resource_id_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "resourceIdOutput"))

    @builtins.property
    @jsii.member(jsii_name="resourceName")
    def resource_name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "resourceName"))


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.NetworkGroupStaticMemberBody",
    jsii_struct_bases=[],
    name_mapping={"properties": "properties"},
)
class NetworkGroupStaticMemberBody:
    def __init__(
        self,
        *,
        properties: typing.Union[_NetworkGroupStaticMemberProperties_808adefa, typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''The resource body interface for Azure Static Member API calls.

        :param properties: 
        '''
        if isinstance(properties, dict):
            properties = _NetworkGroupStaticMemberProperties_808adefa(**properties)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__55042b6ef1f36b0e230f73b0c8c8ec01e6dc9d770c59618366378a2f69de25eb)
            check_type(argname="argument properties", value=properties, expected_type=type_hints["properties"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "properties": properties,
        }

    @builtins.property
    def properties(self) -> _NetworkGroupStaticMemberProperties_808adefa:
        result = self._values.get("properties")
        assert result is not None, "Required property 'properties' is missing"
        return typing.cast(_NetworkGroupStaticMemberProperties_808adefa, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "NetworkGroupStaticMemberBody(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.NetworkGroupStaticMemberProperties",
    jsii_struct_bases=[],
    name_mapping={"resource_id": "resourceId"},
)
class NetworkGroupStaticMemberProperties:
    def __init__(self, *, resource_id: builtins.str) -> None:
        '''Properties for Static Member body.

        :param resource_id: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b21a9d08d280f30c44ff695d7955532e4a8d013bc0039bc140c93c973a2049f4)
            check_type(argname="argument resource_id", value=resource_id, expected_type=type_hints["resource_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "resource_id": resource_id,
        }

    @builtins.property
    def resource_id(self) -> builtins.str:
        result = self._values.get("resource_id")
        assert result is not None, "Required property 'resource_id' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "NetworkGroupStaticMemberProperties(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.NetworkGroupStaticMemberProps",
    jsii_struct_bases=[_AzapiResourceProps_141a2340],
    name_mapping={
        "connection": "connection",
        "count": "count",
        "depends_on": "dependsOn",
        "for_each": "forEach",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "provisioners": "provisioners",
        "api_version": "apiVersion",
        "enable_migration_analysis": "enableMigrationAnalysis",
        "enable_transformation": "enableTransformation",
        "enable_validation": "enableValidation",
        "location": "location",
        "monitoring": "monitoring",
        "name": "name",
        "tags": "tags",
        "network_group_id": "networkGroupId",
        "resource_id": "resourceId",
        "ignore_changes": "ignoreChanges",
    },
)
class NetworkGroupStaticMemberProps(_AzapiResourceProps_141a2340):
    def __init__(
        self,
        *,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
        api_version: typing.Optional[builtins.str] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        location: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        network_group_id: builtins.str,
        resource_id: builtins.str,
        ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''Properties for the Azure Virtual Network Manager Network Group Static Member.

        Extends AzapiResourceProps with Static Member specific properties

        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        :param api_version: Explicit API version to use for this resource. If not specified, the latest active version will be automatically resolved. Use this for version pinning when stability is required over latest features. Default: Latest active version from ApiVersionManager
        :param enable_migration_analysis: Whether to enable migration analysis warnings. When true, the framework will analyze the current version for deprecation status and provide migration recommendations in the deployment output. Default: true
        :param enable_transformation: Whether to apply property transformations automatically. When true, properties will be automatically transformed according to the target schema's transformation rules. This enables backward compatibility. Default: true
        :param enable_validation: Whether to validate properties against the schema. When true, all properties will be validated against the API schema before resource creation. Validation errors will cause deployment failures. Default: true
        :param location: The location where the resource should be created. Default: Varies by resource type - see specific resource documentation
        :param monitoring: Monitoring configuration for this resource. Enables integrated monitoring with diagnostic settings, metric alerts, and activity log alerts. All monitoring is optional and disabled by default.
        :param name: The name of the resource.
        :param tags: Tags to apply to the resource.
        :param network_group_id: Resource ID of the parent Network Group.
        :param resource_id: Full resource ID of the VNet or Subnet to add to the group.
        :param ignore_changes: The lifecycle rules to ignore changes.
        '''
        if isinstance(lifecycle, dict):
            lifecycle = _cdktf_9a9027ec.TerraformResourceLifecycle(**lifecycle)
        if isinstance(monitoring, dict):
            monitoring = _MonitoringConfig_7c28df74(**monitoring)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a373fac0ede7102051c7c429906e301dba46f20a8fecbd216227e34f0e5f0d62)
            check_type(argname="argument connection", value=connection, expected_type=type_hints["connection"])
            check_type(argname="argument count", value=count, expected_type=type_hints["count"])
            check_type(argname="argument depends_on", value=depends_on, expected_type=type_hints["depends_on"])
            check_type(argname="argument for_each", value=for_each, expected_type=type_hints["for_each"])
            check_type(argname="argument lifecycle", value=lifecycle, expected_type=type_hints["lifecycle"])
            check_type(argname="argument provider", value=provider, expected_type=type_hints["provider"])
            check_type(argname="argument provisioners", value=provisioners, expected_type=type_hints["provisioners"])
            check_type(argname="argument api_version", value=api_version, expected_type=type_hints["api_version"])
            check_type(argname="argument enable_migration_analysis", value=enable_migration_analysis, expected_type=type_hints["enable_migration_analysis"])
            check_type(argname="argument enable_transformation", value=enable_transformation, expected_type=type_hints["enable_transformation"])
            check_type(argname="argument enable_validation", value=enable_validation, expected_type=type_hints["enable_validation"])
            check_type(argname="argument location", value=location, expected_type=type_hints["location"])
            check_type(argname="argument monitoring", value=monitoring, expected_type=type_hints["monitoring"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument network_group_id", value=network_group_id, expected_type=type_hints["network_group_id"])
            check_type(argname="argument resource_id", value=resource_id, expected_type=type_hints["resource_id"])
            check_type(argname="argument ignore_changes", value=ignore_changes, expected_type=type_hints["ignore_changes"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "network_group_id": network_group_id,
            "resource_id": resource_id,
        }
        if connection is not None:
            self._values["connection"] = connection
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if for_each is not None:
            self._values["for_each"] = for_each
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider
        if provisioners is not None:
            self._values["provisioners"] = provisioners
        if api_version is not None:
            self._values["api_version"] = api_version
        if enable_migration_analysis is not None:
            self._values["enable_migration_analysis"] = enable_migration_analysis
        if enable_transformation is not None:
            self._values["enable_transformation"] = enable_transformation
        if enable_validation is not None:
            self._values["enable_validation"] = enable_validation
        if location is not None:
            self._values["location"] = location
        if monitoring is not None:
            self._values["monitoring"] = monitoring
        if name is not None:
            self._values["name"] = name
        if tags is not None:
            self._values["tags"] = tags
        if ignore_changes is not None:
            self._values["ignore_changes"] = ignore_changes

    @builtins.property
    def connection(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("connection")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]], result)

    @builtins.property
    def count(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]], result)

    @builtins.property
    def depends_on(
        self,
    ) -> typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]], result)

    @builtins.property
    def for_each(self) -> typing.Optional[_cdktf_9a9027ec.ITerraformIterator]:
        '''
        :stability: experimental
        '''
        result = self._values.get("for_each")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.ITerraformIterator], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[_cdktf_9a9027ec.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformProvider], result)

    @builtins.property
    def provisioners(
        self,
    ) -> typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provisioners")
        return typing.cast(typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]], result)

    @builtins.property
    def api_version(self) -> typing.Optional[builtins.str]:
        '''Explicit API version to use for this resource.

        If not specified, the latest active version will be automatically resolved.
        Use this for version pinning when stability is required over latest features.

        :default: Latest active version from ApiVersionManager

        Example::

            "2024-11-01"
        '''
        result = self._values.get("api_version")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def enable_migration_analysis(self) -> typing.Optional[builtins.bool]:
        '''Whether to enable migration analysis warnings.

        When true, the framework will analyze the current version for deprecation
        status and provide migration recommendations in the deployment output.

        :default: true
        '''
        result = self._values.get("enable_migration_analysis")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_transformation(self) -> typing.Optional[builtins.bool]:
        '''Whether to apply property transformations automatically.

        When true, properties will be automatically transformed according to the
        target schema's transformation rules. This enables backward compatibility.

        :default: true
        '''
        result = self._values.get("enable_transformation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_validation(self) -> typing.Optional[builtins.bool]:
        '''Whether to validate properties against the schema.

        When true, all properties will be validated against the API schema before
        resource creation. Validation errors will cause deployment failures.

        :default: true
        '''
        result = self._values.get("enable_validation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def location(self) -> typing.Optional[builtins.str]:
        '''The location where the resource should be created.

        :default: Varies by resource type - see specific resource documentation

        :remarks:

        Location handling varies by resource type:

        - **Top-level resources**: Most require an explicit location (e.g., "eastus", "westus")
        - **Global resources**: Some use "global" as location (e.g., Private DNS Zones)
        - **Child resources**: Inherit location from parent and should NOT set this property

        Each resource type may provide its own default through the ``resolveLocation()`` method.
        If no location is specified and no default exists, resource creation may fail.

        Example::

            // Child resource (Subnet) - do not set location
            // location: undefined (inherited from parent Virtual Network)
        '''
        result = self._values.get("location")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def monitoring(self) -> typing.Optional[_MonitoringConfig_7c28df74]:
        '''Monitoring configuration for this resource.

        Enables integrated monitoring with diagnostic settings, metric alerts,
        and activity log alerts. All monitoring is optional and disabled by default.

        Example::

            monitoring: {
              enabled: true,
              diagnosticSettings: {
                workspaceId: logAnalytics.id,
                metrics: ['AllMetrics'],
                logs: ['AuditLogs']
              },
              metricAlerts: [{
                name: 'high-cpu-alert',
                severity: 2,
                scopes: [], // Automatically set to this resource
                criteria: { ... },
                actions: [{ actionGroupId: actionGroup.id }]
              }]
            }
        '''
        result = self._values.get("monitoring")
        return typing.cast(typing.Optional[_MonitoringConfig_7c28df74], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the resource.'''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Tags to apply to the resource.'''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def network_group_id(self) -> builtins.str:
        '''Resource ID of the parent Network Group.

        Example::

            "/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/rg/providers/Microsoft.Network/networkManagers/vnm/networkGroups/prod-group"
        '''
        result = self._values.get("network_group_id")
        assert result is not None, "Required property 'network_group_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def resource_id(self) -> builtins.str:
        '''Full resource ID of the VNet or Subnet to add to the group.

        Example::

            "/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/rg/providers/Microsoft.Network/virtualNetworks/vnet1/subnets/subnet1"
        '''
        result = self._values.get("resource_id")
        assert result is not None, "Required property 'resource_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def ignore_changes(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The lifecycle rules to ignore changes.

        Example::

            ["tags"]
        '''
        result = self._values.get("ignore_changes")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "NetworkGroupStaticMemberProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class NetworkInterface(
    _AzapiResource_7e7f5b39,
    metaclass=jsii.JSIIMeta,
    jsii_type="@microsoft/terraform-cdk-constructs.NetworkInterface",
):
    '''Unified Azure Network Interface implementation.

    This class provides a single, version-aware implementation that replaces all
    version-specific Network Interface classes. It automatically handles version
    resolution, schema validation, and property transformation while maintaining
    full backward compatibility.

    Example::

        // Usage with explicit version pinning:
        const nic = new NetworkInterface(this, "nic", {
          name: "mynic",
          location: "eastus",
          resourceGroupId: resourceGroup.id,
          ipConfigurations: [{
            name: "ipconfig1",
            subnet: { id: subnet.id },
            privateIPAllocationMethod: "Dynamic",
            primary: true
          }],
          apiVersion: "2024-07-01",
        });
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        ip_configurations: typing.Sequence[typing.Union[_NetworkInterfaceIPConfiguration_c63cf7d5, typing.Dict[builtins.str, typing.Any]]],
        dns_settings: typing.Optional[typing.Union[_NetworkInterfaceDnsSettings_c9406208, typing.Dict[builtins.str, typing.Any]]] = None,
        enable_accelerated_networking: typing.Optional[builtins.bool] = None,
        enable_ip_forwarding: typing.Optional[builtins.bool] = None,
        ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
        network_security_group: typing.Optional[typing.Union[_NetworkInterfaceNSGReference_c2c81f03, typing.Dict[builtins.str, typing.Any]]] = None,
        resource_group_id: typing.Optional[builtins.str] = None,
        api_version: typing.Optional[builtins.str] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        location: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> None:
        '''Creates a new Azure Network Interface using the VersionedAzapiResource framework.

        :param scope: - The scope in which to define this construct.
        :param id: - The unique identifier for this instance.
        :param ip_configurations: IP configurations for the network interface At least one IP configuration is required One IP configuration must be marked as primary.
        :param dns_settings: DNS settings configuration Optional - configures DNS servers for the NIC.
        :param enable_accelerated_networking: Enable accelerated networking for high-performance scenarios Requires supported VM size. Default: false
        :param enable_ip_forwarding: Enable IP forwarding for network virtual appliances Allows NIC to forward traffic not destined for its IP. Default: false
        :param ignore_changes: The lifecycle rules to ignore changes.
        :param network_security_group: Network Security Group reference with id property Optional - associates an NSG with this NIC.
        :param resource_group_id: Resource group ID where the network interface will be created.
        :param api_version: Explicit API version to use for this resource. If not specified, the latest active version will be automatically resolved. Use this for version pinning when stability is required over latest features. Default: Latest active version from ApiVersionManager
        :param enable_migration_analysis: Whether to enable migration analysis warnings. When true, the framework will analyze the current version for deprecation status and provide migration recommendations in the deployment output. Default: true
        :param enable_transformation: Whether to apply property transformations automatically. When true, properties will be automatically transformed according to the target schema's transformation rules. This enables backward compatibility. Default: true
        :param enable_validation: Whether to validate properties against the schema. When true, all properties will be validated against the API schema before resource creation. Validation errors will cause deployment failures. Default: true
        :param location: The location where the resource should be created. Default: Varies by resource type - see specific resource documentation
        :param monitoring: Monitoring configuration for this resource. Enables integrated monitoring with diagnostic settings, metric alerts, and activity log alerts. All monitoring is optional and disabled by default.
        :param name: The name of the resource.
        :param tags: Tags to apply to the resource.
        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__09f24e8a4ed5b6010c73fb48fcc49e41185a1ecb27ed676869d691bcfcec13ad)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = _NetworkInterfaceProps_e944bdac(
            ip_configurations=ip_configurations,
            dns_settings=dns_settings,
            enable_accelerated_networking=enable_accelerated_networking,
            enable_ip_forwarding=enable_ip_forwarding,
            ignore_changes=ignore_changes,
            network_security_group=network_security_group,
            resource_group_id=resource_group_id,
            api_version=api_version,
            enable_migration_analysis=enable_migration_analysis,
            enable_transformation=enable_transformation,
            enable_validation=enable_validation,
            location=location,
            monitoring=monitoring,
            name=name,
            tags=tags,
            connection=connection,
            count=count,
            depends_on=depends_on,
            for_each=for_each,
            lifecycle=lifecycle,
            provider=provider,
            provisioners=provisioners,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="addTag")
    def add_tag(self, key: builtins.str, value: builtins.str) -> None:
        '''Add a tag to the Network Interface.

        :param key: -
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b26b2d91d3520b70301b4b4baab675412e5fe7285b5b811f2ce822198e421f5e)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "addTag", [key, value]))

    @jsii.member(jsii_name="apiSchema")
    def _api_schema(self) -> _ApiSchema_5ce0490e:
        '''Gets the API schema for the resolved version.'''
        return typing.cast(_ApiSchema_5ce0490e, jsii.invoke(self, "apiSchema", []))

    @jsii.member(jsii_name="createResourceBody")
    def _create_resource_body(self, props: typing.Any) -> typing.Any:
        '''Creates the resource body for the Azure API call.

        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2c38515d7524ce5755d99ed7c591365c4bedb90d935aa2502122914ad4782a0a)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Any, jsii.invoke(self, "createResourceBody", [props]))

    @jsii.member(jsii_name="defaultVersion")
    def _default_version(self) -> builtins.str:
        '''Gets the default API version to use when no explicit version is specified.'''
        return typing.cast(builtins.str, jsii.invoke(self, "defaultVersion", []))

    @jsii.member(jsii_name="removeTag")
    def remove_tag(self, key: builtins.str) -> None:
        '''Remove a tag from the Network Interface.

        :param key: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b1fcf4f51860b105e4a2f71012d9425b32dd7cbd92bb500cdffc147a6af53679)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
        return typing.cast(None, jsii.invoke(self, "removeTag", [key]))

    @jsii.member(jsii_name="requiresLocation")
    def _requires_location(self) -> builtins.bool:
        '''Indicates that location is required for Network Interfaces.'''
        return typing.cast(builtins.bool, jsii.invoke(self, "requiresLocation", []))

    @jsii.member(jsii_name="resourceType")
    def _resource_type(self) -> builtins.str:
        '''Gets the Azure resource type for Network Interfaces.'''
        return typing.cast(builtins.str, jsii.invoke(self, "resourceType", []))

    @builtins.property
    @jsii.member(jsii_name="idOutput")
    def id_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "idOutput"))

    @builtins.property
    @jsii.member(jsii_name="locationOutput")
    def location_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "locationOutput"))

    @builtins.property
    @jsii.member(jsii_name="nameOutput")
    def name_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "nameOutput"))

    @builtins.property
    @jsii.member(jsii_name="privateIPAddress")
    def private_ip_address(self) -> builtins.str:
        '''Get the private IP address of the primary IP configuration Note: This may not be available until after the resource is created The actual IP address location in Azure API response varies by API version.'''
        return typing.cast(builtins.str, jsii.get(self, "privateIPAddress"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def props(self) -> _NetworkInterfaceProps_e944bdac:
        return typing.cast(_NetworkInterfaceProps_e944bdac, jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="tagsOutput")
    def tags_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "tagsOutput"))


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.NetworkInterfaceBody",
    jsii_struct_bases=[],
    name_mapping={"location": "location", "properties": "properties", "tags": "tags"},
)
class NetworkInterfaceBody:
    def __init__(
        self,
        *,
        location: builtins.str,
        properties: typing.Union[_NetworkInterfaceBodyProperties_1ebf3a2a, typing.Dict[builtins.str, typing.Any]],
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''The resource body interface for Azure Network Interface API calls.

        :param location: 
        :param properties: 
        :param tags: 
        '''
        if isinstance(properties, dict):
            properties = _NetworkInterfaceBodyProperties_1ebf3a2a(**properties)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8bb617678ee71da5d07f9204eaf936fb282c8ab86c93718c47b0ff1628ef32f7)
            check_type(argname="argument location", value=location, expected_type=type_hints["location"])
            check_type(argname="argument properties", value=properties, expected_type=type_hints["properties"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "location": location,
            "properties": properties,
        }
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def location(self) -> builtins.str:
        result = self._values.get("location")
        assert result is not None, "Required property 'location' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def properties(self) -> _NetworkInterfaceBodyProperties_1ebf3a2a:
        result = self._values.get("properties")
        assert result is not None, "Required property 'properties' is missing"
        return typing.cast(_NetworkInterfaceBodyProperties_1ebf3a2a, result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "NetworkInterfaceBody(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.NetworkInterfaceBodyProperties",
    jsii_struct_bases=[],
    name_mapping={
        "ip_configurations": "ipConfigurations",
        "dns_settings": "dnsSettings",
        "enable_accelerated_networking": "enableAcceleratedNetworking",
        "enable_ip_forwarding": "enableIPForwarding",
        "network_security_group": "networkSecurityGroup",
    },
)
class NetworkInterfaceBodyProperties:
    def __init__(
        self,
        *,
        ip_configurations: typing.Sequence[typing.Union[_NetworkInterfaceIPConfiguration_c63cf7d5, typing.Dict[builtins.str, typing.Any]]],
        dns_settings: typing.Optional[typing.Union[_NetworkInterfaceDnsSettings_c9406208, typing.Dict[builtins.str, typing.Any]]] = None,
        enable_accelerated_networking: typing.Optional[builtins.bool] = None,
        enable_ip_forwarding: typing.Optional[builtins.bool] = None,
        network_security_group: typing.Optional[typing.Union[_NetworkInterfaceNSGReference_c2c81f03, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Network Interface properties for the request body.

        :param ip_configurations: 
        :param dns_settings: 
        :param enable_accelerated_networking: 
        :param enable_ip_forwarding: 
        :param network_security_group: 
        '''
        if isinstance(dns_settings, dict):
            dns_settings = _NetworkInterfaceDnsSettings_c9406208(**dns_settings)
        if isinstance(network_security_group, dict):
            network_security_group = _NetworkInterfaceNSGReference_c2c81f03(**network_security_group)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__610ddd82dbb41ce589c52ab6f951a37d2af801871eb269d5f42a1ff6d4ab3402)
            check_type(argname="argument ip_configurations", value=ip_configurations, expected_type=type_hints["ip_configurations"])
            check_type(argname="argument dns_settings", value=dns_settings, expected_type=type_hints["dns_settings"])
            check_type(argname="argument enable_accelerated_networking", value=enable_accelerated_networking, expected_type=type_hints["enable_accelerated_networking"])
            check_type(argname="argument enable_ip_forwarding", value=enable_ip_forwarding, expected_type=type_hints["enable_ip_forwarding"])
            check_type(argname="argument network_security_group", value=network_security_group, expected_type=type_hints["network_security_group"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "ip_configurations": ip_configurations,
        }
        if dns_settings is not None:
            self._values["dns_settings"] = dns_settings
        if enable_accelerated_networking is not None:
            self._values["enable_accelerated_networking"] = enable_accelerated_networking
        if enable_ip_forwarding is not None:
            self._values["enable_ip_forwarding"] = enable_ip_forwarding
        if network_security_group is not None:
            self._values["network_security_group"] = network_security_group

    @builtins.property
    def ip_configurations(
        self,
    ) -> typing.List[_NetworkInterfaceIPConfiguration_c63cf7d5]:
        result = self._values.get("ip_configurations")
        assert result is not None, "Required property 'ip_configurations' is missing"
        return typing.cast(typing.List[_NetworkInterfaceIPConfiguration_c63cf7d5], result)

    @builtins.property
    def dns_settings(self) -> typing.Optional[_NetworkInterfaceDnsSettings_c9406208]:
        result = self._values.get("dns_settings")
        return typing.cast(typing.Optional[_NetworkInterfaceDnsSettings_c9406208], result)

    @builtins.property
    def enable_accelerated_networking(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("enable_accelerated_networking")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_ip_forwarding(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("enable_ip_forwarding")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def network_security_group(
        self,
    ) -> typing.Optional[_NetworkInterfaceNSGReference_c2c81f03]:
        result = self._values.get("network_security_group")
        return typing.cast(typing.Optional[_NetworkInterfaceNSGReference_c2c81f03], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "NetworkInterfaceBodyProperties(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.NetworkInterfaceConfiguration",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "properties": "properties"},
)
class NetworkInterfaceConfiguration:
    def __init__(
        self,
        *,
        name: builtins.str,
        properties: typing.Optional[typing.Union[_NetworkInterfaceConfigurationProperties_5b8d6a5d, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Network interface configuration for VMSS.

        :param name: 
        :param properties: 
        '''
        if isinstance(properties, dict):
            properties = _NetworkInterfaceConfigurationProperties_5b8d6a5d(**properties)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6c36ad636e3e52b9c7243e3a3554c193aa4652f3b91b6b817bfc31a67c2e2e99)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument properties", value=properties, expected_type=type_hints["properties"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if properties is not None:
            self._values["properties"] = properties

    @builtins.property
    def name(self) -> builtins.str:
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def properties(
        self,
    ) -> typing.Optional[_NetworkInterfaceConfigurationProperties_5b8d6a5d]:
        result = self._values.get("properties")
        return typing.cast(typing.Optional[_NetworkInterfaceConfigurationProperties_5b8d6a5d], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "NetworkInterfaceConfiguration(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.NetworkInterfaceConfigurationProperties",
    jsii_struct_bases=[],
    name_mapping={
        "ip_configurations": "ipConfigurations",
        "dns_settings": "dnsSettings",
        "enable_accelerated_networking": "enableAcceleratedNetworking",
        "enable_ip_forwarding": "enableIPForwarding",
        "network_security_group": "networkSecurityGroup",
        "primary": "primary",
    },
)
class NetworkInterfaceConfigurationProperties:
    def __init__(
        self,
        *,
        ip_configurations: typing.Sequence[_IPConfiguration_3c957377],
        dns_settings: typing.Optional[typing.Union[_NetworkInterfaceDnsSettings_c9406208, typing.Dict[builtins.str, typing.Any]]] = None,
        enable_accelerated_networking: typing.Optional[builtins.bool] = None,
        enable_ip_forwarding: typing.Optional[builtins.bool] = None,
        network_security_group: typing.Optional[typing.Union[_NetworkSecurityGroupReference_681673f0, typing.Dict[builtins.str, typing.Any]]] = None,
        primary: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Network interface configuration properties Uses NetworkInterfaceDnsSettings from azure-networkinterface for consistency.

        :param ip_configurations: 
        :param dns_settings: 
        :param enable_accelerated_networking: 
        :param enable_ip_forwarding: 
        :param network_security_group: 
        :param primary: 
        '''
        if isinstance(dns_settings, dict):
            dns_settings = _NetworkInterfaceDnsSettings_c9406208(**dns_settings)
        if isinstance(network_security_group, dict):
            network_security_group = _NetworkSecurityGroupReference_681673f0(**network_security_group)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0256863ae08652983c60bcb0528ac53283c86a24bf5f59250d73eb4a7ed0854c)
            check_type(argname="argument ip_configurations", value=ip_configurations, expected_type=type_hints["ip_configurations"])
            check_type(argname="argument dns_settings", value=dns_settings, expected_type=type_hints["dns_settings"])
            check_type(argname="argument enable_accelerated_networking", value=enable_accelerated_networking, expected_type=type_hints["enable_accelerated_networking"])
            check_type(argname="argument enable_ip_forwarding", value=enable_ip_forwarding, expected_type=type_hints["enable_ip_forwarding"])
            check_type(argname="argument network_security_group", value=network_security_group, expected_type=type_hints["network_security_group"])
            check_type(argname="argument primary", value=primary, expected_type=type_hints["primary"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "ip_configurations": ip_configurations,
        }
        if dns_settings is not None:
            self._values["dns_settings"] = dns_settings
        if enable_accelerated_networking is not None:
            self._values["enable_accelerated_networking"] = enable_accelerated_networking
        if enable_ip_forwarding is not None:
            self._values["enable_ip_forwarding"] = enable_ip_forwarding
        if network_security_group is not None:
            self._values["network_security_group"] = network_security_group
        if primary is not None:
            self._values["primary"] = primary

    @builtins.property
    def ip_configurations(self) -> typing.List[_IPConfiguration_3c957377]:
        result = self._values.get("ip_configurations")
        assert result is not None, "Required property 'ip_configurations' is missing"
        return typing.cast(typing.List[_IPConfiguration_3c957377], result)

    @builtins.property
    def dns_settings(self) -> typing.Optional[_NetworkInterfaceDnsSettings_c9406208]:
        result = self._values.get("dns_settings")
        return typing.cast(typing.Optional[_NetworkInterfaceDnsSettings_c9406208], result)

    @builtins.property
    def enable_accelerated_networking(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("enable_accelerated_networking")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_ip_forwarding(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("enable_ip_forwarding")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def network_security_group(
        self,
    ) -> typing.Optional[_NetworkSecurityGroupReference_681673f0]:
        result = self._values.get("network_security_group")
        return typing.cast(typing.Optional[_NetworkSecurityGroupReference_681673f0], result)

    @builtins.property
    def primary(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("primary")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "NetworkInterfaceConfigurationProperties(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.NetworkInterfaceDnsSettings",
    jsii_struct_bases=[],
    name_mapping={
        "dns_servers": "dnsServers",
        "internal_dns_name_label": "internalDnsNameLabel",
    },
)
class NetworkInterfaceDnsSettings:
    def __init__(
        self,
        *,
        dns_servers: typing.Optional[typing.Sequence[builtins.str]] = None,
        internal_dns_name_label: typing.Optional[builtins.str] = None,
    ) -> None:
        '''DNS settings configuration for Network Interface.

        :param dns_servers: Array of DNS server IP addresses.
        :param internal_dns_name_label: Internal DNS name label for the NIC.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__00cabfc566701b2f86ad59bd566748822838cf5e1aac533e5b09b41f4cab0222)
            check_type(argname="argument dns_servers", value=dns_servers, expected_type=type_hints["dns_servers"])
            check_type(argname="argument internal_dns_name_label", value=internal_dns_name_label, expected_type=type_hints["internal_dns_name_label"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if dns_servers is not None:
            self._values["dns_servers"] = dns_servers
        if internal_dns_name_label is not None:
            self._values["internal_dns_name_label"] = internal_dns_name_label

    @builtins.property
    def dns_servers(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Array of DNS server IP addresses.

        Example::

            ["10.0.0.4", "10.0.0.5"]
        '''
        result = self._values.get("dns_servers")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def internal_dns_name_label(self) -> typing.Optional[builtins.str]:
        '''Internal DNS name label for the NIC.

        Example::

            "myvm"
        '''
        result = self._values.get("internal_dns_name_label")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "NetworkInterfaceDnsSettings(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.NetworkInterfaceIPConfiguration",
    jsii_struct_bases=[],
    name_mapping={
        "name": "name",
        "subnet": "subnet",
        "primary": "primary",
        "private_ip_address": "privateIPAddress",
        "private_ip_allocation_method": "privateIPAllocationMethod",
        "public_ip_address": "publicIPAddress",
    },
)
class NetworkInterfaceIPConfiguration:
    def __init__(
        self,
        *,
        name: builtins.str,
        subnet: typing.Union[_NetworkInterfaceSubnetReference_12eff6ea, typing.Dict[builtins.str, typing.Any]],
        primary: typing.Optional[builtins.bool] = None,
        private_ip_address: typing.Optional[builtins.str] = None,
        private_ip_allocation_method: typing.Optional[builtins.str] = None,
        public_ip_address: typing.Optional[typing.Union[_NetworkInterfacePublicIPReference_3c09f670, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''IP Configuration for Network Interface.

        :param name: Name of the IP configuration.
        :param subnet: Subnet reference with id property.
        :param primary: Whether this is the primary IP configuration At least one IP configuration must be primary. Default: false
        :param private_ip_address: Private IP address (required if privateIPAllocationMethod is Static).
        :param private_ip_allocation_method: Private IP allocation method. Default: "Dynamic"
        :param public_ip_address: Public IP address reference with id property Optional - for NICs that need public IPs.
        '''
        if isinstance(subnet, dict):
            subnet = _NetworkInterfaceSubnetReference_12eff6ea(**subnet)
        if isinstance(public_ip_address, dict):
            public_ip_address = _NetworkInterfacePublicIPReference_3c09f670(**public_ip_address)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d9d86acd268dc09376d88ff5a680644364416ccb56777745cc74728036ec77ed)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument subnet", value=subnet, expected_type=type_hints["subnet"])
            check_type(argname="argument primary", value=primary, expected_type=type_hints["primary"])
            check_type(argname="argument private_ip_address", value=private_ip_address, expected_type=type_hints["private_ip_address"])
            check_type(argname="argument private_ip_allocation_method", value=private_ip_allocation_method, expected_type=type_hints["private_ip_allocation_method"])
            check_type(argname="argument public_ip_address", value=public_ip_address, expected_type=type_hints["public_ip_address"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
            "subnet": subnet,
        }
        if primary is not None:
            self._values["primary"] = primary
        if private_ip_address is not None:
            self._values["private_ip_address"] = private_ip_address
        if private_ip_allocation_method is not None:
            self._values["private_ip_allocation_method"] = private_ip_allocation_method
        if public_ip_address is not None:
            self._values["public_ip_address"] = public_ip_address

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of the IP configuration.

        Example::

            "ipconfig1"
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def subnet(self) -> _NetworkInterfaceSubnetReference_12eff6ea:
        '''Subnet reference with id property.

        Example::

            { id: "/subscriptions/.../subnets/mySubnet" }
        '''
        result = self._values.get("subnet")
        assert result is not None, "Required property 'subnet' is missing"
        return typing.cast(_NetworkInterfaceSubnetReference_12eff6ea, result)

    @builtins.property
    def primary(self) -> typing.Optional[builtins.bool]:
        '''Whether this is the primary IP configuration At least one IP configuration must be primary.

        :default: false
        '''
        result = self._values.get("primary")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def private_ip_address(self) -> typing.Optional[builtins.str]:
        '''Private IP address (required if privateIPAllocationMethod is Static).

        Example::

            "10.0.1.4"
        '''
        result = self._values.get("private_ip_address")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def private_ip_allocation_method(self) -> typing.Optional[builtins.str]:
        '''Private IP allocation method.

        :default: "Dynamic"

        Example::

            "Dynamic" or "Static"
        '''
        result = self._values.get("private_ip_allocation_method")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def public_ip_address(
        self,
    ) -> typing.Optional[_NetworkInterfacePublicIPReference_3c09f670]:
        '''Public IP address reference with id property Optional - for NICs that need public IPs.

        Example::

            { id: "/subscriptions/.../publicIPAddresses/myPublicIP" }
        '''
        result = self._values.get("public_ip_address")
        return typing.cast(typing.Optional[_NetworkInterfacePublicIPReference_3c09f670], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "NetworkInterfaceIPConfiguration(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.NetworkInterfaceNSGReference",
    jsii_struct_bases=[],
    name_mapping={"id": "id"},
)
class NetworkInterfaceNSGReference:
    def __init__(self, *, id: builtins.str) -> None:
        '''Network Security Group reference for Network Interface.

        :param id: Network Security Group resource ID.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__77f05f145e7dc125e229e469e7f83892dff066ac5f3fe233c710bf5a132fadb8)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "id": id,
        }

    @builtins.property
    def id(self) -> builtins.str:
        '''Network Security Group resource ID.'''
        result = self._values.get("id")
        assert result is not None, "Required property 'id' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "NetworkInterfaceNSGReference(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.NetworkInterfaceProps",
    jsii_struct_bases=[_AzapiResourceProps_141a2340],
    name_mapping={
        "connection": "connection",
        "count": "count",
        "depends_on": "dependsOn",
        "for_each": "forEach",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "provisioners": "provisioners",
        "api_version": "apiVersion",
        "enable_migration_analysis": "enableMigrationAnalysis",
        "enable_transformation": "enableTransformation",
        "enable_validation": "enableValidation",
        "location": "location",
        "monitoring": "monitoring",
        "name": "name",
        "tags": "tags",
        "ip_configurations": "ipConfigurations",
        "dns_settings": "dnsSettings",
        "enable_accelerated_networking": "enableAcceleratedNetworking",
        "enable_ip_forwarding": "enableIPForwarding",
        "ignore_changes": "ignoreChanges",
        "network_security_group": "networkSecurityGroup",
        "resource_group_id": "resourceGroupId",
    },
)
class NetworkInterfaceProps(_AzapiResourceProps_141a2340):
    def __init__(
        self,
        *,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
        api_version: typing.Optional[builtins.str] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        location: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        ip_configurations: typing.Sequence[typing.Union[_NetworkInterfaceIPConfiguration_c63cf7d5, typing.Dict[builtins.str, typing.Any]]],
        dns_settings: typing.Optional[typing.Union[_NetworkInterfaceDnsSettings_c9406208, typing.Dict[builtins.str, typing.Any]]] = None,
        enable_accelerated_networking: typing.Optional[builtins.bool] = None,
        enable_ip_forwarding: typing.Optional[builtins.bool] = None,
        ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
        network_security_group: typing.Optional[typing.Union[_NetworkInterfaceNSGReference_c2c81f03, typing.Dict[builtins.str, typing.Any]]] = None,
        resource_group_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for the unified Azure Network Interface.

        Extends VersionedAzapiResourceProps with Network Interface specific properties

        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        :param api_version: Explicit API version to use for this resource. If not specified, the latest active version will be automatically resolved. Use this for version pinning when stability is required over latest features. Default: Latest active version from ApiVersionManager
        :param enable_migration_analysis: Whether to enable migration analysis warnings. When true, the framework will analyze the current version for deprecation status and provide migration recommendations in the deployment output. Default: true
        :param enable_transformation: Whether to apply property transformations automatically. When true, properties will be automatically transformed according to the target schema's transformation rules. This enables backward compatibility. Default: true
        :param enable_validation: Whether to validate properties against the schema. When true, all properties will be validated against the API schema before resource creation. Validation errors will cause deployment failures. Default: true
        :param location: The location where the resource should be created. Default: Varies by resource type - see specific resource documentation
        :param monitoring: Monitoring configuration for this resource. Enables integrated monitoring with diagnostic settings, metric alerts, and activity log alerts. All monitoring is optional and disabled by default.
        :param name: The name of the resource.
        :param tags: Tags to apply to the resource.
        :param ip_configurations: IP configurations for the network interface At least one IP configuration is required One IP configuration must be marked as primary.
        :param dns_settings: DNS settings configuration Optional - configures DNS servers for the NIC.
        :param enable_accelerated_networking: Enable accelerated networking for high-performance scenarios Requires supported VM size. Default: false
        :param enable_ip_forwarding: Enable IP forwarding for network virtual appliances Allows NIC to forward traffic not destined for its IP. Default: false
        :param ignore_changes: The lifecycle rules to ignore changes.
        :param network_security_group: Network Security Group reference with id property Optional - associates an NSG with this NIC.
        :param resource_group_id: Resource group ID where the network interface will be created.
        '''
        if isinstance(lifecycle, dict):
            lifecycle = _cdktf_9a9027ec.TerraformResourceLifecycle(**lifecycle)
        if isinstance(monitoring, dict):
            monitoring = _MonitoringConfig_7c28df74(**monitoring)
        if isinstance(dns_settings, dict):
            dns_settings = _NetworkInterfaceDnsSettings_c9406208(**dns_settings)
        if isinstance(network_security_group, dict):
            network_security_group = _NetworkInterfaceNSGReference_c2c81f03(**network_security_group)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3cbf85f4b7cf1de4c36f7e71a6506713428abb4553ba775e90d85a820b88ec8f)
            check_type(argname="argument connection", value=connection, expected_type=type_hints["connection"])
            check_type(argname="argument count", value=count, expected_type=type_hints["count"])
            check_type(argname="argument depends_on", value=depends_on, expected_type=type_hints["depends_on"])
            check_type(argname="argument for_each", value=for_each, expected_type=type_hints["for_each"])
            check_type(argname="argument lifecycle", value=lifecycle, expected_type=type_hints["lifecycle"])
            check_type(argname="argument provider", value=provider, expected_type=type_hints["provider"])
            check_type(argname="argument provisioners", value=provisioners, expected_type=type_hints["provisioners"])
            check_type(argname="argument api_version", value=api_version, expected_type=type_hints["api_version"])
            check_type(argname="argument enable_migration_analysis", value=enable_migration_analysis, expected_type=type_hints["enable_migration_analysis"])
            check_type(argname="argument enable_transformation", value=enable_transformation, expected_type=type_hints["enable_transformation"])
            check_type(argname="argument enable_validation", value=enable_validation, expected_type=type_hints["enable_validation"])
            check_type(argname="argument location", value=location, expected_type=type_hints["location"])
            check_type(argname="argument monitoring", value=monitoring, expected_type=type_hints["monitoring"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument ip_configurations", value=ip_configurations, expected_type=type_hints["ip_configurations"])
            check_type(argname="argument dns_settings", value=dns_settings, expected_type=type_hints["dns_settings"])
            check_type(argname="argument enable_accelerated_networking", value=enable_accelerated_networking, expected_type=type_hints["enable_accelerated_networking"])
            check_type(argname="argument enable_ip_forwarding", value=enable_ip_forwarding, expected_type=type_hints["enable_ip_forwarding"])
            check_type(argname="argument ignore_changes", value=ignore_changes, expected_type=type_hints["ignore_changes"])
            check_type(argname="argument network_security_group", value=network_security_group, expected_type=type_hints["network_security_group"])
            check_type(argname="argument resource_group_id", value=resource_group_id, expected_type=type_hints["resource_group_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "ip_configurations": ip_configurations,
        }
        if connection is not None:
            self._values["connection"] = connection
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if for_each is not None:
            self._values["for_each"] = for_each
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider
        if provisioners is not None:
            self._values["provisioners"] = provisioners
        if api_version is not None:
            self._values["api_version"] = api_version
        if enable_migration_analysis is not None:
            self._values["enable_migration_analysis"] = enable_migration_analysis
        if enable_transformation is not None:
            self._values["enable_transformation"] = enable_transformation
        if enable_validation is not None:
            self._values["enable_validation"] = enable_validation
        if location is not None:
            self._values["location"] = location
        if monitoring is not None:
            self._values["monitoring"] = monitoring
        if name is not None:
            self._values["name"] = name
        if tags is not None:
            self._values["tags"] = tags
        if dns_settings is not None:
            self._values["dns_settings"] = dns_settings
        if enable_accelerated_networking is not None:
            self._values["enable_accelerated_networking"] = enable_accelerated_networking
        if enable_ip_forwarding is not None:
            self._values["enable_ip_forwarding"] = enable_ip_forwarding
        if ignore_changes is not None:
            self._values["ignore_changes"] = ignore_changes
        if network_security_group is not None:
            self._values["network_security_group"] = network_security_group
        if resource_group_id is not None:
            self._values["resource_group_id"] = resource_group_id

    @builtins.property
    def connection(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("connection")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]], result)

    @builtins.property
    def count(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]], result)

    @builtins.property
    def depends_on(
        self,
    ) -> typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]], result)

    @builtins.property
    def for_each(self) -> typing.Optional[_cdktf_9a9027ec.ITerraformIterator]:
        '''
        :stability: experimental
        '''
        result = self._values.get("for_each")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.ITerraformIterator], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[_cdktf_9a9027ec.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformProvider], result)

    @builtins.property
    def provisioners(
        self,
    ) -> typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provisioners")
        return typing.cast(typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]], result)

    @builtins.property
    def api_version(self) -> typing.Optional[builtins.str]:
        '''Explicit API version to use for this resource.

        If not specified, the latest active version will be automatically resolved.
        Use this for version pinning when stability is required over latest features.

        :default: Latest active version from ApiVersionManager

        Example::

            "2024-11-01"
        '''
        result = self._values.get("api_version")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def enable_migration_analysis(self) -> typing.Optional[builtins.bool]:
        '''Whether to enable migration analysis warnings.

        When true, the framework will analyze the current version for deprecation
        status and provide migration recommendations in the deployment output.

        :default: true
        '''
        result = self._values.get("enable_migration_analysis")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_transformation(self) -> typing.Optional[builtins.bool]:
        '''Whether to apply property transformations automatically.

        When true, properties will be automatically transformed according to the
        target schema's transformation rules. This enables backward compatibility.

        :default: true
        '''
        result = self._values.get("enable_transformation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_validation(self) -> typing.Optional[builtins.bool]:
        '''Whether to validate properties against the schema.

        When true, all properties will be validated against the API schema before
        resource creation. Validation errors will cause deployment failures.

        :default: true
        '''
        result = self._values.get("enable_validation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def location(self) -> typing.Optional[builtins.str]:
        '''The location where the resource should be created.

        :default: Varies by resource type - see specific resource documentation

        :remarks:

        Location handling varies by resource type:

        - **Top-level resources**: Most require an explicit location (e.g., "eastus", "westus")
        - **Global resources**: Some use "global" as location (e.g., Private DNS Zones)
        - **Child resources**: Inherit location from parent and should NOT set this property

        Each resource type may provide its own default through the ``resolveLocation()`` method.
        If no location is specified and no default exists, resource creation may fail.

        Example::

            // Child resource (Subnet) - do not set location
            // location: undefined (inherited from parent Virtual Network)
        '''
        result = self._values.get("location")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def monitoring(self) -> typing.Optional[_MonitoringConfig_7c28df74]:
        '''Monitoring configuration for this resource.

        Enables integrated monitoring with diagnostic settings, metric alerts,
        and activity log alerts. All monitoring is optional and disabled by default.

        Example::

            monitoring: {
              enabled: true,
              diagnosticSettings: {
                workspaceId: logAnalytics.id,
                metrics: ['AllMetrics'],
                logs: ['AuditLogs']
              },
              metricAlerts: [{
                name: 'high-cpu-alert',
                severity: 2,
                scopes: [], // Automatically set to this resource
                criteria: { ... },
                actions: [{ actionGroupId: actionGroup.id }]
              }]
            }
        '''
        result = self._values.get("monitoring")
        return typing.cast(typing.Optional[_MonitoringConfig_7c28df74], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the resource.'''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Tags to apply to the resource.'''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def ip_configurations(
        self,
    ) -> typing.List[_NetworkInterfaceIPConfiguration_c63cf7d5]:
        '''IP configurations for the network interface At least one IP configuration is required One IP configuration must be marked as primary.'''
        result = self._values.get("ip_configurations")
        assert result is not None, "Required property 'ip_configurations' is missing"
        return typing.cast(typing.List[_NetworkInterfaceIPConfiguration_c63cf7d5], result)

    @builtins.property
    def dns_settings(self) -> typing.Optional[_NetworkInterfaceDnsSettings_c9406208]:
        '''DNS settings configuration Optional - configures DNS servers for the NIC.'''
        result = self._values.get("dns_settings")
        return typing.cast(typing.Optional[_NetworkInterfaceDnsSettings_c9406208], result)

    @builtins.property
    def enable_accelerated_networking(self) -> typing.Optional[builtins.bool]:
        '''Enable accelerated networking for high-performance scenarios Requires supported VM size.

        :default: false
        '''
        result = self._values.get("enable_accelerated_networking")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_ip_forwarding(self) -> typing.Optional[builtins.bool]:
        '''Enable IP forwarding for network virtual appliances Allows NIC to forward traffic not destined for its IP.

        :default: false
        '''
        result = self._values.get("enable_ip_forwarding")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def ignore_changes(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The lifecycle rules to ignore changes.

        Example::

            ["tags"]
        '''
        result = self._values.get("ignore_changes")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def network_security_group(
        self,
    ) -> typing.Optional[_NetworkInterfaceNSGReference_c2c81f03]:
        '''Network Security Group reference with id property Optional - associates an NSG with this NIC.

        Example::

            { id: "/subscriptions/.../networkSecurityGroups/myNSG" }
        '''
        result = self._values.get("network_security_group")
        return typing.cast(typing.Optional[_NetworkInterfaceNSGReference_c2c81f03], result)

    @builtins.property
    def resource_group_id(self) -> typing.Optional[builtins.str]:
        '''Resource group ID where the network interface will be created.'''
        result = self._values.get("resource_group_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "NetworkInterfaceProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.NetworkInterfacePublicIPReference",
    jsii_struct_bases=[],
    name_mapping={"id": "id"},
)
class NetworkInterfacePublicIPReference:
    def __init__(self, *, id: builtins.str) -> None:
        '''Public IP address reference for Network Interface.

        :param id: Public IP address resource ID.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5e0d6db7759e56b82f512e467124d6d9962bd66cc7d048367db044d5bbaabffc)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "id": id,
        }

    @builtins.property
    def id(self) -> builtins.str:
        '''Public IP address resource ID.'''
        result = self._values.get("id")
        assert result is not None, "Required property 'id' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "NetworkInterfacePublicIPReference(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.NetworkInterfaceSubnetReference",
    jsii_struct_bases=[],
    name_mapping={"id": "id"},
)
class NetworkInterfaceSubnetReference:
    def __init__(self, *, id: builtins.str) -> None:
        '''Subnet reference for Network Interface.

        :param id: Subnet resource ID.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__45d004bcf1c8c57368b99769bdb78d785b6b9c1e3b134a074dc6e768a471aa7f)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "id": id,
        }

    @builtins.property
    def id(self) -> builtins.str:
        '''Subnet resource ID.'''
        result = self._values.get("id")
        assert result is not None, "Required property 'id' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "NetworkInterfaceSubnetReference(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.NetworkManagerScopes",
    jsii_struct_bases=[],
    name_mapping={
        "management_groups": "managementGroups",
        "subscriptions": "subscriptions",
    },
)
class NetworkManagerScopes:
    def __init__(
        self,
        *,
        management_groups: typing.Optional[typing.Sequence[builtins.str]] = None,
        subscriptions: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''Scope configuration for Virtual Network Manager.

        :param management_groups: Array of management group IDs that define the scope.
        :param subscriptions: Array of subscription IDs that define the scope.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0beb176443403aee32dd756890c36035fedd23e33f5d949be1d9f0284cb2aa1b)
            check_type(argname="argument management_groups", value=management_groups, expected_type=type_hints["management_groups"])
            check_type(argname="argument subscriptions", value=subscriptions, expected_type=type_hints["subscriptions"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if management_groups is not None:
            self._values["management_groups"] = management_groups
        if subscriptions is not None:
            self._values["subscriptions"] = subscriptions

    @builtins.property
    def management_groups(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Array of management group IDs that define the scope.

        Example::

            ["/providers/Microsoft.Management/managementGroups/mg1"]
        '''
        result = self._values.get("management_groups")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def subscriptions(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Array of subscription IDs that define the scope.

        Example::

            ["/subscriptions/00000000-0000-0000-0000-000000000000"]
        '''
        result = self._values.get("subscriptions")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "NetworkManagerScopes(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class NetworkSecurityGroup(
    _AzapiResource_7e7f5b39,
    metaclass=jsii.JSIIMeta,
    jsii_type="@microsoft/terraform-cdk-constructs.NetworkSecurityGroup",
):
    '''Azure Network Security Group implementation.

    This class provides a single, version-aware implementation that replaces
    version-specific Network Security Group classes. It automatically handles version
    resolution, schema validation, and property transformation while maintaining
    full backward compatibility.

    Example::

        // Usage with explicit version pinning:
        const nsg = new NetworkSecurityGroup(this, "nsg", {
          name: "my-nsg",
          location: "eastus",
          apiVersion: "2024-07-01",
          securityRules: [...]
        });
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        flush_connection: typing.Optional[builtins.bool] = None,
        ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
        resource_group_id: typing.Optional[builtins.str] = None,
        security_rules: typing.Optional[typing.Sequence[typing.Union[_SecurityRule_e3229718, typing.Dict[builtins.str, typing.Any]]]] = None,
        api_version: typing.Optional[builtins.str] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        location: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> None:
        '''Creates a new Azure Network Security Group using the AzapiResource framework.

        The constructor automatically handles version resolution, schema registration,
        validation, and resource creation. It maintains full backward compatibility
        with existing Network Security Group implementations.

        :param scope: - The scope in which to define this construct.
        :param id: - The unique identifier for this instance.
        :param flush_connection: When enabled, flows created from NSG connections will be re-evaluated when rules are updated. Default: false
        :param ignore_changes: The lifecycle rules to ignore changes Useful for properties that are externally managed.
        :param resource_group_id: Resource group ID where the NSG will be created Optional - will use the subscription scope if not provided.
        :param security_rules: Security rules for the network security group Optional - rules can also be added after creation.
        :param api_version: Explicit API version to use for this resource. If not specified, the latest active version will be automatically resolved. Use this for version pinning when stability is required over latest features. Default: Latest active version from ApiVersionManager
        :param enable_migration_analysis: Whether to enable migration analysis warnings. When true, the framework will analyze the current version for deprecation status and provide migration recommendations in the deployment output. Default: true
        :param enable_transformation: Whether to apply property transformations automatically. When true, properties will be automatically transformed according to the target schema's transformation rules. This enables backward compatibility. Default: true
        :param enable_validation: Whether to validate properties against the schema. When true, all properties will be validated against the API schema before resource creation. Validation errors will cause deployment failures. Default: true
        :param location: The location where the resource should be created. Default: Varies by resource type - see specific resource documentation
        :param monitoring: Monitoring configuration for this resource. Enables integrated monitoring with diagnostic settings, metric alerts, and activity log alerts. All monitoring is optional and disabled by default.
        :param name: The name of the resource.
        :param tags: Tags to apply to the resource.
        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__506933c2da7febf7b8856e205c8fcaf391678f60849c57da6b57d9f919cb5ec6)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = _NetworkSecurityGroupProps_b07981a4(
            flush_connection=flush_connection,
            ignore_changes=ignore_changes,
            resource_group_id=resource_group_id,
            security_rules=security_rules,
            api_version=api_version,
            enable_migration_analysis=enable_migration_analysis,
            enable_transformation=enable_transformation,
            enable_validation=enable_validation,
            location=location,
            monitoring=monitoring,
            name=name,
            tags=tags,
            connection=connection,
            count=count,
            depends_on=depends_on,
            for_each=for_each,
            lifecycle=lifecycle,
            provider=provider,
            provisioners=provisioners,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="addTag")
    def add_tag(self, key: builtins.str, value: builtins.str) -> None:
        '''Add a tag to the Network Security Group Note: This modifies the construct props but requires a new deployment to take effect.

        :param key: -
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c45843a987f1cf901f2aef607d07d4f1056765c1d75bb28b46382f40de9ee42a)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "addTag", [key, value]))

    @jsii.member(jsii_name="apiSchema")
    def _api_schema(self) -> _ApiSchema_5ce0490e:
        '''Gets the API schema for the resolved version Uses the framework's schema resolution to get the appropriate schema.'''
        return typing.cast(_ApiSchema_5ce0490e, jsii.invoke(self, "apiSchema", []))

    @jsii.member(jsii_name="createResourceBody")
    def _create_resource_body(self, props: typing.Any) -> typing.Any:
        '''Creates the resource body for the Azure API call Transforms the input properties into the JSON format expected by Azure REST API.

        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__882f27e6ef60d9417d0e0d39afbdd409ee589dc25cdd46d9b9807ecfab942a1b)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Any, jsii.invoke(self, "createResourceBody", [props]))

    @jsii.member(jsii_name="defaultVersion")
    def _default_version(self) -> builtins.str:
        '''Gets the default API version to use when no explicit version is specified Returns the most recent stable version as the default.'''
        return typing.cast(builtins.str, jsii.invoke(self, "defaultVersion", []))

    @jsii.member(jsii_name="removeTag")
    def remove_tag(self, key: builtins.str) -> None:
        '''Remove a tag from the Network Security Group Note: This modifies the construct props but requires a new deployment to take effect.

        :param key: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__06a9fe506be3033921dce6a338d855445aceac25815451484ec9747c7dc3cc0f)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
        return typing.cast(None, jsii.invoke(self, "removeTag", [key]))

    @jsii.member(jsii_name="requiresLocation")
    def _requires_location(self) -> builtins.bool:
        '''Indicates that location is required for Network Security Groups.'''
        return typing.cast(builtins.bool, jsii.invoke(self, "requiresLocation", []))

    @jsii.member(jsii_name="resourceType")
    def _resource_type(self) -> builtins.str:
        '''Gets the Azure resource type for Network Security Groups.'''
        return typing.cast(builtins.str, jsii.invoke(self, "resourceType", []))

    @builtins.property
    @jsii.member(jsii_name="idOutput")
    def id_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "idOutput"))

    @builtins.property
    @jsii.member(jsii_name="locationOutput")
    def location_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "locationOutput"))

    @builtins.property
    @jsii.member(jsii_name="nameOutput")
    def name_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "nameOutput"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def props(self) -> _NetworkSecurityGroupProps_b07981a4:
        '''The input properties for this Network Security Group instance.'''
        return typing.cast(_NetworkSecurityGroupProps_b07981a4, jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="resourceId")
    def resource_id(self) -> builtins.str:
        '''Get the full resource identifier for use in other Azure resources Alias for the id property to match original interface.'''
        return typing.cast(builtins.str, jsii.get(self, "resourceId"))

    @builtins.property
    @jsii.member(jsii_name="securityRules")
    def security_rules(self) -> builtins.str:
        '''Get the security rules output value Returns the Terraform interpolation string for the security rules.'''
        return typing.cast(builtins.str, jsii.get(self, "securityRules"))

    @builtins.property
    @jsii.member(jsii_name="securityRulesOutput")
    def security_rules_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "securityRulesOutput"))

    @builtins.property
    @jsii.member(jsii_name="subscriptionId")
    def subscription_id(self) -> builtins.str:
        '''Get the subscription ID from the Network Security Group ID Extracts the subscription ID from the Azure resource ID format.'''
        return typing.cast(builtins.str, jsii.get(self, "subscriptionId"))

    @builtins.property
    @jsii.member(jsii_name="tagsOutput")
    def tags_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "tagsOutput"))


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.NetworkSecurityGroupProps",
    jsii_struct_bases=[_AzapiResourceProps_141a2340],
    name_mapping={
        "connection": "connection",
        "count": "count",
        "depends_on": "dependsOn",
        "for_each": "forEach",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "provisioners": "provisioners",
        "api_version": "apiVersion",
        "enable_migration_analysis": "enableMigrationAnalysis",
        "enable_transformation": "enableTransformation",
        "enable_validation": "enableValidation",
        "location": "location",
        "monitoring": "monitoring",
        "name": "name",
        "tags": "tags",
        "flush_connection": "flushConnection",
        "ignore_changes": "ignoreChanges",
        "resource_group_id": "resourceGroupId",
        "security_rules": "securityRules",
    },
)
class NetworkSecurityGroupProps(_AzapiResourceProps_141a2340):
    def __init__(
        self,
        *,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
        api_version: typing.Optional[builtins.str] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        location: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        flush_connection: typing.Optional[builtins.bool] = None,
        ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
        resource_group_id: typing.Optional[builtins.str] = None,
        security_rules: typing.Optional[typing.Sequence[typing.Union[_SecurityRule_e3229718, typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Properties for the Azure Network Security Group.

        Extends AzapiResourceProps with Network Security Group specific properties

        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        :param api_version: Explicit API version to use for this resource. If not specified, the latest active version will be automatically resolved. Use this for version pinning when stability is required over latest features. Default: Latest active version from ApiVersionManager
        :param enable_migration_analysis: Whether to enable migration analysis warnings. When true, the framework will analyze the current version for deprecation status and provide migration recommendations in the deployment output. Default: true
        :param enable_transformation: Whether to apply property transformations automatically. When true, properties will be automatically transformed according to the target schema's transformation rules. This enables backward compatibility. Default: true
        :param enable_validation: Whether to validate properties against the schema. When true, all properties will be validated against the API schema before resource creation. Validation errors will cause deployment failures. Default: true
        :param location: The location where the resource should be created. Default: Varies by resource type - see specific resource documentation
        :param monitoring: Monitoring configuration for this resource. Enables integrated monitoring with diagnostic settings, metric alerts, and activity log alerts. All monitoring is optional and disabled by default.
        :param name: The name of the resource.
        :param tags: Tags to apply to the resource.
        :param flush_connection: When enabled, flows created from NSG connections will be re-evaluated when rules are updated. Default: false
        :param ignore_changes: The lifecycle rules to ignore changes Useful for properties that are externally managed.
        :param resource_group_id: Resource group ID where the NSG will be created Optional - will use the subscription scope if not provided.
        :param security_rules: Security rules for the network security group Optional - rules can also be added after creation.
        '''
        if isinstance(lifecycle, dict):
            lifecycle = _cdktf_9a9027ec.TerraformResourceLifecycle(**lifecycle)
        if isinstance(monitoring, dict):
            monitoring = _MonitoringConfig_7c28df74(**monitoring)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__19d2e80f419bb6cfa512812679637ec83446320cc205994d33c24b74eb249259)
            check_type(argname="argument connection", value=connection, expected_type=type_hints["connection"])
            check_type(argname="argument count", value=count, expected_type=type_hints["count"])
            check_type(argname="argument depends_on", value=depends_on, expected_type=type_hints["depends_on"])
            check_type(argname="argument for_each", value=for_each, expected_type=type_hints["for_each"])
            check_type(argname="argument lifecycle", value=lifecycle, expected_type=type_hints["lifecycle"])
            check_type(argname="argument provider", value=provider, expected_type=type_hints["provider"])
            check_type(argname="argument provisioners", value=provisioners, expected_type=type_hints["provisioners"])
            check_type(argname="argument api_version", value=api_version, expected_type=type_hints["api_version"])
            check_type(argname="argument enable_migration_analysis", value=enable_migration_analysis, expected_type=type_hints["enable_migration_analysis"])
            check_type(argname="argument enable_transformation", value=enable_transformation, expected_type=type_hints["enable_transformation"])
            check_type(argname="argument enable_validation", value=enable_validation, expected_type=type_hints["enable_validation"])
            check_type(argname="argument location", value=location, expected_type=type_hints["location"])
            check_type(argname="argument monitoring", value=monitoring, expected_type=type_hints["monitoring"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument flush_connection", value=flush_connection, expected_type=type_hints["flush_connection"])
            check_type(argname="argument ignore_changes", value=ignore_changes, expected_type=type_hints["ignore_changes"])
            check_type(argname="argument resource_group_id", value=resource_group_id, expected_type=type_hints["resource_group_id"])
            check_type(argname="argument security_rules", value=security_rules, expected_type=type_hints["security_rules"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if connection is not None:
            self._values["connection"] = connection
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if for_each is not None:
            self._values["for_each"] = for_each
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider
        if provisioners is not None:
            self._values["provisioners"] = provisioners
        if api_version is not None:
            self._values["api_version"] = api_version
        if enable_migration_analysis is not None:
            self._values["enable_migration_analysis"] = enable_migration_analysis
        if enable_transformation is not None:
            self._values["enable_transformation"] = enable_transformation
        if enable_validation is not None:
            self._values["enable_validation"] = enable_validation
        if location is not None:
            self._values["location"] = location
        if monitoring is not None:
            self._values["monitoring"] = monitoring
        if name is not None:
            self._values["name"] = name
        if tags is not None:
            self._values["tags"] = tags
        if flush_connection is not None:
            self._values["flush_connection"] = flush_connection
        if ignore_changes is not None:
            self._values["ignore_changes"] = ignore_changes
        if resource_group_id is not None:
            self._values["resource_group_id"] = resource_group_id
        if security_rules is not None:
            self._values["security_rules"] = security_rules

    @builtins.property
    def connection(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("connection")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]], result)

    @builtins.property
    def count(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]], result)

    @builtins.property
    def depends_on(
        self,
    ) -> typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]], result)

    @builtins.property
    def for_each(self) -> typing.Optional[_cdktf_9a9027ec.ITerraformIterator]:
        '''
        :stability: experimental
        '''
        result = self._values.get("for_each")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.ITerraformIterator], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[_cdktf_9a9027ec.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformProvider], result)

    @builtins.property
    def provisioners(
        self,
    ) -> typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provisioners")
        return typing.cast(typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]], result)

    @builtins.property
    def api_version(self) -> typing.Optional[builtins.str]:
        '''Explicit API version to use for this resource.

        If not specified, the latest active version will be automatically resolved.
        Use this for version pinning when stability is required over latest features.

        :default: Latest active version from ApiVersionManager

        Example::

            "2024-11-01"
        '''
        result = self._values.get("api_version")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def enable_migration_analysis(self) -> typing.Optional[builtins.bool]:
        '''Whether to enable migration analysis warnings.

        When true, the framework will analyze the current version for deprecation
        status and provide migration recommendations in the deployment output.

        :default: true
        '''
        result = self._values.get("enable_migration_analysis")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_transformation(self) -> typing.Optional[builtins.bool]:
        '''Whether to apply property transformations automatically.

        When true, properties will be automatically transformed according to the
        target schema's transformation rules. This enables backward compatibility.

        :default: true
        '''
        result = self._values.get("enable_transformation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_validation(self) -> typing.Optional[builtins.bool]:
        '''Whether to validate properties against the schema.

        When true, all properties will be validated against the API schema before
        resource creation. Validation errors will cause deployment failures.

        :default: true
        '''
        result = self._values.get("enable_validation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def location(self) -> typing.Optional[builtins.str]:
        '''The location where the resource should be created.

        :default: Varies by resource type - see specific resource documentation

        :remarks:

        Location handling varies by resource type:

        - **Top-level resources**: Most require an explicit location (e.g., "eastus", "westus")
        - **Global resources**: Some use "global" as location (e.g., Private DNS Zones)
        - **Child resources**: Inherit location from parent and should NOT set this property

        Each resource type may provide its own default through the ``resolveLocation()`` method.
        If no location is specified and no default exists, resource creation may fail.

        Example::

            // Child resource (Subnet) - do not set location
            // location: undefined (inherited from parent Virtual Network)
        '''
        result = self._values.get("location")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def monitoring(self) -> typing.Optional[_MonitoringConfig_7c28df74]:
        '''Monitoring configuration for this resource.

        Enables integrated monitoring with diagnostic settings, metric alerts,
        and activity log alerts. All monitoring is optional and disabled by default.

        Example::

            monitoring: {
              enabled: true,
              diagnosticSettings: {
                workspaceId: logAnalytics.id,
                metrics: ['AllMetrics'],
                logs: ['AuditLogs']
              },
              metricAlerts: [{
                name: 'high-cpu-alert',
                severity: 2,
                scopes: [], // Automatically set to this resource
                criteria: { ... },
                actions: [{ actionGroupId: actionGroup.id }]
              }]
            }
        '''
        result = self._values.get("monitoring")
        return typing.cast(typing.Optional[_MonitoringConfig_7c28df74], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the resource.'''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Tags to apply to the resource.'''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def flush_connection(self) -> typing.Optional[builtins.bool]:
        '''When enabled, flows created from NSG connections will be re-evaluated when rules are updated.

        :default: false
        '''
        result = self._values.get("flush_connection")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def ignore_changes(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The lifecycle rules to ignore changes Useful for properties that are externally managed.

        Example::

            ["tags", "securityRules"]
        '''
        result = self._values.get("ignore_changes")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def resource_group_id(self) -> typing.Optional[builtins.str]:
        '''Resource group ID where the NSG will be created Optional - will use the subscription scope if not provided.'''
        result = self._values.get("resource_group_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def security_rules(self) -> typing.Optional[typing.List[_SecurityRule_e3229718]]:
        '''Security rules for the network security group Optional - rules can also be added after creation.'''
        result = self._values.get("security_rules")
        return typing.cast(typing.Optional[typing.List[_SecurityRule_e3229718]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "NetworkSecurityGroupProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.NetworkSecurityGroupReference",
    jsii_struct_bases=[],
    name_mapping={"id": "id"},
)
class NetworkSecurityGroupReference:
    def __init__(self, *, id: builtins.str) -> None:
        '''Network security group reference.

        :param id: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1a555cce2948e017ec61958da229e0a0dc1d4797bc134c93f5080d3392629d67)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "id": id,
        }

    @builtins.property
    def id(self) -> builtins.str:
        result = self._values.get("id")
        assert result is not None, "Required property 'id' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "NetworkSecurityGroupReference(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.OrphanedResource",
    jsii_struct_bases=[],
    name_mapping={
        "age_hours": "ageHours",
        "cleanup_after": "cleanupAfter",
        "created_at": "createdAt",
        "location": "location",
        "name": "name",
        "resource_group": "resourceGroup",
        "resource_id": "resourceId",
        "resource_type": "resourceType",
        "test_name": "testName",
        "test_run_id": "testRunId",
    },
)
class OrphanedResource:
    def __init__(
        self,
        *,
        age_hours: jsii.Number,
        cleanup_after: datetime.datetime,
        created_at: datetime.datetime,
        location: builtins.str,
        name: builtins.str,
        resource_group: builtins.str,
        resource_id: builtins.str,
        resource_type: builtins.str,
        test_name: builtins.str,
        test_run_id: builtins.str,
    ) -> None:
        '''Orphaned resource information.

        :param age_hours: Age in hours since creation.
        :param cleanup_after: Cleanup after timestamp from tags.
        :param created_at: Creation timestamp from tags.
        :param location: Resource location.
        :param name: Resource name.
        :param resource_group: Resource group name.
        :param resource_id: Azure resource ID.
        :param resource_type: Azure resource type.
        :param test_name: Test name from tags.
        :param test_run_id: Test run ID from tags.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3fd4532e9f020cb8ce5937cff38aed8544a3a7f7653708edd323e5e844d9c270)
            check_type(argname="argument age_hours", value=age_hours, expected_type=type_hints["age_hours"])
            check_type(argname="argument cleanup_after", value=cleanup_after, expected_type=type_hints["cleanup_after"])
            check_type(argname="argument created_at", value=created_at, expected_type=type_hints["created_at"])
            check_type(argname="argument location", value=location, expected_type=type_hints["location"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument resource_group", value=resource_group, expected_type=type_hints["resource_group"])
            check_type(argname="argument resource_id", value=resource_id, expected_type=type_hints["resource_id"])
            check_type(argname="argument resource_type", value=resource_type, expected_type=type_hints["resource_type"])
            check_type(argname="argument test_name", value=test_name, expected_type=type_hints["test_name"])
            check_type(argname="argument test_run_id", value=test_run_id, expected_type=type_hints["test_run_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "age_hours": age_hours,
            "cleanup_after": cleanup_after,
            "created_at": created_at,
            "location": location,
            "name": name,
            "resource_group": resource_group,
            "resource_id": resource_id,
            "resource_type": resource_type,
            "test_name": test_name,
            "test_run_id": test_run_id,
        }

    @builtins.property
    def age_hours(self) -> jsii.Number:
        '''Age in hours since creation.'''
        result = self._values.get("age_hours")
        assert result is not None, "Required property 'age_hours' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def cleanup_after(self) -> datetime.datetime:
        '''Cleanup after timestamp from tags.'''
        result = self._values.get("cleanup_after")
        assert result is not None, "Required property 'cleanup_after' is missing"
        return typing.cast(datetime.datetime, result)

    @builtins.property
    def created_at(self) -> datetime.datetime:
        '''Creation timestamp from tags.'''
        result = self._values.get("created_at")
        assert result is not None, "Required property 'created_at' is missing"
        return typing.cast(datetime.datetime, result)

    @builtins.property
    def location(self) -> builtins.str:
        '''Resource location.'''
        result = self._values.get("location")
        assert result is not None, "Required property 'location' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def name(self) -> builtins.str:
        '''Resource name.'''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def resource_group(self) -> builtins.str:
        '''Resource group name.'''
        result = self._values.get("resource_group")
        assert result is not None, "Required property 'resource_group' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def resource_id(self) -> builtins.str:
        '''Azure resource ID.'''
        result = self._values.get("resource_id")
        assert result is not None, "Required property 'resource_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def resource_type(self) -> builtins.str:
        '''Azure resource type.'''
        result = self._values.get("resource_type")
        assert result is not None, "Required property 'resource_type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def test_name(self) -> builtins.str:
        '''Test name from tags.'''
        result = self._values.get("test_name")
        assert result is not None, "Required property 'test_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def test_run_id(self) -> builtins.str:
        '''Test run ID from tags.'''
        result = self._values.get("test_run_id")
        assert result is not None, "Required property 'test_run_id' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "OrphanedResource(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.ParsedCidr",
    jsii_struct_bases=[],
    name_mapping={
        "cidr": "cidr",
        "first_ip": "firstIp",
        "last_ip": "lastIp",
        "netmask": "netmask",
        "network": "network",
        "prefix": "prefix",
        "total_addresses": "totalAddresses",
    },
)
class ParsedCidr:
    def __init__(
        self,
        *,
        cidr: builtins.str,
        first_ip: builtins.str,
        last_ip: builtins.str,
        netmask: builtins.str,
        network: builtins.str,
        prefix: jsii.Number,
        total_addresses: jsii.Number,
    ) -> None:
        '''Parsed CIDR information.

        :param cidr: Original CIDR notation (e.g., "10.0.0.0/8").
        :param first_ip: First usable IP address.
        :param last_ip: Last usable IP address.
        :param netmask: Network mask (e.g., "255.0.0.0").
        :param network: Network address (e.g., "10.0.0.0").
        :param prefix: Prefix length (e.g., 8).
        :param total_addresses: Total number of addresses in the range.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7ece58b6ac4575ffe65caa0fcf3a34c5383f2a2fa0f13c98ce22aac8ea4d0058)
            check_type(argname="argument cidr", value=cidr, expected_type=type_hints["cidr"])
            check_type(argname="argument first_ip", value=first_ip, expected_type=type_hints["first_ip"])
            check_type(argname="argument last_ip", value=last_ip, expected_type=type_hints["last_ip"])
            check_type(argname="argument netmask", value=netmask, expected_type=type_hints["netmask"])
            check_type(argname="argument network", value=network, expected_type=type_hints["network"])
            check_type(argname="argument prefix", value=prefix, expected_type=type_hints["prefix"])
            check_type(argname="argument total_addresses", value=total_addresses, expected_type=type_hints["total_addresses"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "cidr": cidr,
            "first_ip": first_ip,
            "last_ip": last_ip,
            "netmask": netmask,
            "network": network,
            "prefix": prefix,
            "total_addresses": total_addresses,
        }

    @builtins.property
    def cidr(self) -> builtins.str:
        '''Original CIDR notation (e.g., "10.0.0.0/8").'''
        result = self._values.get("cidr")
        assert result is not None, "Required property 'cidr' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def first_ip(self) -> builtins.str:
        '''First usable IP address.'''
        result = self._values.get("first_ip")
        assert result is not None, "Required property 'first_ip' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def last_ip(self) -> builtins.str:
        '''Last usable IP address.'''
        result = self._values.get("last_ip")
        assert result is not None, "Required property 'last_ip' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def netmask(self) -> builtins.str:
        '''Network mask (e.g., "255.0.0.0").'''
        result = self._values.get("netmask")
        assert result is not None, "Required property 'netmask' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def network(self) -> builtins.str:
        '''Network address (e.g., "10.0.0.0").'''
        result = self._values.get("network")
        assert result is not None, "Required property 'network' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def prefix(self) -> jsii.Number:
        '''Prefix length (e.g., 8).'''
        result = self._values.get("prefix")
        assert result is not None, "Required property 'prefix' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def total_addresses(self) -> jsii.Number:
        '''Total number of addresses in the range.'''
        result = self._values.get("total_addresses")
        assert result is not None, "Required property 'total_addresses' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ParsedCidr(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.PeerReference",
    jsii_struct_bases=[],
    name_mapping={"id": "id"},
)
class PeerReference:
    def __init__(self, *, id: builtins.str) -> None:
        '''Reference to an ExpressRoute circuit peer.

        :param id: Resource ID of the ExpressRoute circuit.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9d29b5d22b446692fa2724fe1522567141dd9618138ab3814d1937144bb4ba5d)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "id": id,
        }

    @builtins.property
    def id(self) -> builtins.str:
        '''Resource ID of the ExpressRoute circuit.'''
        result = self._values.get("id")
        assert result is not None, "Required property 'id' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "PeerReference(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class PolicyAssignment(
    _AzapiResource_7e7f5b39,
    metaclass=jsii.JSIIMeta,
    jsii_type="@microsoft/terraform-cdk-constructs.PolicyAssignment",
):
    '''Unified Azure Policy Assignment implementation.

    This class provides a single, version-aware implementation for managing Azure
    Policy Assignments. It automatically handles version resolution, schema validation,
    and property transformation.

    Note: Policy assignments can be deployed at management group, subscription, resource group,
    or resource scope. Like policy definitions, they do not have a location property as they
    are not region-specific.

    Example::

        // Policy assignment at management group scope:
        const mgAssignment = new PolicyAssignment(this, "mgAssignment", {
          name: "mg-policy-assignment",
          policyDefinitionId: "/providers/Microsoft.Authorization/policyDefinitions/policy-id",
          scope: "/providers/Microsoft.Management/managementGroups/my-mg",
          displayName: "Management Group Policy",
          description: "Applies policy across the entire management group hierarchy"
        });
    '''

    def __init__(
        self,
        scope_: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        policy_definition_id: builtins.str,
        scope: builtins.str,
        description: typing.Optional[builtins.str] = None,
        display_name: typing.Optional[builtins.str] = None,
        enforcement_mode: typing.Optional[builtins.str] = None,
        identity: typing.Optional[typing.Union[_PolicyAssignmentIdentity_49ed2b2a, typing.Dict[builtins.str, typing.Any]]] = None,
        ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
        metadata: typing.Any = None,
        non_compliance_messages: typing.Optional[typing.Sequence[typing.Union[_PolicyAssignmentNonComplianceMessage_4bb37598, typing.Dict[builtins.str, typing.Any]]]] = None,
        not_scopes: typing.Optional[typing.Sequence[builtins.str]] = None,
        parameters: typing.Any = None,
        api_version: typing.Optional[builtins.str] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        location: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> None:
        '''Creates a new Azure Policy Assignment using the VersionedAzapiResource framework.

        The constructor automatically handles version resolution, schema registration,
        validation, and resource creation.

        :param scope_: - The scope in which to define this construct.
        :param id: - The unique identifier for this instance.
        :param policy_definition_id: The policy definition ID to assign This can be a built-in or custom policy definition Required property.
        :param scope: The scope at which the policy assignment is applied Can be a management group, subscription, resource group, or resource Required property.
        :param description: The policy assignment description Provides detailed information about the assignment.
        :param display_name: The display name of the policy assignment Provides a human-readable name for the assignment.
        :param enforcement_mode: The enforcement mode of the policy assignment. Default: "Default"
        :param identity: The managed identity associated with the policy assignment Required for policies with deployIfNotExists or modify effects.
        :param ignore_changes: The lifecycle rules to ignore changes.
        :param metadata: Metadata for the policy assignment Used to store additional information like assignedBy, parameterScopes, etc.
        :param non_compliance_messages: The non-compliance messages for the policy assignment Provides custom messages when resources are non-compliant.
        :param not_scopes: The policy's excluded scopes Resources within these scopes will not be evaluated by the policy.
        :param parameters: Parameters for the policy assignment Provides values for parameters defined in the policy definition.
        :param api_version: Explicit API version to use for this resource. If not specified, the latest active version will be automatically resolved. Use this for version pinning when stability is required over latest features. Default: Latest active version from ApiVersionManager
        :param enable_migration_analysis: Whether to enable migration analysis warnings. When true, the framework will analyze the current version for deprecation status and provide migration recommendations in the deployment output. Default: true
        :param enable_transformation: Whether to apply property transformations automatically. When true, properties will be automatically transformed according to the target schema's transformation rules. This enables backward compatibility. Default: true
        :param enable_validation: Whether to validate properties against the schema. When true, all properties will be validated against the API schema before resource creation. Validation errors will cause deployment failures. Default: true
        :param location: The location where the resource should be created. Default: Varies by resource type - see specific resource documentation
        :param monitoring: Monitoring configuration for this resource. Enables integrated monitoring with diagnostic settings, metric alerts, and activity log alerts. All monitoring is optional and disabled by default.
        :param name: The name of the resource.
        :param tags: Tags to apply to the resource.
        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d2c42c23bcbc9ee5023539b60474c1d15ea36bf325210ba5634a79227c065800)
            check_type(argname="argument scope_", value=scope_, expected_type=type_hints["scope_"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = _PolicyAssignmentProps_ed0fd29f(
            policy_definition_id=policy_definition_id,
            scope=scope,
            description=description,
            display_name=display_name,
            enforcement_mode=enforcement_mode,
            identity=identity,
            ignore_changes=ignore_changes,
            metadata=metadata,
            non_compliance_messages=non_compliance_messages,
            not_scopes=not_scopes,
            parameters=parameters,
            api_version=api_version,
            enable_migration_analysis=enable_migration_analysis,
            enable_transformation=enable_transformation,
            enable_validation=enable_validation,
            location=location,
            monitoring=monitoring,
            name=name,
            tags=tags,
            connection=connection,
            count=count,
            depends_on=depends_on,
            for_each=for_each,
            lifecycle=lifecycle,
            provider=provider,
            provisioners=provisioners,
        )

        jsii.create(self.__class__, self, [scope_, id, props])

    @jsii.member(jsii_name="apiSchema")
    def _api_schema(self) -> _ApiSchema_5ce0490e:
        '''Gets the API schema for the resolved version Uses the framework's schema resolution to get the appropriate schema.'''
        return typing.cast(_ApiSchema_5ce0490e, jsii.invoke(self, "apiSchema", []))

    @jsii.member(jsii_name="createResourceBody")
    def _create_resource_body(self, props: typing.Any) -> typing.Any:
        '''Creates the resource body for the Azure API call Transforms the input properties into the JSON format expected by Azure REST API  Note: Policy assignments do not have a location property as they are scoped resources (subscription, resource group, or resource level).

        The scope property is NOT included in the body as it's read-only and
        automatically derived from the parentId.

        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__12b64aaa6ce46755e3169e4949f798c3d165650d2fdc7f7108d783faab58fc5b)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Any, jsii.invoke(self, "createResourceBody", [props]))

    @jsii.member(jsii_name="defaultVersion")
    def _default_version(self) -> builtins.str:
        '''Gets the default API version to use when no explicit version is specified Returns the most recent stable version as the default.'''
        return typing.cast(builtins.str, jsii.invoke(self, "defaultVersion", []))

    @jsii.member(jsii_name="resolveParentId")
    def _resolve_parent_id(self, props: typing.Any) -> builtins.str:
        '''Overrides parent ID resolution to use the scope from props Policy assignments are scoped resources where the scope IS the parent.

        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d6282aa498497d261887eefab3bd960e4bca659f980dd28230cad0d2c7da0fd2)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(builtins.str, jsii.invoke(self, "resolveParentId", [props]))

    @jsii.member(jsii_name="resourceType")
    def _resource_type(self) -> builtins.str:
        '''Gets the Azure resource type for Policy Assignments.'''
        return typing.cast(builtins.str, jsii.invoke(self, "resourceType", []))

    @jsii.member(jsii_name="supportsTags")
    def _supports_tags(self) -> builtins.bool:
        '''Policy Assignments do not support tags at the resource level Tags are not a valid property for Microsoft.Authorization/policyAssignments.

        :return: false - Policy Assignments cannot have tags

        :override: true
        '''
        return typing.cast(builtins.bool, jsii.invoke(self, "supportsTags", []))

    @builtins.property
    @jsii.member(jsii_name="assignmentScope")
    def assignment_scope(self) -> builtins.str:
        '''Get the scope of this policy assignment.'''
        return typing.cast(builtins.str, jsii.get(self, "assignmentScope"))

    @builtins.property
    @jsii.member(jsii_name="enforcementMode")
    def enforcement_mode(self) -> builtins.str:
        '''Get the enforcement mode.'''
        return typing.cast(builtins.str, jsii.get(self, "enforcementMode"))

    @builtins.property
    @jsii.member(jsii_name="idOutput")
    def id_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "idOutput"))

    @builtins.property
    @jsii.member(jsii_name="nameOutput")
    def name_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "nameOutput"))

    @builtins.property
    @jsii.member(jsii_name="policyDefinitionId")
    def policy_definition_id(self) -> builtins.str:
        '''Get the policy definition ID this assignment references.'''
        return typing.cast(builtins.str, jsii.get(self, "policyDefinitionId"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def props(self) -> _PolicyAssignmentProps_ed0fd29f:
        '''The input properties for this Policy Assignment instance.'''
        return typing.cast(_PolicyAssignmentProps_ed0fd29f, jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="resourceId")
    def resource_id(self) -> builtins.str:
        '''Get the full resource identifier for use in other Azure resources Alias for the id property.'''
        return typing.cast(builtins.str, jsii.get(self, "resourceId"))


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.PolicyAssignmentBody",
    jsii_struct_bases=[],
    name_mapping={"properties": "properties", "identity": "identity"},
)
class PolicyAssignmentBody:
    def __init__(
        self,
        *,
        properties: typing.Union[_PolicyAssignmentProperties_59266900, typing.Dict[builtins.str, typing.Any]],
        identity: typing.Optional[typing.Union[_PolicyAssignmentIdentity_49ed2b2a, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''The resource body interface for Azure Policy Assignment API calls This matches the Azure REST API schema for policy assignments.

        :param properties: The properties of the policy assignment.
        :param identity: The managed identity associated with the policy assignment.
        '''
        if isinstance(properties, dict):
            properties = _PolicyAssignmentProperties_59266900(**properties)
        if isinstance(identity, dict):
            identity = _PolicyAssignmentIdentity_49ed2b2a(**identity)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fdba77223193d2e1d9223e95ce59ef33c0d47ee6c5a29b10f0bb56828243fbe4)
            check_type(argname="argument properties", value=properties, expected_type=type_hints["properties"])
            check_type(argname="argument identity", value=identity, expected_type=type_hints["identity"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "properties": properties,
        }
        if identity is not None:
            self._values["identity"] = identity

    @builtins.property
    def properties(self) -> _PolicyAssignmentProperties_59266900:
        '''The properties of the policy assignment.'''
        result = self._values.get("properties")
        assert result is not None, "Required property 'properties' is missing"
        return typing.cast(_PolicyAssignmentProperties_59266900, result)

    @builtins.property
    def identity(self) -> typing.Optional[_PolicyAssignmentIdentity_49ed2b2a]:
        '''The managed identity associated with the policy assignment.'''
        result = self._values.get("identity")
        return typing.cast(typing.Optional[_PolicyAssignmentIdentity_49ed2b2a], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "PolicyAssignmentBody(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.PolicyAssignmentIdentity",
    jsii_struct_bases=[],
    name_mapping={
        "type": "type",
        "user_assigned_identities": "userAssignedIdentities",
    },
)
class PolicyAssignmentIdentity:
    def __init__(
        self,
        *,
        type: builtins.str,
        user_assigned_identities: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    ) -> None:
        '''Identity configuration for policy assignments Required for policies with deployIfNotExists or modify effects.

        :param type: The type of managed identity.
        :param user_assigned_identities: The user assigned identities associated with the policy assignment Required when type is UserAssigned.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__109d90a74a83d552b8a5257ff586414ce5ec55656cc4a7d8509dc95f8e93f690)
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument user_assigned_identities", value=user_assigned_identities, expected_type=type_hints["user_assigned_identities"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "type": type,
        }
        if user_assigned_identities is not None:
            self._values["user_assigned_identities"] = user_assigned_identities

    @builtins.property
    def type(self) -> builtins.str:
        '''The type of managed identity.

        Example::

            "SystemAssigned", "UserAssigned", "None"
        '''
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def user_assigned_identities(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''The user assigned identities associated with the policy assignment Required when type is UserAssigned.

        Example::

            {
              "/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/rg/providers/Microsoft.ManagedIdentity/userAssignedIdentities/identity": {}
            }
        '''
        result = self._values.get("user_assigned_identities")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "PolicyAssignmentIdentity(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.PolicyAssignmentNonComplianceMessage",
    jsii_struct_bases=[],
    name_mapping={
        "message": "message",
        "policy_definition_reference_id": "policyDefinitionReferenceId",
    },
)
class PolicyAssignmentNonComplianceMessage:
    def __init__(
        self,
        *,
        message: builtins.str,
        policy_definition_reference_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Non-compliance message configuration.

        :param message: The non-compliance message for the policy assignment.
        :param policy_definition_reference_id: The policy definition reference ID within a policy set definition Optional - if specified, this message applies only to the specified policy within the set.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a9c104f18f37c530023b58be39530c64feccffd8b1b2a7413c3ccb44d60752a8)
            check_type(argname="argument message", value=message, expected_type=type_hints["message"])
            check_type(argname="argument policy_definition_reference_id", value=policy_definition_reference_id, expected_type=type_hints["policy_definition_reference_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "message": message,
        }
        if policy_definition_reference_id is not None:
            self._values["policy_definition_reference_id"] = policy_definition_reference_id

    @builtins.property
    def message(self) -> builtins.str:
        '''The non-compliance message for the policy assignment.'''
        result = self._values.get("message")
        assert result is not None, "Required property 'message' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def policy_definition_reference_id(self) -> typing.Optional[builtins.str]:
        '''The policy definition reference ID within a policy set definition Optional - if specified, this message applies only to the specified policy within the set.'''
        result = self._values.get("policy_definition_reference_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "PolicyAssignmentNonComplianceMessage(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.PolicyAssignmentProperties",
    jsii_struct_bases=[],
    name_mapping={
        "policy_definition_id": "policyDefinitionId",
        "scope": "scope",
        "description": "description",
        "display_name": "displayName",
        "enforcement_mode": "enforcementMode",
        "metadata": "metadata",
        "non_compliance_messages": "nonComplianceMessages",
        "not_scopes": "notScopes",
        "parameters": "parameters",
    },
)
class PolicyAssignmentProperties:
    def __init__(
        self,
        *,
        policy_definition_id: builtins.str,
        scope: builtins.str,
        description: typing.Optional[builtins.str] = None,
        display_name: typing.Optional[builtins.str] = None,
        enforcement_mode: typing.Optional[builtins.str] = None,
        metadata: typing.Any = None,
        non_compliance_messages: typing.Optional[typing.Sequence[typing.Union[_PolicyAssignmentNonComplianceMessage_4bb37598, typing.Dict[builtins.str, typing.Any]]]] = None,
        not_scopes: typing.Optional[typing.Sequence[builtins.str]] = None,
        parameters: typing.Any = None,
    ) -> None:
        '''Properties interface for Azure Policy Assignment This is required for JSII compliance to support multi-language code generation.

        :param policy_definition_id: The policy definition ID.
        :param scope: The scope of the policy assignment.
        :param description: The policy assignment description.
        :param display_name: The display name of the policy assignment.
        :param enforcement_mode: The enforcement mode.
        :param metadata: Metadata for the policy assignment.
        :param non_compliance_messages: The non-compliance messages.
        :param not_scopes: The policy's excluded scopes.
        :param parameters: Parameters for the policy assignment.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dabda0ef97df86973c1dfadd3274e121ffd5b01f2e09d9af829becfc8b50c1e8)
            check_type(argname="argument policy_definition_id", value=policy_definition_id, expected_type=type_hints["policy_definition_id"])
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument display_name", value=display_name, expected_type=type_hints["display_name"])
            check_type(argname="argument enforcement_mode", value=enforcement_mode, expected_type=type_hints["enforcement_mode"])
            check_type(argname="argument metadata", value=metadata, expected_type=type_hints["metadata"])
            check_type(argname="argument non_compliance_messages", value=non_compliance_messages, expected_type=type_hints["non_compliance_messages"])
            check_type(argname="argument not_scopes", value=not_scopes, expected_type=type_hints["not_scopes"])
            check_type(argname="argument parameters", value=parameters, expected_type=type_hints["parameters"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "policy_definition_id": policy_definition_id,
            "scope": scope,
        }
        if description is not None:
            self._values["description"] = description
        if display_name is not None:
            self._values["display_name"] = display_name
        if enforcement_mode is not None:
            self._values["enforcement_mode"] = enforcement_mode
        if metadata is not None:
            self._values["metadata"] = metadata
        if non_compliance_messages is not None:
            self._values["non_compliance_messages"] = non_compliance_messages
        if not_scopes is not None:
            self._values["not_scopes"] = not_scopes
        if parameters is not None:
            self._values["parameters"] = parameters

    @builtins.property
    def policy_definition_id(self) -> builtins.str:
        '''The policy definition ID.'''
        result = self._values.get("policy_definition_id")
        assert result is not None, "Required property 'policy_definition_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def scope(self) -> builtins.str:
        '''The scope of the policy assignment.'''
        result = self._values.get("scope")
        assert result is not None, "Required property 'scope' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''The policy assignment description.'''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def display_name(self) -> typing.Optional[builtins.str]:
        '''The display name of the policy assignment.'''
        result = self._values.get("display_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def enforcement_mode(self) -> typing.Optional[builtins.str]:
        '''The enforcement mode.'''
        result = self._values.get("enforcement_mode")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def metadata(self) -> typing.Any:
        '''Metadata for the policy assignment.'''
        result = self._values.get("metadata")
        return typing.cast(typing.Any, result)

    @builtins.property
    def non_compliance_messages(
        self,
    ) -> typing.Optional[typing.List[_PolicyAssignmentNonComplianceMessage_4bb37598]]:
        '''The non-compliance messages.'''
        result = self._values.get("non_compliance_messages")
        return typing.cast(typing.Optional[typing.List[_PolicyAssignmentNonComplianceMessage_4bb37598]], result)

    @builtins.property
    def not_scopes(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The policy's excluded scopes.'''
        result = self._values.get("not_scopes")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def parameters(self) -> typing.Any:
        '''Parameters for the policy assignment.'''
        result = self._values.get("parameters")
        return typing.cast(typing.Any, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "PolicyAssignmentProperties(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.PolicyAssignmentProps",
    jsii_struct_bases=[_AzapiResourceProps_141a2340],
    name_mapping={
        "connection": "connection",
        "count": "count",
        "depends_on": "dependsOn",
        "for_each": "forEach",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "provisioners": "provisioners",
        "api_version": "apiVersion",
        "enable_migration_analysis": "enableMigrationAnalysis",
        "enable_transformation": "enableTransformation",
        "enable_validation": "enableValidation",
        "location": "location",
        "monitoring": "monitoring",
        "name": "name",
        "tags": "tags",
        "policy_definition_id": "policyDefinitionId",
        "scope": "scope",
        "description": "description",
        "display_name": "displayName",
        "enforcement_mode": "enforcementMode",
        "identity": "identity",
        "ignore_changes": "ignoreChanges",
        "metadata": "metadata",
        "non_compliance_messages": "nonComplianceMessages",
        "not_scopes": "notScopes",
        "parameters": "parameters",
    },
)
class PolicyAssignmentProps(_AzapiResourceProps_141a2340):
    def __init__(
        self,
        *,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
        api_version: typing.Optional[builtins.str] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        location: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        policy_definition_id: builtins.str,
        scope: builtins.str,
        description: typing.Optional[builtins.str] = None,
        display_name: typing.Optional[builtins.str] = None,
        enforcement_mode: typing.Optional[builtins.str] = None,
        identity: typing.Optional[typing.Union[_PolicyAssignmentIdentity_49ed2b2a, typing.Dict[builtins.str, typing.Any]]] = None,
        ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
        metadata: typing.Any = None,
        non_compliance_messages: typing.Optional[typing.Sequence[typing.Union[_PolicyAssignmentNonComplianceMessage_4bb37598, typing.Dict[builtins.str, typing.Any]]]] = None,
        not_scopes: typing.Optional[typing.Sequence[builtins.str]] = None,
        parameters: typing.Any = None,
    ) -> None:
        '''Properties for the unified Azure Policy Assignment.

        Extends AzapiResourceProps with Policy Assignment specific properties

        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        :param api_version: Explicit API version to use for this resource. If not specified, the latest active version will be automatically resolved. Use this for version pinning when stability is required over latest features. Default: Latest active version from ApiVersionManager
        :param enable_migration_analysis: Whether to enable migration analysis warnings. When true, the framework will analyze the current version for deprecation status and provide migration recommendations in the deployment output. Default: true
        :param enable_transformation: Whether to apply property transformations automatically. When true, properties will be automatically transformed according to the target schema's transformation rules. This enables backward compatibility. Default: true
        :param enable_validation: Whether to validate properties against the schema. When true, all properties will be validated against the API schema before resource creation. Validation errors will cause deployment failures. Default: true
        :param location: The location where the resource should be created. Default: Varies by resource type - see specific resource documentation
        :param monitoring: Monitoring configuration for this resource. Enables integrated monitoring with diagnostic settings, metric alerts, and activity log alerts. All monitoring is optional and disabled by default.
        :param name: The name of the resource.
        :param tags: Tags to apply to the resource.
        :param policy_definition_id: The policy definition ID to assign This can be a built-in or custom policy definition Required property.
        :param scope: The scope at which the policy assignment is applied Can be a management group, subscription, resource group, or resource Required property.
        :param description: The policy assignment description Provides detailed information about the assignment.
        :param display_name: The display name of the policy assignment Provides a human-readable name for the assignment.
        :param enforcement_mode: The enforcement mode of the policy assignment. Default: "Default"
        :param identity: The managed identity associated with the policy assignment Required for policies with deployIfNotExists or modify effects.
        :param ignore_changes: The lifecycle rules to ignore changes.
        :param metadata: Metadata for the policy assignment Used to store additional information like assignedBy, parameterScopes, etc.
        :param non_compliance_messages: The non-compliance messages for the policy assignment Provides custom messages when resources are non-compliant.
        :param not_scopes: The policy's excluded scopes Resources within these scopes will not be evaluated by the policy.
        :param parameters: Parameters for the policy assignment Provides values for parameters defined in the policy definition.
        '''
        if isinstance(lifecycle, dict):
            lifecycle = _cdktf_9a9027ec.TerraformResourceLifecycle(**lifecycle)
        if isinstance(monitoring, dict):
            monitoring = _MonitoringConfig_7c28df74(**monitoring)
        if isinstance(identity, dict):
            identity = _PolicyAssignmentIdentity_49ed2b2a(**identity)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dd988acdedd9a8cf0053f138bc442108d5cdf6766d1585768dd76f59e385fa5b)
            check_type(argname="argument connection", value=connection, expected_type=type_hints["connection"])
            check_type(argname="argument count", value=count, expected_type=type_hints["count"])
            check_type(argname="argument depends_on", value=depends_on, expected_type=type_hints["depends_on"])
            check_type(argname="argument for_each", value=for_each, expected_type=type_hints["for_each"])
            check_type(argname="argument lifecycle", value=lifecycle, expected_type=type_hints["lifecycle"])
            check_type(argname="argument provider", value=provider, expected_type=type_hints["provider"])
            check_type(argname="argument provisioners", value=provisioners, expected_type=type_hints["provisioners"])
            check_type(argname="argument api_version", value=api_version, expected_type=type_hints["api_version"])
            check_type(argname="argument enable_migration_analysis", value=enable_migration_analysis, expected_type=type_hints["enable_migration_analysis"])
            check_type(argname="argument enable_transformation", value=enable_transformation, expected_type=type_hints["enable_transformation"])
            check_type(argname="argument enable_validation", value=enable_validation, expected_type=type_hints["enable_validation"])
            check_type(argname="argument location", value=location, expected_type=type_hints["location"])
            check_type(argname="argument monitoring", value=monitoring, expected_type=type_hints["monitoring"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument policy_definition_id", value=policy_definition_id, expected_type=type_hints["policy_definition_id"])
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument display_name", value=display_name, expected_type=type_hints["display_name"])
            check_type(argname="argument enforcement_mode", value=enforcement_mode, expected_type=type_hints["enforcement_mode"])
            check_type(argname="argument identity", value=identity, expected_type=type_hints["identity"])
            check_type(argname="argument ignore_changes", value=ignore_changes, expected_type=type_hints["ignore_changes"])
            check_type(argname="argument metadata", value=metadata, expected_type=type_hints["metadata"])
            check_type(argname="argument non_compliance_messages", value=non_compliance_messages, expected_type=type_hints["non_compliance_messages"])
            check_type(argname="argument not_scopes", value=not_scopes, expected_type=type_hints["not_scopes"])
            check_type(argname="argument parameters", value=parameters, expected_type=type_hints["parameters"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "policy_definition_id": policy_definition_id,
            "scope": scope,
        }
        if connection is not None:
            self._values["connection"] = connection
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if for_each is not None:
            self._values["for_each"] = for_each
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider
        if provisioners is not None:
            self._values["provisioners"] = provisioners
        if api_version is not None:
            self._values["api_version"] = api_version
        if enable_migration_analysis is not None:
            self._values["enable_migration_analysis"] = enable_migration_analysis
        if enable_transformation is not None:
            self._values["enable_transformation"] = enable_transformation
        if enable_validation is not None:
            self._values["enable_validation"] = enable_validation
        if location is not None:
            self._values["location"] = location
        if monitoring is not None:
            self._values["monitoring"] = monitoring
        if name is not None:
            self._values["name"] = name
        if tags is not None:
            self._values["tags"] = tags
        if description is not None:
            self._values["description"] = description
        if display_name is not None:
            self._values["display_name"] = display_name
        if enforcement_mode is not None:
            self._values["enforcement_mode"] = enforcement_mode
        if identity is not None:
            self._values["identity"] = identity
        if ignore_changes is not None:
            self._values["ignore_changes"] = ignore_changes
        if metadata is not None:
            self._values["metadata"] = metadata
        if non_compliance_messages is not None:
            self._values["non_compliance_messages"] = non_compliance_messages
        if not_scopes is not None:
            self._values["not_scopes"] = not_scopes
        if parameters is not None:
            self._values["parameters"] = parameters

    @builtins.property
    def connection(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("connection")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]], result)

    @builtins.property
    def count(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]], result)

    @builtins.property
    def depends_on(
        self,
    ) -> typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]], result)

    @builtins.property
    def for_each(self) -> typing.Optional[_cdktf_9a9027ec.ITerraformIterator]:
        '''
        :stability: experimental
        '''
        result = self._values.get("for_each")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.ITerraformIterator], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[_cdktf_9a9027ec.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformProvider], result)

    @builtins.property
    def provisioners(
        self,
    ) -> typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provisioners")
        return typing.cast(typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]], result)

    @builtins.property
    def api_version(self) -> typing.Optional[builtins.str]:
        '''Explicit API version to use for this resource.

        If not specified, the latest active version will be automatically resolved.
        Use this for version pinning when stability is required over latest features.

        :default: Latest active version from ApiVersionManager

        Example::

            "2024-11-01"
        '''
        result = self._values.get("api_version")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def enable_migration_analysis(self) -> typing.Optional[builtins.bool]:
        '''Whether to enable migration analysis warnings.

        When true, the framework will analyze the current version for deprecation
        status and provide migration recommendations in the deployment output.

        :default: true
        '''
        result = self._values.get("enable_migration_analysis")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_transformation(self) -> typing.Optional[builtins.bool]:
        '''Whether to apply property transformations automatically.

        When true, properties will be automatically transformed according to the
        target schema's transformation rules. This enables backward compatibility.

        :default: true
        '''
        result = self._values.get("enable_transformation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_validation(self) -> typing.Optional[builtins.bool]:
        '''Whether to validate properties against the schema.

        When true, all properties will be validated against the API schema before
        resource creation. Validation errors will cause deployment failures.

        :default: true
        '''
        result = self._values.get("enable_validation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def location(self) -> typing.Optional[builtins.str]:
        '''The location where the resource should be created.

        :default: Varies by resource type - see specific resource documentation

        :remarks:

        Location handling varies by resource type:

        - **Top-level resources**: Most require an explicit location (e.g., "eastus", "westus")
        - **Global resources**: Some use "global" as location (e.g., Private DNS Zones)
        - **Child resources**: Inherit location from parent and should NOT set this property

        Each resource type may provide its own default through the ``resolveLocation()`` method.
        If no location is specified and no default exists, resource creation may fail.

        Example::

            // Child resource (Subnet) - do not set location
            // location: undefined (inherited from parent Virtual Network)
        '''
        result = self._values.get("location")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def monitoring(self) -> typing.Optional[_MonitoringConfig_7c28df74]:
        '''Monitoring configuration for this resource.

        Enables integrated monitoring with diagnostic settings, metric alerts,
        and activity log alerts. All monitoring is optional and disabled by default.

        Example::

            monitoring: {
              enabled: true,
              diagnosticSettings: {
                workspaceId: logAnalytics.id,
                metrics: ['AllMetrics'],
                logs: ['AuditLogs']
              },
              metricAlerts: [{
                name: 'high-cpu-alert',
                severity: 2,
                scopes: [], // Automatically set to this resource
                criteria: { ... },
                actions: [{ actionGroupId: actionGroup.id }]
              }]
            }
        '''
        result = self._values.get("monitoring")
        return typing.cast(typing.Optional[_MonitoringConfig_7c28df74], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the resource.'''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Tags to apply to the resource.'''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def policy_definition_id(self) -> builtins.str:
        '''The policy definition ID to assign This can be a built-in or custom policy definition Required property.

        Example::

            "/providers/Microsoft.Authorization/policyDefinitions/06a78e20-9358-41c9-923c-fb736d382a4d" (built-in)
        '''
        result = self._values.get("policy_definition_id")
        assert result is not None, "Required property 'policy_definition_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def scope(self) -> builtins.str:
        '''The scope at which the policy assignment is applied Can be a management group, subscription, resource group, or resource Required property.

        Example::

            "/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/rg-name"
        '''
        result = self._values.get("scope")
        assert result is not None, "Required property 'scope' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''The policy assignment description Provides detailed information about the assignment.

        Example::

            "Enforces required tags on all resources in production environment"
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def display_name(self) -> typing.Optional[builtins.str]:
        '''The display name of the policy assignment Provides a human-readable name for the assignment.

        Example::

            "Require tag on resources in production"
        '''
        result = self._values.get("display_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def enforcement_mode(self) -> typing.Optional[builtins.str]:
        '''The enforcement mode of the policy assignment.

        :default: "Default"

        Example::

            "DoNotEnforce" - Policy effect is not enforced (audit only)
        '''
        result = self._values.get("enforcement_mode")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def identity(self) -> typing.Optional[_PolicyAssignmentIdentity_49ed2b2a]:
        '''The managed identity associated with the policy assignment Required for policies with deployIfNotExists or modify effects.

        Example::

            {
              type: "SystemAssigned"
            }
        '''
        result = self._values.get("identity")
        return typing.cast(typing.Optional[_PolicyAssignmentIdentity_49ed2b2a], result)

    @builtins.property
    def ignore_changes(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The lifecycle rules to ignore changes.

        Example::

            ["metadata"]
        '''
        result = self._values.get("ignore_changes")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def metadata(self) -> typing.Any:
        '''Metadata for the policy assignment Used to store additional information like assignedBy, parameterScopes, etc.

        Example::

            {
              assignedBy: "admin@example.com",
              parameterScopes: {}
            }
        '''
        result = self._values.get("metadata")
        return typing.cast(typing.Any, result)

    @builtins.property
    def non_compliance_messages(
        self,
    ) -> typing.Optional[typing.List[_PolicyAssignmentNonComplianceMessage_4bb37598]]:
        '''The non-compliance messages for the policy assignment Provides custom messages when resources are non-compliant.

        Example::

            [
              {
                message: "Resource must have the Environment tag"
              }
            ]
        '''
        result = self._values.get("non_compliance_messages")
        return typing.cast(typing.Optional[typing.List[_PolicyAssignmentNonComplianceMessage_4bb37598]], result)

    @builtins.property
    def not_scopes(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The policy's excluded scopes Resources within these scopes will not be evaluated by the policy.

        Example::

            ["/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/excluded-rg"]
        '''
        result = self._values.get("not_scopes")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def parameters(self) -> typing.Any:
        '''Parameters for the policy assignment Provides values for parameters defined in the policy definition.

        Example::

            {
              tagName: {
                value: "Environment"
              },
              tagValue: {
                value: "Production"
              }
            }
        '''
        result = self._values.get("parameters")
        return typing.cast(typing.Any, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "PolicyAssignmentProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class PolicyDefinition(
    _AzapiResource_7e7f5b39,
    metaclass=jsii.JSIIMeta,
    jsii_type="@microsoft/terraform-cdk-constructs.PolicyDefinition",
):
    '''Unified Azure Policy Definition implementation.

    This class provides a single, version-aware implementation for managing Azure
    Policy Definitions. It automatically handles version resolution, schema validation,
    and property transformation.

    Note: Policy definitions are deployed at subscription or management group scope.
    Unlike most Azure resources, they do not have a location property as they are
    not region-specific.

    Example::

        // Policy definition at management group scope:
        const mgPolicyDefinition = new PolicyDefinition(this, "mgPolicy", {
          name: "mg-require-tag-policy",
          parentId: "/providers/Microsoft.Management/managementGroups/my-mg",
          displayName: "Management Group Tag Policy",
          description: "Enforces tags across the management group hierarchy",
          policyRule: {
            if: {
              field: "tags['CostCenter']",
              exists: "false"
            },
            then: {
              effect: "deny"
            }
          }
        });
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        policy_rule: typing.Any,
        description: typing.Optional[builtins.str] = None,
        display_name: typing.Optional[builtins.str] = None,
        ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
        metadata: typing.Any = None,
        mode: typing.Optional[builtins.str] = None,
        parameters: typing.Any = None,
        parent_id: typing.Optional[builtins.str] = None,
        policy_type: typing.Optional[builtins.str] = None,
        api_version: typing.Optional[builtins.str] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        location: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> None:
        '''Creates a new Azure Policy Definition using the VersionedAzapiResource framework.

        The constructor automatically handles version resolution, schema registration,
        validation, and resource creation.

        :param scope: - The scope in which to define this construct.
        :param id: - The unique identifier for this instance.
        :param policy_rule: The policy rule as a JSON object Defines the if/then logic that determines policy enforcement This is required for all policy definitions.
        :param description: The policy definition description Provides detailed information about what the policy enforces.
        :param display_name: The display name of the policy definition Provides a human-readable name for the policy.
        :param ignore_changes: The lifecycle rules to ignore changes.
        :param metadata: Metadata for the policy definition Used to store additional information like category, version, etc.
        :param mode: The policy mode Determines which resource types will be evaluated. Default: "All"
        :param parameters: Parameters for the policy definition Allows policy assignments to provide values that are used in the policy rule.
        :param parent_id: The parent scope where the policy definition should be created Can be a management group or subscription scope If not specified, defaults to subscription scope. Default: Subscription scope (auto-detected from client config)
        :param policy_type: The type of policy definition. Default: "Custom"
        :param api_version: Explicit API version to use for this resource. If not specified, the latest active version will be automatically resolved. Use this for version pinning when stability is required over latest features. Default: Latest active version from ApiVersionManager
        :param enable_migration_analysis: Whether to enable migration analysis warnings. When true, the framework will analyze the current version for deprecation status and provide migration recommendations in the deployment output. Default: true
        :param enable_transformation: Whether to apply property transformations automatically. When true, properties will be automatically transformed according to the target schema's transformation rules. This enables backward compatibility. Default: true
        :param enable_validation: Whether to validate properties against the schema. When true, all properties will be validated against the API schema before resource creation. Validation errors will cause deployment failures. Default: true
        :param location: The location where the resource should be created. Default: Varies by resource type - see specific resource documentation
        :param monitoring: Monitoring configuration for this resource. Enables integrated monitoring with diagnostic settings, metric alerts, and activity log alerts. All monitoring is optional and disabled by default.
        :param name: The name of the resource.
        :param tags: Tags to apply to the resource.
        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__32ade476b8cbca4e3521fe6be3b2d3e62398ec6cb44fb5185a02406784ac0da0)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = _PolicyDefinitionProps_10bc74fd(
            policy_rule=policy_rule,
            description=description,
            display_name=display_name,
            ignore_changes=ignore_changes,
            metadata=metadata,
            mode=mode,
            parameters=parameters,
            parent_id=parent_id,
            policy_type=policy_type,
            api_version=api_version,
            enable_migration_analysis=enable_migration_analysis,
            enable_transformation=enable_transformation,
            enable_validation=enable_validation,
            location=location,
            monitoring=monitoring,
            name=name,
            tags=tags,
            connection=connection,
            count=count,
            depends_on=depends_on,
            for_each=for_each,
            lifecycle=lifecycle,
            provider=provider,
            provisioners=provisioners,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="apiSchema")
    def _api_schema(self) -> _ApiSchema_5ce0490e:
        '''Gets the API schema for the resolved version Uses the framework's schema resolution to get the appropriate schema.'''
        return typing.cast(_ApiSchema_5ce0490e, jsii.invoke(self, "apiSchema", []))

    @jsii.member(jsii_name="createResourceBody")
    def _create_resource_body(self, props: typing.Any) -> typing.Any:
        '''Creates the resource body for the Azure API call Transforms the input properties into the JSON format expected by Azure REST API.

        Note: Policy definitions do not have a location property as they are
        subscription or management group scoped resources.

        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__28fc303be9b2468d75f6bc0aca70dddeab372c0b98ce951df82d5c8a14e08ad3)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Any, jsii.invoke(self, "createResourceBody", [props]))

    @jsii.member(jsii_name="customizeResourceConfig")
    def _customize_resource_config(self, config: typing.Any) -> typing.Any:
        '''Customizes the AZAPI ResourceConfig for policy-specific requirements.

        Policy definitions require special handling because:

        1. They contain complex nested objects (ARM templates in DeployIfNotExists policies)
        2. They use Azure Policy expressions like [field()], [parameters()], [variables()]
           which are NOT Terraform interpolations but Azure-native expressions
        3. Schema validation may strip unknown properties from deeply nested structures

        :param config: - The base ResourceConfig.

        :return: Modified ResourceConfig with policy-specific settings

        :override: true
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a36d716d00273ea6a6af571a1c37fbb7d796ec85b026ce6ee72b0cd90e97bca0)
            check_type(argname="argument config", value=config, expected_type=type_hints["config"])
        return typing.cast(typing.Any, jsii.invoke(self, "customizeResourceConfig", [config]))

    @jsii.member(jsii_name="defaultVersion")
    def _default_version(self) -> builtins.str:
        '''Gets the default API version to use when no explicit version is specified Returns the most recent stable version as the default.'''
        return typing.cast(builtins.str, jsii.invoke(self, "defaultVersion", []))

    @jsii.member(jsii_name="resolveParentId")
    def _resolve_parent_id(self, props: typing.Any) -> builtins.str:
        '''Overrides parent ID resolution to use parentId from props if provided Policy definitions can be deployed at subscription or management group scope.

        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__578b265b90b8718a4c38a1538fd2c5c20601d7325814a578d432b92c44ab93aa)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(builtins.str, jsii.invoke(self, "resolveParentId", [props]))

    @jsii.member(jsii_name="resourceType")
    def _resource_type(self) -> builtins.str:
        '''Gets the Azure resource type for Policy Definitions.'''
        return typing.cast(builtins.str, jsii.invoke(self, "resourceType", []))

    @jsii.member(jsii_name="supportsTags")
    def _supports_tags(self) -> builtins.bool:
        '''Policy Definitions do not support tags at the resource level Tags are not a valid property for Microsoft.Authorization/policyDefinitions.

        :return: false - Policy Definitions cannot have tags

        :override: true
        '''
        return typing.cast(builtins.bool, jsii.invoke(self, "supportsTags", []))

    @builtins.property
    @jsii.member(jsii_name="idOutput")
    def id_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "idOutput"))

    @builtins.property
    @jsii.member(jsii_name="nameOutput")
    def name_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "nameOutput"))

    @builtins.property
    @jsii.member(jsii_name="policyMode")
    def policy_mode(self) -> builtins.str:
        '''Get the policy mode.'''
        return typing.cast(builtins.str, jsii.get(self, "policyMode"))

    @builtins.property
    @jsii.member(jsii_name="policyType")
    def policy_type(self) -> builtins.str:
        '''Get the policy type.'''
        return typing.cast(builtins.str, jsii.get(self, "policyType"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def props(self) -> _PolicyDefinitionProps_10bc74fd:
        '''The input properties for this Policy Definition instance.'''
        return typing.cast(_PolicyDefinitionProps_10bc74fd, jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="resourceId")
    def resource_id(self) -> builtins.str:
        '''Get the full resource identifier for use in other Azure resources Alias for the id property.'''
        return typing.cast(builtins.str, jsii.get(self, "resourceId"))


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.PolicyDefinitionBody",
    jsii_struct_bases=[],
    name_mapping={"properties": "properties"},
)
class PolicyDefinitionBody:
    def __init__(
        self,
        *,
        properties: typing.Union[_PolicyDefinitionProperties_ff703616, typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''The resource body interface for Azure Policy Definition API calls This matches the Azure REST API schema for policy definitions.

        :param properties: The properties of the policy definition.
        '''
        if isinstance(properties, dict):
            properties = _PolicyDefinitionProperties_ff703616(**properties)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cb92598a4c3a4da2786ee5794feea197a9e519cd7b198cd953c0dbef404e1fe1)
            check_type(argname="argument properties", value=properties, expected_type=type_hints["properties"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "properties": properties,
        }

    @builtins.property
    def properties(self) -> _PolicyDefinitionProperties_ff703616:
        '''The properties of the policy definition.'''
        result = self._values.get("properties")
        assert result is not None, "Required property 'properties' is missing"
        return typing.cast(_PolicyDefinitionProperties_ff703616, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "PolicyDefinitionBody(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.PolicyDefinitionProperties",
    jsii_struct_bases=[],
    name_mapping={
        "policy_rule": "policyRule",
        "description": "description",
        "display_name": "displayName",
        "metadata": "metadata",
        "mode": "mode",
        "parameters": "parameters",
        "policy_type": "policyType",
    },
)
class PolicyDefinitionProperties:
    def __init__(
        self,
        *,
        policy_rule: typing.Any,
        description: typing.Optional[builtins.str] = None,
        display_name: typing.Optional[builtins.str] = None,
        metadata: typing.Any = None,
        mode: typing.Optional[builtins.str] = None,
        parameters: typing.Any = None,
        policy_type: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties interface for Azure Policy Definition This is required for JSII compliance to support multi-language code generation.

        :param policy_rule: The policy rule object.
        :param description: The policy definition description.
        :param display_name: The display name of the policy definition.
        :param metadata: Metadata for the policy definition.
        :param mode: The policy mode.
        :param parameters: Parameters for the policy definition.
        :param policy_type: The type of policy definition.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6a8e37f6f9f9ffe4d95bca34f655f1baa69008b7ea89e26aee955ab54c582b62)
            check_type(argname="argument policy_rule", value=policy_rule, expected_type=type_hints["policy_rule"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument display_name", value=display_name, expected_type=type_hints["display_name"])
            check_type(argname="argument metadata", value=metadata, expected_type=type_hints["metadata"])
            check_type(argname="argument mode", value=mode, expected_type=type_hints["mode"])
            check_type(argname="argument parameters", value=parameters, expected_type=type_hints["parameters"])
            check_type(argname="argument policy_type", value=policy_type, expected_type=type_hints["policy_type"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "policy_rule": policy_rule,
        }
        if description is not None:
            self._values["description"] = description
        if display_name is not None:
            self._values["display_name"] = display_name
        if metadata is not None:
            self._values["metadata"] = metadata
        if mode is not None:
            self._values["mode"] = mode
        if parameters is not None:
            self._values["parameters"] = parameters
        if policy_type is not None:
            self._values["policy_type"] = policy_type

    @builtins.property
    def policy_rule(self) -> typing.Any:
        '''The policy rule object.'''
        result = self._values.get("policy_rule")
        assert result is not None, "Required property 'policy_rule' is missing"
        return typing.cast(typing.Any, result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''The policy definition description.'''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def display_name(self) -> typing.Optional[builtins.str]:
        '''The display name of the policy definition.'''
        result = self._values.get("display_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def metadata(self) -> typing.Any:
        '''Metadata for the policy definition.'''
        result = self._values.get("metadata")
        return typing.cast(typing.Any, result)

    @builtins.property
    def mode(self) -> typing.Optional[builtins.str]:
        '''The policy mode.'''
        result = self._values.get("mode")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def parameters(self) -> typing.Any:
        '''Parameters for the policy definition.'''
        result = self._values.get("parameters")
        return typing.cast(typing.Any, result)

    @builtins.property
    def policy_type(self) -> typing.Optional[builtins.str]:
        '''The type of policy definition.'''
        result = self._values.get("policy_type")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "PolicyDefinitionProperties(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.PolicyDefinitionProps",
    jsii_struct_bases=[_AzapiResourceProps_141a2340],
    name_mapping={
        "connection": "connection",
        "count": "count",
        "depends_on": "dependsOn",
        "for_each": "forEach",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "provisioners": "provisioners",
        "api_version": "apiVersion",
        "enable_migration_analysis": "enableMigrationAnalysis",
        "enable_transformation": "enableTransformation",
        "enable_validation": "enableValidation",
        "location": "location",
        "monitoring": "monitoring",
        "name": "name",
        "tags": "tags",
        "policy_rule": "policyRule",
        "description": "description",
        "display_name": "displayName",
        "ignore_changes": "ignoreChanges",
        "metadata": "metadata",
        "mode": "mode",
        "parameters": "parameters",
        "parent_id": "parentId",
        "policy_type": "policyType",
    },
)
class PolicyDefinitionProps(_AzapiResourceProps_141a2340):
    def __init__(
        self,
        *,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
        api_version: typing.Optional[builtins.str] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        location: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        policy_rule: typing.Any,
        description: typing.Optional[builtins.str] = None,
        display_name: typing.Optional[builtins.str] = None,
        ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
        metadata: typing.Any = None,
        mode: typing.Optional[builtins.str] = None,
        parameters: typing.Any = None,
        parent_id: typing.Optional[builtins.str] = None,
        policy_type: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for the unified Azure Policy Definition.

        Extends AzapiResourceProps with Policy Definition specific properties

        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        :param api_version: Explicit API version to use for this resource. If not specified, the latest active version will be automatically resolved. Use this for version pinning when stability is required over latest features. Default: Latest active version from ApiVersionManager
        :param enable_migration_analysis: Whether to enable migration analysis warnings. When true, the framework will analyze the current version for deprecation status and provide migration recommendations in the deployment output. Default: true
        :param enable_transformation: Whether to apply property transformations automatically. When true, properties will be automatically transformed according to the target schema's transformation rules. This enables backward compatibility. Default: true
        :param enable_validation: Whether to validate properties against the schema. When true, all properties will be validated against the API schema before resource creation. Validation errors will cause deployment failures. Default: true
        :param location: The location where the resource should be created. Default: Varies by resource type - see specific resource documentation
        :param monitoring: Monitoring configuration for this resource. Enables integrated monitoring with diagnostic settings, metric alerts, and activity log alerts. All monitoring is optional and disabled by default.
        :param name: The name of the resource.
        :param tags: Tags to apply to the resource.
        :param policy_rule: The policy rule as a JSON object Defines the if/then logic that determines policy enforcement This is required for all policy definitions.
        :param description: The policy definition description Provides detailed information about what the policy enforces.
        :param display_name: The display name of the policy definition Provides a human-readable name for the policy.
        :param ignore_changes: The lifecycle rules to ignore changes.
        :param metadata: Metadata for the policy definition Used to store additional information like category, version, etc.
        :param mode: The policy mode Determines which resource types will be evaluated. Default: "All"
        :param parameters: Parameters for the policy definition Allows policy assignments to provide values that are used in the policy rule.
        :param parent_id: The parent scope where the policy definition should be created Can be a management group or subscription scope If not specified, defaults to subscription scope. Default: Subscription scope (auto-detected from client config)
        :param policy_type: The type of policy definition. Default: "Custom"
        '''
        if isinstance(lifecycle, dict):
            lifecycle = _cdktf_9a9027ec.TerraformResourceLifecycle(**lifecycle)
        if isinstance(monitoring, dict):
            monitoring = _MonitoringConfig_7c28df74(**monitoring)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c41e2bcae5dca3227727f47f99543edcf6e042d4b4512da008f7559fed1d3eb0)
            check_type(argname="argument connection", value=connection, expected_type=type_hints["connection"])
            check_type(argname="argument count", value=count, expected_type=type_hints["count"])
            check_type(argname="argument depends_on", value=depends_on, expected_type=type_hints["depends_on"])
            check_type(argname="argument for_each", value=for_each, expected_type=type_hints["for_each"])
            check_type(argname="argument lifecycle", value=lifecycle, expected_type=type_hints["lifecycle"])
            check_type(argname="argument provider", value=provider, expected_type=type_hints["provider"])
            check_type(argname="argument provisioners", value=provisioners, expected_type=type_hints["provisioners"])
            check_type(argname="argument api_version", value=api_version, expected_type=type_hints["api_version"])
            check_type(argname="argument enable_migration_analysis", value=enable_migration_analysis, expected_type=type_hints["enable_migration_analysis"])
            check_type(argname="argument enable_transformation", value=enable_transformation, expected_type=type_hints["enable_transformation"])
            check_type(argname="argument enable_validation", value=enable_validation, expected_type=type_hints["enable_validation"])
            check_type(argname="argument location", value=location, expected_type=type_hints["location"])
            check_type(argname="argument monitoring", value=monitoring, expected_type=type_hints["monitoring"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument policy_rule", value=policy_rule, expected_type=type_hints["policy_rule"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument display_name", value=display_name, expected_type=type_hints["display_name"])
            check_type(argname="argument ignore_changes", value=ignore_changes, expected_type=type_hints["ignore_changes"])
            check_type(argname="argument metadata", value=metadata, expected_type=type_hints["metadata"])
            check_type(argname="argument mode", value=mode, expected_type=type_hints["mode"])
            check_type(argname="argument parameters", value=parameters, expected_type=type_hints["parameters"])
            check_type(argname="argument parent_id", value=parent_id, expected_type=type_hints["parent_id"])
            check_type(argname="argument policy_type", value=policy_type, expected_type=type_hints["policy_type"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "policy_rule": policy_rule,
        }
        if connection is not None:
            self._values["connection"] = connection
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if for_each is not None:
            self._values["for_each"] = for_each
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider
        if provisioners is not None:
            self._values["provisioners"] = provisioners
        if api_version is not None:
            self._values["api_version"] = api_version
        if enable_migration_analysis is not None:
            self._values["enable_migration_analysis"] = enable_migration_analysis
        if enable_transformation is not None:
            self._values["enable_transformation"] = enable_transformation
        if enable_validation is not None:
            self._values["enable_validation"] = enable_validation
        if location is not None:
            self._values["location"] = location
        if monitoring is not None:
            self._values["monitoring"] = monitoring
        if name is not None:
            self._values["name"] = name
        if tags is not None:
            self._values["tags"] = tags
        if description is not None:
            self._values["description"] = description
        if display_name is not None:
            self._values["display_name"] = display_name
        if ignore_changes is not None:
            self._values["ignore_changes"] = ignore_changes
        if metadata is not None:
            self._values["metadata"] = metadata
        if mode is not None:
            self._values["mode"] = mode
        if parameters is not None:
            self._values["parameters"] = parameters
        if parent_id is not None:
            self._values["parent_id"] = parent_id
        if policy_type is not None:
            self._values["policy_type"] = policy_type

    @builtins.property
    def connection(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("connection")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]], result)

    @builtins.property
    def count(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]], result)

    @builtins.property
    def depends_on(
        self,
    ) -> typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]], result)

    @builtins.property
    def for_each(self) -> typing.Optional[_cdktf_9a9027ec.ITerraformIterator]:
        '''
        :stability: experimental
        '''
        result = self._values.get("for_each")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.ITerraformIterator], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[_cdktf_9a9027ec.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformProvider], result)

    @builtins.property
    def provisioners(
        self,
    ) -> typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provisioners")
        return typing.cast(typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]], result)

    @builtins.property
    def api_version(self) -> typing.Optional[builtins.str]:
        '''Explicit API version to use for this resource.

        If not specified, the latest active version will be automatically resolved.
        Use this for version pinning when stability is required over latest features.

        :default: Latest active version from ApiVersionManager

        Example::

            "2024-11-01"
        '''
        result = self._values.get("api_version")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def enable_migration_analysis(self) -> typing.Optional[builtins.bool]:
        '''Whether to enable migration analysis warnings.

        When true, the framework will analyze the current version for deprecation
        status and provide migration recommendations in the deployment output.

        :default: true
        '''
        result = self._values.get("enable_migration_analysis")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_transformation(self) -> typing.Optional[builtins.bool]:
        '''Whether to apply property transformations automatically.

        When true, properties will be automatically transformed according to the
        target schema's transformation rules. This enables backward compatibility.

        :default: true
        '''
        result = self._values.get("enable_transformation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_validation(self) -> typing.Optional[builtins.bool]:
        '''Whether to validate properties against the schema.

        When true, all properties will be validated against the API schema before
        resource creation. Validation errors will cause deployment failures.

        :default: true
        '''
        result = self._values.get("enable_validation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def location(self) -> typing.Optional[builtins.str]:
        '''The location where the resource should be created.

        :default: Varies by resource type - see specific resource documentation

        :remarks:

        Location handling varies by resource type:

        - **Top-level resources**: Most require an explicit location (e.g., "eastus", "westus")
        - **Global resources**: Some use "global" as location (e.g., Private DNS Zones)
        - **Child resources**: Inherit location from parent and should NOT set this property

        Each resource type may provide its own default through the ``resolveLocation()`` method.
        If no location is specified and no default exists, resource creation may fail.

        Example::

            // Child resource (Subnet) - do not set location
            // location: undefined (inherited from parent Virtual Network)
        '''
        result = self._values.get("location")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def monitoring(self) -> typing.Optional[_MonitoringConfig_7c28df74]:
        '''Monitoring configuration for this resource.

        Enables integrated monitoring with diagnostic settings, metric alerts,
        and activity log alerts. All monitoring is optional and disabled by default.

        Example::

            monitoring: {
              enabled: true,
              diagnosticSettings: {
                workspaceId: logAnalytics.id,
                metrics: ['AllMetrics'],
                logs: ['AuditLogs']
              },
              metricAlerts: [{
                name: 'high-cpu-alert',
                severity: 2,
                scopes: [], // Automatically set to this resource
                criteria: { ... },
                actions: [{ actionGroupId: actionGroup.id }]
              }]
            }
        '''
        result = self._values.get("monitoring")
        return typing.cast(typing.Optional[_MonitoringConfig_7c28df74], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the resource.'''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Tags to apply to the resource.'''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def policy_rule(self) -> typing.Any:
        '''The policy rule as a JSON object Defines the if/then logic that determines policy enforcement This is required for all policy definitions.

        Example::

            {
              if: {
                field: "tags['Environment']",
                exists: "false"
              },
              then: {
                effect: "deny"
              }
            }
        '''
        result = self._values.get("policy_rule")
        assert result is not None, "Required property 'policy_rule' is missing"
        return typing.cast(typing.Any, result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''The policy definition description Provides detailed information about what the policy enforces.

        Example::

            "Enforces a required tag and its value on resources"
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def display_name(self) -> typing.Optional[builtins.str]:
        '''The display name of the policy definition Provides a human-readable name for the policy.

        Example::

            "Require tag and its value on resources"
        '''
        result = self._values.get("display_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ignore_changes(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The lifecycle rules to ignore changes.

        Example::

            ["metadata"]
        '''
        result = self._values.get("ignore_changes")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def metadata(self) -> typing.Any:
        '''Metadata for the policy definition Used to store additional information like category, version, etc.

        Example::

            {
              category: "Tags",
              version: "1.0.0"
            }
        '''
        result = self._values.get("metadata")
        return typing.cast(typing.Any, result)

    @builtins.property
    def mode(self) -> typing.Optional[builtins.str]:
        '''The policy mode Determines which resource types will be evaluated.

        :default: "All"

        Example::

            "All", "Indexed", "Microsoft.KeyVault.Data"
        '''
        result = self._values.get("mode")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def parameters(self) -> typing.Any:
        '''Parameters for the policy definition Allows policy assignments to provide values that are used in the policy rule.

        Example::

            {
              tagName: {
                type: "String",
                metadata: {
                  displayName: "Tag Name",
                  description: "Name of the tag to enforce"
                }
              }
            }
        '''
        result = self._values.get("parameters")
        return typing.cast(typing.Any, result)

    @builtins.property
    def parent_id(self) -> typing.Optional[builtins.str]:
        '''The parent scope where the policy definition should be created Can be a management group or subscription scope If not specified, defaults to subscription scope.

        :default: Subscription scope (auto-detected from client config)

        Example::

            "/subscriptions/00000000-0000-0000-0000-000000000000"
        '''
        result = self._values.get("parent_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def policy_type(self) -> typing.Optional[builtins.str]:
        '''The type of policy definition.

        :default: "Custom"

        Example::

            "Custom", "BuiltIn", "Static", "NotSpecified"
        '''
        result = self._values.get("policy_type")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "PolicyDefinitionProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class PrivateDnsZone(
    _AzapiResource_7e7f5b39,
    metaclass=jsii.JSIIMeta,
    jsii_type="@microsoft/terraform-cdk-constructs.PrivateDnsZone",
):
    '''Unified Azure Private DNS Zone implementation.

    This class provides a single, version-aware implementation that replaces all
    version-specific Private DNS Zone classes. It automatically handles version
    resolution, schema validation, and property transformation while maintaining
    full backward compatibility.

    Azure Private DNS Zones are used to provide internal DNS resolution within
    Azure virtual networks. They enable name resolution for resources within a
    virtual network without requiring custom DNS servers.

    Example::

        // Private DNS zone with explicit version pinning:
        const privateDnsZone = new PrivateDnsZone(this, "privateDns", {
          name: "internal.contoso.com",
          location: "global",
          resourceGroupId: resourceGroup.id,
          apiVersion: "2024-06-01",
        });
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
        resource_group_id: typing.Optional[builtins.str] = None,
        api_version: typing.Optional[builtins.str] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        location: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> None:
        '''Creates a new Azure Private DNS Zone using the VersionedAzapiResource framework.

        :param scope: - The scope in which to define this construct.
        :param id: - The unique identifier for this instance.
        :param ignore_changes: The lifecycle rules to ignore changes.
        :param resource_group_id: Resource group ID where the Private DNS Zone will be created.
        :param api_version: Explicit API version to use for this resource. If not specified, the latest active version will be automatically resolved. Use this for version pinning when stability is required over latest features. Default: Latest active version from ApiVersionManager
        :param enable_migration_analysis: Whether to enable migration analysis warnings. When true, the framework will analyze the current version for deprecation status and provide migration recommendations in the deployment output. Default: true
        :param enable_transformation: Whether to apply property transformations automatically. When true, properties will be automatically transformed according to the target schema's transformation rules. This enables backward compatibility. Default: true
        :param enable_validation: Whether to validate properties against the schema. When true, all properties will be validated against the API schema before resource creation. Validation errors will cause deployment failures. Default: true
        :param location: The location where the resource should be created. Default: Varies by resource type - see specific resource documentation
        :param monitoring: Monitoring configuration for this resource. Enables integrated monitoring with diagnostic settings, metric alerts, and activity log alerts. All monitoring is optional and disabled by default.
        :param name: The name of the resource.
        :param tags: Tags to apply to the resource.
        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4013cecceffa70445b14fca8b752d2c9e8bb35c494e18c319538c87d152d14c7)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = _PrivateDnsZoneProps_5abbb1b8(
            ignore_changes=ignore_changes,
            resource_group_id=resource_group_id,
            api_version=api_version,
            enable_migration_analysis=enable_migration_analysis,
            enable_transformation=enable_transformation,
            enable_validation=enable_validation,
            location=location,
            monitoring=monitoring,
            name=name,
            tags=tags,
            connection=connection,
            count=count,
            depends_on=depends_on,
            for_each=for_each,
            lifecycle=lifecycle,
            provider=provider,
            provisioners=provisioners,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="addTag")
    def add_tag(self, key: builtins.str, value: builtins.str) -> None:
        '''Add a tag to the Private DNS Zone.

        :param key: -
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9a728271ad9b694e0d4b8fbb9c51912380fb962a640239a39bae0ae09a8841e2)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "addTag", [key, value]))

    @jsii.member(jsii_name="apiSchema")
    def _api_schema(self) -> _ApiSchema_5ce0490e:
        '''Gets the API schema for the resolved version.'''
        return typing.cast(_ApiSchema_5ce0490e, jsii.invoke(self, "apiSchema", []))

    @jsii.member(jsii_name="createResourceBody")
    def _create_resource_body(self, _props: typing.Any) -> typing.Any:
        '''Creates the resource body for the Azure API call.

        :param _props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0080d271dc9afbec1bb324c2846d504d192e35a1343b5085e1734d72d27dbb85)
            check_type(argname="argument _props", value=_props, expected_type=type_hints["_props"])
        return typing.cast(typing.Any, jsii.invoke(self, "createResourceBody", [_props]))

    @jsii.member(jsii_name="defaultLocation")
    def _default_location(self) -> builtins.str:
        '''Provides default location for Private DNS Zones (global resource).'''
        return typing.cast(builtins.str, jsii.invoke(self, "defaultLocation", []))

    @jsii.member(jsii_name="defaultVersion")
    def _default_version(self) -> builtins.str:
        '''Gets the default API version to use when no explicit version is specified.'''
        return typing.cast(builtins.str, jsii.invoke(self, "defaultVersion", []))

    @jsii.member(jsii_name="removeTag")
    def remove_tag(self, key: builtins.str) -> None:
        '''Remove a tag from the Private DNS Zone.

        :param key: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b167befb596349c9185e561940fb1281e5a0078f1303e2fb09a3c2dada18a38d)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
        return typing.cast(None, jsii.invoke(self, "removeTag", [key]))

    @jsii.member(jsii_name="resourceType")
    def _resource_type(self) -> builtins.str:
        '''Gets the Azure resource type for Private DNS Zones.'''
        return typing.cast(builtins.str, jsii.invoke(self, "resourceType", []))

    @builtins.property
    @jsii.member(jsii_name="idOutput")
    def id_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "idOutput"))

    @builtins.property
    @jsii.member(jsii_name="internalId")
    def internal_id(self) -> builtins.str:
        '''Get the internal identifier for the Private DNS zone.'''
        return typing.cast(builtins.str, jsii.get(self, "internalId"))

    @builtins.property
    @jsii.member(jsii_name="internalIdOutput")
    def internal_id_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "internalIdOutput"))

    @builtins.property
    @jsii.member(jsii_name="locationOutput")
    def location_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "locationOutput"))

    @builtins.property
    @jsii.member(jsii_name="maxNumberOfRecordSets")
    def max_number_of_record_sets(self) -> builtins.str:
        '''Get the maximum number of record sets that can be created in this Private DNS zone.'''
        return typing.cast(builtins.str, jsii.get(self, "maxNumberOfRecordSets"))

    @builtins.property
    @jsii.member(jsii_name="maxNumberOfRecordSetsOutput")
    def max_number_of_record_sets_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "maxNumberOfRecordSetsOutput"))

    @builtins.property
    @jsii.member(jsii_name="maxNumberOfVirtualNetworkLinks")
    def max_number_of_virtual_network_links(self) -> builtins.str:
        '''Get the maximum number of virtual network links that can be created in this Private DNS zone.'''
        return typing.cast(builtins.str, jsii.get(self, "maxNumberOfVirtualNetworkLinks"))

    @builtins.property
    @jsii.member(jsii_name="maxNumberOfVirtualNetworkLinksOutput")
    def max_number_of_virtual_network_links_output(
        self,
    ) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "maxNumberOfVirtualNetworkLinksOutput"))

    @builtins.property
    @jsii.member(jsii_name="maxNumberOfVirtualNetworkLinksWithRegistration")
    def max_number_of_virtual_network_links_with_registration(self) -> builtins.str:
        '''Get the maximum number of virtual network links with auto-registration that can be created in this Private DNS zone.'''
        return typing.cast(builtins.str, jsii.get(self, "maxNumberOfVirtualNetworkLinksWithRegistration"))

    @builtins.property
    @jsii.member(jsii_name="maxNumberOfVirtualNetworkLinksWithRegistrationOutput")
    def max_number_of_virtual_network_links_with_registration_output(
        self,
    ) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "maxNumberOfVirtualNetworkLinksWithRegistrationOutput"))

    @builtins.property
    @jsii.member(jsii_name="nameOutput")
    def name_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "nameOutput"))

    @builtins.property
    @jsii.member(jsii_name="numberOfRecordSets")
    def number_of_record_sets(self) -> builtins.str:
        '''Get the current number of record sets in this Private DNS zone.'''
        return typing.cast(builtins.str, jsii.get(self, "numberOfRecordSets"))

    @builtins.property
    @jsii.member(jsii_name="numberOfRecordSetsOutput")
    def number_of_record_sets_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "numberOfRecordSetsOutput"))

    @builtins.property
    @jsii.member(jsii_name="numberOfVirtualNetworkLinksWithRegistration")
    def number_of_virtual_network_links_with_registration(self) -> builtins.str:
        '''Get the current number of virtual network links with auto-registration in this Private DNS zone.'''
        return typing.cast(builtins.str, jsii.get(self, "numberOfVirtualNetworkLinksWithRegistration"))

    @builtins.property
    @jsii.member(jsii_name="numberOfVirtualNetworkLinksWithRegistrationOutput")
    def number_of_virtual_network_links_with_registration_output(
        self,
    ) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "numberOfVirtualNetworkLinksWithRegistrationOutput"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def props(self) -> _PrivateDnsZoneProps_5abbb1b8:
        return typing.cast(_PrivateDnsZoneProps_5abbb1b8, jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        '''Get the provisioning state of the Private DNS zone.'''
        return typing.cast(builtins.str, jsii.get(self, "provisioningState"))

    @builtins.property
    @jsii.member(jsii_name="provisioningStateOutput")
    def provisioning_state_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "provisioningStateOutput"))

    @builtins.property
    @jsii.member(jsii_name="tagsOutput")
    def tags_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "tagsOutput"))


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.PrivateDnsZoneBody",
    jsii_struct_bases=[],
    name_mapping={"location": "location", "properties": "properties", "tags": "tags"},
)
class PrivateDnsZoneBody:
    def __init__(
        self,
        *,
        location: builtins.str,
        properties: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''The resource body interface for Azure Private DNS Zone API calls This matches the Azure REST API schema.

        :param location: 
        :param properties: 
        :param tags: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f5a9467ea61b11537f191c80338e19a8e1f4977cf24b8483e2b7efd098ac1228)
            check_type(argname="argument location", value=location, expected_type=type_hints["location"])
            check_type(argname="argument properties", value=properties, expected_type=type_hints["properties"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "location": location,
        }
        if properties is not None:
            self._values["properties"] = properties
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def location(self) -> builtins.str:
        result = self._values.get("location")
        assert result is not None, "Required property 'location' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def properties(self) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        result = self._values.get("properties")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "PrivateDnsZoneBody(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class PrivateDnsZoneLink(
    _AzapiResource_7e7f5b39,
    metaclass=jsii.JSIIMeta,
    jsii_type="@microsoft/terraform-cdk-constructs.PrivateDnsZoneLink",
):
    '''Azure Private DNS Zone Virtual Network Link implementation.

    Virtual Network Links connect private DNS zones to virtual networks, enabling DNS
    resolution from those VNets. They support auto-registration of VM DNS records and
    configurable resolution policies.

    Example::

        // Virtual network link with resolution policy:
        const link = new PrivateDnsZoneLink(this, "vnet-link", {
          name: "my-vnet-link",
          privateDnsZoneId: privateDnsZone.id,
          virtualNetworkId: vnet.id,
          resolutionPolicy: "NxDomainRedirect",
          location: "global",
          apiVersion: "2024-06-01"
        });
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        private_dns_zone_id: builtins.str,
        virtual_network_id: builtins.str,
        ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
        registration_enabled: typing.Optional[builtins.bool] = None,
        resolution_policy: typing.Optional[builtins.str] = None,
        api_version: typing.Optional[builtins.str] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        location: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> None:
        '''Creates a new Azure Private DNS Zone Virtual Network Link using the AzapiResource framework.

        :param scope: - The scope in which to define this construct.
        :param id: - The unique identifier for this instance.
        :param private_dns_zone_id: Resource ID of the parent Private DNS Zone.
        :param virtual_network_id: Resource ID of the Virtual Network to link.
        :param ignore_changes: The lifecycle rules to ignore changes.
        :param registration_enabled: Whether auto-registration of virtual machine records is enabled When enabled, VMs in the VNet will automatically register DNS records. Default: false
        :param resolution_policy: The resolution policy for the virtual network link Only applicable to Private Link zones (zones containing "privatelink." in the name) - "Default": Standard DNS resolution - "NxDomainRedirect": Fallback to Azure DNS for unresolved queries Note: This property will be silently ignored if the zone is not a Private Link zone.
        :param api_version: Explicit API version to use for this resource. If not specified, the latest active version will be automatically resolved. Use this for version pinning when stability is required over latest features. Default: Latest active version from ApiVersionManager
        :param enable_migration_analysis: Whether to enable migration analysis warnings. When true, the framework will analyze the current version for deprecation status and provide migration recommendations in the deployment output. Default: true
        :param enable_transformation: Whether to apply property transformations automatically. When true, properties will be automatically transformed according to the target schema's transformation rules. This enables backward compatibility. Default: true
        :param enable_validation: Whether to validate properties against the schema. When true, all properties will be validated against the API schema before resource creation. Validation errors will cause deployment failures. Default: true
        :param location: The location where the resource should be created. Default: Varies by resource type - see specific resource documentation
        :param monitoring: Monitoring configuration for this resource. Enables integrated monitoring with diagnostic settings, metric alerts, and activity log alerts. All monitoring is optional and disabled by default.
        :param name: The name of the resource.
        :param tags: Tags to apply to the resource.
        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e7aa756fabc10aa58ef6c698b5771137128eebce78265cdc5f69aa3df6d95a7e)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = PrivateDnsZoneLinkProps(
            private_dns_zone_id=private_dns_zone_id,
            virtual_network_id=virtual_network_id,
            ignore_changes=ignore_changes,
            registration_enabled=registration_enabled,
            resolution_policy=resolution_policy,
            api_version=api_version,
            enable_migration_analysis=enable_migration_analysis,
            enable_transformation=enable_transformation,
            enable_validation=enable_validation,
            location=location,
            monitoring=monitoring,
            name=name,
            tags=tags,
            connection=connection,
            count=count,
            depends_on=depends_on,
            for_each=for_each,
            lifecycle=lifecycle,
            provider=provider,
            provisioners=provisioners,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="addTag")
    def add_tag(self, key: builtins.str, value: builtins.str) -> None:
        '''Add a tag to the Virtual Network Link.

        :param key: -
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4e5e51efdf3fbac039f07b212e78c8da76b14e015113625649b8a380dfea20e6)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "addTag", [key, value]))

    @jsii.member(jsii_name="apiSchema")
    def _api_schema(self) -> _ApiSchema_5ce0490e:
        '''Gets the API schema for the resolved version.'''
        return typing.cast(_ApiSchema_5ce0490e, jsii.invoke(self, "apiSchema", []))

    @jsii.member(jsii_name="createResourceBody")
    def _create_resource_body(self, props: typing.Any) -> typing.Any:
        '''Creates the resource body for the Azure API call.

        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__938e3b1fe4fd201d4656757b4eb5bffd0cd81d19903c10bc155060f05801bd16)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Any, jsii.invoke(self, "createResourceBody", [props]))

    @jsii.member(jsii_name="defaultLocation")
    def _default_location(self) -> builtins.str:
        '''Gets the default location for this resource type Private DNS Zone Links use "global" location.'''
        return typing.cast(builtins.str, jsii.invoke(self, "defaultLocation", []))

    @jsii.member(jsii_name="defaultVersion")
    def _default_version(self) -> builtins.str:
        '''Gets the default API version to use when no explicit version is specified.'''
        return typing.cast(builtins.str, jsii.invoke(self, "defaultVersion", []))

    @jsii.member(jsii_name="removeTag")
    def remove_tag(self, key: builtins.str) -> None:
        '''Remove a tag from the Virtual Network Link.

        :param key: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2e2ed6576e2c99737a1c83d4591c959829cb9be95e10f11d9c85bf339d5e6579)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
        return typing.cast(None, jsii.invoke(self, "removeTag", [key]))

    @jsii.member(jsii_name="resolveParentId")
    def _resolve_parent_id(self, props: typing.Any) -> builtins.str:
        '''Resolves the parent resource ID for the Virtual Network Link Virtual Network Links are child resources of Private DNS Zones.

        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__13099f2d8ec8969e3ce0bb5ae9ea9c77bda03bd4b145e03a2b47aacbcaf29c22)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(builtins.str, jsii.invoke(self, "resolveParentId", [props]))

    @jsii.member(jsii_name="resourceType")
    def _resource_type(self) -> builtins.str:
        '''Gets the Azure resource type for Virtual Network Links.'''
        return typing.cast(builtins.str, jsii.invoke(self, "resourceType", []))

    @builtins.property
    @jsii.member(jsii_name="idOutput")
    def id_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "idOutput"))

    @builtins.property
    @jsii.member(jsii_name="locationOutput")
    def location_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "locationOutput"))

    @builtins.property
    @jsii.member(jsii_name="nameOutput")
    def name_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "nameOutput"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def props(self) -> "PrivateDnsZoneLinkProps":
        '''The input properties for this Virtual Network Link instance.'''
        return typing.cast("PrivateDnsZoneLinkProps", jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        '''Get the provisioning state of the Virtual Network Link.'''
        return typing.cast(builtins.str, jsii.get(self, "provisioningState"))

    @builtins.property
    @jsii.member(jsii_name="provisioningStateOutput")
    def provisioning_state_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "provisioningStateOutput"))

    @builtins.property
    @jsii.member(jsii_name="registrationEnabled")
    def registration_enabled(self) -> builtins.str:
        '''Get whether auto-registration is enabled Returns a Terraform interpolation string for JSII compliance.'''
        return typing.cast(builtins.str, jsii.get(self, "registrationEnabled"))

    @builtins.property
    @jsii.member(jsii_name="resolutionPolicy")
    def resolution_policy(self) -> builtins.str:
        '''Get the resolution policy Returns a Terraform interpolation string for JSII compliance.'''
        return typing.cast(builtins.str, jsii.get(self, "resolutionPolicy"))

    @builtins.property
    @jsii.member(jsii_name="virtualNetworkId")
    def virtual_network_id(self) -> builtins.str:
        '''Get the Virtual Network ID Note: This returns the input value as Azure API doesn't return it in output.'''
        return typing.cast(builtins.str, jsii.get(self, "virtualNetworkId"))

    @builtins.property
    @jsii.member(jsii_name="virtualNetworkLinkState")
    def virtual_network_link_state(self) -> builtins.str:
        '''Get the state of the Virtual Network Link.'''
        return typing.cast(builtins.str, jsii.get(self, "virtualNetworkLinkState"))

    @builtins.property
    @jsii.member(jsii_name="virtualNetworkLinkStateOutput")
    def virtual_network_link_state_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "virtualNetworkLinkStateOutput"))


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.PrivateDnsZoneLinkBody",
    jsii_struct_bases=[],
    name_mapping={"location": "location", "properties": "properties", "tags": "tags"},
)
class PrivateDnsZoneLinkBody:
    def __init__(
        self,
        *,
        location: builtins.str,
        properties: typing.Union["PrivateDnsZoneLinkProperties", typing.Dict[builtins.str, typing.Any]],
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''The resource body interface for Azure Virtual Network Link API calls.

        :param location: 
        :param properties: 
        :param tags: 
        '''
        if isinstance(properties, dict):
            properties = PrivateDnsZoneLinkProperties(**properties)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9e1e4fb69313e6a29250b410cfe9cdc2e9734ce777de0970c1f0b9aa951bcf50)
            check_type(argname="argument location", value=location, expected_type=type_hints["location"])
            check_type(argname="argument properties", value=properties, expected_type=type_hints["properties"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "location": location,
            "properties": properties,
        }
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def location(self) -> builtins.str:
        result = self._values.get("location")
        assert result is not None, "Required property 'location' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def properties(self) -> "PrivateDnsZoneLinkProperties":
        result = self._values.get("properties")
        assert result is not None, "Required property 'properties' is missing"
        return typing.cast("PrivateDnsZoneLinkProperties", result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "PrivateDnsZoneLinkBody(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.PrivateDnsZoneLinkProperties",
    jsii_struct_bases=[],
    name_mapping={
        "virtual_network": "virtualNetwork",
        "registration_enabled": "registrationEnabled",
        "resolution_policy": "resolutionPolicy",
    },
)
class PrivateDnsZoneLinkProperties:
    def __init__(
        self,
        *,
        virtual_network: typing.Union["PrivateDnsZoneLinkVirtualNetworkReference", typing.Dict[builtins.str, typing.Any]],
        registration_enabled: typing.Optional[builtins.bool] = None,
        resolution_policy: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for Virtual Network Link body.

        :param virtual_network: 
        :param registration_enabled: 
        :param resolution_policy: 
        '''
        if isinstance(virtual_network, dict):
            virtual_network = PrivateDnsZoneLinkVirtualNetworkReference(**virtual_network)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b40c534580ec6eb1a7635d235939cc577bef47f66037fb95c665189cd6ee66f5)
            check_type(argname="argument virtual_network", value=virtual_network, expected_type=type_hints["virtual_network"])
            check_type(argname="argument registration_enabled", value=registration_enabled, expected_type=type_hints["registration_enabled"])
            check_type(argname="argument resolution_policy", value=resolution_policy, expected_type=type_hints["resolution_policy"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "virtual_network": virtual_network,
        }
        if registration_enabled is not None:
            self._values["registration_enabled"] = registration_enabled
        if resolution_policy is not None:
            self._values["resolution_policy"] = resolution_policy

    @builtins.property
    def virtual_network(self) -> "PrivateDnsZoneLinkVirtualNetworkReference":
        result = self._values.get("virtual_network")
        assert result is not None, "Required property 'virtual_network' is missing"
        return typing.cast("PrivateDnsZoneLinkVirtualNetworkReference", result)

    @builtins.property
    def registration_enabled(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("registration_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def resolution_policy(self) -> typing.Optional[builtins.str]:
        result = self._values.get("resolution_policy")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "PrivateDnsZoneLinkProperties(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.PrivateDnsZoneLinkProps",
    jsii_struct_bases=[_AzapiResourceProps_141a2340],
    name_mapping={
        "connection": "connection",
        "count": "count",
        "depends_on": "dependsOn",
        "for_each": "forEach",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "provisioners": "provisioners",
        "api_version": "apiVersion",
        "enable_migration_analysis": "enableMigrationAnalysis",
        "enable_transformation": "enableTransformation",
        "enable_validation": "enableValidation",
        "location": "location",
        "monitoring": "monitoring",
        "name": "name",
        "tags": "tags",
        "private_dns_zone_id": "privateDnsZoneId",
        "virtual_network_id": "virtualNetworkId",
        "ignore_changes": "ignoreChanges",
        "registration_enabled": "registrationEnabled",
        "resolution_policy": "resolutionPolicy",
    },
)
class PrivateDnsZoneLinkProps(_AzapiResourceProps_141a2340):
    def __init__(
        self,
        *,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
        api_version: typing.Optional[builtins.str] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        location: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        private_dns_zone_id: builtins.str,
        virtual_network_id: builtins.str,
        ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
        registration_enabled: typing.Optional[builtins.bool] = None,
        resolution_policy: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for the Azure Private DNS Zone Virtual Network Link.

        Extends AzapiResourceProps with Virtual Network Link specific properties

        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        :param api_version: Explicit API version to use for this resource. If not specified, the latest active version will be automatically resolved. Use this for version pinning when stability is required over latest features. Default: Latest active version from ApiVersionManager
        :param enable_migration_analysis: Whether to enable migration analysis warnings. When true, the framework will analyze the current version for deprecation status and provide migration recommendations in the deployment output. Default: true
        :param enable_transformation: Whether to apply property transformations automatically. When true, properties will be automatically transformed according to the target schema's transformation rules. This enables backward compatibility. Default: true
        :param enable_validation: Whether to validate properties against the schema. When true, all properties will be validated against the API schema before resource creation. Validation errors will cause deployment failures. Default: true
        :param location: The location where the resource should be created. Default: Varies by resource type - see specific resource documentation
        :param monitoring: Monitoring configuration for this resource. Enables integrated monitoring with diagnostic settings, metric alerts, and activity log alerts. All monitoring is optional and disabled by default.
        :param name: The name of the resource.
        :param tags: Tags to apply to the resource.
        :param private_dns_zone_id: Resource ID of the parent Private DNS Zone.
        :param virtual_network_id: Resource ID of the Virtual Network to link.
        :param ignore_changes: The lifecycle rules to ignore changes.
        :param registration_enabled: Whether auto-registration of virtual machine records is enabled When enabled, VMs in the VNet will automatically register DNS records. Default: false
        :param resolution_policy: The resolution policy for the virtual network link Only applicable to Private Link zones (zones containing "privatelink." in the name) - "Default": Standard DNS resolution - "NxDomainRedirect": Fallback to Azure DNS for unresolved queries Note: This property will be silently ignored if the zone is not a Private Link zone.
        '''
        if isinstance(lifecycle, dict):
            lifecycle = _cdktf_9a9027ec.TerraformResourceLifecycle(**lifecycle)
        if isinstance(monitoring, dict):
            monitoring = _MonitoringConfig_7c28df74(**monitoring)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9a565bde41e348de491415272aa1d9cfabc2b63d5e329dc223ca41fd63da6c84)
            check_type(argname="argument connection", value=connection, expected_type=type_hints["connection"])
            check_type(argname="argument count", value=count, expected_type=type_hints["count"])
            check_type(argname="argument depends_on", value=depends_on, expected_type=type_hints["depends_on"])
            check_type(argname="argument for_each", value=for_each, expected_type=type_hints["for_each"])
            check_type(argname="argument lifecycle", value=lifecycle, expected_type=type_hints["lifecycle"])
            check_type(argname="argument provider", value=provider, expected_type=type_hints["provider"])
            check_type(argname="argument provisioners", value=provisioners, expected_type=type_hints["provisioners"])
            check_type(argname="argument api_version", value=api_version, expected_type=type_hints["api_version"])
            check_type(argname="argument enable_migration_analysis", value=enable_migration_analysis, expected_type=type_hints["enable_migration_analysis"])
            check_type(argname="argument enable_transformation", value=enable_transformation, expected_type=type_hints["enable_transformation"])
            check_type(argname="argument enable_validation", value=enable_validation, expected_type=type_hints["enable_validation"])
            check_type(argname="argument location", value=location, expected_type=type_hints["location"])
            check_type(argname="argument monitoring", value=monitoring, expected_type=type_hints["monitoring"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument private_dns_zone_id", value=private_dns_zone_id, expected_type=type_hints["private_dns_zone_id"])
            check_type(argname="argument virtual_network_id", value=virtual_network_id, expected_type=type_hints["virtual_network_id"])
            check_type(argname="argument ignore_changes", value=ignore_changes, expected_type=type_hints["ignore_changes"])
            check_type(argname="argument registration_enabled", value=registration_enabled, expected_type=type_hints["registration_enabled"])
            check_type(argname="argument resolution_policy", value=resolution_policy, expected_type=type_hints["resolution_policy"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "private_dns_zone_id": private_dns_zone_id,
            "virtual_network_id": virtual_network_id,
        }
        if connection is not None:
            self._values["connection"] = connection
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if for_each is not None:
            self._values["for_each"] = for_each
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider
        if provisioners is not None:
            self._values["provisioners"] = provisioners
        if api_version is not None:
            self._values["api_version"] = api_version
        if enable_migration_analysis is not None:
            self._values["enable_migration_analysis"] = enable_migration_analysis
        if enable_transformation is not None:
            self._values["enable_transformation"] = enable_transformation
        if enable_validation is not None:
            self._values["enable_validation"] = enable_validation
        if location is not None:
            self._values["location"] = location
        if monitoring is not None:
            self._values["monitoring"] = monitoring
        if name is not None:
            self._values["name"] = name
        if tags is not None:
            self._values["tags"] = tags
        if ignore_changes is not None:
            self._values["ignore_changes"] = ignore_changes
        if registration_enabled is not None:
            self._values["registration_enabled"] = registration_enabled
        if resolution_policy is not None:
            self._values["resolution_policy"] = resolution_policy

    @builtins.property
    def connection(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("connection")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]], result)

    @builtins.property
    def count(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]], result)

    @builtins.property
    def depends_on(
        self,
    ) -> typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]], result)

    @builtins.property
    def for_each(self) -> typing.Optional[_cdktf_9a9027ec.ITerraformIterator]:
        '''
        :stability: experimental
        '''
        result = self._values.get("for_each")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.ITerraformIterator], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[_cdktf_9a9027ec.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformProvider], result)

    @builtins.property
    def provisioners(
        self,
    ) -> typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provisioners")
        return typing.cast(typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]], result)

    @builtins.property
    def api_version(self) -> typing.Optional[builtins.str]:
        '''Explicit API version to use for this resource.

        If not specified, the latest active version will be automatically resolved.
        Use this for version pinning when stability is required over latest features.

        :default: Latest active version from ApiVersionManager

        Example::

            "2024-11-01"
        '''
        result = self._values.get("api_version")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def enable_migration_analysis(self) -> typing.Optional[builtins.bool]:
        '''Whether to enable migration analysis warnings.

        When true, the framework will analyze the current version for deprecation
        status and provide migration recommendations in the deployment output.

        :default: true
        '''
        result = self._values.get("enable_migration_analysis")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_transformation(self) -> typing.Optional[builtins.bool]:
        '''Whether to apply property transformations automatically.

        When true, properties will be automatically transformed according to the
        target schema's transformation rules. This enables backward compatibility.

        :default: true
        '''
        result = self._values.get("enable_transformation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_validation(self) -> typing.Optional[builtins.bool]:
        '''Whether to validate properties against the schema.

        When true, all properties will be validated against the API schema before
        resource creation. Validation errors will cause deployment failures.

        :default: true
        '''
        result = self._values.get("enable_validation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def location(self) -> typing.Optional[builtins.str]:
        '''The location where the resource should be created.

        :default: Varies by resource type - see specific resource documentation

        :remarks:

        Location handling varies by resource type:

        - **Top-level resources**: Most require an explicit location (e.g., "eastus", "westus")
        - **Global resources**: Some use "global" as location (e.g., Private DNS Zones)
        - **Child resources**: Inherit location from parent and should NOT set this property

        Each resource type may provide its own default through the ``resolveLocation()`` method.
        If no location is specified and no default exists, resource creation may fail.

        Example::

            // Child resource (Subnet) - do not set location
            // location: undefined (inherited from parent Virtual Network)
        '''
        result = self._values.get("location")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def monitoring(self) -> typing.Optional[_MonitoringConfig_7c28df74]:
        '''Monitoring configuration for this resource.

        Enables integrated monitoring with diagnostic settings, metric alerts,
        and activity log alerts. All monitoring is optional and disabled by default.

        Example::

            monitoring: {
              enabled: true,
              diagnosticSettings: {
                workspaceId: logAnalytics.id,
                metrics: ['AllMetrics'],
                logs: ['AuditLogs']
              },
              metricAlerts: [{
                name: 'high-cpu-alert',
                severity: 2,
                scopes: [], // Automatically set to this resource
                criteria: { ... },
                actions: [{ actionGroupId: actionGroup.id }]
              }]
            }
        '''
        result = self._values.get("monitoring")
        return typing.cast(typing.Optional[_MonitoringConfig_7c28df74], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the resource.'''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Tags to apply to the resource.'''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def private_dns_zone_id(self) -> builtins.str:
        '''Resource ID of the parent Private DNS Zone.

        Example::

            "/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/rg/providers/Microsoft.Network/privateDnsZones/internal.contoso.com"
        '''
        result = self._values.get("private_dns_zone_id")
        assert result is not None, "Required property 'private_dns_zone_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def virtual_network_id(self) -> builtins.str:
        '''Resource ID of the Virtual Network to link.

        Example::

            "/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/rg/providers/Microsoft.Network/virtualNetworks/vnet1"
        '''
        result = self._values.get("virtual_network_id")
        assert result is not None, "Required property 'virtual_network_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def ignore_changes(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The lifecycle rules to ignore changes.

        Example::

            ["tags"]
        '''
        result = self._values.get("ignore_changes")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def registration_enabled(self) -> typing.Optional[builtins.bool]:
        '''Whether auto-registration of virtual machine records is enabled When enabled, VMs in the VNet will automatically register DNS records.

        :default: false
        '''
        result = self._values.get("registration_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def resolution_policy(self) -> typing.Optional[builtins.str]:
        '''The resolution policy for the virtual network link Only applicable to Private Link zones (zones containing "privatelink." in the name) - "Default": Standard DNS resolution - "NxDomainRedirect": Fallback to Azure DNS for unresolved queries Note: This property will be silently ignored if the zone is not a Private Link zone.'''
        result = self._values.get("resolution_policy")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "PrivateDnsZoneLinkProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.PrivateDnsZoneLinkVirtualNetworkReference",
    jsii_struct_bases=[],
    name_mapping={"id": "id"},
)
class PrivateDnsZoneLinkVirtualNetworkReference:
    def __init__(self, *, id: builtins.str) -> None:
        '''Virtual Network reference for the Private DNS Zone link.

        :param id: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9ddad4abd6fa4bbc9c8ab2e7d03c0952b534694bb8173edfccbee9c97a731e1d)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "id": id,
        }

    @builtins.property
    def id(self) -> builtins.str:
        result = self._values.get("id")
        assert result is not None, "Required property 'id' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "PrivateDnsZoneLinkVirtualNetworkReference(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.PrivateDnsZoneProps",
    jsii_struct_bases=[_AzapiResourceProps_141a2340],
    name_mapping={
        "connection": "connection",
        "count": "count",
        "depends_on": "dependsOn",
        "for_each": "forEach",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "provisioners": "provisioners",
        "api_version": "apiVersion",
        "enable_migration_analysis": "enableMigrationAnalysis",
        "enable_transformation": "enableTransformation",
        "enable_validation": "enableValidation",
        "location": "location",
        "monitoring": "monitoring",
        "name": "name",
        "tags": "tags",
        "ignore_changes": "ignoreChanges",
        "resource_group_id": "resourceGroupId",
    },
)
class PrivateDnsZoneProps(_AzapiResourceProps_141a2340):
    def __init__(
        self,
        *,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
        api_version: typing.Optional[builtins.str] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        location: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
        resource_group_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for the unified Azure Private DNS Zone.

        Extends AzapiResourceProps with Private DNS Zone specific properties

        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        :param api_version: Explicit API version to use for this resource. If not specified, the latest active version will be automatically resolved. Use this for version pinning when stability is required over latest features. Default: Latest active version from ApiVersionManager
        :param enable_migration_analysis: Whether to enable migration analysis warnings. When true, the framework will analyze the current version for deprecation status and provide migration recommendations in the deployment output. Default: true
        :param enable_transformation: Whether to apply property transformations automatically. When true, properties will be automatically transformed according to the target schema's transformation rules. This enables backward compatibility. Default: true
        :param enable_validation: Whether to validate properties against the schema. When true, all properties will be validated against the API schema before resource creation. Validation errors will cause deployment failures. Default: true
        :param location: The location where the resource should be created. Default: Varies by resource type - see specific resource documentation
        :param monitoring: Monitoring configuration for this resource. Enables integrated monitoring with diagnostic settings, metric alerts, and activity log alerts. All monitoring is optional and disabled by default.
        :param name: The name of the resource.
        :param tags: Tags to apply to the resource.
        :param ignore_changes: The lifecycle rules to ignore changes.
        :param resource_group_id: Resource group ID where the Private DNS Zone will be created.
        '''
        if isinstance(lifecycle, dict):
            lifecycle = _cdktf_9a9027ec.TerraformResourceLifecycle(**lifecycle)
        if isinstance(monitoring, dict):
            monitoring = _MonitoringConfig_7c28df74(**monitoring)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b0d5f6e0513082e6b82c7a2b3bd783ebd7bf620f2d08d092b8eb4642e51f9755)
            check_type(argname="argument connection", value=connection, expected_type=type_hints["connection"])
            check_type(argname="argument count", value=count, expected_type=type_hints["count"])
            check_type(argname="argument depends_on", value=depends_on, expected_type=type_hints["depends_on"])
            check_type(argname="argument for_each", value=for_each, expected_type=type_hints["for_each"])
            check_type(argname="argument lifecycle", value=lifecycle, expected_type=type_hints["lifecycle"])
            check_type(argname="argument provider", value=provider, expected_type=type_hints["provider"])
            check_type(argname="argument provisioners", value=provisioners, expected_type=type_hints["provisioners"])
            check_type(argname="argument api_version", value=api_version, expected_type=type_hints["api_version"])
            check_type(argname="argument enable_migration_analysis", value=enable_migration_analysis, expected_type=type_hints["enable_migration_analysis"])
            check_type(argname="argument enable_transformation", value=enable_transformation, expected_type=type_hints["enable_transformation"])
            check_type(argname="argument enable_validation", value=enable_validation, expected_type=type_hints["enable_validation"])
            check_type(argname="argument location", value=location, expected_type=type_hints["location"])
            check_type(argname="argument monitoring", value=monitoring, expected_type=type_hints["monitoring"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument ignore_changes", value=ignore_changes, expected_type=type_hints["ignore_changes"])
            check_type(argname="argument resource_group_id", value=resource_group_id, expected_type=type_hints["resource_group_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if connection is not None:
            self._values["connection"] = connection
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if for_each is not None:
            self._values["for_each"] = for_each
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider
        if provisioners is not None:
            self._values["provisioners"] = provisioners
        if api_version is not None:
            self._values["api_version"] = api_version
        if enable_migration_analysis is not None:
            self._values["enable_migration_analysis"] = enable_migration_analysis
        if enable_transformation is not None:
            self._values["enable_transformation"] = enable_transformation
        if enable_validation is not None:
            self._values["enable_validation"] = enable_validation
        if location is not None:
            self._values["location"] = location
        if monitoring is not None:
            self._values["monitoring"] = monitoring
        if name is not None:
            self._values["name"] = name
        if tags is not None:
            self._values["tags"] = tags
        if ignore_changes is not None:
            self._values["ignore_changes"] = ignore_changes
        if resource_group_id is not None:
            self._values["resource_group_id"] = resource_group_id

    @builtins.property
    def connection(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("connection")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]], result)

    @builtins.property
    def count(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]], result)

    @builtins.property
    def depends_on(
        self,
    ) -> typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]], result)

    @builtins.property
    def for_each(self) -> typing.Optional[_cdktf_9a9027ec.ITerraformIterator]:
        '''
        :stability: experimental
        '''
        result = self._values.get("for_each")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.ITerraformIterator], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[_cdktf_9a9027ec.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformProvider], result)

    @builtins.property
    def provisioners(
        self,
    ) -> typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provisioners")
        return typing.cast(typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]], result)

    @builtins.property
    def api_version(self) -> typing.Optional[builtins.str]:
        '''Explicit API version to use for this resource.

        If not specified, the latest active version will be automatically resolved.
        Use this for version pinning when stability is required over latest features.

        :default: Latest active version from ApiVersionManager

        Example::

            "2024-11-01"
        '''
        result = self._values.get("api_version")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def enable_migration_analysis(self) -> typing.Optional[builtins.bool]:
        '''Whether to enable migration analysis warnings.

        When true, the framework will analyze the current version for deprecation
        status and provide migration recommendations in the deployment output.

        :default: true
        '''
        result = self._values.get("enable_migration_analysis")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_transformation(self) -> typing.Optional[builtins.bool]:
        '''Whether to apply property transformations automatically.

        When true, properties will be automatically transformed according to the
        target schema's transformation rules. This enables backward compatibility.

        :default: true
        '''
        result = self._values.get("enable_transformation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_validation(self) -> typing.Optional[builtins.bool]:
        '''Whether to validate properties against the schema.

        When true, all properties will be validated against the API schema before
        resource creation. Validation errors will cause deployment failures.

        :default: true
        '''
        result = self._values.get("enable_validation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def location(self) -> typing.Optional[builtins.str]:
        '''The location where the resource should be created.

        :default: Varies by resource type - see specific resource documentation

        :remarks:

        Location handling varies by resource type:

        - **Top-level resources**: Most require an explicit location (e.g., "eastus", "westus")
        - **Global resources**: Some use "global" as location (e.g., Private DNS Zones)
        - **Child resources**: Inherit location from parent and should NOT set this property

        Each resource type may provide its own default through the ``resolveLocation()`` method.
        If no location is specified and no default exists, resource creation may fail.

        Example::

            // Child resource (Subnet) - do not set location
            // location: undefined (inherited from parent Virtual Network)
        '''
        result = self._values.get("location")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def monitoring(self) -> typing.Optional[_MonitoringConfig_7c28df74]:
        '''Monitoring configuration for this resource.

        Enables integrated monitoring with diagnostic settings, metric alerts,
        and activity log alerts. All monitoring is optional and disabled by default.

        Example::

            monitoring: {
              enabled: true,
              diagnosticSettings: {
                workspaceId: logAnalytics.id,
                metrics: ['AllMetrics'],
                logs: ['AuditLogs']
              },
              metricAlerts: [{
                name: 'high-cpu-alert',
                severity: 2,
                scopes: [], // Automatically set to this resource
                criteria: { ... },
                actions: [{ actionGroupId: actionGroup.id }]
              }]
            }
        '''
        result = self._values.get("monitoring")
        return typing.cast(typing.Optional[_MonitoringConfig_7c28df74], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the resource.'''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Tags to apply to the resource.'''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def ignore_changes(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The lifecycle rules to ignore changes.

        Example::

            ["tags"]
        '''
        result = self._values.get("ignore_changes")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def resource_group_id(self) -> typing.Optional[builtins.str]:
        '''Resource group ID where the Private DNS Zone will be created.'''
        result = self._values.get("resource_group_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "PrivateDnsZoneProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.PropertyDefinition",
    jsii_struct_bases=[],
    name_mapping={
        "data_type": "dataType",
        "added_in_version": "addedInVersion",
        "default_value": "defaultValue",
        "deprecated": "deprecated",
        "description": "description",
        "removed_in_version": "removedInVersion",
        "required": "required",
        "validation": "validation",
    },
)
class PropertyDefinition:
    def __init__(
        self,
        *,
        data_type: builtins.str,
        added_in_version: typing.Optional[builtins.str] = None,
        default_value: typing.Any = None,
        deprecated: typing.Optional[builtins.bool] = None,
        description: typing.Optional[builtins.str] = None,
        removed_in_version: typing.Optional[builtins.str] = None,
        required: typing.Optional[builtins.bool] = None,
        validation: typing.Optional[typing.Sequence[typing.Union[_ValidationRule_f1913ed6, typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Property definition for API schema.

        Defines the characteristics, validation rules, and metadata for a single
        property in an API schema. This enables type validation, transformation,
        and documentation generation.

        :param data_type: The data type of the property Must be one of the PropertyType constants.
        :param added_in_version: The API version in which this property was added Used for compatibility analysis and migration planning.
        :param default_value: Default value to use if property is not provided Type must match the property type.
        :param deprecated: Whether this property is deprecated If true, usage warnings will be generated. Default: false
        :param description: Human-readable description of the property Used for documentation generation and IDE support.
        :param removed_in_version: The API version in which this property was removed Used for compatibility analysis and migration planning.
        :param required: Whether this property is required If true, the property must be provided by the user. Default: false
        :param validation: Array of validation rules to apply to this property Rules are evaluated in order and all must pass.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__873687013997a56dc83a159d5ec3b08ecea6e26cf9d0e9412bfe53c038a3f8ee)
            check_type(argname="argument data_type", value=data_type, expected_type=type_hints["data_type"])
            check_type(argname="argument added_in_version", value=added_in_version, expected_type=type_hints["added_in_version"])
            check_type(argname="argument default_value", value=default_value, expected_type=type_hints["default_value"])
            check_type(argname="argument deprecated", value=deprecated, expected_type=type_hints["deprecated"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument removed_in_version", value=removed_in_version, expected_type=type_hints["removed_in_version"])
            check_type(argname="argument required", value=required, expected_type=type_hints["required"])
            check_type(argname="argument validation", value=validation, expected_type=type_hints["validation"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "data_type": data_type,
        }
        if added_in_version is not None:
            self._values["added_in_version"] = added_in_version
        if default_value is not None:
            self._values["default_value"] = default_value
        if deprecated is not None:
            self._values["deprecated"] = deprecated
        if description is not None:
            self._values["description"] = description
        if removed_in_version is not None:
            self._values["removed_in_version"] = removed_in_version
        if required is not None:
            self._values["required"] = required
        if validation is not None:
            self._values["validation"] = validation

    @builtins.property
    def data_type(self) -> builtins.str:
        '''The data type of the property Must be one of the PropertyType constants.'''
        result = self._values.get("data_type")
        assert result is not None, "Required property 'data_type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def added_in_version(self) -> typing.Optional[builtins.str]:
        '''The API version in which this property was added Used for compatibility analysis and migration planning.

        Example::

            "2024-01-01"
        '''
        result = self._values.get("added_in_version")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def default_value(self) -> typing.Any:
        '''Default value to use if property is not provided Type must match the property type.'''
        result = self._values.get("default_value")
        return typing.cast(typing.Any, result)

    @builtins.property
    def deprecated(self) -> typing.Optional[builtins.bool]:
        '''Whether this property is deprecated If true, usage warnings will be generated.

        :default: false
        '''
        result = self._values.get("deprecated")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''Human-readable description of the property Used for documentation generation and IDE support.'''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def removed_in_version(self) -> typing.Optional[builtins.str]:
        '''The API version in which this property was removed Used for compatibility analysis and migration planning.

        Example::

            "2025-01-01"
        '''
        result = self._values.get("removed_in_version")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def required(self) -> typing.Optional[builtins.bool]:
        '''Whether this property is required If true, the property must be provided by the user.

        :default: false
        '''
        result = self._values.get("required")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def validation(self) -> typing.Optional[typing.List[_ValidationRule_f1913ed6]]:
        '''Array of validation rules to apply to this property Rules are evaluated in order and all must pass.'''
        result = self._values.get("validation")
        return typing.cast(typing.Optional[typing.List[_ValidationRule_f1913ed6]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "PropertyDefinition(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.PropertyMapping",
    jsii_struct_bases=[],
    name_mapping={
        "source_property": "sourceProperty",
        "target_property": "targetProperty",
        "default_value": "defaultValue",
        "required": "required",
        "transformer": "transformer",
    },
)
class PropertyMapping:
    def __init__(
        self,
        *,
        source_property: builtins.str,
        target_property: builtins.str,
        default_value: typing.Any = None,
        required: typing.Optional[builtins.bool] = None,
        transformer: typing.Optional[typing.Union[_PropertyTransformer_9b876b7f, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Property mapping definition.

        Defines how a property should be mapped from source to target schema,
        including any transformations or default values to apply.

        :param source_property: The name of the source property.
        :param target_property: The name of the target property.
        :param default_value: Default value to use if source property is not provided.
        :param required: Whether this property is required in the target schema. Default: false
        :param transformer: Optional transformer to apply during mapping.
        '''
        if isinstance(transformer, dict):
            transformer = _PropertyTransformer_9b876b7f(**transformer)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e646261d26230a31efdf6cc86475e2770b333f18140390e5aec8538d4780530b)
            check_type(argname="argument source_property", value=source_property, expected_type=type_hints["source_property"])
            check_type(argname="argument target_property", value=target_property, expected_type=type_hints["target_property"])
            check_type(argname="argument default_value", value=default_value, expected_type=type_hints["default_value"])
            check_type(argname="argument required", value=required, expected_type=type_hints["required"])
            check_type(argname="argument transformer", value=transformer, expected_type=type_hints["transformer"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "source_property": source_property,
            "target_property": target_property,
        }
        if default_value is not None:
            self._values["default_value"] = default_value
        if required is not None:
            self._values["required"] = required
        if transformer is not None:
            self._values["transformer"] = transformer

    @builtins.property
    def source_property(self) -> builtins.str:
        '''The name of the source property.'''
        result = self._values.get("source_property")
        assert result is not None, "Required property 'source_property' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def target_property(self) -> builtins.str:
        '''The name of the target property.'''
        result = self._values.get("target_property")
        assert result is not None, "Required property 'target_property' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def default_value(self) -> typing.Any:
        '''Default value to use if source property is not provided.'''
        result = self._values.get("default_value")
        return typing.cast(typing.Any, result)

    @builtins.property
    def required(self) -> typing.Optional[builtins.bool]:
        '''Whether this property is required in the target schema.

        :default: false
        '''
        result = self._values.get("required")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def transformer(self) -> typing.Optional[_PropertyTransformer_9b876b7f]:
        '''Optional transformer to apply during mapping.'''
        result = self._values.get("transformer")
        return typing.cast(typing.Optional[_PropertyTransformer_9b876b7f], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "PropertyMapping(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class PropertyTransformationType(
    metaclass=jsii.JSIIMeta,
    jsii_type="@microsoft/terraform-cdk-constructs.PropertyTransformationType",
):
    '''Property transformation types for schema mapping.

    Defines the types of transformations that can be applied when mapping
    properties between different schema versions.
    '''

    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.python.classproperty
    @jsii.member(jsii_name="CUSTOM_FUNCTION")
    def CUSTOM_FUNCTION(cls) -> builtins.str:
        '''Apply custom transformation function.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CUSTOM_FUNCTION"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="DIRECT_COPY")
    def DIRECT_COPY(cls) -> builtins.str:
        '''Direct copy with no transformation.'''
        return typing.cast(builtins.str, jsii.sget(cls, "DIRECT_COPY"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="STRUCTURE_TRANSFORMATION")
    def STRUCTURE_TRANSFORMATION(cls) -> builtins.str:
        '''Transform object structure.'''
        return typing.cast(builtins.str, jsii.sget(cls, "STRUCTURE_TRANSFORMATION"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VALUE_MAPPING")
    def VALUE_MAPPING(cls) -> builtins.str:
        '''Map values using a lookup table.'''
        return typing.cast(builtins.str, jsii.sget(cls, "VALUE_MAPPING"))


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.PropertyTransformer",
    jsii_struct_bases=[],
    name_mapping={"transformation_type": "transformationType", "config": "config"},
)
class PropertyTransformer:
    def __init__(
        self,
        *,
        transformation_type: builtins.str,
        config: typing.Any = None,
    ) -> None:
        '''Property transformation interface for schema mapping.

        Defines how properties should be transformed when mapping between
        different schema versions or formats.

        :param transformation_type: The type of transformation to apply Must be one of the PropertyTransformationType constants.
        :param config: Configuration object for the transformation Structure depends on the transformation type.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9eb55571415bfbdd70d0e9d0a78c13122ab931b54ab8c79380c0fe0044d09e27)
            check_type(argname="argument transformation_type", value=transformation_type, expected_type=type_hints["transformation_type"])
            check_type(argname="argument config", value=config, expected_type=type_hints["config"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "transformation_type": transformation_type,
        }
        if config is not None:
            self._values["config"] = config

    @builtins.property
    def transformation_type(self) -> builtins.str:
        '''The type of transformation to apply Must be one of the PropertyTransformationType constants.'''
        result = self._values.get("transformation_type")
        assert result is not None, "Required property 'transformation_type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def config(self) -> typing.Any:
        '''Configuration object for the transformation Structure depends on the transformation type.'''
        result = self._values.get("config")
        return typing.cast(typing.Any, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "PropertyTransformer(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class PropertyType(
    metaclass=jsii.JSIIMeta,
    jsii_type="@microsoft/terraform-cdk-constructs.PropertyType",
):
    '''Property type enumeration for schema definitions.

    Defines the basic data types supported in API schemas for validation
    and transformation purposes.
    '''

    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.python.classproperty
    @jsii.member(jsii_name="ANY")
    def ANY(cls) -> builtins.str:
        '''Any data type (no validation).'''
        return typing.cast(builtins.str, jsii.sget(cls, "ANY"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="ARRAY")
    def ARRAY(cls) -> builtins.str:
        '''Array data type (ordered collection).'''
        return typing.cast(builtins.str, jsii.sget(cls, "ARRAY"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="BOOLEAN")
    def BOOLEAN(cls) -> builtins.str:
        '''Boolean data type (true/false).'''
        return typing.cast(builtins.str, jsii.sget(cls, "BOOLEAN"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="NUMBER")
    def NUMBER(cls) -> builtins.str:
        '''Numeric data type (integer or float).'''
        return typing.cast(builtins.str, jsii.sget(cls, "NUMBER"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="OBJECT")
    def OBJECT(cls) -> builtins.str:
        '''Object data type (key-value pairs).'''
        return typing.cast(builtins.str, jsii.sget(cls, "OBJECT"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="STRING")
    def STRING(cls) -> builtins.str:
        '''String data type.'''
        return typing.cast(builtins.str, jsii.sget(cls, "STRING"))


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.PropertyValidation",
    jsii_struct_bases=[],
    name_mapping={"property": "property", "rules": "rules"},
)
class PropertyValidation:
    def __init__(
        self,
        *,
        property: builtins.str,
        rules: typing.Sequence[typing.Union[_ValidationRule_f1913ed6, typing.Dict[builtins.str, typing.Any]]],
    ) -> None:
        '''Property validation configuration.

        Defines validation rules that apply to specific properties,
        enabling complex validation scenarios and cross-property validation.

        :param property: The name of the property this validation applies to.
        :param rules: Array of validation rules to apply to this property Rules are evaluated in order and all must pass.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__84adfcff60680f878147cacc881873aa8c2fe2987cde811b86790842bf32bba9)
            check_type(argname="argument property", value=property, expected_type=type_hints["property"])
            check_type(argname="argument rules", value=rules, expected_type=type_hints["rules"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "property": property,
            "rules": rules,
        }

    @builtins.property
    def property(self) -> builtins.str:
        '''The name of the property this validation applies to.'''
        result = self._values.get("property")
        assert result is not None, "Required property 'property' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def rules(self) -> typing.List[_ValidationRule_f1913ed6]:
        '''Array of validation rules to apply to this property Rules are evaluated in order and all must pass.'''
        result = self._values.get("rules")
        assert result is not None, "Required property 'rules' is missing"
        return typing.cast(typing.List[_ValidationRule_f1913ed6], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "PropertyValidation(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.ProximityPlacementGroupReference",
    jsii_struct_bases=[],
    name_mapping={"id": "id"},
)
class ProximityPlacementGroupReference:
    def __init__(self, *, id: builtins.str) -> None:
        '''Proximity placement group reference.

        :param id: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__074f8c88a5dc47fb3db6e7bdbf3b8606decb68e6e59cad237d0ddf973adfc7ce)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "id": id,
        }

    @builtins.property
    def id(self) -> builtins.str:
        result = self._values.get("id")
        assert result is not None, "Required property 'id' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ProximityPlacementGroupReference(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class PublicIPAddress(
    _AzapiResource_7e7f5b39,
    metaclass=jsii.JSIIMeta,
    jsii_type="@microsoft/terraform-cdk-constructs.PublicIPAddress",
):
    '''Azure Public IP Address implementation.

    This class provides a single, version-aware implementation that replaces
    version-specific Public IP Address classes. It automatically handles version
    resolution, schema validation, and property transformation while maintaining
    full backward compatibility.

    Example::

        // Zonal Public IP:
        const publicIp = new PublicIPAddress(this, "publicIp", {
          name: "my-public-ip",
          location: "eastus",
          sku: {
            name: "Standard"
          },
          publicIPAllocationMethod: "Static",
          zones: ["1"]
        });
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        dns_settings: typing.Optional[typing.Union[_PublicIPAddressDnsSettings_d3ef5a04, typing.Dict[builtins.str, typing.Any]]] = None,
        idle_timeout_in_minutes: typing.Optional[jsii.Number] = None,
        ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
        public_ip_address_version: typing.Optional[builtins.str] = None,
        public_ip_allocation_method: typing.Optional[builtins.str] = None,
        resource_group_id: typing.Optional[builtins.str] = None,
        sku: typing.Optional[typing.Union[_PublicIPAddressSku_00870b2b, typing.Dict[builtins.str, typing.Any]]] = None,
        zones: typing.Optional[typing.Sequence[builtins.str]] = None,
        api_version: typing.Optional[builtins.str] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        location: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> None:
        '''Creates a new Azure Public IP Address using the AzapiResource framework.

        The constructor automatically handles version resolution, schema registration,
        validation, and resource creation. It maintains full backward compatibility
        with existing Public IP Address implementations.

        :param scope: - The scope in which to define this construct.
        :param id: - The unique identifier for this instance.
        :param dns_settings: DNS settings for the public IP address Optional - configures DNS label for the public IP.
        :param idle_timeout_in_minutes: Idle timeout in minutes Valid range: 4-30 minutes. Default: 4
        :param ignore_changes: The lifecycle rules to ignore changes Useful for properties that are externally managed.
        :param public_ip_address_version: Public IP address version. Default: "IPv4"
        :param public_ip_allocation_method: Public IP allocation method - Static: IP address is allocated immediately and doesn't change - Dynamic: IP address is allocated when associated with a resource Note: Standard SKU requires Static allocation. Default: "Dynamic"
        :param resource_group_id: Resource group ID where the Public IP will be created Optional - will use the subscription scope if not provided.
        :param sku: SKU of the public IP address Standard SKU supports zones and has SLA guarantees Basic SKU does not support zones.
        :param zones: Availability zones for the public IP address Only supported with Standard SKU.
        :param api_version: Explicit API version to use for this resource. If not specified, the latest active version will be automatically resolved. Use this for version pinning when stability is required over latest features. Default: Latest active version from ApiVersionManager
        :param enable_migration_analysis: Whether to enable migration analysis warnings. When true, the framework will analyze the current version for deprecation status and provide migration recommendations in the deployment output. Default: true
        :param enable_transformation: Whether to apply property transformations automatically. When true, properties will be automatically transformed according to the target schema's transformation rules. This enables backward compatibility. Default: true
        :param enable_validation: Whether to validate properties against the schema. When true, all properties will be validated against the API schema before resource creation. Validation errors will cause deployment failures. Default: true
        :param location: The location where the resource should be created. Default: Varies by resource type - see specific resource documentation
        :param monitoring: Monitoring configuration for this resource. Enables integrated monitoring with diagnostic settings, metric alerts, and activity log alerts. All monitoring is optional and disabled by default.
        :param name: The name of the resource.
        :param tags: Tags to apply to the resource.
        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c03ad4acff40fc4658670045a9322dc7f2219aa34386282169bd844ec7c8e1bd)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = _PublicIPAddressProps_ec145bdf(
            dns_settings=dns_settings,
            idle_timeout_in_minutes=idle_timeout_in_minutes,
            ignore_changes=ignore_changes,
            public_ip_address_version=public_ip_address_version,
            public_ip_allocation_method=public_ip_allocation_method,
            resource_group_id=resource_group_id,
            sku=sku,
            zones=zones,
            api_version=api_version,
            enable_migration_analysis=enable_migration_analysis,
            enable_transformation=enable_transformation,
            enable_validation=enable_validation,
            location=location,
            monitoring=monitoring,
            name=name,
            tags=tags,
            connection=connection,
            count=count,
            depends_on=depends_on,
            for_each=for_each,
            lifecycle=lifecycle,
            provider=provider,
            provisioners=provisioners,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="addTag")
    def add_tag(self, key: builtins.str, value: builtins.str) -> None:
        '''Add a tag to the Public IP Address Note: This modifies the construct props but requires a new deployment to take effect.

        :param key: -
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__67b1d3e66ec14784f55898a76b4b08fe917e2fa06b244fe1163442d5632357c8)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "addTag", [key, value]))

    @jsii.member(jsii_name="apiSchema")
    def _api_schema(self) -> _ApiSchema_5ce0490e:
        '''Gets the API schema for the resolved version Uses the framework's schema resolution to get the appropriate schema.'''
        return typing.cast(_ApiSchema_5ce0490e, jsii.invoke(self, "apiSchema", []))

    @jsii.member(jsii_name="createResourceBody")
    def _create_resource_body(self, props: typing.Any) -> typing.Any:
        '''Creates the resource body for the Azure API call Transforms the input properties into the JSON format expected by Azure REST API.

        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__83211c70c033f81b39b5eae00a0fee94b7b6463ebf64387dcaf0c0382afbb7bc)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Any, jsii.invoke(self, "createResourceBody", [props]))

    @jsii.member(jsii_name="defaultVersion")
    def _default_version(self) -> builtins.str:
        '''Gets the default API version to use when no explicit version is specified Returns the most recent stable version as the default.'''
        return typing.cast(builtins.str, jsii.invoke(self, "defaultVersion", []))

    @jsii.member(jsii_name="removeTag")
    def remove_tag(self, key: builtins.str) -> None:
        '''Remove a tag from the Public IP Address Note: This modifies the construct props but requires a new deployment to take effect.

        :param key: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e10aac97b72a9b63ee509be163fbecb06d028fe26f6512e7d52ad432de773af1)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
        return typing.cast(None, jsii.invoke(self, "removeTag", [key]))

    @jsii.member(jsii_name="requiresLocation")
    def _requires_location(self) -> builtins.bool:
        '''Indicates that location is required for Public IP Addresses.'''
        return typing.cast(builtins.bool, jsii.invoke(self, "requiresLocation", []))

    @jsii.member(jsii_name="resourceType")
    def _resource_type(self) -> builtins.str:
        '''Gets the Azure resource type for Public IP Addresses.'''
        return typing.cast(builtins.str, jsii.invoke(self, "resourceType", []))

    @builtins.property
    @jsii.member(jsii_name="idOutput")
    def id_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "idOutput"))

    @builtins.property
    @jsii.member(jsii_name="ipAddress")
    def ip_address(self) -> builtins.str:
        '''Get the IP address output value Returns the Terraform interpolation string for the IP address.'''
        return typing.cast(builtins.str, jsii.get(self, "ipAddress"))

    @builtins.property
    @jsii.member(jsii_name="locationOutput")
    def location_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "locationOutput"))

    @builtins.property
    @jsii.member(jsii_name="nameOutput")
    def name_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "nameOutput"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def props(self) -> _PublicIPAddressProps_ec145bdf:
        '''The input properties for this Public IP Address instance.'''
        return typing.cast(_PublicIPAddressProps_ec145bdf, jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="resourceId")
    def resource_id(self) -> builtins.str:
        '''Get the full resource identifier for use in other Azure resources Alias for the id property to match original interface.'''
        return typing.cast(builtins.str, jsii.get(self, "resourceId"))

    @builtins.property
    @jsii.member(jsii_name="subscriptionId")
    def subscription_id(self) -> builtins.str:
        '''Get the subscription ID from the Public IP Address ID Extracts the subscription ID from the Azure resource ID format.'''
        return typing.cast(builtins.str, jsii.get(self, "subscriptionId"))

    @builtins.property
    @jsii.member(jsii_name="tagsOutput")
    def tags_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "tagsOutput"))


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.PublicIPAddressConfiguration",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "properties": "properties"},
)
class PublicIPAddressConfiguration:
    def __init__(
        self,
        *,
        name: builtins.str,
        properties: typing.Optional[typing.Union[_PublicIPAddressConfigurationProperties_2d1f2680, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Public IP address configuration.

        :param name: 
        :param properties: 
        '''
        if isinstance(properties, dict):
            properties = _PublicIPAddressConfigurationProperties_2d1f2680(**properties)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__97686cace8cf5d2d38bcd4b13bb66bb58b3c1ef11ad59a4b96adc5c7fa8919ef)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument properties", value=properties, expected_type=type_hints["properties"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if properties is not None:
            self._values["properties"] = properties

    @builtins.property
    def name(self) -> builtins.str:
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def properties(
        self,
    ) -> typing.Optional[_PublicIPAddressConfigurationProperties_2d1f2680]:
        result = self._values.get("properties")
        return typing.cast(typing.Optional[_PublicIPAddressConfigurationProperties_2d1f2680], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "PublicIPAddressConfiguration(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.PublicIPAddressConfigurationProperties",
    jsii_struct_bases=[],
    name_mapping={
        "dns_settings": "dnsSettings",
        "idle_timeout_in_minutes": "idleTimeoutInMinutes",
    },
)
class PublicIPAddressConfigurationProperties:
    def __init__(
        self,
        *,
        dns_settings: typing.Optional[typing.Union[_PublicIPDnsSettings_cb1a7a4f, typing.Dict[builtins.str, typing.Any]]] = None,
        idle_timeout_in_minutes: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Public IP address configuration properties.

        :param dns_settings: 
        :param idle_timeout_in_minutes: 
        '''
        if isinstance(dns_settings, dict):
            dns_settings = _PublicIPDnsSettings_cb1a7a4f(**dns_settings)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f19f2b46ee6e8628db0b94aa1c2164aac316a89d5f9d667e462cc198a48c1ff9)
            check_type(argname="argument dns_settings", value=dns_settings, expected_type=type_hints["dns_settings"])
            check_type(argname="argument idle_timeout_in_minutes", value=idle_timeout_in_minutes, expected_type=type_hints["idle_timeout_in_minutes"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if dns_settings is not None:
            self._values["dns_settings"] = dns_settings
        if idle_timeout_in_minutes is not None:
            self._values["idle_timeout_in_minutes"] = idle_timeout_in_minutes

    @builtins.property
    def dns_settings(self) -> typing.Optional[_PublicIPDnsSettings_cb1a7a4f]:
        result = self._values.get("dns_settings")
        return typing.cast(typing.Optional[_PublicIPDnsSettings_cb1a7a4f], result)

    @builtins.property
    def idle_timeout_in_minutes(self) -> typing.Optional[jsii.Number]:
        result = self._values.get("idle_timeout_in_minutes")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "PublicIPAddressConfigurationProperties(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.PublicIPAddressDnsSettings",
    jsii_struct_bases=[],
    name_mapping={
        "domain_name_label": "domainNameLabel",
        "fqdn": "fqdn",
        "reverse_fqdn": "reverseFqdn",
    },
)
class PublicIPAddressDnsSettings:
    def __init__(
        self,
        *,
        domain_name_label: typing.Optional[builtins.str] = None,
        fqdn: typing.Optional[builtins.str] = None,
        reverse_fqdn: typing.Optional[builtins.str] = None,
    ) -> None:
        '''DNS settings configuration for Public IP Address.

        :param domain_name_label: The domain name label The concatenation of the domain name label and regionalized DNS zone make up the fully qualified domain name (FQDN) associated with the public IP.
        :param fqdn: The Fully Qualified Domain Name This is the concatenation of the domainNameLabel and the regionalized DNS zone.
        :param reverse_fqdn: The reverse FQDN A user-visible, fully qualified domain name that resolves to this public IP address.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9de4fbe9ea6e8713b5260f467c334f43141e9c159bad946f63b00c461165e2e6)
            check_type(argname="argument domain_name_label", value=domain_name_label, expected_type=type_hints["domain_name_label"])
            check_type(argname="argument fqdn", value=fqdn, expected_type=type_hints["fqdn"])
            check_type(argname="argument reverse_fqdn", value=reverse_fqdn, expected_type=type_hints["reverse_fqdn"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if domain_name_label is not None:
            self._values["domain_name_label"] = domain_name_label
        if fqdn is not None:
            self._values["fqdn"] = fqdn
        if reverse_fqdn is not None:
            self._values["reverse_fqdn"] = reverse_fqdn

    @builtins.property
    def domain_name_label(self) -> typing.Optional[builtins.str]:
        '''The domain name label The concatenation of the domain name label and regionalized DNS zone make up the fully qualified domain name (FQDN) associated with the public IP.'''
        result = self._values.get("domain_name_label")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def fqdn(self) -> typing.Optional[builtins.str]:
        '''The Fully Qualified Domain Name This is the concatenation of the domainNameLabel and the regionalized DNS zone.'''
        result = self._values.get("fqdn")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def reverse_fqdn(self) -> typing.Optional[builtins.str]:
        '''The reverse FQDN A user-visible, fully qualified domain name that resolves to this public IP address.'''
        result = self._values.get("reverse_fqdn")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "PublicIPAddressDnsSettings(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.PublicIPAddressProps",
    jsii_struct_bases=[_AzapiResourceProps_141a2340],
    name_mapping={
        "connection": "connection",
        "count": "count",
        "depends_on": "dependsOn",
        "for_each": "forEach",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "provisioners": "provisioners",
        "api_version": "apiVersion",
        "enable_migration_analysis": "enableMigrationAnalysis",
        "enable_transformation": "enableTransformation",
        "enable_validation": "enableValidation",
        "location": "location",
        "monitoring": "monitoring",
        "name": "name",
        "tags": "tags",
        "dns_settings": "dnsSettings",
        "idle_timeout_in_minutes": "idleTimeoutInMinutes",
        "ignore_changes": "ignoreChanges",
        "public_ip_address_version": "publicIPAddressVersion",
        "public_ip_allocation_method": "publicIPAllocationMethod",
        "resource_group_id": "resourceGroupId",
        "sku": "sku",
        "zones": "zones",
    },
)
class PublicIPAddressProps(_AzapiResourceProps_141a2340):
    def __init__(
        self,
        *,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
        api_version: typing.Optional[builtins.str] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        location: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        dns_settings: typing.Optional[typing.Union[_PublicIPAddressDnsSettings_d3ef5a04, typing.Dict[builtins.str, typing.Any]]] = None,
        idle_timeout_in_minutes: typing.Optional[jsii.Number] = None,
        ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
        public_ip_address_version: typing.Optional[builtins.str] = None,
        public_ip_allocation_method: typing.Optional[builtins.str] = None,
        resource_group_id: typing.Optional[builtins.str] = None,
        sku: typing.Optional[typing.Union[_PublicIPAddressSku_00870b2b, typing.Dict[builtins.str, typing.Any]]] = None,
        zones: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''Properties for the Azure Public IP Address.

        Extends AzapiResourceProps with Public IP Address specific properties

        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        :param api_version: Explicit API version to use for this resource. If not specified, the latest active version will be automatically resolved. Use this for version pinning when stability is required over latest features. Default: Latest active version from ApiVersionManager
        :param enable_migration_analysis: Whether to enable migration analysis warnings. When true, the framework will analyze the current version for deprecation status and provide migration recommendations in the deployment output. Default: true
        :param enable_transformation: Whether to apply property transformations automatically. When true, properties will be automatically transformed according to the target schema's transformation rules. This enables backward compatibility. Default: true
        :param enable_validation: Whether to validate properties against the schema. When true, all properties will be validated against the API schema before resource creation. Validation errors will cause deployment failures. Default: true
        :param location: The location where the resource should be created. Default: Varies by resource type - see specific resource documentation
        :param monitoring: Monitoring configuration for this resource. Enables integrated monitoring with diagnostic settings, metric alerts, and activity log alerts. All monitoring is optional and disabled by default.
        :param name: The name of the resource.
        :param tags: Tags to apply to the resource.
        :param dns_settings: DNS settings for the public IP address Optional - configures DNS label for the public IP.
        :param idle_timeout_in_minutes: Idle timeout in minutes Valid range: 4-30 minutes. Default: 4
        :param ignore_changes: The lifecycle rules to ignore changes Useful for properties that are externally managed.
        :param public_ip_address_version: Public IP address version. Default: "IPv4"
        :param public_ip_allocation_method: Public IP allocation method - Static: IP address is allocated immediately and doesn't change - Dynamic: IP address is allocated when associated with a resource Note: Standard SKU requires Static allocation. Default: "Dynamic"
        :param resource_group_id: Resource group ID where the Public IP will be created Optional - will use the subscription scope if not provided.
        :param sku: SKU of the public IP address Standard SKU supports zones and has SLA guarantees Basic SKU does not support zones.
        :param zones: Availability zones for the public IP address Only supported with Standard SKU.
        '''
        if isinstance(lifecycle, dict):
            lifecycle = _cdktf_9a9027ec.TerraformResourceLifecycle(**lifecycle)
        if isinstance(monitoring, dict):
            monitoring = _MonitoringConfig_7c28df74(**monitoring)
        if isinstance(dns_settings, dict):
            dns_settings = _PublicIPAddressDnsSettings_d3ef5a04(**dns_settings)
        if isinstance(sku, dict):
            sku = _PublicIPAddressSku_00870b2b(**sku)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d2fbbe2222753076e7e89f45db902e0ef226bccf28d39dc640b4460d09f9a369)
            check_type(argname="argument connection", value=connection, expected_type=type_hints["connection"])
            check_type(argname="argument count", value=count, expected_type=type_hints["count"])
            check_type(argname="argument depends_on", value=depends_on, expected_type=type_hints["depends_on"])
            check_type(argname="argument for_each", value=for_each, expected_type=type_hints["for_each"])
            check_type(argname="argument lifecycle", value=lifecycle, expected_type=type_hints["lifecycle"])
            check_type(argname="argument provider", value=provider, expected_type=type_hints["provider"])
            check_type(argname="argument provisioners", value=provisioners, expected_type=type_hints["provisioners"])
            check_type(argname="argument api_version", value=api_version, expected_type=type_hints["api_version"])
            check_type(argname="argument enable_migration_analysis", value=enable_migration_analysis, expected_type=type_hints["enable_migration_analysis"])
            check_type(argname="argument enable_transformation", value=enable_transformation, expected_type=type_hints["enable_transformation"])
            check_type(argname="argument enable_validation", value=enable_validation, expected_type=type_hints["enable_validation"])
            check_type(argname="argument location", value=location, expected_type=type_hints["location"])
            check_type(argname="argument monitoring", value=monitoring, expected_type=type_hints["monitoring"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument dns_settings", value=dns_settings, expected_type=type_hints["dns_settings"])
            check_type(argname="argument idle_timeout_in_minutes", value=idle_timeout_in_minutes, expected_type=type_hints["idle_timeout_in_minutes"])
            check_type(argname="argument ignore_changes", value=ignore_changes, expected_type=type_hints["ignore_changes"])
            check_type(argname="argument public_ip_address_version", value=public_ip_address_version, expected_type=type_hints["public_ip_address_version"])
            check_type(argname="argument public_ip_allocation_method", value=public_ip_allocation_method, expected_type=type_hints["public_ip_allocation_method"])
            check_type(argname="argument resource_group_id", value=resource_group_id, expected_type=type_hints["resource_group_id"])
            check_type(argname="argument sku", value=sku, expected_type=type_hints["sku"])
            check_type(argname="argument zones", value=zones, expected_type=type_hints["zones"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if connection is not None:
            self._values["connection"] = connection
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if for_each is not None:
            self._values["for_each"] = for_each
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider
        if provisioners is not None:
            self._values["provisioners"] = provisioners
        if api_version is not None:
            self._values["api_version"] = api_version
        if enable_migration_analysis is not None:
            self._values["enable_migration_analysis"] = enable_migration_analysis
        if enable_transformation is not None:
            self._values["enable_transformation"] = enable_transformation
        if enable_validation is not None:
            self._values["enable_validation"] = enable_validation
        if location is not None:
            self._values["location"] = location
        if monitoring is not None:
            self._values["monitoring"] = monitoring
        if name is not None:
            self._values["name"] = name
        if tags is not None:
            self._values["tags"] = tags
        if dns_settings is not None:
            self._values["dns_settings"] = dns_settings
        if idle_timeout_in_minutes is not None:
            self._values["idle_timeout_in_minutes"] = idle_timeout_in_minutes
        if ignore_changes is not None:
            self._values["ignore_changes"] = ignore_changes
        if public_ip_address_version is not None:
            self._values["public_ip_address_version"] = public_ip_address_version
        if public_ip_allocation_method is not None:
            self._values["public_ip_allocation_method"] = public_ip_allocation_method
        if resource_group_id is not None:
            self._values["resource_group_id"] = resource_group_id
        if sku is not None:
            self._values["sku"] = sku
        if zones is not None:
            self._values["zones"] = zones

    @builtins.property
    def connection(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("connection")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]], result)

    @builtins.property
    def count(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]], result)

    @builtins.property
    def depends_on(
        self,
    ) -> typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]], result)

    @builtins.property
    def for_each(self) -> typing.Optional[_cdktf_9a9027ec.ITerraformIterator]:
        '''
        :stability: experimental
        '''
        result = self._values.get("for_each")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.ITerraformIterator], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[_cdktf_9a9027ec.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformProvider], result)

    @builtins.property
    def provisioners(
        self,
    ) -> typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provisioners")
        return typing.cast(typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]], result)

    @builtins.property
    def api_version(self) -> typing.Optional[builtins.str]:
        '''Explicit API version to use for this resource.

        If not specified, the latest active version will be automatically resolved.
        Use this for version pinning when stability is required over latest features.

        :default: Latest active version from ApiVersionManager

        Example::

            "2024-11-01"
        '''
        result = self._values.get("api_version")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def enable_migration_analysis(self) -> typing.Optional[builtins.bool]:
        '''Whether to enable migration analysis warnings.

        When true, the framework will analyze the current version for deprecation
        status and provide migration recommendations in the deployment output.

        :default: true
        '''
        result = self._values.get("enable_migration_analysis")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_transformation(self) -> typing.Optional[builtins.bool]:
        '''Whether to apply property transformations automatically.

        When true, properties will be automatically transformed according to the
        target schema's transformation rules. This enables backward compatibility.

        :default: true
        '''
        result = self._values.get("enable_transformation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_validation(self) -> typing.Optional[builtins.bool]:
        '''Whether to validate properties against the schema.

        When true, all properties will be validated against the API schema before
        resource creation. Validation errors will cause deployment failures.

        :default: true
        '''
        result = self._values.get("enable_validation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def location(self) -> typing.Optional[builtins.str]:
        '''The location where the resource should be created.

        :default: Varies by resource type - see specific resource documentation

        :remarks:

        Location handling varies by resource type:

        - **Top-level resources**: Most require an explicit location (e.g., "eastus", "westus")
        - **Global resources**: Some use "global" as location (e.g., Private DNS Zones)
        - **Child resources**: Inherit location from parent and should NOT set this property

        Each resource type may provide its own default through the ``resolveLocation()`` method.
        If no location is specified and no default exists, resource creation may fail.

        Example::

            // Child resource (Subnet) - do not set location
            // location: undefined (inherited from parent Virtual Network)
        '''
        result = self._values.get("location")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def monitoring(self) -> typing.Optional[_MonitoringConfig_7c28df74]:
        '''Monitoring configuration for this resource.

        Enables integrated monitoring with diagnostic settings, metric alerts,
        and activity log alerts. All monitoring is optional and disabled by default.

        Example::

            monitoring: {
              enabled: true,
              diagnosticSettings: {
                workspaceId: logAnalytics.id,
                metrics: ['AllMetrics'],
                logs: ['AuditLogs']
              },
              metricAlerts: [{
                name: 'high-cpu-alert',
                severity: 2,
                scopes: [], // Automatically set to this resource
                criteria: { ... },
                actions: [{ actionGroupId: actionGroup.id }]
              }]
            }
        '''
        result = self._values.get("monitoring")
        return typing.cast(typing.Optional[_MonitoringConfig_7c28df74], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the resource.'''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Tags to apply to the resource.'''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def dns_settings(self) -> typing.Optional[_PublicIPAddressDnsSettings_d3ef5a04]:
        '''DNS settings for the public IP address Optional - configures DNS label for the public IP.'''
        result = self._values.get("dns_settings")
        return typing.cast(typing.Optional[_PublicIPAddressDnsSettings_d3ef5a04], result)

    @builtins.property
    def idle_timeout_in_minutes(self) -> typing.Optional[jsii.Number]:
        '''Idle timeout in minutes Valid range: 4-30 minutes.

        :default: 4
        '''
        result = self._values.get("idle_timeout_in_minutes")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def ignore_changes(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The lifecycle rules to ignore changes Useful for properties that are externally managed.

        Example::

            ["tags"]
        '''
        result = self._values.get("ignore_changes")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def public_ip_address_version(self) -> typing.Optional[builtins.str]:
        '''Public IP address version.

        :default: "IPv4"
        '''
        result = self._values.get("public_ip_address_version")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def public_ip_allocation_method(self) -> typing.Optional[builtins.str]:
        '''Public IP allocation method - Static: IP address is allocated immediately and doesn't change - Dynamic: IP address is allocated when associated with a resource Note: Standard SKU requires Static allocation.

        :default: "Dynamic"
        '''
        result = self._values.get("public_ip_allocation_method")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def resource_group_id(self) -> typing.Optional[builtins.str]:
        '''Resource group ID where the Public IP will be created Optional - will use the subscription scope if not provided.'''
        result = self._values.get("resource_group_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def sku(self) -> typing.Optional[_PublicIPAddressSku_00870b2b]:
        '''SKU of the public IP address Standard SKU supports zones and has SLA guarantees Basic SKU does not support zones.'''
        result = self._values.get("sku")
        return typing.cast(typing.Optional[_PublicIPAddressSku_00870b2b], result)

    @builtins.property
    def zones(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Availability zones for the public IP address Only supported with Standard SKU.

        Example::

            ["1"], ["2"], ["3"], ["1", "2", "3"]
        '''
        result = self._values.get("zones")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "PublicIPAddressProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.PublicIPAddressSku",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "tier": "tier"},
)
class PublicIPAddressSku:
    def __init__(
        self,
        *,
        name: builtins.str,
        tier: typing.Optional[builtins.str] = None,
    ) -> None:
        '''SKU configuration for Public IP Address.

        :param name: Name of the SKU.
        :param tier: Tier of the SKU.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5547f3c5345d103f57b7971fc8305a522920acdaf12309e272a3f667c2fc978d)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument tier", value=tier, expected_type=type_hints["tier"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if tier is not None:
            self._values["tier"] = tier

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of the SKU.

        Example::

            "Basic", "Standard"
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def tier(self) -> typing.Optional[builtins.str]:
        '''Tier of the SKU.

        Example::

            "Regional", "Global"
        '''
        result = self._values.get("tier")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "PublicIPAddressSku(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.PublicIPDnsSettings",
    jsii_struct_bases=[],
    name_mapping={"domain_name_label": "domainNameLabel"},
)
class PublicIPDnsSettings:
    def __init__(self, *, domain_name_label: builtins.str) -> None:
        '''DNS settings for public IP.

        :param domain_name_label: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__145c9c955d12d6a133f90260230ef0309c9fb578c896d0c37f0d156d19c4d2a4)
            check_type(argname="argument domain_name_label", value=domain_name_label, expected_type=type_hints["domain_name_label"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "domain_name_label": domain_name_label,
        }

    @builtins.property
    def domain_name_label(self) -> builtins.str:
        result = self._values.get("domain_name_label")
        assert result is not None, "Required property 'domain_name_label' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "PublicIPDnsSettings(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class Resource(
    _cdktf_9a9027ec.TerraformResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@microsoft/terraform-cdk-constructs.Resource",
):
    '''Represents a {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource azapi_resource}.'''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        type: builtins.str,
        body: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        create_headers: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        create_query_parameters: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.Sequence[builtins.str]]]] = None,
        delete_headers: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        delete_query_parameters: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.Sequence[builtins.str]]]] = None,
        identity: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ResourceIdentity", typing.Dict[builtins.str, typing.Any]]]]] = None,
        ignore_casing: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        ignore_missing_property: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        ignore_null_property: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        location: typing.Optional[builtins.str] = None,
        locks: typing.Optional[typing.Sequence[builtins.str]] = None,
        name: typing.Optional[builtins.str] = None,
        parent_id: typing.Optional[builtins.str] = None,
        read_headers: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        read_query_parameters: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.Sequence[builtins.str]]]] = None,
        replace_triggers_external_values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        replace_triggers_refs: typing.Optional[typing.Sequence[builtins.str]] = None,
        response_export_values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        retry: typing.Optional[typing.Union["ResourceRetry", typing.Dict[builtins.str, typing.Any]]] = None,
        schema_validation_enabled: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        sensitive_body: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        sensitive_body_version: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        timeouts: typing.Optional[typing.Union["ResourceTimeouts", typing.Dict[builtins.str, typing.Any]]] = None,
        update_headers: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        update_query_parameters: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.Sequence[builtins.str]]]] = None,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> None:
        '''Create a new {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource azapi_resource} Resource.

        :param scope: The scope in which to define this construct.
        :param id: The scoped construct ID. Must be unique amongst siblings in the same scope
        :param type: In a format like ``<resource-type>@<api-version>``. ``<resource-type>`` is the Azure resource type, for example, ``Microsoft.Storage/storageAccounts``. ``<api-version>`` is version of the API used to manage this azure resource. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#type Resource#type}
        :param body: A dynamic attribute that contains the request body. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#body Resource#body}
        :param create_headers: A mapping of headers to be sent with the create request. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#create_headers Resource#create_headers}
        :param create_query_parameters: A mapping of query parameters to be sent with the create request. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#create_query_parameters Resource#create_query_parameters}
        :param delete_headers: A mapping of headers to be sent with the delete request. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#delete_headers Resource#delete_headers}
        :param delete_query_parameters: A mapping of query parameters to be sent with the delete request. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#delete_query_parameters Resource#delete_query_parameters}
        :param identity: identity block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#identity Resource#identity}
        :param ignore_casing: Whether ignore the casing of the property names in the response body. Defaults to ``false``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#ignore_casing Resource#ignore_casing}
        :param ignore_missing_property: Whether ignore not returned properties like credentials in ``body`` to suppress plan-diff. Defaults to ``true``. It's recommend to enable this option when some sensitive properties are not returned in response body, instead of setting them in ``lifecycle.ignore_changes`` because it will make the sensitive fields unable to update. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#ignore_missing_property Resource#ignore_missing_property}
        :param ignore_null_property: When set to ``true``, the provider will ignore properties whose values are ``null`` in the ``body``. These properties will not be included in the request body sent to the API, and the difference will not be shown in the plan output. Defaults to ``false``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#ignore_null_property Resource#ignore_null_property}
        :param location: The location of the Azure resource. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#location Resource#location}
        :param locks: A list of ARM resource IDs which are used to avoid create/modify/delete azapi resources at the same time. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#locks Resource#locks}
        :param name: Specifies the name of the azure resource. Changing this forces a new resource to be created. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#name Resource#name}
        :param parent_id: The ID of the azure resource in which this resource is created. It supports different kinds of deployment scope for **top level** resources: - resource group scope: ``parent_id`` should be the ID of a resource group, it's recommended to manage a resource group by azurerm_resource_group. - management group scope: ``parent_id`` should be the ID of a management group, it's recommended to manage a management group by azurerm_management_group. - extension scope: ``parent_id`` should be the ID of the resource you're adding the extension to. - subscription scope: ``parent_id`` should be like \\x60/subscriptions/00000000-0000-0000-0000-000000000000\\x60 - tenant scope: ``parent_id`` should be / For child level resources, the ``parent_id`` should be the ID of its parent resource, for example, subnet resource's ``parent_id`` is the ID of the vnet. For type ``Microsoft.Resources/resourceGroups``, the ``parent_id`` could be omitted, it defaults to subscription ID specified in provider or the default subscription (You could check the default subscription by azure cli command: ``az account show``). Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#parent_id Resource#parent_id}
        :param read_headers: A mapping of headers to be sent with the read request. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#read_headers Resource#read_headers}
        :param read_query_parameters: A mapping of query parameters to be sent with the read request. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#read_query_parameters Resource#read_query_parameters}
        :param replace_triggers_external_values: Will trigger a replace of the resource when the value changes and is not ``null``. This can be used by practitioners to force a replace of the resource when certain values change, e.g. changing the SKU of a virtual machine based on the value of variables or locals. The value is a ``dynamic``, so practitioners can compose the input however they wish. For a "break glass" set the value to ``null`` to prevent the plan modifier taking effect. If you have ``null`` values that you do want to be tracked as affecting the resource replacement, include these inside an object. Advanced use cases are possible and resource replacement can be triggered by values external to the resource, for example when a dependent resource changes. e.g. to replace a resource when either the SKU or os_type attributes change:: resource "azapi_resource" "example" { name = var.name type = "Microsoft.Network/publicIPAddresses@2023-11-01" parent_id = "/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/example" body = { properties = { sku = var.sku zones = var.zones } } replace_triggers_external_values = [ var.sku, var.zones, ] } Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#replace_triggers_external_values Resource#replace_triggers_external_values}
        :param replace_triggers_refs: A list of paths in the current Terraform configuration. When the values at these paths change, the resource will be replaced. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#replace_triggers_refs Resource#replace_triggers_refs}
        :param response_export_values: The attribute can accept either a list or a map. - **List**: A list of paths that need to be exported from the response body. Setting it to ``["*"]`` will export the full response body. Here's an example. If it sets to ``["properties.loginServer", "properties.policies.quarantinePolicy.status"]``, it will set the following HCL object to the computed property output:: { properties = { loginServer = "registry1.azurecr.io" policies = { quarantinePolicy = { status = "disabled" } } } } - **Map**: A map where the key is the name for the result and the value is a JMESPath query string to filter the response. Here's an example. If it sets to ``{"login_server": "properties.loginServer", "quarantine_status": "properties.policies.quarantinePolicy.status"}``, it will set the following HCL object to the computed property output:: { "login_server" = "registry1.azurecr.io" "quarantine_status" = "disabled" } To learn more about JMESPath, visit `JMESPath <https://jmespath.org/>`_. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#response_export_values Resource#response_export_values}
        :param retry: The retry object supports the following attributes:. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#retry Resource#retry}
        :param schema_validation_enabled: Whether enabled the validation on ``type`` and ``body`` with embedded schema. Defaults to ``true``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#schema_validation_enabled Resource#schema_validation_enabled}
        :param sensitive_body: A dynamic attribute that contains the write-only properties of the request body. This will be merge-patched to the body to construct the actual request body. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#sensitive_body Resource#sensitive_body}
        :param sensitive_body_version: A map where the key is the path to the property in ``sensitive_body`` and the value is the version of the property. The key is a string in the format of ``path.to.property[index].subproperty``, where ``index`` is the index of the item in an array. When the version is changed, the property will be included in the request body, otherwise it will be omitted from the request body. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#sensitive_body_version Resource#sensitive_body_version}
        :param tags: A mapping of tags which should be assigned to the Azure resource. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#tags Resource#tags}
        :param timeouts: timeouts block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#timeouts Resource#timeouts}
        :param update_headers: A mapping of headers to be sent with the update request. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#update_headers Resource#update_headers}
        :param update_query_parameters: A mapping of query parameters to be sent with the update request. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#update_query_parameters Resource#update_query_parameters}
        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__360cf756a18f01faf6eea402730f531aef83cf5f1f419da649a2e9b5928d74ad)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        config = ResourceConfig(
            type=type,
            body=body,
            create_headers=create_headers,
            create_query_parameters=create_query_parameters,
            delete_headers=delete_headers,
            delete_query_parameters=delete_query_parameters,
            identity=identity,
            ignore_casing=ignore_casing,
            ignore_missing_property=ignore_missing_property,
            ignore_null_property=ignore_null_property,
            location=location,
            locks=locks,
            name=name,
            parent_id=parent_id,
            read_headers=read_headers,
            read_query_parameters=read_query_parameters,
            replace_triggers_external_values=replace_triggers_external_values,
            replace_triggers_refs=replace_triggers_refs,
            response_export_values=response_export_values,
            retry=retry,
            schema_validation_enabled=schema_validation_enabled,
            sensitive_body=sensitive_body,
            sensitive_body_version=sensitive_body_version,
            tags=tags,
            timeouts=timeouts,
            update_headers=update_headers,
            update_query_parameters=update_query_parameters,
            connection=connection,
            count=count,
            depends_on=depends_on,
            for_each=for_each,
            lifecycle=lifecycle,
            provider=provider,
            provisioners=provisioners,
        )

        jsii.create(self.__class__, self, [scope, id, config])

    @jsii.member(jsii_name="generateConfigForImport")
    @builtins.classmethod
    def generate_config_for_import(
        cls,
        scope: _constructs_77d1e7e8.Construct,
        import_to_id: builtins.str,
        import_from_id: builtins.str,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    ) -> _cdktf_9a9027ec.ImportableResource:
        '''Generates CDKTF code for importing a Resource resource upon running "cdktf plan ".

        :param scope: The scope in which to define this construct.
        :param import_to_id: The construct id used in the generated config for the Resource to import.
        :param import_from_id: The id of the existing Resource that should be imported. Refer to the {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#import import section} in the documentation of this resource for the id to use
        :param provider: ? Optional instance of the provider where the Resource to import is found.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__edff1d2f5265b2950973771424e150a68c06c9041437e44ee8be96cb9b192995)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument import_to_id", value=import_to_id, expected_type=type_hints["import_to_id"])
            check_type(argname="argument import_from_id", value=import_from_id, expected_type=type_hints["import_from_id"])
            check_type(argname="argument provider", value=provider, expected_type=type_hints["provider"])
        return typing.cast(_cdktf_9a9027ec.ImportableResource, jsii.sinvoke(cls, "generateConfigForImport", [scope, import_to_id, import_from_id, provider]))

    @jsii.member(jsii_name="putIdentity")
    def put_identity(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ResourceIdentity", typing.Dict[builtins.str, typing.Any]]]],
    ) -> None:
        '''
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6f150919e21a56a085faf5046991755e5048d66d84d4b475e7fe138f81dbc7be)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "putIdentity", [value]))

    @jsii.member(jsii_name="putRetry")
    def put_retry(
        self,
        *,
        error_message_regex: typing.Sequence[builtins.str],
        interval_seconds: typing.Optional[jsii.Number] = None,
        max_interval_seconds: typing.Optional[jsii.Number] = None,
        multiplier: typing.Optional[jsii.Number] = None,
        randomization_factor: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param error_message_regex: A list of regular expressions to match against error messages. If any of the regular expressions match, the request will be retried. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#error_message_regex Resource#error_message_regex}
        :param interval_seconds: The base number of seconds to wait between retries. Default is ``10``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#interval_seconds Resource#interval_seconds}
        :param max_interval_seconds: The maximum number of seconds to wait between retries. Default is ``180``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#max_interval_seconds Resource#max_interval_seconds}
        :param multiplier: The multiplier to apply to the interval between retries. Default is ``1.5``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#multiplier Resource#multiplier}
        :param randomization_factor: The randomization factor to apply to the interval between retries. The formula for the randomized interval is: ``RetryInterval * (random value in range [1 - RandomizationFactor, 1 + RandomizationFactor])``. Therefore set to zero ``0.0`` for no randomization. Default is ``0.5``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#randomization_factor Resource#randomization_factor}
        '''
        value = ResourceRetry(
            error_message_regex=error_message_regex,
            interval_seconds=interval_seconds,
            max_interval_seconds=max_interval_seconds,
            multiplier=multiplier,
            randomization_factor=randomization_factor,
        )

        return typing.cast(None, jsii.invoke(self, "putRetry", [value]))

    @jsii.member(jsii_name="putTimeouts")
    def put_timeouts(
        self,
        *,
        create: typing.Optional[builtins.str] = None,
        delete: typing.Optional[builtins.str] = None,
        read: typing.Optional[builtins.str] = None,
        update: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param create: A string that can be `parsed as a duration <https://pkg.go.dev/time#ParseDuration>`_ consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#create Resource#create}
        :param delete: A string that can be `parsed as a duration <https://pkg.go.dev/time#ParseDuration>`_ consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#delete Resource#delete}
        :param read: A string that can be `parsed as a duration <https://pkg.go.dev/time#ParseDuration>`_ consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#read Resource#read}
        :param update: A string that can be `parsed as a duration <https://pkg.go.dev/time#ParseDuration>`_ consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#update Resource#update}
        '''
        value = ResourceTimeouts(
            create=create, delete=delete, read=read, update=update
        )

        return typing.cast(None, jsii.invoke(self, "putTimeouts", [value]))

    @jsii.member(jsii_name="resetBody")
    def reset_body(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetBody", []))

    @jsii.member(jsii_name="resetCreateHeaders")
    def reset_create_headers(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCreateHeaders", []))

    @jsii.member(jsii_name="resetCreateQueryParameters")
    def reset_create_query_parameters(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCreateQueryParameters", []))

    @jsii.member(jsii_name="resetDeleteHeaders")
    def reset_delete_headers(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDeleteHeaders", []))

    @jsii.member(jsii_name="resetDeleteQueryParameters")
    def reset_delete_query_parameters(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDeleteQueryParameters", []))

    @jsii.member(jsii_name="resetIdentity")
    def reset_identity(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetIdentity", []))

    @jsii.member(jsii_name="resetIgnoreCasing")
    def reset_ignore_casing(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetIgnoreCasing", []))

    @jsii.member(jsii_name="resetIgnoreMissingProperty")
    def reset_ignore_missing_property(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetIgnoreMissingProperty", []))

    @jsii.member(jsii_name="resetIgnoreNullProperty")
    def reset_ignore_null_property(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetIgnoreNullProperty", []))

    @jsii.member(jsii_name="resetLocation")
    def reset_location(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetLocation", []))

    @jsii.member(jsii_name="resetLocks")
    def reset_locks(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetLocks", []))

    @jsii.member(jsii_name="resetName")
    def reset_name(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetName", []))

    @jsii.member(jsii_name="resetParentId")
    def reset_parent_id(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetParentId", []))

    @jsii.member(jsii_name="resetReadHeaders")
    def reset_read_headers(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetReadHeaders", []))

    @jsii.member(jsii_name="resetReadQueryParameters")
    def reset_read_query_parameters(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetReadQueryParameters", []))

    @jsii.member(jsii_name="resetReplaceTriggersExternalValues")
    def reset_replace_triggers_external_values(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetReplaceTriggersExternalValues", []))

    @jsii.member(jsii_name="resetReplaceTriggersRefs")
    def reset_replace_triggers_refs(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetReplaceTriggersRefs", []))

    @jsii.member(jsii_name="resetResponseExportValues")
    def reset_response_export_values(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetResponseExportValues", []))

    @jsii.member(jsii_name="resetRetry")
    def reset_retry(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRetry", []))

    @jsii.member(jsii_name="resetSchemaValidationEnabled")
    def reset_schema_validation_enabled(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSchemaValidationEnabled", []))

    @jsii.member(jsii_name="resetSensitiveBody")
    def reset_sensitive_body(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSensitiveBody", []))

    @jsii.member(jsii_name="resetSensitiveBodyVersion")
    def reset_sensitive_body_version(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSensitiveBodyVersion", []))

    @jsii.member(jsii_name="resetTags")
    def reset_tags(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTags", []))

    @jsii.member(jsii_name="resetTimeouts")
    def reset_timeouts(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTimeouts", []))

    @jsii.member(jsii_name="resetUpdateHeaders")
    def reset_update_headers(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetUpdateHeaders", []))

    @jsii.member(jsii_name="resetUpdateQueryParameters")
    def reset_update_query_parameters(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetUpdateQueryParameters", []))

    @jsii.member(jsii_name="synthesizeAttributes")
    def _synthesize_attributes(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "synthesizeAttributes", []))

    @jsii.member(jsii_name="synthesizeHclAttributes")
    def _synthesize_hcl_attributes(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "synthesizeHclAttributes", []))

    @jsii.python.classproperty
    @jsii.member(jsii_name="tfResourceType")
    def TF_RESOURCE_TYPE(cls) -> builtins.str:
        return typing.cast(builtins.str, jsii.sget(cls, "tfResourceType"))

    @builtins.property
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @builtins.property
    @jsii.member(jsii_name="identity")
    def identity(self) -> "ResourceIdentityList":
        return typing.cast("ResourceIdentityList", jsii.get(self, "identity"))

    @builtins.property
    @jsii.member(jsii_name="output")
    def output(self) -> _cdktf_9a9027ec.AnyMap:
        return typing.cast(_cdktf_9a9027ec.AnyMap, jsii.get(self, "output"))

    @builtins.property
    @jsii.member(jsii_name="retry")
    def retry(self) -> "ResourceRetryOutputReference":
        return typing.cast("ResourceRetryOutputReference", jsii.get(self, "retry"))

    @builtins.property
    @jsii.member(jsii_name="timeouts")
    def timeouts(self) -> "ResourceTimeoutsOutputReference":
        return typing.cast("ResourceTimeoutsOutputReference", jsii.get(self, "timeouts"))

    @builtins.property
    @jsii.member(jsii_name="bodyInput")
    def body_input(self) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], jsii.get(self, "bodyInput"))

    @builtins.property
    @jsii.member(jsii_name="createHeadersInput")
    def create_headers_input(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], jsii.get(self, "createHeadersInput"))

    @builtins.property
    @jsii.member(jsii_name="createQueryParametersInput")
    def create_query_parameters_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.List[builtins.str]]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.List[builtins.str]]]], jsii.get(self, "createQueryParametersInput"))

    @builtins.property
    @jsii.member(jsii_name="deleteHeadersInput")
    def delete_headers_input(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], jsii.get(self, "deleteHeadersInput"))

    @builtins.property
    @jsii.member(jsii_name="deleteQueryParametersInput")
    def delete_query_parameters_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.List[builtins.str]]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.List[builtins.str]]]], jsii.get(self, "deleteQueryParametersInput"))

    @builtins.property
    @jsii.member(jsii_name="identityInput")
    def identity_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ResourceIdentity"]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ResourceIdentity"]]], jsii.get(self, "identityInput"))

    @builtins.property
    @jsii.member(jsii_name="ignoreCasingInput")
    def ignore_casing_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "ignoreCasingInput"))

    @builtins.property
    @jsii.member(jsii_name="ignoreMissingPropertyInput")
    def ignore_missing_property_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "ignoreMissingPropertyInput"))

    @builtins.property
    @jsii.member(jsii_name="ignoreNullPropertyInput")
    def ignore_null_property_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "ignoreNullPropertyInput"))

    @builtins.property
    @jsii.member(jsii_name="locationInput")
    def location_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "locationInput"))

    @builtins.property
    @jsii.member(jsii_name="locksInput")
    def locks_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "locksInput"))

    @builtins.property
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nameInput"))

    @builtins.property
    @jsii.member(jsii_name="parentIdInput")
    def parent_id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "parentIdInput"))

    @builtins.property
    @jsii.member(jsii_name="readHeadersInput")
    def read_headers_input(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], jsii.get(self, "readHeadersInput"))

    @builtins.property
    @jsii.member(jsii_name="readQueryParametersInput")
    def read_query_parameters_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.List[builtins.str]]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.List[builtins.str]]]], jsii.get(self, "readQueryParametersInput"))

    @builtins.property
    @jsii.member(jsii_name="replaceTriggersExternalValuesInput")
    def replace_triggers_external_values_input(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], jsii.get(self, "replaceTriggersExternalValuesInput"))

    @builtins.property
    @jsii.member(jsii_name="replaceTriggersRefsInput")
    def replace_triggers_refs_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "replaceTriggersRefsInput"))

    @builtins.property
    @jsii.member(jsii_name="responseExportValuesInput")
    def response_export_values_input(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], jsii.get(self, "responseExportValuesInput"))

    @builtins.property
    @jsii.member(jsii_name="retryInput")
    def retry_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, "ResourceRetry"]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, "ResourceRetry"]], jsii.get(self, "retryInput"))

    @builtins.property
    @jsii.member(jsii_name="schemaValidationEnabledInput")
    def schema_validation_enabled_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "schemaValidationEnabledInput"))

    @builtins.property
    @jsii.member(jsii_name="sensitiveBodyInput")
    def sensitive_body_input(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], jsii.get(self, "sensitiveBodyInput"))

    @builtins.property
    @jsii.member(jsii_name="sensitiveBodyVersionInput")
    def sensitive_body_version_input(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], jsii.get(self, "sensitiveBodyVersionInput"))

    @builtins.property
    @jsii.member(jsii_name="tagsInput")
    def tags_input(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], jsii.get(self, "tagsInput"))

    @builtins.property
    @jsii.member(jsii_name="timeoutsInput")
    def timeouts_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, "ResourceTimeouts"]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, "ResourceTimeouts"]], jsii.get(self, "timeoutsInput"))

    @builtins.property
    @jsii.member(jsii_name="typeInput")
    def type_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "typeInput"))

    @builtins.property
    @jsii.member(jsii_name="updateHeadersInput")
    def update_headers_input(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], jsii.get(self, "updateHeadersInput"))

    @builtins.property
    @jsii.member(jsii_name="updateQueryParametersInput")
    def update_query_parameters_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.List[builtins.str]]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.List[builtins.str]]]], jsii.get(self, "updateQueryParametersInput"))

    @builtins.property
    @jsii.member(jsii_name="body")
    def body(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "body"))

    @body.setter
    def body(self, value: typing.Mapping[builtins.str, typing.Any]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__98edd861ded07fa7bbcb64cbb23535c57c7912b9ea044420e57e4ab49aa2f676)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "body", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="createHeaders")
    def create_headers(self) -> typing.Mapping[builtins.str, builtins.str]:
        return typing.cast(typing.Mapping[builtins.str, builtins.str], jsii.get(self, "createHeaders"))

    @create_headers.setter
    def create_headers(self, value: typing.Mapping[builtins.str, builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e5bc5a1a4b0c645ec8f5b08757f4da96be098885bb6fcc8a04471cf13ccd1974)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "createHeaders", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="createQueryParameters")
    def create_query_parameters(
        self,
    ) -> typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.List[builtins.str]]]:
        return typing.cast(typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.List[builtins.str]]], jsii.get(self, "createQueryParameters"))

    @create_query_parameters.setter
    def create_query_parameters(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.List[builtins.str]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1b0cb7f0c1c1b9b4eafd1bb02195514e3a9b02c438cdf43b145ba46350d14af9)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "createQueryParameters", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="deleteHeaders")
    def delete_headers(self) -> typing.Mapping[builtins.str, builtins.str]:
        return typing.cast(typing.Mapping[builtins.str, builtins.str], jsii.get(self, "deleteHeaders"))

    @delete_headers.setter
    def delete_headers(self, value: typing.Mapping[builtins.str, builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0b854cd284c7651abfa4dca18251d596d0ac808fa1daeb955602022f1d36881f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "deleteHeaders", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="deleteQueryParameters")
    def delete_query_parameters(
        self,
    ) -> typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.List[builtins.str]]]:
        return typing.cast(typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.List[builtins.str]]], jsii.get(self, "deleteQueryParameters"))

    @delete_query_parameters.setter
    def delete_query_parameters(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.List[builtins.str]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__af650baa6c89b699d2aaeb9dae047a1ab73f14735ea5566040864cc31b9a10de)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "deleteQueryParameters", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="ignoreCasing")
    def ignore_casing(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "ignoreCasing"))

    @ignore_casing.setter
    def ignore_casing(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7c330a3da38779fdfde9ce7876aee87039a107dd1abf1ad4a70965d7f6ac24c6)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "ignoreCasing", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="ignoreMissingProperty")
    def ignore_missing_property(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "ignoreMissingProperty"))

    @ignore_missing_property.setter
    def ignore_missing_property(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__45eb6abb157ab6d63e1946c17ac812308f7b4d3d395a192022c6b5672892d0c7)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "ignoreMissingProperty", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="ignoreNullProperty")
    def ignore_null_property(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "ignoreNullProperty"))

    @ignore_null_property.setter
    def ignore_null_property(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4f29ee916ad478f0f1c3d6eec138b84bc516b8bbf1688f25c659ac0a959395ec)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "ignoreNullProperty", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="location")
    def location(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "location"))

    @location.setter
    def location(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__40de70c0c8f1eff71f3465ca96a211867eda879e736c0cdd0dd8721bf2d5eae8)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "location", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="locks")
    def locks(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "locks"))

    @locks.setter
    def locks(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__41946711b488d86ee4066511bd326ba8fae0292a07da47b826ea818e435cc601)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "locks", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9e8c2a738ac0a7e986617e7c476e73a630939a10ea67d5631700063935a529e3)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "name", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="parentId")
    def parent_id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "parentId"))

    @parent_id.setter
    def parent_id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4702438dc870ea43d45f3b2e9b7d7e15df9b998e7e4eb78bd0ab2f3165f95998)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "parentId", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="readHeaders")
    def read_headers(self) -> typing.Mapping[builtins.str, builtins.str]:
        return typing.cast(typing.Mapping[builtins.str, builtins.str], jsii.get(self, "readHeaders"))

    @read_headers.setter
    def read_headers(self, value: typing.Mapping[builtins.str, builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__38d805fbcbb389aafed2b0a7e878ea19eaa04ace49cc995fbe48daad165cf782)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "readHeaders", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="readQueryParameters")
    def read_query_parameters(
        self,
    ) -> typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.List[builtins.str]]]:
        return typing.cast(typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.List[builtins.str]]], jsii.get(self, "readQueryParameters"))

    @read_query_parameters.setter
    def read_query_parameters(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.List[builtins.str]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f8604726bdf155a156d6c5024a7ec71e5a60cd842b7b9edf9ef6891e8bde8be5)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "readQueryParameters", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="replaceTriggersExternalValues")
    def replace_triggers_external_values(
        self,
    ) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "replaceTriggersExternalValues"))

    @replace_triggers_external_values.setter
    def replace_triggers_external_values(
        self,
        value: typing.Mapping[builtins.str, typing.Any],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3d60c8fdfa7bcf46fee2e9e31f278fe66ee35ff6a452d2cd492b936672bf08df)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "replaceTriggersExternalValues", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="replaceTriggersRefs")
    def replace_triggers_refs(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "replaceTriggersRefs"))

    @replace_triggers_refs.setter
    def replace_triggers_refs(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c3ba278ec6bc25bc8f200ac1f3aad8f7e7278ebb9ed40968b75dc5924cc2f86a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "replaceTriggersRefs", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="responseExportValues")
    def response_export_values(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "responseExportValues"))

    @response_export_values.setter
    def response_export_values(
        self,
        value: typing.Mapping[builtins.str, typing.Any],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b141e7bfa993c4527bb95583fb32e65e1c81ec037a0f4c87ba003e74231a0335)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "responseExportValues", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="schemaValidationEnabled")
    def schema_validation_enabled(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "schemaValidationEnabled"))

    @schema_validation_enabled.setter
    def schema_validation_enabled(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3988d4dcdc80fe58d6bfe5b0833246562b217d8f9103298f3c08cf563ac4e6ab)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "schemaValidationEnabled", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="sensitiveBody")
    def sensitive_body(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "sensitiveBody"))

    @sensitive_body.setter
    def sensitive_body(self, value: typing.Mapping[builtins.str, typing.Any]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a823ed51d1ce9ba6c69a4c8b3a7c22a9c794ed9aaf9df9b3d97fb6b3ea0a36d5)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "sensitiveBody", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="sensitiveBodyVersion")
    def sensitive_body_version(self) -> typing.Mapping[builtins.str, builtins.str]:
        return typing.cast(typing.Mapping[builtins.str, builtins.str], jsii.get(self, "sensitiveBodyVersion"))

    @sensitive_body_version.setter
    def sensitive_body_version(
        self,
        value: typing.Mapping[builtins.str, builtins.str],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__837e68941d7639aceeb0dcd7db90ae3688b8ce5c6711934421026b3538e55f54)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "sensitiveBodyVersion", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="tags")
    def tags(self) -> typing.Mapping[builtins.str, builtins.str]:
        return typing.cast(typing.Mapping[builtins.str, builtins.str], jsii.get(self, "tags"))

    @tags.setter
    def tags(self, value: typing.Mapping[builtins.str, builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a6889b4d7b37bf070255471d414ce1869f19c41af6a3132e05b7ae71ae022133)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "tags", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="type")
    def type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "type"))

    @type.setter
    def type(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__22aad63a3939465809abf1ce8416c25ba8fe259012c462900fcccb00d1b613fa)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "type", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="updateHeaders")
    def update_headers(self) -> typing.Mapping[builtins.str, builtins.str]:
        return typing.cast(typing.Mapping[builtins.str, builtins.str], jsii.get(self, "updateHeaders"))

    @update_headers.setter
    def update_headers(self, value: typing.Mapping[builtins.str, builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ca3eb787ce2c0134489014db653c496820e374931e9387e965898d0a3d74292f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "updateHeaders", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="updateQueryParameters")
    def update_query_parameters(
        self,
    ) -> typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.List[builtins.str]]]:
        return typing.cast(typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.List[builtins.str]]], jsii.get(self, "updateQueryParameters"))

    @update_query_parameters.setter
    def update_query_parameters(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.List[builtins.str]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__665b7816c8fb83eb81099827eba36497d576d48a89b25694c45b88f3faff00ea)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "updateQueryParameters", value) # pyright: ignore[reportArgumentType]


class ResourceAction(
    _cdktf_9a9027ec.TerraformResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@microsoft/terraform-cdk-constructs.ResourceAction",
):
    '''Represents a {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource_action azapi_resource_action}.'''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        resource_id: builtins.str,
        type: builtins.str,
        action: typing.Optional[builtins.str] = None,
        body: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        headers: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        locks: typing.Optional[typing.Sequence[builtins.str]] = None,
        method: typing.Optional[builtins.str] = None,
        query_parameters: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.Sequence[builtins.str]]]] = None,
        response_export_values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        retry: typing.Optional[typing.Union["ResourceActionRetry", typing.Dict[builtins.str, typing.Any]]] = None,
        sensitive_response_export_values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        timeouts: typing.Optional[typing.Union["ResourceActionTimeouts", typing.Dict[builtins.str, typing.Any]]] = None,
        when: typing.Optional[builtins.str] = None,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> None:
        '''Create a new {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource_action azapi_resource_action} Resource.

        :param scope: The scope in which to define this construct.
        :param id: The scoped construct ID. Must be unique amongst siblings in the same scope
        :param resource_id: The ID of an existing Azure source. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource_action#resource_id ResourceAction#resource_id}
        :param type: In a format like ``<resource-type>@<api-version>``. ``<resource-type>`` is the Azure resource type, for example, ``Microsoft.Storage/storageAccounts``. ``<api-version>`` is version of the API used to manage this azure resource. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource_action#type ResourceAction#type}
        :param action: The name of the resource action. It's also possible to make HTTP requests towards the resource ID if leave this field empty. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource_action#action ResourceAction#action}
        :param body: A dynamic attribute that contains the request body. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource_action#body ResourceAction#body}
        :param headers: A map of headers to include in the request. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource_action#headers ResourceAction#headers}
        :param locks: A list of ARM resource IDs which are used to avoid create/modify/delete azapi resources at the same time. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource_action#locks ResourceAction#locks}
        :param method: Specifies the HTTP method of the azure resource action. Allowed values are ``POST``, ``PATCH``, ``PUT`` and ``DELETE``. Defaults to ``POST``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource_action#method ResourceAction#method}
        :param query_parameters: A map of query parameters to include in the request. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource_action#query_parameters ResourceAction#query_parameters}
        :param response_export_values: The attribute can accept either a list or a map. - **List**: A list of paths that need to be exported from the response body. Setting it to ``["*"]`` will export the full response body. Here's an example. If it sets to ``["properties.loginServer", "properties.policies.quarantinePolicy.status"]``, it will set the following HCL object to the computed property output:: { properties = { loginServer = "registry1.azurecr.io" policies = { quarantinePolicy = { status = "disabled" } } } } - **Map**: A map where the key is the name for the result and the value is a JMESPath query string to filter the response. Here's an example. If it sets to ``{"login_server": "properties.loginServer", "quarantine_status": "properties.policies.quarantinePolicy.status"}``, it will set the following HCL object to the computed property output:: { "login_server" = "registry1.azurecr.io" "quarantine_status" = "disabled" } To learn more about JMESPath, visit `JMESPath <https://jmespath.org/>`_. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource_action#response_export_values ResourceAction#response_export_values}
        :param retry: The retry object supports the following attributes:. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource_action#retry ResourceAction#retry}
        :param sensitive_response_export_values: The attribute can accept either a list or a map. - **List**: A list of paths that need to be exported from the response body. Setting it to ``["*"]`` will export the full response body. Here's an example. If it sets to ``["properties.loginServer", "properties.policies.quarantinePolicy.status"]``, it will set the following HCL object to the computed property output:: { properties = { loginServer = "registry1.azurecr.io" policies = { quarantinePolicy = { status = "disabled" } } } } - **Map**: A map where the key is the name for the result and the value is a JMESPath query string to filter the response. Here's an example. If it sets to ``{"login_server": "properties.loginServer", "quarantine_status": "properties.policies.quarantinePolicy.status"}``, it will set the following HCL object to the computed property output:: { "login_server" = "registry1.azurecr.io" "quarantine_status" = "disabled" } To learn more about JMESPath, visit `JMESPath <https://jmespath.org/>`_. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource_action#sensitive_response_export_values ResourceAction#sensitive_response_export_values}
        :param timeouts: timeouts block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource_action#timeouts ResourceAction#timeouts}
        :param when: When to perform the action, value must be one of: ``apply``, ``destroy``. Default is ``apply``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource_action#when ResourceAction#when}
        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__da027795a53c827c06f63ae41ff835cffcd5a4ec2fddea4d23dd77566dcdced2)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        config = ResourceActionConfig(
            resource_id=resource_id,
            type=type,
            action=action,
            body=body,
            headers=headers,
            locks=locks,
            method=method,
            query_parameters=query_parameters,
            response_export_values=response_export_values,
            retry=retry,
            sensitive_response_export_values=sensitive_response_export_values,
            timeouts=timeouts,
            when=when,
            connection=connection,
            count=count,
            depends_on=depends_on,
            for_each=for_each,
            lifecycle=lifecycle,
            provider=provider,
            provisioners=provisioners,
        )

        jsii.create(self.__class__, self, [scope, id, config])

    @jsii.member(jsii_name="generateConfigForImport")
    @builtins.classmethod
    def generate_config_for_import(
        cls,
        scope: _constructs_77d1e7e8.Construct,
        import_to_id: builtins.str,
        import_from_id: builtins.str,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    ) -> _cdktf_9a9027ec.ImportableResource:
        '''Generates CDKTF code for importing a ResourceAction resource upon running "cdktf plan ".

        :param scope: The scope in which to define this construct.
        :param import_to_id: The construct id used in the generated config for the ResourceAction to import.
        :param import_from_id: The id of the existing ResourceAction that should be imported. Refer to the {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource_action#import import section} in the documentation of this resource for the id to use
        :param provider: ? Optional instance of the provider where the ResourceAction to import is found.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__29bc96a955f54b134c6e853a1b24de207626f1c35467a147d769bf69d5687b6c)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument import_to_id", value=import_to_id, expected_type=type_hints["import_to_id"])
            check_type(argname="argument import_from_id", value=import_from_id, expected_type=type_hints["import_from_id"])
            check_type(argname="argument provider", value=provider, expected_type=type_hints["provider"])
        return typing.cast(_cdktf_9a9027ec.ImportableResource, jsii.sinvoke(cls, "generateConfigForImport", [scope, import_to_id, import_from_id, provider]))

    @jsii.member(jsii_name="putRetry")
    def put_retry(
        self,
        *,
        error_message_regex: typing.Sequence[builtins.str],
        interval_seconds: typing.Optional[jsii.Number] = None,
        max_interval_seconds: typing.Optional[jsii.Number] = None,
        multiplier: typing.Optional[jsii.Number] = None,
        randomization_factor: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param error_message_regex: A list of regular expressions to match against error messages. If any of the regular expressions match, the request will be retried. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource_action#error_message_regex ResourceAction#error_message_regex}
        :param interval_seconds: The base number of seconds to wait between retries. Default is ``10``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource_action#interval_seconds ResourceAction#interval_seconds}
        :param max_interval_seconds: The maximum number of seconds to wait between retries. Default is ``180``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource_action#max_interval_seconds ResourceAction#max_interval_seconds}
        :param multiplier: The multiplier to apply to the interval between retries. Default is ``1.5``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource_action#multiplier ResourceAction#multiplier}
        :param randomization_factor: The randomization factor to apply to the interval between retries. The formula for the randomized interval is: ``RetryInterval * (random value in range [1 - RandomizationFactor, 1 + RandomizationFactor])``. Therefore set to zero ``0.0`` for no randomization. Default is ``0.5``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource_action#randomization_factor ResourceAction#randomization_factor}
        '''
        value = ResourceActionRetry(
            error_message_regex=error_message_regex,
            interval_seconds=interval_seconds,
            max_interval_seconds=max_interval_seconds,
            multiplier=multiplier,
            randomization_factor=randomization_factor,
        )

        return typing.cast(None, jsii.invoke(self, "putRetry", [value]))

    @jsii.member(jsii_name="putTimeouts")
    def put_timeouts(
        self,
        *,
        create: typing.Optional[builtins.str] = None,
        delete: typing.Optional[builtins.str] = None,
        read: typing.Optional[builtins.str] = None,
        update: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param create: A string that can be `parsed as a duration <https://pkg.go.dev/time#ParseDuration>`_ consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource_action#create ResourceAction#create}
        :param delete: A string that can be `parsed as a duration <https://pkg.go.dev/time#ParseDuration>`_ consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource_action#delete ResourceAction#delete}
        :param read: A string that can be `parsed as a duration <https://pkg.go.dev/time#ParseDuration>`_ consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource_action#read ResourceAction#read}
        :param update: A string that can be `parsed as a duration <https://pkg.go.dev/time#ParseDuration>`_ consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource_action#update ResourceAction#update}
        '''
        value = ResourceActionTimeouts(
            create=create, delete=delete, read=read, update=update
        )

        return typing.cast(None, jsii.invoke(self, "putTimeouts", [value]))

    @jsii.member(jsii_name="resetAction")
    def reset_action(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetAction", []))

    @jsii.member(jsii_name="resetBody")
    def reset_body(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetBody", []))

    @jsii.member(jsii_name="resetHeaders")
    def reset_headers(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetHeaders", []))

    @jsii.member(jsii_name="resetLocks")
    def reset_locks(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetLocks", []))

    @jsii.member(jsii_name="resetMethod")
    def reset_method(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMethod", []))

    @jsii.member(jsii_name="resetQueryParameters")
    def reset_query_parameters(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetQueryParameters", []))

    @jsii.member(jsii_name="resetResponseExportValues")
    def reset_response_export_values(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetResponseExportValues", []))

    @jsii.member(jsii_name="resetRetry")
    def reset_retry(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRetry", []))

    @jsii.member(jsii_name="resetSensitiveResponseExportValues")
    def reset_sensitive_response_export_values(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSensitiveResponseExportValues", []))

    @jsii.member(jsii_name="resetTimeouts")
    def reset_timeouts(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTimeouts", []))

    @jsii.member(jsii_name="resetWhen")
    def reset_when(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetWhen", []))

    @jsii.member(jsii_name="synthesizeAttributes")
    def _synthesize_attributes(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "synthesizeAttributes", []))

    @jsii.member(jsii_name="synthesizeHclAttributes")
    def _synthesize_hcl_attributes(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "synthesizeHclAttributes", []))

    @jsii.python.classproperty
    @jsii.member(jsii_name="tfResourceType")
    def TF_RESOURCE_TYPE(cls) -> builtins.str:
        return typing.cast(builtins.str, jsii.sget(cls, "tfResourceType"))

    @builtins.property
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @builtins.property
    @jsii.member(jsii_name="output")
    def output(self) -> _cdktf_9a9027ec.AnyMap:
        return typing.cast(_cdktf_9a9027ec.AnyMap, jsii.get(self, "output"))

    @builtins.property
    @jsii.member(jsii_name="retry")
    def retry(self) -> "ResourceActionRetryOutputReference":
        return typing.cast("ResourceActionRetryOutputReference", jsii.get(self, "retry"))

    @builtins.property
    @jsii.member(jsii_name="sensitiveOutput")
    def sensitive_output(self) -> _cdktf_9a9027ec.AnyMap:
        return typing.cast(_cdktf_9a9027ec.AnyMap, jsii.get(self, "sensitiveOutput"))

    @builtins.property
    @jsii.member(jsii_name="timeouts")
    def timeouts(self) -> "ResourceActionTimeoutsOutputReference":
        return typing.cast("ResourceActionTimeoutsOutputReference", jsii.get(self, "timeouts"))

    @builtins.property
    @jsii.member(jsii_name="actionInput")
    def action_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "actionInput"))

    @builtins.property
    @jsii.member(jsii_name="bodyInput")
    def body_input(self) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], jsii.get(self, "bodyInput"))

    @builtins.property
    @jsii.member(jsii_name="headersInput")
    def headers_input(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], jsii.get(self, "headersInput"))

    @builtins.property
    @jsii.member(jsii_name="locksInput")
    def locks_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "locksInput"))

    @builtins.property
    @jsii.member(jsii_name="methodInput")
    def method_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "methodInput"))

    @builtins.property
    @jsii.member(jsii_name="queryParametersInput")
    def query_parameters_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.List[builtins.str]]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.List[builtins.str]]]], jsii.get(self, "queryParametersInput"))

    @builtins.property
    @jsii.member(jsii_name="resourceIdInput")
    def resource_id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "resourceIdInput"))

    @builtins.property
    @jsii.member(jsii_name="responseExportValuesInput")
    def response_export_values_input(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], jsii.get(self, "responseExportValuesInput"))

    @builtins.property
    @jsii.member(jsii_name="retryInput")
    def retry_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, "ResourceActionRetry"]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, "ResourceActionRetry"]], jsii.get(self, "retryInput"))

    @builtins.property
    @jsii.member(jsii_name="sensitiveResponseExportValuesInput")
    def sensitive_response_export_values_input(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], jsii.get(self, "sensitiveResponseExportValuesInput"))

    @builtins.property
    @jsii.member(jsii_name="timeoutsInput")
    def timeouts_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, "ResourceActionTimeouts"]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, "ResourceActionTimeouts"]], jsii.get(self, "timeoutsInput"))

    @builtins.property
    @jsii.member(jsii_name="typeInput")
    def type_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "typeInput"))

    @builtins.property
    @jsii.member(jsii_name="whenInput")
    def when_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "whenInput"))

    @builtins.property
    @jsii.member(jsii_name="action")
    def action(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "action"))

    @action.setter
    def action(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e6cf10e33b1f20cd2e69e1c8e976bd035ef6b55b4ce733d91ee6d726e849ecd3)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "action", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="body")
    def body(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "body"))

    @body.setter
    def body(self, value: typing.Mapping[builtins.str, typing.Any]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__29829d45a45a8dab2ef641af59ea0c16d8cba8b01a5760d0aba179f21f37b581)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "body", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="headers")
    def headers(self) -> typing.Mapping[builtins.str, builtins.str]:
        return typing.cast(typing.Mapping[builtins.str, builtins.str], jsii.get(self, "headers"))

    @headers.setter
    def headers(self, value: typing.Mapping[builtins.str, builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9c649c2389d6150c86086659a272921793bdac1d01a17818729a718634d5f78c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "headers", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="locks")
    def locks(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "locks"))

    @locks.setter
    def locks(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ecface4d64f727299378773d22d6aad179566c3b318ab8fb886bf08c1109be0a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "locks", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="method")
    def method(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "method"))

    @method.setter
    def method(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a004d1d6767d31a29dfc6842432afb2b2c56123d78ad2d4dffe7443d09510de1)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "method", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="queryParameters")
    def query_parameters(
        self,
    ) -> typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.List[builtins.str]]]:
        return typing.cast(typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.List[builtins.str]]], jsii.get(self, "queryParameters"))

    @query_parameters.setter
    def query_parameters(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.List[builtins.str]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__75003ceeeba04467530caba827b8e3acf689d4f714b06fced16ecc43b42f4dba)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "queryParameters", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="resourceId")
    def resource_id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "resourceId"))

    @resource_id.setter
    def resource_id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__618428c81e64ca9dc3b28ddbd0a2caa3b488ba4899431c70afde207e779a49ae)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "resourceId", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="responseExportValues")
    def response_export_values(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "responseExportValues"))

    @response_export_values.setter
    def response_export_values(
        self,
        value: typing.Mapping[builtins.str, typing.Any],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__357b0007148e00bdf7bd48788e9dd50264c0b7decb944dd954983ed045d16fe0)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "responseExportValues", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="sensitiveResponseExportValues")
    def sensitive_response_export_values(
        self,
    ) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "sensitiveResponseExportValues"))

    @sensitive_response_export_values.setter
    def sensitive_response_export_values(
        self,
        value: typing.Mapping[builtins.str, typing.Any],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0319798eb06f4e230b99dd90a3a0392620aff4947336e180d07cd99eb67ef2a5)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "sensitiveResponseExportValues", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="type")
    def type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "type"))

    @type.setter
    def type(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__595b452dc41ac6e1e18f9f594cf05df16be57566288f18e8c538b35de247eff3)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "type", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="when")
    def when(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "when"))

    @when.setter
    def when(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7e4e242bce02e6a930efa9bfc9ebdf4c1dda6e62bbae50d41d9dd940c2dfdac7)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "when", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.ResourceActionConfig",
    jsii_struct_bases=[_cdktf_9a9027ec.TerraformMetaArguments],
    name_mapping={
        "connection": "connection",
        "count": "count",
        "depends_on": "dependsOn",
        "for_each": "forEach",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "provisioners": "provisioners",
        "resource_id": "resourceId",
        "type": "type",
        "action": "action",
        "body": "body",
        "headers": "headers",
        "locks": "locks",
        "method": "method",
        "query_parameters": "queryParameters",
        "response_export_values": "responseExportValues",
        "retry": "retry",
        "sensitive_response_export_values": "sensitiveResponseExportValues",
        "timeouts": "timeouts",
        "when": "when",
    },
)
class ResourceActionConfig(_cdktf_9a9027ec.TerraformMetaArguments):
    def __init__(
        self,
        *,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
        resource_id: builtins.str,
        type: builtins.str,
        action: typing.Optional[builtins.str] = None,
        body: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        headers: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        locks: typing.Optional[typing.Sequence[builtins.str]] = None,
        method: typing.Optional[builtins.str] = None,
        query_parameters: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.Sequence[builtins.str]]]] = None,
        response_export_values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        retry: typing.Optional[typing.Union["ResourceActionRetry", typing.Dict[builtins.str, typing.Any]]] = None,
        sensitive_response_export_values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        timeouts: typing.Optional[typing.Union["ResourceActionTimeouts", typing.Dict[builtins.str, typing.Any]]] = None,
        when: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        :param resource_id: The ID of an existing Azure source. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource_action#resource_id ResourceAction#resource_id}
        :param type: In a format like ``<resource-type>@<api-version>``. ``<resource-type>`` is the Azure resource type, for example, ``Microsoft.Storage/storageAccounts``. ``<api-version>`` is version of the API used to manage this azure resource. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource_action#type ResourceAction#type}
        :param action: The name of the resource action. It's also possible to make HTTP requests towards the resource ID if leave this field empty. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource_action#action ResourceAction#action}
        :param body: A dynamic attribute that contains the request body. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource_action#body ResourceAction#body}
        :param headers: A map of headers to include in the request. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource_action#headers ResourceAction#headers}
        :param locks: A list of ARM resource IDs which are used to avoid create/modify/delete azapi resources at the same time. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource_action#locks ResourceAction#locks}
        :param method: Specifies the HTTP method of the azure resource action. Allowed values are ``POST``, ``PATCH``, ``PUT`` and ``DELETE``. Defaults to ``POST``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource_action#method ResourceAction#method}
        :param query_parameters: A map of query parameters to include in the request. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource_action#query_parameters ResourceAction#query_parameters}
        :param response_export_values: The attribute can accept either a list or a map. - **List**: A list of paths that need to be exported from the response body. Setting it to ``["*"]`` will export the full response body. Here's an example. If it sets to ``["properties.loginServer", "properties.policies.quarantinePolicy.status"]``, it will set the following HCL object to the computed property output:: { properties = { loginServer = "registry1.azurecr.io" policies = { quarantinePolicy = { status = "disabled" } } } } - **Map**: A map where the key is the name for the result and the value is a JMESPath query string to filter the response. Here's an example. If it sets to ``{"login_server": "properties.loginServer", "quarantine_status": "properties.policies.quarantinePolicy.status"}``, it will set the following HCL object to the computed property output:: { "login_server" = "registry1.azurecr.io" "quarantine_status" = "disabled" } To learn more about JMESPath, visit `JMESPath <https://jmespath.org/>`_. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource_action#response_export_values ResourceAction#response_export_values}
        :param retry: The retry object supports the following attributes:. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource_action#retry ResourceAction#retry}
        :param sensitive_response_export_values: The attribute can accept either a list or a map. - **List**: A list of paths that need to be exported from the response body. Setting it to ``["*"]`` will export the full response body. Here's an example. If it sets to ``["properties.loginServer", "properties.policies.quarantinePolicy.status"]``, it will set the following HCL object to the computed property output:: { properties = { loginServer = "registry1.azurecr.io" policies = { quarantinePolicy = { status = "disabled" } } } } - **Map**: A map where the key is the name for the result and the value is a JMESPath query string to filter the response. Here's an example. If it sets to ``{"login_server": "properties.loginServer", "quarantine_status": "properties.policies.quarantinePolicy.status"}``, it will set the following HCL object to the computed property output:: { "login_server" = "registry1.azurecr.io" "quarantine_status" = "disabled" } To learn more about JMESPath, visit `JMESPath <https://jmespath.org/>`_. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource_action#sensitive_response_export_values ResourceAction#sensitive_response_export_values}
        :param timeouts: timeouts block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource_action#timeouts ResourceAction#timeouts}
        :param when: When to perform the action, value must be one of: ``apply``, ``destroy``. Default is ``apply``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource_action#when ResourceAction#when}
        '''
        if isinstance(lifecycle, dict):
            lifecycle = _cdktf_9a9027ec.TerraformResourceLifecycle(**lifecycle)
        if isinstance(retry, dict):
            retry = ResourceActionRetry(**retry)
        if isinstance(timeouts, dict):
            timeouts = ResourceActionTimeouts(**timeouts)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f8e2bb85c6fbed66627658d3e8222936052424f03b9388708ba0e28309d48ca7)
            check_type(argname="argument connection", value=connection, expected_type=type_hints["connection"])
            check_type(argname="argument count", value=count, expected_type=type_hints["count"])
            check_type(argname="argument depends_on", value=depends_on, expected_type=type_hints["depends_on"])
            check_type(argname="argument for_each", value=for_each, expected_type=type_hints["for_each"])
            check_type(argname="argument lifecycle", value=lifecycle, expected_type=type_hints["lifecycle"])
            check_type(argname="argument provider", value=provider, expected_type=type_hints["provider"])
            check_type(argname="argument provisioners", value=provisioners, expected_type=type_hints["provisioners"])
            check_type(argname="argument resource_id", value=resource_id, expected_type=type_hints["resource_id"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument action", value=action, expected_type=type_hints["action"])
            check_type(argname="argument body", value=body, expected_type=type_hints["body"])
            check_type(argname="argument headers", value=headers, expected_type=type_hints["headers"])
            check_type(argname="argument locks", value=locks, expected_type=type_hints["locks"])
            check_type(argname="argument method", value=method, expected_type=type_hints["method"])
            check_type(argname="argument query_parameters", value=query_parameters, expected_type=type_hints["query_parameters"])
            check_type(argname="argument response_export_values", value=response_export_values, expected_type=type_hints["response_export_values"])
            check_type(argname="argument retry", value=retry, expected_type=type_hints["retry"])
            check_type(argname="argument sensitive_response_export_values", value=sensitive_response_export_values, expected_type=type_hints["sensitive_response_export_values"])
            check_type(argname="argument timeouts", value=timeouts, expected_type=type_hints["timeouts"])
            check_type(argname="argument when", value=when, expected_type=type_hints["when"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "resource_id": resource_id,
            "type": type,
        }
        if connection is not None:
            self._values["connection"] = connection
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if for_each is not None:
            self._values["for_each"] = for_each
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider
        if provisioners is not None:
            self._values["provisioners"] = provisioners
        if action is not None:
            self._values["action"] = action
        if body is not None:
            self._values["body"] = body
        if headers is not None:
            self._values["headers"] = headers
        if locks is not None:
            self._values["locks"] = locks
        if method is not None:
            self._values["method"] = method
        if query_parameters is not None:
            self._values["query_parameters"] = query_parameters
        if response_export_values is not None:
            self._values["response_export_values"] = response_export_values
        if retry is not None:
            self._values["retry"] = retry
        if sensitive_response_export_values is not None:
            self._values["sensitive_response_export_values"] = sensitive_response_export_values
        if timeouts is not None:
            self._values["timeouts"] = timeouts
        if when is not None:
            self._values["when"] = when

    @builtins.property
    def connection(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("connection")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]], result)

    @builtins.property
    def count(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]], result)

    @builtins.property
    def depends_on(
        self,
    ) -> typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]], result)

    @builtins.property
    def for_each(self) -> typing.Optional[_cdktf_9a9027ec.ITerraformIterator]:
        '''
        :stability: experimental
        '''
        result = self._values.get("for_each")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.ITerraformIterator], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[_cdktf_9a9027ec.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformProvider], result)

    @builtins.property
    def provisioners(
        self,
    ) -> typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provisioners")
        return typing.cast(typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]], result)

    @builtins.property
    def resource_id(self) -> builtins.str:
        '''The ID of an existing Azure source.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource_action#resource_id ResourceAction#resource_id}
        '''
        result = self._values.get("resource_id")
        assert result is not None, "Required property 'resource_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def type(self) -> builtins.str:
        '''In a format like ``<resource-type>@<api-version>``.

        ``<resource-type>`` is the Azure resource type, for example, ``Microsoft.Storage/storageAccounts``. ``<api-version>`` is version of the API used to manage this azure resource.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource_action#type ResourceAction#type}
        '''
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def action(self) -> typing.Optional[builtins.str]:
        '''The name of the resource action.

        It's also possible to make HTTP requests towards the resource ID if leave this field empty.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource_action#action ResourceAction#action}
        '''
        result = self._values.get("action")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def body(self) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''A dynamic attribute that contains the request body.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource_action#body ResourceAction#body}
        '''
        result = self._values.get("body")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def headers(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''A map of headers to include in the request.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource_action#headers ResourceAction#headers}
        '''
        result = self._values.get("headers")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def locks(self) -> typing.Optional[typing.List[builtins.str]]:
        '''A list of ARM resource IDs which are used to avoid create/modify/delete azapi resources at the same time.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource_action#locks ResourceAction#locks}
        '''
        result = self._values.get("locks")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def method(self) -> typing.Optional[builtins.str]:
        '''Specifies the HTTP method of the azure resource action.

        Allowed values are ``POST``, ``PATCH``, ``PUT`` and ``DELETE``. Defaults to ``POST``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource_action#method ResourceAction#method}
        '''
        result = self._values.get("method")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def query_parameters(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.List[builtins.str]]]]:
        '''A map of query parameters to include in the request.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource_action#query_parameters ResourceAction#query_parameters}
        '''
        result = self._values.get("query_parameters")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.List[builtins.str]]]], result)

    @builtins.property
    def response_export_values(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''The attribute can accept either a list or a map.

        - **List**: A list of paths that need to be exported from the response body. Setting it to ``["*"]`` will export the full response body. Here's an example. If it sets to ``["properties.loginServer", "properties.policies.quarantinePolicy.status"]``, it will set the following HCL object to the computed property output::

             {
             	properties = {
             		loginServer = "registry1.azurecr.io"
             		policies = {
             			quarantinePolicy = {
             				status = "disabled"
             			}
             		}
             	}
             }
        - **Map**: A map where the key is the name for the result and the value is a JMESPath query string to filter the response. Here's an example. If it sets to ``{"login_server": "properties.loginServer", "quarantine_status": "properties.policies.quarantinePolicy.status"}``, it will set the following HCL object to the computed property output::

             {
             	"login_server" = "registry1.azurecr.io"
             	"quarantine_status" = "disabled"
             }

        To learn more about JMESPath, visit `JMESPath <https://jmespath.org/>`_.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource_action#response_export_values ResourceAction#response_export_values}
        '''
        result = self._values.get("response_export_values")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def retry(self) -> typing.Optional["ResourceActionRetry"]:
        '''The retry object supports the following attributes:.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource_action#retry ResourceAction#retry}
        '''
        result = self._values.get("retry")
        return typing.cast(typing.Optional["ResourceActionRetry"], result)

    @builtins.property
    def sensitive_response_export_values(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''The attribute can accept either a list or a map.

        - **List**: A list of paths that need to be exported from the response body. Setting it to ``["*"]`` will export the full response body. Here's an example. If it sets to ``["properties.loginServer", "properties.policies.quarantinePolicy.status"]``, it will set the following HCL object to the computed property output::

             {
             	properties = {
             		loginServer = "registry1.azurecr.io"
             		policies = {
             			quarantinePolicy = {
             				status = "disabled"
             			}
             		}
             	}
             }
        - **Map**: A map where the key is the name for the result and the value is a JMESPath query string to filter the response. Here's an example. If it sets to ``{"login_server": "properties.loginServer", "quarantine_status": "properties.policies.quarantinePolicy.status"}``, it will set the following HCL object to the computed property output::

             {
             	"login_server" = "registry1.azurecr.io"
             	"quarantine_status" = "disabled"
             }

        To learn more about JMESPath, visit `JMESPath <https://jmespath.org/>`_.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource_action#sensitive_response_export_values ResourceAction#sensitive_response_export_values}
        '''
        result = self._values.get("sensitive_response_export_values")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def timeouts(self) -> typing.Optional["ResourceActionTimeouts"]:
        '''timeouts block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource_action#timeouts ResourceAction#timeouts}
        '''
        result = self._values.get("timeouts")
        return typing.cast(typing.Optional["ResourceActionTimeouts"], result)

    @builtins.property
    def when(self) -> typing.Optional[builtins.str]:
        '''When to perform the action, value must be one of: ``apply``, ``destroy``. Default is ``apply``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource_action#when ResourceAction#when}
        '''
        result = self._values.get("when")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ResourceActionConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.ResourceActionRetry",
    jsii_struct_bases=[],
    name_mapping={
        "error_message_regex": "errorMessageRegex",
        "interval_seconds": "intervalSeconds",
        "max_interval_seconds": "maxIntervalSeconds",
        "multiplier": "multiplier",
        "randomization_factor": "randomizationFactor",
    },
)
class ResourceActionRetry:
    def __init__(
        self,
        *,
        error_message_regex: typing.Sequence[builtins.str],
        interval_seconds: typing.Optional[jsii.Number] = None,
        max_interval_seconds: typing.Optional[jsii.Number] = None,
        multiplier: typing.Optional[jsii.Number] = None,
        randomization_factor: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param error_message_regex: A list of regular expressions to match against error messages. If any of the regular expressions match, the request will be retried. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource_action#error_message_regex ResourceAction#error_message_regex}
        :param interval_seconds: The base number of seconds to wait between retries. Default is ``10``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource_action#interval_seconds ResourceAction#interval_seconds}
        :param max_interval_seconds: The maximum number of seconds to wait between retries. Default is ``180``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource_action#max_interval_seconds ResourceAction#max_interval_seconds}
        :param multiplier: The multiplier to apply to the interval between retries. Default is ``1.5``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource_action#multiplier ResourceAction#multiplier}
        :param randomization_factor: The randomization factor to apply to the interval between retries. The formula for the randomized interval is: ``RetryInterval * (random value in range [1 - RandomizationFactor, 1 + RandomizationFactor])``. Therefore set to zero ``0.0`` for no randomization. Default is ``0.5``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource_action#randomization_factor ResourceAction#randomization_factor}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__28e46efabfe16eb872f9211500b5dd2f673943819499d88429251542fb87d608)
            check_type(argname="argument error_message_regex", value=error_message_regex, expected_type=type_hints["error_message_regex"])
            check_type(argname="argument interval_seconds", value=interval_seconds, expected_type=type_hints["interval_seconds"])
            check_type(argname="argument max_interval_seconds", value=max_interval_seconds, expected_type=type_hints["max_interval_seconds"])
            check_type(argname="argument multiplier", value=multiplier, expected_type=type_hints["multiplier"])
            check_type(argname="argument randomization_factor", value=randomization_factor, expected_type=type_hints["randomization_factor"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "error_message_regex": error_message_regex,
        }
        if interval_seconds is not None:
            self._values["interval_seconds"] = interval_seconds
        if max_interval_seconds is not None:
            self._values["max_interval_seconds"] = max_interval_seconds
        if multiplier is not None:
            self._values["multiplier"] = multiplier
        if randomization_factor is not None:
            self._values["randomization_factor"] = randomization_factor

    @builtins.property
    def error_message_regex(self) -> typing.List[builtins.str]:
        '''A list of regular expressions to match against error messages.

        If any of the regular expressions match, the request will be retried.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource_action#error_message_regex ResourceAction#error_message_regex}
        '''
        result = self._values.get("error_message_regex")
        assert result is not None, "Required property 'error_message_regex' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def interval_seconds(self) -> typing.Optional[jsii.Number]:
        '''The base number of seconds to wait between retries. Default is ``10``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource_action#interval_seconds ResourceAction#interval_seconds}
        '''
        result = self._values.get("interval_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def max_interval_seconds(self) -> typing.Optional[jsii.Number]:
        '''The maximum number of seconds to wait between retries. Default is ``180``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource_action#max_interval_seconds ResourceAction#max_interval_seconds}
        '''
        result = self._values.get("max_interval_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def multiplier(self) -> typing.Optional[jsii.Number]:
        '''The multiplier to apply to the interval between retries. Default is ``1.5``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource_action#multiplier ResourceAction#multiplier}
        '''
        result = self._values.get("multiplier")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def randomization_factor(self) -> typing.Optional[jsii.Number]:
        '''The randomization factor to apply to the interval between retries.

        The formula for the randomized interval is: ``RetryInterval * (random value in range [1 - RandomizationFactor, 1 + RandomizationFactor])``. Therefore set to zero ``0.0`` for no randomization. Default is ``0.5``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource_action#randomization_factor ResourceAction#randomization_factor}
        '''
        result = self._values.get("randomization_factor")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ResourceActionRetry(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ResourceActionRetryOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@microsoft/terraform-cdk-constructs.ResourceActionRetryOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__00c2b505e65ddc5b0eab80b8e3925e063da0ba2a162cf555ff1da5fa728f859b)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetIntervalSeconds")
    def reset_interval_seconds(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetIntervalSeconds", []))

    @jsii.member(jsii_name="resetMaxIntervalSeconds")
    def reset_max_interval_seconds(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMaxIntervalSeconds", []))

    @jsii.member(jsii_name="resetMultiplier")
    def reset_multiplier(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMultiplier", []))

    @jsii.member(jsii_name="resetRandomizationFactor")
    def reset_randomization_factor(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRandomizationFactor", []))

    @builtins.property
    @jsii.member(jsii_name="errorMessageRegexInput")
    def error_message_regex_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "errorMessageRegexInput"))

    @builtins.property
    @jsii.member(jsii_name="intervalSecondsInput")
    def interval_seconds_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "intervalSecondsInput"))

    @builtins.property
    @jsii.member(jsii_name="maxIntervalSecondsInput")
    def max_interval_seconds_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "maxIntervalSecondsInput"))

    @builtins.property
    @jsii.member(jsii_name="multiplierInput")
    def multiplier_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "multiplierInput"))

    @builtins.property
    @jsii.member(jsii_name="randomizationFactorInput")
    def randomization_factor_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "randomizationFactorInput"))

    @builtins.property
    @jsii.member(jsii_name="errorMessageRegex")
    def error_message_regex(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "errorMessageRegex"))

    @error_message_regex.setter
    def error_message_regex(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__baae077936ab43a7958119c062b9fad9e223deb4cc1a0c05b8edbdeae1418a7c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "errorMessageRegex", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="intervalSeconds")
    def interval_seconds(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "intervalSeconds"))

    @interval_seconds.setter
    def interval_seconds(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9f364015da412ddbcdf7e825f3063adc0b3de3bf9363d68e147722bc2411f8aa)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "intervalSeconds", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="maxIntervalSeconds")
    def max_interval_seconds(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "maxIntervalSeconds"))

    @max_interval_seconds.setter
    def max_interval_seconds(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d40beb561bc4af16cab276bed7ab791d6d3478f692640f472415e88be5ea03dd)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "maxIntervalSeconds", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="multiplier")
    def multiplier(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "multiplier"))

    @multiplier.setter
    def multiplier(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e2262c316736506a51d44f860c32ba79aa990b17c43b3c3479e47992738912a4)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "multiplier", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="randomizationFactor")
    def randomization_factor(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "randomizationFactor"))

    @randomization_factor.setter
    def randomization_factor(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bd6be8daf53287e67ad06aa69e56938d7f91719ed089167a362e1cbe5d2391c2)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "randomizationFactor", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ResourceActionRetry]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ResourceActionRetry]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ResourceActionRetry]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__026803ddbdf7b5454fdd2d1dac7f26b97cdd33f24166845a5f1bbb406c6ca40e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.ResourceActionTimeouts",
    jsii_struct_bases=[],
    name_mapping={
        "create": "create",
        "delete": "delete",
        "read": "read",
        "update": "update",
    },
)
class ResourceActionTimeouts:
    def __init__(
        self,
        *,
        create: typing.Optional[builtins.str] = None,
        delete: typing.Optional[builtins.str] = None,
        read: typing.Optional[builtins.str] = None,
        update: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param create: A string that can be `parsed as a duration <https://pkg.go.dev/time#ParseDuration>`_ consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource_action#create ResourceAction#create}
        :param delete: A string that can be `parsed as a duration <https://pkg.go.dev/time#ParseDuration>`_ consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource_action#delete ResourceAction#delete}
        :param read: A string that can be `parsed as a duration <https://pkg.go.dev/time#ParseDuration>`_ consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource_action#read ResourceAction#read}
        :param update: A string that can be `parsed as a duration <https://pkg.go.dev/time#ParseDuration>`_ consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource_action#update ResourceAction#update}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3ee5eacfd46440ebfb5470174494f3da3d2ea98c95731344f7e0794305cdb15e)
            check_type(argname="argument create", value=create, expected_type=type_hints["create"])
            check_type(argname="argument delete", value=delete, expected_type=type_hints["delete"])
            check_type(argname="argument read", value=read, expected_type=type_hints["read"])
            check_type(argname="argument update", value=update, expected_type=type_hints["update"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if create is not None:
            self._values["create"] = create
        if delete is not None:
            self._values["delete"] = delete
        if read is not None:
            self._values["read"] = read
        if update is not None:
            self._values["update"] = update

    @builtins.property
    def create(self) -> typing.Optional[builtins.str]:
        '''A string that can be `parsed as a duration <https://pkg.go.dev/time#ParseDuration>`_ consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource_action#create ResourceAction#create}
        '''
        result = self._values.get("create")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def delete(self) -> typing.Optional[builtins.str]:
        '''A string that can be `parsed as a duration <https://pkg.go.dev/time#ParseDuration>`_ consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource_action#delete ResourceAction#delete}
        '''
        result = self._values.get("delete")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def read(self) -> typing.Optional[builtins.str]:
        '''A string that can be `parsed as a duration <https://pkg.go.dev/time#ParseDuration>`_ consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource_action#read ResourceAction#read}
        '''
        result = self._values.get("read")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def update(self) -> typing.Optional[builtins.str]:
        '''A string that can be `parsed as a duration <https://pkg.go.dev/time#ParseDuration>`_ consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource_action#update ResourceAction#update}
        '''
        result = self._values.get("update")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ResourceActionTimeouts(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ResourceActionTimeoutsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@microsoft/terraform-cdk-constructs.ResourceActionTimeoutsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f0d0cb9794de2331a0700fc234c67c1c997de1bccf68794aff848a45872aab72)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetCreate")
    def reset_create(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCreate", []))

    @jsii.member(jsii_name="resetDelete")
    def reset_delete(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDelete", []))

    @jsii.member(jsii_name="resetRead")
    def reset_read(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRead", []))

    @jsii.member(jsii_name="resetUpdate")
    def reset_update(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetUpdate", []))

    @builtins.property
    @jsii.member(jsii_name="createInput")
    def create_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "createInput"))

    @builtins.property
    @jsii.member(jsii_name="deleteInput")
    def delete_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "deleteInput"))

    @builtins.property
    @jsii.member(jsii_name="readInput")
    def read_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "readInput"))

    @builtins.property
    @jsii.member(jsii_name="updateInput")
    def update_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "updateInput"))

    @builtins.property
    @jsii.member(jsii_name="create")
    def create(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "create"))

    @create.setter
    def create(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a656c1a2a49619464df067705a34ecc7311594a109ac428f21d5180142e5262e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "create", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="delete")
    def delete(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "delete"))

    @delete.setter
    def delete(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__06a44b9c7e024ce8ba9a65de2a1d2e3b83c16e2175cf074a964fe2ea8df03783)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "delete", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="read")
    def read(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "read"))

    @read.setter
    def read(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__31257aab74109d3af4698313da9c73e0d185636e06e2c9bee106bf22de94e89f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "read", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="update")
    def update(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "update"))

    @update.setter
    def update(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__35e531b763c8e10f3decbaf7a5738cf248e9ea7b21a2bc3001de3b1fe735d065)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "update", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ResourceActionTimeouts]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ResourceActionTimeouts]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ResourceActionTimeouts]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__eb8f61d9dfa427401bb0a23cb0dc1488c437e857a759fbe4368ce74f670b549d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ResourceCleanupService(
    metaclass=jsii.JSIIMeta,
    jsii_type="@microsoft/terraform-cdk-constructs.ResourceCleanupService",
):
    '''Main cleanup service class.'''

    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="checkAzureCliAvailable")
    def check_azure_cli_available(self) -> builtins.bool:
        '''Checks if Azure CLI is available.'''
        return typing.cast(builtins.bool, jsii.invoke(self, "checkAzureCliAvailable", []))

    @jsii.member(jsii_name="queryAzureResourcesByTags")
    def query_azure_resources_by_tags(
        self,
        tags: typing.Mapping[builtins.str, builtins.str],
        subscription: typing.Optional[builtins.str] = None,
    ) -> typing.List[typing.Any]:
        '''Queries Azure Resource Graph for resources by tags.

        Returns empty array on errors for graceful degradation.

        :param tags: -
        :param subscription: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dd1b7579dcc308ca524a96cd6ee4b87bde571b1c101a9599fc573123069a9fd3)
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument subscription", value=subscription, expected_type=type_hints["subscription"])
        return typing.cast(typing.List[typing.Any], jsii.invoke(self, "queryAzureResourcesByTags", [tags, subscription]))


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.ResourceConfig",
    jsii_struct_bases=[_cdktf_9a9027ec.TerraformMetaArguments],
    name_mapping={
        "connection": "connection",
        "count": "count",
        "depends_on": "dependsOn",
        "for_each": "forEach",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "provisioners": "provisioners",
        "type": "type",
        "body": "body",
        "create_headers": "createHeaders",
        "create_query_parameters": "createQueryParameters",
        "delete_headers": "deleteHeaders",
        "delete_query_parameters": "deleteQueryParameters",
        "identity": "identity",
        "ignore_casing": "ignoreCasing",
        "ignore_missing_property": "ignoreMissingProperty",
        "ignore_null_property": "ignoreNullProperty",
        "location": "location",
        "locks": "locks",
        "name": "name",
        "parent_id": "parentId",
        "read_headers": "readHeaders",
        "read_query_parameters": "readQueryParameters",
        "replace_triggers_external_values": "replaceTriggersExternalValues",
        "replace_triggers_refs": "replaceTriggersRefs",
        "response_export_values": "responseExportValues",
        "retry": "retry",
        "schema_validation_enabled": "schemaValidationEnabled",
        "sensitive_body": "sensitiveBody",
        "sensitive_body_version": "sensitiveBodyVersion",
        "tags": "tags",
        "timeouts": "timeouts",
        "update_headers": "updateHeaders",
        "update_query_parameters": "updateQueryParameters",
    },
)
class ResourceConfig(_cdktf_9a9027ec.TerraformMetaArguments):
    def __init__(
        self,
        *,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
        type: builtins.str,
        body: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        create_headers: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        create_query_parameters: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.Sequence[builtins.str]]]] = None,
        delete_headers: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        delete_query_parameters: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.Sequence[builtins.str]]]] = None,
        identity: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union["ResourceIdentity", typing.Dict[builtins.str, typing.Any]]]]] = None,
        ignore_casing: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        ignore_missing_property: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        ignore_null_property: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        location: typing.Optional[builtins.str] = None,
        locks: typing.Optional[typing.Sequence[builtins.str]] = None,
        name: typing.Optional[builtins.str] = None,
        parent_id: typing.Optional[builtins.str] = None,
        read_headers: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        read_query_parameters: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.Sequence[builtins.str]]]] = None,
        replace_triggers_external_values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        replace_triggers_refs: typing.Optional[typing.Sequence[builtins.str]] = None,
        response_export_values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        retry: typing.Optional[typing.Union["ResourceRetry", typing.Dict[builtins.str, typing.Any]]] = None,
        schema_validation_enabled: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        sensitive_body: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        sensitive_body_version: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        timeouts: typing.Optional[typing.Union["ResourceTimeouts", typing.Dict[builtins.str, typing.Any]]] = None,
        update_headers: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        update_query_parameters: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.Sequence[builtins.str]]]] = None,
    ) -> None:
        '''
        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        :param type: In a format like ``<resource-type>@<api-version>``. ``<resource-type>`` is the Azure resource type, for example, ``Microsoft.Storage/storageAccounts``. ``<api-version>`` is version of the API used to manage this azure resource. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#type Resource#type}
        :param body: A dynamic attribute that contains the request body. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#body Resource#body}
        :param create_headers: A mapping of headers to be sent with the create request. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#create_headers Resource#create_headers}
        :param create_query_parameters: A mapping of query parameters to be sent with the create request. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#create_query_parameters Resource#create_query_parameters}
        :param delete_headers: A mapping of headers to be sent with the delete request. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#delete_headers Resource#delete_headers}
        :param delete_query_parameters: A mapping of query parameters to be sent with the delete request. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#delete_query_parameters Resource#delete_query_parameters}
        :param identity: identity block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#identity Resource#identity}
        :param ignore_casing: Whether ignore the casing of the property names in the response body. Defaults to ``false``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#ignore_casing Resource#ignore_casing}
        :param ignore_missing_property: Whether ignore not returned properties like credentials in ``body`` to suppress plan-diff. Defaults to ``true``. It's recommend to enable this option when some sensitive properties are not returned in response body, instead of setting them in ``lifecycle.ignore_changes`` because it will make the sensitive fields unable to update. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#ignore_missing_property Resource#ignore_missing_property}
        :param ignore_null_property: When set to ``true``, the provider will ignore properties whose values are ``null`` in the ``body``. These properties will not be included in the request body sent to the API, and the difference will not be shown in the plan output. Defaults to ``false``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#ignore_null_property Resource#ignore_null_property}
        :param location: The location of the Azure resource. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#location Resource#location}
        :param locks: A list of ARM resource IDs which are used to avoid create/modify/delete azapi resources at the same time. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#locks Resource#locks}
        :param name: Specifies the name of the azure resource. Changing this forces a new resource to be created. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#name Resource#name}
        :param parent_id: The ID of the azure resource in which this resource is created. It supports different kinds of deployment scope for **top level** resources: - resource group scope: ``parent_id`` should be the ID of a resource group, it's recommended to manage a resource group by azurerm_resource_group. - management group scope: ``parent_id`` should be the ID of a management group, it's recommended to manage a management group by azurerm_management_group. - extension scope: ``parent_id`` should be the ID of the resource you're adding the extension to. - subscription scope: ``parent_id`` should be like \\x60/subscriptions/00000000-0000-0000-0000-000000000000\\x60 - tenant scope: ``parent_id`` should be / For child level resources, the ``parent_id`` should be the ID of its parent resource, for example, subnet resource's ``parent_id`` is the ID of the vnet. For type ``Microsoft.Resources/resourceGroups``, the ``parent_id`` could be omitted, it defaults to subscription ID specified in provider or the default subscription (You could check the default subscription by azure cli command: ``az account show``). Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#parent_id Resource#parent_id}
        :param read_headers: A mapping of headers to be sent with the read request. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#read_headers Resource#read_headers}
        :param read_query_parameters: A mapping of query parameters to be sent with the read request. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#read_query_parameters Resource#read_query_parameters}
        :param replace_triggers_external_values: Will trigger a replace of the resource when the value changes and is not ``null``. This can be used by practitioners to force a replace of the resource when certain values change, e.g. changing the SKU of a virtual machine based on the value of variables or locals. The value is a ``dynamic``, so practitioners can compose the input however they wish. For a "break glass" set the value to ``null`` to prevent the plan modifier taking effect. If you have ``null`` values that you do want to be tracked as affecting the resource replacement, include these inside an object. Advanced use cases are possible and resource replacement can be triggered by values external to the resource, for example when a dependent resource changes. e.g. to replace a resource when either the SKU or os_type attributes change:: resource "azapi_resource" "example" { name = var.name type = "Microsoft.Network/publicIPAddresses@2023-11-01" parent_id = "/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/example" body = { properties = { sku = var.sku zones = var.zones } } replace_triggers_external_values = [ var.sku, var.zones, ] } Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#replace_triggers_external_values Resource#replace_triggers_external_values}
        :param replace_triggers_refs: A list of paths in the current Terraform configuration. When the values at these paths change, the resource will be replaced. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#replace_triggers_refs Resource#replace_triggers_refs}
        :param response_export_values: The attribute can accept either a list or a map. - **List**: A list of paths that need to be exported from the response body. Setting it to ``["*"]`` will export the full response body. Here's an example. If it sets to ``["properties.loginServer", "properties.policies.quarantinePolicy.status"]``, it will set the following HCL object to the computed property output:: { properties = { loginServer = "registry1.azurecr.io" policies = { quarantinePolicy = { status = "disabled" } } } } - **Map**: A map where the key is the name for the result and the value is a JMESPath query string to filter the response. Here's an example. If it sets to ``{"login_server": "properties.loginServer", "quarantine_status": "properties.policies.quarantinePolicy.status"}``, it will set the following HCL object to the computed property output:: { "login_server" = "registry1.azurecr.io" "quarantine_status" = "disabled" } To learn more about JMESPath, visit `JMESPath <https://jmespath.org/>`_. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#response_export_values Resource#response_export_values}
        :param retry: The retry object supports the following attributes:. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#retry Resource#retry}
        :param schema_validation_enabled: Whether enabled the validation on ``type`` and ``body`` with embedded schema. Defaults to ``true``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#schema_validation_enabled Resource#schema_validation_enabled}
        :param sensitive_body: A dynamic attribute that contains the write-only properties of the request body. This will be merge-patched to the body to construct the actual request body. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#sensitive_body Resource#sensitive_body}
        :param sensitive_body_version: A map where the key is the path to the property in ``sensitive_body`` and the value is the version of the property. The key is a string in the format of ``path.to.property[index].subproperty``, where ``index`` is the index of the item in an array. When the version is changed, the property will be included in the request body, otherwise it will be omitted from the request body. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#sensitive_body_version Resource#sensitive_body_version}
        :param tags: A mapping of tags which should be assigned to the Azure resource. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#tags Resource#tags}
        :param timeouts: timeouts block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#timeouts Resource#timeouts}
        :param update_headers: A mapping of headers to be sent with the update request. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#update_headers Resource#update_headers}
        :param update_query_parameters: A mapping of query parameters to be sent with the update request. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#update_query_parameters Resource#update_query_parameters}
        '''
        if isinstance(lifecycle, dict):
            lifecycle = _cdktf_9a9027ec.TerraformResourceLifecycle(**lifecycle)
        if isinstance(retry, dict):
            retry = ResourceRetry(**retry)
        if isinstance(timeouts, dict):
            timeouts = ResourceTimeouts(**timeouts)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0dba8b11025af1cd1bb936835c3223213bf9904b11157b2cd5518ae03dd90289)
            check_type(argname="argument connection", value=connection, expected_type=type_hints["connection"])
            check_type(argname="argument count", value=count, expected_type=type_hints["count"])
            check_type(argname="argument depends_on", value=depends_on, expected_type=type_hints["depends_on"])
            check_type(argname="argument for_each", value=for_each, expected_type=type_hints["for_each"])
            check_type(argname="argument lifecycle", value=lifecycle, expected_type=type_hints["lifecycle"])
            check_type(argname="argument provider", value=provider, expected_type=type_hints["provider"])
            check_type(argname="argument provisioners", value=provisioners, expected_type=type_hints["provisioners"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument body", value=body, expected_type=type_hints["body"])
            check_type(argname="argument create_headers", value=create_headers, expected_type=type_hints["create_headers"])
            check_type(argname="argument create_query_parameters", value=create_query_parameters, expected_type=type_hints["create_query_parameters"])
            check_type(argname="argument delete_headers", value=delete_headers, expected_type=type_hints["delete_headers"])
            check_type(argname="argument delete_query_parameters", value=delete_query_parameters, expected_type=type_hints["delete_query_parameters"])
            check_type(argname="argument identity", value=identity, expected_type=type_hints["identity"])
            check_type(argname="argument ignore_casing", value=ignore_casing, expected_type=type_hints["ignore_casing"])
            check_type(argname="argument ignore_missing_property", value=ignore_missing_property, expected_type=type_hints["ignore_missing_property"])
            check_type(argname="argument ignore_null_property", value=ignore_null_property, expected_type=type_hints["ignore_null_property"])
            check_type(argname="argument location", value=location, expected_type=type_hints["location"])
            check_type(argname="argument locks", value=locks, expected_type=type_hints["locks"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument parent_id", value=parent_id, expected_type=type_hints["parent_id"])
            check_type(argname="argument read_headers", value=read_headers, expected_type=type_hints["read_headers"])
            check_type(argname="argument read_query_parameters", value=read_query_parameters, expected_type=type_hints["read_query_parameters"])
            check_type(argname="argument replace_triggers_external_values", value=replace_triggers_external_values, expected_type=type_hints["replace_triggers_external_values"])
            check_type(argname="argument replace_triggers_refs", value=replace_triggers_refs, expected_type=type_hints["replace_triggers_refs"])
            check_type(argname="argument response_export_values", value=response_export_values, expected_type=type_hints["response_export_values"])
            check_type(argname="argument retry", value=retry, expected_type=type_hints["retry"])
            check_type(argname="argument schema_validation_enabled", value=schema_validation_enabled, expected_type=type_hints["schema_validation_enabled"])
            check_type(argname="argument sensitive_body", value=sensitive_body, expected_type=type_hints["sensitive_body"])
            check_type(argname="argument sensitive_body_version", value=sensitive_body_version, expected_type=type_hints["sensitive_body_version"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument timeouts", value=timeouts, expected_type=type_hints["timeouts"])
            check_type(argname="argument update_headers", value=update_headers, expected_type=type_hints["update_headers"])
            check_type(argname="argument update_query_parameters", value=update_query_parameters, expected_type=type_hints["update_query_parameters"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "type": type,
        }
        if connection is not None:
            self._values["connection"] = connection
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if for_each is not None:
            self._values["for_each"] = for_each
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider
        if provisioners is not None:
            self._values["provisioners"] = provisioners
        if body is not None:
            self._values["body"] = body
        if create_headers is not None:
            self._values["create_headers"] = create_headers
        if create_query_parameters is not None:
            self._values["create_query_parameters"] = create_query_parameters
        if delete_headers is not None:
            self._values["delete_headers"] = delete_headers
        if delete_query_parameters is not None:
            self._values["delete_query_parameters"] = delete_query_parameters
        if identity is not None:
            self._values["identity"] = identity
        if ignore_casing is not None:
            self._values["ignore_casing"] = ignore_casing
        if ignore_missing_property is not None:
            self._values["ignore_missing_property"] = ignore_missing_property
        if ignore_null_property is not None:
            self._values["ignore_null_property"] = ignore_null_property
        if location is not None:
            self._values["location"] = location
        if locks is not None:
            self._values["locks"] = locks
        if name is not None:
            self._values["name"] = name
        if parent_id is not None:
            self._values["parent_id"] = parent_id
        if read_headers is not None:
            self._values["read_headers"] = read_headers
        if read_query_parameters is not None:
            self._values["read_query_parameters"] = read_query_parameters
        if replace_triggers_external_values is not None:
            self._values["replace_triggers_external_values"] = replace_triggers_external_values
        if replace_triggers_refs is not None:
            self._values["replace_triggers_refs"] = replace_triggers_refs
        if response_export_values is not None:
            self._values["response_export_values"] = response_export_values
        if retry is not None:
            self._values["retry"] = retry
        if schema_validation_enabled is not None:
            self._values["schema_validation_enabled"] = schema_validation_enabled
        if sensitive_body is not None:
            self._values["sensitive_body"] = sensitive_body
        if sensitive_body_version is not None:
            self._values["sensitive_body_version"] = sensitive_body_version
        if tags is not None:
            self._values["tags"] = tags
        if timeouts is not None:
            self._values["timeouts"] = timeouts
        if update_headers is not None:
            self._values["update_headers"] = update_headers
        if update_query_parameters is not None:
            self._values["update_query_parameters"] = update_query_parameters

    @builtins.property
    def connection(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("connection")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]], result)

    @builtins.property
    def count(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]], result)

    @builtins.property
    def depends_on(
        self,
    ) -> typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]], result)

    @builtins.property
    def for_each(self) -> typing.Optional[_cdktf_9a9027ec.ITerraformIterator]:
        '''
        :stability: experimental
        '''
        result = self._values.get("for_each")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.ITerraformIterator], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[_cdktf_9a9027ec.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformProvider], result)

    @builtins.property
    def provisioners(
        self,
    ) -> typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provisioners")
        return typing.cast(typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]], result)

    @builtins.property
    def type(self) -> builtins.str:
        '''In a format like ``<resource-type>@<api-version>``.

        ``<resource-type>`` is the Azure resource type, for example, ``Microsoft.Storage/storageAccounts``. ``<api-version>`` is version of the API used to manage this azure resource.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#type Resource#type}
        '''
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def body(self) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''A dynamic attribute that contains the request body.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#body Resource#body}
        '''
        result = self._values.get("body")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def create_headers(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''A mapping of headers to be sent with the create request.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#create_headers Resource#create_headers}
        '''
        result = self._values.get("create_headers")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def create_query_parameters(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.List[builtins.str]]]]:
        '''A mapping of query parameters to be sent with the create request.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#create_query_parameters Resource#create_query_parameters}
        '''
        result = self._values.get("create_query_parameters")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.List[builtins.str]]]], result)

    @builtins.property
    def delete_headers(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''A mapping of headers to be sent with the delete request.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#delete_headers Resource#delete_headers}
        '''
        result = self._values.get("delete_headers")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def delete_query_parameters(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.List[builtins.str]]]]:
        '''A mapping of query parameters to be sent with the delete request.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#delete_query_parameters Resource#delete_query_parameters}
        '''
        result = self._values.get("delete_query_parameters")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.List[builtins.str]]]], result)

    @builtins.property
    def identity(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ResourceIdentity"]]]:
        '''identity block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#identity Resource#identity}
        '''
        result = self._values.get("identity")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List["ResourceIdentity"]]], result)

    @builtins.property
    def ignore_casing(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Whether ignore the casing of the property names in the response body. Defaults to ``false``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#ignore_casing Resource#ignore_casing}
        '''
        result = self._values.get("ignore_casing")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    @builtins.property
    def ignore_missing_property(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Whether ignore not returned properties like credentials in ``body`` to suppress plan-diff.

        Defaults to ``true``. It's recommend to enable this option when some sensitive properties are not returned in response body, instead of setting them in ``lifecycle.ignore_changes`` because it will make the sensitive fields unable to update.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#ignore_missing_property Resource#ignore_missing_property}
        '''
        result = self._values.get("ignore_missing_property")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    @builtins.property
    def ignore_null_property(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''When set to ``true``, the provider will ignore properties whose values are ``null`` in the ``body``.

        These properties will not be included in the request body sent to the API, and the difference will not be shown in the plan output. Defaults to ``false``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#ignore_null_property Resource#ignore_null_property}
        '''
        result = self._values.get("ignore_null_property")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    @builtins.property
    def location(self) -> typing.Optional[builtins.str]:
        '''The location of the Azure resource.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#location Resource#location}
        '''
        result = self._values.get("location")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def locks(self) -> typing.Optional[typing.List[builtins.str]]:
        '''A list of ARM resource IDs which are used to avoid create/modify/delete azapi resources at the same time.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#locks Resource#locks}
        '''
        result = self._values.get("locks")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''Specifies the name of the azure resource. Changing this forces a new resource to be created.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#name Resource#name}
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def parent_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the azure resource in which this resource is created.

        It supports different kinds of deployment scope for **top level** resources:

        - resource group scope: ``parent_id`` should be the ID of a resource group, it's recommended to manage a resource group by azurerm_resource_group.

          - management group scope: ``parent_id`` should be the ID of a management group, it's recommended to manage a management group by azurerm_management_group.
          - extension scope: ``parent_id`` should be the ID of the resource you're adding the extension to.
          - subscription scope: ``parent_id`` should be like \\x60/subscriptions/00000000-0000-0000-0000-000000000000\\x60
          - tenant scope: ``parent_id`` should be /

        For child level resources, the ``parent_id`` should be the ID of its parent resource, for example, subnet resource's ``parent_id`` is the ID of the vnet.

        For type ``Microsoft.Resources/resourceGroups``, the ``parent_id`` could be omitted, it defaults to subscription ID specified in provider or the default subscription (You could check the default subscription by azure cli command: ``az account show``).

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#parent_id Resource#parent_id}
        '''
        result = self._values.get("parent_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def read_headers(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''A mapping of headers to be sent with the read request.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#read_headers Resource#read_headers}
        '''
        result = self._values.get("read_headers")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def read_query_parameters(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.List[builtins.str]]]]:
        '''A mapping of query parameters to be sent with the read request.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#read_query_parameters Resource#read_query_parameters}
        '''
        result = self._values.get("read_query_parameters")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.List[builtins.str]]]], result)

    @builtins.property
    def replace_triggers_external_values(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''Will trigger a replace of the resource when the value changes and is not ``null``.

        This can be used by practitioners to force a replace of the resource when certain values change, e.g. changing the SKU of a virtual machine based on the value of variables or locals. The value is a ``dynamic``, so practitioners can compose the input however they wish. For a "break glass" set the value to ``null`` to prevent the plan modifier taking effect.
        If you have ``null`` values that you do want to be tracked as affecting the resource replacement, include these inside an object.
        Advanced use cases are possible and resource replacement can be triggered by values external to the resource, for example when a dependent resource changes.

        e.g. to replace a resource when either the SKU or os_type attributes change::

           resource "azapi_resource" "example" {
             name      = var.name
             type      = "Microsoft.Network/publicIPAddresses@2023-11-01"
             parent_id = "/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/example"
             body = {
               properties = {
                 sku   = var.sku
                 zones = var.zones
               }
             }

             replace_triggers_external_values = [
               var.sku,
               var.zones,
             ]
           }

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#replace_triggers_external_values Resource#replace_triggers_external_values}
        '''
        result = self._values.get("replace_triggers_external_values")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def replace_triggers_refs(self) -> typing.Optional[typing.List[builtins.str]]:
        '''A list of paths in the current Terraform configuration.

        When the values at these paths change, the resource will be replaced.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#replace_triggers_refs Resource#replace_triggers_refs}
        '''
        result = self._values.get("replace_triggers_refs")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def response_export_values(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''The attribute can accept either a list or a map.

        - **List**: A list of paths that need to be exported from the response body. Setting it to ``["*"]`` will export the full response body. Here's an example. If it sets to ``["properties.loginServer", "properties.policies.quarantinePolicy.status"]``, it will set the following HCL object to the computed property output::

             {
             	properties = {
             		loginServer = "registry1.azurecr.io"
             		policies = {
             			quarantinePolicy = {
             				status = "disabled"
             			}
             		}
             	}
             }
        - **Map**: A map where the key is the name for the result and the value is a JMESPath query string to filter the response. Here's an example. If it sets to ``{"login_server": "properties.loginServer", "quarantine_status": "properties.policies.quarantinePolicy.status"}``, it will set the following HCL object to the computed property output::

             {
             	"login_server" = "registry1.azurecr.io"
             	"quarantine_status" = "disabled"
             }

        To learn more about JMESPath, visit `JMESPath <https://jmespath.org/>`_.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#response_export_values Resource#response_export_values}
        '''
        result = self._values.get("response_export_values")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def retry(self) -> typing.Optional["ResourceRetry"]:
        '''The retry object supports the following attributes:.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#retry Resource#retry}
        '''
        result = self._values.get("retry")
        return typing.cast(typing.Optional["ResourceRetry"], result)

    @builtins.property
    def schema_validation_enabled(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Whether enabled the validation on ``type`` and ``body`` with embedded schema. Defaults to ``true``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#schema_validation_enabled Resource#schema_validation_enabled}
        '''
        result = self._values.get("schema_validation_enabled")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    @builtins.property
    def sensitive_body(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''A dynamic attribute that contains the write-only properties of the request body.

        This will be merge-patched to the body to construct the actual request body.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#sensitive_body Resource#sensitive_body}
        '''
        result = self._values.get("sensitive_body")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def sensitive_body_version(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''A map where the key is the path to the property in ``sensitive_body`` and the value is the version of the property.

        The key is a string in the format of ``path.to.property[index].subproperty``, where ``index`` is the index of the item in an array. When the version is changed, the property will be included in the request body, otherwise it will be omitted from the request body.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#sensitive_body_version Resource#sensitive_body_version}
        '''
        result = self._values.get("sensitive_body_version")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''A mapping of tags which should be assigned to the Azure resource.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#tags Resource#tags}
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def timeouts(self) -> typing.Optional["ResourceTimeouts"]:
        '''timeouts block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#timeouts Resource#timeouts}
        '''
        result = self._values.get("timeouts")
        return typing.cast(typing.Optional["ResourceTimeouts"], result)

    @builtins.property
    def update_headers(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''A mapping of headers to be sent with the update request.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#update_headers Resource#update_headers}
        '''
        result = self._values.get("update_headers")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def update_query_parameters(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.List[builtins.str]]]]:
        '''A mapping of query parameters to be sent with the update request.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#update_query_parameters Resource#update_query_parameters}
        '''
        result = self._values.get("update_query_parameters")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.List[builtins.str]]]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ResourceConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ResourceGroup(
    _AzapiResource_7e7f5b39,
    metaclass=jsii.JSIIMeta,
    jsii_type="@microsoft/terraform-cdk-constructs.ResourceGroup",
):
    '''Unified Azure Resource Group implementation.

    This class provides a single, version-aware implementation that replaces all
    version-specific Resource Group classes. It automatically handles version
    resolution, schema validation, and property transformation while maintaining
    full backward compatibility.

    The class uses the VersionedAzapiResource framework to provide:

    - Automatic latest version resolution (2025-03-01 as of this implementation)
    - Support for explicit version pinning when stability is required
    - Schema-driven property validation and transformation
    - Migration analysis and deprecation warnings
    - Full JSII compliance for multi-language support

    Example::

        // Usage with explicit version pinning:
        const resourceGroup = new ResourceGroup(this, "rg", {
          name: "my-resource-group",
          location: "eastus",
          apiVersion: "2024-11-01", // Pin to specific version
          tags: { environment: "production" }
        });
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
        managed_by: typing.Optional[builtins.str] = None,
        api_version: typing.Optional[builtins.str] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        location: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> None:
        '''Creates a new Azure Resource Group using the VersionedAzapiResource framework.

        The constructor automatically handles version resolution, schema registration,
        validation, and resource creation. It maintains full backward compatibility
        with existing Resource Group implementations.

        :param scope: - The scope in which to define this construct.
        :param id: - The unique identifier for this instance.
        :param ignore_changes: The lifecycle rules to ignore changes. Useful for properties that are externally managed or should not trigger updates.
        :param managed_by: Managed by information for the resource group. Indicates what service or tool is managing this resource group.
        :param api_version: Explicit API version to use for this resource. If not specified, the latest active version will be automatically resolved. Use this for version pinning when stability is required over latest features. Default: Latest active version from ApiVersionManager
        :param enable_migration_analysis: Whether to enable migration analysis warnings. When true, the framework will analyze the current version for deprecation status and provide migration recommendations in the deployment output. Default: true
        :param enable_transformation: Whether to apply property transformations automatically. When true, properties will be automatically transformed according to the target schema's transformation rules. This enables backward compatibility. Default: true
        :param enable_validation: Whether to validate properties against the schema. When true, all properties will be validated against the API schema before resource creation. Validation errors will cause deployment failures. Default: true
        :param location: The location where the resource should be created. Default: Varies by resource type - see specific resource documentation
        :param monitoring: Monitoring configuration for this resource. Enables integrated monitoring with diagnostic settings, metric alerts, and activity log alerts. All monitoring is optional and disabled by default.
        :param name: The name of the resource.
        :param tags: Tags to apply to the resource.
        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__29b0473f748c77e8cf5a499a8a1cb9dbd38d71e9f891bc8febb8ed132057b1ce)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = _ResourceGroupProps_2bf9437d(
            ignore_changes=ignore_changes,
            managed_by=managed_by,
            api_version=api_version,
            enable_migration_analysis=enable_migration_analysis,
            enable_transformation=enable_transformation,
            enable_validation=enable_validation,
            location=location,
            monitoring=monitoring,
            name=name,
            tags=tags,
            connection=connection,
            count=count,
            depends_on=depends_on,
            for_each=for_each,
            lifecycle=lifecycle,
            provider=provider,
            provisioners=provisioners,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="apiSchema")
    def _api_schema(self) -> _ApiSchema_5ce0490e:
        '''Gets the API schema for the resolved version Uses the framework's schema resolution to get the appropriate schema.'''
        return typing.cast(_ApiSchema_5ce0490e, jsii.invoke(self, "apiSchema", []))

    @jsii.member(jsii_name="createResourceBody")
    def _create_resource_body(self, props: typing.Any) -> typing.Any:
        '''Creates the resource body for the Azure API call Transforms the input properties into the JSON format expected by Azure REST API.

        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3fc32ce7cf0743f4d9783f3fb0755941fbe96b318c5653c79f3bc1f3f8af25ec)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Any, jsii.invoke(self, "createResourceBody", [props]))

    @jsii.member(jsii_name="defaultVersion")
    def _default_version(self) -> builtins.str:
        '''Gets the default API version to use when no explicit version is specified Returns the most recent stable version as the default.'''
        return typing.cast(builtins.str, jsii.invoke(self, "defaultVersion", []))

    @jsii.member(jsii_name="requiresLocation")
    def _requires_location(self) -> builtins.bool:
        '''Indicates that location is required for Resource Groups.'''
        return typing.cast(builtins.bool, jsii.invoke(self, "requiresLocation", []))

    @jsii.member(jsii_name="resolveParentId")
    def _resolve_parent_id(self, _props: typing.Any) -> builtins.str:
        '''Resolves the parent ID for Resource Groups Resource Groups are top-level resources with subscription as parent.

        :param _props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__86cf1ed103d6b382f226e0453cfef8a9f3700fa2fc06e6a37620e72c2f207aed)
            check_type(argname="argument _props", value=_props, expected_type=type_hints["_props"])
        return typing.cast(builtins.str, jsii.invoke(self, "resolveParentId", [_props]))

    @jsii.member(jsii_name="resourceType")
    def _resource_type(self) -> builtins.str:
        '''Gets the Azure resource type for Resource Groups.'''
        return typing.cast(builtins.str, jsii.invoke(self, "resourceType", []))

    @builtins.property
    @jsii.member(jsii_name="idOutput")
    def id_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "idOutput"))

    @builtins.property
    @jsii.member(jsii_name="locationOutput")
    def location_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "locationOutput"))

    @builtins.property
    @jsii.member(jsii_name="nameOutput")
    def name_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "nameOutput"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def props(self) -> _ResourceGroupProps_2bf9437d:
        '''The input properties for this Resource Group instance.'''
        return typing.cast(_ResourceGroupProps_2bf9437d, jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="resourceId")
    def resource_id(self) -> builtins.str:
        '''Get the full resource identifier for use in other Azure resources Alias for the id property to match original interface.'''
        return typing.cast(builtins.str, jsii.get(self, "resourceId"))

    @builtins.property
    @jsii.member(jsii_name="subscriptionId")
    def subscription_id(self) -> builtins.str:
        '''Get the subscription ID from the Resource Group ID Extracts the subscription ID from the Azure resource ID format.'''
        return typing.cast(builtins.str, jsii.get(self, "subscriptionId"))

    @builtins.property
    @jsii.member(jsii_name="tagsOutput")
    def tags_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "tagsOutput"))


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.ResourceGroupBody",
    jsii_struct_bases=[],
    name_mapping={"location": "location", "managed_by": "managedBy", "tags": "tags"},
)
class ResourceGroupBody:
    def __init__(
        self,
        *,
        location: builtins.str,
        managed_by: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''The resource body interface for Azure Resource Group API calls This matches the Azure REST API schema for resource groups.

        :param location: The location of the resource group. Cannot be changed after creation.
        :param managed_by: The ID of the resource that manages this resource group.
        :param tags: The tags attached to the resource group.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1323ac136a1170344d1118d9c54f81085344d6968ef0d2d115e69fc0fa8254d0)
            check_type(argname="argument location", value=location, expected_type=type_hints["location"])
            check_type(argname="argument managed_by", value=managed_by, expected_type=type_hints["managed_by"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "location": location,
        }
        if managed_by is not None:
            self._values["managed_by"] = managed_by
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def location(self) -> builtins.str:
        '''The location of the resource group.

        Cannot be changed after creation.
        '''
        result = self._values.get("location")
        assert result is not None, "Required property 'location' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def managed_by(self) -> typing.Optional[builtins.str]:
        '''The ID of the resource that manages this resource group.'''
        result = self._values.get("managed_by")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''The tags attached to the resource group.'''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ResourceGroupBody(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.ResourceGroupProps",
    jsii_struct_bases=[_AzapiResourceProps_141a2340],
    name_mapping={
        "connection": "connection",
        "count": "count",
        "depends_on": "dependsOn",
        "for_each": "forEach",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "provisioners": "provisioners",
        "api_version": "apiVersion",
        "enable_migration_analysis": "enableMigrationAnalysis",
        "enable_transformation": "enableTransformation",
        "enable_validation": "enableValidation",
        "location": "location",
        "monitoring": "monitoring",
        "name": "name",
        "tags": "tags",
        "ignore_changes": "ignoreChanges",
        "managed_by": "managedBy",
    },
)
class ResourceGroupProps(_AzapiResourceProps_141a2340):
    def __init__(
        self,
        *,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
        api_version: typing.Optional[builtins.str] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        location: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
        managed_by: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for the unified Azure Resource Group.

        Extends VersionedAzapiResourceProps with Resource Group specific properties
        while maintaining full compatibility with the original GroupProps interface.

        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        :param api_version: Explicit API version to use for this resource. If not specified, the latest active version will be automatically resolved. Use this for version pinning when stability is required over latest features. Default: Latest active version from ApiVersionManager
        :param enable_migration_analysis: Whether to enable migration analysis warnings. When true, the framework will analyze the current version for deprecation status and provide migration recommendations in the deployment output. Default: true
        :param enable_transformation: Whether to apply property transformations automatically. When true, properties will be automatically transformed according to the target schema's transformation rules. This enables backward compatibility. Default: true
        :param enable_validation: Whether to validate properties against the schema. When true, all properties will be validated against the API schema before resource creation. Validation errors will cause deployment failures. Default: true
        :param location: The location where the resource should be created. Default: Varies by resource type - see specific resource documentation
        :param monitoring: Monitoring configuration for this resource. Enables integrated monitoring with diagnostic settings, metric alerts, and activity log alerts. All monitoring is optional and disabled by default.
        :param name: The name of the resource.
        :param tags: Tags to apply to the resource.
        :param ignore_changes: The lifecycle rules to ignore changes. Useful for properties that are externally managed or should not trigger updates.
        :param managed_by: Managed by information for the resource group. Indicates what service or tool is managing this resource group.
        '''
        if isinstance(lifecycle, dict):
            lifecycle = _cdktf_9a9027ec.TerraformResourceLifecycle(**lifecycle)
        if isinstance(monitoring, dict):
            monitoring = _MonitoringConfig_7c28df74(**monitoring)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__00f9d149205e57c257371a1ebedf9fed7fb1e90db72bae0538c3d2fec74c45be)
            check_type(argname="argument connection", value=connection, expected_type=type_hints["connection"])
            check_type(argname="argument count", value=count, expected_type=type_hints["count"])
            check_type(argname="argument depends_on", value=depends_on, expected_type=type_hints["depends_on"])
            check_type(argname="argument for_each", value=for_each, expected_type=type_hints["for_each"])
            check_type(argname="argument lifecycle", value=lifecycle, expected_type=type_hints["lifecycle"])
            check_type(argname="argument provider", value=provider, expected_type=type_hints["provider"])
            check_type(argname="argument provisioners", value=provisioners, expected_type=type_hints["provisioners"])
            check_type(argname="argument api_version", value=api_version, expected_type=type_hints["api_version"])
            check_type(argname="argument enable_migration_analysis", value=enable_migration_analysis, expected_type=type_hints["enable_migration_analysis"])
            check_type(argname="argument enable_transformation", value=enable_transformation, expected_type=type_hints["enable_transformation"])
            check_type(argname="argument enable_validation", value=enable_validation, expected_type=type_hints["enable_validation"])
            check_type(argname="argument location", value=location, expected_type=type_hints["location"])
            check_type(argname="argument monitoring", value=monitoring, expected_type=type_hints["monitoring"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument ignore_changes", value=ignore_changes, expected_type=type_hints["ignore_changes"])
            check_type(argname="argument managed_by", value=managed_by, expected_type=type_hints["managed_by"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if connection is not None:
            self._values["connection"] = connection
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if for_each is not None:
            self._values["for_each"] = for_each
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider
        if provisioners is not None:
            self._values["provisioners"] = provisioners
        if api_version is not None:
            self._values["api_version"] = api_version
        if enable_migration_analysis is not None:
            self._values["enable_migration_analysis"] = enable_migration_analysis
        if enable_transformation is not None:
            self._values["enable_transformation"] = enable_transformation
        if enable_validation is not None:
            self._values["enable_validation"] = enable_validation
        if location is not None:
            self._values["location"] = location
        if monitoring is not None:
            self._values["monitoring"] = monitoring
        if name is not None:
            self._values["name"] = name
        if tags is not None:
            self._values["tags"] = tags
        if ignore_changes is not None:
            self._values["ignore_changes"] = ignore_changes
        if managed_by is not None:
            self._values["managed_by"] = managed_by

    @builtins.property
    def connection(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("connection")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]], result)

    @builtins.property
    def count(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]], result)

    @builtins.property
    def depends_on(
        self,
    ) -> typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]], result)

    @builtins.property
    def for_each(self) -> typing.Optional[_cdktf_9a9027ec.ITerraformIterator]:
        '''
        :stability: experimental
        '''
        result = self._values.get("for_each")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.ITerraformIterator], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[_cdktf_9a9027ec.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformProvider], result)

    @builtins.property
    def provisioners(
        self,
    ) -> typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provisioners")
        return typing.cast(typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]], result)

    @builtins.property
    def api_version(self) -> typing.Optional[builtins.str]:
        '''Explicit API version to use for this resource.

        If not specified, the latest active version will be automatically resolved.
        Use this for version pinning when stability is required over latest features.

        :default: Latest active version from ApiVersionManager

        Example::

            "2024-11-01"
        '''
        result = self._values.get("api_version")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def enable_migration_analysis(self) -> typing.Optional[builtins.bool]:
        '''Whether to enable migration analysis warnings.

        When true, the framework will analyze the current version for deprecation
        status and provide migration recommendations in the deployment output.

        :default: true
        '''
        result = self._values.get("enable_migration_analysis")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_transformation(self) -> typing.Optional[builtins.bool]:
        '''Whether to apply property transformations automatically.

        When true, properties will be automatically transformed according to the
        target schema's transformation rules. This enables backward compatibility.

        :default: true
        '''
        result = self._values.get("enable_transformation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_validation(self) -> typing.Optional[builtins.bool]:
        '''Whether to validate properties against the schema.

        When true, all properties will be validated against the API schema before
        resource creation. Validation errors will cause deployment failures.

        :default: true
        '''
        result = self._values.get("enable_validation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def location(self) -> typing.Optional[builtins.str]:
        '''The location where the resource should be created.

        :default: Varies by resource type - see specific resource documentation

        :remarks:

        Location handling varies by resource type:

        - **Top-level resources**: Most require an explicit location (e.g., "eastus", "westus")
        - **Global resources**: Some use "global" as location (e.g., Private DNS Zones)
        - **Child resources**: Inherit location from parent and should NOT set this property

        Each resource type may provide its own default through the ``resolveLocation()`` method.
        If no location is specified and no default exists, resource creation may fail.

        Example::

            // Child resource (Subnet) - do not set location
            // location: undefined (inherited from parent Virtual Network)
        '''
        result = self._values.get("location")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def monitoring(self) -> typing.Optional[_MonitoringConfig_7c28df74]:
        '''Monitoring configuration for this resource.

        Enables integrated monitoring with diagnostic settings, metric alerts,
        and activity log alerts. All monitoring is optional and disabled by default.

        Example::

            monitoring: {
              enabled: true,
              diagnosticSettings: {
                workspaceId: logAnalytics.id,
                metrics: ['AllMetrics'],
                logs: ['AuditLogs']
              },
              metricAlerts: [{
                name: 'high-cpu-alert',
                severity: 2,
                scopes: [], // Automatically set to this resource
                criteria: { ... },
                actions: [{ actionGroupId: actionGroup.id }]
              }]
            }
        '''
        result = self._values.get("monitoring")
        return typing.cast(typing.Optional[_MonitoringConfig_7c28df74], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the resource.'''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Tags to apply to the resource.'''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def ignore_changes(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The lifecycle rules to ignore changes.

        Useful for properties that are externally managed or should not trigger updates.

        Example::

            ["tags", "managedBy"]
        '''
        result = self._values.get("ignore_changes")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def managed_by(self) -> typing.Optional[builtins.str]:
        '''Managed by information for the resource group.

        Indicates what service or tool is managing this resource group.
        '''
        result = self._values.get("managed_by")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ResourceGroupProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.ResourceIdentity",
    jsii_struct_bases=[],
    name_mapping={"type": "type", "identity_ids": "identityIds"},
)
class ResourceIdentity:
    def __init__(
        self,
        *,
        type: builtins.str,
        identity_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param type: The Type of Identity which should be used for this azure resource. Possible values are ``SystemAssigned``, ``UserAssigned`` and ``SystemAssigned,UserAssigned``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#type Resource#type}
        :param identity_ids: A list of User Managed Identity ID's which should be assigned to the azure resource. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#identity_ids Resource#identity_ids}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__52c12ff10ae1f91ea81406a63ac44465db1733866e3b4e573c96fbd491e8396a)
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument identity_ids", value=identity_ids, expected_type=type_hints["identity_ids"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "type": type,
        }
        if identity_ids is not None:
            self._values["identity_ids"] = identity_ids

    @builtins.property
    def type(self) -> builtins.str:
        '''The Type of Identity which should be used for this azure resource. Possible values are ``SystemAssigned``, ``UserAssigned`` and ``SystemAssigned,UserAssigned``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#type Resource#type}
        '''
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def identity_ids(self) -> typing.Optional[typing.List[builtins.str]]:
        '''A list of User Managed Identity ID's which should be assigned to the azure resource.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#identity_ids Resource#identity_ids}
        '''
        result = self._values.get("identity_ids")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ResourceIdentity(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ResourceIdentityList(
    _cdktf_9a9027ec.ComplexList,
    metaclass=jsii.JSIIMeta,
    jsii_type="@microsoft/terraform-cdk-constructs.ResourceIdentityList",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        wraps_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param wraps_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ad8d5bcf536a2bf97e7c786ae80ebde8ed0263faaa0da60aafb6a9c34bbfbd28)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument wraps_set", value=wraps_set, expected_type=type_hints["wraps_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, wraps_set])

    @jsii.member(jsii_name="get")
    def get(self, index: jsii.Number) -> "ResourceIdentityOutputReference":
        '''
        :param index: the index of the item to return.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e2853f8e17a0492754c88e8f76e6da89db331a4e7d3b433ba9398c406c8945d5)
            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
        return typing.cast("ResourceIdentityOutputReference", jsii.invoke(self, "get", [index]))

    @builtins.property
    @jsii.member(jsii_name="terraformAttribute")
    def _terraform_attribute(self) -> builtins.str:
        '''The attribute on the parent resource this class is referencing.'''
        return typing.cast(builtins.str, jsii.get(self, "terraformAttribute"))

    @_terraform_attribute.setter
    def _terraform_attribute(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7d91140734b86f4427853447aab47a37a2eb5d7e0f178adec228df8c4e915a5d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformAttribute", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="terraformResource")
    def _terraform_resource(self) -> _cdktf_9a9027ec.IInterpolatingParent:
        '''The parent resource.'''
        return typing.cast(_cdktf_9a9027ec.IInterpolatingParent, jsii.get(self, "terraformResource"))

    @_terraform_resource.setter
    def _terraform_resource(self, value: _cdktf_9a9027ec.IInterpolatingParent) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__41f84f167da33ddaf69687ffe06bbe94c7ea1b052b6d03296eb6452ee6349386)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "terraformResource", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="wrapsSet")
    def _wraps_set(self) -> builtins.bool:
        '''whether the list is wrapping a set (will add tolist() to be able to access an item via an index).'''
        return typing.cast(builtins.bool, jsii.get(self, "wrapsSet"))

    @_wraps_set.setter
    def _wraps_set(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1eb795e3b089bdae4f19ca0c05ca50f165c61d0240fbcc4f7eabf33bcca4e631)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "wrapsSet", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ResourceIdentity]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ResourceIdentity]]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ResourceIdentity]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e52ebd7e8bcbdea5dc89cc5b9b0867832aa098d2fa4dffe77bf6bbd0a9e7cb42)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


class ResourceIdentityOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@microsoft/terraform-cdk-constructs.ResourceIdentityOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
        complex_object_index: jsii.Number,
        complex_object_is_from_set: builtins.bool,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        :param complex_object_index: the index of this item in the list.
        :param complex_object_is_from_set: whether the list is wrapping a set (will add tolist() to be able to access an item via an index).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f19617e93a12cd6b0421753d1b24a2c4b49d02f4b495c1e5e300d0d8792480db)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
            check_type(argname="argument complex_object_index", value=complex_object_index, expected_type=type_hints["complex_object_index"])
            check_type(argname="argument complex_object_is_from_set", value=complex_object_is_from_set, expected_type=type_hints["complex_object_is_from_set"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute, complex_object_index, complex_object_is_from_set])

    @jsii.member(jsii_name="resetIdentityIds")
    def reset_identity_ids(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetIdentityIds", []))

    @builtins.property
    @jsii.member(jsii_name="principalId")
    def principal_id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "principalId"))

    @builtins.property
    @jsii.member(jsii_name="tenantId")
    def tenant_id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "tenantId"))

    @builtins.property
    @jsii.member(jsii_name="identityIdsInput")
    def identity_ids_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "identityIdsInput"))

    @builtins.property
    @jsii.member(jsii_name="typeInput")
    def type_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "typeInput"))

    @builtins.property
    @jsii.member(jsii_name="identityIds")
    def identity_ids(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "identityIds"))

    @identity_ids.setter
    def identity_ids(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8ac80f65161d5f9550a7fd12ec9c6e719abfd6ba606e52b7eb5ff5b7dcc057da)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "identityIds", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="type")
    def type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "type"))

    @type.setter
    def type(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6426f4c03ae3bdae7cab4d741f9740345086ca56b44437ac0a6798b395a95f5d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "type", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ResourceIdentity]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ResourceIdentity]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ResourceIdentity]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a86e85302b9b79b20851effe0af9250a8f5a2e902618a3df8ae46e57f8d38a18)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.ResourceMetadata",
    jsii_struct_bases=[],
    name_mapping={
        "created_at": "createdAt",
        "name": "name",
        "resource_id": "resourceId",
        "resource_type": "resourceType",
        "tags": "tags",
        "test_run_id": "testRunId",
        "destroyed": "destroyed",
        "destroyed_at": "destroyedAt",
        "location": "location",
    },
)
class ResourceMetadata:
    def __init__(
        self,
        *,
        created_at: datetime.datetime,
        name: builtins.str,
        resource_id: builtins.str,
        resource_type: builtins.str,
        tags: typing.Mapping[builtins.str, builtins.str],
        test_run_id: builtins.str,
        destroyed: typing.Optional[builtins.bool] = None,
        destroyed_at: typing.Optional[datetime.datetime] = None,
        location: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Metadata for an individual resource created during testing.

        :param created_at: Timestamp when resource was created.
        :param name: Resource name.
        :param resource_id: Azure resource ID.
        :param resource_type: Azure resource type (e.g., 'Microsoft.Resources/resourceGroups').
        :param tags: Resource tags.
        :param test_run_id: Test run ID that created this resource.
        :param destroyed: Whether this resource was successfully destroyed.
        :param destroyed_at: Timestamp when resource was destroyed.
        :param location: Resource location (Azure region).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8dc0552c1058af02495c191fda190e66ff4124a4219458020996a232874af644)
            check_type(argname="argument created_at", value=created_at, expected_type=type_hints["created_at"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument resource_id", value=resource_id, expected_type=type_hints["resource_id"])
            check_type(argname="argument resource_type", value=resource_type, expected_type=type_hints["resource_type"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument test_run_id", value=test_run_id, expected_type=type_hints["test_run_id"])
            check_type(argname="argument destroyed", value=destroyed, expected_type=type_hints["destroyed"])
            check_type(argname="argument destroyed_at", value=destroyed_at, expected_type=type_hints["destroyed_at"])
            check_type(argname="argument location", value=location, expected_type=type_hints["location"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "created_at": created_at,
            "name": name,
            "resource_id": resource_id,
            "resource_type": resource_type,
            "tags": tags,
            "test_run_id": test_run_id,
        }
        if destroyed is not None:
            self._values["destroyed"] = destroyed
        if destroyed_at is not None:
            self._values["destroyed_at"] = destroyed_at
        if location is not None:
            self._values["location"] = location

    @builtins.property
    def created_at(self) -> datetime.datetime:
        '''Timestamp when resource was created.'''
        result = self._values.get("created_at")
        assert result is not None, "Required property 'created_at' is missing"
        return typing.cast(datetime.datetime, result)

    @builtins.property
    def name(self) -> builtins.str:
        '''Resource name.'''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def resource_id(self) -> builtins.str:
        '''Azure resource ID.'''
        result = self._values.get("resource_id")
        assert result is not None, "Required property 'resource_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def resource_type(self) -> builtins.str:
        '''Azure resource type (e.g., 'Microsoft.Resources/resourceGroups').'''
        result = self._values.get("resource_type")
        assert result is not None, "Required property 'resource_type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def tags(self) -> typing.Mapping[builtins.str, builtins.str]:
        '''Resource tags.'''
        result = self._values.get("tags")
        assert result is not None, "Required property 'tags' is missing"
        return typing.cast(typing.Mapping[builtins.str, builtins.str], result)

    @builtins.property
    def test_run_id(self) -> builtins.str:
        '''Test run ID that created this resource.'''
        result = self._values.get("test_run_id")
        assert result is not None, "Required property 'test_run_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def destroyed(self) -> typing.Optional[builtins.bool]:
        '''Whether this resource was successfully destroyed.'''
        result = self._values.get("destroyed")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def destroyed_at(self) -> typing.Optional[datetime.datetime]:
        '''Timestamp when resource was destroyed.'''
        result = self._values.get("destroyed_at")
        return typing.cast(typing.Optional[datetime.datetime], result)

    @builtins.property
    def location(self) -> typing.Optional[builtins.str]:
        '''Resource location (Azure region).'''
        result = self._values.get("location")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ResourceMetadata(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.ResourceReference",
    jsii_struct_bases=[],
    name_mapping={"id": "id"},
)
class ResourceReference:
    def __init__(self, *, id: builtins.str) -> None:
        '''Resource reference with ID.

        :param id: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__70371c572990fdd62753e30fddf8cbdb1e488a2f9f26d52b0d3e2b5ad28656d2)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "id": id,
        }

    @builtins.property
    def id(self) -> builtins.str:
        result = self._values.get("id")
        assert result is not None, "Required property 'id' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ResourceReference(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.ResourceRetry",
    jsii_struct_bases=[],
    name_mapping={
        "error_message_regex": "errorMessageRegex",
        "interval_seconds": "intervalSeconds",
        "max_interval_seconds": "maxIntervalSeconds",
        "multiplier": "multiplier",
        "randomization_factor": "randomizationFactor",
    },
)
class ResourceRetry:
    def __init__(
        self,
        *,
        error_message_regex: typing.Sequence[builtins.str],
        interval_seconds: typing.Optional[jsii.Number] = None,
        max_interval_seconds: typing.Optional[jsii.Number] = None,
        multiplier: typing.Optional[jsii.Number] = None,
        randomization_factor: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param error_message_regex: A list of regular expressions to match against error messages. If any of the regular expressions match, the request will be retried. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#error_message_regex Resource#error_message_regex}
        :param interval_seconds: The base number of seconds to wait between retries. Default is ``10``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#interval_seconds Resource#interval_seconds}
        :param max_interval_seconds: The maximum number of seconds to wait between retries. Default is ``180``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#max_interval_seconds Resource#max_interval_seconds}
        :param multiplier: The multiplier to apply to the interval between retries. Default is ``1.5``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#multiplier Resource#multiplier}
        :param randomization_factor: The randomization factor to apply to the interval between retries. The formula for the randomized interval is: ``RetryInterval * (random value in range [1 - RandomizationFactor, 1 + RandomizationFactor])``. Therefore set to zero ``0.0`` for no randomization. Default is ``0.5``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#randomization_factor Resource#randomization_factor}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__024e91c8b12ce75919dbcc4b5e0b1db9094d70c07451c163b0e308801852c9c3)
            check_type(argname="argument error_message_regex", value=error_message_regex, expected_type=type_hints["error_message_regex"])
            check_type(argname="argument interval_seconds", value=interval_seconds, expected_type=type_hints["interval_seconds"])
            check_type(argname="argument max_interval_seconds", value=max_interval_seconds, expected_type=type_hints["max_interval_seconds"])
            check_type(argname="argument multiplier", value=multiplier, expected_type=type_hints["multiplier"])
            check_type(argname="argument randomization_factor", value=randomization_factor, expected_type=type_hints["randomization_factor"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "error_message_regex": error_message_regex,
        }
        if interval_seconds is not None:
            self._values["interval_seconds"] = interval_seconds
        if max_interval_seconds is not None:
            self._values["max_interval_seconds"] = max_interval_seconds
        if multiplier is not None:
            self._values["multiplier"] = multiplier
        if randomization_factor is not None:
            self._values["randomization_factor"] = randomization_factor

    @builtins.property
    def error_message_regex(self) -> typing.List[builtins.str]:
        '''A list of regular expressions to match against error messages.

        If any of the regular expressions match, the request will be retried.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#error_message_regex Resource#error_message_regex}
        '''
        result = self._values.get("error_message_regex")
        assert result is not None, "Required property 'error_message_regex' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def interval_seconds(self) -> typing.Optional[jsii.Number]:
        '''The base number of seconds to wait between retries. Default is ``10``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#interval_seconds Resource#interval_seconds}
        '''
        result = self._values.get("interval_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def max_interval_seconds(self) -> typing.Optional[jsii.Number]:
        '''The maximum number of seconds to wait between retries. Default is ``180``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#max_interval_seconds Resource#max_interval_seconds}
        '''
        result = self._values.get("max_interval_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def multiplier(self) -> typing.Optional[jsii.Number]:
        '''The multiplier to apply to the interval between retries. Default is ``1.5``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#multiplier Resource#multiplier}
        '''
        result = self._values.get("multiplier")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def randomization_factor(self) -> typing.Optional[jsii.Number]:
        '''The randomization factor to apply to the interval between retries.

        The formula for the randomized interval is: ``RetryInterval * (random value in range [1 - RandomizationFactor, 1 + RandomizationFactor])``. Therefore set to zero ``0.0`` for no randomization. Default is ``0.5``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#randomization_factor Resource#randomization_factor}
        '''
        result = self._values.get("randomization_factor")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ResourceRetry(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ResourceRetryOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@microsoft/terraform-cdk-constructs.ResourceRetryOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6bb64d0a72a186c4863d2a4a71b30ac970083c75f978e112917a733263aebb1c)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetIntervalSeconds")
    def reset_interval_seconds(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetIntervalSeconds", []))

    @jsii.member(jsii_name="resetMaxIntervalSeconds")
    def reset_max_interval_seconds(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMaxIntervalSeconds", []))

    @jsii.member(jsii_name="resetMultiplier")
    def reset_multiplier(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMultiplier", []))

    @jsii.member(jsii_name="resetRandomizationFactor")
    def reset_randomization_factor(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRandomizationFactor", []))

    @builtins.property
    @jsii.member(jsii_name="errorMessageRegexInput")
    def error_message_regex_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "errorMessageRegexInput"))

    @builtins.property
    @jsii.member(jsii_name="intervalSecondsInput")
    def interval_seconds_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "intervalSecondsInput"))

    @builtins.property
    @jsii.member(jsii_name="maxIntervalSecondsInput")
    def max_interval_seconds_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "maxIntervalSecondsInput"))

    @builtins.property
    @jsii.member(jsii_name="multiplierInput")
    def multiplier_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "multiplierInput"))

    @builtins.property
    @jsii.member(jsii_name="randomizationFactorInput")
    def randomization_factor_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "randomizationFactorInput"))

    @builtins.property
    @jsii.member(jsii_name="errorMessageRegex")
    def error_message_regex(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "errorMessageRegex"))

    @error_message_regex.setter
    def error_message_regex(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__25b8230f793ecd56b881e62949fd842e67d99df864648976c2e13bed7a938654)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "errorMessageRegex", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="intervalSeconds")
    def interval_seconds(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "intervalSeconds"))

    @interval_seconds.setter
    def interval_seconds(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7ed0e0aa54dc53eabceb33268d39eafa992b77b554a143f773ffea7445730a1f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "intervalSeconds", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="maxIntervalSeconds")
    def max_interval_seconds(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "maxIntervalSeconds"))

    @max_interval_seconds.setter
    def max_interval_seconds(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7acfe1be0d5b1089b93b5281bbe4ddfa35b311b3dd4e77b9c22294f4bfacd6c8)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "maxIntervalSeconds", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="multiplier")
    def multiplier(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "multiplier"))

    @multiplier.setter
    def multiplier(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7f98bbdc89b58f2d423b303e43458dfb5fe88d3fe28fc532cf16cb892d747907)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "multiplier", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="randomizationFactor")
    def randomization_factor(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "randomizationFactor"))

    @randomization_factor.setter
    def randomization_factor(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0282de5cab879cf45313e14134319b2259b2e50de1343cdf51a84c04e2e9677d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "randomizationFactor", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ResourceRetry]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ResourceRetry]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ResourceRetry]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e3c2a4029bce73af4eecab3710e0bbcab30af3631ca57e4d7221bc1c2931134f)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.ResourceTimeouts",
    jsii_struct_bases=[],
    name_mapping={
        "create": "create",
        "delete": "delete",
        "read": "read",
        "update": "update",
    },
)
class ResourceTimeouts:
    def __init__(
        self,
        *,
        create: typing.Optional[builtins.str] = None,
        delete: typing.Optional[builtins.str] = None,
        read: typing.Optional[builtins.str] = None,
        update: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param create: A string that can be `parsed as a duration <https://pkg.go.dev/time#ParseDuration>`_ consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#create Resource#create}
        :param delete: A string that can be `parsed as a duration <https://pkg.go.dev/time#ParseDuration>`_ consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#delete Resource#delete}
        :param read: A string that can be `parsed as a duration <https://pkg.go.dev/time#ParseDuration>`_ consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#read Resource#read}
        :param update: A string that can be `parsed as a duration <https://pkg.go.dev/time#ParseDuration>`_ consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#update Resource#update}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d5eda75602061bb145f3d35070438044c4bbb7ca7feb7df8adf7b438026f3d9b)
            check_type(argname="argument create", value=create, expected_type=type_hints["create"])
            check_type(argname="argument delete", value=delete, expected_type=type_hints["delete"])
            check_type(argname="argument read", value=read, expected_type=type_hints["read"])
            check_type(argname="argument update", value=update, expected_type=type_hints["update"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if create is not None:
            self._values["create"] = create
        if delete is not None:
            self._values["delete"] = delete
        if read is not None:
            self._values["read"] = read
        if update is not None:
            self._values["update"] = update

    @builtins.property
    def create(self) -> typing.Optional[builtins.str]:
        '''A string that can be `parsed as a duration <https://pkg.go.dev/time#ParseDuration>`_ consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#create Resource#create}
        '''
        result = self._values.get("create")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def delete(self) -> typing.Optional[builtins.str]:
        '''A string that can be `parsed as a duration <https://pkg.go.dev/time#ParseDuration>`_ consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#delete Resource#delete}
        '''
        result = self._values.get("delete")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def read(self) -> typing.Optional[builtins.str]:
        '''A string that can be `parsed as a duration <https://pkg.go.dev/time#ParseDuration>`_ consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#read Resource#read}
        '''
        result = self._values.get("read")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def update(self) -> typing.Optional[builtins.str]:
        '''A string that can be `parsed as a duration <https://pkg.go.dev/time#ParseDuration>`_ consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/resource#update Resource#update}
        '''
        result = self._values.get("update")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ResourceTimeouts(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ResourceTimeoutsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@microsoft/terraform-cdk-constructs.ResourceTimeoutsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e9dd0b4cb6319942940e117e4eb08f8fe2c13aa394c52a85206e8600f9dace0b)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetCreate")
    def reset_create(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCreate", []))

    @jsii.member(jsii_name="resetDelete")
    def reset_delete(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDelete", []))

    @jsii.member(jsii_name="resetRead")
    def reset_read(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRead", []))

    @jsii.member(jsii_name="resetUpdate")
    def reset_update(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetUpdate", []))

    @builtins.property
    @jsii.member(jsii_name="createInput")
    def create_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "createInput"))

    @builtins.property
    @jsii.member(jsii_name="deleteInput")
    def delete_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "deleteInput"))

    @builtins.property
    @jsii.member(jsii_name="readInput")
    def read_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "readInput"))

    @builtins.property
    @jsii.member(jsii_name="updateInput")
    def update_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "updateInput"))

    @builtins.property
    @jsii.member(jsii_name="create")
    def create(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "create"))

    @create.setter
    def create(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fd8df8efdf1749681e653a7efce9f5db55b5e525f066e2754f6c287f9ae3d92c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "create", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="delete")
    def delete(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "delete"))

    @delete.setter
    def delete(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5ad77ecbaeba8f59286342f048f3683cfdbd1115ab10ee2a355bc41584fa0b03)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "delete", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="read")
    def read(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "read"))

    @read.setter
    def read(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d1275a9ef5ffb9ab2fcb7563a67feee38f587d99ba4cae8e65b7493c9d4786d1)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "read", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="update")
    def update(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "update"))

    @update.setter
    def update(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5281d50a62ebece318860e00e21dbae13c791abdb339dc50b4c46bac442c7019)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "update", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ResourceTimeouts]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ResourceTimeouts]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ResourceTimeouts]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5fb549b00fd4a8c6de83658597b657b96b3d7c272740e27a65c20ccc7187d868)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.RetentionPolicyConfig",
    jsii_struct_bases=[],
    name_mapping={"days": "days", "enabled": "enabled"},
)
class RetentionPolicyConfig:
    def __init__(self, *, days: jsii.Number, enabled: builtins.bool) -> None:
        '''Retention policy configuration.

        :param days: 
        :param enabled: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7638bfc6d836a3bc87e0b0222bc338bd510d5d7a354220a29559904376c0a1a1)
            check_type(argname="argument days", value=days, expected_type=type_hints["days"])
            check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "days": days,
            "enabled": enabled,
        }

    @builtins.property
    def days(self) -> jsii.Number:
        result = self._values.get("days")
        assert result is not None, "Required property 'days' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def enabled(self) -> builtins.bool:
        result = self._values.get("enabled")
        assert result is not None, "Required property 'enabled' is missing"
        return typing.cast(builtins.bool, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RetentionPolicyConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RoleAssignment(
    _AzapiResource_7e7f5b39,
    metaclass=jsii.JSIIMeta,
    jsii_type="@microsoft/terraform-cdk-constructs.RoleAssignment",
):
    '''Unified Azure Role Assignment implementation.

    This class provides a single, version-aware implementation for managing Azure
    Role Assignments. It automatically handles version resolution, schema validation,
    and property transformation.

    **Important Notes:**

    - Role assignments are scoped resources deployed at management group, subscription,
      resource group, or resource level. They do not have a location property as they
      are not region-specific.
    - The ``name`` property (inherited from AzapiResourceProps) is not used. Azure automatically
      generates a deterministic GUID for role assignment names based on the deployment context.
      This ensures idempotent deployments without duplicate role assignments.

    Example::

        Management group scoped assignment - Assign Reader role at management group level
        
        const mgAssignment = new RoleAssignment(this, "mg-assignment", {
          roleDefinitionId: "/providers/Microsoft.Authorization/roleDefinitions/acdd72a7-3385-48ef-bd42-f606fba81ae7",
          principalId: "00000000-0000-0000-0000-000000000000",
          scope: "/providers/Microsoft.Management/managementGroups/my-mg",
          principalType: "Group",
          description: "Grants read access across the entire management group hierarchy",
        });
    '''

    def __init__(
        self,
        scope_: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        principal_id: builtins.str,
        role_definition_id: builtins.str,
        scope: builtins.str,
        condition: typing.Optional[builtins.str] = None,
        condition_version: typing.Optional[builtins.str] = None,
        delegated_managed_identity_resource_id: typing.Optional[builtins.str] = None,
        description: typing.Optional[builtins.str] = None,
        ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
        principal_type: typing.Optional[builtins.str] = None,
        api_version: typing.Optional[builtins.str] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        location: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> None:
        '''Creates a new Azure Role Assignment using the VersionedAzapiResource framework.

        The constructor automatically handles version resolution, schema registration,
        validation, and resource creation.

        :param scope_: - The scope in which to define this construct.
        :param id: - The unique identifier for this instance.
        :param principal_id: The principal ID (object ID) to which the role is assigned This can be a user, group, service principal, or managed identity Required property.
        :param role_definition_id: The role definition ID to assign This can be a built-in or custom role definition Required property.
        :param scope: The scope at which the role assignment is applied Can be a management group, subscription, resource group, or resource Required property.
        :param condition: The conditions on the role assignment Limits the resources it applies to using ABAC expressions Requires conditionVersion to be set when used.
        :param condition_version: Version of the condition syntax Required when condition is specified. Default: undefined
        :param delegated_managed_identity_resource_id: The delegated Azure Resource Id which contains a Managed Identity Applicable only when the principalType is Group Used for scenarios where a group assignment should use a specific managed identity.
        :param description: The role assignment description Provides detailed information about why the assignment was made.
        :param ignore_changes: The lifecycle rules to ignore changes.
        :param principal_type: The type of principal Specifies what kind of identity is being assigned the role. Default: undefined (Azure will auto-detect)
        :param api_version: Explicit API version to use for this resource. If not specified, the latest active version will be automatically resolved. Use this for version pinning when stability is required over latest features. Default: Latest active version from ApiVersionManager
        :param enable_migration_analysis: Whether to enable migration analysis warnings. When true, the framework will analyze the current version for deprecation status and provide migration recommendations in the deployment output. Default: true
        :param enable_transformation: Whether to apply property transformations automatically. When true, properties will be automatically transformed according to the target schema's transformation rules. This enables backward compatibility. Default: true
        :param enable_validation: Whether to validate properties against the schema. When true, all properties will be validated against the API schema before resource creation. Validation errors will cause deployment failures. Default: true
        :param location: The location where the resource should be created. Default: Varies by resource type - see specific resource documentation
        :param monitoring: Monitoring configuration for this resource. Enables integrated monitoring with diagnostic settings, metric alerts, and activity log alerts. All monitoring is optional and disabled by default.
        :param name: The name of the resource.
        :param tags: Tags to apply to the resource.
        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__de7c84fb5d7023a0c1d8714ddb2555fb8c828f0d555ec53d0a106f5ff424a00e)
            check_type(argname="argument scope_", value=scope_, expected_type=type_hints["scope_"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = _RoleAssignmentProps_ee8daa82(
            principal_id=principal_id,
            role_definition_id=role_definition_id,
            scope=scope,
            condition=condition,
            condition_version=condition_version,
            delegated_managed_identity_resource_id=delegated_managed_identity_resource_id,
            description=description,
            ignore_changes=ignore_changes,
            principal_type=principal_type,
            api_version=api_version,
            enable_migration_analysis=enable_migration_analysis,
            enable_transformation=enable_transformation,
            enable_validation=enable_validation,
            location=location,
            monitoring=monitoring,
            name=name,
            tags=tags,
            connection=connection,
            count=count,
            depends_on=depends_on,
            for_each=for_each,
            lifecycle=lifecycle,
            provider=provider,
            provisioners=provisioners,
        )

        jsii.create(self.__class__, self, [scope_, id, props])

    @jsii.member(jsii_name="apiSchema")
    def _api_schema(self) -> _ApiSchema_5ce0490e:
        '''Gets the API schema for the resolved version Uses the framework's schema resolution to get the appropriate schema.'''
        return typing.cast(_ApiSchema_5ce0490e, jsii.invoke(self, "apiSchema", []))

    @jsii.member(jsii_name="createResourceBody")
    def _create_resource_body(self, props: typing.Any) -> typing.Any:
        '''Creates the resource body for the Azure API call Transforms the input properties into the JSON format expected by Azure REST API  Note: Role assignments do not have a location property as they are scoped resources (management group, subscription, resource group, or resource level).

        The scope property is NOT included in the body as it's read-only and
        automatically derived from the parentId.

        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__892baaabfaeac525108fd2ea2509bdf800e2d6a80330a9394be8833254550fb4)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Any, jsii.invoke(self, "createResourceBody", [props]))

    @jsii.member(jsii_name="defaultVersion")
    def _default_version(self) -> builtins.str:
        '''Gets the default API version to use when no explicit version is specified Returns the most recent stable version as the default.'''
        return typing.cast(builtins.str, jsii.invoke(self, "defaultVersion", []))

    @jsii.member(jsii_name="resolveName")
    def _resolve_name(
        self,
        *,
        api_version: typing.Optional[builtins.str] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        location: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> builtins.str:
        '''Overrides the name resolution to generate deterministic GUIDs for role assignments.

        Role assignments require GUID format IDs. This implementation generates a deterministic
        UUID based on the role assignment's key properties to ensure:

        - Same GUID is generated on re-deployments with same parameters
        - Idempotent deployments (no duplicate role assignments)
        - Consistent behavior across deployment runs

        :param api_version: Explicit API version to use for this resource. If not specified, the latest active version will be automatically resolved. Use this for version pinning when stability is required over latest features. Default: Latest active version from ApiVersionManager
        :param enable_migration_analysis: Whether to enable migration analysis warnings. When true, the framework will analyze the current version for deprecation status and provide migration recommendations in the deployment output. Default: true
        :param enable_transformation: Whether to apply property transformations automatically. When true, properties will be automatically transformed according to the target schema's transformation rules. This enables backward compatibility. Default: true
        :param enable_validation: Whether to validate properties against the schema. When true, all properties will be validated against the API schema before resource creation. Validation errors will cause deployment failures. Default: true
        :param location: The location where the resource should be created. Default: Varies by resource type - see specific resource documentation
        :param monitoring: Monitoring configuration for this resource. Enables integrated monitoring with diagnostic settings, metric alerts, and activity log alerts. All monitoring is optional and disabled by default.
        :param name: The name of the resource.
        :param tags: Tags to apply to the resource.
        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        '''
        props = _AzapiResourceProps_141a2340(
            api_version=api_version,
            enable_migration_analysis=enable_migration_analysis,
            enable_transformation=enable_transformation,
            enable_validation=enable_validation,
            location=location,
            monitoring=monitoring,
            name=name,
            tags=tags,
            connection=connection,
            count=count,
            depends_on=depends_on,
            for_each=for_each,
            lifecycle=lifecycle,
            provider=provider,
            provisioners=provisioners,
        )

        return typing.cast(builtins.str, jsii.invoke(self, "resolveName", [props]))

    @jsii.member(jsii_name="resolveParentId")
    def _resolve_parent_id(self, props: typing.Any) -> builtins.str:
        '''Overrides parent ID resolution to use the scope from props Role assignments are scoped resources where the scope IS the parent.

        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c74758db67483e4c40c59626b2fff87a0a49d58a9b10971e3c15c9cbf273f45c)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(builtins.str, jsii.invoke(self, "resolveParentId", [props]))

    @jsii.member(jsii_name="resourceType")
    def _resource_type(self) -> builtins.str:
        '''Gets the Azure resource type for Role Assignments.'''
        return typing.cast(builtins.str, jsii.invoke(self, "resourceType", []))

    @builtins.property
    @jsii.member(jsii_name="assignmentScope")
    def assignment_scope(self) -> builtins.str:
        '''Get the scope of this role assignment.'''
        return typing.cast(builtins.str, jsii.get(self, "assignmentScope"))

    @builtins.property
    @jsii.member(jsii_name="idOutput")
    def id_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "idOutput"))

    @builtins.property
    @jsii.member(jsii_name="nameOutput")
    def name_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "nameOutput"))

    @builtins.property
    @jsii.member(jsii_name="principalId")
    def principal_id(self) -> builtins.str:
        '''Get the principal ID that was granted this role.'''
        return typing.cast(builtins.str, jsii.get(self, "principalId"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def props(self) -> _RoleAssignmentProps_ee8daa82:
        '''The input properties for this Role Assignment instance.'''
        return typing.cast(_RoleAssignmentProps_ee8daa82, jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="resourceId")
    def resource_id(self) -> builtins.str:
        '''Get the full resource identifier for use in other Azure resources Alias for the id property.'''
        return typing.cast(builtins.str, jsii.get(self, "resourceId"))

    @builtins.property
    @jsii.member(jsii_name="roleDefinitionId")
    def role_definition_id(self) -> builtins.str:
        '''Get the role definition ID this assignment references.'''
        return typing.cast(builtins.str, jsii.get(self, "roleDefinitionId"))

    @builtins.property
    @jsii.member(jsii_name="principalType")
    def principal_type(self) -> typing.Optional[builtins.str]:
        '''Get the principal type.'''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "principalType"))


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.RoleAssignmentBody",
    jsii_struct_bases=[],
    name_mapping={"properties": "properties"},
)
class RoleAssignmentBody:
    def __init__(
        self,
        *,
        properties: typing.Union[_RoleAssignmentProperties_d993b254, typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''The resource body interface for Azure Role Assignment API calls This matches the Azure REST API schema for role assignments.

        :param properties: The properties of the role assignment.
        '''
        if isinstance(properties, dict):
            properties = _RoleAssignmentProperties_d993b254(**properties)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2331091adabf612d55e87abaac20314dd1de60c7643c51f5d8f8a9694cd4a099)
            check_type(argname="argument properties", value=properties, expected_type=type_hints["properties"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "properties": properties,
        }

    @builtins.property
    def properties(self) -> _RoleAssignmentProperties_d993b254:
        '''The properties of the role assignment.'''
        result = self._values.get("properties")
        assert result is not None, "Required property 'properties' is missing"
        return typing.cast(_RoleAssignmentProperties_d993b254, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RoleAssignmentBody(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.RoleAssignmentProperties",
    jsii_struct_bases=[],
    name_mapping={
        "principal_id": "principalId",
        "role_definition_id": "roleDefinitionId",
        "scope": "scope",
        "condition": "condition",
        "condition_version": "conditionVersion",
        "delegated_managed_identity_resource_id": "delegatedManagedIdentityResourceId",
        "description": "description",
        "principal_type": "principalType",
    },
)
class RoleAssignmentProperties:
    def __init__(
        self,
        *,
        principal_id: builtins.str,
        role_definition_id: builtins.str,
        scope: builtins.str,
        condition: typing.Optional[builtins.str] = None,
        condition_version: typing.Optional[builtins.str] = None,
        delegated_managed_identity_resource_id: typing.Optional[builtins.str] = None,
        description: typing.Optional[builtins.str] = None,
        principal_type: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties interface for Azure Role Assignment This is required for JSII compliance to support multi-language code generation.

        :param principal_id: The principal ID.
        :param role_definition_id: The role definition ID.
        :param scope: The scope of the role assignment.
        :param condition: The conditions on the role assignment.
        :param condition_version: Version of the condition syntax.
        :param delegated_managed_identity_resource_id: The delegated managed identity resource ID.
        :param description: The role assignment description.
        :param principal_type: The type of principal.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5d31fbcf67760bd526f6587e38b01ec2f20f6f498a5c461f9491eed7eb508312)
            check_type(argname="argument principal_id", value=principal_id, expected_type=type_hints["principal_id"])
            check_type(argname="argument role_definition_id", value=role_definition_id, expected_type=type_hints["role_definition_id"])
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument condition", value=condition, expected_type=type_hints["condition"])
            check_type(argname="argument condition_version", value=condition_version, expected_type=type_hints["condition_version"])
            check_type(argname="argument delegated_managed_identity_resource_id", value=delegated_managed_identity_resource_id, expected_type=type_hints["delegated_managed_identity_resource_id"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument principal_type", value=principal_type, expected_type=type_hints["principal_type"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "principal_id": principal_id,
            "role_definition_id": role_definition_id,
            "scope": scope,
        }
        if condition is not None:
            self._values["condition"] = condition
        if condition_version is not None:
            self._values["condition_version"] = condition_version
        if delegated_managed_identity_resource_id is not None:
            self._values["delegated_managed_identity_resource_id"] = delegated_managed_identity_resource_id
        if description is not None:
            self._values["description"] = description
        if principal_type is not None:
            self._values["principal_type"] = principal_type

    @builtins.property
    def principal_id(self) -> builtins.str:
        '''The principal ID.'''
        result = self._values.get("principal_id")
        assert result is not None, "Required property 'principal_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def role_definition_id(self) -> builtins.str:
        '''The role definition ID.'''
        result = self._values.get("role_definition_id")
        assert result is not None, "Required property 'role_definition_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def scope(self) -> builtins.str:
        '''The scope of the role assignment.'''
        result = self._values.get("scope")
        assert result is not None, "Required property 'scope' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def condition(self) -> typing.Optional[builtins.str]:
        '''The conditions on the role assignment.'''
        result = self._values.get("condition")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def condition_version(self) -> typing.Optional[builtins.str]:
        '''Version of the condition syntax.'''
        result = self._values.get("condition_version")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def delegated_managed_identity_resource_id(self) -> typing.Optional[builtins.str]:
        '''The delegated managed identity resource ID.'''
        result = self._values.get("delegated_managed_identity_resource_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''The role assignment description.'''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def principal_type(self) -> typing.Optional[builtins.str]:
        '''The type of principal.'''
        result = self._values.get("principal_type")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RoleAssignmentProperties(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.RoleAssignmentProps",
    jsii_struct_bases=[_AzapiResourceProps_141a2340],
    name_mapping={
        "connection": "connection",
        "count": "count",
        "depends_on": "dependsOn",
        "for_each": "forEach",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "provisioners": "provisioners",
        "api_version": "apiVersion",
        "enable_migration_analysis": "enableMigrationAnalysis",
        "enable_transformation": "enableTransformation",
        "enable_validation": "enableValidation",
        "location": "location",
        "monitoring": "monitoring",
        "name": "name",
        "tags": "tags",
        "principal_id": "principalId",
        "role_definition_id": "roleDefinitionId",
        "scope": "scope",
        "condition": "condition",
        "condition_version": "conditionVersion",
        "delegated_managed_identity_resource_id": "delegatedManagedIdentityResourceId",
        "description": "description",
        "ignore_changes": "ignoreChanges",
        "principal_type": "principalType",
    },
)
class RoleAssignmentProps(_AzapiResourceProps_141a2340):
    def __init__(
        self,
        *,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
        api_version: typing.Optional[builtins.str] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        location: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        principal_id: builtins.str,
        role_definition_id: builtins.str,
        scope: builtins.str,
        condition: typing.Optional[builtins.str] = None,
        condition_version: typing.Optional[builtins.str] = None,
        delegated_managed_identity_resource_id: typing.Optional[builtins.str] = None,
        description: typing.Optional[builtins.str] = None,
        ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
        principal_type: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for the unified Azure Role Assignment.

        Extends AzapiResourceProps with Role Assignment specific properties.

        **Note on the ``name`` property:** While this interface inherits the ``name`` property
        from AzapiResourceProps, it is not used for role assignments. Azure role assignments
        require GUID format names, which are automatically generated by the construct.
        Any user-provided name value will be ignored in favor of Azure's deterministic
        GUID generation based on the deployment context.

        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        :param api_version: Explicit API version to use for this resource. If not specified, the latest active version will be automatically resolved. Use this for version pinning when stability is required over latest features. Default: Latest active version from ApiVersionManager
        :param enable_migration_analysis: Whether to enable migration analysis warnings. When true, the framework will analyze the current version for deprecation status and provide migration recommendations in the deployment output. Default: true
        :param enable_transformation: Whether to apply property transformations automatically. When true, properties will be automatically transformed according to the target schema's transformation rules. This enables backward compatibility. Default: true
        :param enable_validation: Whether to validate properties against the schema. When true, all properties will be validated against the API schema before resource creation. Validation errors will cause deployment failures. Default: true
        :param location: The location where the resource should be created. Default: Varies by resource type - see specific resource documentation
        :param monitoring: Monitoring configuration for this resource. Enables integrated monitoring with diagnostic settings, metric alerts, and activity log alerts. All monitoring is optional and disabled by default.
        :param name: The name of the resource.
        :param tags: Tags to apply to the resource.
        :param principal_id: The principal ID (object ID) to which the role is assigned This can be a user, group, service principal, or managed identity Required property.
        :param role_definition_id: The role definition ID to assign This can be a built-in or custom role definition Required property.
        :param scope: The scope at which the role assignment is applied Can be a management group, subscription, resource group, or resource Required property.
        :param condition: The conditions on the role assignment Limits the resources it applies to using ABAC expressions Requires conditionVersion to be set when used.
        :param condition_version: Version of the condition syntax Required when condition is specified. Default: undefined
        :param delegated_managed_identity_resource_id: The delegated Azure Resource Id which contains a Managed Identity Applicable only when the principalType is Group Used for scenarios where a group assignment should use a specific managed identity.
        :param description: The role assignment description Provides detailed information about why the assignment was made.
        :param ignore_changes: The lifecycle rules to ignore changes.
        :param principal_type: The type of principal Specifies what kind of identity is being assigned the role. Default: undefined (Azure will auto-detect)
        '''
        if isinstance(lifecycle, dict):
            lifecycle = _cdktf_9a9027ec.TerraformResourceLifecycle(**lifecycle)
        if isinstance(monitoring, dict):
            monitoring = _MonitoringConfig_7c28df74(**monitoring)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__03bec8e53dcf8b41eb1af764c332139e5b12d09c43a8ba1da148faae07c6aa81)
            check_type(argname="argument connection", value=connection, expected_type=type_hints["connection"])
            check_type(argname="argument count", value=count, expected_type=type_hints["count"])
            check_type(argname="argument depends_on", value=depends_on, expected_type=type_hints["depends_on"])
            check_type(argname="argument for_each", value=for_each, expected_type=type_hints["for_each"])
            check_type(argname="argument lifecycle", value=lifecycle, expected_type=type_hints["lifecycle"])
            check_type(argname="argument provider", value=provider, expected_type=type_hints["provider"])
            check_type(argname="argument provisioners", value=provisioners, expected_type=type_hints["provisioners"])
            check_type(argname="argument api_version", value=api_version, expected_type=type_hints["api_version"])
            check_type(argname="argument enable_migration_analysis", value=enable_migration_analysis, expected_type=type_hints["enable_migration_analysis"])
            check_type(argname="argument enable_transformation", value=enable_transformation, expected_type=type_hints["enable_transformation"])
            check_type(argname="argument enable_validation", value=enable_validation, expected_type=type_hints["enable_validation"])
            check_type(argname="argument location", value=location, expected_type=type_hints["location"])
            check_type(argname="argument monitoring", value=monitoring, expected_type=type_hints["monitoring"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument principal_id", value=principal_id, expected_type=type_hints["principal_id"])
            check_type(argname="argument role_definition_id", value=role_definition_id, expected_type=type_hints["role_definition_id"])
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument condition", value=condition, expected_type=type_hints["condition"])
            check_type(argname="argument condition_version", value=condition_version, expected_type=type_hints["condition_version"])
            check_type(argname="argument delegated_managed_identity_resource_id", value=delegated_managed_identity_resource_id, expected_type=type_hints["delegated_managed_identity_resource_id"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument ignore_changes", value=ignore_changes, expected_type=type_hints["ignore_changes"])
            check_type(argname="argument principal_type", value=principal_type, expected_type=type_hints["principal_type"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "principal_id": principal_id,
            "role_definition_id": role_definition_id,
            "scope": scope,
        }
        if connection is not None:
            self._values["connection"] = connection
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if for_each is not None:
            self._values["for_each"] = for_each
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider
        if provisioners is not None:
            self._values["provisioners"] = provisioners
        if api_version is not None:
            self._values["api_version"] = api_version
        if enable_migration_analysis is not None:
            self._values["enable_migration_analysis"] = enable_migration_analysis
        if enable_transformation is not None:
            self._values["enable_transformation"] = enable_transformation
        if enable_validation is not None:
            self._values["enable_validation"] = enable_validation
        if location is not None:
            self._values["location"] = location
        if monitoring is not None:
            self._values["monitoring"] = monitoring
        if name is not None:
            self._values["name"] = name
        if tags is not None:
            self._values["tags"] = tags
        if condition is not None:
            self._values["condition"] = condition
        if condition_version is not None:
            self._values["condition_version"] = condition_version
        if delegated_managed_identity_resource_id is not None:
            self._values["delegated_managed_identity_resource_id"] = delegated_managed_identity_resource_id
        if description is not None:
            self._values["description"] = description
        if ignore_changes is not None:
            self._values["ignore_changes"] = ignore_changes
        if principal_type is not None:
            self._values["principal_type"] = principal_type

    @builtins.property
    def connection(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("connection")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]], result)

    @builtins.property
    def count(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]], result)

    @builtins.property
    def depends_on(
        self,
    ) -> typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]], result)

    @builtins.property
    def for_each(self) -> typing.Optional[_cdktf_9a9027ec.ITerraformIterator]:
        '''
        :stability: experimental
        '''
        result = self._values.get("for_each")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.ITerraformIterator], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[_cdktf_9a9027ec.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformProvider], result)

    @builtins.property
    def provisioners(
        self,
    ) -> typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provisioners")
        return typing.cast(typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]], result)

    @builtins.property
    def api_version(self) -> typing.Optional[builtins.str]:
        '''Explicit API version to use for this resource.

        If not specified, the latest active version will be automatically resolved.
        Use this for version pinning when stability is required over latest features.

        :default: Latest active version from ApiVersionManager

        Example::

            "2024-11-01"
        '''
        result = self._values.get("api_version")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def enable_migration_analysis(self) -> typing.Optional[builtins.bool]:
        '''Whether to enable migration analysis warnings.

        When true, the framework will analyze the current version for deprecation
        status and provide migration recommendations in the deployment output.

        :default: true
        '''
        result = self._values.get("enable_migration_analysis")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_transformation(self) -> typing.Optional[builtins.bool]:
        '''Whether to apply property transformations automatically.

        When true, properties will be automatically transformed according to the
        target schema's transformation rules. This enables backward compatibility.

        :default: true
        '''
        result = self._values.get("enable_transformation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_validation(self) -> typing.Optional[builtins.bool]:
        '''Whether to validate properties against the schema.

        When true, all properties will be validated against the API schema before
        resource creation. Validation errors will cause deployment failures.

        :default: true
        '''
        result = self._values.get("enable_validation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def location(self) -> typing.Optional[builtins.str]:
        '''The location where the resource should be created.

        :default: Varies by resource type - see specific resource documentation

        :remarks:

        Location handling varies by resource type:

        - **Top-level resources**: Most require an explicit location (e.g., "eastus", "westus")
        - **Global resources**: Some use "global" as location (e.g., Private DNS Zones)
        - **Child resources**: Inherit location from parent and should NOT set this property

        Each resource type may provide its own default through the ``resolveLocation()`` method.
        If no location is specified and no default exists, resource creation may fail.

        Example::

            // Child resource (Subnet) - do not set location
            // location: undefined (inherited from parent Virtual Network)
        '''
        result = self._values.get("location")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def monitoring(self) -> typing.Optional[_MonitoringConfig_7c28df74]:
        '''Monitoring configuration for this resource.

        Enables integrated monitoring with diagnostic settings, metric alerts,
        and activity log alerts. All monitoring is optional and disabled by default.

        Example::

            monitoring: {
              enabled: true,
              diagnosticSettings: {
                workspaceId: logAnalytics.id,
                metrics: ['AllMetrics'],
                logs: ['AuditLogs']
              },
              metricAlerts: [{
                name: 'high-cpu-alert',
                severity: 2,
                scopes: [], // Automatically set to this resource
                criteria: { ... },
                actions: [{ actionGroupId: actionGroup.id }]
              }]
            }
        '''
        result = self._values.get("monitoring")
        return typing.cast(typing.Optional[_MonitoringConfig_7c28df74], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the resource.'''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Tags to apply to the resource.'''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def principal_id(self) -> builtins.str:
        '''The principal ID (object ID) to which the role is assigned This can be a user, group, service principal, or managed identity Required property.

        Example::

            "00000000-0000-0000-0000-000000000000"
        '''
        result = self._values.get("principal_id")
        assert result is not None, "Required property 'principal_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def role_definition_id(self) -> builtins.str:
        '''The role definition ID to assign This can be a built-in or custom role definition Required property.

        Example::

            "/providers/Microsoft.Authorization/roleDefinitions/b24988ac-6180-42a0-ab88-20f7382dd24c" (Contributor)
        '''
        result = self._values.get("role_definition_id")
        assert result is not None, "Required property 'role_definition_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def scope(self) -> builtins.str:
        '''The scope at which the role assignment is applied Can be a management group, subscription, resource group, or resource Required property.

        Example::

            "/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/rg-name/providers/Microsoft.Storage/storageAccounts/storage-name"
        '''
        result = self._values.get("scope")
        assert result is not None, "Required property 'scope' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def condition(self) -> typing.Optional[builtins.str]:
        '''The conditions on the role assignment Limits the resources it applies to using ABAC expressions Requires conditionVersion to be set when used.

        Example::

            "@Resource[Microsoft.Storage/storageAccounts/blobServices/containers:name] StringEquals 'logs'"
        '''
        result = self._values.get("condition")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def condition_version(self) -> typing.Optional[builtins.str]:
        '''Version of the condition syntax Required when condition is specified.

        :default: undefined

        Example::

            "2.0"
        '''
        result = self._values.get("condition_version")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def delegated_managed_identity_resource_id(self) -> typing.Optional[builtins.str]:
        '''The delegated Azure Resource Id which contains a Managed Identity Applicable only when the principalType is Group Used for scenarios where a group assignment should use a specific managed identity.

        Example::

            "/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/rg/providers/Microsoft.ManagedIdentity/userAssignedIdentities/identity"
        '''
        result = self._values.get("delegated_managed_identity_resource_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''The role assignment description Provides detailed information about why the assignment was made.

        Example::

            "Grants read access to monitoring team for resource diagnostics"
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ignore_changes(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The lifecycle rules to ignore changes.

        Example::

            ["description"]
        '''
        result = self._values.get("ignore_changes")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def principal_type(self) -> typing.Optional[builtins.str]:
        '''The type of principal Specifies what kind of identity is being assigned the role.

        :default: undefined (Azure will auto-detect)

        Example::

            "Device" - A device identity
        '''
        result = self._values.get("principal_type")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RoleAssignmentProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RoleDefinition(
    _AzapiResource_7e7f5b39,
    metaclass=jsii.JSIIMeta,
    jsii_type="@microsoft/terraform-cdk-constructs.RoleDefinition",
):
    '''Unified Azure Role Definition implementation.

    This class provides a single, version-aware implementation for managing Azure
    Role Definitions. It automatically handles version resolution, schema validation,
    and property transformation.

    Note: Role definitions are tenant-specific resources deployed at subscription or
    management group scope. Unlike most Azure resources, they do not have a location
    property as they are not region-specific.

    Example::

        Basic custom role definition for read-only access to compute resources
        
        Advanced features like data plane actions and complex permissions are supported
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        assignable_scopes: typing.Sequence[builtins.str],
        permissions: typing.Sequence[typing.Union[_RoleDefinitionPermission_5623a628, typing.Dict[builtins.str, typing.Any]]],
        role_name: builtins.str,
        description: typing.Optional[builtins.str] = None,
        ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
        type: typing.Optional[builtins.str] = None,
        api_version: typing.Optional[builtins.str] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        location: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> None:
        '''Creates a new Azure Role Definition using the VersionedAzapiResource framework.

        The constructor automatically handles version resolution, schema registration,
        validation, and resource creation.

        :param scope: - The scope in which to define this construct.
        :param id: - The unique identifier for this instance.
        :param assignable_scopes: An array of scopes where this role can be assigned Can include subscription, resource group, or management group scopes Required property.
        :param permissions: An array of permissions objects that define what actions the role can perform Required property.
        :param role_name: The name of the role definition This is the display name shown in the Azure portal Required property.
        :param description: The role definition description Provides detailed information about what the role allows.
        :param ignore_changes: The lifecycle rules to ignore changes.
        :param type: The type of role definition. Default: "CustomRole"
        :param api_version: Explicit API version to use for this resource. If not specified, the latest active version will be automatically resolved. Use this for version pinning when stability is required over latest features. Default: Latest active version from ApiVersionManager
        :param enable_migration_analysis: Whether to enable migration analysis warnings. When true, the framework will analyze the current version for deprecation status and provide migration recommendations in the deployment output. Default: true
        :param enable_transformation: Whether to apply property transformations automatically. When true, properties will be automatically transformed according to the target schema's transformation rules. This enables backward compatibility. Default: true
        :param enable_validation: Whether to validate properties against the schema. When true, all properties will be validated against the API schema before resource creation. Validation errors will cause deployment failures. Default: true
        :param location: The location where the resource should be created. Default: Varies by resource type - see specific resource documentation
        :param monitoring: Monitoring configuration for this resource. Enables integrated monitoring with diagnostic settings, metric alerts, and activity log alerts. All monitoring is optional and disabled by default.
        :param name: The name of the resource.
        :param tags: Tags to apply to the resource.
        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7969d4ecafedd4e6f4e222892616c115671138615d280f6ed3ea5c9644e8634d)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = _RoleDefinitionProps_4196e132(
            assignable_scopes=assignable_scopes,
            permissions=permissions,
            role_name=role_name,
            description=description,
            ignore_changes=ignore_changes,
            type=type,
            api_version=api_version,
            enable_migration_analysis=enable_migration_analysis,
            enable_transformation=enable_transformation,
            enable_validation=enable_validation,
            location=location,
            monitoring=monitoring,
            name=name,
            tags=tags,
            connection=connection,
            count=count,
            depends_on=depends_on,
            for_each=for_each,
            lifecycle=lifecycle,
            provider=provider,
            provisioners=provisioners,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="apiSchema")
    def _api_schema(self) -> _ApiSchema_5ce0490e:
        '''Gets the API schema for the resolved version Uses the framework's schema resolution to get the appropriate schema.'''
        return typing.cast(_ApiSchema_5ce0490e, jsii.invoke(self, "apiSchema", []))

    @jsii.member(jsii_name="createResourceBody")
    def _create_resource_body(self, props: typing.Any) -> typing.Any:
        '''Creates the resource body for the Azure API call Transforms the input properties into the JSON format expected by Azure REST API.

        Note: Role definitions do not have a location property as they are
        tenant-specific resources deployed at subscription or management group scope.

        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__822850a3d6fa75a5a482c4d91310ac609d9577ab55b90b3c5cdff61cebc5e01c)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Any, jsii.invoke(self, "createResourceBody", [props]))

    @jsii.member(jsii_name="defaultVersion")
    def _default_version(self) -> builtins.str:
        '''Gets the default API version to use when no explicit version is specified Returns the most recent stable version as the default.'''
        return typing.cast(builtins.str, jsii.invoke(self, "defaultVersion", []))

    @jsii.member(jsii_name="resolveName")
    def _resolve_name(
        self,
        *,
        api_version: typing.Optional[builtins.str] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        location: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> builtins.str:
        '''Overrides the name resolution to generate deterministic GUIDs for role definitions.

        Role definitions require GUID format IDs. This implementation generates a deterministic
        UUID based on the role definition's key properties to ensure:

        - Same GUID is generated on re-deployments with same parameters
        - Idempotent deployments (no duplicate role definitions)
        - Consistent behavior across deployment runs

        :param api_version: Explicit API version to use for this resource. If not specified, the latest active version will be automatically resolved. Use this for version pinning when stability is required over latest features. Default: Latest active version from ApiVersionManager
        :param enable_migration_analysis: Whether to enable migration analysis warnings. When true, the framework will analyze the current version for deprecation status and provide migration recommendations in the deployment output. Default: true
        :param enable_transformation: Whether to apply property transformations automatically. When true, properties will be automatically transformed according to the target schema's transformation rules. This enables backward compatibility. Default: true
        :param enable_validation: Whether to validate properties against the schema. When true, all properties will be validated against the API schema before resource creation. Validation errors will cause deployment failures. Default: true
        :param location: The location where the resource should be created. Default: Varies by resource type - see specific resource documentation
        :param monitoring: Monitoring configuration for this resource. Enables integrated monitoring with diagnostic settings, metric alerts, and activity log alerts. All monitoring is optional and disabled by default.
        :param name: The name of the resource.
        :param tags: Tags to apply to the resource.
        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        '''
        props = _AzapiResourceProps_141a2340(
            api_version=api_version,
            enable_migration_analysis=enable_migration_analysis,
            enable_transformation=enable_transformation,
            enable_validation=enable_validation,
            location=location,
            monitoring=monitoring,
            name=name,
            tags=tags,
            connection=connection,
            count=count,
            depends_on=depends_on,
            for_each=for_each,
            lifecycle=lifecycle,
            provider=provider,
            provisioners=provisioners,
        )

        return typing.cast(builtins.str, jsii.invoke(self, "resolveName", [props]))

    @jsii.member(jsii_name="resourceType")
    def _resource_type(self) -> builtins.str:
        '''Gets the Azure resource type for Role Definitions.'''
        return typing.cast(builtins.str, jsii.invoke(self, "resourceType", []))

    @builtins.property
    @jsii.member(jsii_name="idOutput")
    def id_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "idOutput"))

    @builtins.property
    @jsii.member(jsii_name="nameOutput")
    def name_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "nameOutput"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def props(self) -> _RoleDefinitionProps_4196e132:
        '''The input properties for this Role Definition instance.'''
        return typing.cast(_RoleDefinitionProps_4196e132, jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="resourceId")
    def resource_id(self) -> builtins.str:
        '''Get the full resource identifier for use in other Azure resources Alias for the id property.'''
        return typing.cast(builtins.str, jsii.get(self, "resourceId"))

    @builtins.property
    @jsii.member(jsii_name="roleName")
    def role_name(self) -> builtins.str:
        '''Get the role name.'''
        return typing.cast(builtins.str, jsii.get(self, "roleName"))

    @builtins.property
    @jsii.member(jsii_name="roleType")
    def role_type(self) -> builtins.str:
        '''Get the role type.'''
        return typing.cast(builtins.str, jsii.get(self, "roleType"))


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.RoleDefinitionBody",
    jsii_struct_bases=[],
    name_mapping={"properties": "properties"},
)
class RoleDefinitionBody:
    def __init__(
        self,
        *,
        properties: typing.Union[_RoleDefinitionProperties_f78101b5, typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''The resource body interface for Azure Role Definition API calls This matches the Azure REST API schema for role definitions.

        :param properties: The properties of the role definition.
        '''
        if isinstance(properties, dict):
            properties = _RoleDefinitionProperties_f78101b5(**properties)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d4d45dba934decb4422008139afaab5935b2006a344616638e5ea0cd237cf870)
            check_type(argname="argument properties", value=properties, expected_type=type_hints["properties"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "properties": properties,
        }

    @builtins.property
    def properties(self) -> _RoleDefinitionProperties_f78101b5:
        '''The properties of the role definition.'''
        result = self._values.get("properties")
        assert result is not None, "Required property 'properties' is missing"
        return typing.cast(_RoleDefinitionProperties_f78101b5, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RoleDefinitionBody(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.RoleDefinitionPermission",
    jsii_struct_bases=[],
    name_mapping={
        "actions": "actions",
        "data_actions": "dataActions",
        "not_actions": "notActions",
        "not_data_actions": "notDataActions",
    },
)
class RoleDefinitionPermission:
    def __init__(
        self,
        *,
        actions: typing.Optional[typing.Sequence[builtins.str]] = None,
        data_actions: typing.Optional[typing.Sequence[builtins.str]] = None,
        not_actions: typing.Optional[typing.Sequence[builtins.str]] = None,
        not_data_actions: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''Permission configuration for role definitions Defines what actions the role can perform on control plane and data plane.

        :param actions: Array of allowed control plane actions Actions are operations that can be performed on Azure resources.
        :param data_actions: Array of allowed data plane actions Data actions are operations that can be performed on data within resources.
        :param not_actions: Array of excluded control plane actions Actions that are explicitly denied even if included in actions array.
        :param not_data_actions: Array of excluded data plane actions Data actions that are explicitly denied.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__67f9f50e66dc6c020f5644a83d37fb90365639676ed04c2747b68fd64abfb510)
            check_type(argname="argument actions", value=actions, expected_type=type_hints["actions"])
            check_type(argname="argument data_actions", value=data_actions, expected_type=type_hints["data_actions"])
            check_type(argname="argument not_actions", value=not_actions, expected_type=type_hints["not_actions"])
            check_type(argname="argument not_data_actions", value=not_data_actions, expected_type=type_hints["not_data_actions"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if actions is not None:
            self._values["actions"] = actions
        if data_actions is not None:
            self._values["data_actions"] = data_actions
        if not_actions is not None:
            self._values["not_actions"] = not_actions
        if not_data_actions is not None:
            self._values["not_data_actions"] = not_data_actions

    @builtins.property
    def actions(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Array of allowed control plane actions Actions are operations that can be performed on Azure resources.

        Example::

            ["Microsoft.Compute/virtualMachines/read", "Microsoft.Compute/virtualMachines/start/action"]
        '''
        result = self._values.get("actions")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def data_actions(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Array of allowed data plane actions Data actions are operations that can be performed on data within resources.

        Example::

            ["Microsoft.Storage/storageAccounts/blobServices/containers/blobs/read"]
        '''
        result = self._values.get("data_actions")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def not_actions(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Array of excluded control plane actions Actions that are explicitly denied even if included in actions array.

        Example::

            ["Microsoft.Compute/virtualMachines/delete"]
        '''
        result = self._values.get("not_actions")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def not_data_actions(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Array of excluded data plane actions Data actions that are explicitly denied.

        Example::

            ["Microsoft.Storage/storageAccounts/blobServices/containers/blobs/delete"]
        '''
        result = self._values.get("not_data_actions")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RoleDefinitionPermission(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.RoleDefinitionProperties",
    jsii_struct_bases=[],
    name_mapping={
        "assignable_scopes": "assignableScopes",
        "permissions": "permissions",
        "role_name": "roleName",
        "description": "description",
        "type": "type",
    },
)
class RoleDefinitionProperties:
    def __init__(
        self,
        *,
        assignable_scopes: typing.Sequence[builtins.str],
        permissions: typing.Sequence[typing.Union[_RoleDefinitionPermission_5623a628, typing.Dict[builtins.str, typing.Any]]],
        role_name: builtins.str,
        description: typing.Optional[builtins.str] = None,
        type: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties interface for Azure Role Definition This is required for JSII compliance to support multi-language code generation.

        :param assignable_scopes: An array of assignable scopes.
        :param permissions: An array of permissions objects.
        :param role_name: The name of the role definition.
        :param description: The role definition description.
        :param type: The type of role definition.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__45ceef2ceaeb8b1820103fcc378e380971cb312363bcbbfd6990cbefb71dd973)
            check_type(argname="argument assignable_scopes", value=assignable_scopes, expected_type=type_hints["assignable_scopes"])
            check_type(argname="argument permissions", value=permissions, expected_type=type_hints["permissions"])
            check_type(argname="argument role_name", value=role_name, expected_type=type_hints["role_name"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "assignable_scopes": assignable_scopes,
            "permissions": permissions,
            "role_name": role_name,
        }
        if description is not None:
            self._values["description"] = description
        if type is not None:
            self._values["type"] = type

    @builtins.property
    def assignable_scopes(self) -> typing.List[builtins.str]:
        '''An array of assignable scopes.'''
        result = self._values.get("assignable_scopes")
        assert result is not None, "Required property 'assignable_scopes' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def permissions(self) -> typing.List[_RoleDefinitionPermission_5623a628]:
        '''An array of permissions objects.'''
        result = self._values.get("permissions")
        assert result is not None, "Required property 'permissions' is missing"
        return typing.cast(typing.List[_RoleDefinitionPermission_5623a628], result)

    @builtins.property
    def role_name(self) -> builtins.str:
        '''The name of the role definition.'''
        result = self._values.get("role_name")
        assert result is not None, "Required property 'role_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''The role definition description.'''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def type(self) -> typing.Optional[builtins.str]:
        '''The type of role definition.'''
        result = self._values.get("type")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RoleDefinitionProperties(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.RoleDefinitionProps",
    jsii_struct_bases=[_AzapiResourceProps_141a2340],
    name_mapping={
        "connection": "connection",
        "count": "count",
        "depends_on": "dependsOn",
        "for_each": "forEach",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "provisioners": "provisioners",
        "api_version": "apiVersion",
        "enable_migration_analysis": "enableMigrationAnalysis",
        "enable_transformation": "enableTransformation",
        "enable_validation": "enableValidation",
        "location": "location",
        "monitoring": "monitoring",
        "name": "name",
        "tags": "tags",
        "assignable_scopes": "assignableScopes",
        "permissions": "permissions",
        "role_name": "roleName",
        "description": "description",
        "ignore_changes": "ignoreChanges",
        "type": "type",
    },
)
class RoleDefinitionProps(_AzapiResourceProps_141a2340):
    def __init__(
        self,
        *,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
        api_version: typing.Optional[builtins.str] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        location: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        assignable_scopes: typing.Sequence[builtins.str],
        permissions: typing.Sequence[typing.Union[_RoleDefinitionPermission_5623a628, typing.Dict[builtins.str, typing.Any]]],
        role_name: builtins.str,
        description: typing.Optional[builtins.str] = None,
        ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
        type: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for the unified Azure Role Definition.

        Extends AzapiResourceProps with Role Definition specific properties

        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        :param api_version: Explicit API version to use for this resource. If not specified, the latest active version will be automatically resolved. Use this for version pinning when stability is required over latest features. Default: Latest active version from ApiVersionManager
        :param enable_migration_analysis: Whether to enable migration analysis warnings. When true, the framework will analyze the current version for deprecation status and provide migration recommendations in the deployment output. Default: true
        :param enable_transformation: Whether to apply property transformations automatically. When true, properties will be automatically transformed according to the target schema's transformation rules. This enables backward compatibility. Default: true
        :param enable_validation: Whether to validate properties against the schema. When true, all properties will be validated against the API schema before resource creation. Validation errors will cause deployment failures. Default: true
        :param location: The location where the resource should be created. Default: Varies by resource type - see specific resource documentation
        :param monitoring: Monitoring configuration for this resource. Enables integrated monitoring with diagnostic settings, metric alerts, and activity log alerts. All monitoring is optional and disabled by default.
        :param name: The name of the resource.
        :param tags: Tags to apply to the resource.
        :param assignable_scopes: An array of scopes where this role can be assigned Can include subscription, resource group, or management group scopes Required property.
        :param permissions: An array of permissions objects that define what actions the role can perform Required property.
        :param role_name: The name of the role definition This is the display name shown in the Azure portal Required property.
        :param description: The role definition description Provides detailed information about what the role allows.
        :param ignore_changes: The lifecycle rules to ignore changes.
        :param type: The type of role definition. Default: "CustomRole"
        '''
        if isinstance(lifecycle, dict):
            lifecycle = _cdktf_9a9027ec.TerraformResourceLifecycle(**lifecycle)
        if isinstance(monitoring, dict):
            monitoring = _MonitoringConfig_7c28df74(**monitoring)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__425e6ab1f308fd7935b72c47c3fdb8eea9f21615aaa59c995487510e0cbfa9e9)
            check_type(argname="argument connection", value=connection, expected_type=type_hints["connection"])
            check_type(argname="argument count", value=count, expected_type=type_hints["count"])
            check_type(argname="argument depends_on", value=depends_on, expected_type=type_hints["depends_on"])
            check_type(argname="argument for_each", value=for_each, expected_type=type_hints["for_each"])
            check_type(argname="argument lifecycle", value=lifecycle, expected_type=type_hints["lifecycle"])
            check_type(argname="argument provider", value=provider, expected_type=type_hints["provider"])
            check_type(argname="argument provisioners", value=provisioners, expected_type=type_hints["provisioners"])
            check_type(argname="argument api_version", value=api_version, expected_type=type_hints["api_version"])
            check_type(argname="argument enable_migration_analysis", value=enable_migration_analysis, expected_type=type_hints["enable_migration_analysis"])
            check_type(argname="argument enable_transformation", value=enable_transformation, expected_type=type_hints["enable_transformation"])
            check_type(argname="argument enable_validation", value=enable_validation, expected_type=type_hints["enable_validation"])
            check_type(argname="argument location", value=location, expected_type=type_hints["location"])
            check_type(argname="argument monitoring", value=monitoring, expected_type=type_hints["monitoring"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument assignable_scopes", value=assignable_scopes, expected_type=type_hints["assignable_scopes"])
            check_type(argname="argument permissions", value=permissions, expected_type=type_hints["permissions"])
            check_type(argname="argument role_name", value=role_name, expected_type=type_hints["role_name"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument ignore_changes", value=ignore_changes, expected_type=type_hints["ignore_changes"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "assignable_scopes": assignable_scopes,
            "permissions": permissions,
            "role_name": role_name,
        }
        if connection is not None:
            self._values["connection"] = connection
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if for_each is not None:
            self._values["for_each"] = for_each
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider
        if provisioners is not None:
            self._values["provisioners"] = provisioners
        if api_version is not None:
            self._values["api_version"] = api_version
        if enable_migration_analysis is not None:
            self._values["enable_migration_analysis"] = enable_migration_analysis
        if enable_transformation is not None:
            self._values["enable_transformation"] = enable_transformation
        if enable_validation is not None:
            self._values["enable_validation"] = enable_validation
        if location is not None:
            self._values["location"] = location
        if monitoring is not None:
            self._values["monitoring"] = monitoring
        if name is not None:
            self._values["name"] = name
        if tags is not None:
            self._values["tags"] = tags
        if description is not None:
            self._values["description"] = description
        if ignore_changes is not None:
            self._values["ignore_changes"] = ignore_changes
        if type is not None:
            self._values["type"] = type

    @builtins.property
    def connection(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("connection")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]], result)

    @builtins.property
    def count(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]], result)

    @builtins.property
    def depends_on(
        self,
    ) -> typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]], result)

    @builtins.property
    def for_each(self) -> typing.Optional[_cdktf_9a9027ec.ITerraformIterator]:
        '''
        :stability: experimental
        '''
        result = self._values.get("for_each")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.ITerraformIterator], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[_cdktf_9a9027ec.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformProvider], result)

    @builtins.property
    def provisioners(
        self,
    ) -> typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provisioners")
        return typing.cast(typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]], result)

    @builtins.property
    def api_version(self) -> typing.Optional[builtins.str]:
        '''Explicit API version to use for this resource.

        If not specified, the latest active version will be automatically resolved.
        Use this for version pinning when stability is required over latest features.

        :default: Latest active version from ApiVersionManager

        Example::

            "2024-11-01"
        '''
        result = self._values.get("api_version")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def enable_migration_analysis(self) -> typing.Optional[builtins.bool]:
        '''Whether to enable migration analysis warnings.

        When true, the framework will analyze the current version for deprecation
        status and provide migration recommendations in the deployment output.

        :default: true
        '''
        result = self._values.get("enable_migration_analysis")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_transformation(self) -> typing.Optional[builtins.bool]:
        '''Whether to apply property transformations automatically.

        When true, properties will be automatically transformed according to the
        target schema's transformation rules. This enables backward compatibility.

        :default: true
        '''
        result = self._values.get("enable_transformation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_validation(self) -> typing.Optional[builtins.bool]:
        '''Whether to validate properties against the schema.

        When true, all properties will be validated against the API schema before
        resource creation. Validation errors will cause deployment failures.

        :default: true
        '''
        result = self._values.get("enable_validation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def location(self) -> typing.Optional[builtins.str]:
        '''The location where the resource should be created.

        :default: Varies by resource type - see specific resource documentation

        :remarks:

        Location handling varies by resource type:

        - **Top-level resources**: Most require an explicit location (e.g., "eastus", "westus")
        - **Global resources**: Some use "global" as location (e.g., Private DNS Zones)
        - **Child resources**: Inherit location from parent and should NOT set this property

        Each resource type may provide its own default through the ``resolveLocation()`` method.
        If no location is specified and no default exists, resource creation may fail.

        Example::

            // Child resource (Subnet) - do not set location
            // location: undefined (inherited from parent Virtual Network)
        '''
        result = self._values.get("location")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def monitoring(self) -> typing.Optional[_MonitoringConfig_7c28df74]:
        '''Monitoring configuration for this resource.

        Enables integrated monitoring with diagnostic settings, metric alerts,
        and activity log alerts. All monitoring is optional and disabled by default.

        Example::

            monitoring: {
              enabled: true,
              diagnosticSettings: {
                workspaceId: logAnalytics.id,
                metrics: ['AllMetrics'],
                logs: ['AuditLogs']
              },
              metricAlerts: [{
                name: 'high-cpu-alert',
                severity: 2,
                scopes: [], // Automatically set to this resource
                criteria: { ... },
                actions: [{ actionGroupId: actionGroup.id }]
              }]
            }
        '''
        result = self._values.get("monitoring")
        return typing.cast(typing.Optional[_MonitoringConfig_7c28df74], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the resource.'''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Tags to apply to the resource.'''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def assignable_scopes(self) -> typing.List[builtins.str]:
        '''An array of scopes where this role can be assigned Can include subscription, resource group, or management group scopes Required property.

        Example::

            ["/providers/Microsoft.Management/managementGroups/my-mg"]
        '''
        result = self._values.get("assignable_scopes")
        assert result is not None, "Required property 'assignable_scopes' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def permissions(self) -> typing.List[_RoleDefinitionPermission_5623a628]:
        '''An array of permissions objects that define what actions the role can perform Required property.

        Example::

            [
              {
                actions: ["Microsoft.Compute/virtualMachines/read"],
                notActions: [],
                dataActions: [],
                notDataActions: []
              }
            ]
        '''
        result = self._values.get("permissions")
        assert result is not None, "Required property 'permissions' is missing"
        return typing.cast(typing.List[_RoleDefinitionPermission_5623a628], result)

    @builtins.property
    def role_name(self) -> builtins.str:
        '''The name of the role definition This is the display name shown in the Azure portal Required property.

        Example::

            "Virtual Machine Reader"
        '''
        result = self._values.get("role_name")
        assert result is not None, "Required property 'role_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''The role definition description Provides detailed information about what the role allows.

        Example::

            "Can view virtual machines and their properties"
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ignore_changes(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The lifecycle rules to ignore changes.

        Example::

            ["description"]
        '''
        result = self._values.get("ignore_changes")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def type(self) -> typing.Optional[builtins.str]:
        '''The type of role definition.

        :default: "CustomRole"

        Example::

            "CustomRole", "BuiltInRole"
        '''
        result = self._values.get("type")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RoleDefinitionProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.RollingUpgradePolicy",
    jsii_struct_bases=[],
    name_mapping={
        "enable_cross_zone_upgrade": "enableCrossZoneUpgrade",
        "max_batch_instance_percent": "maxBatchInstancePercent",
        "max_unhealthy_instance_percent": "maxUnhealthyInstancePercent",
        "max_unhealthy_upgraded_instance_percent": "maxUnhealthyUpgradedInstancePercent",
        "pause_time_between_batches": "pauseTimeBetweenBatches",
        "prioritize_unhealthy_instances": "prioritizeUnhealthyInstances",
    },
)
class RollingUpgradePolicy:
    def __init__(
        self,
        *,
        enable_cross_zone_upgrade: typing.Optional[builtins.bool] = None,
        max_batch_instance_percent: typing.Optional[jsii.Number] = None,
        max_unhealthy_instance_percent: typing.Optional[jsii.Number] = None,
        max_unhealthy_upgraded_instance_percent: typing.Optional[jsii.Number] = None,
        pause_time_between_batches: typing.Optional[builtins.str] = None,
        prioritize_unhealthy_instances: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Rolling upgrade policy.

        :param enable_cross_zone_upgrade: 
        :param max_batch_instance_percent: 
        :param max_unhealthy_instance_percent: 
        :param max_unhealthy_upgraded_instance_percent: 
        :param pause_time_between_batches: 
        :param prioritize_unhealthy_instances: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__df6b20ff165ab2880d6ca51efd072153f9051d7b651f87eb2ba62ef357f72df3)
            check_type(argname="argument enable_cross_zone_upgrade", value=enable_cross_zone_upgrade, expected_type=type_hints["enable_cross_zone_upgrade"])
            check_type(argname="argument max_batch_instance_percent", value=max_batch_instance_percent, expected_type=type_hints["max_batch_instance_percent"])
            check_type(argname="argument max_unhealthy_instance_percent", value=max_unhealthy_instance_percent, expected_type=type_hints["max_unhealthy_instance_percent"])
            check_type(argname="argument max_unhealthy_upgraded_instance_percent", value=max_unhealthy_upgraded_instance_percent, expected_type=type_hints["max_unhealthy_upgraded_instance_percent"])
            check_type(argname="argument pause_time_between_batches", value=pause_time_between_batches, expected_type=type_hints["pause_time_between_batches"])
            check_type(argname="argument prioritize_unhealthy_instances", value=prioritize_unhealthy_instances, expected_type=type_hints["prioritize_unhealthy_instances"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if enable_cross_zone_upgrade is not None:
            self._values["enable_cross_zone_upgrade"] = enable_cross_zone_upgrade
        if max_batch_instance_percent is not None:
            self._values["max_batch_instance_percent"] = max_batch_instance_percent
        if max_unhealthy_instance_percent is not None:
            self._values["max_unhealthy_instance_percent"] = max_unhealthy_instance_percent
        if max_unhealthy_upgraded_instance_percent is not None:
            self._values["max_unhealthy_upgraded_instance_percent"] = max_unhealthy_upgraded_instance_percent
        if pause_time_between_batches is not None:
            self._values["pause_time_between_batches"] = pause_time_between_batches
        if prioritize_unhealthy_instances is not None:
            self._values["prioritize_unhealthy_instances"] = prioritize_unhealthy_instances

    @builtins.property
    def enable_cross_zone_upgrade(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("enable_cross_zone_upgrade")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def max_batch_instance_percent(self) -> typing.Optional[jsii.Number]:
        result = self._values.get("max_batch_instance_percent")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def max_unhealthy_instance_percent(self) -> typing.Optional[jsii.Number]:
        result = self._values.get("max_unhealthy_instance_percent")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def max_unhealthy_upgraded_instance_percent(self) -> typing.Optional[jsii.Number]:
        result = self._values.get("max_unhealthy_upgraded_instance_percent")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def pause_time_between_batches(self) -> typing.Optional[builtins.str]:
        result = self._values.get("pause_time_between_batches")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def prioritize_unhealthy_instances(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("prioritize_unhealthy_instances")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RollingUpgradePolicy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.ScheduledEventsProfile",
    jsii_struct_bases=[],
    name_mapping={"terminate_notification_profile": "terminateNotificationProfile"},
)
class ScheduledEventsProfile:
    def __init__(
        self,
        *,
        terminate_notification_profile: typing.Optional[typing.Union[_TerminateNotificationProfile_f8017676, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Scheduled events profile.

        :param terminate_notification_profile: 
        '''
        if isinstance(terminate_notification_profile, dict):
            terminate_notification_profile = _TerminateNotificationProfile_f8017676(**terminate_notification_profile)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__eb815f1ddbef62464da1d3f01d48c73e3ce3256bad192161d078e91f6c80260f)
            check_type(argname="argument terminate_notification_profile", value=terminate_notification_profile, expected_type=type_hints["terminate_notification_profile"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if terminate_notification_profile is not None:
            self._values["terminate_notification_profile"] = terminate_notification_profile

    @builtins.property
    def terminate_notification_profile(
        self,
    ) -> typing.Optional[_TerminateNotificationProfile_f8017676]:
        result = self._values.get("terminate_notification_profile")
        return typing.cast(typing.Optional[_TerminateNotificationProfile_f8017676], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ScheduledEventsProfile(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class SchemaMapper(
    metaclass=jsii.JSIIMeta,
    jsii_type="@microsoft/terraform-cdk-constructs.SchemaMapper",
):
    '''SchemaMapper class for property transformation and validation.

    This class provides a comprehensive property transformation engine that enables
    mapping between different API schema versions with full validation support.
    It implements JSII-compliant patterns for multi-language code generation.

    The SchemaMapper handles:

    - Property transformation between schema versions
    - Validation against API schema definitions
    - Default value injection for new properties
    - Nested object and array processing
    - Detailed error reporting with property paths

    Example::

        const schema: ApiSchema = {
          resourceType: 'Microsoft.Resources/resourceGroups',
          version: '2024-11-01',
          properties: {
            name: { dataType: PropertyType.STRING, required: true },
            location: { dataType: PropertyType.STRING, required: true }
          },
          required: ['name', 'location']
        };
        
        const mapper = SchemaMapper.create(schema);
        const result = mapper.validateProperties({ name: 'myRG', location: 'eastus' });
    '''

    @jsii.member(jsii_name="create")
    @builtins.classmethod
    def create(
        cls,
        *,
        properties: typing.Mapping[builtins.str, typing.Union[_PropertyDefinition_2a5c46ac, typing.Dict[builtins.str, typing.Any]]],
        required: typing.Sequence[builtins.str],
        resource_type: builtins.str,
        version: builtins.str,
        deprecated: typing.Optional[typing.Sequence[builtins.str]] = None,
        optional: typing.Optional[typing.Sequence[builtins.str]] = None,
        transformation_rules: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        validation_rules: typing.Optional[typing.Sequence[typing.Union[_PropertyValidation_bb241cd7, typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> _SchemaMapper_cf4ebcd7:
        '''Creates a new SchemaMapper instance for the specified schema.

        This factory method creates a SchemaMapper configured for a specific API schema.
        The schema defines the structure, validation rules, and transformation mappings
        that will be used for property operations.

        :param properties: Dictionary of property definitions keyed by property name Each property defines its type, validation, and metadata.
        :param required: Array of property names that are required Properties listed here must be provided by the user.
        :param resource_type: The Azure resource type this schema applies to.
        :param version: The API version this schema represents.
        :param deprecated: Array of property names that are deprecated Usage of these properties will generate warnings.
        :param optional: Array of property names that are optional Used for documentation and validation optimization.
        :param transformation_rules: Property transformation rules for schema mapping Maps input property names to target property names.
        :param validation_rules: Property-specific validation rules Applied in addition to individual property validation.

        :return: A new SchemaMapper instance configured with the provided schema

        :throws: Error if the schema is invalid or missing required properties

        Example::

            const schema: ApiSchema = {
              resourceType: 'Microsoft.Resources/resourceGroups',
              version: '2024-11-01',
              properties: { name: { dataType: PropertyType.STRING, required: true } },
              required: ['name']
            };
            const mapper = SchemaMapper.create(schema);
        '''
        schema = _ApiSchema_5ce0490e(
            properties=properties,
            required=required,
            resource_type=resource_type,
            version=version,
            deprecated=deprecated,
            optional=optional,
            transformation_rules=transformation_rules,
            validation_rules=validation_rules,
        )

        return typing.cast(_SchemaMapper_cf4ebcd7, jsii.sinvoke(cls, "create", [schema]))

    @jsii.member(jsii_name="applyDefaults")
    def apply_defaults(self, properties: typing.Any) -> typing.Any:
        '''Applies default values to properties based on schema definitions.

        This method injects default values for properties that are not provided
        but have default values defined in the schema. It preserves existing
        property values and only adds defaults for missing properties.

        :param properties: - The properties to apply defaults to.

        :return: New properties object with default values applied

        Example::

            const props = { name: 'myRG' };
            const withDefaults = mapper.applyDefaults(props);
            // If schema defines location default as 'eastus':
            // Result: { name: 'myRG', location: 'eastus' }
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9bc74f355d7d1fbc5878fd5086f6a928f240de6ff73782a583c218a10d828715)
            check_type(argname="argument properties", value=properties, expected_type=type_hints["properties"])
        return typing.cast(typing.Any, jsii.invoke(self, "applyDefaults", [properties]))

    @jsii.member(jsii_name="mapProperty")
    def map_property(
        self,
        property_name: builtins.str,
        value: typing.Any,
        *,
        data_type: builtins.str,
        added_in_version: typing.Optional[builtins.str] = None,
        default_value: typing.Any = None,
        deprecated: typing.Optional[builtins.bool] = None,
        description: typing.Optional[builtins.str] = None,
        removed_in_version: typing.Optional[builtins.str] = None,
        required: typing.Optional[builtins.bool] = None,
        validation: typing.Optional[typing.Sequence[typing.Union[_ValidationRule_f1913ed6, typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> typing.Any:
        '''Maps a single property value using transformation rules.

        This method applies transformation logic to a single property value based on
        the target property definition. It handles type conversion, value mapping,
        and custom transformations.

        :param property_name: - The name of the property being mapped.
        :param value: - The source value to transform.
        :param data_type: The data type of the property Must be one of the PropertyType constants.
        :param added_in_version: The API version in which this property was added Used for compatibility analysis and migration planning.
        :param default_value: Default value to use if property is not provided Type must match the property type.
        :param deprecated: Whether this property is deprecated If true, usage warnings will be generated. Default: false
        :param description: Human-readable description of the property Used for documentation generation and IDE support.
        :param removed_in_version: The API version in which this property was removed Used for compatibility analysis and migration planning.
        :param required: Whether this property is required If true, the property must be provided by the user. Default: false
        :param validation: Array of validation rules to apply to this property Rules are evaluated in order and all must pass.

        :return: The transformed property value

        :throws: Error if the transformation fails or types are incompatible

        Example::

            const targetProp = { dataType: PropertyType.STRING, required: true };
            const mapped = mapper.mapProperty('name', 'myResourceGroup', targetProp);
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__43d584f170c18d0a1f9ce4ebea063952f341a4fd5428b535de04954db03508bc)
            check_type(argname="argument property_name", value=property_name, expected_type=type_hints["property_name"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        target_property = _PropertyDefinition_2a5c46ac(
            data_type=data_type,
            added_in_version=added_in_version,
            default_value=default_value,
            deprecated=deprecated,
            description=description,
            removed_in_version=removed_in_version,
            required=required,
            validation=validation,
        )

        return typing.cast(typing.Any, jsii.invoke(self, "mapProperty", [property_name, value, target_property]))

    @jsii.member(jsii_name="transformProperties")
    def transform_properties(
        self,
        source_props: typing.Any,
        *,
        properties: typing.Mapping[builtins.str, typing.Union[_PropertyDefinition_2a5c46ac, typing.Dict[builtins.str, typing.Any]]],
        required: typing.Sequence[builtins.str],
        resource_type: builtins.str,
        version: builtins.str,
        deprecated: typing.Optional[typing.Sequence[builtins.str]] = None,
        optional: typing.Optional[typing.Sequence[builtins.str]] = None,
        transformation_rules: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        validation_rules: typing.Optional[typing.Sequence[typing.Union[_PropertyValidation_bb241cd7, typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> typing.Any:
        '''Transforms properties from source format to target schema format.

        This method applies transformation rules to convert properties from one schema
        format to another. It handles property renaming, restructuring, type conversion,
        and nested object/array transformations based on the target schema definition.

        :param source_props: - The source properties to transform.
        :param properties: Dictionary of property definitions keyed by property name Each property defines its type, validation, and metadata.
        :param required: Array of property names that are required Properties listed here must be provided by the user.
        :param resource_type: The Azure resource type this schema applies to.
        :param version: The API version this schema represents.
        :param deprecated: Array of property names that are deprecated Usage of these properties will generate warnings.
        :param optional: Array of property names that are optional Used for documentation and validation optimization.
        :param transformation_rules: Property transformation rules for schema mapping Maps input property names to target property names.
        :param validation_rules: Property-specific validation rules Applied in addition to individual property validation.

        :return: The transformed properties matching the target schema format

        :throws: Error if transformation fails due to incompatible types or missing mappings

        Example::

            const sourceProps = { oldName: 'value', location: 'eastus' };
            const targetSchema = {
              transformationRules: { oldName: 'newName' },
              properties: { newName: { dataType: PropertyType.STRING } }
            };
            const transformed = mapper.transformProperties(sourceProps, targetSchema);
            // Result: { newName: 'value', location: 'eastus' }
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ed7a2ae22d9d62578b80294cb5e2742132463bddece8df681e869f07c4734680)
            check_type(argname="argument source_props", value=source_props, expected_type=type_hints["source_props"])
        target_schema = _ApiSchema_5ce0490e(
            properties=properties,
            required=required,
            resource_type=resource_type,
            version=version,
            deprecated=deprecated,
            optional=optional,
            transformation_rules=transformation_rules,
            validation_rules=validation_rules,
        )

        return typing.cast(typing.Any, jsii.invoke(self, "transformProperties", [source_props, target_schema]))

    @jsii.member(jsii_name="validateProperties")
    def validate_properties(self, properties: typing.Any) -> _ValidationResult_87269226:
        '''Validates properties against the schema definition.

        This method performs comprehensive validation of properties against the
        configured schema. It checks required properties, data types, validation rules,
        and provides detailed error reporting with property path information.

        :param properties: - The properties to validate.

        :return: Detailed validation results including errors and warnings

        Example::

            const properties = { name: 'myRG', location: 'eastus', tags: { env: 'dev' } };
            const result = mapper.validateProperties(properties);
            
            if (!result.valid) {
              console.log('Validation errors:', result.errors);
              console.log('Property errors:', result.propertyErrors);
            }
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bfa13727f782f0851343415e4c43c40889fbd50653114d5f10bee312362db43d)
            check_type(argname="argument properties", value=properties, expected_type=type_hints["properties"])
        return typing.cast(_ValidationResult_87269226, jsii.invoke(self, "validateProperties", [properties]))


class SecurityAdminConfiguration(
    _AzapiResource_7e7f5b39,
    metaclass=jsii.JSIIMeta,
    jsii_type="@microsoft/terraform-cdk-constructs.SecurityAdminConfiguration",
):
    '''Azure Virtual Network Manager Security Admin Configuration implementation.

    Security admin configurations define high-priority security rules that are evaluated
    BEFORE traditional Network Security Groups (NSGs). This allows organizations to enforce
    security policies that cannot be overridden by individual teams managing NSGs.

    Key features:

    - Three action types: Allow (NSG can still deny), Deny (stops traffic), AlwaysAllow (forces allow)
    - Higher priority than NSG rules
    - Centralized security policy enforcement
    - Can block high-risk ports organization-wide

    Example::

        // Configuration with service-specific settings:
        const securityConfig = new SecurityAdminConfiguration(this, "security-config", {
          name: "org-security-rules",
          networkManagerId: networkManager.id,
          description: "Organization-wide security enforcement",
          applyOnNetworkIntentPolicyBasedServices: ["None"],
          apiVersion: "2024-05-01"
        });
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        network_manager_id: builtins.str,
        apply_on_network_intent_policy_based_services: typing.Optional[typing.Sequence[builtins.str]] = None,
        description: typing.Optional[builtins.str] = None,
        ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
        api_version: typing.Optional[builtins.str] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        location: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> None:
        '''Creates a new Azure Virtual Network Manager Security Admin Configuration using the AzapiResource framework.

        :param scope: - The scope in which to define this construct.
        :param id: - The unique identifier for this instance.
        :param network_manager_id: Resource ID of the parent Network Manager.
        :param apply_on_network_intent_policy_based_services: Services to apply the security admin configuration on.
        :param description: Optional description of the security admin configuration.
        :param ignore_changes: The lifecycle rules to ignore changes.
        :param api_version: Explicit API version to use for this resource. If not specified, the latest active version will be automatically resolved. Use this for version pinning when stability is required over latest features. Default: Latest active version from ApiVersionManager
        :param enable_migration_analysis: Whether to enable migration analysis warnings. When true, the framework will analyze the current version for deprecation status and provide migration recommendations in the deployment output. Default: true
        :param enable_transformation: Whether to apply property transformations automatically. When true, properties will be automatically transformed according to the target schema's transformation rules. This enables backward compatibility. Default: true
        :param enable_validation: Whether to validate properties against the schema. When true, all properties will be validated against the API schema before resource creation. Validation errors will cause deployment failures. Default: true
        :param location: The location where the resource should be created. Default: Varies by resource type - see specific resource documentation
        :param monitoring: Monitoring configuration for this resource. Enables integrated monitoring with diagnostic settings, metric alerts, and activity log alerts. All monitoring is optional and disabled by default.
        :param name: The name of the resource.
        :param tags: Tags to apply to the resource.
        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__de61fe958c4b0171491310738ade5f0227a9c661d15266c7f0028d4aaebbdfd4)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = _SecurityAdminConfigurationProps_a2d487cb(
            network_manager_id=network_manager_id,
            apply_on_network_intent_policy_based_services=apply_on_network_intent_policy_based_services,
            description=description,
            ignore_changes=ignore_changes,
            api_version=api_version,
            enable_migration_analysis=enable_migration_analysis,
            enable_transformation=enable_transformation,
            enable_validation=enable_validation,
            location=location,
            monitoring=monitoring,
            name=name,
            tags=tags,
            connection=connection,
            count=count,
            depends_on=depends_on,
            for_each=for_each,
            lifecycle=lifecycle,
            provider=provider,
            provisioners=provisioners,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="apiSchema")
    def _api_schema(self) -> _ApiSchema_5ce0490e:
        '''Gets the API schema for the resolved version.'''
        return typing.cast(_ApiSchema_5ce0490e, jsii.invoke(self, "apiSchema", []))

    @jsii.member(jsii_name="createResourceBody")
    def _create_resource_body(self, props: typing.Any) -> typing.Any:
        '''Creates the resource body for the Azure API call.

        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e27270e9fcf85d1d2dd06cb6d667f38782533c8bd36c5f4a0fa7dd3e3ac52575)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Any, jsii.invoke(self, "createResourceBody", [props]))

    @jsii.member(jsii_name="defaultVersion")
    def _default_version(self) -> builtins.str:
        '''Gets the default API version to use when no explicit version is specified.'''
        return typing.cast(builtins.str, jsii.invoke(self, "defaultVersion", []))

    @jsii.member(jsii_name="resolveParentId")
    def _resolve_parent_id(self, props: typing.Any) -> builtins.str:
        '''Resolves the parent resource ID for the Security Admin Configuration Security Admin Configurations are scoped to Network Managers.

        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1032027af6f7301310e227b215de01ad8ab106f1b689ba05173b978499244026)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(builtins.str, jsii.invoke(self, "resolveParentId", [props]))

    @jsii.member(jsii_name="resourceType")
    def _resource_type(self) -> builtins.str:
        '''Gets the Azure resource type for Security Admin Configurations.'''
        return typing.cast(builtins.str, jsii.invoke(self, "resourceType", []))

    @builtins.property
    @jsii.member(jsii_name="idOutput")
    def id_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "idOutput"))

    @builtins.property
    @jsii.member(jsii_name="nameOutput")
    def name_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "nameOutput"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def props(self) -> _SecurityAdminConfigurationProps_a2d487cb:
        '''The input properties for this Security Admin Configuration instance.'''
        return typing.cast(_SecurityAdminConfigurationProps_a2d487cb, jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        '''Get the provisioning state of the Security Admin Configuration.'''
        return typing.cast(builtins.str, jsii.get(self, "provisioningState"))

    @builtins.property
    @jsii.member(jsii_name="provisioningStateOutput")
    def provisioning_state_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "provisioningStateOutput"))

    @builtins.property
    @jsii.member(jsii_name="resourceName")
    def resource_name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "resourceName"))


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.SecurityAdminConfigurationBody",
    jsii_struct_bases=[],
    name_mapping={"properties": "properties"},
)
class SecurityAdminConfigurationBody:
    def __init__(
        self,
        *,
        properties: typing.Optional[typing.Union[_SecurityAdminConfigurationProperties_fd4a713c, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''The resource body interface for Azure Security Admin Configuration API calls.

        :param properties: 
        '''
        if isinstance(properties, dict):
            properties = _SecurityAdminConfigurationProperties_fd4a713c(**properties)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__97a69def9965f85ff89a91e78a3caedb33b082787554e90c7cfb50646fba6301)
            check_type(argname="argument properties", value=properties, expected_type=type_hints["properties"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if properties is not None:
            self._values["properties"] = properties

    @builtins.property
    def properties(
        self,
    ) -> typing.Optional[_SecurityAdminConfigurationProperties_fd4a713c]:
        result = self._values.get("properties")
        return typing.cast(typing.Optional[_SecurityAdminConfigurationProperties_fd4a713c], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecurityAdminConfigurationBody(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.SecurityAdminConfigurationProperties",
    jsii_struct_bases=[],
    name_mapping={
        "apply_on_network_intent_policy_based_services": "applyOnNetworkIntentPolicyBasedServices",
        "description": "description",
    },
)
class SecurityAdminConfigurationProperties:
    def __init__(
        self,
        *,
        apply_on_network_intent_policy_based_services: typing.Optional[typing.Sequence[builtins.str]] = None,
        description: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for Security Admin Configuration body.

        :param apply_on_network_intent_policy_based_services: 
        :param description: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8e875f0959e7256829407724a2ba59f009a7e9f58526170ac921e82e788ea648)
            check_type(argname="argument apply_on_network_intent_policy_based_services", value=apply_on_network_intent_policy_based_services, expected_type=type_hints["apply_on_network_intent_policy_based_services"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if apply_on_network_intent_policy_based_services is not None:
            self._values["apply_on_network_intent_policy_based_services"] = apply_on_network_intent_policy_based_services
        if description is not None:
            self._values["description"] = description

    @builtins.property
    def apply_on_network_intent_policy_based_services(
        self,
    ) -> typing.Optional[typing.List[builtins.str]]:
        result = self._values.get("apply_on_network_intent_policy_based_services")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecurityAdminConfigurationProperties(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.SecurityAdminConfigurationProps",
    jsii_struct_bases=[_AzapiResourceProps_141a2340],
    name_mapping={
        "connection": "connection",
        "count": "count",
        "depends_on": "dependsOn",
        "for_each": "forEach",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "provisioners": "provisioners",
        "api_version": "apiVersion",
        "enable_migration_analysis": "enableMigrationAnalysis",
        "enable_transformation": "enableTransformation",
        "enable_validation": "enableValidation",
        "location": "location",
        "monitoring": "monitoring",
        "name": "name",
        "tags": "tags",
        "network_manager_id": "networkManagerId",
        "apply_on_network_intent_policy_based_services": "applyOnNetworkIntentPolicyBasedServices",
        "description": "description",
        "ignore_changes": "ignoreChanges",
    },
)
class SecurityAdminConfigurationProps(_AzapiResourceProps_141a2340):
    def __init__(
        self,
        *,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
        api_version: typing.Optional[builtins.str] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        location: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        network_manager_id: builtins.str,
        apply_on_network_intent_policy_based_services: typing.Optional[typing.Sequence[builtins.str]] = None,
        description: typing.Optional[builtins.str] = None,
        ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''Properties for the Azure Virtual Network Manager Security Admin Configuration.

        Extends AzapiResourceProps with Security Admin Configuration specific properties

        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        :param api_version: Explicit API version to use for this resource. If not specified, the latest active version will be automatically resolved. Use this for version pinning when stability is required over latest features. Default: Latest active version from ApiVersionManager
        :param enable_migration_analysis: Whether to enable migration analysis warnings. When true, the framework will analyze the current version for deprecation status and provide migration recommendations in the deployment output. Default: true
        :param enable_transformation: Whether to apply property transformations automatically. When true, properties will be automatically transformed according to the target schema's transformation rules. This enables backward compatibility. Default: true
        :param enable_validation: Whether to validate properties against the schema. When true, all properties will be validated against the API schema before resource creation. Validation errors will cause deployment failures. Default: true
        :param location: The location where the resource should be created. Default: Varies by resource type - see specific resource documentation
        :param monitoring: Monitoring configuration for this resource. Enables integrated monitoring with diagnostic settings, metric alerts, and activity log alerts. All monitoring is optional and disabled by default.
        :param name: The name of the resource.
        :param tags: Tags to apply to the resource.
        :param network_manager_id: Resource ID of the parent Network Manager.
        :param apply_on_network_intent_policy_based_services: Services to apply the security admin configuration on.
        :param description: Optional description of the security admin configuration.
        :param ignore_changes: The lifecycle rules to ignore changes.
        '''
        if isinstance(lifecycle, dict):
            lifecycle = _cdktf_9a9027ec.TerraformResourceLifecycle(**lifecycle)
        if isinstance(monitoring, dict):
            monitoring = _MonitoringConfig_7c28df74(**monitoring)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6568fd3da447c201ff0306e003022c09bb59c49c4fcaf9a9b77341e32c82fc30)
            check_type(argname="argument connection", value=connection, expected_type=type_hints["connection"])
            check_type(argname="argument count", value=count, expected_type=type_hints["count"])
            check_type(argname="argument depends_on", value=depends_on, expected_type=type_hints["depends_on"])
            check_type(argname="argument for_each", value=for_each, expected_type=type_hints["for_each"])
            check_type(argname="argument lifecycle", value=lifecycle, expected_type=type_hints["lifecycle"])
            check_type(argname="argument provider", value=provider, expected_type=type_hints["provider"])
            check_type(argname="argument provisioners", value=provisioners, expected_type=type_hints["provisioners"])
            check_type(argname="argument api_version", value=api_version, expected_type=type_hints["api_version"])
            check_type(argname="argument enable_migration_analysis", value=enable_migration_analysis, expected_type=type_hints["enable_migration_analysis"])
            check_type(argname="argument enable_transformation", value=enable_transformation, expected_type=type_hints["enable_transformation"])
            check_type(argname="argument enable_validation", value=enable_validation, expected_type=type_hints["enable_validation"])
            check_type(argname="argument location", value=location, expected_type=type_hints["location"])
            check_type(argname="argument monitoring", value=monitoring, expected_type=type_hints["monitoring"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument network_manager_id", value=network_manager_id, expected_type=type_hints["network_manager_id"])
            check_type(argname="argument apply_on_network_intent_policy_based_services", value=apply_on_network_intent_policy_based_services, expected_type=type_hints["apply_on_network_intent_policy_based_services"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument ignore_changes", value=ignore_changes, expected_type=type_hints["ignore_changes"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "network_manager_id": network_manager_id,
        }
        if connection is not None:
            self._values["connection"] = connection
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if for_each is not None:
            self._values["for_each"] = for_each
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider
        if provisioners is not None:
            self._values["provisioners"] = provisioners
        if api_version is not None:
            self._values["api_version"] = api_version
        if enable_migration_analysis is not None:
            self._values["enable_migration_analysis"] = enable_migration_analysis
        if enable_transformation is not None:
            self._values["enable_transformation"] = enable_transformation
        if enable_validation is not None:
            self._values["enable_validation"] = enable_validation
        if location is not None:
            self._values["location"] = location
        if monitoring is not None:
            self._values["monitoring"] = monitoring
        if name is not None:
            self._values["name"] = name
        if tags is not None:
            self._values["tags"] = tags
        if apply_on_network_intent_policy_based_services is not None:
            self._values["apply_on_network_intent_policy_based_services"] = apply_on_network_intent_policy_based_services
        if description is not None:
            self._values["description"] = description
        if ignore_changes is not None:
            self._values["ignore_changes"] = ignore_changes

    @builtins.property
    def connection(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("connection")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]], result)

    @builtins.property
    def count(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]], result)

    @builtins.property
    def depends_on(
        self,
    ) -> typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]], result)

    @builtins.property
    def for_each(self) -> typing.Optional[_cdktf_9a9027ec.ITerraformIterator]:
        '''
        :stability: experimental
        '''
        result = self._values.get("for_each")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.ITerraformIterator], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[_cdktf_9a9027ec.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformProvider], result)

    @builtins.property
    def provisioners(
        self,
    ) -> typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provisioners")
        return typing.cast(typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]], result)

    @builtins.property
    def api_version(self) -> typing.Optional[builtins.str]:
        '''Explicit API version to use for this resource.

        If not specified, the latest active version will be automatically resolved.
        Use this for version pinning when stability is required over latest features.

        :default: Latest active version from ApiVersionManager

        Example::

            "2024-11-01"
        '''
        result = self._values.get("api_version")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def enable_migration_analysis(self) -> typing.Optional[builtins.bool]:
        '''Whether to enable migration analysis warnings.

        When true, the framework will analyze the current version for deprecation
        status and provide migration recommendations in the deployment output.

        :default: true
        '''
        result = self._values.get("enable_migration_analysis")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_transformation(self) -> typing.Optional[builtins.bool]:
        '''Whether to apply property transformations automatically.

        When true, properties will be automatically transformed according to the
        target schema's transformation rules. This enables backward compatibility.

        :default: true
        '''
        result = self._values.get("enable_transformation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_validation(self) -> typing.Optional[builtins.bool]:
        '''Whether to validate properties against the schema.

        When true, all properties will be validated against the API schema before
        resource creation. Validation errors will cause deployment failures.

        :default: true
        '''
        result = self._values.get("enable_validation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def location(self) -> typing.Optional[builtins.str]:
        '''The location where the resource should be created.

        :default: Varies by resource type - see specific resource documentation

        :remarks:

        Location handling varies by resource type:

        - **Top-level resources**: Most require an explicit location (e.g., "eastus", "westus")
        - **Global resources**: Some use "global" as location (e.g., Private DNS Zones)
        - **Child resources**: Inherit location from parent and should NOT set this property

        Each resource type may provide its own default through the ``resolveLocation()`` method.
        If no location is specified and no default exists, resource creation may fail.

        Example::

            // Child resource (Subnet) - do not set location
            // location: undefined (inherited from parent Virtual Network)
        '''
        result = self._values.get("location")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def monitoring(self) -> typing.Optional[_MonitoringConfig_7c28df74]:
        '''Monitoring configuration for this resource.

        Enables integrated monitoring with diagnostic settings, metric alerts,
        and activity log alerts. All monitoring is optional and disabled by default.

        Example::

            monitoring: {
              enabled: true,
              diagnosticSettings: {
                workspaceId: logAnalytics.id,
                metrics: ['AllMetrics'],
                logs: ['AuditLogs']
              },
              metricAlerts: [{
                name: 'high-cpu-alert',
                severity: 2,
                scopes: [], // Automatically set to this resource
                criteria: { ... },
                actions: [{ actionGroupId: actionGroup.id }]
              }]
            }
        '''
        result = self._values.get("monitoring")
        return typing.cast(typing.Optional[_MonitoringConfig_7c28df74], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the resource.'''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Tags to apply to the resource.'''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def network_manager_id(self) -> builtins.str:
        '''Resource ID of the parent Network Manager.

        Example::

            "/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/rg/providers/Microsoft.Network/networkManagers/vnm"
        '''
        result = self._values.get("network_manager_id")
        assert result is not None, "Required property 'network_manager_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def apply_on_network_intent_policy_based_services(
        self,
    ) -> typing.Optional[typing.List[builtins.str]]:
        '''Services to apply the security admin configuration on.

        Example::

            ["All"]
        '''
        result = self._values.get("apply_on_network_intent_policy_based_services")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''Optional description of the security admin configuration.

        Example::

            "Organization-wide security rules for production workloads"
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ignore_changes(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The lifecycle rules to ignore changes.

        Example::

            ["tags"]
        '''
        result = self._values.get("ignore_changes")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecurityAdminConfigurationProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.SecurityAdminConfigurationRuleGroupItem",
    jsii_struct_bases=[],
    name_mapping={"network_group_id": "networkGroupId"},
)
class SecurityAdminConfigurationRuleGroupItem:
    def __init__(self, *, network_group_id: builtins.str) -> None:
        '''Network group reference for rule collection.

        :param network_group_id: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d3a8b1facce470a2ebaf2b76b878968a076431c8b77317aafc77f751fe1e3ced)
            check_type(argname="argument network_group_id", value=network_group_id, expected_type=type_hints["network_group_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "network_group_id": network_group_id,
        }

    @builtins.property
    def network_group_id(self) -> builtins.str:
        result = self._values.get("network_group_id")
        assert result is not None, "Required property 'network_group_id' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecurityAdminConfigurationRuleGroupItem(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class SecurityAdminRule(
    _AzapiResource_7e7f5b39,
    metaclass=jsii.JSIIMeta,
    jsii_type="@microsoft/terraform-cdk-constructs.SecurityAdminRule",
):
    '''Azure Virtual Network Manager Security Admin Rule implementation.

    Security admin rules define high-priority security policies that are evaluated BEFORE
    traditional Network Security Groups (NSGs). This enables centralized security enforcement
    that cannot be overridden by individual teams.

    Key concepts:

    - Priority: Lower numbers = higher priority (evaluated first)
    - Allow: Permits traffic, but NSG can still deny it
    - Deny: Blocks traffic immediately, no further evaluation
    - AlwaysAllow: Forces traffic to be allowed, overriding NSG denies

    Example::

        // Always allow monitoring traffic:
        const allowMonitoring = new SecurityAdminRule(this, "allow-monitoring", {
          name: "always-allow-monitoring",
          ruleCollectionId: ruleCollection.id,
          description: "Always allow traffic from monitoring systems",
          priority: 50,
          action: "AlwaysAllow",
          direction: "Inbound",
          protocol: "Any",
          sources: [{ addressPrefix: "10.0.0.0/24", addressPrefixType: "IPPrefix" }],
          destinations: [{ addressPrefix: "*", addressPrefixType: "IPPrefix" }]
        });
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        action: builtins.str,
        direction: builtins.str,
        priority: jsii.Number,
        protocol: builtins.str,
        rule_collection_id: builtins.str,
        description: typing.Optional[builtins.str] = None,
        destination_port_ranges: typing.Optional[typing.Sequence[builtins.str]] = None,
        destinations: typing.Optional[typing.Sequence[typing.Union[_AddressPrefixItem_ccd8b167, typing.Dict[builtins.str, typing.Any]]]] = None,
        ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
        source_port_ranges: typing.Optional[typing.Sequence[builtins.str]] = None,
        sources: typing.Optional[typing.Sequence[typing.Union[_AddressPrefixItem_ccd8b167, typing.Dict[builtins.str, typing.Any]]]] = None,
        api_version: typing.Optional[builtins.str] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        location: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> None:
        '''Creates a new Azure Virtual Network Manager Security Admin Rule using the AzapiResource framework.

        :param scope: - The scope in which to define this construct.
        :param id: - The unique identifier for this instance.
        :param action: Action to take when the rule matches - Allow: Allow traffic (NSG can still deny) - Deny: Deny traffic (stops evaluation) - AlwaysAllow: Force allow (overrides NSG denies).
        :param direction: Direction of traffic this rule applies to.
        :param priority: Priority of the rule (1-4096, lower number = higher priority) Rules with lower priority numbers are evaluated first.
        :param protocol: Protocol this rule applies to.
        :param rule_collection_id: Resource ID of the parent Rule Collection.
        :param description: Optional description of the security admin rule.
        :param destination_port_ranges: Destination port ranges Use ["*"] for all ports or specify ranges. Default: ["*"]
        :param destinations: Destination addresses or network groups.
        :param ignore_changes: The lifecycle rules to ignore changes.
        :param source_port_ranges: Source port ranges Use ["*"] for all ports or specify ranges like ["80", "443", "8000-8999"]. Default: ["*"]
        :param sources: Source addresses or network groups.
        :param api_version: Explicit API version to use for this resource. If not specified, the latest active version will be automatically resolved. Use this for version pinning when stability is required over latest features. Default: Latest active version from ApiVersionManager
        :param enable_migration_analysis: Whether to enable migration analysis warnings. When true, the framework will analyze the current version for deprecation status and provide migration recommendations in the deployment output. Default: true
        :param enable_transformation: Whether to apply property transformations automatically. When true, properties will be automatically transformed according to the target schema's transformation rules. This enables backward compatibility. Default: true
        :param enable_validation: Whether to validate properties against the schema. When true, all properties will be validated against the API schema before resource creation. Validation errors will cause deployment failures. Default: true
        :param location: The location where the resource should be created. Default: Varies by resource type - see specific resource documentation
        :param monitoring: Monitoring configuration for this resource. Enables integrated monitoring with diagnostic settings, metric alerts, and activity log alerts. All monitoring is optional and disabled by default.
        :param name: The name of the resource.
        :param tags: Tags to apply to the resource.
        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5a5095cc1460831c453af44e07d7a1abad954a0de1963edc46658783e34a677d)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = _SecurityAdminRuleProps_cb122363(
            action=action,
            direction=direction,
            priority=priority,
            protocol=protocol,
            rule_collection_id=rule_collection_id,
            description=description,
            destination_port_ranges=destination_port_ranges,
            destinations=destinations,
            ignore_changes=ignore_changes,
            source_port_ranges=source_port_ranges,
            sources=sources,
            api_version=api_version,
            enable_migration_analysis=enable_migration_analysis,
            enable_transformation=enable_transformation,
            enable_validation=enable_validation,
            location=location,
            monitoring=monitoring,
            name=name,
            tags=tags,
            connection=connection,
            count=count,
            depends_on=depends_on,
            for_each=for_each,
            lifecycle=lifecycle,
            provider=provider,
            provisioners=provisioners,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="apiSchema")
    def _api_schema(self) -> _ApiSchema_5ce0490e:
        '''Gets the API schema for the resolved version.'''
        return typing.cast(_ApiSchema_5ce0490e, jsii.invoke(self, "apiSchema", []))

    @jsii.member(jsii_name="createResourceBody")
    def _create_resource_body(self, props: typing.Any) -> typing.Any:
        '''Creates the resource body for the Azure API call.

        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4ec77f664aac5fb11ba29b818bbc137bbf2179762800afb578fa4ccb81e2162e)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Any, jsii.invoke(self, "createResourceBody", [props]))

    @jsii.member(jsii_name="defaultVersion")
    def _default_version(self) -> builtins.str:
        '''Gets the default API version to use when no explicit version is specified.'''
        return typing.cast(builtins.str, jsii.invoke(self, "defaultVersion", []))

    @jsii.member(jsii_name="resolveParentId")
    def _resolve_parent_id(self, props: typing.Any) -> builtins.str:
        '''Resolves the parent resource ID for the Security Admin Rule Security Admin Rules are scoped to Rule Collections.

        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9d2b07377060555b8f6ca4cac3e28b5a9afee515d9d7a12b4b04ed8b10dfb47e)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(builtins.str, jsii.invoke(self, "resolveParentId", [props]))

    @jsii.member(jsii_name="resourceType")
    def _resource_type(self) -> builtins.str:
        '''Gets the Azure resource type for Security Admin Rules.'''
        return typing.cast(builtins.str, jsii.invoke(self, "resourceType", []))

    @builtins.property
    @jsii.member(jsii_name="idOutput")
    def id_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "idOutput"))

    @builtins.property
    @jsii.member(jsii_name="nameOutput")
    def name_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "nameOutput"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def props(self) -> _SecurityAdminRuleProps_cb122363:
        '''The input properties for this Security Admin Rule instance.'''
        return typing.cast(_SecurityAdminRuleProps_cb122363, jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        '''Get the provisioning state of the Security Admin Rule.'''
        return typing.cast(builtins.str, jsii.get(self, "provisioningState"))

    @builtins.property
    @jsii.member(jsii_name="provisioningStateOutput")
    def provisioning_state_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "provisioningStateOutput"))

    @builtins.property
    @jsii.member(jsii_name="resourceName")
    def resource_name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "resourceName"))

    @builtins.property
    @jsii.member(jsii_name="ruleAction")
    def rule_action(self) -> builtins.str:
        '''Get the action of the rule.'''
        return typing.cast(builtins.str, jsii.get(self, "ruleAction"))

    @builtins.property
    @jsii.member(jsii_name="rulePriority")
    def rule_priority(self) -> jsii.Number:
        '''Get the priority of the rule.'''
        return typing.cast(jsii.Number, jsii.get(self, "rulePriority"))


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.SecurityAdminRuleBody",
    jsii_struct_bases=[],
    name_mapping={"kind": "kind", "properties": "properties"},
)
class SecurityAdminRuleBody:
    def __init__(
        self,
        *,
        kind: builtins.str,
        properties: typing.Union[_SecurityAdminRuleProperties_239a5478, typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''The resource body interface for Azure Security Admin Rule API calls.

        :param kind: 
        :param properties: 
        '''
        if isinstance(properties, dict):
            properties = _SecurityAdminRuleProperties_239a5478(**properties)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__254d3e38448eb991f949ad52f0ebff3416a2234864fd2a19577d8b41f0e78f05)
            check_type(argname="argument kind", value=kind, expected_type=type_hints["kind"])
            check_type(argname="argument properties", value=properties, expected_type=type_hints["properties"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "kind": kind,
            "properties": properties,
        }

    @builtins.property
    def kind(self) -> builtins.str:
        result = self._values.get("kind")
        assert result is not None, "Required property 'kind' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def properties(self) -> _SecurityAdminRuleProperties_239a5478:
        result = self._values.get("properties")
        assert result is not None, "Required property 'properties' is missing"
        return typing.cast(_SecurityAdminRuleProperties_239a5478, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecurityAdminRuleBody(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class SecurityAdminRuleCollection(
    _AzapiResource_7e7f5b39,
    metaclass=jsii.JSIIMeta,
    jsii_type="@microsoft/terraform-cdk-constructs.SecurityAdminRuleCollection",
):
    '''Azure Virtual Network Manager Security Admin Rule Collection implementation.

    Rule collections group related security admin rules together and define which network
    groups receive those rules. This allows for organized rule management and targeted
    application of security policies.

    Example::

        // Rule collection applied to multiple network groups:
        const allowMonitoring = new SecurityAdminRuleCollection(this, "allow-monitoring", {
          name: "allow-monitoring-traffic",
          securityAdminConfigurationId: securityConfig.id,
          description: "Always allow monitoring and security scanner traffic",
          appliesToGroups: [
            { networkGroupId: productionGroup.id },
            { networkGroupId: stagingGroup.id }
          ],
          apiVersion: "2024-05-01"
        });
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        applies_to_groups: typing.Sequence[typing.Union[_SecurityAdminConfigurationRuleGroupItem_29d670e4, typing.Dict[builtins.str, typing.Any]]],
        security_admin_configuration_id: builtins.str,
        description: typing.Optional[builtins.str] = None,
        ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
        api_version: typing.Optional[builtins.str] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        location: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> None:
        '''Creates a new Azure Virtual Network Manager Security Admin Rule Collection using the AzapiResource framework.

        :param scope: - The scope in which to define this construct.
        :param id: - The unique identifier for this instance.
        :param applies_to_groups: Network groups to apply this rule collection to Each item specifies a network group that will receive these rules.
        :param security_admin_configuration_id: Resource ID of the parent Security Admin Configuration.
        :param description: Optional description of the rule collection.
        :param ignore_changes: The lifecycle rules to ignore changes.
        :param api_version: Explicit API version to use for this resource. If not specified, the latest active version will be automatically resolved. Use this for version pinning when stability is required over latest features. Default: Latest active version from ApiVersionManager
        :param enable_migration_analysis: Whether to enable migration analysis warnings. When true, the framework will analyze the current version for deprecation status and provide migration recommendations in the deployment output. Default: true
        :param enable_transformation: Whether to apply property transformations automatically. When true, properties will be automatically transformed according to the target schema's transformation rules. This enables backward compatibility. Default: true
        :param enable_validation: Whether to validate properties against the schema. When true, all properties will be validated against the API schema before resource creation. Validation errors will cause deployment failures. Default: true
        :param location: The location where the resource should be created. Default: Varies by resource type - see specific resource documentation
        :param monitoring: Monitoring configuration for this resource. Enables integrated monitoring with diagnostic settings, metric alerts, and activity log alerts. All monitoring is optional and disabled by default.
        :param name: The name of the resource.
        :param tags: Tags to apply to the resource.
        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1f4e16d7ea09625415c4be9adda694ea176dde4d202ca6e97c81301109656ca5)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = _SecurityAdminRuleCollectionProps_7f0467b9(
            applies_to_groups=applies_to_groups,
            security_admin_configuration_id=security_admin_configuration_id,
            description=description,
            ignore_changes=ignore_changes,
            api_version=api_version,
            enable_migration_analysis=enable_migration_analysis,
            enable_transformation=enable_transformation,
            enable_validation=enable_validation,
            location=location,
            monitoring=monitoring,
            name=name,
            tags=tags,
            connection=connection,
            count=count,
            depends_on=depends_on,
            for_each=for_each,
            lifecycle=lifecycle,
            provider=provider,
            provisioners=provisioners,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="apiSchema")
    def _api_schema(self) -> _ApiSchema_5ce0490e:
        '''Gets the API schema for the resolved version.'''
        return typing.cast(_ApiSchema_5ce0490e, jsii.invoke(self, "apiSchema", []))

    @jsii.member(jsii_name="createResourceBody")
    def _create_resource_body(self, props: typing.Any) -> typing.Any:
        '''Creates the resource body for the Azure API call.

        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__41c0459860a5857517050caf3a7d806ab4ec84d0aa7e822a9a7fa85d240b3f22)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Any, jsii.invoke(self, "createResourceBody", [props]))

    @jsii.member(jsii_name="defaultVersion")
    def _default_version(self) -> builtins.str:
        '''Gets the default API version to use when no explicit version is specified.'''
        return typing.cast(builtins.str, jsii.invoke(self, "defaultVersion", []))

    @jsii.member(jsii_name="resolveParentId")
    def _resolve_parent_id(self, props: typing.Any) -> builtins.str:
        '''Resolves the parent resource ID for the Rule Collection Rule Collections are scoped to Security Admin Configurations.

        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1c4fcd4db527474d25c37242924aba05682089bd694ee2b2950869ffef18d656)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(builtins.str, jsii.invoke(self, "resolveParentId", [props]))

    @jsii.member(jsii_name="resourceType")
    def _resource_type(self) -> builtins.str:
        '''Gets the Azure resource type for Rule Collections.'''
        return typing.cast(builtins.str, jsii.invoke(self, "resourceType", []))

    @builtins.property
    @jsii.member(jsii_name="idOutput")
    def id_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "idOutput"))

    @builtins.property
    @jsii.member(jsii_name="nameOutput")
    def name_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "nameOutput"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def props(self) -> _SecurityAdminRuleCollectionProps_7f0467b9:
        '''The input properties for this Rule Collection instance.'''
        return typing.cast(_SecurityAdminRuleCollectionProps_7f0467b9, jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        '''Get the provisioning state of the Rule Collection.'''
        return typing.cast(builtins.str, jsii.get(self, "provisioningState"))

    @builtins.property
    @jsii.member(jsii_name="provisioningStateOutput")
    def provisioning_state_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "provisioningStateOutput"))

    @builtins.property
    @jsii.member(jsii_name="resourceName")
    def resource_name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "resourceName"))


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.SecurityAdminRuleCollectionBody",
    jsii_struct_bases=[],
    name_mapping={"properties": "properties"},
)
class SecurityAdminRuleCollectionBody:
    def __init__(
        self,
        *,
        properties: typing.Union[_SecurityAdminRuleCollectionProperties_40adae7c, typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''The resource body interface for Azure Rule Collection API calls.

        :param properties: 
        '''
        if isinstance(properties, dict):
            properties = _SecurityAdminRuleCollectionProperties_40adae7c(**properties)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__31433914b4ab9d7d00aecc2cdce2ac720a13951b3a9b0d72a1ce51f2cc7fe676)
            check_type(argname="argument properties", value=properties, expected_type=type_hints["properties"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "properties": properties,
        }

    @builtins.property
    def properties(self) -> _SecurityAdminRuleCollectionProperties_40adae7c:
        result = self._values.get("properties")
        assert result is not None, "Required property 'properties' is missing"
        return typing.cast(_SecurityAdminRuleCollectionProperties_40adae7c, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecurityAdminRuleCollectionBody(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.SecurityAdminRuleCollectionProperties",
    jsii_struct_bases=[],
    name_mapping={
        "applies_to_groups": "appliesToGroups",
        "description": "description",
    },
)
class SecurityAdminRuleCollectionProperties:
    def __init__(
        self,
        *,
        applies_to_groups: typing.Sequence[typing.Union[_SecurityAdminConfigurationRuleGroupItem_29d670e4, typing.Dict[builtins.str, typing.Any]]],
        description: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for Rule Collection body.

        :param applies_to_groups: 
        :param description: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__64b2f7b55fcb3a37d072669265f49a99097781d561169a7a6ea8f61546024cba)
            check_type(argname="argument applies_to_groups", value=applies_to_groups, expected_type=type_hints["applies_to_groups"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "applies_to_groups": applies_to_groups,
        }
        if description is not None:
            self._values["description"] = description

    @builtins.property
    def applies_to_groups(
        self,
    ) -> typing.List[_SecurityAdminConfigurationRuleGroupItem_29d670e4]:
        result = self._values.get("applies_to_groups")
        assert result is not None, "Required property 'applies_to_groups' is missing"
        return typing.cast(typing.List[_SecurityAdminConfigurationRuleGroupItem_29d670e4], result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecurityAdminRuleCollectionProperties(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.SecurityAdminRuleCollectionProps",
    jsii_struct_bases=[_AzapiResourceProps_141a2340],
    name_mapping={
        "connection": "connection",
        "count": "count",
        "depends_on": "dependsOn",
        "for_each": "forEach",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "provisioners": "provisioners",
        "api_version": "apiVersion",
        "enable_migration_analysis": "enableMigrationAnalysis",
        "enable_transformation": "enableTransformation",
        "enable_validation": "enableValidation",
        "location": "location",
        "monitoring": "monitoring",
        "name": "name",
        "tags": "tags",
        "applies_to_groups": "appliesToGroups",
        "security_admin_configuration_id": "securityAdminConfigurationId",
        "description": "description",
        "ignore_changes": "ignoreChanges",
    },
)
class SecurityAdminRuleCollectionProps(_AzapiResourceProps_141a2340):
    def __init__(
        self,
        *,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
        api_version: typing.Optional[builtins.str] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        location: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        applies_to_groups: typing.Sequence[typing.Union[_SecurityAdminConfigurationRuleGroupItem_29d670e4, typing.Dict[builtins.str, typing.Any]]],
        security_admin_configuration_id: builtins.str,
        description: typing.Optional[builtins.str] = None,
        ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''Properties for the Azure Virtual Network Manager Security Admin Rule Collection.

        Extends AzapiResourceProps with Rule Collection specific properties

        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        :param api_version: Explicit API version to use for this resource. If not specified, the latest active version will be automatically resolved. Use this for version pinning when stability is required over latest features. Default: Latest active version from ApiVersionManager
        :param enable_migration_analysis: Whether to enable migration analysis warnings. When true, the framework will analyze the current version for deprecation status and provide migration recommendations in the deployment output. Default: true
        :param enable_transformation: Whether to apply property transformations automatically. When true, properties will be automatically transformed according to the target schema's transformation rules. This enables backward compatibility. Default: true
        :param enable_validation: Whether to validate properties against the schema. When true, all properties will be validated against the API schema before resource creation. Validation errors will cause deployment failures. Default: true
        :param location: The location where the resource should be created. Default: Varies by resource type - see specific resource documentation
        :param monitoring: Monitoring configuration for this resource. Enables integrated monitoring with diagnostic settings, metric alerts, and activity log alerts. All monitoring is optional and disabled by default.
        :param name: The name of the resource.
        :param tags: Tags to apply to the resource.
        :param applies_to_groups: Network groups to apply this rule collection to Each item specifies a network group that will receive these rules.
        :param security_admin_configuration_id: Resource ID of the parent Security Admin Configuration.
        :param description: Optional description of the rule collection.
        :param ignore_changes: The lifecycle rules to ignore changes.
        '''
        if isinstance(lifecycle, dict):
            lifecycle = _cdktf_9a9027ec.TerraformResourceLifecycle(**lifecycle)
        if isinstance(monitoring, dict):
            monitoring = _MonitoringConfig_7c28df74(**monitoring)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1e8659f827657eb4a4053397a6d45ac8383eacd32b01abd27ef416df560ac923)
            check_type(argname="argument connection", value=connection, expected_type=type_hints["connection"])
            check_type(argname="argument count", value=count, expected_type=type_hints["count"])
            check_type(argname="argument depends_on", value=depends_on, expected_type=type_hints["depends_on"])
            check_type(argname="argument for_each", value=for_each, expected_type=type_hints["for_each"])
            check_type(argname="argument lifecycle", value=lifecycle, expected_type=type_hints["lifecycle"])
            check_type(argname="argument provider", value=provider, expected_type=type_hints["provider"])
            check_type(argname="argument provisioners", value=provisioners, expected_type=type_hints["provisioners"])
            check_type(argname="argument api_version", value=api_version, expected_type=type_hints["api_version"])
            check_type(argname="argument enable_migration_analysis", value=enable_migration_analysis, expected_type=type_hints["enable_migration_analysis"])
            check_type(argname="argument enable_transformation", value=enable_transformation, expected_type=type_hints["enable_transformation"])
            check_type(argname="argument enable_validation", value=enable_validation, expected_type=type_hints["enable_validation"])
            check_type(argname="argument location", value=location, expected_type=type_hints["location"])
            check_type(argname="argument monitoring", value=monitoring, expected_type=type_hints["monitoring"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument applies_to_groups", value=applies_to_groups, expected_type=type_hints["applies_to_groups"])
            check_type(argname="argument security_admin_configuration_id", value=security_admin_configuration_id, expected_type=type_hints["security_admin_configuration_id"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument ignore_changes", value=ignore_changes, expected_type=type_hints["ignore_changes"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "applies_to_groups": applies_to_groups,
            "security_admin_configuration_id": security_admin_configuration_id,
        }
        if connection is not None:
            self._values["connection"] = connection
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if for_each is not None:
            self._values["for_each"] = for_each
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider
        if provisioners is not None:
            self._values["provisioners"] = provisioners
        if api_version is not None:
            self._values["api_version"] = api_version
        if enable_migration_analysis is not None:
            self._values["enable_migration_analysis"] = enable_migration_analysis
        if enable_transformation is not None:
            self._values["enable_transformation"] = enable_transformation
        if enable_validation is not None:
            self._values["enable_validation"] = enable_validation
        if location is not None:
            self._values["location"] = location
        if monitoring is not None:
            self._values["monitoring"] = monitoring
        if name is not None:
            self._values["name"] = name
        if tags is not None:
            self._values["tags"] = tags
        if description is not None:
            self._values["description"] = description
        if ignore_changes is not None:
            self._values["ignore_changes"] = ignore_changes

    @builtins.property
    def connection(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("connection")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]], result)

    @builtins.property
    def count(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]], result)

    @builtins.property
    def depends_on(
        self,
    ) -> typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]], result)

    @builtins.property
    def for_each(self) -> typing.Optional[_cdktf_9a9027ec.ITerraformIterator]:
        '''
        :stability: experimental
        '''
        result = self._values.get("for_each")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.ITerraformIterator], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[_cdktf_9a9027ec.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformProvider], result)

    @builtins.property
    def provisioners(
        self,
    ) -> typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provisioners")
        return typing.cast(typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]], result)

    @builtins.property
    def api_version(self) -> typing.Optional[builtins.str]:
        '''Explicit API version to use for this resource.

        If not specified, the latest active version will be automatically resolved.
        Use this for version pinning when stability is required over latest features.

        :default: Latest active version from ApiVersionManager

        Example::

            "2024-11-01"
        '''
        result = self._values.get("api_version")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def enable_migration_analysis(self) -> typing.Optional[builtins.bool]:
        '''Whether to enable migration analysis warnings.

        When true, the framework will analyze the current version for deprecation
        status and provide migration recommendations in the deployment output.

        :default: true
        '''
        result = self._values.get("enable_migration_analysis")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_transformation(self) -> typing.Optional[builtins.bool]:
        '''Whether to apply property transformations automatically.

        When true, properties will be automatically transformed according to the
        target schema's transformation rules. This enables backward compatibility.

        :default: true
        '''
        result = self._values.get("enable_transformation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_validation(self) -> typing.Optional[builtins.bool]:
        '''Whether to validate properties against the schema.

        When true, all properties will be validated against the API schema before
        resource creation. Validation errors will cause deployment failures.

        :default: true
        '''
        result = self._values.get("enable_validation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def location(self) -> typing.Optional[builtins.str]:
        '''The location where the resource should be created.

        :default: Varies by resource type - see specific resource documentation

        :remarks:

        Location handling varies by resource type:

        - **Top-level resources**: Most require an explicit location (e.g., "eastus", "westus")
        - **Global resources**: Some use "global" as location (e.g., Private DNS Zones)
        - **Child resources**: Inherit location from parent and should NOT set this property

        Each resource type may provide its own default through the ``resolveLocation()`` method.
        If no location is specified and no default exists, resource creation may fail.

        Example::

            // Child resource (Subnet) - do not set location
            // location: undefined (inherited from parent Virtual Network)
        '''
        result = self._values.get("location")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def monitoring(self) -> typing.Optional[_MonitoringConfig_7c28df74]:
        '''Monitoring configuration for this resource.

        Enables integrated monitoring with diagnostic settings, metric alerts,
        and activity log alerts. All monitoring is optional and disabled by default.

        Example::

            monitoring: {
              enabled: true,
              diagnosticSettings: {
                workspaceId: logAnalytics.id,
                metrics: ['AllMetrics'],
                logs: ['AuditLogs']
              },
              metricAlerts: [{
                name: 'high-cpu-alert',
                severity: 2,
                scopes: [], // Automatically set to this resource
                criteria: { ... },
                actions: [{ actionGroupId: actionGroup.id }]
              }]
            }
        '''
        result = self._values.get("monitoring")
        return typing.cast(typing.Optional[_MonitoringConfig_7c28df74], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the resource.'''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Tags to apply to the resource.'''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def applies_to_groups(
        self,
    ) -> typing.List[_SecurityAdminConfigurationRuleGroupItem_29d670e4]:
        '''Network groups to apply this rule collection to Each item specifies a network group that will receive these rules.'''
        result = self._values.get("applies_to_groups")
        assert result is not None, "Required property 'applies_to_groups' is missing"
        return typing.cast(typing.List[_SecurityAdminConfigurationRuleGroupItem_29d670e4], result)

    @builtins.property
    def security_admin_configuration_id(self) -> builtins.str:
        '''Resource ID of the parent Security Admin Configuration.

        Example::

            "/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/rg/providers/Microsoft.Network/networkManagers/vnm/securityAdminConfigurations/config"
        '''
        result = self._values.get("security_admin_configuration_id")
        assert result is not None, "Required property 'security_admin_configuration_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''Optional description of the rule collection.

        Example::

            "Rules to block high-risk ports"
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ignore_changes(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The lifecycle rules to ignore changes.

        Example::

            ["tags"]
        '''
        result = self._values.get("ignore_changes")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecurityAdminRuleCollectionProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.SecurityAdminRuleProperties",
    jsii_struct_bases=[],
    name_mapping={
        "action": "action",
        "direction": "direction",
        "priority": "priority",
        "protocol": "protocol",
        "description": "description",
        "destination_port_ranges": "destinationPortRanges",
        "destinations": "destinations",
        "source_port_ranges": "sourcePortRanges",
        "sources": "sources",
    },
)
class SecurityAdminRuleProperties:
    def __init__(
        self,
        *,
        action: builtins.str,
        direction: builtins.str,
        priority: jsii.Number,
        protocol: builtins.str,
        description: typing.Optional[builtins.str] = None,
        destination_port_ranges: typing.Optional[typing.Sequence[builtins.str]] = None,
        destinations: typing.Optional[typing.Sequence[typing.Union[_AddressPrefixItem_ccd8b167, typing.Dict[builtins.str, typing.Any]]]] = None,
        source_port_ranges: typing.Optional[typing.Sequence[builtins.str]] = None,
        sources: typing.Optional[typing.Sequence[typing.Union[_AddressPrefixItem_ccd8b167, typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Properties for Security Admin Rule body.

        :param action: 
        :param direction: 
        :param priority: 
        :param protocol: 
        :param description: 
        :param destination_port_ranges: 
        :param destinations: 
        :param source_port_ranges: 
        :param sources: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__41add7f24d9488e49e4dd4c555d06394c0b3a9a90b9236ee62f446e898d68d25)
            check_type(argname="argument action", value=action, expected_type=type_hints["action"])
            check_type(argname="argument direction", value=direction, expected_type=type_hints["direction"])
            check_type(argname="argument priority", value=priority, expected_type=type_hints["priority"])
            check_type(argname="argument protocol", value=protocol, expected_type=type_hints["protocol"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument destination_port_ranges", value=destination_port_ranges, expected_type=type_hints["destination_port_ranges"])
            check_type(argname="argument destinations", value=destinations, expected_type=type_hints["destinations"])
            check_type(argname="argument source_port_ranges", value=source_port_ranges, expected_type=type_hints["source_port_ranges"])
            check_type(argname="argument sources", value=sources, expected_type=type_hints["sources"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "action": action,
            "direction": direction,
            "priority": priority,
            "protocol": protocol,
        }
        if description is not None:
            self._values["description"] = description
        if destination_port_ranges is not None:
            self._values["destination_port_ranges"] = destination_port_ranges
        if destinations is not None:
            self._values["destinations"] = destinations
        if source_port_ranges is not None:
            self._values["source_port_ranges"] = source_port_ranges
        if sources is not None:
            self._values["sources"] = sources

    @builtins.property
    def action(self) -> builtins.str:
        result = self._values.get("action")
        assert result is not None, "Required property 'action' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def direction(self) -> builtins.str:
        result = self._values.get("direction")
        assert result is not None, "Required property 'direction' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def priority(self) -> jsii.Number:
        result = self._values.get("priority")
        assert result is not None, "Required property 'priority' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def protocol(self) -> builtins.str:
        result = self._values.get("protocol")
        assert result is not None, "Required property 'protocol' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def destination_port_ranges(self) -> typing.Optional[typing.List[builtins.str]]:
        result = self._values.get("destination_port_ranges")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def destinations(self) -> typing.Optional[typing.List[_AddressPrefixItem_ccd8b167]]:
        result = self._values.get("destinations")
        return typing.cast(typing.Optional[typing.List[_AddressPrefixItem_ccd8b167]], result)

    @builtins.property
    def source_port_ranges(self) -> typing.Optional[typing.List[builtins.str]]:
        result = self._values.get("source_port_ranges")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def sources(self) -> typing.Optional[typing.List[_AddressPrefixItem_ccd8b167]]:
        result = self._values.get("sources")
        return typing.cast(typing.Optional[typing.List[_AddressPrefixItem_ccd8b167]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecurityAdminRuleProperties(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.SecurityAdminRuleProps",
    jsii_struct_bases=[_AzapiResourceProps_141a2340],
    name_mapping={
        "connection": "connection",
        "count": "count",
        "depends_on": "dependsOn",
        "for_each": "forEach",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "provisioners": "provisioners",
        "api_version": "apiVersion",
        "enable_migration_analysis": "enableMigrationAnalysis",
        "enable_transformation": "enableTransformation",
        "enable_validation": "enableValidation",
        "location": "location",
        "monitoring": "monitoring",
        "name": "name",
        "tags": "tags",
        "action": "action",
        "direction": "direction",
        "priority": "priority",
        "protocol": "protocol",
        "rule_collection_id": "ruleCollectionId",
        "description": "description",
        "destination_port_ranges": "destinationPortRanges",
        "destinations": "destinations",
        "ignore_changes": "ignoreChanges",
        "source_port_ranges": "sourcePortRanges",
        "sources": "sources",
    },
)
class SecurityAdminRuleProps(_AzapiResourceProps_141a2340):
    def __init__(
        self,
        *,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
        api_version: typing.Optional[builtins.str] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        location: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        action: builtins.str,
        direction: builtins.str,
        priority: jsii.Number,
        protocol: builtins.str,
        rule_collection_id: builtins.str,
        description: typing.Optional[builtins.str] = None,
        destination_port_ranges: typing.Optional[typing.Sequence[builtins.str]] = None,
        destinations: typing.Optional[typing.Sequence[typing.Union[_AddressPrefixItem_ccd8b167, typing.Dict[builtins.str, typing.Any]]]] = None,
        ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
        source_port_ranges: typing.Optional[typing.Sequence[builtins.str]] = None,
        sources: typing.Optional[typing.Sequence[typing.Union[_AddressPrefixItem_ccd8b167, typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Properties for the Azure Virtual Network Manager Security Admin Rule.

        Extends AzapiResourceProps with Security Admin Rule specific properties

        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        :param api_version: Explicit API version to use for this resource. If not specified, the latest active version will be automatically resolved. Use this for version pinning when stability is required over latest features. Default: Latest active version from ApiVersionManager
        :param enable_migration_analysis: Whether to enable migration analysis warnings. When true, the framework will analyze the current version for deprecation status and provide migration recommendations in the deployment output. Default: true
        :param enable_transformation: Whether to apply property transformations automatically. When true, properties will be automatically transformed according to the target schema's transformation rules. This enables backward compatibility. Default: true
        :param enable_validation: Whether to validate properties against the schema. When true, all properties will be validated against the API schema before resource creation. Validation errors will cause deployment failures. Default: true
        :param location: The location where the resource should be created. Default: Varies by resource type - see specific resource documentation
        :param monitoring: Monitoring configuration for this resource. Enables integrated monitoring with diagnostic settings, metric alerts, and activity log alerts. All monitoring is optional and disabled by default.
        :param name: The name of the resource.
        :param tags: Tags to apply to the resource.
        :param action: Action to take when the rule matches - Allow: Allow traffic (NSG can still deny) - Deny: Deny traffic (stops evaluation) - AlwaysAllow: Force allow (overrides NSG denies).
        :param direction: Direction of traffic this rule applies to.
        :param priority: Priority of the rule (1-4096, lower number = higher priority) Rules with lower priority numbers are evaluated first.
        :param protocol: Protocol this rule applies to.
        :param rule_collection_id: Resource ID of the parent Rule Collection.
        :param description: Optional description of the security admin rule.
        :param destination_port_ranges: Destination port ranges Use ["*"] for all ports or specify ranges. Default: ["*"]
        :param destinations: Destination addresses or network groups.
        :param ignore_changes: The lifecycle rules to ignore changes.
        :param source_port_ranges: Source port ranges Use ["*"] for all ports or specify ranges like ["80", "443", "8000-8999"]. Default: ["*"]
        :param sources: Source addresses or network groups.
        '''
        if isinstance(lifecycle, dict):
            lifecycle = _cdktf_9a9027ec.TerraformResourceLifecycle(**lifecycle)
        if isinstance(monitoring, dict):
            monitoring = _MonitoringConfig_7c28df74(**monitoring)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7ce34db17a650321bfe258e1fdfb1187d08cf202f660ac7eb0b648defb0cce6e)
            check_type(argname="argument connection", value=connection, expected_type=type_hints["connection"])
            check_type(argname="argument count", value=count, expected_type=type_hints["count"])
            check_type(argname="argument depends_on", value=depends_on, expected_type=type_hints["depends_on"])
            check_type(argname="argument for_each", value=for_each, expected_type=type_hints["for_each"])
            check_type(argname="argument lifecycle", value=lifecycle, expected_type=type_hints["lifecycle"])
            check_type(argname="argument provider", value=provider, expected_type=type_hints["provider"])
            check_type(argname="argument provisioners", value=provisioners, expected_type=type_hints["provisioners"])
            check_type(argname="argument api_version", value=api_version, expected_type=type_hints["api_version"])
            check_type(argname="argument enable_migration_analysis", value=enable_migration_analysis, expected_type=type_hints["enable_migration_analysis"])
            check_type(argname="argument enable_transformation", value=enable_transformation, expected_type=type_hints["enable_transformation"])
            check_type(argname="argument enable_validation", value=enable_validation, expected_type=type_hints["enable_validation"])
            check_type(argname="argument location", value=location, expected_type=type_hints["location"])
            check_type(argname="argument monitoring", value=monitoring, expected_type=type_hints["monitoring"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument action", value=action, expected_type=type_hints["action"])
            check_type(argname="argument direction", value=direction, expected_type=type_hints["direction"])
            check_type(argname="argument priority", value=priority, expected_type=type_hints["priority"])
            check_type(argname="argument protocol", value=protocol, expected_type=type_hints["protocol"])
            check_type(argname="argument rule_collection_id", value=rule_collection_id, expected_type=type_hints["rule_collection_id"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument destination_port_ranges", value=destination_port_ranges, expected_type=type_hints["destination_port_ranges"])
            check_type(argname="argument destinations", value=destinations, expected_type=type_hints["destinations"])
            check_type(argname="argument ignore_changes", value=ignore_changes, expected_type=type_hints["ignore_changes"])
            check_type(argname="argument source_port_ranges", value=source_port_ranges, expected_type=type_hints["source_port_ranges"])
            check_type(argname="argument sources", value=sources, expected_type=type_hints["sources"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "action": action,
            "direction": direction,
            "priority": priority,
            "protocol": protocol,
            "rule_collection_id": rule_collection_id,
        }
        if connection is not None:
            self._values["connection"] = connection
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if for_each is not None:
            self._values["for_each"] = for_each
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider
        if provisioners is not None:
            self._values["provisioners"] = provisioners
        if api_version is not None:
            self._values["api_version"] = api_version
        if enable_migration_analysis is not None:
            self._values["enable_migration_analysis"] = enable_migration_analysis
        if enable_transformation is not None:
            self._values["enable_transformation"] = enable_transformation
        if enable_validation is not None:
            self._values["enable_validation"] = enable_validation
        if location is not None:
            self._values["location"] = location
        if monitoring is not None:
            self._values["monitoring"] = monitoring
        if name is not None:
            self._values["name"] = name
        if tags is not None:
            self._values["tags"] = tags
        if description is not None:
            self._values["description"] = description
        if destination_port_ranges is not None:
            self._values["destination_port_ranges"] = destination_port_ranges
        if destinations is not None:
            self._values["destinations"] = destinations
        if ignore_changes is not None:
            self._values["ignore_changes"] = ignore_changes
        if source_port_ranges is not None:
            self._values["source_port_ranges"] = source_port_ranges
        if sources is not None:
            self._values["sources"] = sources

    @builtins.property
    def connection(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("connection")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]], result)

    @builtins.property
    def count(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]], result)

    @builtins.property
    def depends_on(
        self,
    ) -> typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]], result)

    @builtins.property
    def for_each(self) -> typing.Optional[_cdktf_9a9027ec.ITerraformIterator]:
        '''
        :stability: experimental
        '''
        result = self._values.get("for_each")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.ITerraformIterator], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[_cdktf_9a9027ec.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformProvider], result)

    @builtins.property
    def provisioners(
        self,
    ) -> typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provisioners")
        return typing.cast(typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]], result)

    @builtins.property
    def api_version(self) -> typing.Optional[builtins.str]:
        '''Explicit API version to use for this resource.

        If not specified, the latest active version will be automatically resolved.
        Use this for version pinning when stability is required over latest features.

        :default: Latest active version from ApiVersionManager

        Example::

            "2024-11-01"
        '''
        result = self._values.get("api_version")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def enable_migration_analysis(self) -> typing.Optional[builtins.bool]:
        '''Whether to enable migration analysis warnings.

        When true, the framework will analyze the current version for deprecation
        status and provide migration recommendations in the deployment output.

        :default: true
        '''
        result = self._values.get("enable_migration_analysis")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_transformation(self) -> typing.Optional[builtins.bool]:
        '''Whether to apply property transformations automatically.

        When true, properties will be automatically transformed according to the
        target schema's transformation rules. This enables backward compatibility.

        :default: true
        '''
        result = self._values.get("enable_transformation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_validation(self) -> typing.Optional[builtins.bool]:
        '''Whether to validate properties against the schema.

        When true, all properties will be validated against the API schema before
        resource creation. Validation errors will cause deployment failures.

        :default: true
        '''
        result = self._values.get("enable_validation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def location(self) -> typing.Optional[builtins.str]:
        '''The location where the resource should be created.

        :default: Varies by resource type - see specific resource documentation

        :remarks:

        Location handling varies by resource type:

        - **Top-level resources**: Most require an explicit location (e.g., "eastus", "westus")
        - **Global resources**: Some use "global" as location (e.g., Private DNS Zones)
        - **Child resources**: Inherit location from parent and should NOT set this property

        Each resource type may provide its own default through the ``resolveLocation()`` method.
        If no location is specified and no default exists, resource creation may fail.

        Example::

            // Child resource (Subnet) - do not set location
            // location: undefined (inherited from parent Virtual Network)
        '''
        result = self._values.get("location")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def monitoring(self) -> typing.Optional[_MonitoringConfig_7c28df74]:
        '''Monitoring configuration for this resource.

        Enables integrated monitoring with diagnostic settings, metric alerts,
        and activity log alerts. All monitoring is optional and disabled by default.

        Example::

            monitoring: {
              enabled: true,
              diagnosticSettings: {
                workspaceId: logAnalytics.id,
                metrics: ['AllMetrics'],
                logs: ['AuditLogs']
              },
              metricAlerts: [{
                name: 'high-cpu-alert',
                severity: 2,
                scopes: [], // Automatically set to this resource
                criteria: { ... },
                actions: [{ actionGroupId: actionGroup.id }]
              }]
            }
        '''
        result = self._values.get("monitoring")
        return typing.cast(typing.Optional[_MonitoringConfig_7c28df74], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the resource.'''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Tags to apply to the resource.'''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def action(self) -> builtins.str:
        '''Action to take when the rule matches - Allow: Allow traffic (NSG can still deny) - Deny: Deny traffic (stops evaluation) - AlwaysAllow: Force allow (overrides NSG denies).

        Example::

            "AlwaysAllow"
        '''
        result = self._values.get("action")
        assert result is not None, "Required property 'action' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def direction(self) -> builtins.str:
        '''Direction of traffic this rule applies to.

        Example::

            "Outbound"
        '''
        result = self._values.get("direction")
        assert result is not None, "Required property 'direction' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def priority(self) -> jsii.Number:
        '''Priority of the rule (1-4096, lower number = higher priority) Rules with lower priority numbers are evaluated first.

        Example::

            100
        '''
        result = self._values.get("priority")
        assert result is not None, "Required property 'priority' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def protocol(self) -> builtins.str:
        '''Protocol this rule applies to.

        Example::

            "Any"
        '''
        result = self._values.get("protocol")
        assert result is not None, "Required property 'protocol' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def rule_collection_id(self) -> builtins.str:
        '''Resource ID of the parent Rule Collection.

        Example::

            "/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/rg/providers/Microsoft.Network/networkManagers/vnm/securityAdminConfigurations/config/ruleCollections/collection"
        '''
        result = self._values.get("rule_collection_id")
        assert result is not None, "Required property 'rule_collection_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''Optional description of the security admin rule.

        Example::

            "Block SSH access from internet"
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def destination_port_ranges(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Destination port ranges Use ["*"] for all ports or specify ranges.

        :default: ["*"]

        Example::

            ["3389", "5985-5986"]
        '''
        result = self._values.get("destination_port_ranges")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def destinations(self) -> typing.Optional[typing.List[_AddressPrefixItem_ccd8b167]]:
        '''Destination addresses or network groups.

        Example::

            [{ addressPrefix: "Internet", addressPrefixType: "ServiceTag" }]
        '''
        result = self._values.get("destinations")
        return typing.cast(typing.Optional[typing.List[_AddressPrefixItem_ccd8b167]], result)

    @builtins.property
    def ignore_changes(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The lifecycle rules to ignore changes.

        Example::

            ["tags"]
        '''
        result = self._values.get("ignore_changes")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def source_port_ranges(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Source port ranges Use ["*"] for all ports or specify ranges like ["80", "443", "8000-8999"].

        :default: ["*"]

        Example::

            ["80", "443"]
        '''
        result = self._values.get("source_port_ranges")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def sources(self) -> typing.Optional[typing.List[_AddressPrefixItem_ccd8b167]]:
        '''Source addresses or network groups.

        Example::

            [{ addressPrefix: "10.0.0.0/8", addressPrefixType: "IPPrefix" }]
        '''
        result = self._values.get("sources")
        return typing.cast(typing.Optional[typing.List[_AddressPrefixItem_ccd8b167]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecurityAdminRuleProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.SecurityRule",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "properties": "properties"},
)
class SecurityRule:
    def __init__(
        self,
        *,
        name: builtins.str,
        properties: typing.Union[_SecurityRuleProperties_74ae9ffc, typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''Security rule configuration for Network Security Group.

        :param name: The name of the security rule Must be unique within the NSG.
        :param properties: Properties of the security rule.
        '''
        if isinstance(properties, dict):
            properties = _SecurityRuleProperties_74ae9ffc(**properties)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6f8e843ecbf8c77df48f0c18b5485511e2fd4bbc551c07c170736ebd7fbff8c5)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument properties", value=properties, expected_type=type_hints["properties"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
            "properties": properties,
        }

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the security rule Must be unique within the NSG.'''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def properties(self) -> _SecurityRuleProperties_74ae9ffc:
        '''Properties of the security rule.'''
        result = self._values.get("properties")
        assert result is not None, "Required property 'properties' is missing"
        return typing.cast(_SecurityRuleProperties_74ae9ffc, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecurityRule(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.SecurityRuleProperties",
    jsii_struct_bases=[],
    name_mapping={
        "access": "access",
        "direction": "direction",
        "priority": "priority",
        "protocol": "protocol",
        "description": "description",
        "destination_address_prefix": "destinationAddressPrefix",
        "destination_address_prefixes": "destinationAddressPrefixes",
        "destination_application_security_groups": "destinationApplicationSecurityGroups",
        "destination_port_range": "destinationPortRange",
        "destination_port_ranges": "destinationPortRanges",
        "source_address_prefix": "sourceAddressPrefix",
        "source_address_prefixes": "sourceAddressPrefixes",
        "source_application_security_groups": "sourceApplicationSecurityGroups",
        "source_port_range": "sourcePortRange",
        "source_port_ranges": "sourcePortRanges",
    },
)
class SecurityRuleProperties:
    def __init__(
        self,
        *,
        access: builtins.str,
        direction: builtins.str,
        priority: jsii.Number,
        protocol: builtins.str,
        description: typing.Optional[builtins.str] = None,
        destination_address_prefix: typing.Optional[builtins.str] = None,
        destination_address_prefixes: typing.Optional[typing.Sequence[builtins.str]] = None,
        destination_application_security_groups: typing.Optional[typing.Sequence[typing.Any]] = None,
        destination_port_range: typing.Optional[builtins.str] = None,
        destination_port_ranges: typing.Optional[typing.Sequence[builtins.str]] = None,
        source_address_prefix: typing.Optional[builtins.str] = None,
        source_address_prefixes: typing.Optional[typing.Sequence[builtins.str]] = None,
        source_application_security_groups: typing.Optional[typing.Sequence[typing.Any]] = None,
        source_port_range: typing.Optional[builtins.str] = None,
        source_port_ranges: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''Properties for a security rule.

        :param access: The network traffic is allowed or denied Must be "Allow" or "Deny".
        :param direction: The direction of the rule Must be "Inbound" or "Outbound".
        :param priority: The priority of the rule Value must be between 100 and 4096 Lower values have higher priority.
        :param protocol: Network protocol this rule applies to.
        :param description: A description for this rule Restricted to 140 characters.
        :param destination_address_prefix: The destination address prefix.
        :param destination_address_prefixes: The destination address prefixes (for multiple destinations).
        :param destination_application_security_groups: Destination application security groups.
        :param destination_port_range: The destination port or range.
        :param destination_port_ranges: The destination port ranges (for multiple ranges).
        :param source_address_prefix: The source address prefix.
        :param source_address_prefixes: The source address prefixes (for multiple sources).
        :param source_application_security_groups: Source application security groups.
        :param source_port_range: The source port or range.
        :param source_port_ranges: The source port ranges (for multiple ranges).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9010680f24da9b75b135d487c22fb1a34d2186be8eb4ac50211c88d0baedacd9)
            check_type(argname="argument access", value=access, expected_type=type_hints["access"])
            check_type(argname="argument direction", value=direction, expected_type=type_hints["direction"])
            check_type(argname="argument priority", value=priority, expected_type=type_hints["priority"])
            check_type(argname="argument protocol", value=protocol, expected_type=type_hints["protocol"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument destination_address_prefix", value=destination_address_prefix, expected_type=type_hints["destination_address_prefix"])
            check_type(argname="argument destination_address_prefixes", value=destination_address_prefixes, expected_type=type_hints["destination_address_prefixes"])
            check_type(argname="argument destination_application_security_groups", value=destination_application_security_groups, expected_type=type_hints["destination_application_security_groups"])
            check_type(argname="argument destination_port_range", value=destination_port_range, expected_type=type_hints["destination_port_range"])
            check_type(argname="argument destination_port_ranges", value=destination_port_ranges, expected_type=type_hints["destination_port_ranges"])
            check_type(argname="argument source_address_prefix", value=source_address_prefix, expected_type=type_hints["source_address_prefix"])
            check_type(argname="argument source_address_prefixes", value=source_address_prefixes, expected_type=type_hints["source_address_prefixes"])
            check_type(argname="argument source_application_security_groups", value=source_application_security_groups, expected_type=type_hints["source_application_security_groups"])
            check_type(argname="argument source_port_range", value=source_port_range, expected_type=type_hints["source_port_range"])
            check_type(argname="argument source_port_ranges", value=source_port_ranges, expected_type=type_hints["source_port_ranges"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "access": access,
            "direction": direction,
            "priority": priority,
            "protocol": protocol,
        }
        if description is not None:
            self._values["description"] = description
        if destination_address_prefix is not None:
            self._values["destination_address_prefix"] = destination_address_prefix
        if destination_address_prefixes is not None:
            self._values["destination_address_prefixes"] = destination_address_prefixes
        if destination_application_security_groups is not None:
            self._values["destination_application_security_groups"] = destination_application_security_groups
        if destination_port_range is not None:
            self._values["destination_port_range"] = destination_port_range
        if destination_port_ranges is not None:
            self._values["destination_port_ranges"] = destination_port_ranges
        if source_address_prefix is not None:
            self._values["source_address_prefix"] = source_address_prefix
        if source_address_prefixes is not None:
            self._values["source_address_prefixes"] = source_address_prefixes
        if source_application_security_groups is not None:
            self._values["source_application_security_groups"] = source_application_security_groups
        if source_port_range is not None:
            self._values["source_port_range"] = source_port_range
        if source_port_ranges is not None:
            self._values["source_port_ranges"] = source_port_ranges

    @builtins.property
    def access(self) -> builtins.str:
        '''The network traffic is allowed or denied Must be "Allow" or "Deny".'''
        result = self._values.get("access")
        assert result is not None, "Required property 'access' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def direction(self) -> builtins.str:
        '''The direction of the rule Must be "Inbound" or "Outbound".'''
        result = self._values.get("direction")
        assert result is not None, "Required property 'direction' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def priority(self) -> jsii.Number:
        '''The priority of the rule Value must be between 100 and 4096 Lower values have higher priority.'''
        result = self._values.get("priority")
        assert result is not None, "Required property 'priority' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def protocol(self) -> builtins.str:
        '''Network protocol this rule applies to.

        Example::

            "Tcp", "Udp", "Icmp", "Esp", "Ah", "*"
        '''
        result = self._values.get("protocol")
        assert result is not None, "Required property 'protocol' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''A description for this rule Restricted to 140 characters.'''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def destination_address_prefix(self) -> typing.Optional[builtins.str]:
        '''The destination address prefix.

        Example::

            "10.0.1.0/24", "VirtualNetwork", "*"
        '''
        result = self._values.get("destination_address_prefix")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def destination_address_prefixes(
        self,
    ) -> typing.Optional[typing.List[builtins.str]]:
        '''The destination address prefixes (for multiple destinations).

        Example::

            ["10.0.1.0/24", "10.0.2.0/24"]
        '''
        result = self._values.get("destination_address_prefixes")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def destination_application_security_groups(
        self,
    ) -> typing.Optional[typing.List[typing.Any]]:
        '''Destination application security groups.'''
        result = self._values.get("destination_application_security_groups")
        return typing.cast(typing.Optional[typing.List[typing.Any]], result)

    @builtins.property
    def destination_port_range(self) -> typing.Optional[builtins.str]:
        '''The destination port or range.

        Example::

            "443", "3389", "*"
        '''
        result = self._values.get("destination_port_range")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def destination_port_ranges(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The destination port ranges (for multiple ranges).

        Example::

            ["80", "443"]
        '''
        result = self._values.get("destination_port_ranges")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def source_address_prefix(self) -> typing.Optional[builtins.str]:
        '''The source address prefix.

        Example::

            "10.0.0.0/16", "VirtualNetwork", "Internet", "*"
        '''
        result = self._values.get("source_address_prefix")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def source_address_prefixes(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The source address prefixes (for multiple sources).

        Example::

            ["10.0.0.0/16", "10.1.0.0/16"]
        '''
        result = self._values.get("source_address_prefixes")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def source_application_security_groups(
        self,
    ) -> typing.Optional[typing.List[typing.Any]]:
        '''Source application security groups.'''
        result = self._values.get("source_application_security_groups")
        return typing.cast(typing.Optional[typing.List[typing.Any]], result)

    @builtins.property
    def source_port_range(self) -> typing.Optional[builtins.str]:
        '''The source port or range.

        Example::

            "80", "8000-8999", "*"
        '''
        result = self._values.get("source_port_range")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def source_port_ranges(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The source port ranges (for multiple ranges).

        Example::

            ["80", "443", "8080-8090"]
        '''
        result = self._values.get("source_port_ranges")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecurityRuleProperties(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.SmsReceiver",
    jsii_struct_bases=[],
    name_mapping={
        "country_code": "countryCode",
        "name": "name",
        "phone_number": "phoneNumber",
    },
)
class SmsReceiver:
    def __init__(
        self,
        *,
        country_code: builtins.str,
        name: builtins.str,
        phone_number: builtins.str,
    ) -> None:
        '''SMS receiver configuration.

        :param country_code: The country code (e.g., "1" for US).
        :param name: The name of the SMS receiver.
        :param phone_number: The phone number to send SMS to.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3f72d3c5e298cfb8d90a585110b05576250f5363f70271a9523b6b778ef11bdd)
            check_type(argname="argument country_code", value=country_code, expected_type=type_hints["country_code"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument phone_number", value=phone_number, expected_type=type_hints["phone_number"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "country_code": country_code,
            "name": name,
            "phone_number": phone_number,
        }

    @builtins.property
    def country_code(self) -> builtins.str:
        '''The country code (e.g., "1" for US).'''
        result = self._values.get("country_code")
        assert result is not None, "Required property 'country_code' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the SMS receiver.'''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def phone_number(self) -> builtins.str:
        '''The phone number to send SMS to.'''
        result = self._values.get("phone_number")
        assert result is not None, "Required property 'phone_number' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SmsReceiver(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.StaticThresholdCriteria",
    jsii_struct_bases=[],
    name_mapping={
        "metric_name": "metricName",
        "operator": "operator",
        "threshold": "threshold",
        "time_aggregation": "timeAggregation",
        "type": "type",
        "dimensions": "dimensions",
        "metric_namespace": "metricNamespace",
    },
)
class StaticThresholdCriteria:
    def __init__(
        self,
        *,
        metric_name: builtins.str,
        operator: builtins.str,
        threshold: jsii.Number,
        time_aggregation: builtins.str,
        type: builtins.str,
        dimensions: typing.Optional[typing.Sequence[typing.Union[_MetricDimension_8611b872, typing.Dict[builtins.str, typing.Any]]]] = None,
        metric_namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Static threshold criteria configuration.

        :param metric_name: The metric name.
        :param operator: The comparison operator.
        :param threshold: The threshold value.
        :param time_aggregation: The time aggregation method.
        :param type: The criteria type.
        :param dimensions: Metric dimensions for filtering (optional).
        :param metric_namespace: The metric namespace (optional).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__de75fdfc2f64711aa418cf1c1b2d776002bc24fc97d891d024f17835fd4c5109)
            check_type(argname="argument metric_name", value=metric_name, expected_type=type_hints["metric_name"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument time_aggregation", value=time_aggregation, expected_type=type_hints["time_aggregation"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument dimensions", value=dimensions, expected_type=type_hints["dimensions"])
            check_type(argname="argument metric_namespace", value=metric_namespace, expected_type=type_hints["metric_namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "metric_name": metric_name,
            "operator": operator,
            "threshold": threshold,
            "time_aggregation": time_aggregation,
            "type": type,
        }
        if dimensions is not None:
            self._values["dimensions"] = dimensions
        if metric_namespace is not None:
            self._values["metric_namespace"] = metric_namespace

    @builtins.property
    def metric_name(self) -> builtins.str:
        '''The metric name.'''
        result = self._values.get("metric_name")
        assert result is not None, "Required property 'metric_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''The comparison operator.'''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def threshold(self) -> jsii.Number:
        '''The threshold value.'''
        result = self._values.get("threshold")
        assert result is not None, "Required property 'threshold' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def time_aggregation(self) -> builtins.str:
        '''The time aggregation method.'''
        result = self._values.get("time_aggregation")
        assert result is not None, "Required property 'time_aggregation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def type(self) -> builtins.str:
        '''The criteria type.'''
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def dimensions(self) -> typing.Optional[typing.List[_MetricDimension_8611b872]]:
        '''Metric dimensions for filtering (optional).'''
        result = self._values.get("dimensions")
        return typing.cast(typing.Optional[typing.List[_MetricDimension_8611b872]], result)

    @builtins.property
    def metric_namespace(self) -> typing.Optional[builtins.str]:
        '''The metric namespace (optional).'''
        result = self._values.get("metric_namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "StaticThresholdCriteria(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class StorageAccount(
    _AzapiResource_7e7f5b39,
    metaclass=jsii.JSIIMeta,
    jsii_type="@microsoft/terraform-cdk-constructs.StorageAccount",
):
    '''Unified Azure Storage Account implementation.

    This class provides a single, version-aware implementation that replaces all
    version-specific Storage Account classes. It automatically handles version
    resolution, schema validation, and property transformation while maintaining
    full backward compatibility.

    Example::

        // Usage with explicit version pinning:
        const storageAccount = new StorageAccount(this, "storage", {
          name: "mystorageaccount",
          location: "eastus",
          resourceGroupId: resourceGroup.id,
          sku: { name: "Standard_LRS" },
          apiVersion: "2023-05-01",
        });
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        sku: typing.Union[_StorageAccountSku_fa953b33, typing.Dict[builtins.str, typing.Any]],
        access_tier: typing.Optional[builtins.str] = None,
        allow_blob_public_access: typing.Optional[builtins.bool] = None,
        enable_https_traffic_only: typing.Optional[builtins.bool] = None,
        encryption: typing.Optional[typing.Union[_StorageAccountEncryption_77d27837, typing.Dict[builtins.str, typing.Any]]] = None,
        identity: typing.Optional[typing.Union[_StorageAccountIdentity_d6b6a344, typing.Dict[builtins.str, typing.Any]]] = None,
        ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
        kind: typing.Optional[builtins.str] = None,
        minimum_tls_version: typing.Optional[builtins.str] = None,
        network_acls: typing.Optional[typing.Union[_StorageAccountNetworkAcls_768fda36, typing.Dict[builtins.str, typing.Any]]] = None,
        resource_group_id: typing.Optional[builtins.str] = None,
        api_version: typing.Optional[builtins.str] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        location: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> None:
        '''Creates a new Azure Storage Account using the VersionedAzapiResource framework.

        :param scope: - The scope in which to define this construct.
        :param id: - The unique identifier for this instance.
        :param sku: The SKU (pricing tier) for the Storage Account.
        :param access_tier: The access tier for blob storage. Default: "Hot"
        :param allow_blob_public_access: Whether to allow public access to blobs. Default: false
        :param enable_https_traffic_only: Whether to allow only HTTPS traffic. Default: true
        :param encryption: Encryption settings.
        :param identity: Managed identity configuration.
        :param ignore_changes: The lifecycle rules to ignore changes.
        :param kind: The kind of Storage Account. Default: "StorageV2"
        :param minimum_tls_version: The minimum TLS version required. Default: "TLS1_2"
        :param network_acls: Network ACL rules for the storage account.
        :param resource_group_id: Resource group ID where the storage account will be created.
        :param api_version: Explicit API version to use for this resource. If not specified, the latest active version will be automatically resolved. Use this for version pinning when stability is required over latest features. Default: Latest active version from ApiVersionManager
        :param enable_migration_analysis: Whether to enable migration analysis warnings. When true, the framework will analyze the current version for deprecation status and provide migration recommendations in the deployment output. Default: true
        :param enable_transformation: Whether to apply property transformations automatically. When true, properties will be automatically transformed according to the target schema's transformation rules. This enables backward compatibility. Default: true
        :param enable_validation: Whether to validate properties against the schema. When true, all properties will be validated against the API schema before resource creation. Validation errors will cause deployment failures. Default: true
        :param location: The location where the resource should be created. Default: Varies by resource type - see specific resource documentation
        :param monitoring: Monitoring configuration for this resource. Enables integrated monitoring with diagnostic settings, metric alerts, and activity log alerts. All monitoring is optional and disabled by default.
        :param name: The name of the resource.
        :param tags: Tags to apply to the resource.
        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b723ffd4e5207ba4fcafe0e1ca19c61dbe7d2cfea410be368c89585a651db31c)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = _StorageAccountProps_0b7b5bac(
            sku=sku,
            access_tier=access_tier,
            allow_blob_public_access=allow_blob_public_access,
            enable_https_traffic_only=enable_https_traffic_only,
            encryption=encryption,
            identity=identity,
            ignore_changes=ignore_changes,
            kind=kind,
            minimum_tls_version=minimum_tls_version,
            network_acls=network_acls,
            resource_group_id=resource_group_id,
            api_version=api_version,
            enable_migration_analysis=enable_migration_analysis,
            enable_transformation=enable_transformation,
            enable_validation=enable_validation,
            location=location,
            monitoring=monitoring,
            name=name,
            tags=tags,
            connection=connection,
            count=count,
            depends_on=depends_on,
            for_each=for_each,
            lifecycle=lifecycle,
            provider=provider,
            provisioners=provisioners,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="defaultMonitoring")
    @builtins.classmethod
    def default_monitoring(
        cls,
        action_group_id: builtins.str,
        workspace_id: typing.Optional[builtins.str] = None,
        *,
        availability_alert_severity: typing.Optional[jsii.Number] = None,
        availability_threshold: typing.Optional[jsii.Number] = None,
        egress_alert_severity: typing.Optional[jsii.Number] = None,
        egress_threshold: typing.Optional[jsii.Number] = None,
        enable_availability_alert: typing.Optional[builtins.bool] = None,
        enable_deletion_alert: typing.Optional[builtins.bool] = None,
        enable_egress_alert: typing.Optional[builtins.bool] = None,
        enable_transactions_alert: typing.Optional[builtins.bool] = None,
        transactions_alert_severity: typing.Optional[jsii.Number] = None,
        transactions_threshold: typing.Optional[jsii.Number] = None,
    ) -> _MonitoringConfig_7c28df74:
        '''Returns a production-ready monitoring configuration for Storage Accounts.

        This static factory method provides a complete MonitoringConfig with sensible defaults
        for storage account monitoring including availability, egress, transactions alerts, and deletion tracking.

        :param action_group_id: - The resource ID of the action group for alert notifications.
        :param workspace_id: - Optional Log Analytics workspace ID for diagnostic settings.
        :param availability_alert_severity: Severity level for availability alerts. Severity levels: - 0: Critical - 1: Error - 2: Warning - 3: Informational - 4: Verbose Default: 1 - Error severity for availability issues
        :param availability_threshold: Threshold for storage account availability percentage. Alert triggers when availability drops below this threshold Default: 99.9 - Triggers alert when availability is below 99.9%
        :param egress_alert_severity: Severity level for egress alerts. Severity levels: - 0: Critical - 1: Error - 2: Warning - 3: Informational - 4: Verbose Default: 2 - Warning severity for high egress
        :param egress_threshold: Threshold for storage account egress in bytes. Alert triggers when egress exceeds this threshold Default: 10737418240 - Triggers alert when egress exceeds 10GB
        :param enable_availability_alert: Enable or disable availability monitoring alert. Default: true - Availability alert is enabled by default
        :param enable_deletion_alert: Enable or disable deletion activity log alert. Default: true - Deletion alert is enabled by default
        :param enable_egress_alert: Enable or disable egress monitoring alert. Default: true - Egress alert is enabled by default
        :param enable_transactions_alert: Enable or disable transactions monitoring alert. Default: true - Transactions alert is enabled by default
        :param transactions_alert_severity: Severity level for transactions alerts. Severity levels: - 0: Critical - 1: Error - 2: Warning - 3: Informational - 4: Verbose Default: 2 - Warning severity for high transaction count
        :param transactions_threshold: Threshold for storage account transactions count. Alert triggers when transaction count exceeds this threshold Default: 100000 - Triggers alert when transactions exceed 100k

        :return: A complete MonitoringConfig object ready to use in StorageAccount props

        Example::

            // Custom thresholds
            const storageAccount = new StorageAccount(this, "storage", {
              // ... other properties ...
              monitoring: StorageAccount.defaultMonitoring(
                actionGroup.id,
                workspace.id,
                {
                  availabilityThreshold: 99.5,
                  egressThreshold: 21474836480, // 20GB
                  enableTransactionsAlert: false
                }
              )
            });
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dfe98404a0c2a4f096cc78d7bea2dff324cd4fb672f7954e0a5fa71bd80dd182)
            check_type(argname="argument action_group_id", value=action_group_id, expected_type=type_hints["action_group_id"])
            check_type(argname="argument workspace_id", value=workspace_id, expected_type=type_hints["workspace_id"])
        options = _StorageAccountMonitoringOptions_a7efe8e5(
            availability_alert_severity=availability_alert_severity,
            availability_threshold=availability_threshold,
            egress_alert_severity=egress_alert_severity,
            egress_threshold=egress_threshold,
            enable_availability_alert=enable_availability_alert,
            enable_deletion_alert=enable_deletion_alert,
            enable_egress_alert=enable_egress_alert,
            enable_transactions_alert=enable_transactions_alert,
            transactions_alert_severity=transactions_alert_severity,
            transactions_threshold=transactions_threshold,
        )

        return typing.cast(_MonitoringConfig_7c28df74, jsii.sinvoke(cls, "defaultMonitoring", [action_group_id, workspace_id, options]))

    @jsii.member(jsii_name="addTag")
    def add_tag(self, key: builtins.str, value: builtins.str) -> None:
        '''Add a tag to the Storage Account.

        :param key: -
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6d4e890b88be1047ae9d17f768064bd1e8113534b01c70eadffeedde9929441b)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "addTag", [key, value]))

    @jsii.member(jsii_name="apiSchema")
    def _api_schema(self) -> _ApiSchema_5ce0490e:
        '''Gets the API schema for the resolved version.'''
        return typing.cast(_ApiSchema_5ce0490e, jsii.invoke(self, "apiSchema", []))

    @jsii.member(jsii_name="createResourceBody")
    def _create_resource_body(self, props: typing.Any) -> typing.Any:
        '''Creates the resource body for the Azure API call.

        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ba54a1f3260d1a10e0e0845ba8ad70caf3468f8b4c2ef774f8198d9f228b1e11)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Any, jsii.invoke(self, "createResourceBody", [props]))

    @jsii.member(jsii_name="defaultVersion")
    def _default_version(self) -> builtins.str:
        '''Gets the default API version to use when no explicit version is specified.'''
        return typing.cast(builtins.str, jsii.invoke(self, "defaultVersion", []))

    @jsii.member(jsii_name="removeTag")
    def remove_tag(self, key: builtins.str) -> None:
        '''Remove a tag from the Storage Account.

        :param key: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__900410703cbb9d837c440ac28e508c62fba57a49e5ebfcc50111c14f14238d7b)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
        return typing.cast(None, jsii.invoke(self, "removeTag", [key]))

    @jsii.member(jsii_name="requiresLocation")
    def _requires_location(self) -> builtins.bool:
        '''Indicates that location is required for Storage Accounts.'''
        return typing.cast(builtins.bool, jsii.invoke(self, "requiresLocation", []))

    @jsii.member(jsii_name="resourceType")
    def _resource_type(self) -> builtins.str:
        '''Gets the Azure resource type for Storage Accounts.'''
        return typing.cast(builtins.str, jsii.invoke(self, "resourceType", []))

    @builtins.property
    @jsii.member(jsii_name="idOutput")
    def id_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "idOutput"))

    @builtins.property
    @jsii.member(jsii_name="locationOutput")
    def location_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "locationOutput"))

    @builtins.property
    @jsii.member(jsii_name="nameOutput")
    def name_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "nameOutput"))

    @builtins.property
    @jsii.member(jsii_name="primaryBlobEndpoint")
    def primary_blob_endpoint(self) -> builtins.str:
        '''Get the primary blob endpoint.'''
        return typing.cast(builtins.str, jsii.get(self, "primaryBlobEndpoint"))

    @builtins.property
    @jsii.member(jsii_name="primaryEndpointsOutput")
    def primary_endpoints_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "primaryEndpointsOutput"))

    @builtins.property
    @jsii.member(jsii_name="primaryFileEndpoint")
    def primary_file_endpoint(self) -> builtins.str:
        '''Get the primary file endpoint.'''
        return typing.cast(builtins.str, jsii.get(self, "primaryFileEndpoint"))

    @builtins.property
    @jsii.member(jsii_name="primaryQueueEndpoint")
    def primary_queue_endpoint(self) -> builtins.str:
        '''Get the primary queue endpoint.'''
        return typing.cast(builtins.str, jsii.get(self, "primaryQueueEndpoint"))

    @builtins.property
    @jsii.member(jsii_name="primaryTableEndpoint")
    def primary_table_endpoint(self) -> builtins.str:
        '''Get the primary table endpoint.'''
        return typing.cast(builtins.str, jsii.get(self, "primaryTableEndpoint"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def props(self) -> _StorageAccountProps_0b7b5bac:
        return typing.cast(_StorageAccountProps_0b7b5bac, jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="tagsOutput")
    def tags_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "tagsOutput"))


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.StorageAccountBody",
    jsii_struct_bases=[],
    name_mapping={
        "kind": "kind",
        "location": "location",
        "sku": "sku",
        "identity": "identity",
        "properties": "properties",
        "tags": "tags",
    },
)
class StorageAccountBody:
    def __init__(
        self,
        *,
        kind: builtins.str,
        location: builtins.str,
        sku: typing.Union[_StorageAccountSku_fa953b33, typing.Dict[builtins.str, typing.Any]],
        identity: typing.Optional[typing.Union[_StorageAccountIdentity_d6b6a344, typing.Dict[builtins.str, typing.Any]]] = None,
        properties: typing.Optional[typing.Union[_StorageAccountBodyProperties_4d550b33, typing.Dict[builtins.str, typing.Any]]] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''The resource body interface for Azure Storage Account API calls.

        :param kind: 
        :param location: 
        :param sku: 
        :param identity: 
        :param properties: 
        :param tags: 
        '''
        if isinstance(sku, dict):
            sku = _StorageAccountSku_fa953b33(**sku)
        if isinstance(identity, dict):
            identity = _StorageAccountIdentity_d6b6a344(**identity)
        if isinstance(properties, dict):
            properties = _StorageAccountBodyProperties_4d550b33(**properties)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b57d5b316754bbd430424592c26503e0ccd012f480d21900f4dad4d48b1398b2)
            check_type(argname="argument kind", value=kind, expected_type=type_hints["kind"])
            check_type(argname="argument location", value=location, expected_type=type_hints["location"])
            check_type(argname="argument sku", value=sku, expected_type=type_hints["sku"])
            check_type(argname="argument identity", value=identity, expected_type=type_hints["identity"])
            check_type(argname="argument properties", value=properties, expected_type=type_hints["properties"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "kind": kind,
            "location": location,
            "sku": sku,
        }
        if identity is not None:
            self._values["identity"] = identity
        if properties is not None:
            self._values["properties"] = properties
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def kind(self) -> builtins.str:
        result = self._values.get("kind")
        assert result is not None, "Required property 'kind' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def location(self) -> builtins.str:
        result = self._values.get("location")
        assert result is not None, "Required property 'location' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def sku(self) -> _StorageAccountSku_fa953b33:
        result = self._values.get("sku")
        assert result is not None, "Required property 'sku' is missing"
        return typing.cast(_StorageAccountSku_fa953b33, result)

    @builtins.property
    def identity(self) -> typing.Optional[_StorageAccountIdentity_d6b6a344]:
        result = self._values.get("identity")
        return typing.cast(typing.Optional[_StorageAccountIdentity_d6b6a344], result)

    @builtins.property
    def properties(self) -> typing.Optional[_StorageAccountBodyProperties_4d550b33]:
        result = self._values.get("properties")
        return typing.cast(typing.Optional[_StorageAccountBodyProperties_4d550b33], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "StorageAccountBody(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.StorageAccountBodyProperties",
    jsii_struct_bases=[],
    name_mapping={
        "access_tier": "accessTier",
        "allow_blob_public_access": "allowBlobPublicAccess",
        "encryption": "encryption",
        "minimum_tls_version": "minimumTlsVersion",
        "network_acls": "networkAcls",
        "supports_https_traffic_only": "supportsHttpsTrafficOnly",
    },
)
class StorageAccountBodyProperties:
    def __init__(
        self,
        *,
        access_tier: typing.Optional[builtins.str] = None,
        allow_blob_public_access: typing.Optional[builtins.bool] = None,
        encryption: typing.Optional[typing.Union[_StorageAccountEncryption_77d27837, typing.Dict[builtins.str, typing.Any]]] = None,
        minimum_tls_version: typing.Optional[builtins.str] = None,
        network_acls: typing.Optional[typing.Union[_StorageAccountNetworkAcls_768fda36, typing.Dict[builtins.str, typing.Any]]] = None,
        supports_https_traffic_only: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Storage Account properties for the request body.

        :param access_tier: 
        :param allow_blob_public_access: 
        :param encryption: 
        :param minimum_tls_version: 
        :param network_acls: 
        :param supports_https_traffic_only: 
        '''
        if isinstance(encryption, dict):
            encryption = _StorageAccountEncryption_77d27837(**encryption)
        if isinstance(network_acls, dict):
            network_acls = _StorageAccountNetworkAcls_768fda36(**network_acls)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__40f569c3e3a12c7436014caf94387a09bff2f9c6f171ccb9d8f510fc2f60ec1b)
            check_type(argname="argument access_tier", value=access_tier, expected_type=type_hints["access_tier"])
            check_type(argname="argument allow_blob_public_access", value=allow_blob_public_access, expected_type=type_hints["allow_blob_public_access"])
            check_type(argname="argument encryption", value=encryption, expected_type=type_hints["encryption"])
            check_type(argname="argument minimum_tls_version", value=minimum_tls_version, expected_type=type_hints["minimum_tls_version"])
            check_type(argname="argument network_acls", value=network_acls, expected_type=type_hints["network_acls"])
            check_type(argname="argument supports_https_traffic_only", value=supports_https_traffic_only, expected_type=type_hints["supports_https_traffic_only"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if access_tier is not None:
            self._values["access_tier"] = access_tier
        if allow_blob_public_access is not None:
            self._values["allow_blob_public_access"] = allow_blob_public_access
        if encryption is not None:
            self._values["encryption"] = encryption
        if minimum_tls_version is not None:
            self._values["minimum_tls_version"] = minimum_tls_version
        if network_acls is not None:
            self._values["network_acls"] = network_acls
        if supports_https_traffic_only is not None:
            self._values["supports_https_traffic_only"] = supports_https_traffic_only

    @builtins.property
    def access_tier(self) -> typing.Optional[builtins.str]:
        result = self._values.get("access_tier")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def allow_blob_public_access(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("allow_blob_public_access")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def encryption(self) -> typing.Optional[_StorageAccountEncryption_77d27837]:
        result = self._values.get("encryption")
        return typing.cast(typing.Optional[_StorageAccountEncryption_77d27837], result)

    @builtins.property
    def minimum_tls_version(self) -> typing.Optional[builtins.str]:
        result = self._values.get("minimum_tls_version")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def network_acls(self) -> typing.Optional[_StorageAccountNetworkAcls_768fda36]:
        result = self._values.get("network_acls")
        return typing.cast(typing.Optional[_StorageAccountNetworkAcls_768fda36], result)

    @builtins.property
    def supports_https_traffic_only(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("supports_https_traffic_only")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "StorageAccountBodyProperties(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.StorageAccountEncryption",
    jsii_struct_bases=[],
    name_mapping={"key_source": "keySource", "services": "services"},
)
class StorageAccountEncryption:
    def __init__(
        self,
        *,
        key_source: typing.Optional[builtins.str] = None,
        services: typing.Optional[typing.Union[_StorageAccountEncryptionServices_8a1bf271, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Encryption configuration for Storage Account.

        :param key_source: Key source (Microsoft.Storage or Microsoft.Keyvault).
        :param services: Encryption services (blob, file, table, queue).
        '''
        if isinstance(services, dict):
            services = _StorageAccountEncryptionServices_8a1bf271(**services)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8ed14d2e557eb2340e8a610a56556e2f85a87f10993561aa732e622fda9d4dce)
            check_type(argname="argument key_source", value=key_source, expected_type=type_hints["key_source"])
            check_type(argname="argument services", value=services, expected_type=type_hints["services"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key_source is not None:
            self._values["key_source"] = key_source
        if services is not None:
            self._values["services"] = services

    @builtins.property
    def key_source(self) -> typing.Optional[builtins.str]:
        '''Key source (Microsoft.Storage or Microsoft.Keyvault).'''
        result = self._values.get("key_source")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def services(self) -> typing.Optional[_StorageAccountEncryptionServices_8a1bf271]:
        '''Encryption services (blob, file, table, queue).'''
        result = self._values.get("services")
        return typing.cast(typing.Optional[_StorageAccountEncryptionServices_8a1bf271], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "StorageAccountEncryption(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.StorageAccountEncryptionService",
    jsii_struct_bases=[],
    name_mapping={"enabled": "enabled"},
)
class StorageAccountEncryptionService:
    def __init__(self, *, enabled: typing.Optional[builtins.bool] = None) -> None:
        '''Encryption service configuration.

        :param enabled: Whether encryption is enabled.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a6d0ec7498167d2e53cc6b520284093055f4a44fab1eb71da6132dfb50211bb6)
            check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if enabled is not None:
            self._values["enabled"] = enabled

    @builtins.property
    def enabled(self) -> typing.Optional[builtins.bool]:
        '''Whether encryption is enabled.'''
        result = self._values.get("enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "StorageAccountEncryptionService(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.StorageAccountEncryptionServices",
    jsii_struct_bases=[],
    name_mapping={"blob": "blob", "file": "file", "queue": "queue", "table": "table"},
)
class StorageAccountEncryptionServices:
    def __init__(
        self,
        *,
        blob: typing.Optional[typing.Union[_StorageAccountEncryptionService_aaadb7be, typing.Dict[builtins.str, typing.Any]]] = None,
        file: typing.Optional[typing.Union[_StorageAccountEncryptionService_aaadb7be, typing.Dict[builtins.str, typing.Any]]] = None,
        queue: typing.Optional[typing.Union[_StorageAccountEncryptionService_aaadb7be, typing.Dict[builtins.str, typing.Any]]] = None,
        table: typing.Optional[typing.Union[_StorageAccountEncryptionService_aaadb7be, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Encryption services configuration.

        :param blob: Blob service encryption.
        :param file: File service encryption.
        :param queue: Queue service encryption.
        :param table: Table service encryption.
        '''
        if isinstance(blob, dict):
            blob = _StorageAccountEncryptionService_aaadb7be(**blob)
        if isinstance(file, dict):
            file = _StorageAccountEncryptionService_aaadb7be(**file)
        if isinstance(queue, dict):
            queue = _StorageAccountEncryptionService_aaadb7be(**queue)
        if isinstance(table, dict):
            table = _StorageAccountEncryptionService_aaadb7be(**table)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b7563a9805c7ad8fed6c30d58d9736388e5ad53e0f156ba7c14a77e9561b0a38)
            check_type(argname="argument blob", value=blob, expected_type=type_hints["blob"])
            check_type(argname="argument file", value=file, expected_type=type_hints["file"])
            check_type(argname="argument queue", value=queue, expected_type=type_hints["queue"])
            check_type(argname="argument table", value=table, expected_type=type_hints["table"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if blob is not None:
            self._values["blob"] = blob
        if file is not None:
            self._values["file"] = file
        if queue is not None:
            self._values["queue"] = queue
        if table is not None:
            self._values["table"] = table

    @builtins.property
    def blob(self) -> typing.Optional[_StorageAccountEncryptionService_aaadb7be]:
        '''Blob service encryption.'''
        result = self._values.get("blob")
        return typing.cast(typing.Optional[_StorageAccountEncryptionService_aaadb7be], result)

    @builtins.property
    def file(self) -> typing.Optional[_StorageAccountEncryptionService_aaadb7be]:
        '''File service encryption.'''
        result = self._values.get("file")
        return typing.cast(typing.Optional[_StorageAccountEncryptionService_aaadb7be], result)

    @builtins.property
    def queue(self) -> typing.Optional[_StorageAccountEncryptionService_aaadb7be]:
        '''Queue service encryption.'''
        result = self._values.get("queue")
        return typing.cast(typing.Optional[_StorageAccountEncryptionService_aaadb7be], result)

    @builtins.property
    def table(self) -> typing.Optional[_StorageAccountEncryptionService_aaadb7be]:
        '''Table service encryption.'''
        result = self._values.get("table")
        return typing.cast(typing.Optional[_StorageAccountEncryptionService_aaadb7be], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "StorageAccountEncryptionServices(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.StorageAccountIdentity",
    jsii_struct_bases=[],
    name_mapping={
        "type": "type",
        "user_assigned_identities": "userAssignedIdentities",
    },
)
class StorageAccountIdentity:
    def __init__(
        self,
        *,
        type: builtins.str,
        user_assigned_identities: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    ) -> None:
        '''Identity configuration for Storage Account.

        :param type: The type of identity (SystemAssigned, UserAssigned, SystemAssigned,UserAssigned).
        :param user_assigned_identities: User assigned identity IDs.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__502fa19b120d6e7109eec152cd494ff2ee5ddbe633cca88345174662345345f4)
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument user_assigned_identities", value=user_assigned_identities, expected_type=type_hints["user_assigned_identities"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "type": type,
        }
        if user_assigned_identities is not None:
            self._values["user_assigned_identities"] = user_assigned_identities

    @builtins.property
    def type(self) -> builtins.str:
        '''The type of identity (SystemAssigned, UserAssigned, SystemAssigned,UserAssigned).'''
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def user_assigned_identities(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''User assigned identity IDs.'''
        result = self._values.get("user_assigned_identities")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "StorageAccountIdentity(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.StorageAccountIpRule",
    jsii_struct_bases=[],
    name_mapping={"value": "value"},
)
class StorageAccountIpRule:
    def __init__(self, *, value: builtins.str) -> None:
        '''IP rule for network ACLs.

        :param value: IP address or CIDR range.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4b79a21076dc9f14021e21bf25e1dc488ee8035373bd2369979335116b3cfabb)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "value": value,
        }

    @builtins.property
    def value(self) -> builtins.str:
        '''IP address or CIDR range.'''
        result = self._values.get("value")
        assert result is not None, "Required property 'value' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "StorageAccountIpRule(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.StorageAccountMonitoringOptions",
    jsii_struct_bases=[],
    name_mapping={
        "availability_alert_severity": "availabilityAlertSeverity",
        "availability_threshold": "availabilityThreshold",
        "egress_alert_severity": "egressAlertSeverity",
        "egress_threshold": "egressThreshold",
        "enable_availability_alert": "enableAvailabilityAlert",
        "enable_deletion_alert": "enableDeletionAlert",
        "enable_egress_alert": "enableEgressAlert",
        "enable_transactions_alert": "enableTransactionsAlert",
        "transactions_alert_severity": "transactionsAlertSeverity",
        "transactions_threshold": "transactionsThreshold",
    },
)
class StorageAccountMonitoringOptions:
    def __init__(
        self,
        *,
        availability_alert_severity: typing.Optional[jsii.Number] = None,
        availability_threshold: typing.Optional[jsii.Number] = None,
        egress_alert_severity: typing.Optional[jsii.Number] = None,
        egress_threshold: typing.Optional[jsii.Number] = None,
        enable_availability_alert: typing.Optional[builtins.bool] = None,
        enable_deletion_alert: typing.Optional[builtins.bool] = None,
        enable_egress_alert: typing.Optional[builtins.bool] = None,
        enable_transactions_alert: typing.Optional[builtins.bool] = None,
        transactions_alert_severity: typing.Optional[jsii.Number] = None,
        transactions_threshold: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Configuration options for Storage Account monitoring.

        This interface defines the configurable options for setting up monitoring alerts
        and diagnostic settings for Azure Storage Accounts. All properties are optional
        and have sensible defaults for production use.

        :param availability_alert_severity: Severity level for availability alerts. Severity levels: - 0: Critical - 1: Error - 2: Warning - 3: Informational - 4: Verbose Default: 1 - Error severity for availability issues
        :param availability_threshold: Threshold for storage account availability percentage. Alert triggers when availability drops below this threshold Default: 99.9 - Triggers alert when availability is below 99.9%
        :param egress_alert_severity: Severity level for egress alerts. Severity levels: - 0: Critical - 1: Error - 2: Warning - 3: Informational - 4: Verbose Default: 2 - Warning severity for high egress
        :param egress_threshold: Threshold for storage account egress in bytes. Alert triggers when egress exceeds this threshold Default: 10737418240 - Triggers alert when egress exceeds 10GB
        :param enable_availability_alert: Enable or disable availability monitoring alert. Default: true - Availability alert is enabled by default
        :param enable_deletion_alert: Enable or disable deletion activity log alert. Default: true - Deletion alert is enabled by default
        :param enable_egress_alert: Enable or disable egress monitoring alert. Default: true - Egress alert is enabled by default
        :param enable_transactions_alert: Enable or disable transactions monitoring alert. Default: true - Transactions alert is enabled by default
        :param transactions_alert_severity: Severity level for transactions alerts. Severity levels: - 0: Critical - 1: Error - 2: Warning - 3: Informational - 4: Verbose Default: 2 - Warning severity for high transaction count
        :param transactions_threshold: Threshold for storage account transactions count. Alert triggers when transaction count exceeds this threshold Default: 100000 - Triggers alert when transactions exceed 100k
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__af21ea8d212053d955f2593f7cfb6cd52f76c26564e2b215737b02cf6b5b4dfc)
            check_type(argname="argument availability_alert_severity", value=availability_alert_severity, expected_type=type_hints["availability_alert_severity"])
            check_type(argname="argument availability_threshold", value=availability_threshold, expected_type=type_hints["availability_threshold"])
            check_type(argname="argument egress_alert_severity", value=egress_alert_severity, expected_type=type_hints["egress_alert_severity"])
            check_type(argname="argument egress_threshold", value=egress_threshold, expected_type=type_hints["egress_threshold"])
            check_type(argname="argument enable_availability_alert", value=enable_availability_alert, expected_type=type_hints["enable_availability_alert"])
            check_type(argname="argument enable_deletion_alert", value=enable_deletion_alert, expected_type=type_hints["enable_deletion_alert"])
            check_type(argname="argument enable_egress_alert", value=enable_egress_alert, expected_type=type_hints["enable_egress_alert"])
            check_type(argname="argument enable_transactions_alert", value=enable_transactions_alert, expected_type=type_hints["enable_transactions_alert"])
            check_type(argname="argument transactions_alert_severity", value=transactions_alert_severity, expected_type=type_hints["transactions_alert_severity"])
            check_type(argname="argument transactions_threshold", value=transactions_threshold, expected_type=type_hints["transactions_threshold"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if availability_alert_severity is not None:
            self._values["availability_alert_severity"] = availability_alert_severity
        if availability_threshold is not None:
            self._values["availability_threshold"] = availability_threshold
        if egress_alert_severity is not None:
            self._values["egress_alert_severity"] = egress_alert_severity
        if egress_threshold is not None:
            self._values["egress_threshold"] = egress_threshold
        if enable_availability_alert is not None:
            self._values["enable_availability_alert"] = enable_availability_alert
        if enable_deletion_alert is not None:
            self._values["enable_deletion_alert"] = enable_deletion_alert
        if enable_egress_alert is not None:
            self._values["enable_egress_alert"] = enable_egress_alert
        if enable_transactions_alert is not None:
            self._values["enable_transactions_alert"] = enable_transactions_alert
        if transactions_alert_severity is not None:
            self._values["transactions_alert_severity"] = transactions_alert_severity
        if transactions_threshold is not None:
            self._values["transactions_threshold"] = transactions_threshold

    @builtins.property
    def availability_alert_severity(self) -> typing.Optional[jsii.Number]:
        '''Severity level for availability alerts.

        Severity levels:

        - 0: Critical
        - 1: Error
        - 2: Warning
        - 3: Informational
        - 4: Verbose

        :default: 1 - Error severity for availability issues
        '''
        result = self._values.get("availability_alert_severity")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def availability_threshold(self) -> typing.Optional[jsii.Number]:
        '''Threshold for storage account availability percentage.

        Alert triggers when availability drops below this threshold

        :default: 99.9 - Triggers alert when availability is below 99.9%
        '''
        result = self._values.get("availability_threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def egress_alert_severity(self) -> typing.Optional[jsii.Number]:
        '''Severity level for egress alerts.

        Severity levels:

        - 0: Critical
        - 1: Error
        - 2: Warning
        - 3: Informational
        - 4: Verbose

        :default: 2 - Warning severity for high egress
        '''
        result = self._values.get("egress_alert_severity")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def egress_threshold(self) -> typing.Optional[jsii.Number]:
        '''Threshold for storage account egress in bytes.

        Alert triggers when egress exceeds this threshold

        :default: 10737418240 - Triggers alert when egress exceeds 10GB
        '''
        result = self._values.get("egress_threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def enable_availability_alert(self) -> typing.Optional[builtins.bool]:
        '''Enable or disable availability monitoring alert.

        :default: true - Availability alert is enabled by default
        '''
        result = self._values.get("enable_availability_alert")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_deletion_alert(self) -> typing.Optional[builtins.bool]:
        '''Enable or disable deletion activity log alert.

        :default: true - Deletion alert is enabled by default
        '''
        result = self._values.get("enable_deletion_alert")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_egress_alert(self) -> typing.Optional[builtins.bool]:
        '''Enable or disable egress monitoring alert.

        :default: true - Egress alert is enabled by default
        '''
        result = self._values.get("enable_egress_alert")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_transactions_alert(self) -> typing.Optional[builtins.bool]:
        '''Enable or disable transactions monitoring alert.

        :default: true - Transactions alert is enabled by default
        '''
        result = self._values.get("enable_transactions_alert")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def transactions_alert_severity(self) -> typing.Optional[jsii.Number]:
        '''Severity level for transactions alerts.

        Severity levels:

        - 0: Critical
        - 1: Error
        - 2: Warning
        - 3: Informational
        - 4: Verbose

        :default: 2 - Warning severity for high transaction count
        '''
        result = self._values.get("transactions_alert_severity")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def transactions_threshold(self) -> typing.Optional[jsii.Number]:
        '''Threshold for storage account transactions count.

        Alert triggers when transaction count exceeds this threshold

        :default: 100000 - Triggers alert when transactions exceed 100k
        '''
        result = self._values.get("transactions_threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "StorageAccountMonitoringOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.StorageAccountNetworkAcls",
    jsii_struct_bases=[],
    name_mapping={
        "bypass": "bypass",
        "default_action": "defaultAction",
        "ip_rules": "ipRules",
        "virtual_network_rules": "virtualNetworkRules",
    },
)
class StorageAccountNetworkAcls:
    def __init__(
        self,
        *,
        bypass: typing.Optional[builtins.str] = None,
        default_action: typing.Optional[builtins.str] = None,
        ip_rules: typing.Optional[typing.Sequence[typing.Union[_StorageAccountIpRule_83a6da4e, typing.Dict[builtins.str, typing.Any]]]] = None,
        virtual_network_rules: typing.Optional[typing.Sequence[typing.Union[_StorageAccountVirtualNetworkRule_825a3860, typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Network ACL configuration for Storage Account.

        :param bypass: Whether to bypass network rules for Azure services.
        :param default_action: Default action when no rule matches (Allow or Deny).
        :param ip_rules: IP rules for the storage account.
        :param virtual_network_rules: Virtual network rules for the storage account.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1f28dba6ea2cd128a19e73772f7563bbbde15eba3f292a0b0bf9b031557ae004)
            check_type(argname="argument bypass", value=bypass, expected_type=type_hints["bypass"])
            check_type(argname="argument default_action", value=default_action, expected_type=type_hints["default_action"])
            check_type(argname="argument ip_rules", value=ip_rules, expected_type=type_hints["ip_rules"])
            check_type(argname="argument virtual_network_rules", value=virtual_network_rules, expected_type=type_hints["virtual_network_rules"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if bypass is not None:
            self._values["bypass"] = bypass
        if default_action is not None:
            self._values["default_action"] = default_action
        if ip_rules is not None:
            self._values["ip_rules"] = ip_rules
        if virtual_network_rules is not None:
            self._values["virtual_network_rules"] = virtual_network_rules

    @builtins.property
    def bypass(self) -> typing.Optional[builtins.str]:
        '''Whether to bypass network rules for Azure services.'''
        result = self._values.get("bypass")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def default_action(self) -> typing.Optional[builtins.str]:
        '''Default action when no rule matches (Allow or Deny).'''
        result = self._values.get("default_action")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ip_rules(self) -> typing.Optional[typing.List[_StorageAccountIpRule_83a6da4e]]:
        '''IP rules for the storage account.'''
        result = self._values.get("ip_rules")
        return typing.cast(typing.Optional[typing.List[_StorageAccountIpRule_83a6da4e]], result)

    @builtins.property
    def virtual_network_rules(
        self,
    ) -> typing.Optional[typing.List[_StorageAccountVirtualNetworkRule_825a3860]]:
        '''Virtual network rules for the storage account.'''
        result = self._values.get("virtual_network_rules")
        return typing.cast(typing.Optional[typing.List[_StorageAccountVirtualNetworkRule_825a3860]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "StorageAccountNetworkAcls(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.StorageAccountProps",
    jsii_struct_bases=[_AzapiResourceProps_141a2340],
    name_mapping={
        "connection": "connection",
        "count": "count",
        "depends_on": "dependsOn",
        "for_each": "forEach",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "provisioners": "provisioners",
        "api_version": "apiVersion",
        "enable_migration_analysis": "enableMigrationAnalysis",
        "enable_transformation": "enableTransformation",
        "enable_validation": "enableValidation",
        "location": "location",
        "monitoring": "monitoring",
        "name": "name",
        "tags": "tags",
        "sku": "sku",
        "access_tier": "accessTier",
        "allow_blob_public_access": "allowBlobPublicAccess",
        "enable_https_traffic_only": "enableHttpsTrafficOnly",
        "encryption": "encryption",
        "identity": "identity",
        "ignore_changes": "ignoreChanges",
        "kind": "kind",
        "minimum_tls_version": "minimumTlsVersion",
        "network_acls": "networkAcls",
        "resource_group_id": "resourceGroupId",
    },
)
class StorageAccountProps(_AzapiResourceProps_141a2340):
    def __init__(
        self,
        *,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
        api_version: typing.Optional[builtins.str] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        location: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        sku: typing.Union[_StorageAccountSku_fa953b33, typing.Dict[builtins.str, typing.Any]],
        access_tier: typing.Optional[builtins.str] = None,
        allow_blob_public_access: typing.Optional[builtins.bool] = None,
        enable_https_traffic_only: typing.Optional[builtins.bool] = None,
        encryption: typing.Optional[typing.Union[_StorageAccountEncryption_77d27837, typing.Dict[builtins.str, typing.Any]]] = None,
        identity: typing.Optional[typing.Union[_StorageAccountIdentity_d6b6a344, typing.Dict[builtins.str, typing.Any]]] = None,
        ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
        kind: typing.Optional[builtins.str] = None,
        minimum_tls_version: typing.Optional[builtins.str] = None,
        network_acls: typing.Optional[typing.Union[_StorageAccountNetworkAcls_768fda36, typing.Dict[builtins.str, typing.Any]]] = None,
        resource_group_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for the unified Azure Storage Account.

        Extends VersionedAzapiResourceProps with Storage Account specific properties

        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        :param api_version: Explicit API version to use for this resource. If not specified, the latest active version will be automatically resolved. Use this for version pinning when stability is required over latest features. Default: Latest active version from ApiVersionManager
        :param enable_migration_analysis: Whether to enable migration analysis warnings. When true, the framework will analyze the current version for deprecation status and provide migration recommendations in the deployment output. Default: true
        :param enable_transformation: Whether to apply property transformations automatically. When true, properties will be automatically transformed according to the target schema's transformation rules. This enables backward compatibility. Default: true
        :param enable_validation: Whether to validate properties against the schema. When true, all properties will be validated against the API schema before resource creation. Validation errors will cause deployment failures. Default: true
        :param location: The location where the resource should be created. Default: Varies by resource type - see specific resource documentation
        :param monitoring: Monitoring configuration for this resource. Enables integrated monitoring with diagnostic settings, metric alerts, and activity log alerts. All monitoring is optional and disabled by default.
        :param name: The name of the resource.
        :param tags: Tags to apply to the resource.
        :param sku: The SKU (pricing tier) for the Storage Account.
        :param access_tier: The access tier for blob storage. Default: "Hot"
        :param allow_blob_public_access: Whether to allow public access to blobs. Default: false
        :param enable_https_traffic_only: Whether to allow only HTTPS traffic. Default: true
        :param encryption: Encryption settings.
        :param identity: Managed identity configuration.
        :param ignore_changes: The lifecycle rules to ignore changes.
        :param kind: The kind of Storage Account. Default: "StorageV2"
        :param minimum_tls_version: The minimum TLS version required. Default: "TLS1_2"
        :param network_acls: Network ACL rules for the storage account.
        :param resource_group_id: Resource group ID where the storage account will be created.
        '''
        if isinstance(lifecycle, dict):
            lifecycle = _cdktf_9a9027ec.TerraformResourceLifecycle(**lifecycle)
        if isinstance(monitoring, dict):
            monitoring = _MonitoringConfig_7c28df74(**monitoring)
        if isinstance(sku, dict):
            sku = _StorageAccountSku_fa953b33(**sku)
        if isinstance(encryption, dict):
            encryption = _StorageAccountEncryption_77d27837(**encryption)
        if isinstance(identity, dict):
            identity = _StorageAccountIdentity_d6b6a344(**identity)
        if isinstance(network_acls, dict):
            network_acls = _StorageAccountNetworkAcls_768fda36(**network_acls)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__50747e225fb92dcb75801bf29a578ecfd07d5458a3f1b792b469a0235e8c5a49)
            check_type(argname="argument connection", value=connection, expected_type=type_hints["connection"])
            check_type(argname="argument count", value=count, expected_type=type_hints["count"])
            check_type(argname="argument depends_on", value=depends_on, expected_type=type_hints["depends_on"])
            check_type(argname="argument for_each", value=for_each, expected_type=type_hints["for_each"])
            check_type(argname="argument lifecycle", value=lifecycle, expected_type=type_hints["lifecycle"])
            check_type(argname="argument provider", value=provider, expected_type=type_hints["provider"])
            check_type(argname="argument provisioners", value=provisioners, expected_type=type_hints["provisioners"])
            check_type(argname="argument api_version", value=api_version, expected_type=type_hints["api_version"])
            check_type(argname="argument enable_migration_analysis", value=enable_migration_analysis, expected_type=type_hints["enable_migration_analysis"])
            check_type(argname="argument enable_transformation", value=enable_transformation, expected_type=type_hints["enable_transformation"])
            check_type(argname="argument enable_validation", value=enable_validation, expected_type=type_hints["enable_validation"])
            check_type(argname="argument location", value=location, expected_type=type_hints["location"])
            check_type(argname="argument monitoring", value=monitoring, expected_type=type_hints["monitoring"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument sku", value=sku, expected_type=type_hints["sku"])
            check_type(argname="argument access_tier", value=access_tier, expected_type=type_hints["access_tier"])
            check_type(argname="argument allow_blob_public_access", value=allow_blob_public_access, expected_type=type_hints["allow_blob_public_access"])
            check_type(argname="argument enable_https_traffic_only", value=enable_https_traffic_only, expected_type=type_hints["enable_https_traffic_only"])
            check_type(argname="argument encryption", value=encryption, expected_type=type_hints["encryption"])
            check_type(argname="argument identity", value=identity, expected_type=type_hints["identity"])
            check_type(argname="argument ignore_changes", value=ignore_changes, expected_type=type_hints["ignore_changes"])
            check_type(argname="argument kind", value=kind, expected_type=type_hints["kind"])
            check_type(argname="argument minimum_tls_version", value=minimum_tls_version, expected_type=type_hints["minimum_tls_version"])
            check_type(argname="argument network_acls", value=network_acls, expected_type=type_hints["network_acls"])
            check_type(argname="argument resource_group_id", value=resource_group_id, expected_type=type_hints["resource_group_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "sku": sku,
        }
        if connection is not None:
            self._values["connection"] = connection
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if for_each is not None:
            self._values["for_each"] = for_each
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider
        if provisioners is not None:
            self._values["provisioners"] = provisioners
        if api_version is not None:
            self._values["api_version"] = api_version
        if enable_migration_analysis is not None:
            self._values["enable_migration_analysis"] = enable_migration_analysis
        if enable_transformation is not None:
            self._values["enable_transformation"] = enable_transformation
        if enable_validation is not None:
            self._values["enable_validation"] = enable_validation
        if location is not None:
            self._values["location"] = location
        if monitoring is not None:
            self._values["monitoring"] = monitoring
        if name is not None:
            self._values["name"] = name
        if tags is not None:
            self._values["tags"] = tags
        if access_tier is not None:
            self._values["access_tier"] = access_tier
        if allow_blob_public_access is not None:
            self._values["allow_blob_public_access"] = allow_blob_public_access
        if enable_https_traffic_only is not None:
            self._values["enable_https_traffic_only"] = enable_https_traffic_only
        if encryption is not None:
            self._values["encryption"] = encryption
        if identity is not None:
            self._values["identity"] = identity
        if ignore_changes is not None:
            self._values["ignore_changes"] = ignore_changes
        if kind is not None:
            self._values["kind"] = kind
        if minimum_tls_version is not None:
            self._values["minimum_tls_version"] = minimum_tls_version
        if network_acls is not None:
            self._values["network_acls"] = network_acls
        if resource_group_id is not None:
            self._values["resource_group_id"] = resource_group_id

    @builtins.property
    def connection(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("connection")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]], result)

    @builtins.property
    def count(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]], result)

    @builtins.property
    def depends_on(
        self,
    ) -> typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]], result)

    @builtins.property
    def for_each(self) -> typing.Optional[_cdktf_9a9027ec.ITerraformIterator]:
        '''
        :stability: experimental
        '''
        result = self._values.get("for_each")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.ITerraformIterator], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[_cdktf_9a9027ec.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformProvider], result)

    @builtins.property
    def provisioners(
        self,
    ) -> typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provisioners")
        return typing.cast(typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]], result)

    @builtins.property
    def api_version(self) -> typing.Optional[builtins.str]:
        '''Explicit API version to use for this resource.

        If not specified, the latest active version will be automatically resolved.
        Use this for version pinning when stability is required over latest features.

        :default: Latest active version from ApiVersionManager

        Example::

            "2024-11-01"
        '''
        result = self._values.get("api_version")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def enable_migration_analysis(self) -> typing.Optional[builtins.bool]:
        '''Whether to enable migration analysis warnings.

        When true, the framework will analyze the current version for deprecation
        status and provide migration recommendations in the deployment output.

        :default: true
        '''
        result = self._values.get("enable_migration_analysis")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_transformation(self) -> typing.Optional[builtins.bool]:
        '''Whether to apply property transformations automatically.

        When true, properties will be automatically transformed according to the
        target schema's transformation rules. This enables backward compatibility.

        :default: true
        '''
        result = self._values.get("enable_transformation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_validation(self) -> typing.Optional[builtins.bool]:
        '''Whether to validate properties against the schema.

        When true, all properties will be validated against the API schema before
        resource creation. Validation errors will cause deployment failures.

        :default: true
        '''
        result = self._values.get("enable_validation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def location(self) -> typing.Optional[builtins.str]:
        '''The location where the resource should be created.

        :default: Varies by resource type - see specific resource documentation

        :remarks:

        Location handling varies by resource type:

        - **Top-level resources**: Most require an explicit location (e.g., "eastus", "westus")
        - **Global resources**: Some use "global" as location (e.g., Private DNS Zones)
        - **Child resources**: Inherit location from parent and should NOT set this property

        Each resource type may provide its own default through the ``resolveLocation()`` method.
        If no location is specified and no default exists, resource creation may fail.

        Example::

            // Child resource (Subnet) - do not set location
            // location: undefined (inherited from parent Virtual Network)
        '''
        result = self._values.get("location")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def monitoring(self) -> typing.Optional[_MonitoringConfig_7c28df74]:
        '''Monitoring configuration for this resource.

        Enables integrated monitoring with diagnostic settings, metric alerts,
        and activity log alerts. All monitoring is optional and disabled by default.

        Example::

            monitoring: {
              enabled: true,
              diagnosticSettings: {
                workspaceId: logAnalytics.id,
                metrics: ['AllMetrics'],
                logs: ['AuditLogs']
              },
              metricAlerts: [{
                name: 'high-cpu-alert',
                severity: 2,
                scopes: [], // Automatically set to this resource
                criteria: { ... },
                actions: [{ actionGroupId: actionGroup.id }]
              }]
            }
        '''
        result = self._values.get("monitoring")
        return typing.cast(typing.Optional[_MonitoringConfig_7c28df74], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the resource.'''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Tags to apply to the resource.'''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def sku(self) -> _StorageAccountSku_fa953b33:
        '''The SKU (pricing tier) for the Storage Account.

        Example::

            { name: "Standard_LRS" }
        '''
        result = self._values.get("sku")
        assert result is not None, "Required property 'sku' is missing"
        return typing.cast(_StorageAccountSku_fa953b33, result)

    @builtins.property
    def access_tier(self) -> typing.Optional[builtins.str]:
        '''The access tier for blob storage.

        :default: "Hot"

        Example::

            "Hot", "Cool"
        '''
        result = self._values.get("access_tier")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def allow_blob_public_access(self) -> typing.Optional[builtins.bool]:
        '''Whether to allow public access to blobs.

        :default: false
        '''
        result = self._values.get("allow_blob_public_access")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_https_traffic_only(self) -> typing.Optional[builtins.bool]:
        '''Whether to allow only HTTPS traffic.

        :default: true
        '''
        result = self._values.get("enable_https_traffic_only")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def encryption(self) -> typing.Optional[_StorageAccountEncryption_77d27837]:
        '''Encryption settings.'''
        result = self._values.get("encryption")
        return typing.cast(typing.Optional[_StorageAccountEncryption_77d27837], result)

    @builtins.property
    def identity(self) -> typing.Optional[_StorageAccountIdentity_d6b6a344]:
        '''Managed identity configuration.'''
        result = self._values.get("identity")
        return typing.cast(typing.Optional[_StorageAccountIdentity_d6b6a344], result)

    @builtins.property
    def ignore_changes(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The lifecycle rules to ignore changes.

        Example::

            ["tags"]
        '''
        result = self._values.get("ignore_changes")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def kind(self) -> typing.Optional[builtins.str]:
        '''The kind of Storage Account.

        :default: "StorageV2"

        Example::

            "StorageV2", "BlobStorage", "BlockBlobStorage", "FileStorage"
        '''
        result = self._values.get("kind")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def minimum_tls_version(self) -> typing.Optional[builtins.str]:
        '''The minimum TLS version required.

        :default: "TLS1_2"
        '''
        result = self._values.get("minimum_tls_version")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def network_acls(self) -> typing.Optional[_StorageAccountNetworkAcls_768fda36]:
        '''Network ACL rules for the storage account.'''
        result = self._values.get("network_acls")
        return typing.cast(typing.Optional[_StorageAccountNetworkAcls_768fda36], result)

    @builtins.property
    def resource_group_id(self) -> typing.Optional[builtins.str]:
        '''Resource group ID where the storage account will be created.'''
        result = self._values.get("resource_group_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "StorageAccountProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.StorageAccountSku",
    jsii_struct_bases=[],
    name_mapping={"name": "name"},
)
class StorageAccountSku:
    def __init__(self, *, name: builtins.str) -> None:
        '''SKU configuration for Storage Account.

        :param name: The SKU name (Standard_LRS, Standard_GRS, Standard_RAGRS, Standard_ZRS, Premium_LRS, Premium_ZRS).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f170c62cdf8fb6a8a124b20e1b48a309ba2dc3cbbdf6ddc5798be9e101de4ba1)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }

    @builtins.property
    def name(self) -> builtins.str:
        '''The SKU name (Standard_LRS, Standard_GRS, Standard_RAGRS, Standard_ZRS, Premium_LRS, Premium_ZRS).'''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "StorageAccountSku(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.StorageAccountVirtualNetworkRule",
    jsii_struct_bases=[],
    name_mapping={"id": "id"},
)
class StorageAccountVirtualNetworkRule:
    def __init__(self, *, id: builtins.str) -> None:
        '''Virtual network rule for network ACLs.

        :param id: Virtual network resource ID.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3073662893bd85c109decc801fdb5b5d9ef7d2f526570fb1f6dcf9bc82edbd9a)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "id": id,
        }

    @builtins.property
    def id(self) -> builtins.str:
        '''Virtual network resource ID.'''
        result = self._values.get("id")
        assert result is not None, "Required property 'id' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "StorageAccountVirtualNetworkRule(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class Subnet(
    _AzapiResource_7e7f5b39,
    metaclass=jsii.JSIIMeta,
    jsii_type="@microsoft/terraform-cdk-constructs.Subnet",
):
    '''Azure Subnet implementation.

    This class provides a single, version-aware implementation that replaces
    version-specific Subnet classes. It automatically handles version
    resolution, schema validation, and property transformation while maintaining
    full backward compatibility.

    **Child Resource Pattern**: Subnets are child resources of Virtual Networks.
    This implementation overrides the ``resolveParentId()`` method to properly
    construct the Virtual Network ID as the parent, following the enhanced base
    class pattern for child resources.

    Example::

        // Usage with network security group:
        const subnet = new Subnet(this, "subnet", {
          name: "my-subnet",
          virtualNetworkName: "my-vnet",
          resourceGroupId: resourceGroup.id,
          addressPrefix: "10.0.1.0/24",
          networkSecurityGroup: { id: nsg.id }
        });
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        address_prefix: builtins.str,
        resource_group_id: builtins.str,
        virtual_network_name: builtins.str,
        delegations: typing.Optional[typing.Sequence[typing.Union[_SubnetDelegation_c6136dfd, typing.Dict[builtins.str, typing.Any]]]] = None,
        ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
        ip_allocations: typing.Optional[typing.Sequence[typing.Any]] = None,
        nat_gateway: typing.Optional[typing.Union[_SubnetNATGatewayReference_cf82a70c, typing.Dict[builtins.str, typing.Any]]] = None,
        network_security_group: typing.Optional[typing.Union[_SubnetNSGReference_02d94a8f, typing.Dict[builtins.str, typing.Any]]] = None,
        private_endpoint_network_policies: typing.Optional[builtins.str] = None,
        private_link_service_network_policies: typing.Optional[builtins.str] = None,
        route_table: typing.Optional[typing.Union[_SubnetRouteTableReference_5c30e955, typing.Dict[builtins.str, typing.Any]]] = None,
        service_endpoints: typing.Optional[typing.Sequence[typing.Union[_SubnetServiceEndpoint_ada81b5d, typing.Dict[builtins.str, typing.Any]]]] = None,
        virtual_network_id: typing.Optional[builtins.str] = None,
        api_version: typing.Optional[builtins.str] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        location: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> None:
        '''Creates a new Azure Subnet using the AzapiResource framework.

        The constructor automatically handles version resolution, schema registration,
        validation, and resource creation. It maintains full backward compatibility
        with existing Subnet implementations.

        **Parent ID Resolution**: Subnets are child resources of Virtual Networks.
        The resolveParentId() method is overridden to return the Virtual Network ID
        instead of the Resource Group ID, establishing the proper parent-child hierarchy.

        :param scope: - The scope in which to define this construct.
        :param id: - The unique identifier for this instance.
        :param address_prefix: Address prefix for the subnet in CIDR notation Must be within the parent VNet's address space.
        :param resource_group_id: Resource group ID where the parent VNet exists Required for constructing the parent ID.
        :param virtual_network_name: Name of the parent virtual network Required for constructing the parent ID.
        :param delegations: Subnet delegations Delegates subnet to specific Azure services.
        :param ignore_changes: The lifecycle rules to ignore changes Useful for properties that are externally managed.
        :param ip_allocations: IP allocations for the subnet Optional - for custom IP allocation.
        :param nat_gateway: NAT gateway reference Optional - for outbound internet connectivity.
        :param network_security_group: Network security group reference Optional - can be attached later.
        :param private_endpoint_network_policies: Private endpoint network policies Controls whether network policies apply to private endpoints. Default: "Disabled"
        :param private_link_service_network_policies: Private link service network policies Controls whether network policies apply to private link services. Default: "Enabled"
        :param route_table: Route table reference Optional - can be attached later.
        :param service_endpoints: Service endpoints for the subnet Enables private access to Azure services.
        :param virtual_network_id: Optional: Full resource ID of the parent Virtual Network When provided, creates a proper Terraform dependency on the VNet If not provided, the parent ID will be constructed from resourceGroupId and virtualNetworkName.
        :param api_version: Explicit API version to use for this resource. If not specified, the latest active version will be automatically resolved. Use this for version pinning when stability is required over latest features. Default: Latest active version from ApiVersionManager
        :param enable_migration_analysis: Whether to enable migration analysis warnings. When true, the framework will analyze the current version for deprecation status and provide migration recommendations in the deployment output. Default: true
        :param enable_transformation: Whether to apply property transformations automatically. When true, properties will be automatically transformed according to the target schema's transformation rules. This enables backward compatibility. Default: true
        :param enable_validation: Whether to validate properties against the schema. When true, all properties will be validated against the API schema before resource creation. Validation errors will cause deployment failures. Default: true
        :param location: The location where the resource should be created. Default: Varies by resource type - see specific resource documentation
        :param monitoring: Monitoring configuration for this resource. Enables integrated monitoring with diagnostic settings, metric alerts, and activity log alerts. All monitoring is optional and disabled by default.
        :param name: The name of the resource.
        :param tags: Tags to apply to the resource.
        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3b023144ff1b17084bab6dd3d98a222c67d354dd086b8c85dd65b4638ab29ab7)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = _SubnetProps_b86f39ca(
            address_prefix=address_prefix,
            resource_group_id=resource_group_id,
            virtual_network_name=virtual_network_name,
            delegations=delegations,
            ignore_changes=ignore_changes,
            ip_allocations=ip_allocations,
            nat_gateway=nat_gateway,
            network_security_group=network_security_group,
            private_endpoint_network_policies=private_endpoint_network_policies,
            private_link_service_network_policies=private_link_service_network_policies,
            route_table=route_table,
            service_endpoints=service_endpoints,
            virtual_network_id=virtual_network_id,
            api_version=api_version,
            enable_migration_analysis=enable_migration_analysis,
            enable_transformation=enable_transformation,
            enable_validation=enable_validation,
            location=location,
            monitoring=monitoring,
            name=name,
            tags=tags,
            connection=connection,
            count=count,
            depends_on=depends_on,
            for_each=for_each,
            lifecycle=lifecycle,
            provider=provider,
            provisioners=provisioners,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="apiSchema")
    def _api_schema(self) -> _ApiSchema_5ce0490e:
        '''Gets the API schema for the resolved version Uses the framework's schema resolution to get the appropriate schema.'''
        return typing.cast(_ApiSchema_5ce0490e, jsii.invoke(self, "apiSchema", []))

    @jsii.member(jsii_name="createResourceBody")
    def _create_resource_body(self, props: typing.Any) -> typing.Any:
        '''Creates the resource body for the Azure API call Transforms the input properties into the JSON format expected by Azure REST API.

        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5112d9b24205b916ceefb4b41cc5316eab3c8e358f96d0d46a6172ab10d3cff6)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Any, jsii.invoke(self, "createResourceBody", [props]))

    @jsii.member(jsii_name="defaultVersion")
    def _default_version(self) -> builtins.str:
        '''Gets the default API version to use when no explicit version is specified Returns the most recent stable version as the default.'''
        return typing.cast(builtins.str, jsii.invoke(self, "defaultVersion", []))

    @jsii.member(jsii_name="parentResourceForLocation")
    def _parent_resource_for_location(self) -> typing.Optional[_AzapiResource_7e7f5b39]:
        '''Subnets inherit location from their parent VNet, so no parent resource reference needed The Azure API automatically handles location inheritance for child resources.'''
        return typing.cast(typing.Optional[_AzapiResource_7e7f5b39], jsii.invoke(self, "parentResourceForLocation", []))

    @jsii.member(jsii_name="resolveParentId")
    def _resolve_parent_id(self, props: typing.Any) -> builtins.str:
        '''Resolves the parent ID for the Subnet resource.

        Subnets are child resources of Virtual Networks. This method overrides
        the default parent ID resolution to return the Virtual Network ID instead
        of the Resource Group ID.

        :param props: - The resource properties.

        :return: The Virtual Network ID (parent resource ID)
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e5972640e46e09acc53ddf0b0c905522d1f781f5b76444682c5e30295b3d37b7)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(builtins.str, jsii.invoke(self, "resolveParentId", [props]))

    @jsii.member(jsii_name="resourceType")
    def _resource_type(self) -> builtins.str:
        '''Gets the Azure resource type for Subnets.'''
        return typing.cast(builtins.str, jsii.invoke(self, "resourceType", []))

    @builtins.property
    @jsii.member(jsii_name="addressPrefix")
    def address_prefix(self) -> builtins.str:
        '''Get the address prefix value Returns the address prefix from the input props since Azure API doesn't return it in output.'''
        return typing.cast(builtins.str, jsii.get(self, "addressPrefix"))

    @builtins.property
    @jsii.member(jsii_name="idOutput")
    def id_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "idOutput"))

    @builtins.property
    @jsii.member(jsii_name="nameOutput")
    def name_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "nameOutput"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def props(self) -> _SubnetProps_b86f39ca:
        '''The input properties for this Subnet instance.'''
        return typing.cast(_SubnetProps_b86f39ca, jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="resourceId")
    def resource_id(self) -> builtins.str:
        '''Get the full resource identifier for use in other Azure resources Alias for the id property to match original interface.'''
        return typing.cast(builtins.str, jsii.get(self, "resourceId"))

    @builtins.property
    @jsii.member(jsii_name="virtualNetworkId")
    def virtual_network_id(self) -> builtins.str:
        '''Get the parent Virtual Network ID Constructs the VNet resource ID from the subnet's parent reference.'''
        return typing.cast(builtins.str, jsii.get(self, "virtualNetworkId"))


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.SubnetDelegation",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "service_name": "serviceName", "actions": "actions"},
)
class SubnetDelegation:
    def __init__(
        self,
        *,
        name: builtins.str,
        service_name: builtins.str,
        actions: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''Delegation configuration for Subnet.

        :param name: Name of the delegation.
        :param service_name: The service name to delegate to.
        :param actions: Optional actions allowed for the delegation.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3760530bed36cfa1f705b6e798ab662d62d22a5194bc2a40c8587dba4bba9122)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument service_name", value=service_name, expected_type=type_hints["service_name"])
            check_type(argname="argument actions", value=actions, expected_type=type_hints["actions"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
            "service_name": service_name,
        }
        if actions is not None:
            self._values["actions"] = actions

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of the delegation.'''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def service_name(self) -> builtins.str:
        '''The service name to delegate to.

        Example::

            "Microsoft.Sql/managedInstances"
        '''
        result = self._values.get("service_name")
        assert result is not None, "Required property 'service_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def actions(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Optional actions allowed for the delegation.'''
        result = self._values.get("actions")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SubnetDelegation(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.SubnetNATGatewayReference",
    jsii_struct_bases=[],
    name_mapping={"id": "id"},
)
class SubnetNATGatewayReference:
    def __init__(self, *, id: builtins.str) -> None:
        '''NAT Gateway reference for Subnet.

        :param id: NAT Gateway resource ID.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0abdc93f08f1ad260f5d16f954fc1ff5924049ca242cf8f1dc775d31ee461fbb)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "id": id,
        }

    @builtins.property
    def id(self) -> builtins.str:
        '''NAT Gateway resource ID.'''
        result = self._values.get("id")
        assert result is not None, "Required property 'id' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SubnetNATGatewayReference(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.SubnetNSGReference",
    jsii_struct_bases=[],
    name_mapping={"id": "id"},
)
class SubnetNSGReference:
    def __init__(self, *, id: builtins.str) -> None:
        '''Network Security Group reference for Subnet.

        :param id: Network Security Group resource ID.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7d8c36e05b330717745616b73eb1d7111c3b1b4005e15c9215c2fa2ba7da1b9c)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "id": id,
        }

    @builtins.property
    def id(self) -> builtins.str:
        '''Network Security Group resource ID.'''
        result = self._values.get("id")
        assert result is not None, "Required property 'id' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SubnetNSGReference(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.SubnetProps",
    jsii_struct_bases=[_AzapiResourceProps_141a2340],
    name_mapping={
        "connection": "connection",
        "count": "count",
        "depends_on": "dependsOn",
        "for_each": "forEach",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "provisioners": "provisioners",
        "api_version": "apiVersion",
        "enable_migration_analysis": "enableMigrationAnalysis",
        "enable_transformation": "enableTransformation",
        "enable_validation": "enableValidation",
        "location": "location",
        "monitoring": "monitoring",
        "name": "name",
        "tags": "tags",
        "address_prefix": "addressPrefix",
        "resource_group_id": "resourceGroupId",
        "virtual_network_name": "virtualNetworkName",
        "delegations": "delegations",
        "ignore_changes": "ignoreChanges",
        "ip_allocations": "ipAllocations",
        "nat_gateway": "natGateway",
        "network_security_group": "networkSecurityGroup",
        "private_endpoint_network_policies": "privateEndpointNetworkPolicies",
        "private_link_service_network_policies": "privateLinkServiceNetworkPolicies",
        "route_table": "routeTable",
        "service_endpoints": "serviceEndpoints",
        "virtual_network_id": "virtualNetworkId",
    },
)
class SubnetProps(_AzapiResourceProps_141a2340):
    def __init__(
        self,
        *,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
        api_version: typing.Optional[builtins.str] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        location: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        address_prefix: builtins.str,
        resource_group_id: builtins.str,
        virtual_network_name: builtins.str,
        delegations: typing.Optional[typing.Sequence[typing.Union[_SubnetDelegation_c6136dfd, typing.Dict[builtins.str, typing.Any]]]] = None,
        ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
        ip_allocations: typing.Optional[typing.Sequence[typing.Any]] = None,
        nat_gateway: typing.Optional[typing.Union[_SubnetNATGatewayReference_cf82a70c, typing.Dict[builtins.str, typing.Any]]] = None,
        network_security_group: typing.Optional[typing.Union[_SubnetNSGReference_02d94a8f, typing.Dict[builtins.str, typing.Any]]] = None,
        private_endpoint_network_policies: typing.Optional[builtins.str] = None,
        private_link_service_network_policies: typing.Optional[builtins.str] = None,
        route_table: typing.Optional[typing.Union[_SubnetRouteTableReference_5c30e955, typing.Dict[builtins.str, typing.Any]]] = None,
        service_endpoints: typing.Optional[typing.Sequence[typing.Union[_SubnetServiceEndpoint_ada81b5d, typing.Dict[builtins.str, typing.Any]]]] = None,
        virtual_network_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for the Azure Subnet.

        Extends AzapiResourceProps with Subnet specific properties

        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        :param api_version: Explicit API version to use for this resource. If not specified, the latest active version will be automatically resolved. Use this for version pinning when stability is required over latest features. Default: Latest active version from ApiVersionManager
        :param enable_migration_analysis: Whether to enable migration analysis warnings. When true, the framework will analyze the current version for deprecation status and provide migration recommendations in the deployment output. Default: true
        :param enable_transformation: Whether to apply property transformations automatically. When true, properties will be automatically transformed according to the target schema's transformation rules. This enables backward compatibility. Default: true
        :param enable_validation: Whether to validate properties against the schema. When true, all properties will be validated against the API schema before resource creation. Validation errors will cause deployment failures. Default: true
        :param location: The location where the resource should be created. Default: Varies by resource type - see specific resource documentation
        :param monitoring: Monitoring configuration for this resource. Enables integrated monitoring with diagnostic settings, metric alerts, and activity log alerts. All monitoring is optional and disabled by default.
        :param name: The name of the resource.
        :param tags: Tags to apply to the resource.
        :param address_prefix: Address prefix for the subnet in CIDR notation Must be within the parent VNet's address space.
        :param resource_group_id: Resource group ID where the parent VNet exists Required for constructing the parent ID.
        :param virtual_network_name: Name of the parent virtual network Required for constructing the parent ID.
        :param delegations: Subnet delegations Delegates subnet to specific Azure services.
        :param ignore_changes: The lifecycle rules to ignore changes Useful for properties that are externally managed.
        :param ip_allocations: IP allocations for the subnet Optional - for custom IP allocation.
        :param nat_gateway: NAT gateway reference Optional - for outbound internet connectivity.
        :param network_security_group: Network security group reference Optional - can be attached later.
        :param private_endpoint_network_policies: Private endpoint network policies Controls whether network policies apply to private endpoints. Default: "Disabled"
        :param private_link_service_network_policies: Private link service network policies Controls whether network policies apply to private link services. Default: "Enabled"
        :param route_table: Route table reference Optional - can be attached later.
        :param service_endpoints: Service endpoints for the subnet Enables private access to Azure services.
        :param virtual_network_id: Optional: Full resource ID of the parent Virtual Network When provided, creates a proper Terraform dependency on the VNet If not provided, the parent ID will be constructed from resourceGroupId and virtualNetworkName.
        '''
        if isinstance(lifecycle, dict):
            lifecycle = _cdktf_9a9027ec.TerraformResourceLifecycle(**lifecycle)
        if isinstance(monitoring, dict):
            monitoring = _MonitoringConfig_7c28df74(**monitoring)
        if isinstance(nat_gateway, dict):
            nat_gateway = _SubnetNATGatewayReference_cf82a70c(**nat_gateway)
        if isinstance(network_security_group, dict):
            network_security_group = _SubnetNSGReference_02d94a8f(**network_security_group)
        if isinstance(route_table, dict):
            route_table = _SubnetRouteTableReference_5c30e955(**route_table)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fb7eb17865b91080d67f982d72efdd403124f996da63284cbe00e79529a552ee)
            check_type(argname="argument connection", value=connection, expected_type=type_hints["connection"])
            check_type(argname="argument count", value=count, expected_type=type_hints["count"])
            check_type(argname="argument depends_on", value=depends_on, expected_type=type_hints["depends_on"])
            check_type(argname="argument for_each", value=for_each, expected_type=type_hints["for_each"])
            check_type(argname="argument lifecycle", value=lifecycle, expected_type=type_hints["lifecycle"])
            check_type(argname="argument provider", value=provider, expected_type=type_hints["provider"])
            check_type(argname="argument provisioners", value=provisioners, expected_type=type_hints["provisioners"])
            check_type(argname="argument api_version", value=api_version, expected_type=type_hints["api_version"])
            check_type(argname="argument enable_migration_analysis", value=enable_migration_analysis, expected_type=type_hints["enable_migration_analysis"])
            check_type(argname="argument enable_transformation", value=enable_transformation, expected_type=type_hints["enable_transformation"])
            check_type(argname="argument enable_validation", value=enable_validation, expected_type=type_hints["enable_validation"])
            check_type(argname="argument location", value=location, expected_type=type_hints["location"])
            check_type(argname="argument monitoring", value=monitoring, expected_type=type_hints["monitoring"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument address_prefix", value=address_prefix, expected_type=type_hints["address_prefix"])
            check_type(argname="argument resource_group_id", value=resource_group_id, expected_type=type_hints["resource_group_id"])
            check_type(argname="argument virtual_network_name", value=virtual_network_name, expected_type=type_hints["virtual_network_name"])
            check_type(argname="argument delegations", value=delegations, expected_type=type_hints["delegations"])
            check_type(argname="argument ignore_changes", value=ignore_changes, expected_type=type_hints["ignore_changes"])
            check_type(argname="argument ip_allocations", value=ip_allocations, expected_type=type_hints["ip_allocations"])
            check_type(argname="argument nat_gateway", value=nat_gateway, expected_type=type_hints["nat_gateway"])
            check_type(argname="argument network_security_group", value=network_security_group, expected_type=type_hints["network_security_group"])
            check_type(argname="argument private_endpoint_network_policies", value=private_endpoint_network_policies, expected_type=type_hints["private_endpoint_network_policies"])
            check_type(argname="argument private_link_service_network_policies", value=private_link_service_network_policies, expected_type=type_hints["private_link_service_network_policies"])
            check_type(argname="argument route_table", value=route_table, expected_type=type_hints["route_table"])
            check_type(argname="argument service_endpoints", value=service_endpoints, expected_type=type_hints["service_endpoints"])
            check_type(argname="argument virtual_network_id", value=virtual_network_id, expected_type=type_hints["virtual_network_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "address_prefix": address_prefix,
            "resource_group_id": resource_group_id,
            "virtual_network_name": virtual_network_name,
        }
        if connection is not None:
            self._values["connection"] = connection
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if for_each is not None:
            self._values["for_each"] = for_each
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider
        if provisioners is not None:
            self._values["provisioners"] = provisioners
        if api_version is not None:
            self._values["api_version"] = api_version
        if enable_migration_analysis is not None:
            self._values["enable_migration_analysis"] = enable_migration_analysis
        if enable_transformation is not None:
            self._values["enable_transformation"] = enable_transformation
        if enable_validation is not None:
            self._values["enable_validation"] = enable_validation
        if location is not None:
            self._values["location"] = location
        if monitoring is not None:
            self._values["monitoring"] = monitoring
        if name is not None:
            self._values["name"] = name
        if tags is not None:
            self._values["tags"] = tags
        if delegations is not None:
            self._values["delegations"] = delegations
        if ignore_changes is not None:
            self._values["ignore_changes"] = ignore_changes
        if ip_allocations is not None:
            self._values["ip_allocations"] = ip_allocations
        if nat_gateway is not None:
            self._values["nat_gateway"] = nat_gateway
        if network_security_group is not None:
            self._values["network_security_group"] = network_security_group
        if private_endpoint_network_policies is not None:
            self._values["private_endpoint_network_policies"] = private_endpoint_network_policies
        if private_link_service_network_policies is not None:
            self._values["private_link_service_network_policies"] = private_link_service_network_policies
        if route_table is not None:
            self._values["route_table"] = route_table
        if service_endpoints is not None:
            self._values["service_endpoints"] = service_endpoints
        if virtual_network_id is not None:
            self._values["virtual_network_id"] = virtual_network_id

    @builtins.property
    def connection(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("connection")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]], result)

    @builtins.property
    def count(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]], result)

    @builtins.property
    def depends_on(
        self,
    ) -> typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]], result)

    @builtins.property
    def for_each(self) -> typing.Optional[_cdktf_9a9027ec.ITerraformIterator]:
        '''
        :stability: experimental
        '''
        result = self._values.get("for_each")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.ITerraformIterator], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[_cdktf_9a9027ec.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformProvider], result)

    @builtins.property
    def provisioners(
        self,
    ) -> typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provisioners")
        return typing.cast(typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]], result)

    @builtins.property
    def api_version(self) -> typing.Optional[builtins.str]:
        '''Explicit API version to use for this resource.

        If not specified, the latest active version will be automatically resolved.
        Use this for version pinning when stability is required over latest features.

        :default: Latest active version from ApiVersionManager

        Example::

            "2024-11-01"
        '''
        result = self._values.get("api_version")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def enable_migration_analysis(self) -> typing.Optional[builtins.bool]:
        '''Whether to enable migration analysis warnings.

        When true, the framework will analyze the current version for deprecation
        status and provide migration recommendations in the deployment output.

        :default: true
        '''
        result = self._values.get("enable_migration_analysis")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_transformation(self) -> typing.Optional[builtins.bool]:
        '''Whether to apply property transformations automatically.

        When true, properties will be automatically transformed according to the
        target schema's transformation rules. This enables backward compatibility.

        :default: true
        '''
        result = self._values.get("enable_transformation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_validation(self) -> typing.Optional[builtins.bool]:
        '''Whether to validate properties against the schema.

        When true, all properties will be validated against the API schema before
        resource creation. Validation errors will cause deployment failures.

        :default: true
        '''
        result = self._values.get("enable_validation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def location(self) -> typing.Optional[builtins.str]:
        '''The location where the resource should be created.

        :default: Varies by resource type - see specific resource documentation

        :remarks:

        Location handling varies by resource type:

        - **Top-level resources**: Most require an explicit location (e.g., "eastus", "westus")
        - **Global resources**: Some use "global" as location (e.g., Private DNS Zones)
        - **Child resources**: Inherit location from parent and should NOT set this property

        Each resource type may provide its own default through the ``resolveLocation()`` method.
        If no location is specified and no default exists, resource creation may fail.

        Example::

            // Child resource (Subnet) - do not set location
            // location: undefined (inherited from parent Virtual Network)
        '''
        result = self._values.get("location")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def monitoring(self) -> typing.Optional[_MonitoringConfig_7c28df74]:
        '''Monitoring configuration for this resource.

        Enables integrated monitoring with diagnostic settings, metric alerts,
        and activity log alerts. All monitoring is optional and disabled by default.

        Example::

            monitoring: {
              enabled: true,
              diagnosticSettings: {
                workspaceId: logAnalytics.id,
                metrics: ['AllMetrics'],
                logs: ['AuditLogs']
              },
              metricAlerts: [{
                name: 'high-cpu-alert',
                severity: 2,
                scopes: [], // Automatically set to this resource
                criteria: { ... },
                actions: [{ actionGroupId: actionGroup.id }]
              }]
            }
        '''
        result = self._values.get("monitoring")
        return typing.cast(typing.Optional[_MonitoringConfig_7c28df74], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the resource.'''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Tags to apply to the resource.'''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def address_prefix(self) -> builtins.str:
        '''Address prefix for the subnet in CIDR notation Must be within the parent VNet's address space.

        Example::

            "10.0.1.0/24"
        '''
        result = self._values.get("address_prefix")
        assert result is not None, "Required property 'address_prefix' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def resource_group_id(self) -> builtins.str:
        '''Resource group ID where the parent VNet exists Required for constructing the parent ID.'''
        result = self._values.get("resource_group_id")
        assert result is not None, "Required property 'resource_group_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def virtual_network_name(self) -> builtins.str:
        '''Name of the parent virtual network Required for constructing the parent ID.'''
        result = self._values.get("virtual_network_name")
        assert result is not None, "Required property 'virtual_network_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def delegations(self) -> typing.Optional[typing.List[_SubnetDelegation_c6136dfd]]:
        '''Subnet delegations Delegates subnet to specific Azure services.'''
        result = self._values.get("delegations")
        return typing.cast(typing.Optional[typing.List[_SubnetDelegation_c6136dfd]], result)

    @builtins.property
    def ignore_changes(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The lifecycle rules to ignore changes Useful for properties that are externally managed.

        Example::

            ["networkSecurityGroup", "routeTable"]
        '''
        result = self._values.get("ignore_changes")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def ip_allocations(self) -> typing.Optional[typing.List[typing.Any]]:
        '''IP allocations for the subnet Optional - for custom IP allocation.'''
        result = self._values.get("ip_allocations")
        return typing.cast(typing.Optional[typing.List[typing.Any]], result)

    @builtins.property
    def nat_gateway(self) -> typing.Optional[_SubnetNATGatewayReference_cf82a70c]:
        '''NAT gateway reference Optional - for outbound internet connectivity.'''
        result = self._values.get("nat_gateway")
        return typing.cast(typing.Optional[_SubnetNATGatewayReference_cf82a70c], result)

    @builtins.property
    def network_security_group(self) -> typing.Optional[_SubnetNSGReference_02d94a8f]:
        '''Network security group reference Optional - can be attached later.'''
        result = self._values.get("network_security_group")
        return typing.cast(typing.Optional[_SubnetNSGReference_02d94a8f], result)

    @builtins.property
    def private_endpoint_network_policies(self) -> typing.Optional[builtins.str]:
        '''Private endpoint network policies Controls whether network policies apply to private endpoints.

        :default: "Disabled"
        '''
        result = self._values.get("private_endpoint_network_policies")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def private_link_service_network_policies(self) -> typing.Optional[builtins.str]:
        '''Private link service network policies Controls whether network policies apply to private link services.

        :default: "Enabled"
        '''
        result = self._values.get("private_link_service_network_policies")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def route_table(self) -> typing.Optional[_SubnetRouteTableReference_5c30e955]:
        '''Route table reference Optional - can be attached later.'''
        result = self._values.get("route_table")
        return typing.cast(typing.Optional[_SubnetRouteTableReference_5c30e955], result)

    @builtins.property
    def service_endpoints(
        self,
    ) -> typing.Optional[typing.List[_SubnetServiceEndpoint_ada81b5d]]:
        '''Service endpoints for the subnet Enables private access to Azure services.'''
        result = self._values.get("service_endpoints")
        return typing.cast(typing.Optional[typing.List[_SubnetServiceEndpoint_ada81b5d]], result)

    @builtins.property
    def virtual_network_id(self) -> typing.Optional[builtins.str]:
        '''Optional: Full resource ID of the parent Virtual Network When provided, creates a proper Terraform dependency on the VNet If not provided, the parent ID will be constructed from resourceGroupId and virtualNetworkName.'''
        result = self._values.get("virtual_network_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SubnetProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.SubnetRouteTableReference",
    jsii_struct_bases=[],
    name_mapping={"id": "id"},
)
class SubnetRouteTableReference:
    def __init__(self, *, id: builtins.str) -> None:
        '''Route Table reference for Subnet.

        :param id: Route Table resource ID.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__317803f224ae6350bc978cf483787d91b9bd6c2cc10f09d9f6219cb00b5d6e39)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "id": id,
        }

    @builtins.property
    def id(self) -> builtins.str:
        '''Route Table resource ID.'''
        result = self._values.get("id")
        assert result is not None, "Required property 'id' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SubnetRouteTableReference(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.SubnetServiceEndpoint",
    jsii_struct_bases=[],
    name_mapping={"service": "service", "locations": "locations"},
)
class SubnetServiceEndpoint:
    def __init__(
        self,
        *,
        service: builtins.str,
        locations: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''Service endpoint configuration for Subnet.

        :param service: The service endpoint identifier.
        :param locations: Optional locations where the service endpoint is available.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6d23087bd71b7dfc6f6e16a1cb6352021382cae9e2a59822134183f1aded153f)
            check_type(argname="argument service", value=service, expected_type=type_hints["service"])
            check_type(argname="argument locations", value=locations, expected_type=type_hints["locations"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "service": service,
        }
        if locations is not None:
            self._values["locations"] = locations

    @builtins.property
    def service(self) -> builtins.str:
        '''The service endpoint identifier.

        Example::

            "Microsoft.Storage"
        '''
        result = self._values.get("service")
        assert result is not None, "Required property 'service' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def locations(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Optional locations where the service endpoint is available.

        Example::

            ["eastus", "westus"]
        '''
        result = self._values.get("locations")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SubnetServiceEndpoint(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.TargetDnsServer",
    jsii_struct_bases=[],
    name_mapping={"ip_address": "ipAddress", "port": "port"},
)
class TargetDnsServer:
    def __init__(
        self,
        *,
        ip_address: builtins.str,
        port: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Target DNS server configuration.

        :param ip_address: IP address of the target DNS server.
        :param port: Port number for the target DNS server. Default: 53
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__680757806b3f5351ed32f42bbfedb07ecf76650dc452a0bfa3271f6674a6fcc5)
            check_type(argname="argument ip_address", value=ip_address, expected_type=type_hints["ip_address"])
            check_type(argname="argument port", value=port, expected_type=type_hints["port"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "ip_address": ip_address,
        }
        if port is not None:
            self._values["port"] = port

    @builtins.property
    def ip_address(self) -> builtins.str:
        '''IP address of the target DNS server.

        Example::

            "10.0.0.4"
        '''
        result = self._values.get("ip_address")
        assert result is not None, "Required property 'ip_address' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def port(self) -> typing.Optional[jsii.Number]:
        '''Port number for the target DNS server.

        :default: 53
        '''
        result = self._values.get("port")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TargetDnsServer(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.TerminateNotificationProfile",
    jsii_struct_bases=[],
    name_mapping={"enable": "enable", "not_before_timeout": "notBeforeTimeout"},
)
class TerminateNotificationProfile:
    def __init__(
        self,
        *,
        enable: typing.Optional[builtins.bool] = None,
        not_before_timeout: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Terminate notification profile.

        :param enable: 
        :param not_before_timeout: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7963aec77ea6a0aa80222651c1ba8727cb0ba96c25efde2582b65a5197de0945)
            check_type(argname="argument enable", value=enable, expected_type=type_hints["enable"])
            check_type(argname="argument not_before_timeout", value=not_before_timeout, expected_type=type_hints["not_before_timeout"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if enable is not None:
            self._values["enable"] = enable
        if not_before_timeout is not None:
            self._values["not_before_timeout"] = not_before_timeout

    @builtins.property
    def enable(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("enable")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def not_before_timeout(self) -> typing.Optional[builtins.str]:
        result = self._values.get("not_before_timeout")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TerminateNotificationProfile(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class TestRunMetadata(
    metaclass=jsii.JSIIMeta,
    jsii_type="@microsoft/terraform-cdk-constructs.TestRunMetadata",
):
    '''Metadata for an integration test run.

    Generated once per test execution and shared across all resources
    in that test. Provides unique identification, temporal tracking,
    and CI/CD context.
    '''

    def __init__(
        self,
        test_name: builtins.str,
        *,
        auto_cleanup: typing.Optional[builtins.bool] = None,
        cleanup_policy: typing.Optional[builtins.str] = None,
        max_age_hours: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Creates new test run metadata.

        :param test_name: - Test name (will be sanitized).
        :param auto_cleanup: Enable automated cleanup (default: true).
        :param cleanup_policy: Cleanup policy (default: 'immediate').
        :param max_age_hours: Maximum age in hours before cleanup eligible (default: 4).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a6c18b06c791d78911a393c9173c6d46c9a0e4a914a08076ceaba401c0fb92bf)
            check_type(argname="argument test_name", value=test_name, expected_type=type_hints["test_name"])
        options = TestRunOptions(
            auto_cleanup=auto_cleanup,
            cleanup_policy=cleanup_policy,
            max_age_hours=max_age_hours,
        )

        jsii.create(self.__class__, self, [test_name, options])

    @jsii.member(jsii_name="generateSystemTags")
    def generate_system_tags(self) -> typing.Mapping[builtins.str, builtins.str]:
        '''Generates system tags for resources.

        :return: Integration test system tags
        '''
        return typing.cast(typing.Mapping[builtins.str, builtins.str], jsii.invoke(self, "generateSystemTags", []))

    @jsii.member(jsii_name="isCleanupEligible")
    def is_cleanup_eligible(
        self,
        now: typing.Optional[datetime.datetime] = None,
    ) -> builtins.bool:
        '''Checks if resources from this run are eligible for cleanup.

        :param now: - Current time (defaults to now).

        :return: Whether cleanup is eligible
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f14b21ffc6b4749e52e86ae8c68fe0f10f8dfc035fe5da79fc5360498ba01525)
            check_type(argname="argument now", value=now, expected_type=type_hints["now"])
        return typing.cast(builtins.bool, jsii.invoke(self, "isCleanupEligible", [now]))

    @jsii.member(jsii_name="toJSON")
    def to_json(self) -> typing.Mapping[builtins.str, typing.Any]:
        '''Serializes metadata to JSON for logging.

        :return: JSON-serializable object
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "toJSON", []))

    @builtins.property
    @jsii.member(jsii_name="autoCleanup")
    def auto_cleanup(self) -> builtins.bool:
        '''Enable automated cleanup.'''
        return typing.cast(builtins.bool, jsii.get(self, "autoCleanup"))

    @builtins.property
    @jsii.member(jsii_name="cleanupAfter")
    def cleanup_after(self) -> datetime.datetime:
        '''Cleanup after timestamp (createdAt + maxAgeHours).'''
        return typing.cast(datetime.datetime, jsii.get(self, "cleanupAfter"))

    @builtins.property
    @jsii.member(jsii_name="cleanupPolicy")
    def cleanup_policy(self) -> builtins.str:
        '''Cleanup policy.'''
        return typing.cast(builtins.str, jsii.get(self, "cleanupPolicy"))

    @builtins.property
    @jsii.member(jsii_name="createdAt")
    def created_at(self) -> datetime.datetime:
        '''Timestamp when the test run started.'''
        return typing.cast(datetime.datetime, jsii.get(self, "createdAt"))

    @builtins.property
    @jsii.member(jsii_name="maxAgeHours")
    def max_age_hours(self) -> jsii.Number:
        '''Maximum age in hours before cleanup eligible.'''
        return typing.cast(jsii.Number, jsii.get(self, "maxAgeHours"))

    @builtins.property
    @jsii.member(jsii_name="runId")
    def run_id(self) -> builtins.str:
        '''Unique identifier for this test run (UUID v4).'''
        return typing.cast(builtins.str, jsii.get(self, "runId"))

    @builtins.property
    @jsii.member(jsii_name="testName")
    def test_name(self) -> builtins.str:
        '''Sanitized test name from the describe block.'''
        return typing.cast(builtins.str, jsii.get(self, "testName"))

    @builtins.property
    @jsii.member(jsii_name="ciContext")
    def ci_context(self) -> typing.Optional[CIContext]:
        '''CI/CD context (populated from environment variables).'''
        return typing.cast(typing.Optional[CIContext], jsii.get(self, "ciContext"))


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.TestRunOptions",
    jsii_struct_bases=[],
    name_mapping={
        "auto_cleanup": "autoCleanup",
        "cleanup_policy": "cleanupPolicy",
        "max_age_hours": "maxAgeHours",
    },
)
class TestRunOptions:
    def __init__(
        self,
        *,
        auto_cleanup: typing.Optional[builtins.bool] = None,
        cleanup_policy: typing.Optional[builtins.str] = None,
        max_age_hours: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Test run configuration options.

        :param auto_cleanup: Enable automated cleanup (default: true).
        :param cleanup_policy: Cleanup policy (default: 'immediate').
        :param max_age_hours: Maximum age in hours before cleanup eligible (default: 4).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5d0e17f0c4411328210dedb3abad7c9f9a33f55a5cdb0c104a18addab8a90c00)
            check_type(argname="argument auto_cleanup", value=auto_cleanup, expected_type=type_hints["auto_cleanup"])
            check_type(argname="argument cleanup_policy", value=cleanup_policy, expected_type=type_hints["cleanup_policy"])
            check_type(argname="argument max_age_hours", value=max_age_hours, expected_type=type_hints["max_age_hours"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if auto_cleanup is not None:
            self._values["auto_cleanup"] = auto_cleanup
        if cleanup_policy is not None:
            self._values["cleanup_policy"] = cleanup_policy
        if max_age_hours is not None:
            self._values["max_age_hours"] = max_age_hours

    @builtins.property
    def auto_cleanup(self) -> typing.Optional[builtins.bool]:
        '''Enable automated cleanup (default: true).'''
        result = self._values.get("auto_cleanup")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def cleanup_policy(self) -> typing.Optional[builtins.str]:
        '''Cleanup policy (default: 'immediate').'''
        result = self._values.get("cleanup_policy")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def max_age_hours(self) -> typing.Optional[jsii.Number]:
        '''Maximum age in hours before cleanup eligible (default: 4).'''
        result = self._values.get("max_age_hours")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TestRunOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class UpdateResource(
    _cdktf_9a9027ec.TerraformResource,
    metaclass=jsii.JSIIMeta,
    jsii_type="@microsoft/terraform-cdk-constructs.UpdateResource",
):
    '''Represents a {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/update_resource azapi_update_resource}.'''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        type: builtins.str,
        body: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        ignore_casing: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        ignore_missing_property: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        locks: typing.Optional[typing.Sequence[builtins.str]] = None,
        name: typing.Optional[builtins.str] = None,
        parent_id: typing.Optional[builtins.str] = None,
        read_headers: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        read_query_parameters: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.Sequence[builtins.str]]]] = None,
        resource_id: typing.Optional[builtins.str] = None,
        response_export_values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        retry: typing.Optional[typing.Union["UpdateResourceRetry", typing.Dict[builtins.str, typing.Any]]] = None,
        sensitive_body: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        sensitive_body_version: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        timeouts: typing.Optional[typing.Union["UpdateResourceTimeouts", typing.Dict[builtins.str, typing.Any]]] = None,
        update_headers: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        update_query_parameters: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.Sequence[builtins.str]]]] = None,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> None:
        '''Create a new {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/update_resource azapi_update_resource} Resource.

        :param scope: The scope in which to define this construct.
        :param id: The scoped construct ID. Must be unique amongst siblings in the same scope
        :param type: In a format like ``<resource-type>@<api-version>``. ``<resource-type>`` is the Azure resource type, for example, ``Microsoft.Storage/storageAccounts``. ``<api-version>`` is version of the API used to manage this azure resource. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/update_resource#type UpdateResource#type}
        :param body: A dynamic attribute that contains the request body. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/update_resource#body UpdateResource#body}
        :param ignore_casing: Whether ignore the casing of the property names in the response body. Defaults to ``false``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/update_resource#ignore_casing UpdateResource#ignore_casing}
        :param ignore_missing_property: Whether ignore not returned properties like credentials in ``body`` to suppress plan-diff. Defaults to ``true``. It's recommend to enable this option when some sensitive properties are not returned in response body, instead of setting them in ``lifecycle.ignore_changes`` because it will make the sensitive fields unable to update. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/update_resource#ignore_missing_property UpdateResource#ignore_missing_property}
        :param locks: A list of ARM resource IDs which are used to avoid create/modify/delete azapi resources at the same time. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/update_resource#locks UpdateResource#locks}
        :param name: Specifies the name of the Azure resource. Changing this forces a new resource to be created. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/update_resource#name UpdateResource#name}
        :param parent_id: The ID of the azure resource in which this resource is created. It supports different kinds of deployment scope for **top level** resources: - resource group scope: ``parent_id`` should be the ID of a resource group, it's recommended to manage a resource group by azurerm_resource_group. - management group scope: ``parent_id`` should be the ID of a management group, it's recommended to manage a management group by azurerm_management_group. - extension scope: ``parent_id`` should be the ID of the resource you're adding the extension to. - subscription scope: ``parent_id`` should be like \\x60/subscriptions/00000000-0000-0000-0000-000000000000\\x60 - tenant scope: ``parent_id`` should be / For child level resources, the ``parent_id`` should be the ID of its parent resource, for example, subnet resource's ``parent_id`` is the ID of the vnet. For type ``Microsoft.Resources/resourceGroups``, the ``parent_id`` could be omitted, it defaults to subscription ID specified in provider or the default subscription (You could check the default subscription by azure cli command: ``az account show``). Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/update_resource#parent_id UpdateResource#parent_id}
        :param read_headers: A mapping of headers to be sent with the read request. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/update_resource#read_headers UpdateResource#read_headers}
        :param read_query_parameters: A mapping of query parameters to be sent with the read request. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/update_resource#read_query_parameters UpdateResource#read_query_parameters}
        :param resource_id: The ID of an existing Azure source. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/update_resource#resource_id UpdateResource#resource_id}
        :param response_export_values: The attribute can accept either a list or a map. - **List**: A list of paths that need to be exported from the response body. Setting it to ``["*"]`` will export the full response body. Here's an example. If it sets to ``["properties.loginServer", "properties.policies.quarantinePolicy.status"]``, it will set the following HCL object to the computed property output:: { properties = { loginServer = "registry1.azurecr.io" policies = { quarantinePolicy = { status = "disabled" } } } } - **Map**: A map where the key is the name for the result and the value is a JMESPath query string to filter the response. Here's an example. If it sets to ``{"login_server": "properties.loginServer", "quarantine_status": "properties.policies.quarantinePolicy.status"}``, it will set the following HCL object to the computed property output:: { "login_server" = "registry1.azurecr.io" "quarantine_status" = "disabled" } To learn more about JMESPath, visit `JMESPath <https://jmespath.org/>`_. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/update_resource#response_export_values UpdateResource#response_export_values}
        :param retry: The retry object supports the following attributes:. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/update_resource#retry UpdateResource#retry}
        :param sensitive_body: A dynamic attribute that contains the write-only properties of the request body. This will be merge-patched to the body to construct the actual request body. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/update_resource#sensitive_body UpdateResource#sensitive_body}
        :param sensitive_body_version: A map where the key is the path to the property in ``sensitive_body`` and the value is the version of the property. The key is a string in the format of ``path.to.property[index].subproperty``, where ``index`` is the index of the item in an array. When the version is changed, the property will be included in the request body, otherwise it will be omitted from the request body. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/update_resource#sensitive_body_version UpdateResource#sensitive_body_version}
        :param timeouts: timeouts block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/update_resource#timeouts UpdateResource#timeouts}
        :param update_headers: A mapping of headers to be sent with the update request. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/update_resource#update_headers UpdateResource#update_headers}
        :param update_query_parameters: A mapping of query parameters to be sent with the update request. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/update_resource#update_query_parameters UpdateResource#update_query_parameters}
        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__281208bd5979459b2fb9c40473b7e56ff3827a001dfdab3f367e6d9fa584f1ad)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        config = UpdateResourceConfig(
            type=type,
            body=body,
            ignore_casing=ignore_casing,
            ignore_missing_property=ignore_missing_property,
            locks=locks,
            name=name,
            parent_id=parent_id,
            read_headers=read_headers,
            read_query_parameters=read_query_parameters,
            resource_id=resource_id,
            response_export_values=response_export_values,
            retry=retry,
            sensitive_body=sensitive_body,
            sensitive_body_version=sensitive_body_version,
            timeouts=timeouts,
            update_headers=update_headers,
            update_query_parameters=update_query_parameters,
            connection=connection,
            count=count,
            depends_on=depends_on,
            for_each=for_each,
            lifecycle=lifecycle,
            provider=provider,
            provisioners=provisioners,
        )

        jsii.create(self.__class__, self, [scope, id, config])

    @jsii.member(jsii_name="generateConfigForImport")
    @builtins.classmethod
    def generate_config_for_import(
        cls,
        scope: _constructs_77d1e7e8.Construct,
        import_to_id: builtins.str,
        import_from_id: builtins.str,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    ) -> _cdktf_9a9027ec.ImportableResource:
        '''Generates CDKTF code for importing a UpdateResource resource upon running "cdktf plan ".

        :param scope: The scope in which to define this construct.
        :param import_to_id: The construct id used in the generated config for the UpdateResource to import.
        :param import_from_id: The id of the existing UpdateResource that should be imported. Refer to the {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/update_resource#import import section} in the documentation of this resource for the id to use
        :param provider: ? Optional instance of the provider where the UpdateResource to import is found.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fefd091115ceafa7b98d61be5296b58a51fb8f395595c3e55e9e8dbc42318865)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument import_to_id", value=import_to_id, expected_type=type_hints["import_to_id"])
            check_type(argname="argument import_from_id", value=import_from_id, expected_type=type_hints["import_from_id"])
            check_type(argname="argument provider", value=provider, expected_type=type_hints["provider"])
        return typing.cast(_cdktf_9a9027ec.ImportableResource, jsii.sinvoke(cls, "generateConfigForImport", [scope, import_to_id, import_from_id, provider]))

    @jsii.member(jsii_name="putRetry")
    def put_retry(
        self,
        *,
        error_message_regex: typing.Sequence[builtins.str],
        interval_seconds: typing.Optional[jsii.Number] = None,
        max_interval_seconds: typing.Optional[jsii.Number] = None,
        multiplier: typing.Optional[jsii.Number] = None,
        randomization_factor: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param error_message_regex: A list of regular expressions to match against error messages. If any of the regular expressions match, the request will be retried. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/update_resource#error_message_regex UpdateResource#error_message_regex}
        :param interval_seconds: The base number of seconds to wait between retries. Default is ``10``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/update_resource#interval_seconds UpdateResource#interval_seconds}
        :param max_interval_seconds: The maximum number of seconds to wait between retries. Default is ``180``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/update_resource#max_interval_seconds UpdateResource#max_interval_seconds}
        :param multiplier: The multiplier to apply to the interval between retries. Default is ``1.5``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/update_resource#multiplier UpdateResource#multiplier}
        :param randomization_factor: The randomization factor to apply to the interval between retries. The formula for the randomized interval is: ``RetryInterval * (random value in range [1 - RandomizationFactor, 1 + RandomizationFactor])``. Therefore set to zero ``0.0`` for no randomization. Default is ``0.5``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/update_resource#randomization_factor UpdateResource#randomization_factor}
        '''
        value = UpdateResourceRetry(
            error_message_regex=error_message_regex,
            interval_seconds=interval_seconds,
            max_interval_seconds=max_interval_seconds,
            multiplier=multiplier,
            randomization_factor=randomization_factor,
        )

        return typing.cast(None, jsii.invoke(self, "putRetry", [value]))

    @jsii.member(jsii_name="putTimeouts")
    def put_timeouts(
        self,
        *,
        create: typing.Optional[builtins.str] = None,
        delete: typing.Optional[builtins.str] = None,
        read: typing.Optional[builtins.str] = None,
        update: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param create: A string that can be `parsed as a duration <https://pkg.go.dev/time#ParseDuration>`_ consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/update_resource#create UpdateResource#create}
        :param delete: A string that can be `parsed as a duration <https://pkg.go.dev/time#ParseDuration>`_ consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/update_resource#delete UpdateResource#delete}
        :param read: A string that can be `parsed as a duration <https://pkg.go.dev/time#ParseDuration>`_ consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/update_resource#read UpdateResource#read}
        :param update: A string that can be `parsed as a duration <https://pkg.go.dev/time#ParseDuration>`_ consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/update_resource#update UpdateResource#update}
        '''
        value = UpdateResourceTimeouts(
            create=create, delete=delete, read=read, update=update
        )

        return typing.cast(None, jsii.invoke(self, "putTimeouts", [value]))

    @jsii.member(jsii_name="resetBody")
    def reset_body(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetBody", []))

    @jsii.member(jsii_name="resetIgnoreCasing")
    def reset_ignore_casing(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetIgnoreCasing", []))

    @jsii.member(jsii_name="resetIgnoreMissingProperty")
    def reset_ignore_missing_property(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetIgnoreMissingProperty", []))

    @jsii.member(jsii_name="resetLocks")
    def reset_locks(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetLocks", []))

    @jsii.member(jsii_name="resetName")
    def reset_name(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetName", []))

    @jsii.member(jsii_name="resetParentId")
    def reset_parent_id(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetParentId", []))

    @jsii.member(jsii_name="resetReadHeaders")
    def reset_read_headers(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetReadHeaders", []))

    @jsii.member(jsii_name="resetReadQueryParameters")
    def reset_read_query_parameters(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetReadQueryParameters", []))

    @jsii.member(jsii_name="resetResourceId")
    def reset_resource_id(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetResourceId", []))

    @jsii.member(jsii_name="resetResponseExportValues")
    def reset_response_export_values(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetResponseExportValues", []))

    @jsii.member(jsii_name="resetRetry")
    def reset_retry(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRetry", []))

    @jsii.member(jsii_name="resetSensitiveBody")
    def reset_sensitive_body(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSensitiveBody", []))

    @jsii.member(jsii_name="resetSensitiveBodyVersion")
    def reset_sensitive_body_version(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetSensitiveBodyVersion", []))

    @jsii.member(jsii_name="resetTimeouts")
    def reset_timeouts(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetTimeouts", []))

    @jsii.member(jsii_name="resetUpdateHeaders")
    def reset_update_headers(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetUpdateHeaders", []))

    @jsii.member(jsii_name="resetUpdateQueryParameters")
    def reset_update_query_parameters(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetUpdateQueryParameters", []))

    @jsii.member(jsii_name="synthesizeAttributes")
    def _synthesize_attributes(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "synthesizeAttributes", []))

    @jsii.member(jsii_name="synthesizeHclAttributes")
    def _synthesize_hcl_attributes(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "synthesizeHclAttributes", []))

    @jsii.python.classproperty
    @jsii.member(jsii_name="tfResourceType")
    def TF_RESOURCE_TYPE(cls) -> builtins.str:
        return typing.cast(builtins.str, jsii.sget(cls, "tfResourceType"))

    @builtins.property
    @jsii.member(jsii_name="id")
    def id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "id"))

    @builtins.property
    @jsii.member(jsii_name="output")
    def output(self) -> _cdktf_9a9027ec.AnyMap:
        return typing.cast(_cdktf_9a9027ec.AnyMap, jsii.get(self, "output"))

    @builtins.property
    @jsii.member(jsii_name="retry")
    def retry(self) -> "UpdateResourceRetryOutputReference":
        return typing.cast("UpdateResourceRetryOutputReference", jsii.get(self, "retry"))

    @builtins.property
    @jsii.member(jsii_name="timeouts")
    def timeouts(self) -> "UpdateResourceTimeoutsOutputReference":
        return typing.cast("UpdateResourceTimeoutsOutputReference", jsii.get(self, "timeouts"))

    @builtins.property
    @jsii.member(jsii_name="bodyInput")
    def body_input(self) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], jsii.get(self, "bodyInput"))

    @builtins.property
    @jsii.member(jsii_name="ignoreCasingInput")
    def ignore_casing_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "ignoreCasingInput"))

    @builtins.property
    @jsii.member(jsii_name="ignoreMissingPropertyInput")
    def ignore_missing_property_input(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], jsii.get(self, "ignoreMissingPropertyInput"))

    @builtins.property
    @jsii.member(jsii_name="locksInput")
    def locks_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "locksInput"))

    @builtins.property
    @jsii.member(jsii_name="nameInput")
    def name_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "nameInput"))

    @builtins.property
    @jsii.member(jsii_name="parentIdInput")
    def parent_id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "parentIdInput"))

    @builtins.property
    @jsii.member(jsii_name="readHeadersInput")
    def read_headers_input(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], jsii.get(self, "readHeadersInput"))

    @builtins.property
    @jsii.member(jsii_name="readQueryParametersInput")
    def read_query_parameters_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.List[builtins.str]]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.List[builtins.str]]]], jsii.get(self, "readQueryParametersInput"))

    @builtins.property
    @jsii.member(jsii_name="resourceIdInput")
    def resource_id_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "resourceIdInput"))

    @builtins.property
    @jsii.member(jsii_name="responseExportValuesInput")
    def response_export_values_input(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], jsii.get(self, "responseExportValuesInput"))

    @builtins.property
    @jsii.member(jsii_name="retryInput")
    def retry_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, "UpdateResourceRetry"]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, "UpdateResourceRetry"]], jsii.get(self, "retryInput"))

    @builtins.property
    @jsii.member(jsii_name="sensitiveBodyInput")
    def sensitive_body_input(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], jsii.get(self, "sensitiveBodyInput"))

    @builtins.property
    @jsii.member(jsii_name="sensitiveBodyVersionInput")
    def sensitive_body_version_input(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], jsii.get(self, "sensitiveBodyVersionInput"))

    @builtins.property
    @jsii.member(jsii_name="timeoutsInput")
    def timeouts_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, "UpdateResourceTimeouts"]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, "UpdateResourceTimeouts"]], jsii.get(self, "timeoutsInput"))

    @builtins.property
    @jsii.member(jsii_name="typeInput")
    def type_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "typeInput"))

    @builtins.property
    @jsii.member(jsii_name="updateHeadersInput")
    def update_headers_input(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], jsii.get(self, "updateHeadersInput"))

    @builtins.property
    @jsii.member(jsii_name="updateQueryParametersInput")
    def update_query_parameters_input(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.List[builtins.str]]]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.List[builtins.str]]]], jsii.get(self, "updateQueryParametersInput"))

    @builtins.property
    @jsii.member(jsii_name="body")
    def body(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "body"))

    @body.setter
    def body(self, value: typing.Mapping[builtins.str, typing.Any]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__24bd794bbb1c46f8402e96bc858c8b28a4df0590b2d7ec745bbffb768c3d3470)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "body", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="ignoreCasing")
    def ignore_casing(self) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "ignoreCasing"))

    @ignore_casing.setter
    def ignore_casing(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4cb8639f9a6c82b24ae25e590163132a7c1792f25db19e5af27ec1b7260c0c2a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "ignoreCasing", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="ignoreMissingProperty")
    def ignore_missing_property(
        self,
    ) -> typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]:
        return typing.cast(typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable], jsii.get(self, "ignoreMissingProperty"))

    @ignore_missing_property.setter
    def ignore_missing_property(
        self,
        value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c927810abfe7b4a93a2fbe970cda9edc52458cfc55d325dd0bef1eb10166d266)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "ignoreMissingProperty", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="locks")
    def locks(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "locks"))

    @locks.setter
    def locks(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c66cc57c5c940069dfa83f81f2b057d8eeb97eb23f6e8f5e612a20d1ca2bfbe0)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "locks", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @name.setter
    def name(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e5509c8c583dfd37eb7060c7ea283c0d48a6db05c143e44b8d74f03a717ab06c)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "name", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="parentId")
    def parent_id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "parentId"))

    @parent_id.setter
    def parent_id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0ee27014ec34d7df609c5d4d737f963f47a932978b48529be68eeaf583b3b30d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "parentId", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="readHeaders")
    def read_headers(self) -> typing.Mapping[builtins.str, builtins.str]:
        return typing.cast(typing.Mapping[builtins.str, builtins.str], jsii.get(self, "readHeaders"))

    @read_headers.setter
    def read_headers(self, value: typing.Mapping[builtins.str, builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2f5f4a4fbb1be9992450563aa07816a421096eead03aff37e8c856bd42467c48)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "readHeaders", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="readQueryParameters")
    def read_query_parameters(
        self,
    ) -> typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.List[builtins.str]]]:
        return typing.cast(typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.List[builtins.str]]], jsii.get(self, "readQueryParameters"))

    @read_query_parameters.setter
    def read_query_parameters(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.List[builtins.str]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8382baf5d98d087a6f342e3de120650f84a781f601d9d3e0c0a8e9436658ccb1)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "readQueryParameters", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="resourceId")
    def resource_id(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "resourceId"))

    @resource_id.setter
    def resource_id(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__724528297e435ecd5d272c296a481cf0035199c8fa6e59f6e8d50de64b1be84d)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "resourceId", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="responseExportValues")
    def response_export_values(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "responseExportValues"))

    @response_export_values.setter
    def response_export_values(
        self,
        value: typing.Mapping[builtins.str, typing.Any],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bc2704da0c80b3eff015e9306a550af5fb677bdca419c256e384ef41c206f576)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "responseExportValues", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="sensitiveBody")
    def sensitive_body(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "sensitiveBody"))

    @sensitive_body.setter
    def sensitive_body(self, value: typing.Mapping[builtins.str, typing.Any]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4a601f943176f52cfd86bece65a02257c652ca356e0a5d03633156ccf00c8ca1)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "sensitiveBody", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="sensitiveBodyVersion")
    def sensitive_body_version(self) -> typing.Mapping[builtins.str, builtins.str]:
        return typing.cast(typing.Mapping[builtins.str, builtins.str], jsii.get(self, "sensitiveBodyVersion"))

    @sensitive_body_version.setter
    def sensitive_body_version(
        self,
        value: typing.Mapping[builtins.str, builtins.str],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d1e5a9bd6f57eefda1dc9ffe8f8e3220c35d087ac5d6fc3a2a7fd0fb1e01b432)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "sensitiveBodyVersion", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="type")
    def type(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "type"))

    @type.setter
    def type(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6faff092d7698d576ca2125b85d264d346e87923aa86938a05cc59b365f562bc)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "type", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="updateHeaders")
    def update_headers(self) -> typing.Mapping[builtins.str, builtins.str]:
        return typing.cast(typing.Mapping[builtins.str, builtins.str], jsii.get(self, "updateHeaders"))

    @update_headers.setter
    def update_headers(self, value: typing.Mapping[builtins.str, builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1df2ecf47fdda34769a609afd2ff064f7dba437a340acaa5c572ac5ee66ae164)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "updateHeaders", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="updateQueryParameters")
    def update_query_parameters(
        self,
    ) -> typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.List[builtins.str]]]:
        return typing.cast(typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.List[builtins.str]]], jsii.get(self, "updateQueryParameters"))

    @update_query_parameters.setter
    def update_query_parameters(
        self,
        value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.List[builtins.str]]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__997323a4824c206e270959d8c13005833d29789e2c841658d98259d3e2ee0fe0)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "updateQueryParameters", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.UpdateResourceConfig",
    jsii_struct_bases=[_cdktf_9a9027ec.TerraformMetaArguments],
    name_mapping={
        "connection": "connection",
        "count": "count",
        "depends_on": "dependsOn",
        "for_each": "forEach",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "provisioners": "provisioners",
        "type": "type",
        "body": "body",
        "ignore_casing": "ignoreCasing",
        "ignore_missing_property": "ignoreMissingProperty",
        "locks": "locks",
        "name": "name",
        "parent_id": "parentId",
        "read_headers": "readHeaders",
        "read_query_parameters": "readQueryParameters",
        "resource_id": "resourceId",
        "response_export_values": "responseExportValues",
        "retry": "retry",
        "sensitive_body": "sensitiveBody",
        "sensitive_body_version": "sensitiveBodyVersion",
        "timeouts": "timeouts",
        "update_headers": "updateHeaders",
        "update_query_parameters": "updateQueryParameters",
    },
)
class UpdateResourceConfig(_cdktf_9a9027ec.TerraformMetaArguments):
    def __init__(
        self,
        *,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
        type: builtins.str,
        body: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        ignore_casing: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        ignore_missing_property: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
        locks: typing.Optional[typing.Sequence[builtins.str]] = None,
        name: typing.Optional[builtins.str] = None,
        parent_id: typing.Optional[builtins.str] = None,
        read_headers: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        read_query_parameters: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.Sequence[builtins.str]]]] = None,
        resource_id: typing.Optional[builtins.str] = None,
        response_export_values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        retry: typing.Optional[typing.Union["UpdateResourceRetry", typing.Dict[builtins.str, typing.Any]]] = None,
        sensitive_body: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        sensitive_body_version: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        timeouts: typing.Optional[typing.Union["UpdateResourceTimeouts", typing.Dict[builtins.str, typing.Any]]] = None,
        update_headers: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        update_query_parameters: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.Sequence[builtins.str]]]] = None,
    ) -> None:
        '''
        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        :param type: In a format like ``<resource-type>@<api-version>``. ``<resource-type>`` is the Azure resource type, for example, ``Microsoft.Storage/storageAccounts``. ``<api-version>`` is version of the API used to manage this azure resource. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/update_resource#type UpdateResource#type}
        :param body: A dynamic attribute that contains the request body. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/update_resource#body UpdateResource#body}
        :param ignore_casing: Whether ignore the casing of the property names in the response body. Defaults to ``false``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/update_resource#ignore_casing UpdateResource#ignore_casing}
        :param ignore_missing_property: Whether ignore not returned properties like credentials in ``body`` to suppress plan-diff. Defaults to ``true``. It's recommend to enable this option when some sensitive properties are not returned in response body, instead of setting them in ``lifecycle.ignore_changes`` because it will make the sensitive fields unable to update. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/update_resource#ignore_missing_property UpdateResource#ignore_missing_property}
        :param locks: A list of ARM resource IDs which are used to avoid create/modify/delete azapi resources at the same time. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/update_resource#locks UpdateResource#locks}
        :param name: Specifies the name of the Azure resource. Changing this forces a new resource to be created. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/update_resource#name UpdateResource#name}
        :param parent_id: The ID of the azure resource in which this resource is created. It supports different kinds of deployment scope for **top level** resources: - resource group scope: ``parent_id`` should be the ID of a resource group, it's recommended to manage a resource group by azurerm_resource_group. - management group scope: ``parent_id`` should be the ID of a management group, it's recommended to manage a management group by azurerm_management_group. - extension scope: ``parent_id`` should be the ID of the resource you're adding the extension to. - subscription scope: ``parent_id`` should be like \\x60/subscriptions/00000000-0000-0000-0000-000000000000\\x60 - tenant scope: ``parent_id`` should be / For child level resources, the ``parent_id`` should be the ID of its parent resource, for example, subnet resource's ``parent_id`` is the ID of the vnet. For type ``Microsoft.Resources/resourceGroups``, the ``parent_id`` could be omitted, it defaults to subscription ID specified in provider or the default subscription (You could check the default subscription by azure cli command: ``az account show``). Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/update_resource#parent_id UpdateResource#parent_id}
        :param read_headers: A mapping of headers to be sent with the read request. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/update_resource#read_headers UpdateResource#read_headers}
        :param read_query_parameters: A mapping of query parameters to be sent with the read request. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/update_resource#read_query_parameters UpdateResource#read_query_parameters}
        :param resource_id: The ID of an existing Azure source. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/update_resource#resource_id UpdateResource#resource_id}
        :param response_export_values: The attribute can accept either a list or a map. - **List**: A list of paths that need to be exported from the response body. Setting it to ``["*"]`` will export the full response body. Here's an example. If it sets to ``["properties.loginServer", "properties.policies.quarantinePolicy.status"]``, it will set the following HCL object to the computed property output:: { properties = { loginServer = "registry1.azurecr.io" policies = { quarantinePolicy = { status = "disabled" } } } } - **Map**: A map where the key is the name for the result and the value is a JMESPath query string to filter the response. Here's an example. If it sets to ``{"login_server": "properties.loginServer", "quarantine_status": "properties.policies.quarantinePolicy.status"}``, it will set the following HCL object to the computed property output:: { "login_server" = "registry1.azurecr.io" "quarantine_status" = "disabled" } To learn more about JMESPath, visit `JMESPath <https://jmespath.org/>`_. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/update_resource#response_export_values UpdateResource#response_export_values}
        :param retry: The retry object supports the following attributes:. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/update_resource#retry UpdateResource#retry}
        :param sensitive_body: A dynamic attribute that contains the write-only properties of the request body. This will be merge-patched to the body to construct the actual request body. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/update_resource#sensitive_body UpdateResource#sensitive_body}
        :param sensitive_body_version: A map where the key is the path to the property in ``sensitive_body`` and the value is the version of the property. The key is a string in the format of ``path.to.property[index].subproperty``, where ``index`` is the index of the item in an array. When the version is changed, the property will be included in the request body, otherwise it will be omitted from the request body. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/update_resource#sensitive_body_version UpdateResource#sensitive_body_version}
        :param timeouts: timeouts block. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/update_resource#timeouts UpdateResource#timeouts}
        :param update_headers: A mapping of headers to be sent with the update request. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/update_resource#update_headers UpdateResource#update_headers}
        :param update_query_parameters: A mapping of query parameters to be sent with the update request. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/update_resource#update_query_parameters UpdateResource#update_query_parameters}
        '''
        if isinstance(lifecycle, dict):
            lifecycle = _cdktf_9a9027ec.TerraformResourceLifecycle(**lifecycle)
        if isinstance(retry, dict):
            retry = UpdateResourceRetry(**retry)
        if isinstance(timeouts, dict):
            timeouts = UpdateResourceTimeouts(**timeouts)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7b47a964a364d29e6295c7e65c99c8a54cd1962f0bd798c23d32ee91f00e4a13)
            check_type(argname="argument connection", value=connection, expected_type=type_hints["connection"])
            check_type(argname="argument count", value=count, expected_type=type_hints["count"])
            check_type(argname="argument depends_on", value=depends_on, expected_type=type_hints["depends_on"])
            check_type(argname="argument for_each", value=for_each, expected_type=type_hints["for_each"])
            check_type(argname="argument lifecycle", value=lifecycle, expected_type=type_hints["lifecycle"])
            check_type(argname="argument provider", value=provider, expected_type=type_hints["provider"])
            check_type(argname="argument provisioners", value=provisioners, expected_type=type_hints["provisioners"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument body", value=body, expected_type=type_hints["body"])
            check_type(argname="argument ignore_casing", value=ignore_casing, expected_type=type_hints["ignore_casing"])
            check_type(argname="argument ignore_missing_property", value=ignore_missing_property, expected_type=type_hints["ignore_missing_property"])
            check_type(argname="argument locks", value=locks, expected_type=type_hints["locks"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument parent_id", value=parent_id, expected_type=type_hints["parent_id"])
            check_type(argname="argument read_headers", value=read_headers, expected_type=type_hints["read_headers"])
            check_type(argname="argument read_query_parameters", value=read_query_parameters, expected_type=type_hints["read_query_parameters"])
            check_type(argname="argument resource_id", value=resource_id, expected_type=type_hints["resource_id"])
            check_type(argname="argument response_export_values", value=response_export_values, expected_type=type_hints["response_export_values"])
            check_type(argname="argument retry", value=retry, expected_type=type_hints["retry"])
            check_type(argname="argument sensitive_body", value=sensitive_body, expected_type=type_hints["sensitive_body"])
            check_type(argname="argument sensitive_body_version", value=sensitive_body_version, expected_type=type_hints["sensitive_body_version"])
            check_type(argname="argument timeouts", value=timeouts, expected_type=type_hints["timeouts"])
            check_type(argname="argument update_headers", value=update_headers, expected_type=type_hints["update_headers"])
            check_type(argname="argument update_query_parameters", value=update_query_parameters, expected_type=type_hints["update_query_parameters"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "type": type,
        }
        if connection is not None:
            self._values["connection"] = connection
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if for_each is not None:
            self._values["for_each"] = for_each
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider
        if provisioners is not None:
            self._values["provisioners"] = provisioners
        if body is not None:
            self._values["body"] = body
        if ignore_casing is not None:
            self._values["ignore_casing"] = ignore_casing
        if ignore_missing_property is not None:
            self._values["ignore_missing_property"] = ignore_missing_property
        if locks is not None:
            self._values["locks"] = locks
        if name is not None:
            self._values["name"] = name
        if parent_id is not None:
            self._values["parent_id"] = parent_id
        if read_headers is not None:
            self._values["read_headers"] = read_headers
        if read_query_parameters is not None:
            self._values["read_query_parameters"] = read_query_parameters
        if resource_id is not None:
            self._values["resource_id"] = resource_id
        if response_export_values is not None:
            self._values["response_export_values"] = response_export_values
        if retry is not None:
            self._values["retry"] = retry
        if sensitive_body is not None:
            self._values["sensitive_body"] = sensitive_body
        if sensitive_body_version is not None:
            self._values["sensitive_body_version"] = sensitive_body_version
        if timeouts is not None:
            self._values["timeouts"] = timeouts
        if update_headers is not None:
            self._values["update_headers"] = update_headers
        if update_query_parameters is not None:
            self._values["update_query_parameters"] = update_query_parameters

    @builtins.property
    def connection(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("connection")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]], result)

    @builtins.property
    def count(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]], result)

    @builtins.property
    def depends_on(
        self,
    ) -> typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]], result)

    @builtins.property
    def for_each(self) -> typing.Optional[_cdktf_9a9027ec.ITerraformIterator]:
        '''
        :stability: experimental
        '''
        result = self._values.get("for_each")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.ITerraformIterator], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[_cdktf_9a9027ec.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformProvider], result)

    @builtins.property
    def provisioners(
        self,
    ) -> typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provisioners")
        return typing.cast(typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]], result)

    @builtins.property
    def type(self) -> builtins.str:
        '''In a format like ``<resource-type>@<api-version>``.

        ``<resource-type>`` is the Azure resource type, for example, ``Microsoft.Storage/storageAccounts``. ``<api-version>`` is version of the API used to manage this azure resource.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/update_resource#type UpdateResource#type}
        '''
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def body(self) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''A dynamic attribute that contains the request body.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/update_resource#body UpdateResource#body}
        '''
        result = self._values.get("body")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def ignore_casing(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Whether ignore the casing of the property names in the response body. Defaults to ``false``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/update_resource#ignore_casing UpdateResource#ignore_casing}
        '''
        result = self._values.get("ignore_casing")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    @builtins.property
    def ignore_missing_property(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]]:
        '''Whether ignore not returned properties like credentials in ``body`` to suppress plan-diff.

        Defaults to ``true``. It's recommend to enable this option when some sensitive properties are not returned in response body, instead of setting them in ``lifecycle.ignore_changes`` because it will make the sensitive fields unable to update.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/update_resource#ignore_missing_property UpdateResource#ignore_missing_property}
        '''
        result = self._values.get("ignore_missing_property")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]], result)

    @builtins.property
    def locks(self) -> typing.Optional[typing.List[builtins.str]]:
        '''A list of ARM resource IDs which are used to avoid create/modify/delete azapi resources at the same time.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/update_resource#locks UpdateResource#locks}
        '''
        result = self._values.get("locks")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''Specifies the name of the Azure resource. Changing this forces a new resource to be created.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/update_resource#name UpdateResource#name}
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def parent_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the azure resource in which this resource is created.

        It supports different kinds of deployment scope for **top level** resources:

        - resource group scope: ``parent_id`` should be the ID of a resource group, it's recommended to manage a resource group by azurerm_resource_group.

          - management group scope: ``parent_id`` should be the ID of a management group, it's recommended to manage a management group by azurerm_management_group.
          - extension scope: ``parent_id`` should be the ID of the resource you're adding the extension to.
          - subscription scope: ``parent_id`` should be like \\x60/subscriptions/00000000-0000-0000-0000-000000000000\\x60
          - tenant scope: ``parent_id`` should be /

        For child level resources, the ``parent_id`` should be the ID of its parent resource, for example, subnet resource's ``parent_id`` is the ID of the vnet.

        For type ``Microsoft.Resources/resourceGroups``, the ``parent_id`` could be omitted, it defaults to subscription ID specified in provider or the default subscription (You could check the default subscription by azure cli command: ``az account show``).

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/update_resource#parent_id UpdateResource#parent_id}
        '''
        result = self._values.get("parent_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def read_headers(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''A mapping of headers to be sent with the read request.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/update_resource#read_headers UpdateResource#read_headers}
        '''
        result = self._values.get("read_headers")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def read_query_parameters(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.List[builtins.str]]]]:
        '''A mapping of query parameters to be sent with the read request.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/update_resource#read_query_parameters UpdateResource#read_query_parameters}
        '''
        result = self._values.get("read_query_parameters")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.List[builtins.str]]]], result)

    @builtins.property
    def resource_id(self) -> typing.Optional[builtins.str]:
        '''The ID of an existing Azure source.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/update_resource#resource_id UpdateResource#resource_id}
        '''
        result = self._values.get("resource_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def response_export_values(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''The attribute can accept either a list or a map.

        - **List**: A list of paths that need to be exported from the response body. Setting it to ``["*"]`` will export the full response body. Here's an example. If it sets to ``["properties.loginServer", "properties.policies.quarantinePolicy.status"]``, it will set the following HCL object to the computed property output::

             {
             	properties = {
             		loginServer = "registry1.azurecr.io"
             		policies = {
             			quarantinePolicy = {
             				status = "disabled"
             			}
             		}
             	}
             }
        - **Map**: A map where the key is the name for the result and the value is a JMESPath query string to filter the response. Here's an example. If it sets to ``{"login_server": "properties.loginServer", "quarantine_status": "properties.policies.quarantinePolicy.status"}``, it will set the following HCL object to the computed property output::

             {
             	"login_server" = "registry1.azurecr.io"
             	"quarantine_status" = "disabled"
             }

        To learn more about JMESPath, visit `JMESPath <https://jmespath.org/>`_.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/update_resource#response_export_values UpdateResource#response_export_values}
        '''
        result = self._values.get("response_export_values")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def retry(self) -> typing.Optional["UpdateResourceRetry"]:
        '''The retry object supports the following attributes:.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/update_resource#retry UpdateResource#retry}
        '''
        result = self._values.get("retry")
        return typing.cast(typing.Optional["UpdateResourceRetry"], result)

    @builtins.property
    def sensitive_body(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''A dynamic attribute that contains the write-only properties of the request body.

        This will be merge-patched to the body to construct the actual request body.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/update_resource#sensitive_body UpdateResource#sensitive_body}
        '''
        result = self._values.get("sensitive_body")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def sensitive_body_version(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''A map where the key is the path to the property in ``sensitive_body`` and the value is the version of the property.

        The key is a string in the format of ``path.to.property[index].subproperty``, where ``index`` is the index of the item in an array. When the version is changed, the property will be included in the request body, otherwise it will be omitted from the request body.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/update_resource#sensitive_body_version UpdateResource#sensitive_body_version}
        '''
        result = self._values.get("sensitive_body_version")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def timeouts(self) -> typing.Optional["UpdateResourceTimeouts"]:
        '''timeouts block.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/update_resource#timeouts UpdateResource#timeouts}
        '''
        result = self._values.get("timeouts")
        return typing.cast(typing.Optional["UpdateResourceTimeouts"], result)

    @builtins.property
    def update_headers(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''A mapping of headers to be sent with the update request.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/update_resource#update_headers UpdateResource#update_headers}
        '''
        result = self._values.get("update_headers")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def update_query_parameters(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.List[builtins.str]]]]:
        '''A mapping of query parameters to be sent with the update request.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/update_resource#update_query_parameters UpdateResource#update_query_parameters}
        '''
        result = self._values.get("update_query_parameters")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.List[builtins.str]]]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "UpdateResourceConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.UpdateResourceRetry",
    jsii_struct_bases=[],
    name_mapping={
        "error_message_regex": "errorMessageRegex",
        "interval_seconds": "intervalSeconds",
        "max_interval_seconds": "maxIntervalSeconds",
        "multiplier": "multiplier",
        "randomization_factor": "randomizationFactor",
    },
)
class UpdateResourceRetry:
    def __init__(
        self,
        *,
        error_message_regex: typing.Sequence[builtins.str],
        interval_seconds: typing.Optional[jsii.Number] = None,
        max_interval_seconds: typing.Optional[jsii.Number] = None,
        multiplier: typing.Optional[jsii.Number] = None,
        randomization_factor: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param error_message_regex: A list of regular expressions to match against error messages. If any of the regular expressions match, the request will be retried. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/update_resource#error_message_regex UpdateResource#error_message_regex}
        :param interval_seconds: The base number of seconds to wait between retries. Default is ``10``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/update_resource#interval_seconds UpdateResource#interval_seconds}
        :param max_interval_seconds: The maximum number of seconds to wait between retries. Default is ``180``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/update_resource#max_interval_seconds UpdateResource#max_interval_seconds}
        :param multiplier: The multiplier to apply to the interval between retries. Default is ``1.5``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/update_resource#multiplier UpdateResource#multiplier}
        :param randomization_factor: The randomization factor to apply to the interval between retries. The formula for the randomized interval is: ``RetryInterval * (random value in range [1 - RandomizationFactor, 1 + RandomizationFactor])``. Therefore set to zero ``0.0`` for no randomization. Default is ``0.5``. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/update_resource#randomization_factor UpdateResource#randomization_factor}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__87d45f83b2ad1d82c585e1dba7904d689304a9d3f8e8b83aaafd685ddc575771)
            check_type(argname="argument error_message_regex", value=error_message_regex, expected_type=type_hints["error_message_regex"])
            check_type(argname="argument interval_seconds", value=interval_seconds, expected_type=type_hints["interval_seconds"])
            check_type(argname="argument max_interval_seconds", value=max_interval_seconds, expected_type=type_hints["max_interval_seconds"])
            check_type(argname="argument multiplier", value=multiplier, expected_type=type_hints["multiplier"])
            check_type(argname="argument randomization_factor", value=randomization_factor, expected_type=type_hints["randomization_factor"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "error_message_regex": error_message_regex,
        }
        if interval_seconds is not None:
            self._values["interval_seconds"] = interval_seconds
        if max_interval_seconds is not None:
            self._values["max_interval_seconds"] = max_interval_seconds
        if multiplier is not None:
            self._values["multiplier"] = multiplier
        if randomization_factor is not None:
            self._values["randomization_factor"] = randomization_factor

    @builtins.property
    def error_message_regex(self) -> typing.List[builtins.str]:
        '''A list of regular expressions to match against error messages.

        If any of the regular expressions match, the request will be retried.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/update_resource#error_message_regex UpdateResource#error_message_regex}
        '''
        result = self._values.get("error_message_regex")
        assert result is not None, "Required property 'error_message_regex' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def interval_seconds(self) -> typing.Optional[jsii.Number]:
        '''The base number of seconds to wait between retries. Default is ``10``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/update_resource#interval_seconds UpdateResource#interval_seconds}
        '''
        result = self._values.get("interval_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def max_interval_seconds(self) -> typing.Optional[jsii.Number]:
        '''The maximum number of seconds to wait between retries. Default is ``180``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/update_resource#max_interval_seconds UpdateResource#max_interval_seconds}
        '''
        result = self._values.get("max_interval_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def multiplier(self) -> typing.Optional[jsii.Number]:
        '''The multiplier to apply to the interval between retries. Default is ``1.5``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/update_resource#multiplier UpdateResource#multiplier}
        '''
        result = self._values.get("multiplier")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def randomization_factor(self) -> typing.Optional[jsii.Number]:
        '''The randomization factor to apply to the interval between retries.

        The formula for the randomized interval is: ``RetryInterval * (random value in range [1 - RandomizationFactor, 1 + RandomizationFactor])``. Therefore set to zero ``0.0`` for no randomization. Default is ``0.5``.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/update_resource#randomization_factor UpdateResource#randomization_factor}
        '''
        result = self._values.get("randomization_factor")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "UpdateResourceRetry(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class UpdateResourceRetryOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@microsoft/terraform-cdk-constructs.UpdateResourceRetryOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c41206770fa357fa9709c92d018356f71b2e869135d9fe2861d8157847223556)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetIntervalSeconds")
    def reset_interval_seconds(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetIntervalSeconds", []))

    @jsii.member(jsii_name="resetMaxIntervalSeconds")
    def reset_max_interval_seconds(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMaxIntervalSeconds", []))

    @jsii.member(jsii_name="resetMultiplier")
    def reset_multiplier(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetMultiplier", []))

    @jsii.member(jsii_name="resetRandomizationFactor")
    def reset_randomization_factor(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRandomizationFactor", []))

    @builtins.property
    @jsii.member(jsii_name="errorMessageRegexInput")
    def error_message_regex_input(self) -> typing.Optional[typing.List[builtins.str]]:
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "errorMessageRegexInput"))

    @builtins.property
    @jsii.member(jsii_name="intervalSecondsInput")
    def interval_seconds_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "intervalSecondsInput"))

    @builtins.property
    @jsii.member(jsii_name="maxIntervalSecondsInput")
    def max_interval_seconds_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "maxIntervalSecondsInput"))

    @builtins.property
    @jsii.member(jsii_name="multiplierInput")
    def multiplier_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "multiplierInput"))

    @builtins.property
    @jsii.member(jsii_name="randomizationFactorInput")
    def randomization_factor_input(self) -> typing.Optional[jsii.Number]:
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "randomizationFactorInput"))

    @builtins.property
    @jsii.member(jsii_name="errorMessageRegex")
    def error_message_regex(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "errorMessageRegex"))

    @error_message_regex.setter
    def error_message_regex(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__da62c45d5fbf12579507780b8c2183bd172b80225c48b831e041bd16e9303cb2)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "errorMessageRegex", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="intervalSeconds")
    def interval_seconds(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "intervalSeconds"))

    @interval_seconds.setter
    def interval_seconds(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__edb395a935210b210773fbc5a92da77cafde2ae6c7bca0e8af9442c17428f48e)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "intervalSeconds", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="maxIntervalSeconds")
    def max_interval_seconds(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "maxIntervalSeconds"))

    @max_interval_seconds.setter
    def max_interval_seconds(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f47cf8c7b3f381923d0a2daadd5b1874533029c21befa0ec4128fcb287e1fca1)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "maxIntervalSeconds", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="multiplier")
    def multiplier(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "multiplier"))

    @multiplier.setter
    def multiplier(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dc6aeca07ac69489c9dfeac49dd53309a5fe591b3332385ff32f64d17c8296dc)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "multiplier", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="randomizationFactor")
    def randomization_factor(self) -> jsii.Number:
        return typing.cast(jsii.Number, jsii.get(self, "randomizationFactor"))

    @randomization_factor.setter
    def randomization_factor(self, value: jsii.Number) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0e34b85505a5ed45c25bc4b00f058a7820d2104f28f306ab039fcd3e9b1c1131)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "randomizationFactor", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, UpdateResourceRetry]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, UpdateResourceRetry]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, UpdateResourceRetry]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a1858a84871a0495501923f0e43383c66682ba256e531363d48c31ef7505b6aa)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.UpdateResourceTimeouts",
    jsii_struct_bases=[],
    name_mapping={
        "create": "create",
        "delete": "delete",
        "read": "read",
        "update": "update",
    },
)
class UpdateResourceTimeouts:
    def __init__(
        self,
        *,
        create: typing.Optional[builtins.str] = None,
        delete: typing.Optional[builtins.str] = None,
        read: typing.Optional[builtins.str] = None,
        update: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param create: A string that can be `parsed as a duration <https://pkg.go.dev/time#ParseDuration>`_ consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/update_resource#create UpdateResource#create}
        :param delete: A string that can be `parsed as a duration <https://pkg.go.dev/time#ParseDuration>`_ consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/update_resource#delete UpdateResource#delete}
        :param read: A string that can be `parsed as a duration <https://pkg.go.dev/time#ParseDuration>`_ consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled. Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/update_resource#read UpdateResource#read}
        :param update: A string that can be `parsed as a duration <https://pkg.go.dev/time#ParseDuration>`_ consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/update_resource#update UpdateResource#update}
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7beb3d1c9cf97f822976fb8d91dde2779b79c5b2568e7e5917e16c666376c6c7)
            check_type(argname="argument create", value=create, expected_type=type_hints["create"])
            check_type(argname="argument delete", value=delete, expected_type=type_hints["delete"])
            check_type(argname="argument read", value=read, expected_type=type_hints["read"])
            check_type(argname="argument update", value=update, expected_type=type_hints["update"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if create is not None:
            self._values["create"] = create
        if delete is not None:
            self._values["delete"] = delete
        if read is not None:
            self._values["read"] = read
        if update is not None:
            self._values["update"] = update

    @builtins.property
    def create(self) -> typing.Optional[builtins.str]:
        '''A string that can be `parsed as a duration <https://pkg.go.dev/time#ParseDuration>`_ consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/update_resource#create UpdateResource#create}
        '''
        result = self._values.get("create")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def delete(self) -> typing.Optional[builtins.str]:
        '''A string that can be `parsed as a duration <https://pkg.go.dev/time#ParseDuration>`_ consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/update_resource#delete UpdateResource#delete}
        '''
        result = self._values.get("delete")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def read(self) -> typing.Optional[builtins.str]:
        '''A string that can be `parsed as a duration <https://pkg.go.dev/time#ParseDuration>`_ consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/update_resource#read UpdateResource#read}
        '''
        result = self._values.get("read")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def update(self) -> typing.Optional[builtins.str]:
        '''A string that can be `parsed as a duration <https://pkg.go.dev/time#ParseDuration>`_ consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).

        Docs at Terraform Registry: {@link https://registry.terraform.io/providers/azure/azapi/2.7.0/docs/resources/update_resource#update UpdateResource#update}
        '''
        result = self._values.get("update")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "UpdateResourceTimeouts(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class UpdateResourceTimeoutsOutputReference(
    _cdktf_9a9027ec.ComplexObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="@microsoft/terraform-cdk-constructs.UpdateResourceTimeoutsOutputReference",
):
    def __init__(
        self,
        terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
        terraform_attribute: builtins.str,
    ) -> None:
        '''
        :param terraform_resource: The parent resource.
        :param terraform_attribute: The attribute on the parent resource this class is referencing.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4cdb2be43cdb81266407e287f64c0f7ead06e2cc7b0af479133afe8a3f8e5441)
            check_type(argname="argument terraform_resource", value=terraform_resource, expected_type=type_hints["terraform_resource"])
            check_type(argname="argument terraform_attribute", value=terraform_attribute, expected_type=type_hints["terraform_attribute"])
        jsii.create(self.__class__, self, [terraform_resource, terraform_attribute])

    @jsii.member(jsii_name="resetCreate")
    def reset_create(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetCreate", []))

    @jsii.member(jsii_name="resetDelete")
    def reset_delete(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetDelete", []))

    @jsii.member(jsii_name="resetRead")
    def reset_read(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetRead", []))

    @jsii.member(jsii_name="resetUpdate")
    def reset_update(self) -> None:
        return typing.cast(None, jsii.invoke(self, "resetUpdate", []))

    @builtins.property
    @jsii.member(jsii_name="createInput")
    def create_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "createInput"))

    @builtins.property
    @jsii.member(jsii_name="deleteInput")
    def delete_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "deleteInput"))

    @builtins.property
    @jsii.member(jsii_name="readInput")
    def read_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "readInput"))

    @builtins.property
    @jsii.member(jsii_name="updateInput")
    def update_input(self) -> typing.Optional[builtins.str]:
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "updateInput"))

    @builtins.property
    @jsii.member(jsii_name="create")
    def create(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "create"))

    @create.setter
    def create(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2ea0c0435ad4f0bbc6334e33680c82d307017baf1d3faa288e184f9b6012b7cb)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "create", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="delete")
    def delete(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "delete"))

    @delete.setter
    def delete(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__97fa4065ed423e575c7441b8d3cd5824905feeaf4af1151d6c8335a357aa6572)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "delete", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="read")
    def read(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "read"))

    @read.setter
    def read(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__62808aa669eed1a514c445c8d9b9dcdc6910194f865509913e8cfc403a1071ed)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "read", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="update")
    def update(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "update"))

    @update.setter
    def update(self, value: builtins.str) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__500c9941017ee642f6d6664026835932d4644c05cfe9f19f28f00529e6bf3f8b)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "update", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="internalValue")
    def internal_value(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, UpdateResourceTimeouts]]:
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, UpdateResourceTimeouts]], jsii.get(self, "internalValue"))

    @internal_value.setter
    def internal_value(
        self,
        value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, UpdateResourceTimeouts]],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2ce912d4ee4c6f42dd550125ccdf206b15eb5503da49fd7c4e1709b5283de27a)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "internalValue", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.VMExtension",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "properties": "properties"},
)
class VMExtension:
    def __init__(
        self,
        *,
        name: builtins.str,
        properties: typing.Optional[typing.Union[_VMExtensionProperties_a1e3e947, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''VM extension.

        :param name: 
        :param properties: 
        '''
        if isinstance(properties, dict):
            properties = _VMExtensionProperties_a1e3e947(**properties)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__976911fa6b440fa7cd43d95335c5f85c6f9261e14e1cce9f48c917411ba9c1c1)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument properties", value=properties, expected_type=type_hints["properties"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if properties is not None:
            self._values["properties"] = properties

    @builtins.property
    def name(self) -> builtins.str:
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def properties(self) -> typing.Optional[_VMExtensionProperties_a1e3e947]:
        result = self._values.get("properties")
        return typing.cast(typing.Optional[_VMExtensionProperties_a1e3e947], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VMExtension(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.VMExtensionProperties",
    jsii_struct_bases=[],
    name_mapping={
        "publisher": "publisher",
        "type": "type",
        "type_handler_version": "typeHandlerVersion",
        "auto_upgrade_minor_version": "autoUpgradeMinorVersion",
        "protected_settings": "protectedSettings",
        "settings": "settings",
    },
)
class VMExtensionProperties:
    def __init__(
        self,
        *,
        publisher: builtins.str,
        type: builtins.str,
        type_handler_version: builtins.str,
        auto_upgrade_minor_version: typing.Optional[builtins.bool] = None,
        protected_settings: typing.Any = None,
        settings: typing.Any = None,
    ) -> None:
        '''Extension properties.

        :param publisher: 
        :param type: 
        :param type_handler_version: 
        :param auto_upgrade_minor_version: 
        :param protected_settings: 
        :param settings: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__73d97dbf61395f5a606d108b452766d13480c62a19108fb4866b15ed4baf7753)
            check_type(argname="argument publisher", value=publisher, expected_type=type_hints["publisher"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument type_handler_version", value=type_handler_version, expected_type=type_hints["type_handler_version"])
            check_type(argname="argument auto_upgrade_minor_version", value=auto_upgrade_minor_version, expected_type=type_hints["auto_upgrade_minor_version"])
            check_type(argname="argument protected_settings", value=protected_settings, expected_type=type_hints["protected_settings"])
            check_type(argname="argument settings", value=settings, expected_type=type_hints["settings"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "publisher": publisher,
            "type": type,
            "type_handler_version": type_handler_version,
        }
        if auto_upgrade_minor_version is not None:
            self._values["auto_upgrade_minor_version"] = auto_upgrade_minor_version
        if protected_settings is not None:
            self._values["protected_settings"] = protected_settings
        if settings is not None:
            self._values["settings"] = settings

    @builtins.property
    def publisher(self) -> builtins.str:
        result = self._values.get("publisher")
        assert result is not None, "Required property 'publisher' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def type(self) -> builtins.str:
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def type_handler_version(self) -> builtins.str:
        result = self._values.get("type_handler_version")
        assert result is not None, "Required property 'type_handler_version' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def auto_upgrade_minor_version(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("auto_upgrade_minor_version")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def protected_settings(self) -> typing.Any:
        result = self._values.get("protected_settings")
        return typing.cast(typing.Any, result)

    @builtins.property
    def settings(self) -> typing.Any:
        result = self._values.get("settings")
        return typing.cast(typing.Any, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VMExtensionProperties(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.ValidationResult",
    jsii_struct_bases=[],
    name_mapping={
        "errors": "errors",
        "valid": "valid",
        "warnings": "warnings",
        "property_errors": "propertyErrors",
    },
)
class ValidationResult:
    def __init__(
        self,
        *,
        errors: typing.Sequence[builtins.str],
        valid: builtins.bool,
        warnings: typing.Sequence[builtins.str],
        property_errors: typing.Optional[typing.Mapping[builtins.str, typing.Sequence[builtins.str]]] = None,
    ) -> None:
        '''Validation result interface.

        Results of validating properties against a schema.
        Provides detailed error and warning information for debugging
        and user feedback.

        :param errors: Array of validation error messages Empty if validation passed.
        :param valid: Whether validation passed If false, the errors array will contain details.
        :param warnings: Array of validation warning messages Non-blocking issues that should be addressed.
        :param property_errors: Property-specific error messages Maps property names to arrays of error messages.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e65d20f8430765c4156f0a11302091f5baf85b0f70db34bdcaf4ed8dc8365404)
            check_type(argname="argument errors", value=errors, expected_type=type_hints["errors"])
            check_type(argname="argument valid", value=valid, expected_type=type_hints["valid"])
            check_type(argname="argument warnings", value=warnings, expected_type=type_hints["warnings"])
            check_type(argname="argument property_errors", value=property_errors, expected_type=type_hints["property_errors"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "errors": errors,
            "valid": valid,
            "warnings": warnings,
        }
        if property_errors is not None:
            self._values["property_errors"] = property_errors

    @builtins.property
    def errors(self) -> typing.List[builtins.str]:
        '''Array of validation error messages Empty if validation passed.'''
        result = self._values.get("errors")
        assert result is not None, "Required property 'errors' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def valid(self) -> builtins.bool:
        '''Whether validation passed If false, the errors array will contain details.'''
        result = self._values.get("valid")
        assert result is not None, "Required property 'valid' is missing"
        return typing.cast(builtins.bool, result)

    @builtins.property
    def warnings(self) -> typing.List[builtins.str]:
        '''Array of validation warning messages Non-blocking issues that should be addressed.'''
        result = self._values.get("warnings")
        assert result is not None, "Required property 'warnings' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def property_errors(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.List[builtins.str]]]:
        '''Property-specific error messages Maps property names to arrays of error messages.'''
        result = self._values.get("property_errors")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.List[builtins.str]]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ValidationResult(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.ValidationRule",
    jsii_struct_bases=[],
    name_mapping={"rule_type": "ruleType", "message": "message", "value": "value"},
)
class ValidationRule:
    def __init__(
        self,
        *,
        rule_type: builtins.str,
        message: typing.Optional[builtins.str] = None,
        value: typing.Any = None,
    ) -> None:
        '''Validation rule definition for property validation.

        Defines a single validation rule that can be applied to a property
        to ensure data integrity and provide user feedback.

        :param rule_type: The type of validation rule to apply Must be one of the ValidationRuleType constants.
        :param message: Custom error message to display when validation fails If not provided, a default message will be generated.
        :param value: The value or parameter for the validation rule Type depends on the validation rule type.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__74fd92c71ed2c1615886631f31c8b508b206e72f93a2b7fd1c30a52a199f0892)
            check_type(argname="argument rule_type", value=rule_type, expected_type=type_hints["rule_type"])
            check_type(argname="argument message", value=message, expected_type=type_hints["message"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "rule_type": rule_type,
        }
        if message is not None:
            self._values["message"] = message
        if value is not None:
            self._values["value"] = value

    @builtins.property
    def rule_type(self) -> builtins.str:
        '''The type of validation rule to apply Must be one of the ValidationRuleType constants.'''
        result = self._values.get("rule_type")
        assert result is not None, "Required property 'rule_type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def message(self) -> typing.Optional[builtins.str]:
        '''Custom error message to display when validation fails If not provided, a default message will be generated.'''
        result = self._values.get("message")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def value(self) -> typing.Any:
        '''The value or parameter for the validation rule Type depends on the validation rule type.

        Example::

            For VALUE_RANGE: { min: 0, max: 100 }
        '''
        result = self._values.get("value")
        return typing.cast(typing.Any, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ValidationRule(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ValidationRuleType(
    metaclass=jsii.JSIIMeta,
    jsii_type="@microsoft/terraform-cdk-constructs.ValidationRuleType",
):
    '''Validation rule types for property validation.

    Defines the types of validation rules that can be applied to properties
    for input validation and data integrity.
    '''

    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.python.classproperty
    @jsii.member(jsii_name="CUSTOM_VALIDATION")
    def CUSTOM_VALIDATION(cls) -> builtins.str:
        '''Custom validation function.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CUSTOM_VALIDATION"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="PATTERN_MATCH")
    def PATTERN_MATCH(cls) -> builtins.str:
        '''Validate property value matches regex pattern.'''
        return typing.cast(builtins.str, jsii.sget(cls, "PATTERN_MATCH"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="REQUIRED")
    def REQUIRED(cls) -> builtins.str:
        '''Property is required and cannot be undefined.'''
        return typing.cast(builtins.str, jsii.sget(cls, "REQUIRED"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="TYPE_CHECK")
    def TYPE_CHECK(cls) -> builtins.str:
        '''Validate property type matches expected type.'''
        return typing.cast(builtins.str, jsii.sget(cls, "TYPE_CHECK"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="VALUE_RANGE")
    def VALUE_RANGE(cls) -> builtins.str:
        '''Validate property value is within specified range.'''
        return typing.cast(builtins.str, jsii.sget(cls, "VALUE_RANGE"))


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.VerificationResult",
    jsii_struct_bases=[],
    name_mapping={
        "message": "message",
        "orphaned_resources": "orphanedResources",
        "success": "success",
        "expected_count": "expectedCount",
        "found_count": "foundCount",
    },
)
class VerificationResult:
    def __init__(
        self,
        *,
        message: builtins.str,
        orphaned_resources: typing.Sequence[builtins.str],
        success: builtins.bool,
        expected_count: typing.Optional[jsii.Number] = None,
        found_count: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Result of resource cleanup verification.

        :param message: Human-readable message describing the result.
        :param orphaned_resources: List of orphaned resource IDs (if any).
        :param success: Whether verification succeeded (all resources deleted).
        :param expected_count: Number of resources expected to be deleted.
        :param found_count: Number of resources actually found.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5a88718c046cb975240b02c9d6085c9511848add6f515337450eaa7bc1aa595b)
            check_type(argname="argument message", value=message, expected_type=type_hints["message"])
            check_type(argname="argument orphaned_resources", value=orphaned_resources, expected_type=type_hints["orphaned_resources"])
            check_type(argname="argument success", value=success, expected_type=type_hints["success"])
            check_type(argname="argument expected_count", value=expected_count, expected_type=type_hints["expected_count"])
            check_type(argname="argument found_count", value=found_count, expected_type=type_hints["found_count"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "message": message,
            "orphaned_resources": orphaned_resources,
            "success": success,
        }
        if expected_count is not None:
            self._values["expected_count"] = expected_count
        if found_count is not None:
            self._values["found_count"] = found_count

    @builtins.property
    def message(self) -> builtins.str:
        '''Human-readable message describing the result.'''
        result = self._values.get("message")
        assert result is not None, "Required property 'message' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def orphaned_resources(self) -> typing.List[builtins.str]:
        '''List of orphaned resource IDs (if any).'''
        result = self._values.get("orphaned_resources")
        assert result is not None, "Required property 'orphaned_resources' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def success(self) -> builtins.bool:
        '''Whether verification succeeded (all resources deleted).'''
        result = self._values.get("success")
        assert result is not None, "Required property 'success' is missing"
        return typing.cast(builtins.bool, result)

    @builtins.property
    def expected_count(self) -> typing.Optional[jsii.Number]:
        '''Number of resources expected to be deleted.'''
        result = self._values.get("expected_count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def found_count(self) -> typing.Optional[jsii.Number]:
        '''Number of resources actually found.'''
        result = self._values.get("found_count")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VerificationResult(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.VersionChangeLog",
    jsii_struct_bases=[],
    name_mapping={
        "change_type": "changeType",
        "description": "description",
        "affected_property": "affectedProperty",
        "breaking": "breaking",
    },
)
class VersionChangeLog:
    def __init__(
        self,
        *,
        change_type: builtins.str,
        description: builtins.str,
        affected_property: typing.Optional[builtins.str] = None,
        breaking: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Version changelog entry.

        Documents changes made in a specific version for transparency
        and to help developers understand version evolution.

        :param change_type: The type of change (added, changed, deprecated, removed, fixed).
        :param description: Brief description of the change.
        :param affected_property: Property or feature affected by the change.
        :param breaking: Whether this change is breaking. Default: false
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b56a9bd32e04dbce9a4e8ec5d6350fb902c7dd6cdab1c292b8f0a593c3227531)
            check_type(argname="argument change_type", value=change_type, expected_type=type_hints["change_type"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument affected_property", value=affected_property, expected_type=type_hints["affected_property"])
            check_type(argname="argument breaking", value=breaking, expected_type=type_hints["breaking"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "change_type": change_type,
            "description": description,
        }
        if affected_property is not None:
            self._values["affected_property"] = affected_property
        if breaking is not None:
            self._values["breaking"] = breaking

    @builtins.property
    def change_type(self) -> builtins.str:
        '''The type of change (added, changed, deprecated, removed, fixed).'''
        result = self._values.get("change_type")
        assert result is not None, "Required property 'change_type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def description(self) -> builtins.str:
        '''Brief description of the change.'''
        result = self._values.get("description")
        assert result is not None, "Required property 'description' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def affected_property(self) -> typing.Optional[builtins.str]:
        '''Property or feature affected by the change.'''
        result = self._values.get("affected_property")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def breaking(self) -> typing.Optional[builtins.bool]:
        '''Whether this change is breaking.

        :default: false
        '''
        result = self._values.get("breaking")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VersionChangeLog(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.VersionConfig",
    jsii_struct_bases=[],
    name_mapping={
        "release_date": "releaseDate",
        "schema": "schema",
        "support_level": "supportLevel",
        "version": "version",
        "breaking_changes": "breakingChanges",
        "change_log": "changeLog",
        "deprecation_date": "deprecationDate",
        "migration_guide": "migrationGuide",
        "sunset_date": "sunsetDate",
    },
)
class VersionConfig:
    def __init__(
        self,
        *,
        release_date: builtins.str,
        schema: typing.Union[_ApiSchema_5ce0490e, typing.Dict[builtins.str, typing.Any]],
        support_level: builtins.str,
        version: builtins.str,
        breaking_changes: typing.Optional[typing.Sequence[typing.Union[_BreakingChange_5dc94c31, typing.Dict[builtins.str, typing.Any]]]] = None,
        change_log: typing.Optional[typing.Sequence[typing.Union[_VersionChangeLog_3bfd366b, typing.Dict[builtins.str, typing.Any]]]] = None,
        deprecation_date: typing.Optional[builtins.str] = None,
        migration_guide: typing.Optional[builtins.str] = None,
        sunset_date: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Version configuration interface.

        Complete configuration for an API version including schema, lifecycle
        information, and migration metadata. This is the primary interface
        for version management and automated tooling.

        :param release_date: Date when this version was released Used for lifecycle management and compatibility analysis.
        :param schema: The complete API schema for this version Defines all properties, validation, and transformation rules.
        :param support_level: Current support level for this version Must be one of the VersionSupportLevel constants.
        :param version: The API version string.
        :param breaking_changes: Array of breaking changes introduced in this version Used for migration analysis and automated tooling.
        :param change_log: Array of changes made in this version Provides transparency and helps with troubleshooting.
        :param deprecation_date: Date when this version was deprecated (if applicable) Indicates when migration planning should begin.
        :param migration_guide: URL or path to detailed migration guide Provides comprehensive migration instructions.
        :param sunset_date: Date when this version will be sunset (if known) Indicates deadline for migration completion.
        '''
        if isinstance(schema, dict):
            schema = _ApiSchema_5ce0490e(**schema)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__189788820aa0902240f9afa632bd5e213fdd9ff8bd2341f60745e78e53a0c91d)
            check_type(argname="argument release_date", value=release_date, expected_type=type_hints["release_date"])
            check_type(argname="argument schema", value=schema, expected_type=type_hints["schema"])
            check_type(argname="argument support_level", value=support_level, expected_type=type_hints["support_level"])
            check_type(argname="argument version", value=version, expected_type=type_hints["version"])
            check_type(argname="argument breaking_changes", value=breaking_changes, expected_type=type_hints["breaking_changes"])
            check_type(argname="argument change_log", value=change_log, expected_type=type_hints["change_log"])
            check_type(argname="argument deprecation_date", value=deprecation_date, expected_type=type_hints["deprecation_date"])
            check_type(argname="argument migration_guide", value=migration_guide, expected_type=type_hints["migration_guide"])
            check_type(argname="argument sunset_date", value=sunset_date, expected_type=type_hints["sunset_date"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "release_date": release_date,
            "schema": schema,
            "support_level": support_level,
            "version": version,
        }
        if breaking_changes is not None:
            self._values["breaking_changes"] = breaking_changes
        if change_log is not None:
            self._values["change_log"] = change_log
        if deprecation_date is not None:
            self._values["deprecation_date"] = deprecation_date
        if migration_guide is not None:
            self._values["migration_guide"] = migration_guide
        if sunset_date is not None:
            self._values["sunset_date"] = sunset_date

    @builtins.property
    def release_date(self) -> builtins.str:
        '''Date when this version was released Used for lifecycle management and compatibility analysis.

        Example::

            "2024-11-01"
        '''
        result = self._values.get("release_date")
        assert result is not None, "Required property 'release_date' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def schema(self) -> _ApiSchema_5ce0490e:
        '''The complete API schema for this version Defines all properties, validation, and transformation rules.'''
        result = self._values.get("schema")
        assert result is not None, "Required property 'schema' is missing"
        return typing.cast(_ApiSchema_5ce0490e, result)

    @builtins.property
    def support_level(self) -> builtins.str:
        '''Current support level for this version Must be one of the VersionSupportLevel constants.'''
        result = self._values.get("support_level")
        assert result is not None, "Required property 'support_level' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def version(self) -> builtins.str:
        '''The API version string.

        Example::

            "2024-11-01"
        '''
        result = self._values.get("version")
        assert result is not None, "Required property 'version' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def breaking_changes(
        self,
    ) -> typing.Optional[typing.List[_BreakingChange_5dc94c31]]:
        '''Array of breaking changes introduced in this version Used for migration analysis and automated tooling.'''
        result = self._values.get("breaking_changes")
        return typing.cast(typing.Optional[typing.List[_BreakingChange_5dc94c31]], result)

    @builtins.property
    def change_log(self) -> typing.Optional[typing.List[_VersionChangeLog_3bfd366b]]:
        '''Array of changes made in this version Provides transparency and helps with troubleshooting.'''
        result = self._values.get("change_log")
        return typing.cast(typing.Optional[typing.List[_VersionChangeLog_3bfd366b]], result)

    @builtins.property
    def deprecation_date(self) -> typing.Optional[builtins.str]:
        '''Date when this version was deprecated (if applicable) Indicates when migration planning should begin.

        Example::

            "2025-11-01"
        '''
        result = self._values.get("deprecation_date")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def migration_guide(self) -> typing.Optional[builtins.str]:
        '''URL or path to detailed migration guide Provides comprehensive migration instructions.

        Example::

            "/docs/migration-guides/v2024-11-01"
        '''
        result = self._values.get("migration_guide")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def sunset_date(self) -> typing.Optional[builtins.str]:
        '''Date when this version will be sunset (if known) Indicates deadline for migration completion.

        Example::

            "2026-11-01"
        '''
        result = self._values.get("sunset_date")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VersionConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.VersionConstraints",
    jsii_struct_bases=[],
    name_mapping={
        "exclude_deprecated": "excludeDeprecated",
        "not_older_than": "notOlderThan",
        "required_features": "requiredFeatures",
        "support_level": "supportLevel",
    },
)
class VersionConstraints:
    def __init__(
        self,
        *,
        exclude_deprecated: typing.Optional[builtins.bool] = None,
        not_older_than: typing.Optional[datetime.datetime] = None,
        required_features: typing.Optional[typing.Sequence[builtins.str]] = None,
        support_level: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Version selection constraints.

        Defines constraints for automatic version selection to help
        choose the most appropriate version based on requirements.

        :param exclude_deprecated: Whether to exclude deprecated versions. Default: true
        :param not_older_than: Minimum release date for version selection Versions older than this date will be excluded.
        :param required_features: Array of required features that the version must support.
        :param support_level: Required support level Must be one of the VersionSupportLevel constants.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2bcebf3be9934a89eabf09669afb151e0510d3510b90c22489549fe756ea9dec)
            check_type(argname="argument exclude_deprecated", value=exclude_deprecated, expected_type=type_hints["exclude_deprecated"])
            check_type(argname="argument not_older_than", value=not_older_than, expected_type=type_hints["not_older_than"])
            check_type(argname="argument required_features", value=required_features, expected_type=type_hints["required_features"])
            check_type(argname="argument support_level", value=support_level, expected_type=type_hints["support_level"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if exclude_deprecated is not None:
            self._values["exclude_deprecated"] = exclude_deprecated
        if not_older_than is not None:
            self._values["not_older_than"] = not_older_than
        if required_features is not None:
            self._values["required_features"] = required_features
        if support_level is not None:
            self._values["support_level"] = support_level

    @builtins.property
    def exclude_deprecated(self) -> typing.Optional[builtins.bool]:
        '''Whether to exclude deprecated versions.

        :default: true
        '''
        result = self._values.get("exclude_deprecated")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def not_older_than(self) -> typing.Optional[datetime.datetime]:
        '''Minimum release date for version selection Versions older than this date will be excluded.'''
        result = self._values.get("not_older_than")
        return typing.cast(typing.Optional[datetime.datetime], result)

    @builtins.property
    def required_features(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Array of required features that the version must support.'''
        result = self._values.get("required_features")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def support_level(self) -> typing.Optional[builtins.str]:
        '''Required support level Must be one of the VersionSupportLevel constants.'''
        result = self._values.get("support_level")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VersionConstraints(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.VersionLifecycle",
    jsii_struct_bases=[],
    name_mapping={
        "phase": "phase",
        "version": "version",
        "estimated_sunset_date": "estimatedSunsetDate",
        "next_phase": "nextPhase",
        "transition_date": "transitionDate",
    },
)
class VersionLifecycle:
    def __init__(
        self,
        *,
        phase: builtins.str,
        version: builtins.str,
        estimated_sunset_date: typing.Optional[builtins.str] = None,
        next_phase: typing.Optional[builtins.str] = None,
        transition_date: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Version lifecycle management.

        Tracks the current phase and transition timeline for an API version
        to enable proactive lifecycle management.

        :param phase: Current lifecycle phase Must be one of the VersionPhase constants.
        :param version: The API version string.
        :param estimated_sunset_date: Estimated date when version will be sunset Used for long-term planning.
        :param next_phase: Next planned phase in the lifecycle Must be one of the VersionPhase constants.
        :param transition_date: Date when the current phase was entered.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c362404295e2dc7aaf0aa2e4f14ad45e2149d98426448c16ef6d42342d88ef0d)
            check_type(argname="argument phase", value=phase, expected_type=type_hints["phase"])
            check_type(argname="argument version", value=version, expected_type=type_hints["version"])
            check_type(argname="argument estimated_sunset_date", value=estimated_sunset_date, expected_type=type_hints["estimated_sunset_date"])
            check_type(argname="argument next_phase", value=next_phase, expected_type=type_hints["next_phase"])
            check_type(argname="argument transition_date", value=transition_date, expected_type=type_hints["transition_date"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "phase": phase,
            "version": version,
        }
        if estimated_sunset_date is not None:
            self._values["estimated_sunset_date"] = estimated_sunset_date
        if next_phase is not None:
            self._values["next_phase"] = next_phase
        if transition_date is not None:
            self._values["transition_date"] = transition_date

    @builtins.property
    def phase(self) -> builtins.str:
        '''Current lifecycle phase Must be one of the VersionPhase constants.'''
        result = self._values.get("phase")
        assert result is not None, "Required property 'phase' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def version(self) -> builtins.str:
        '''The API version string.'''
        result = self._values.get("version")
        assert result is not None, "Required property 'version' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def estimated_sunset_date(self) -> typing.Optional[builtins.str]:
        '''Estimated date when version will be sunset Used for long-term planning.

        Example::

            "2026-11-01"
        '''
        result = self._values.get("estimated_sunset_date")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def next_phase(self) -> typing.Optional[builtins.str]:
        '''Next planned phase in the lifecycle Must be one of the VersionPhase constants.'''
        result = self._values.get("next_phase")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def transition_date(self) -> typing.Optional[builtins.str]:
        '''Date when the current phase was entered.

        Example::

            "2024-11-01"
        '''
        result = self._values.get("transition_date")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VersionLifecycle(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class VersionPhase(
    metaclass=jsii.JSIIMeta,
    jsii_type="@microsoft/terraform-cdk-constructs.VersionPhase",
):
    '''Version lifecycle phases.

    Defines the phases in an API version's lifecycle from initial
    development through sunset.
    '''

    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.python.classproperty
    @jsii.member(jsii_name="ACTIVE")
    def ACTIVE(cls) -> builtins.str:
        '''Active phase - fully supported and recommended.'''
        return typing.cast(builtins.str, jsii.sget(cls, "ACTIVE"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="DEPRECATED")
    def DEPRECATED(cls) -> builtins.str:
        '''Deprecated phase - migration recommended.'''
        return typing.cast(builtins.str, jsii.sget(cls, "DEPRECATED"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="MAINTENANCE")
    def MAINTENANCE(cls) -> builtins.str:
        '''Maintenance phase - bug fixes only.'''
        return typing.cast(builtins.str, jsii.sget(cls, "MAINTENANCE"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="PREVIEW")
    def PREVIEW(cls) -> builtins.str:
        '''Preview/beta phase - not recommended for production.'''
        return typing.cast(builtins.str, jsii.sget(cls, "PREVIEW"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="SUNSET")
    def SUNSET(cls) -> builtins.str:
        '''Sunset phase - no longer supported.'''
        return typing.cast(builtins.str, jsii.sget(cls, "SUNSET"))


class VersionSupportLevel(
    metaclass=jsii.JSIIMeta,
    jsii_type="@microsoft/terraform-cdk-constructs.VersionSupportLevel",
):
    '''Version support level enumeration for API lifecycle management.

    Defines the current support status of an API version to help developers
    understand maintenance commitments and migration planning.
    '''

    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.python.classproperty
    @jsii.member(jsii_name="ACTIVE")
    def ACTIVE(cls) -> builtins.str:
        '''Active support - full feature development and bug fixes Recommended for new development.'''
        return typing.cast(builtins.str, jsii.sget(cls, "ACTIVE"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="DEPRECATED")
    def DEPRECATED(cls) -> builtins.str:
        '''Deprecated - security fixes only, migration recommended Should not be used for new development.'''
        return typing.cast(builtins.str, jsii.sget(cls, "DEPRECATED"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="MAINTENANCE")
    def MAINTENANCE(cls) -> builtins.str:
        '''Maintenance support - critical bug fixes only, no new features Stable for production use but consider migration planning.'''
        return typing.cast(builtins.str, jsii.sget(cls, "MAINTENANCE"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="SUNSET")
    def SUNSET(cls) -> builtins.str:
        '''Sunset - no longer supported, immediate migration required May be removed in future releases.'''
        return typing.cast(builtins.str, jsii.sget(cls, "SUNSET"))


class VirtualMachine(
    _AzapiResource_7e7f5b39,
    metaclass=jsii.JSIIMeta,
    jsii_type="@microsoft/terraform-cdk-constructs.VirtualMachine",
):
    '''Unified Azure Virtual Machine implementation.

    This class provides a single, version-aware implementation that automatically handles version
    resolution, schema validation, and property transformation while maintaining full JSII compliance.

    The class uses the VersionedAzapiResource framework to provide:

    - Automatic latest version resolution (2025-04-01 as of this implementation)
    - Support for explicit version pinning when stability is required
    - Schema-driven property validation and transformation
    - Migration analysis and deprecation warnings
    - Full JSII compliance for multi-language support

    Example::

        // Windows VM with password authentication:
        const windowsVm = new VirtualMachine(this, "windows-vm", {
          name: "my-windows-vm",
          location: "eastus",
          resourceGroupId: resourceGroup.id,
          hardwareProfile: {
            vmSize: "Standard_D2s_v3"
          },
          storageProfile: {
            imageReference: {
              publisher: "MicrosoftWindowsServer",
              offer: "WindowsServer",
              sku: "2022-datacenter-azure-edition",
              version: "latest"
            },
            osDisk: {
              createOption: "FromImage",
              managedDisk: {
                storageAccountType: "Premium_LRS"
              }
            }
          },
          osProfile: {
            computerName: "mywinvm",
            adminUsername: "azureuser",
            adminPassword: "P@ssw0rd1234!",
            windowsConfiguration: {
              provisionVMAgent: true,
              enableAutomaticUpdates: true
            }
          },
          networkProfile: {
            networkInterfaces: [{
              id: networkInterface.id
            }]
          },
          licenseType: "Windows_Server"
        });
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        hardware_profile: typing.Union[_VirtualMachineHardwareProfile_cb34f918, typing.Dict[builtins.str, typing.Any]],
        network_profile: typing.Union[_VirtualMachineNetworkProfile_42959f1d, typing.Dict[builtins.str, typing.Any]],
        storage_profile: typing.Union[_VirtualMachineStorageProfile_793daa4a, typing.Dict[builtins.str, typing.Any]],
        additional_capabilities: typing.Optional[typing.Union[_VirtualMachineAdditionalCapabilities_22a84ae8, typing.Dict[builtins.str, typing.Any]]] = None,
        availability_set: typing.Optional[typing.Union[_VirtualMachineAvailabilitySetReference_639f580a, typing.Dict[builtins.str, typing.Any]]] = None,
        billing_profile: typing.Optional[typing.Union[_VirtualMachineBillingProfile_b57d8936, typing.Dict[builtins.str, typing.Any]]] = None,
        diagnostics_profile: typing.Optional[typing.Union[_VirtualMachineDiagnosticsProfile_05cee027, typing.Dict[builtins.str, typing.Any]]] = None,
        eviction_policy: typing.Optional[builtins.str] = None,
        host: typing.Optional[typing.Union[_VirtualMachineHostReference_f551629f, typing.Dict[builtins.str, typing.Any]]] = None,
        identity: typing.Optional[typing.Union[_VirtualMachineIdentity_dc7decb0, typing.Dict[builtins.str, typing.Any]]] = None,
        ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
        license_type: typing.Optional[builtins.str] = None,
        os_profile: typing.Optional[typing.Union[_VirtualMachineOSProfile_6980e298, typing.Dict[builtins.str, typing.Any]]] = None,
        plan: typing.Optional[typing.Union[_VirtualMachinePlan_2ca6c6de, typing.Dict[builtins.str, typing.Any]]] = None,
        priority: typing.Optional[builtins.str] = None,
        proximity_placement_group: typing.Optional[typing.Union[_VirtualMachineProximityPlacementGroupReference_b821dec8, typing.Dict[builtins.str, typing.Any]]] = None,
        resource_group_id: typing.Optional[builtins.str] = None,
        security_profile: typing.Optional[typing.Union[_VirtualMachineSecurityProfile_59175751, typing.Dict[builtins.str, typing.Any]]] = None,
        virtual_machine_scale_set: typing.Optional[typing.Union[_VirtualMachineScaleSetReference_c6dfc840, typing.Dict[builtins.str, typing.Any]]] = None,
        zones: typing.Optional[typing.Sequence[builtins.str]] = None,
        api_version: typing.Optional[builtins.str] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        location: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> None:
        '''Creates a new Azure Virtual Machine using the VersionedAzapiResource framework.

        The constructor automatically handles version resolution, schema registration,
        validation, and resource creation.

        :param scope: - The scope in which to define this construct.
        :param id: - The unique identifier for this instance.
        :param hardware_profile: The hardware profile for the Virtual Machine (VM size).
        :param network_profile: The network profile for the Virtual Machine Defines network interfaces attached to the VM.
        :param storage_profile: The storage profile for the Virtual Machine Defines the OS disk, data disks, and image reference.
        :param additional_capabilities: Additional capabilities like Ultra SSD.
        :param availability_set: Reference to an availability set.
        :param billing_profile: The billing profile for Spot VMs.
        :param diagnostics_profile: The diagnostics profile for boot diagnostics.
        :param eviction_policy: The eviction policy for Spot VMs.
        :param host: Reference to a dedicated host.
        :param identity: The identity configuration for the Virtual Machine.
        :param ignore_changes: The lifecycle rules to ignore changes Useful for properties that are externally managed or should not trigger updates.
        :param license_type: License type for Windows VMs.
        :param os_profile: The OS profile for the Virtual Machine Defines computer name, admin credentials, and OS-specific configuration.
        :param plan: Plan information for marketplace images.
        :param priority: The priority of the Virtual Machine. Default: "Regular"
        :param proximity_placement_group: Reference to a proximity placement group.
        :param resource_group_id: Resource group ID where the Virtual Machine will be created.
        :param security_profile: Security settings for the Virtual Machine.
        :param virtual_machine_scale_set: Reference to a virtual machine scale set.
        :param zones: Availability zones for the Virtual Machine.
        :param api_version: Explicit API version to use for this resource. If not specified, the latest active version will be automatically resolved. Use this for version pinning when stability is required over latest features. Default: Latest active version from ApiVersionManager
        :param enable_migration_analysis: Whether to enable migration analysis warnings. When true, the framework will analyze the current version for deprecation status and provide migration recommendations in the deployment output. Default: true
        :param enable_transformation: Whether to apply property transformations automatically. When true, properties will be automatically transformed according to the target schema's transformation rules. This enables backward compatibility. Default: true
        :param enable_validation: Whether to validate properties against the schema. When true, all properties will be validated against the API schema before resource creation. Validation errors will cause deployment failures. Default: true
        :param location: The location where the resource should be created. Default: Varies by resource type - see specific resource documentation
        :param monitoring: Monitoring configuration for this resource. Enables integrated monitoring with diagnostic settings, metric alerts, and activity log alerts. All monitoring is optional and disabled by default.
        :param name: The name of the resource.
        :param tags: Tags to apply to the resource.
        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2a8c7ec48ec4c580f86685320413e261bdd956469c30532ce086539fb09726de)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = _VirtualMachineProps_9011059a(
            hardware_profile=hardware_profile,
            network_profile=network_profile,
            storage_profile=storage_profile,
            additional_capabilities=additional_capabilities,
            availability_set=availability_set,
            billing_profile=billing_profile,
            diagnostics_profile=diagnostics_profile,
            eviction_policy=eviction_policy,
            host=host,
            identity=identity,
            ignore_changes=ignore_changes,
            license_type=license_type,
            os_profile=os_profile,
            plan=plan,
            priority=priority,
            proximity_placement_group=proximity_placement_group,
            resource_group_id=resource_group_id,
            security_profile=security_profile,
            virtual_machine_scale_set=virtual_machine_scale_set,
            zones=zones,
            api_version=api_version,
            enable_migration_analysis=enable_migration_analysis,
            enable_transformation=enable_transformation,
            enable_validation=enable_validation,
            location=location,
            monitoring=monitoring,
            name=name,
            tags=tags,
            connection=connection,
            count=count,
            depends_on=depends_on,
            for_each=for_each,
            lifecycle=lifecycle,
            provider=provider,
            provisioners=provisioners,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="defaultMonitoring")
    @builtins.classmethod
    def default_monitoring(
        cls,
        action_group_id: builtins.str,
        workspace_id: typing.Optional[builtins.str] = None,
        *,
        cpu_alert_severity: typing.Optional[jsii.Number] = None,
        cpu_threshold: typing.Optional[jsii.Number] = None,
        disk_queue_alert_severity: typing.Optional[jsii.Number] = None,
        disk_queue_threshold: typing.Optional[jsii.Number] = None,
        enable_cpu_alert: typing.Optional[builtins.bool] = None,
        enable_deletion_alert: typing.Optional[builtins.bool] = None,
        enable_disk_queue_alert: typing.Optional[builtins.bool] = None,
        enable_memory_alert: typing.Optional[builtins.bool] = None,
        memory_alert_severity: typing.Optional[jsii.Number] = None,
        memory_threshold: typing.Optional[jsii.Number] = None,
    ) -> _MonitoringConfig_7c28df74:
        '''Returns a production-ready monitoring configuration for Virtual Machines.

        This static factory method provides a complete MonitoringConfig with sensible defaults
        for VM monitoring including CPU, memory, disk queue alerts, and deletion tracking.

        :param action_group_id: - The resource ID of the action group for alert notifications.
        :param workspace_id: - Optional Log Analytics workspace ID for diagnostic settings.
        :param cpu_alert_severity: 
        :param cpu_threshold: 
        :param disk_queue_alert_severity: 
        :param disk_queue_threshold: 
        :param enable_cpu_alert: 
        :param enable_deletion_alert: 
        :param enable_disk_queue_alert: 
        :param enable_memory_alert: 
        :param memory_alert_severity: 
        :param memory_threshold: 

        :return: A complete MonitoringConfig object ready to use in VirtualMachine props

        Example::

            // Custom thresholds
            const vm = new VirtualMachine(this, "vm", {
              // ... other properties ...
              monitoring: VirtualMachine.defaultMonitoring(
                actionGroup.id,
                workspace.id,
                {
                  cpuThreshold: 90,
                  memoryThreshold: 536870912, // 512MB
                  enableDiskQueueAlert: false
                }
              )
            });
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c4a13f8a02410aa36113d3e2b666a05b8ed4bc1e6d207ea02b65de81685d60b4)
            check_type(argname="argument action_group_id", value=action_group_id, expected_type=type_hints["action_group_id"])
            check_type(argname="argument workspace_id", value=workspace_id, expected_type=type_hints["workspace_id"])
        options = _VirtualMachineMonitoringOptions_083b4c57(
            cpu_alert_severity=cpu_alert_severity,
            cpu_threshold=cpu_threshold,
            disk_queue_alert_severity=disk_queue_alert_severity,
            disk_queue_threshold=disk_queue_threshold,
            enable_cpu_alert=enable_cpu_alert,
            enable_deletion_alert=enable_deletion_alert,
            enable_disk_queue_alert=enable_disk_queue_alert,
            enable_memory_alert=enable_memory_alert,
            memory_alert_severity=memory_alert_severity,
            memory_threshold=memory_threshold,
        )

        return typing.cast(_MonitoringConfig_7c28df74, jsii.sinvoke(cls, "defaultMonitoring", [action_group_id, workspace_id, options]))

    @jsii.member(jsii_name="addTag")
    def add_tag(self, key: builtins.str, value: builtins.str) -> None:
        '''Add a tag to the Virtual Machine Note: This modifies the construct props but requires a new deployment to take effect.

        :param key: -
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d552b7c2f460cd9d250e77f5bcd29916d0cdaf0433be39af9444a30ae0fa3dda)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "addTag", [key, value]))

    @jsii.member(jsii_name="apiSchema")
    def _api_schema(self) -> _ApiSchema_5ce0490e:
        '''Gets the API schema for the resolved version Uses the framework's schema resolution to get the appropriate schema.'''
        return typing.cast(_ApiSchema_5ce0490e, jsii.invoke(self, "apiSchema", []))

    @jsii.member(jsii_name="createResourceBody")
    def _create_resource_body(self, props: typing.Any) -> typing.Any:
        '''Creates the resource body for the Azure API call Transforms the input properties into the JSON format expected by Azure REST API.

        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5b2b92a8952b59c50e3cd7d4f7e035a021faab82078a5bcb97905c3a63092927)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Any, jsii.invoke(self, "createResourceBody", [props]))

    @jsii.member(jsii_name="defaultVersion")
    def _default_version(self) -> builtins.str:
        '''Gets the default API version to use when no explicit version is specified Returns the most recent stable version as the default.'''
        return typing.cast(builtins.str, jsii.invoke(self, "defaultVersion", []))

    @jsii.member(jsii_name="removeTag")
    def remove_tag(self, key: builtins.str) -> None:
        '''Remove a tag from the Virtual Machine Note: This modifies the construct props but requires a new deployment to take effect.

        :param key: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a519b26e2dcadec5007f2a705c9789919e22e6e78909b1e14da041690500883c)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
        return typing.cast(None, jsii.invoke(self, "removeTag", [key]))

    @jsii.member(jsii_name="requiresLocation")
    def _requires_location(self) -> builtins.bool:
        '''Indicates that location is required for Virtual Machines.'''
        return typing.cast(builtins.bool, jsii.invoke(self, "requiresLocation", []))

    @jsii.member(jsii_name="resourceType")
    def _resource_type(self) -> builtins.str:
        '''Gets the Azure resource type for Virtual Machines.'''
        return typing.cast(builtins.str, jsii.invoke(self, "resourceType", []))

    @builtins.property
    @jsii.member(jsii_name="idOutput")
    def id_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "idOutput"))

    @builtins.property
    @jsii.member(jsii_name="locationOutput")
    def location_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "locationOutput"))

    @builtins.property
    @jsii.member(jsii_name="nameOutput")
    def name_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "nameOutput"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def props(self) -> _VirtualMachineProps_9011059a:
        '''The input properties for this Virtual Machine instance.'''
        return typing.cast(_VirtualMachineProps_9011059a, jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        '''Get the provisioning state of the Virtual Machine.'''
        return typing.cast(builtins.str, jsii.get(self, "provisioningState"))

    @builtins.property
    @jsii.member(jsii_name="tagsOutput")
    def tags_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "tagsOutput"))

    @builtins.property
    @jsii.member(jsii_name="vmId")
    def vm_id(self) -> builtins.str:
        '''Get the VM ID (unique identifier assigned by Azure).'''
        return typing.cast(builtins.str, jsii.get(self, "vmId"))

    @builtins.property
    @jsii.member(jsii_name="vmIdOutput")
    def vm_id_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "vmIdOutput"))

    @builtins.property
    @jsii.member(jsii_name="vmSize")
    def vm_size(self) -> builtins.str:
        '''Get the VM size.'''
        return typing.cast(builtins.str, jsii.get(self, "vmSize"))

    @builtins.property
    @jsii.member(jsii_name="computerName")
    def computer_name(self) -> typing.Optional[builtins.str]:
        '''Get the OS profile computer name.'''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "computerName"))


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.VirtualMachineAdditionalCapabilities",
    jsii_struct_bases=[],
    name_mapping={
        "hibernation_enabled": "hibernationEnabled",
        "ultra_ssd_enabled": "ultraSSDEnabled",
    },
)
class VirtualMachineAdditionalCapabilities:
    def __init__(
        self,
        *,
        hibernation_enabled: typing.Optional[builtins.bool] = None,
        ultra_ssd_enabled: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Additional capabilities.

        :param hibernation_enabled: 
        :param ultra_ssd_enabled: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__26adea4125ec451a718e48288e9ee76968a6ed717d6ebe7b73fc875697bdda9a)
            check_type(argname="argument hibernation_enabled", value=hibernation_enabled, expected_type=type_hints["hibernation_enabled"])
            check_type(argname="argument ultra_ssd_enabled", value=ultra_ssd_enabled, expected_type=type_hints["ultra_ssd_enabled"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if hibernation_enabled is not None:
            self._values["hibernation_enabled"] = hibernation_enabled
        if ultra_ssd_enabled is not None:
            self._values["ultra_ssd_enabled"] = ultra_ssd_enabled

    @builtins.property
    def hibernation_enabled(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("hibernation_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def ultra_ssd_enabled(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("ultra_ssd_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VirtualMachineAdditionalCapabilities(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.VirtualMachineAvailabilitySetReference",
    jsii_struct_bases=[],
    name_mapping={"id": "id"},
)
class VirtualMachineAvailabilitySetReference:
    def __init__(self, *, id: typing.Optional[builtins.str] = None) -> None:
        '''Availability set reference.

        :param id: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__16465a013c8c370ce1d88d5e07f5d136b74f25774195406a1774919d43d29e15)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if id is not None:
            self._values["id"] = id

    @builtins.property
    def id(self) -> typing.Optional[builtins.str]:
        result = self._values.get("id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VirtualMachineAvailabilitySetReference(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.VirtualMachineBillingProfile",
    jsii_struct_bases=[],
    name_mapping={"max_price": "maxPrice"},
)
class VirtualMachineBillingProfile:
    def __init__(self, *, max_price: typing.Optional[jsii.Number] = None) -> None:
        '''Billing profile for spot VMs.

        :param max_price: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b677f33cf11acf85506356854befbf59fde682453ea3da7884270ac8c2638e1d)
            check_type(argname="argument max_price", value=max_price, expected_type=type_hints["max_price"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if max_price is not None:
            self._values["max_price"] = max_price

    @builtins.property
    def max_price(self) -> typing.Optional[jsii.Number]:
        result = self._values.get("max_price")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VirtualMachineBillingProfile(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.VirtualMachineBody",
    jsii_struct_bases=[],
    name_mapping={
        "location": "location",
        "properties": "properties",
        "identity": "identity",
        "plan": "plan",
        "tags": "tags",
        "zones": "zones",
    },
)
class VirtualMachineBody:
    def __init__(
        self,
        *,
        location: builtins.str,
        properties: typing.Union[_VirtualMachineBodyProperties_b30829f2, typing.Dict[builtins.str, typing.Any]],
        identity: typing.Optional[typing.Union[_VirtualMachineIdentity_dc7decb0, typing.Dict[builtins.str, typing.Any]]] = None,
        plan: typing.Optional[typing.Union[_VirtualMachinePlan_2ca6c6de, typing.Dict[builtins.str, typing.Any]]] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        zones: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''The resource body interface for Azure Virtual Machine API calls.

        :param location: 
        :param properties: 
        :param identity: 
        :param plan: 
        :param tags: 
        :param zones: 
        '''
        if isinstance(properties, dict):
            properties = _VirtualMachineBodyProperties_b30829f2(**properties)
        if isinstance(identity, dict):
            identity = _VirtualMachineIdentity_dc7decb0(**identity)
        if isinstance(plan, dict):
            plan = _VirtualMachinePlan_2ca6c6de(**plan)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1284f2fc4472af8d852cbb6be0ba4f2ca83aa2cf93b5763efb7e218748ad7ad0)
            check_type(argname="argument location", value=location, expected_type=type_hints["location"])
            check_type(argname="argument properties", value=properties, expected_type=type_hints["properties"])
            check_type(argname="argument identity", value=identity, expected_type=type_hints["identity"])
            check_type(argname="argument plan", value=plan, expected_type=type_hints["plan"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument zones", value=zones, expected_type=type_hints["zones"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "location": location,
            "properties": properties,
        }
        if identity is not None:
            self._values["identity"] = identity
        if plan is not None:
            self._values["plan"] = plan
        if tags is not None:
            self._values["tags"] = tags
        if zones is not None:
            self._values["zones"] = zones

    @builtins.property
    def location(self) -> builtins.str:
        result = self._values.get("location")
        assert result is not None, "Required property 'location' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def properties(self) -> _VirtualMachineBodyProperties_b30829f2:
        result = self._values.get("properties")
        assert result is not None, "Required property 'properties' is missing"
        return typing.cast(_VirtualMachineBodyProperties_b30829f2, result)

    @builtins.property
    def identity(self) -> typing.Optional[_VirtualMachineIdentity_dc7decb0]:
        result = self._values.get("identity")
        return typing.cast(typing.Optional[_VirtualMachineIdentity_dc7decb0], result)

    @builtins.property
    def plan(self) -> typing.Optional[_VirtualMachinePlan_2ca6c6de]:
        result = self._values.get("plan")
        return typing.cast(typing.Optional[_VirtualMachinePlan_2ca6c6de], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def zones(self) -> typing.Optional[typing.List[builtins.str]]:
        result = self._values.get("zones")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VirtualMachineBody(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.VirtualMachineBodyProperties",
    jsii_struct_bases=[],
    name_mapping={
        "hardware_profile": "hardwareProfile",
        "network_profile": "networkProfile",
        "storage_profile": "storageProfile",
        "additional_capabilities": "additionalCapabilities",
        "availability_set": "availabilitySet",
        "billing_profile": "billingProfile",
        "diagnostics_profile": "diagnosticsProfile",
        "eviction_policy": "evictionPolicy",
        "host": "host",
        "license_type": "licenseType",
        "os_profile": "osProfile",
        "priority": "priority",
        "proximity_placement_group": "proximityPlacementGroup",
        "security_profile": "securityProfile",
        "virtual_machine_scale_set": "virtualMachineScaleSet",
    },
)
class VirtualMachineBodyProperties:
    def __init__(
        self,
        *,
        hardware_profile: typing.Union[_VirtualMachineHardwareProfile_cb34f918, typing.Dict[builtins.str, typing.Any]],
        network_profile: typing.Union[_VirtualMachineNetworkProfile_42959f1d, typing.Dict[builtins.str, typing.Any]],
        storage_profile: typing.Union[_VirtualMachineStorageProfile_793daa4a, typing.Dict[builtins.str, typing.Any]],
        additional_capabilities: typing.Optional[typing.Union[_VirtualMachineAdditionalCapabilities_22a84ae8, typing.Dict[builtins.str, typing.Any]]] = None,
        availability_set: typing.Optional[typing.Union[_VirtualMachineAvailabilitySetReference_639f580a, typing.Dict[builtins.str, typing.Any]]] = None,
        billing_profile: typing.Optional[typing.Union[_VirtualMachineBillingProfile_b57d8936, typing.Dict[builtins.str, typing.Any]]] = None,
        diagnostics_profile: typing.Optional[typing.Union[_VirtualMachineDiagnosticsProfile_05cee027, typing.Dict[builtins.str, typing.Any]]] = None,
        eviction_policy: typing.Optional[builtins.str] = None,
        host: typing.Optional[typing.Union[_VirtualMachineHostReference_f551629f, typing.Dict[builtins.str, typing.Any]]] = None,
        license_type: typing.Optional[builtins.str] = None,
        os_profile: typing.Optional[typing.Union[_VirtualMachineOSProfile_6980e298, typing.Dict[builtins.str, typing.Any]]] = None,
        priority: typing.Optional[builtins.str] = None,
        proximity_placement_group: typing.Optional[typing.Union[_VirtualMachineProximityPlacementGroupReference_b821dec8, typing.Dict[builtins.str, typing.Any]]] = None,
        security_profile: typing.Optional[typing.Union[_VirtualMachineSecurityProfile_59175751, typing.Dict[builtins.str, typing.Any]]] = None,
        virtual_machine_scale_set: typing.Optional[typing.Union[_VirtualMachineScaleSetReference_c6dfc840, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Virtual Machine properties for the request body.

        :param hardware_profile: 
        :param network_profile: 
        :param storage_profile: 
        :param additional_capabilities: 
        :param availability_set: 
        :param billing_profile: 
        :param diagnostics_profile: 
        :param eviction_policy: 
        :param host: 
        :param license_type: 
        :param os_profile: 
        :param priority: 
        :param proximity_placement_group: 
        :param security_profile: 
        :param virtual_machine_scale_set: 
        '''
        if isinstance(hardware_profile, dict):
            hardware_profile = _VirtualMachineHardwareProfile_cb34f918(**hardware_profile)
        if isinstance(network_profile, dict):
            network_profile = _VirtualMachineNetworkProfile_42959f1d(**network_profile)
        if isinstance(storage_profile, dict):
            storage_profile = _VirtualMachineStorageProfile_793daa4a(**storage_profile)
        if isinstance(additional_capabilities, dict):
            additional_capabilities = _VirtualMachineAdditionalCapabilities_22a84ae8(**additional_capabilities)
        if isinstance(availability_set, dict):
            availability_set = _VirtualMachineAvailabilitySetReference_639f580a(**availability_set)
        if isinstance(billing_profile, dict):
            billing_profile = _VirtualMachineBillingProfile_b57d8936(**billing_profile)
        if isinstance(diagnostics_profile, dict):
            diagnostics_profile = _VirtualMachineDiagnosticsProfile_05cee027(**diagnostics_profile)
        if isinstance(host, dict):
            host = _VirtualMachineHostReference_f551629f(**host)
        if isinstance(os_profile, dict):
            os_profile = _VirtualMachineOSProfile_6980e298(**os_profile)
        if isinstance(proximity_placement_group, dict):
            proximity_placement_group = _VirtualMachineProximityPlacementGroupReference_b821dec8(**proximity_placement_group)
        if isinstance(security_profile, dict):
            security_profile = _VirtualMachineSecurityProfile_59175751(**security_profile)
        if isinstance(virtual_machine_scale_set, dict):
            virtual_machine_scale_set = _VirtualMachineScaleSetReference_c6dfc840(**virtual_machine_scale_set)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__525da36b7d33e8b5227746a951c2f21a99dbf791a30a47b61fc2a9225b2c88ec)
            check_type(argname="argument hardware_profile", value=hardware_profile, expected_type=type_hints["hardware_profile"])
            check_type(argname="argument network_profile", value=network_profile, expected_type=type_hints["network_profile"])
            check_type(argname="argument storage_profile", value=storage_profile, expected_type=type_hints["storage_profile"])
            check_type(argname="argument additional_capabilities", value=additional_capabilities, expected_type=type_hints["additional_capabilities"])
            check_type(argname="argument availability_set", value=availability_set, expected_type=type_hints["availability_set"])
            check_type(argname="argument billing_profile", value=billing_profile, expected_type=type_hints["billing_profile"])
            check_type(argname="argument diagnostics_profile", value=diagnostics_profile, expected_type=type_hints["diagnostics_profile"])
            check_type(argname="argument eviction_policy", value=eviction_policy, expected_type=type_hints["eviction_policy"])
            check_type(argname="argument host", value=host, expected_type=type_hints["host"])
            check_type(argname="argument license_type", value=license_type, expected_type=type_hints["license_type"])
            check_type(argname="argument os_profile", value=os_profile, expected_type=type_hints["os_profile"])
            check_type(argname="argument priority", value=priority, expected_type=type_hints["priority"])
            check_type(argname="argument proximity_placement_group", value=proximity_placement_group, expected_type=type_hints["proximity_placement_group"])
            check_type(argname="argument security_profile", value=security_profile, expected_type=type_hints["security_profile"])
            check_type(argname="argument virtual_machine_scale_set", value=virtual_machine_scale_set, expected_type=type_hints["virtual_machine_scale_set"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "hardware_profile": hardware_profile,
            "network_profile": network_profile,
            "storage_profile": storage_profile,
        }
        if additional_capabilities is not None:
            self._values["additional_capabilities"] = additional_capabilities
        if availability_set is not None:
            self._values["availability_set"] = availability_set
        if billing_profile is not None:
            self._values["billing_profile"] = billing_profile
        if diagnostics_profile is not None:
            self._values["diagnostics_profile"] = diagnostics_profile
        if eviction_policy is not None:
            self._values["eviction_policy"] = eviction_policy
        if host is not None:
            self._values["host"] = host
        if license_type is not None:
            self._values["license_type"] = license_type
        if os_profile is not None:
            self._values["os_profile"] = os_profile
        if priority is not None:
            self._values["priority"] = priority
        if proximity_placement_group is not None:
            self._values["proximity_placement_group"] = proximity_placement_group
        if security_profile is not None:
            self._values["security_profile"] = security_profile
        if virtual_machine_scale_set is not None:
            self._values["virtual_machine_scale_set"] = virtual_machine_scale_set

    @builtins.property
    def hardware_profile(self) -> _VirtualMachineHardwareProfile_cb34f918:
        result = self._values.get("hardware_profile")
        assert result is not None, "Required property 'hardware_profile' is missing"
        return typing.cast(_VirtualMachineHardwareProfile_cb34f918, result)

    @builtins.property
    def network_profile(self) -> _VirtualMachineNetworkProfile_42959f1d:
        result = self._values.get("network_profile")
        assert result is not None, "Required property 'network_profile' is missing"
        return typing.cast(_VirtualMachineNetworkProfile_42959f1d, result)

    @builtins.property
    def storage_profile(self) -> _VirtualMachineStorageProfile_793daa4a:
        result = self._values.get("storage_profile")
        assert result is not None, "Required property 'storage_profile' is missing"
        return typing.cast(_VirtualMachineStorageProfile_793daa4a, result)

    @builtins.property
    def additional_capabilities(
        self,
    ) -> typing.Optional[_VirtualMachineAdditionalCapabilities_22a84ae8]:
        result = self._values.get("additional_capabilities")
        return typing.cast(typing.Optional[_VirtualMachineAdditionalCapabilities_22a84ae8], result)

    @builtins.property
    def availability_set(
        self,
    ) -> typing.Optional[_VirtualMachineAvailabilitySetReference_639f580a]:
        result = self._values.get("availability_set")
        return typing.cast(typing.Optional[_VirtualMachineAvailabilitySetReference_639f580a], result)

    @builtins.property
    def billing_profile(
        self,
    ) -> typing.Optional[_VirtualMachineBillingProfile_b57d8936]:
        result = self._values.get("billing_profile")
        return typing.cast(typing.Optional[_VirtualMachineBillingProfile_b57d8936], result)

    @builtins.property
    def diagnostics_profile(
        self,
    ) -> typing.Optional[_VirtualMachineDiagnosticsProfile_05cee027]:
        result = self._values.get("diagnostics_profile")
        return typing.cast(typing.Optional[_VirtualMachineDiagnosticsProfile_05cee027], result)

    @builtins.property
    def eviction_policy(self) -> typing.Optional[builtins.str]:
        result = self._values.get("eviction_policy")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def host(self) -> typing.Optional[_VirtualMachineHostReference_f551629f]:
        result = self._values.get("host")
        return typing.cast(typing.Optional[_VirtualMachineHostReference_f551629f], result)

    @builtins.property
    def license_type(self) -> typing.Optional[builtins.str]:
        result = self._values.get("license_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def os_profile(self) -> typing.Optional[_VirtualMachineOSProfile_6980e298]:
        result = self._values.get("os_profile")
        return typing.cast(typing.Optional[_VirtualMachineOSProfile_6980e298], result)

    @builtins.property
    def priority(self) -> typing.Optional[builtins.str]:
        result = self._values.get("priority")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def proximity_placement_group(
        self,
    ) -> typing.Optional[_VirtualMachineProximityPlacementGroupReference_b821dec8]:
        result = self._values.get("proximity_placement_group")
        return typing.cast(typing.Optional[_VirtualMachineProximityPlacementGroupReference_b821dec8], result)

    @builtins.property
    def security_profile(
        self,
    ) -> typing.Optional[_VirtualMachineSecurityProfile_59175751]:
        result = self._values.get("security_profile")
        return typing.cast(typing.Optional[_VirtualMachineSecurityProfile_59175751], result)

    @builtins.property
    def virtual_machine_scale_set(
        self,
    ) -> typing.Optional[_VirtualMachineScaleSetReference_c6dfc840]:
        result = self._values.get("virtual_machine_scale_set")
        return typing.cast(typing.Optional[_VirtualMachineScaleSetReference_c6dfc840], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VirtualMachineBodyProperties(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.VirtualMachineBootDiagnostics",
    jsii_struct_bases=[],
    name_mapping={"enabled": "enabled", "storage_uri": "storageUri"},
)
class VirtualMachineBootDiagnostics:
    def __init__(
        self,
        *,
        enabled: typing.Optional[builtins.bool] = None,
        storage_uri: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Boot diagnostics configuration.

        :param enabled: 
        :param storage_uri: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__953747cd15556d517cddfe8025f0c48d7ad9e5763f1be53358c24335509cb411)
            check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
            check_type(argname="argument storage_uri", value=storage_uri, expected_type=type_hints["storage_uri"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if enabled is not None:
            self._values["enabled"] = enabled
        if storage_uri is not None:
            self._values["storage_uri"] = storage_uri

    @builtins.property
    def enabled(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def storage_uri(self) -> typing.Optional[builtins.str]:
        result = self._values.get("storage_uri")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VirtualMachineBootDiagnostics(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.VirtualMachineDataDisk",
    jsii_struct_bases=[],
    name_mapping={
        "create_option": "createOption",
        "lun": "lun",
        "caching": "caching",
        "disk_size_gb": "diskSizeGB",
        "managed_disk": "managedDisk",
        "name": "name",
    },
)
class VirtualMachineDataDisk:
    def __init__(
        self,
        *,
        create_option: builtins.str,
        lun: jsii.Number,
        caching: typing.Optional[builtins.str] = None,
        disk_size_gb: typing.Optional[jsii.Number] = None,
        managed_disk: typing.Optional[typing.Union[_VirtualMachineManagedDiskParameters_0c76a786, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Data disk configuration.

        :param create_option: 
        :param lun: 
        :param caching: 
        :param disk_size_gb: 
        :param managed_disk: 
        :param name: 
        '''
        if isinstance(managed_disk, dict):
            managed_disk = _VirtualMachineManagedDiskParameters_0c76a786(**managed_disk)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__951c7ad99b7715ad57eaa2f260eeb8f689895869e0084ca7a461748872b14183)
            check_type(argname="argument create_option", value=create_option, expected_type=type_hints["create_option"])
            check_type(argname="argument lun", value=lun, expected_type=type_hints["lun"])
            check_type(argname="argument caching", value=caching, expected_type=type_hints["caching"])
            check_type(argname="argument disk_size_gb", value=disk_size_gb, expected_type=type_hints["disk_size_gb"])
            check_type(argname="argument managed_disk", value=managed_disk, expected_type=type_hints["managed_disk"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "create_option": create_option,
            "lun": lun,
        }
        if caching is not None:
            self._values["caching"] = caching
        if disk_size_gb is not None:
            self._values["disk_size_gb"] = disk_size_gb
        if managed_disk is not None:
            self._values["managed_disk"] = managed_disk
        if name is not None:
            self._values["name"] = name

    @builtins.property
    def create_option(self) -> builtins.str:
        result = self._values.get("create_option")
        assert result is not None, "Required property 'create_option' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def lun(self) -> jsii.Number:
        result = self._values.get("lun")
        assert result is not None, "Required property 'lun' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def caching(self) -> typing.Optional[builtins.str]:
        result = self._values.get("caching")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def disk_size_gb(self) -> typing.Optional[jsii.Number]:
        result = self._values.get("disk_size_gb")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def managed_disk(
        self,
    ) -> typing.Optional[_VirtualMachineManagedDiskParameters_0c76a786]:
        result = self._values.get("managed_disk")
        return typing.cast(typing.Optional[_VirtualMachineManagedDiskParameters_0c76a786], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VirtualMachineDataDisk(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.VirtualMachineDiagnosticsProfile",
    jsii_struct_bases=[],
    name_mapping={"boot_diagnostics": "bootDiagnostics"},
)
class VirtualMachineDiagnosticsProfile:
    def __init__(
        self,
        *,
        boot_diagnostics: typing.Optional[typing.Union[_VirtualMachineBootDiagnostics_51400f7e, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Diagnostics profile.

        :param boot_diagnostics: 
        '''
        if isinstance(boot_diagnostics, dict):
            boot_diagnostics = _VirtualMachineBootDiagnostics_51400f7e(**boot_diagnostics)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__da4169752c2c1e98e6fc9e95cb4b274453833aebf92d16b43991fdb0173327e3)
            check_type(argname="argument boot_diagnostics", value=boot_diagnostics, expected_type=type_hints["boot_diagnostics"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if boot_diagnostics is not None:
            self._values["boot_diagnostics"] = boot_diagnostics

    @builtins.property
    def boot_diagnostics(
        self,
    ) -> typing.Optional[_VirtualMachineBootDiagnostics_51400f7e]:
        result = self._values.get("boot_diagnostics")
        return typing.cast(typing.Optional[_VirtualMachineBootDiagnostics_51400f7e], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VirtualMachineDiagnosticsProfile(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.VirtualMachineDiskEncryptionSetParameters",
    jsii_struct_bases=[],
    name_mapping={"id": "id"},
)
class VirtualMachineDiskEncryptionSetParameters:
    def __init__(self, *, id: typing.Optional[builtins.str] = None) -> None:
        '''Disk encryption set parameters.

        :param id: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__95ecc859635dcb34792f2768641828d034732ac69218eb08e44ec2543a2a7160)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if id is not None:
            self._values["id"] = id

    @builtins.property
    def id(self) -> typing.Optional[builtins.str]:
        result = self._values.get("id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VirtualMachineDiskEncryptionSetParameters(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.VirtualMachineHardwareProfile",
    jsii_struct_bases=[],
    name_mapping={"vm_size": "vmSize"},
)
class VirtualMachineHardwareProfile:
    def __init__(self, *, vm_size: builtins.str) -> None:
        '''Hardware profile for the virtual machine.

        :param vm_size: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__59eab7fd2aa85e829716bd35b8b7d9ec556e972a438fde1d69f55a3815443e71)
            check_type(argname="argument vm_size", value=vm_size, expected_type=type_hints["vm_size"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "vm_size": vm_size,
        }

    @builtins.property
    def vm_size(self) -> builtins.str:
        result = self._values.get("vm_size")
        assert result is not None, "Required property 'vm_size' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VirtualMachineHardwareProfile(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.VirtualMachineHostReference",
    jsii_struct_bases=[],
    name_mapping={"id": "id"},
)
class VirtualMachineHostReference:
    def __init__(self, *, id: typing.Optional[builtins.str] = None) -> None:
        '''Host reference.

        :param id: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__99af5e01959856487fa4929b901e1ad0cab8483e139f972526efcf2452f7a980)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if id is not None:
            self._values["id"] = id

    @builtins.property
    def id(self) -> typing.Optional[builtins.str]:
        result = self._values.get("id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VirtualMachineHostReference(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.VirtualMachineIdentity",
    jsii_struct_bases=[],
    name_mapping={
        "type": "type",
        "user_assigned_identities": "userAssignedIdentities",
    },
)
class VirtualMachineIdentity:
    def __init__(
        self,
        *,
        type: builtins.str,
        user_assigned_identities: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    ) -> None:
        '''Identity configuration for the virtual machine.

        :param type: 
        :param user_assigned_identities: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5b2ecca209d80aec6bc9261a8563ec397215f2eca1ad76b53eda3ed2b67bffd8)
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument user_assigned_identities", value=user_assigned_identities, expected_type=type_hints["user_assigned_identities"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "type": type,
        }
        if user_assigned_identities is not None:
            self._values["user_assigned_identities"] = user_assigned_identities

    @builtins.property
    def type(self) -> builtins.str:
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def user_assigned_identities(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        result = self._values.get("user_assigned_identities")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VirtualMachineIdentity(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.VirtualMachineImageReference",
    jsii_struct_bases=[],
    name_mapping={
        "id": "id",
        "offer": "offer",
        "publisher": "publisher",
        "sku": "sku",
        "version": "version",
    },
)
class VirtualMachineImageReference:
    def __init__(
        self,
        *,
        id: typing.Optional[builtins.str] = None,
        offer: typing.Optional[builtins.str] = None,
        publisher: typing.Optional[builtins.str] = None,
        sku: typing.Optional[builtins.str] = None,
        version: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Image reference for OS disk.

        :param id: 
        :param offer: 
        :param publisher: 
        :param sku: 
        :param version: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d32a2b64a02c22b9421a7b3db44deda6a7a880211d88852f4ad52b9bbd1023f6)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument offer", value=offer, expected_type=type_hints["offer"])
            check_type(argname="argument publisher", value=publisher, expected_type=type_hints["publisher"])
            check_type(argname="argument sku", value=sku, expected_type=type_hints["sku"])
            check_type(argname="argument version", value=version, expected_type=type_hints["version"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if id is not None:
            self._values["id"] = id
        if offer is not None:
            self._values["offer"] = offer
        if publisher is not None:
            self._values["publisher"] = publisher
        if sku is not None:
            self._values["sku"] = sku
        if version is not None:
            self._values["version"] = version

    @builtins.property
    def id(self) -> typing.Optional[builtins.str]:
        result = self._values.get("id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def offer(self) -> typing.Optional[builtins.str]:
        result = self._values.get("offer")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def publisher(self) -> typing.Optional[builtins.str]:
        result = self._values.get("publisher")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def sku(self) -> typing.Optional[builtins.str]:
        result = self._values.get("sku")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def version(self) -> typing.Optional[builtins.str]:
        result = self._values.get("version")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VirtualMachineImageReference(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.VirtualMachineLinuxConfiguration",
    jsii_struct_bases=[],
    name_mapping={
        "disable_password_authentication": "disablePasswordAuthentication",
        "patch_settings": "patchSettings",
        "provision_vm_agent": "provisionVMAgent",
        "ssh": "ssh",
    },
)
class VirtualMachineLinuxConfiguration:
    def __init__(
        self,
        *,
        disable_password_authentication: typing.Optional[builtins.bool] = None,
        patch_settings: typing.Optional[typing.Union[_VirtualMachineLinuxPatchSettings_171efe8f, typing.Dict[builtins.str, typing.Any]]] = None,
        provision_vm_agent: typing.Optional[builtins.bool] = None,
        ssh: typing.Optional[typing.Union[_VirtualMachineSshConfiguration_7da21948, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Linux configuration.

        :param disable_password_authentication: 
        :param patch_settings: 
        :param provision_vm_agent: 
        :param ssh: 
        '''
        if isinstance(patch_settings, dict):
            patch_settings = _VirtualMachineLinuxPatchSettings_171efe8f(**patch_settings)
        if isinstance(ssh, dict):
            ssh = _VirtualMachineSshConfiguration_7da21948(**ssh)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__be86fc92efe31b6f35dbeef3ca3d359887aaf1566cc38155f8cb396f8d93cbb4)
            check_type(argname="argument disable_password_authentication", value=disable_password_authentication, expected_type=type_hints["disable_password_authentication"])
            check_type(argname="argument patch_settings", value=patch_settings, expected_type=type_hints["patch_settings"])
            check_type(argname="argument provision_vm_agent", value=provision_vm_agent, expected_type=type_hints["provision_vm_agent"])
            check_type(argname="argument ssh", value=ssh, expected_type=type_hints["ssh"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if disable_password_authentication is not None:
            self._values["disable_password_authentication"] = disable_password_authentication
        if patch_settings is not None:
            self._values["patch_settings"] = patch_settings
        if provision_vm_agent is not None:
            self._values["provision_vm_agent"] = provision_vm_agent
        if ssh is not None:
            self._values["ssh"] = ssh

    @builtins.property
    def disable_password_authentication(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("disable_password_authentication")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def patch_settings(
        self,
    ) -> typing.Optional[_VirtualMachineLinuxPatchSettings_171efe8f]:
        result = self._values.get("patch_settings")
        return typing.cast(typing.Optional[_VirtualMachineLinuxPatchSettings_171efe8f], result)

    @builtins.property
    def provision_vm_agent(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("provision_vm_agent")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def ssh(self) -> typing.Optional[_VirtualMachineSshConfiguration_7da21948]:
        result = self._values.get("ssh")
        return typing.cast(typing.Optional[_VirtualMachineSshConfiguration_7da21948], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VirtualMachineLinuxConfiguration(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.VirtualMachineLinuxPatchSettings",
    jsii_struct_bases=[],
    name_mapping={"assessment_mode": "assessmentMode", "patch_mode": "patchMode"},
)
class VirtualMachineLinuxPatchSettings:
    def __init__(
        self,
        *,
        assessment_mode: typing.Optional[builtins.str] = None,
        patch_mode: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Linux patch settings.

        :param assessment_mode: 
        :param patch_mode: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1843b7001ff1dab82d7a77070bc2b2b9e3e8839038e185b12757671caad992cd)
            check_type(argname="argument assessment_mode", value=assessment_mode, expected_type=type_hints["assessment_mode"])
            check_type(argname="argument patch_mode", value=patch_mode, expected_type=type_hints["patch_mode"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if assessment_mode is not None:
            self._values["assessment_mode"] = assessment_mode
        if patch_mode is not None:
            self._values["patch_mode"] = patch_mode

    @builtins.property
    def assessment_mode(self) -> typing.Optional[builtins.str]:
        result = self._values.get("assessment_mode")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def patch_mode(self) -> typing.Optional[builtins.str]:
        result = self._values.get("patch_mode")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VirtualMachineLinuxPatchSettings(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.VirtualMachineManagedDiskParameters",
    jsii_struct_bases=[],
    name_mapping={
        "disk_encryption_set": "diskEncryptionSet",
        "id": "id",
        "storage_account_type": "storageAccountType",
    },
)
class VirtualMachineManagedDiskParameters:
    def __init__(
        self,
        *,
        disk_encryption_set: typing.Optional[typing.Union[_VirtualMachineDiskEncryptionSetParameters_804f37ce, typing.Dict[builtins.str, typing.Any]]] = None,
        id: typing.Optional[builtins.str] = None,
        storage_account_type: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Managed disk parameters.

        :param disk_encryption_set: 
        :param id: 
        :param storage_account_type: 
        '''
        if isinstance(disk_encryption_set, dict):
            disk_encryption_set = _VirtualMachineDiskEncryptionSetParameters_804f37ce(**disk_encryption_set)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ce19973e85e5907fee21b00be4ba64aa45b8fbe2497bf3fad067f57f7e73d2de)
            check_type(argname="argument disk_encryption_set", value=disk_encryption_set, expected_type=type_hints["disk_encryption_set"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument storage_account_type", value=storage_account_type, expected_type=type_hints["storage_account_type"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if disk_encryption_set is not None:
            self._values["disk_encryption_set"] = disk_encryption_set
        if id is not None:
            self._values["id"] = id
        if storage_account_type is not None:
            self._values["storage_account_type"] = storage_account_type

    @builtins.property
    def disk_encryption_set(
        self,
    ) -> typing.Optional[_VirtualMachineDiskEncryptionSetParameters_804f37ce]:
        result = self._values.get("disk_encryption_set")
        return typing.cast(typing.Optional[_VirtualMachineDiskEncryptionSetParameters_804f37ce], result)

    @builtins.property
    def id(self) -> typing.Optional[builtins.str]:
        result = self._values.get("id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def storage_account_type(self) -> typing.Optional[builtins.str]:
        result = self._values.get("storage_account_type")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VirtualMachineManagedDiskParameters(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.VirtualMachineMonitoringOptions",
    jsii_struct_bases=[],
    name_mapping={
        "cpu_alert_severity": "cpuAlertSeverity",
        "cpu_threshold": "cpuThreshold",
        "disk_queue_alert_severity": "diskQueueAlertSeverity",
        "disk_queue_threshold": "diskQueueThreshold",
        "enable_cpu_alert": "enableCpuAlert",
        "enable_deletion_alert": "enableDeletionAlert",
        "enable_disk_queue_alert": "enableDiskQueueAlert",
        "enable_memory_alert": "enableMemoryAlert",
        "memory_alert_severity": "memoryAlertSeverity",
        "memory_threshold": "memoryThreshold",
    },
)
class VirtualMachineMonitoringOptions:
    def __init__(
        self,
        *,
        cpu_alert_severity: typing.Optional[jsii.Number] = None,
        cpu_threshold: typing.Optional[jsii.Number] = None,
        disk_queue_alert_severity: typing.Optional[jsii.Number] = None,
        disk_queue_threshold: typing.Optional[jsii.Number] = None,
        enable_cpu_alert: typing.Optional[builtins.bool] = None,
        enable_deletion_alert: typing.Optional[builtins.bool] = None,
        enable_disk_queue_alert: typing.Optional[builtins.bool] = None,
        enable_memory_alert: typing.Optional[builtins.bool] = None,
        memory_alert_severity: typing.Optional[jsii.Number] = None,
        memory_threshold: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Configuration options for Virtual Machine monitoring.

        :param cpu_alert_severity: 
        :param cpu_threshold: 
        :param disk_queue_alert_severity: 
        :param disk_queue_threshold: 
        :param enable_cpu_alert: 
        :param enable_deletion_alert: 
        :param enable_disk_queue_alert: 
        :param enable_memory_alert: 
        :param memory_alert_severity: 
        :param memory_threshold: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__67a8c7fc59da4b92ee2e7102987556299b6894a48f0289303e62a99fe0b2caa4)
            check_type(argname="argument cpu_alert_severity", value=cpu_alert_severity, expected_type=type_hints["cpu_alert_severity"])
            check_type(argname="argument cpu_threshold", value=cpu_threshold, expected_type=type_hints["cpu_threshold"])
            check_type(argname="argument disk_queue_alert_severity", value=disk_queue_alert_severity, expected_type=type_hints["disk_queue_alert_severity"])
            check_type(argname="argument disk_queue_threshold", value=disk_queue_threshold, expected_type=type_hints["disk_queue_threshold"])
            check_type(argname="argument enable_cpu_alert", value=enable_cpu_alert, expected_type=type_hints["enable_cpu_alert"])
            check_type(argname="argument enable_deletion_alert", value=enable_deletion_alert, expected_type=type_hints["enable_deletion_alert"])
            check_type(argname="argument enable_disk_queue_alert", value=enable_disk_queue_alert, expected_type=type_hints["enable_disk_queue_alert"])
            check_type(argname="argument enable_memory_alert", value=enable_memory_alert, expected_type=type_hints["enable_memory_alert"])
            check_type(argname="argument memory_alert_severity", value=memory_alert_severity, expected_type=type_hints["memory_alert_severity"])
            check_type(argname="argument memory_threshold", value=memory_threshold, expected_type=type_hints["memory_threshold"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if cpu_alert_severity is not None:
            self._values["cpu_alert_severity"] = cpu_alert_severity
        if cpu_threshold is not None:
            self._values["cpu_threshold"] = cpu_threshold
        if disk_queue_alert_severity is not None:
            self._values["disk_queue_alert_severity"] = disk_queue_alert_severity
        if disk_queue_threshold is not None:
            self._values["disk_queue_threshold"] = disk_queue_threshold
        if enable_cpu_alert is not None:
            self._values["enable_cpu_alert"] = enable_cpu_alert
        if enable_deletion_alert is not None:
            self._values["enable_deletion_alert"] = enable_deletion_alert
        if enable_disk_queue_alert is not None:
            self._values["enable_disk_queue_alert"] = enable_disk_queue_alert
        if enable_memory_alert is not None:
            self._values["enable_memory_alert"] = enable_memory_alert
        if memory_alert_severity is not None:
            self._values["memory_alert_severity"] = memory_alert_severity
        if memory_threshold is not None:
            self._values["memory_threshold"] = memory_threshold

    @builtins.property
    def cpu_alert_severity(self) -> typing.Optional[jsii.Number]:
        result = self._values.get("cpu_alert_severity")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def cpu_threshold(self) -> typing.Optional[jsii.Number]:
        result = self._values.get("cpu_threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def disk_queue_alert_severity(self) -> typing.Optional[jsii.Number]:
        result = self._values.get("disk_queue_alert_severity")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def disk_queue_threshold(self) -> typing.Optional[jsii.Number]:
        result = self._values.get("disk_queue_threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def enable_cpu_alert(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("enable_cpu_alert")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_deletion_alert(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("enable_deletion_alert")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_disk_queue_alert(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("enable_disk_queue_alert")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_memory_alert(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("enable_memory_alert")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def memory_alert_severity(self) -> typing.Optional[jsii.Number]:
        result = self._values.get("memory_alert_severity")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def memory_threshold(self) -> typing.Optional[jsii.Number]:
        result = self._values.get("memory_threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VirtualMachineMonitoringOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.VirtualMachineNetworkInterfaceProperties",
    jsii_struct_bases=[],
    name_mapping={"primary": "primary"},
)
class VirtualMachineNetworkInterfaceProperties:
    def __init__(self, *, primary: typing.Optional[builtins.bool] = None) -> None:
        '''Network interface properties.

        :param primary: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__acd6aacf643662630b2a25abd973908e33a21c6983b4214d8db9b4d7504d9f84)
            check_type(argname="argument primary", value=primary, expected_type=type_hints["primary"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if primary is not None:
            self._values["primary"] = primary

    @builtins.property
    def primary(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("primary")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VirtualMachineNetworkInterfaceProperties(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.VirtualMachineNetworkInterfaceReference",
    jsii_struct_bases=[],
    name_mapping={"id": "id", "properties": "properties"},
)
class VirtualMachineNetworkInterfaceReference:
    def __init__(
        self,
        *,
        id: builtins.str,
        properties: typing.Optional[typing.Union[_VirtualMachineNetworkInterfaceProperties_d2a4bcfa, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Network interface reference.

        :param id: 
        :param properties: 
        '''
        if isinstance(properties, dict):
            properties = _VirtualMachineNetworkInterfaceProperties_d2a4bcfa(**properties)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c937df4c3e06601e97789dc600226548577f28467ea74b53b317667ed2f3600a)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument properties", value=properties, expected_type=type_hints["properties"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "id": id,
        }
        if properties is not None:
            self._values["properties"] = properties

    @builtins.property
    def id(self) -> builtins.str:
        result = self._values.get("id")
        assert result is not None, "Required property 'id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def properties(
        self,
    ) -> typing.Optional[_VirtualMachineNetworkInterfaceProperties_d2a4bcfa]:
        result = self._values.get("properties")
        return typing.cast(typing.Optional[_VirtualMachineNetworkInterfaceProperties_d2a4bcfa], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VirtualMachineNetworkInterfaceReference(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.VirtualMachineNetworkProfile",
    jsii_struct_bases=[],
    name_mapping={"network_interfaces": "networkInterfaces"},
)
class VirtualMachineNetworkProfile:
    def __init__(
        self,
        *,
        network_interfaces: typing.Sequence[typing.Union[_VirtualMachineNetworkInterfaceReference_67cea400, typing.Dict[builtins.str, typing.Any]]],
    ) -> None:
        '''Network profile for the virtual machine.

        :param network_interfaces: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__144bbceaf31a370710e099c6114f76bec174198900948bf4eba616963a5a21a1)
            check_type(argname="argument network_interfaces", value=network_interfaces, expected_type=type_hints["network_interfaces"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "network_interfaces": network_interfaces,
        }

    @builtins.property
    def network_interfaces(
        self,
    ) -> typing.List[_VirtualMachineNetworkInterfaceReference_67cea400]:
        result = self._values.get("network_interfaces")
        assert result is not None, "Required property 'network_interfaces' is missing"
        return typing.cast(typing.List[_VirtualMachineNetworkInterfaceReference_67cea400], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VirtualMachineNetworkProfile(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.VirtualMachineOSDisk",
    jsii_struct_bases=[],
    name_mapping={
        "create_option": "createOption",
        "caching": "caching",
        "disk_size_gb": "diskSizeGB",
        "managed_disk": "managedDisk",
        "name": "name",
        "os_type": "osType",
    },
)
class VirtualMachineOSDisk:
    def __init__(
        self,
        *,
        create_option: builtins.str,
        caching: typing.Optional[builtins.str] = None,
        disk_size_gb: typing.Optional[jsii.Number] = None,
        managed_disk: typing.Optional[typing.Union[_VirtualMachineManagedDiskParameters_0c76a786, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        os_type: typing.Optional[builtins.str] = None,
    ) -> None:
        '''OS disk configuration.

        :param create_option: 
        :param caching: 
        :param disk_size_gb: 
        :param managed_disk: 
        :param name: 
        :param os_type: 
        '''
        if isinstance(managed_disk, dict):
            managed_disk = _VirtualMachineManagedDiskParameters_0c76a786(**managed_disk)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e24d8ece99591c7f3bf5395bd91f355d99bf1d43f05ce4a5df8da71361d876db)
            check_type(argname="argument create_option", value=create_option, expected_type=type_hints["create_option"])
            check_type(argname="argument caching", value=caching, expected_type=type_hints["caching"])
            check_type(argname="argument disk_size_gb", value=disk_size_gb, expected_type=type_hints["disk_size_gb"])
            check_type(argname="argument managed_disk", value=managed_disk, expected_type=type_hints["managed_disk"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument os_type", value=os_type, expected_type=type_hints["os_type"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "create_option": create_option,
        }
        if caching is not None:
            self._values["caching"] = caching
        if disk_size_gb is not None:
            self._values["disk_size_gb"] = disk_size_gb
        if managed_disk is not None:
            self._values["managed_disk"] = managed_disk
        if name is not None:
            self._values["name"] = name
        if os_type is not None:
            self._values["os_type"] = os_type

    @builtins.property
    def create_option(self) -> builtins.str:
        result = self._values.get("create_option")
        assert result is not None, "Required property 'create_option' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def caching(self) -> typing.Optional[builtins.str]:
        result = self._values.get("caching")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def disk_size_gb(self) -> typing.Optional[jsii.Number]:
        result = self._values.get("disk_size_gb")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def managed_disk(
        self,
    ) -> typing.Optional[_VirtualMachineManagedDiskParameters_0c76a786]:
        result = self._values.get("managed_disk")
        return typing.cast(typing.Optional[_VirtualMachineManagedDiskParameters_0c76a786], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def os_type(self) -> typing.Optional[builtins.str]:
        result = self._values.get("os_type")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VirtualMachineOSDisk(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.VirtualMachineOSProfile",
    jsii_struct_bases=[],
    name_mapping={
        "admin_username": "adminUsername",
        "computer_name": "computerName",
        "admin_password": "adminPassword",
        "allow_extension_operations": "allowExtensionOperations",
        "custom_data": "customData",
        "linux_configuration": "linuxConfiguration",
        "secrets": "secrets",
        "windows_configuration": "windowsConfiguration",
    },
)
class VirtualMachineOSProfile:
    def __init__(
        self,
        *,
        admin_username: builtins.str,
        computer_name: builtins.str,
        admin_password: typing.Optional[builtins.str] = None,
        allow_extension_operations: typing.Optional[builtins.bool] = None,
        custom_data: typing.Optional[builtins.str] = None,
        linux_configuration: typing.Optional[typing.Union[_VirtualMachineLinuxConfiguration_5f791d4c, typing.Dict[builtins.str, typing.Any]]] = None,
        secrets: typing.Optional[typing.Sequence[typing.Union[_VirtualMachineSecret_47d96616, typing.Dict[builtins.str, typing.Any]]]] = None,
        windows_configuration: typing.Optional[typing.Union[_VirtualMachineWindowsConfiguration_31cdebe5, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''OS profile for the virtual machine.

        :param admin_username: 
        :param computer_name: 
        :param admin_password: 
        :param allow_extension_operations: 
        :param custom_data: 
        :param linux_configuration: 
        :param secrets: 
        :param windows_configuration: 
        '''
        if isinstance(linux_configuration, dict):
            linux_configuration = _VirtualMachineLinuxConfiguration_5f791d4c(**linux_configuration)
        if isinstance(windows_configuration, dict):
            windows_configuration = _VirtualMachineWindowsConfiguration_31cdebe5(**windows_configuration)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__349655f3da2830f7da9accb559e7334b21b5d1151ed4b7a9db9d95ed8161f5e0)
            check_type(argname="argument admin_username", value=admin_username, expected_type=type_hints["admin_username"])
            check_type(argname="argument computer_name", value=computer_name, expected_type=type_hints["computer_name"])
            check_type(argname="argument admin_password", value=admin_password, expected_type=type_hints["admin_password"])
            check_type(argname="argument allow_extension_operations", value=allow_extension_operations, expected_type=type_hints["allow_extension_operations"])
            check_type(argname="argument custom_data", value=custom_data, expected_type=type_hints["custom_data"])
            check_type(argname="argument linux_configuration", value=linux_configuration, expected_type=type_hints["linux_configuration"])
            check_type(argname="argument secrets", value=secrets, expected_type=type_hints["secrets"])
            check_type(argname="argument windows_configuration", value=windows_configuration, expected_type=type_hints["windows_configuration"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "admin_username": admin_username,
            "computer_name": computer_name,
        }
        if admin_password is not None:
            self._values["admin_password"] = admin_password
        if allow_extension_operations is not None:
            self._values["allow_extension_operations"] = allow_extension_operations
        if custom_data is not None:
            self._values["custom_data"] = custom_data
        if linux_configuration is not None:
            self._values["linux_configuration"] = linux_configuration
        if secrets is not None:
            self._values["secrets"] = secrets
        if windows_configuration is not None:
            self._values["windows_configuration"] = windows_configuration

    @builtins.property
    def admin_username(self) -> builtins.str:
        result = self._values.get("admin_username")
        assert result is not None, "Required property 'admin_username' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def computer_name(self) -> builtins.str:
        result = self._values.get("computer_name")
        assert result is not None, "Required property 'computer_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def admin_password(self) -> typing.Optional[builtins.str]:
        result = self._values.get("admin_password")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def allow_extension_operations(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("allow_extension_operations")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def custom_data(self) -> typing.Optional[builtins.str]:
        result = self._values.get("custom_data")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def linux_configuration(
        self,
    ) -> typing.Optional[_VirtualMachineLinuxConfiguration_5f791d4c]:
        result = self._values.get("linux_configuration")
        return typing.cast(typing.Optional[_VirtualMachineLinuxConfiguration_5f791d4c], result)

    @builtins.property
    def secrets(self) -> typing.Optional[typing.List[_VirtualMachineSecret_47d96616]]:
        result = self._values.get("secrets")
        return typing.cast(typing.Optional[typing.List[_VirtualMachineSecret_47d96616]], result)

    @builtins.property
    def windows_configuration(
        self,
    ) -> typing.Optional[_VirtualMachineWindowsConfiguration_31cdebe5]:
        result = self._values.get("windows_configuration")
        return typing.cast(typing.Optional[_VirtualMachineWindowsConfiguration_31cdebe5], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VirtualMachineOSProfile(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.VirtualMachinePlan",
    jsii_struct_bases=[],
    name_mapping={
        "name": "name",
        "product": "product",
        "promotion_code": "promotionCode",
        "publisher": "publisher",
    },
)
class VirtualMachinePlan:
    def __init__(
        self,
        *,
        name: typing.Optional[builtins.str] = None,
        product: typing.Optional[builtins.str] = None,
        promotion_code: typing.Optional[builtins.str] = None,
        publisher: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Plan information for marketplace images.

        :param name: 
        :param product: 
        :param promotion_code: 
        :param publisher: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__35630fe41fd120fe35b4c0db61a9d05beb2e9b54a5cce9ca3e98f7f52806712b)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument product", value=product, expected_type=type_hints["product"])
            check_type(argname="argument promotion_code", value=promotion_code, expected_type=type_hints["promotion_code"])
            check_type(argname="argument publisher", value=publisher, expected_type=type_hints["publisher"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if name is not None:
            self._values["name"] = name
        if product is not None:
            self._values["product"] = product
        if promotion_code is not None:
            self._values["promotion_code"] = promotion_code
        if publisher is not None:
            self._values["publisher"] = publisher

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def product(self) -> typing.Optional[builtins.str]:
        result = self._values.get("product")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def promotion_code(self) -> typing.Optional[builtins.str]:
        result = self._values.get("promotion_code")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def publisher(self) -> typing.Optional[builtins.str]:
        result = self._values.get("publisher")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VirtualMachinePlan(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.VirtualMachinePriorityProfile",
    jsii_struct_bases=[],
    name_mapping={
        "billing_profile": "billingProfile",
        "eviction_policy": "evictionPolicy",
        "priority": "priority",
    },
)
class VirtualMachinePriorityProfile:
    def __init__(
        self,
        *,
        billing_profile: typing.Optional[typing.Union[_VirtualMachineBillingProfile_b57d8936, typing.Dict[builtins.str, typing.Any]]] = None,
        eviction_policy: typing.Optional[builtins.str] = None,
        priority: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Priority and eviction policy for spot VMs.

        :param billing_profile: 
        :param eviction_policy: 
        :param priority: 
        '''
        if isinstance(billing_profile, dict):
            billing_profile = _VirtualMachineBillingProfile_b57d8936(**billing_profile)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6d46795c7b225d47751b88466c07ce694a17f10bd5f0a02cce28e95a6f5b7d2e)
            check_type(argname="argument billing_profile", value=billing_profile, expected_type=type_hints["billing_profile"])
            check_type(argname="argument eviction_policy", value=eviction_policy, expected_type=type_hints["eviction_policy"])
            check_type(argname="argument priority", value=priority, expected_type=type_hints["priority"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if billing_profile is not None:
            self._values["billing_profile"] = billing_profile
        if eviction_policy is not None:
            self._values["eviction_policy"] = eviction_policy
        if priority is not None:
            self._values["priority"] = priority

    @builtins.property
    def billing_profile(
        self,
    ) -> typing.Optional[_VirtualMachineBillingProfile_b57d8936]:
        result = self._values.get("billing_profile")
        return typing.cast(typing.Optional[_VirtualMachineBillingProfile_b57d8936], result)

    @builtins.property
    def eviction_policy(self) -> typing.Optional[builtins.str]:
        result = self._values.get("eviction_policy")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def priority(self) -> typing.Optional[builtins.str]:
        result = self._values.get("priority")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VirtualMachinePriorityProfile(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.VirtualMachineProps",
    jsii_struct_bases=[_AzapiResourceProps_141a2340],
    name_mapping={
        "connection": "connection",
        "count": "count",
        "depends_on": "dependsOn",
        "for_each": "forEach",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "provisioners": "provisioners",
        "api_version": "apiVersion",
        "enable_migration_analysis": "enableMigrationAnalysis",
        "enable_transformation": "enableTransformation",
        "enable_validation": "enableValidation",
        "location": "location",
        "monitoring": "monitoring",
        "name": "name",
        "tags": "tags",
        "hardware_profile": "hardwareProfile",
        "network_profile": "networkProfile",
        "storage_profile": "storageProfile",
        "additional_capabilities": "additionalCapabilities",
        "availability_set": "availabilitySet",
        "billing_profile": "billingProfile",
        "diagnostics_profile": "diagnosticsProfile",
        "eviction_policy": "evictionPolicy",
        "host": "host",
        "identity": "identity",
        "ignore_changes": "ignoreChanges",
        "license_type": "licenseType",
        "os_profile": "osProfile",
        "plan": "plan",
        "priority": "priority",
        "proximity_placement_group": "proximityPlacementGroup",
        "resource_group_id": "resourceGroupId",
        "security_profile": "securityProfile",
        "virtual_machine_scale_set": "virtualMachineScaleSet",
        "zones": "zones",
    },
)
class VirtualMachineProps(_AzapiResourceProps_141a2340):
    def __init__(
        self,
        *,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
        api_version: typing.Optional[builtins.str] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        location: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        hardware_profile: typing.Union[_VirtualMachineHardwareProfile_cb34f918, typing.Dict[builtins.str, typing.Any]],
        network_profile: typing.Union[_VirtualMachineNetworkProfile_42959f1d, typing.Dict[builtins.str, typing.Any]],
        storage_profile: typing.Union[_VirtualMachineStorageProfile_793daa4a, typing.Dict[builtins.str, typing.Any]],
        additional_capabilities: typing.Optional[typing.Union[_VirtualMachineAdditionalCapabilities_22a84ae8, typing.Dict[builtins.str, typing.Any]]] = None,
        availability_set: typing.Optional[typing.Union[_VirtualMachineAvailabilitySetReference_639f580a, typing.Dict[builtins.str, typing.Any]]] = None,
        billing_profile: typing.Optional[typing.Union[_VirtualMachineBillingProfile_b57d8936, typing.Dict[builtins.str, typing.Any]]] = None,
        diagnostics_profile: typing.Optional[typing.Union[_VirtualMachineDiagnosticsProfile_05cee027, typing.Dict[builtins.str, typing.Any]]] = None,
        eviction_policy: typing.Optional[builtins.str] = None,
        host: typing.Optional[typing.Union[_VirtualMachineHostReference_f551629f, typing.Dict[builtins.str, typing.Any]]] = None,
        identity: typing.Optional[typing.Union[_VirtualMachineIdentity_dc7decb0, typing.Dict[builtins.str, typing.Any]]] = None,
        ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
        license_type: typing.Optional[builtins.str] = None,
        os_profile: typing.Optional[typing.Union[_VirtualMachineOSProfile_6980e298, typing.Dict[builtins.str, typing.Any]]] = None,
        plan: typing.Optional[typing.Union[_VirtualMachinePlan_2ca6c6de, typing.Dict[builtins.str, typing.Any]]] = None,
        priority: typing.Optional[builtins.str] = None,
        proximity_placement_group: typing.Optional[typing.Union[_VirtualMachineProximityPlacementGroupReference_b821dec8, typing.Dict[builtins.str, typing.Any]]] = None,
        resource_group_id: typing.Optional[builtins.str] = None,
        security_profile: typing.Optional[typing.Union[_VirtualMachineSecurityProfile_59175751, typing.Dict[builtins.str, typing.Any]]] = None,
        virtual_machine_scale_set: typing.Optional[typing.Union[_VirtualMachineScaleSetReference_c6dfc840, typing.Dict[builtins.str, typing.Any]]] = None,
        zones: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''Properties for the unified Azure Virtual Machine.

        Extends AzapiResourceProps with Virtual Machine specific properties

        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        :param api_version: Explicit API version to use for this resource. If not specified, the latest active version will be automatically resolved. Use this for version pinning when stability is required over latest features. Default: Latest active version from ApiVersionManager
        :param enable_migration_analysis: Whether to enable migration analysis warnings. When true, the framework will analyze the current version for deprecation status and provide migration recommendations in the deployment output. Default: true
        :param enable_transformation: Whether to apply property transformations automatically. When true, properties will be automatically transformed according to the target schema's transformation rules. This enables backward compatibility. Default: true
        :param enable_validation: Whether to validate properties against the schema. When true, all properties will be validated against the API schema before resource creation. Validation errors will cause deployment failures. Default: true
        :param location: The location where the resource should be created. Default: Varies by resource type - see specific resource documentation
        :param monitoring: Monitoring configuration for this resource. Enables integrated monitoring with diagnostic settings, metric alerts, and activity log alerts. All monitoring is optional and disabled by default.
        :param name: The name of the resource.
        :param tags: Tags to apply to the resource.
        :param hardware_profile: The hardware profile for the Virtual Machine (VM size).
        :param network_profile: The network profile for the Virtual Machine Defines network interfaces attached to the VM.
        :param storage_profile: The storage profile for the Virtual Machine Defines the OS disk, data disks, and image reference.
        :param additional_capabilities: Additional capabilities like Ultra SSD.
        :param availability_set: Reference to an availability set.
        :param billing_profile: The billing profile for Spot VMs.
        :param diagnostics_profile: The diagnostics profile for boot diagnostics.
        :param eviction_policy: The eviction policy for Spot VMs.
        :param host: Reference to a dedicated host.
        :param identity: The identity configuration for the Virtual Machine.
        :param ignore_changes: The lifecycle rules to ignore changes Useful for properties that are externally managed or should not trigger updates.
        :param license_type: License type for Windows VMs.
        :param os_profile: The OS profile for the Virtual Machine Defines computer name, admin credentials, and OS-specific configuration.
        :param plan: Plan information for marketplace images.
        :param priority: The priority of the Virtual Machine. Default: "Regular"
        :param proximity_placement_group: Reference to a proximity placement group.
        :param resource_group_id: Resource group ID where the Virtual Machine will be created.
        :param security_profile: Security settings for the Virtual Machine.
        :param virtual_machine_scale_set: Reference to a virtual machine scale set.
        :param zones: Availability zones for the Virtual Machine.
        '''
        if isinstance(lifecycle, dict):
            lifecycle = _cdktf_9a9027ec.TerraformResourceLifecycle(**lifecycle)
        if isinstance(monitoring, dict):
            monitoring = _MonitoringConfig_7c28df74(**monitoring)
        if isinstance(hardware_profile, dict):
            hardware_profile = _VirtualMachineHardwareProfile_cb34f918(**hardware_profile)
        if isinstance(network_profile, dict):
            network_profile = _VirtualMachineNetworkProfile_42959f1d(**network_profile)
        if isinstance(storage_profile, dict):
            storage_profile = _VirtualMachineStorageProfile_793daa4a(**storage_profile)
        if isinstance(additional_capabilities, dict):
            additional_capabilities = _VirtualMachineAdditionalCapabilities_22a84ae8(**additional_capabilities)
        if isinstance(availability_set, dict):
            availability_set = _VirtualMachineAvailabilitySetReference_639f580a(**availability_set)
        if isinstance(billing_profile, dict):
            billing_profile = _VirtualMachineBillingProfile_b57d8936(**billing_profile)
        if isinstance(diagnostics_profile, dict):
            diagnostics_profile = _VirtualMachineDiagnosticsProfile_05cee027(**diagnostics_profile)
        if isinstance(host, dict):
            host = _VirtualMachineHostReference_f551629f(**host)
        if isinstance(identity, dict):
            identity = _VirtualMachineIdentity_dc7decb0(**identity)
        if isinstance(os_profile, dict):
            os_profile = _VirtualMachineOSProfile_6980e298(**os_profile)
        if isinstance(plan, dict):
            plan = _VirtualMachinePlan_2ca6c6de(**plan)
        if isinstance(proximity_placement_group, dict):
            proximity_placement_group = _VirtualMachineProximityPlacementGroupReference_b821dec8(**proximity_placement_group)
        if isinstance(security_profile, dict):
            security_profile = _VirtualMachineSecurityProfile_59175751(**security_profile)
        if isinstance(virtual_machine_scale_set, dict):
            virtual_machine_scale_set = _VirtualMachineScaleSetReference_c6dfc840(**virtual_machine_scale_set)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__34a7c945f01f3ffeb4fe733b91c2faa1a06a4e4cadd1e4d5c147770c5ad1e400)
            check_type(argname="argument connection", value=connection, expected_type=type_hints["connection"])
            check_type(argname="argument count", value=count, expected_type=type_hints["count"])
            check_type(argname="argument depends_on", value=depends_on, expected_type=type_hints["depends_on"])
            check_type(argname="argument for_each", value=for_each, expected_type=type_hints["for_each"])
            check_type(argname="argument lifecycle", value=lifecycle, expected_type=type_hints["lifecycle"])
            check_type(argname="argument provider", value=provider, expected_type=type_hints["provider"])
            check_type(argname="argument provisioners", value=provisioners, expected_type=type_hints["provisioners"])
            check_type(argname="argument api_version", value=api_version, expected_type=type_hints["api_version"])
            check_type(argname="argument enable_migration_analysis", value=enable_migration_analysis, expected_type=type_hints["enable_migration_analysis"])
            check_type(argname="argument enable_transformation", value=enable_transformation, expected_type=type_hints["enable_transformation"])
            check_type(argname="argument enable_validation", value=enable_validation, expected_type=type_hints["enable_validation"])
            check_type(argname="argument location", value=location, expected_type=type_hints["location"])
            check_type(argname="argument monitoring", value=monitoring, expected_type=type_hints["monitoring"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument hardware_profile", value=hardware_profile, expected_type=type_hints["hardware_profile"])
            check_type(argname="argument network_profile", value=network_profile, expected_type=type_hints["network_profile"])
            check_type(argname="argument storage_profile", value=storage_profile, expected_type=type_hints["storage_profile"])
            check_type(argname="argument additional_capabilities", value=additional_capabilities, expected_type=type_hints["additional_capabilities"])
            check_type(argname="argument availability_set", value=availability_set, expected_type=type_hints["availability_set"])
            check_type(argname="argument billing_profile", value=billing_profile, expected_type=type_hints["billing_profile"])
            check_type(argname="argument diagnostics_profile", value=diagnostics_profile, expected_type=type_hints["diagnostics_profile"])
            check_type(argname="argument eviction_policy", value=eviction_policy, expected_type=type_hints["eviction_policy"])
            check_type(argname="argument host", value=host, expected_type=type_hints["host"])
            check_type(argname="argument identity", value=identity, expected_type=type_hints["identity"])
            check_type(argname="argument ignore_changes", value=ignore_changes, expected_type=type_hints["ignore_changes"])
            check_type(argname="argument license_type", value=license_type, expected_type=type_hints["license_type"])
            check_type(argname="argument os_profile", value=os_profile, expected_type=type_hints["os_profile"])
            check_type(argname="argument plan", value=plan, expected_type=type_hints["plan"])
            check_type(argname="argument priority", value=priority, expected_type=type_hints["priority"])
            check_type(argname="argument proximity_placement_group", value=proximity_placement_group, expected_type=type_hints["proximity_placement_group"])
            check_type(argname="argument resource_group_id", value=resource_group_id, expected_type=type_hints["resource_group_id"])
            check_type(argname="argument security_profile", value=security_profile, expected_type=type_hints["security_profile"])
            check_type(argname="argument virtual_machine_scale_set", value=virtual_machine_scale_set, expected_type=type_hints["virtual_machine_scale_set"])
            check_type(argname="argument zones", value=zones, expected_type=type_hints["zones"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "hardware_profile": hardware_profile,
            "network_profile": network_profile,
            "storage_profile": storage_profile,
        }
        if connection is not None:
            self._values["connection"] = connection
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if for_each is not None:
            self._values["for_each"] = for_each
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider
        if provisioners is not None:
            self._values["provisioners"] = provisioners
        if api_version is not None:
            self._values["api_version"] = api_version
        if enable_migration_analysis is not None:
            self._values["enable_migration_analysis"] = enable_migration_analysis
        if enable_transformation is not None:
            self._values["enable_transformation"] = enable_transformation
        if enable_validation is not None:
            self._values["enable_validation"] = enable_validation
        if location is not None:
            self._values["location"] = location
        if monitoring is not None:
            self._values["monitoring"] = monitoring
        if name is not None:
            self._values["name"] = name
        if tags is not None:
            self._values["tags"] = tags
        if additional_capabilities is not None:
            self._values["additional_capabilities"] = additional_capabilities
        if availability_set is not None:
            self._values["availability_set"] = availability_set
        if billing_profile is not None:
            self._values["billing_profile"] = billing_profile
        if diagnostics_profile is not None:
            self._values["diagnostics_profile"] = diagnostics_profile
        if eviction_policy is not None:
            self._values["eviction_policy"] = eviction_policy
        if host is not None:
            self._values["host"] = host
        if identity is not None:
            self._values["identity"] = identity
        if ignore_changes is not None:
            self._values["ignore_changes"] = ignore_changes
        if license_type is not None:
            self._values["license_type"] = license_type
        if os_profile is not None:
            self._values["os_profile"] = os_profile
        if plan is not None:
            self._values["plan"] = plan
        if priority is not None:
            self._values["priority"] = priority
        if proximity_placement_group is not None:
            self._values["proximity_placement_group"] = proximity_placement_group
        if resource_group_id is not None:
            self._values["resource_group_id"] = resource_group_id
        if security_profile is not None:
            self._values["security_profile"] = security_profile
        if virtual_machine_scale_set is not None:
            self._values["virtual_machine_scale_set"] = virtual_machine_scale_set
        if zones is not None:
            self._values["zones"] = zones

    @builtins.property
    def connection(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("connection")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]], result)

    @builtins.property
    def count(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]], result)

    @builtins.property
    def depends_on(
        self,
    ) -> typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]], result)

    @builtins.property
    def for_each(self) -> typing.Optional[_cdktf_9a9027ec.ITerraformIterator]:
        '''
        :stability: experimental
        '''
        result = self._values.get("for_each")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.ITerraformIterator], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[_cdktf_9a9027ec.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformProvider], result)

    @builtins.property
    def provisioners(
        self,
    ) -> typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provisioners")
        return typing.cast(typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]], result)

    @builtins.property
    def api_version(self) -> typing.Optional[builtins.str]:
        '''Explicit API version to use for this resource.

        If not specified, the latest active version will be automatically resolved.
        Use this for version pinning when stability is required over latest features.

        :default: Latest active version from ApiVersionManager

        Example::

            "2024-11-01"
        '''
        result = self._values.get("api_version")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def enable_migration_analysis(self) -> typing.Optional[builtins.bool]:
        '''Whether to enable migration analysis warnings.

        When true, the framework will analyze the current version for deprecation
        status and provide migration recommendations in the deployment output.

        :default: true
        '''
        result = self._values.get("enable_migration_analysis")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_transformation(self) -> typing.Optional[builtins.bool]:
        '''Whether to apply property transformations automatically.

        When true, properties will be automatically transformed according to the
        target schema's transformation rules. This enables backward compatibility.

        :default: true
        '''
        result = self._values.get("enable_transformation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_validation(self) -> typing.Optional[builtins.bool]:
        '''Whether to validate properties against the schema.

        When true, all properties will be validated against the API schema before
        resource creation. Validation errors will cause deployment failures.

        :default: true
        '''
        result = self._values.get("enable_validation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def location(self) -> typing.Optional[builtins.str]:
        '''The location where the resource should be created.

        :default: Varies by resource type - see specific resource documentation

        :remarks:

        Location handling varies by resource type:

        - **Top-level resources**: Most require an explicit location (e.g., "eastus", "westus")
        - **Global resources**: Some use "global" as location (e.g., Private DNS Zones)
        - **Child resources**: Inherit location from parent and should NOT set this property

        Each resource type may provide its own default through the ``resolveLocation()`` method.
        If no location is specified and no default exists, resource creation may fail.

        Example::

            // Child resource (Subnet) - do not set location
            // location: undefined (inherited from parent Virtual Network)
        '''
        result = self._values.get("location")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def monitoring(self) -> typing.Optional[_MonitoringConfig_7c28df74]:
        '''Monitoring configuration for this resource.

        Enables integrated monitoring with diagnostic settings, metric alerts,
        and activity log alerts. All monitoring is optional and disabled by default.

        Example::

            monitoring: {
              enabled: true,
              diagnosticSettings: {
                workspaceId: logAnalytics.id,
                metrics: ['AllMetrics'],
                logs: ['AuditLogs']
              },
              metricAlerts: [{
                name: 'high-cpu-alert',
                severity: 2,
                scopes: [], // Automatically set to this resource
                criteria: { ... },
                actions: [{ actionGroupId: actionGroup.id }]
              }]
            }
        '''
        result = self._values.get("monitoring")
        return typing.cast(typing.Optional[_MonitoringConfig_7c28df74], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the resource.'''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Tags to apply to the resource.'''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def hardware_profile(self) -> _VirtualMachineHardwareProfile_cb34f918:
        '''The hardware profile for the Virtual Machine (VM size).

        Example::

            { vmSize: "Standard_D2s_v3" }
        '''
        result = self._values.get("hardware_profile")
        assert result is not None, "Required property 'hardware_profile' is missing"
        return typing.cast(_VirtualMachineHardwareProfile_cb34f918, result)

    @builtins.property
    def network_profile(self) -> _VirtualMachineNetworkProfile_42959f1d:
        '''The network profile for the Virtual Machine Defines network interfaces attached to the VM.'''
        result = self._values.get("network_profile")
        assert result is not None, "Required property 'network_profile' is missing"
        return typing.cast(_VirtualMachineNetworkProfile_42959f1d, result)

    @builtins.property
    def storage_profile(self) -> _VirtualMachineStorageProfile_793daa4a:
        '''The storage profile for the Virtual Machine Defines the OS disk, data disks, and image reference.'''
        result = self._values.get("storage_profile")
        assert result is not None, "Required property 'storage_profile' is missing"
        return typing.cast(_VirtualMachineStorageProfile_793daa4a, result)

    @builtins.property
    def additional_capabilities(
        self,
    ) -> typing.Optional[_VirtualMachineAdditionalCapabilities_22a84ae8]:
        '''Additional capabilities like Ultra SSD.'''
        result = self._values.get("additional_capabilities")
        return typing.cast(typing.Optional[_VirtualMachineAdditionalCapabilities_22a84ae8], result)

    @builtins.property
    def availability_set(
        self,
    ) -> typing.Optional[_VirtualMachineAvailabilitySetReference_639f580a]:
        '''Reference to an availability set.'''
        result = self._values.get("availability_set")
        return typing.cast(typing.Optional[_VirtualMachineAvailabilitySetReference_639f580a], result)

    @builtins.property
    def billing_profile(
        self,
    ) -> typing.Optional[_VirtualMachineBillingProfile_b57d8936]:
        '''The billing profile for Spot VMs.'''
        result = self._values.get("billing_profile")
        return typing.cast(typing.Optional[_VirtualMachineBillingProfile_b57d8936], result)

    @builtins.property
    def diagnostics_profile(
        self,
    ) -> typing.Optional[_VirtualMachineDiagnosticsProfile_05cee027]:
        '''The diagnostics profile for boot diagnostics.'''
        result = self._values.get("diagnostics_profile")
        return typing.cast(typing.Optional[_VirtualMachineDiagnosticsProfile_05cee027], result)

    @builtins.property
    def eviction_policy(self) -> typing.Optional[builtins.str]:
        '''The eviction policy for Spot VMs.

        Example::

            "Deallocate", "Delete"
        '''
        result = self._values.get("eviction_policy")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def host(self) -> typing.Optional[_VirtualMachineHostReference_f551629f]:
        '''Reference to a dedicated host.'''
        result = self._values.get("host")
        return typing.cast(typing.Optional[_VirtualMachineHostReference_f551629f], result)

    @builtins.property
    def identity(self) -> typing.Optional[_VirtualMachineIdentity_dc7decb0]:
        '''The identity configuration for the Virtual Machine.

        Example::

            { type: "UserAssigned", userAssignedIdentities: { "/subscriptions/.../resourceGroups/.../providers/Microsoft.ManagedIdentity/userAssignedIdentities/myIdentity": {} } }
        '''
        result = self._values.get("identity")
        return typing.cast(typing.Optional[_VirtualMachineIdentity_dc7decb0], result)

    @builtins.property
    def ignore_changes(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The lifecycle rules to ignore changes Useful for properties that are externally managed or should not trigger updates.

        Example::

            ["osProfile.adminPassword"]
        '''
        result = self._values.get("ignore_changes")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def license_type(self) -> typing.Optional[builtins.str]:
        '''License type for Windows VMs.

        Example::

            "Windows_Client"
        '''
        result = self._values.get("license_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def os_profile(self) -> typing.Optional[_VirtualMachineOSProfile_6980e298]:
        '''The OS profile for the Virtual Machine Defines computer name, admin credentials, and OS-specific configuration.'''
        result = self._values.get("os_profile")
        return typing.cast(typing.Optional[_VirtualMachineOSProfile_6980e298], result)

    @builtins.property
    def plan(self) -> typing.Optional[_VirtualMachinePlan_2ca6c6de]:
        '''Plan information for marketplace images.'''
        result = self._values.get("plan")
        return typing.cast(typing.Optional[_VirtualMachinePlan_2ca6c6de], result)

    @builtins.property
    def priority(self) -> typing.Optional[builtins.str]:
        '''The priority of the Virtual Machine.

        :default: "Regular"

        Example::

            "Regular", "Low", "Spot"
        '''
        result = self._values.get("priority")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def proximity_placement_group(
        self,
    ) -> typing.Optional[_VirtualMachineProximityPlacementGroupReference_b821dec8]:
        '''Reference to a proximity placement group.'''
        result = self._values.get("proximity_placement_group")
        return typing.cast(typing.Optional[_VirtualMachineProximityPlacementGroupReference_b821dec8], result)

    @builtins.property
    def resource_group_id(self) -> typing.Optional[builtins.str]:
        '''Resource group ID where the Virtual Machine will be created.'''
        result = self._values.get("resource_group_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def security_profile(
        self,
    ) -> typing.Optional[_VirtualMachineSecurityProfile_59175751]:
        '''Security settings for the Virtual Machine.'''
        result = self._values.get("security_profile")
        return typing.cast(typing.Optional[_VirtualMachineSecurityProfile_59175751], result)

    @builtins.property
    def virtual_machine_scale_set(
        self,
    ) -> typing.Optional[_VirtualMachineScaleSetReference_c6dfc840]:
        '''Reference to a virtual machine scale set.'''
        result = self._values.get("virtual_machine_scale_set")
        return typing.cast(typing.Optional[_VirtualMachineScaleSetReference_c6dfc840], result)

    @builtins.property
    def zones(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Availability zones for the Virtual Machine.

        Example::

            ["1", "2"]
        '''
        result = self._values.get("zones")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VirtualMachineProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.VirtualMachineProximityPlacementGroupReference",
    jsii_struct_bases=[],
    name_mapping={"id": "id"},
)
class VirtualMachineProximityPlacementGroupReference:
    def __init__(self, *, id: typing.Optional[builtins.str] = None) -> None:
        '''Proximity placement group reference.

        :param id: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__82bf5177dc9562ea6e13381a0ee8e6416d195eccb3825639f155f6a11ffef234)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if id is not None:
            self._values["id"] = id

    @builtins.property
    def id(self) -> typing.Optional[builtins.str]:
        result = self._values.get("id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VirtualMachineProximityPlacementGroupReference(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class VirtualMachineScaleSet(
    _AzapiResource_7e7f5b39,
    metaclass=jsii.JSIIMeta,
    jsii_type="@microsoft/terraform-cdk-constructs.VirtualMachineScaleSet",
):
    '''Unified Azure Virtual Machine Scale Set implementation.

    This class provides a single, version-aware implementation that automatically handles version
    resolution, schema validation, and property transformation while maintaining full JSII compliance.

    The class uses the AzapiResource framework to provide:

    - Automatic latest version resolution (2025-04-01 as of this implementation)
    - Support for explicit version pinning when stability is required
    - Schema-driven property validation and transformation
    - Migration analysis and deprecation warnings
    - Full JSII compliance for multi-language support

    Example::

        // Flexible orchestration mode with rolling upgrades:
        const flexibleVmss = new VirtualMachineScaleSet(this, "flexible-vmss", {
          name: "my-flexible-vmss",
          location: "eastus",
          resourceGroupId: resourceGroup.id,
          sku: {
            name: "Standard_D2s_v3",
            capacity: 5
          },
          orchestrationMode: "Flexible",
          upgradePolicy: {
            mode: "Rolling",
            rollingUpgradePolicy: {
              maxBatchInstancePercent: 20,
              maxUnhealthyInstancePercent: 20,
              maxUnhealthyUpgradedInstancePercent: 20,
              pauseTimeBetweenBatches: "PT5S"
            }
          },
          automaticRepairsPolicy: {
            enabled: true,
            gracePeriod: "PT30M"
          }
        });
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        location: builtins.str,
        name: builtins.str,
        sku: typing.Union[_VirtualMachineScaleSetSku_34577b48, typing.Dict[builtins.str, typing.Any]],
        additional_capabilities: typing.Optional[typing.Union[_AdditionalCapabilities_a2950776, typing.Dict[builtins.str, typing.Any]]] = None,
        api_version: typing.Optional[builtins.str] = None,
        automatic_repairs_policy: typing.Optional[typing.Union[_AutomaticRepairsPolicy_6d70e54f, typing.Dict[builtins.str, typing.Any]]] = None,
        do_not_run_extensions_on_overprovisioned_v_ms: typing.Optional[builtins.bool] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        host_group: typing.Optional[typing.Union[_HostGroupReference_3690e1b0, typing.Dict[builtins.str, typing.Any]]] = None,
        identity: typing.Optional[typing.Union[_VirtualMachineIdentity_dc7decb0, typing.Dict[builtins.str, typing.Any]]] = None,
        ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
        monitoring: typing.Any = None,
        orchestration_mode: typing.Optional[builtins.str] = None,
        overprovision: typing.Optional[builtins.bool] = None,
        plan: typing.Optional[typing.Union[_VirtualMachinePlan_2ca6c6de, typing.Dict[builtins.str, typing.Any]]] = None,
        platform_fault_domain_count: typing.Optional[jsii.Number] = None,
        proximity_placement_group: typing.Optional[typing.Union[_ProximityPlacementGroupReference_c34e9a6e, typing.Dict[builtins.str, typing.Any]]] = None,
        resource_group_id: typing.Optional[builtins.str] = None,
        scale_in_policy: typing.Optional[typing.Union[_VirtualMachineScaleSetScaleInPolicy_08264334, typing.Dict[builtins.str, typing.Any]]] = None,
        single_placement_group: typing.Optional[builtins.bool] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        upgrade_policy: typing.Optional[typing.Union[_VirtualMachineScaleSetUpgradePolicy_ff7653fe, typing.Dict[builtins.str, typing.Any]]] = None,
        virtual_machine_profile: typing.Optional[typing.Union[_VirtualMachineScaleSetVMProfile_ec8f7867, typing.Dict[builtins.str, typing.Any]]] = None,
        zone_balance: typing.Optional[builtins.bool] = None,
        zones: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''Creates a new Azure Virtual Machine Scale Set using the AzapiResource framework.

        The constructor automatically handles version resolution, schema registration,
        validation, and resource creation.

        :param scope: - The scope in which to define this construct.
        :param id: - The unique identifier for this instance.
        :param location: 
        :param name: 
        :param sku: 
        :param additional_capabilities: 
        :param api_version: 
        :param automatic_repairs_policy: 
        :param do_not_run_extensions_on_overprovisioned_v_ms: 
        :param enable_migration_analysis: 
        :param enable_transformation: 
        :param enable_validation: 
        :param host_group: 
        :param identity: 
        :param ignore_changes: 
        :param monitoring: 
        :param orchestration_mode: 
        :param overprovision: 
        :param plan: 
        :param platform_fault_domain_count: 
        :param proximity_placement_group: 
        :param resource_group_id: 
        :param scale_in_policy: 
        :param single_placement_group: 
        :param tags: 
        :param upgrade_policy: 
        :param virtual_machine_profile: 
        :param zone_balance: 
        :param zones: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6dd41697378c19cc11378623e9bc97db6bb3ba92efdb45d6824862ee02889419)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = _VirtualMachineScaleSetProps_1daecaa8(
            location=location,
            name=name,
            sku=sku,
            additional_capabilities=additional_capabilities,
            api_version=api_version,
            automatic_repairs_policy=automatic_repairs_policy,
            do_not_run_extensions_on_overprovisioned_v_ms=do_not_run_extensions_on_overprovisioned_v_ms,
            enable_migration_analysis=enable_migration_analysis,
            enable_transformation=enable_transformation,
            enable_validation=enable_validation,
            host_group=host_group,
            identity=identity,
            ignore_changes=ignore_changes,
            monitoring=monitoring,
            orchestration_mode=orchestration_mode,
            overprovision=overprovision,
            plan=plan,
            platform_fault_domain_count=platform_fault_domain_count,
            proximity_placement_group=proximity_placement_group,
            resource_group_id=resource_group_id,
            scale_in_policy=scale_in_policy,
            single_placement_group=single_placement_group,
            tags=tags,
            upgrade_policy=upgrade_policy,
            virtual_machine_profile=virtual_machine_profile,
            zone_balance=zone_balance,
            zones=zones,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="defaultMonitoring")
    @builtins.classmethod
    def default_monitoring(
        cls,
        action_group_id: builtins.str,
        workspace_id: typing.Optional[builtins.str] = None,
        *,
        cpu_alert_severity: typing.Optional[jsii.Number] = None,
        cpu_threshold: typing.Optional[jsii.Number] = None,
        disk_queue_alert_severity: typing.Optional[jsii.Number] = None,
        disk_queue_threshold: typing.Optional[jsii.Number] = None,
        enable_cpu_alert: typing.Optional[builtins.bool] = None,
        enable_deletion_alert: typing.Optional[builtins.bool] = None,
        enable_disk_queue_alert: typing.Optional[builtins.bool] = None,
        enable_memory_alert: typing.Optional[builtins.bool] = None,
        memory_alert_severity: typing.Optional[jsii.Number] = None,
        memory_threshold: typing.Optional[jsii.Number] = None,
    ) -> _MonitoringConfig_7c28df74:
        '''Returns a production-ready monitoring configuration for Virtual Machine Scale Sets.

        This static factory method provides a complete MonitoringConfig with sensible defaults
        for VMSS monitoring including CPU, memory, disk queue alerts, and deletion tracking.

        VMSS uses a lower CPU threshold (75%) compared to single VMs (80%) to allow headroom
        for scaling operations before reaching saturation.

        :param action_group_id: - The resource ID of the action group for alert notifications.
        :param workspace_id: - Optional Log Analytics workspace ID for diagnostic settings.
        :param cpu_alert_severity: Severity level for CPU usage alerts. - 0: Critical - 1: Error - 2: Warning - 3: Informational - 4: Verbose Default: 2
        :param cpu_threshold: CPU usage threshold percentage for triggering alerts. VMSS uses a lower default threshold (75%) compared to single VMs (80%) to allow headroom for scaling operations before reaching saturation. Default: 75
        :param disk_queue_alert_severity: Severity level for disk queue depth alerts. - 0: Critical - 1: Error - 2: Warning - 3: Informational - 4: Verbose Default: 2
        :param disk_queue_threshold: Disk queue depth threshold for triggering alerts. High disk queue depth can indicate disk performance bottlenecks. Default: 32
        :param enable_cpu_alert: Enable or disable CPU usage alert. Default: true
        :param enable_deletion_alert: Enable or disable VMSS deletion activity log alert. Default: true
        :param enable_disk_queue_alert: Enable or disable disk queue depth alert. Default: true
        :param enable_memory_alert: Enable or disable memory usage alert. Default: true
        :param memory_alert_severity: Severity level for memory usage alerts. - 0: Critical - 1: Error - 2: Warning - 3: Informational - 4: Verbose Default: 2
        :param memory_threshold: Available memory threshold in bytes for triggering alerts. When available memory drops below this threshold, an alert will be triggered. Default is 1GB (1073741824 bytes). Default: 1073741824

        :return: A complete MonitoringConfig object ready to use in VirtualMachineScaleSet props

        Example::

            // Custom thresholds and severities
            const vmss = new VirtualMachineScaleSet(this, "vmss", {
              // ... other properties ...
              monitoring: VirtualMachineScaleSet.defaultMonitoring(
                actionGroup.id,
                workspace.id,
                {
                  cpuThreshold: 85,
                  memoryThreshold: 536870912, // 512MB
                  enableDiskQueueAlert: false,
                  cpuAlertSeverity: 1 // Error level
                }
              )
            });
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8cf87579583cfa02c6a9eb91584ef30cf16ccd42e0456b7bcfcd40c487148558)
            check_type(argname="argument action_group_id", value=action_group_id, expected_type=type_hints["action_group_id"])
            check_type(argname="argument workspace_id", value=workspace_id, expected_type=type_hints["workspace_id"])
        options = _VmssMonitoringOptions_d4afc1e8(
            cpu_alert_severity=cpu_alert_severity,
            cpu_threshold=cpu_threshold,
            disk_queue_alert_severity=disk_queue_alert_severity,
            disk_queue_threshold=disk_queue_threshold,
            enable_cpu_alert=enable_cpu_alert,
            enable_deletion_alert=enable_deletion_alert,
            enable_disk_queue_alert=enable_disk_queue_alert,
            enable_memory_alert=enable_memory_alert,
            memory_alert_severity=memory_alert_severity,
            memory_threshold=memory_threshold,
        )

        return typing.cast(_MonitoringConfig_7c28df74, jsii.sinvoke(cls, "defaultMonitoring", [action_group_id, workspace_id, options]))

    @jsii.member(jsii_name="addTag")
    def add_tag(self, key: builtins.str, value: builtins.str) -> None:
        '''Add a tag to the Virtual Machine Scale Set Note: This modifies the construct props but requires a new deployment to take effect.

        :param key: -
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__657c9068a1ac2f64155887cbbae0f395c6a8d05869dd84ae8527abe23175127c)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "addTag", [key, value]))

    @jsii.member(jsii_name="apiSchema")
    def _api_schema(self) -> _ApiSchema_5ce0490e:
        '''Gets the API schema for the resolved version Uses the framework's schema resolution to get the appropriate schema.'''
        return typing.cast(_ApiSchema_5ce0490e, jsii.invoke(self, "apiSchema", []))

    @jsii.member(jsii_name="createResourceBody")
    def _create_resource_body(self, props: typing.Any) -> typing.Any:
        '''Creates the resource body for the Azure API call Transforms the input properties into the JSON format expected by Azure REST API.

        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__93897854661b55f6093497152d6cb55ae9b78e0153f79a8c56009a2e0b9271c7)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Any, jsii.invoke(self, "createResourceBody", [props]))

    @jsii.member(jsii_name="defaultVersion")
    def _default_version(self) -> builtins.str:
        '''Gets the default API version to use when no explicit version is specified Returns the most recent stable version as the default.'''
        return typing.cast(builtins.str, jsii.invoke(self, "defaultVersion", []))

    @jsii.member(jsii_name="removeTag")
    def remove_tag(self, key: builtins.str) -> None:
        '''Remove a tag from the Virtual Machine Scale Set Note: This modifies the construct props but requires a new deployment to take effect.

        :param key: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__061fa6ba3d8de22be01727b5757f50f2d6e4a7cc99be16ffd389a66ded26b131)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
        return typing.cast(None, jsii.invoke(self, "removeTag", [key]))

    @jsii.member(jsii_name="requiresLocation")
    def _requires_location(self) -> builtins.bool:
        '''Indicates that location is required for Virtual Machine Scale Sets.'''
        return typing.cast(builtins.bool, jsii.invoke(self, "requiresLocation", []))

    @jsii.member(jsii_name="resourceType")
    def _resource_type(self) -> builtins.str:
        '''Gets the Azure resource type for Virtual Machine Scale Sets.'''
        return typing.cast(builtins.str, jsii.invoke(self, "resourceType", []))

    @builtins.property
    @jsii.member(jsii_name="idOutput")
    def id_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "idOutput"))

    @builtins.property
    @jsii.member(jsii_name="locationOutput")
    def location_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "locationOutput"))

    @builtins.property
    @jsii.member(jsii_name="nameOutput")
    def name_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "nameOutput"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def props(self) -> _VirtualMachineScaleSetProps_1daecaa8:
        '''The input properties for this VMSS instance.'''
        return typing.cast(_VirtualMachineScaleSetProps_1daecaa8, jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        '''Get the provisioning state of the Virtual Machine Scale Set.'''
        return typing.cast(builtins.str, jsii.get(self, "provisioningState"))

    @builtins.property
    @jsii.member(jsii_name="sku")
    def sku(self) -> _VirtualMachineScaleSetSku_34577b48:
        '''Get the SKU configuration.'''
        return typing.cast(_VirtualMachineScaleSetSku_34577b48, jsii.get(self, "sku"))

    @builtins.property
    @jsii.member(jsii_name="tagsOutput")
    def tags_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "tagsOutput"))

    @builtins.property
    @jsii.member(jsii_name="uniqueId")
    def unique_id(self) -> builtins.str:
        '''Get the unique ID (unique identifier assigned by Azure).'''
        return typing.cast(builtins.str, jsii.get(self, "uniqueId"))

    @builtins.property
    @jsii.member(jsii_name="uniqueIdOutput")
    def unique_id_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "uniqueIdOutput"))

    @builtins.property
    @jsii.member(jsii_name="capacity")
    def capacity(self) -> typing.Optional[jsii.Number]:
        '''Get the capacity (number of VMs).'''
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "capacity"))

    @builtins.property
    @jsii.member(jsii_name="orchestrationMode")
    def orchestration_mode(self) -> typing.Optional[builtins.str]:
        '''Get the orchestration mode.'''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "orchestrationMode"))


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.VirtualMachineScaleSetBody",
    jsii_struct_bases=[],
    name_mapping={
        "location": "location",
        "properties": "properties",
        "sku": "sku",
        "identity": "identity",
        "plan": "plan",
        "tags": "tags",
        "zones": "zones",
    },
)
class VirtualMachineScaleSetBody:
    def __init__(
        self,
        *,
        location: builtins.str,
        properties: typing.Union[_VirtualMachineScaleSetBodyProperties_4f71389b, typing.Dict[builtins.str, typing.Any]],
        sku: typing.Union[_VirtualMachineScaleSetSku_34577b48, typing.Dict[builtins.str, typing.Any]],
        identity: typing.Optional[typing.Union[_VirtualMachineIdentity_dc7decb0, typing.Dict[builtins.str, typing.Any]]] = None,
        plan: typing.Optional[typing.Union[_VirtualMachinePlan_2ca6c6de, typing.Dict[builtins.str, typing.Any]]] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        zones: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''The resource body interface for Azure VMSS API calls.

        :param location: 
        :param properties: 
        :param sku: 
        :param identity: 
        :param plan: 
        :param tags: 
        :param zones: 
        '''
        if isinstance(properties, dict):
            properties = _VirtualMachineScaleSetBodyProperties_4f71389b(**properties)
        if isinstance(sku, dict):
            sku = _VirtualMachineScaleSetSku_34577b48(**sku)
        if isinstance(identity, dict):
            identity = _VirtualMachineIdentity_dc7decb0(**identity)
        if isinstance(plan, dict):
            plan = _VirtualMachinePlan_2ca6c6de(**plan)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__91b88b373f7453efb4cc762f7b890b1565b1f0d1a0bf20bb26b0dcb0fc0d1763)
            check_type(argname="argument location", value=location, expected_type=type_hints["location"])
            check_type(argname="argument properties", value=properties, expected_type=type_hints["properties"])
            check_type(argname="argument sku", value=sku, expected_type=type_hints["sku"])
            check_type(argname="argument identity", value=identity, expected_type=type_hints["identity"])
            check_type(argname="argument plan", value=plan, expected_type=type_hints["plan"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument zones", value=zones, expected_type=type_hints["zones"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "location": location,
            "properties": properties,
            "sku": sku,
        }
        if identity is not None:
            self._values["identity"] = identity
        if plan is not None:
            self._values["plan"] = plan
        if tags is not None:
            self._values["tags"] = tags
        if zones is not None:
            self._values["zones"] = zones

    @builtins.property
    def location(self) -> builtins.str:
        result = self._values.get("location")
        assert result is not None, "Required property 'location' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def properties(self) -> _VirtualMachineScaleSetBodyProperties_4f71389b:
        result = self._values.get("properties")
        assert result is not None, "Required property 'properties' is missing"
        return typing.cast(_VirtualMachineScaleSetBodyProperties_4f71389b, result)

    @builtins.property
    def sku(self) -> _VirtualMachineScaleSetSku_34577b48:
        result = self._values.get("sku")
        assert result is not None, "Required property 'sku' is missing"
        return typing.cast(_VirtualMachineScaleSetSku_34577b48, result)

    @builtins.property
    def identity(self) -> typing.Optional[_VirtualMachineIdentity_dc7decb0]:
        result = self._values.get("identity")
        return typing.cast(typing.Optional[_VirtualMachineIdentity_dc7decb0], result)

    @builtins.property
    def plan(self) -> typing.Optional[_VirtualMachinePlan_2ca6c6de]:
        result = self._values.get("plan")
        return typing.cast(typing.Optional[_VirtualMachinePlan_2ca6c6de], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def zones(self) -> typing.Optional[typing.List[builtins.str]]:
        result = self._values.get("zones")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VirtualMachineScaleSetBody(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.VirtualMachineScaleSetBodyProperties",
    jsii_struct_bases=[],
    name_mapping={
        "additional_capabilities": "additionalCapabilities",
        "automatic_repairs_policy": "automaticRepairsPolicy",
        "do_not_run_extensions_on_overprovisioned_v_ms": "doNotRunExtensionsOnOverprovisionedVMs",
        "host_group": "hostGroup",
        "orchestration_mode": "orchestrationMode",
        "overprovision": "overprovision",
        "platform_fault_domain_count": "platformFaultDomainCount",
        "proximity_placement_group": "proximityPlacementGroup",
        "scale_in_policy": "scaleInPolicy",
        "single_placement_group": "singlePlacementGroup",
        "upgrade_policy": "upgradePolicy",
        "virtual_machine_profile": "virtualMachineProfile",
        "zone_balance": "zoneBalance",
    },
)
class VirtualMachineScaleSetBodyProperties:
    def __init__(
        self,
        *,
        additional_capabilities: typing.Optional[typing.Union[_AdditionalCapabilities_a2950776, typing.Dict[builtins.str, typing.Any]]] = None,
        automatic_repairs_policy: typing.Optional[typing.Union[_AutomaticRepairsPolicy_6d70e54f, typing.Dict[builtins.str, typing.Any]]] = None,
        do_not_run_extensions_on_overprovisioned_v_ms: typing.Optional[builtins.bool] = None,
        host_group: typing.Optional[typing.Union[_HostGroupReference_3690e1b0, typing.Dict[builtins.str, typing.Any]]] = None,
        orchestration_mode: typing.Optional[builtins.str] = None,
        overprovision: typing.Optional[builtins.bool] = None,
        platform_fault_domain_count: typing.Optional[jsii.Number] = None,
        proximity_placement_group: typing.Optional[typing.Union[_ProximityPlacementGroupReference_c34e9a6e, typing.Dict[builtins.str, typing.Any]]] = None,
        scale_in_policy: typing.Optional[typing.Union[_VirtualMachineScaleSetScaleInPolicy_08264334, typing.Dict[builtins.str, typing.Any]]] = None,
        single_placement_group: typing.Optional[builtins.bool] = None,
        upgrade_policy: typing.Optional[typing.Union[_VirtualMachineScaleSetUpgradePolicy_ff7653fe, typing.Dict[builtins.str, typing.Any]]] = None,
        virtual_machine_profile: typing.Optional[typing.Union[_VirtualMachineScaleSetVMProfile_ec8f7867, typing.Dict[builtins.str, typing.Any]]] = None,
        zone_balance: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Body properties for VMSS.

        :param additional_capabilities: 
        :param automatic_repairs_policy: 
        :param do_not_run_extensions_on_overprovisioned_v_ms: 
        :param host_group: 
        :param orchestration_mode: 
        :param overprovision: 
        :param platform_fault_domain_count: 
        :param proximity_placement_group: 
        :param scale_in_policy: 
        :param single_placement_group: 
        :param upgrade_policy: 
        :param virtual_machine_profile: 
        :param zone_balance: 
        '''
        if isinstance(additional_capabilities, dict):
            additional_capabilities = _AdditionalCapabilities_a2950776(**additional_capabilities)
        if isinstance(automatic_repairs_policy, dict):
            automatic_repairs_policy = _AutomaticRepairsPolicy_6d70e54f(**automatic_repairs_policy)
        if isinstance(host_group, dict):
            host_group = _HostGroupReference_3690e1b0(**host_group)
        if isinstance(proximity_placement_group, dict):
            proximity_placement_group = _ProximityPlacementGroupReference_c34e9a6e(**proximity_placement_group)
        if isinstance(scale_in_policy, dict):
            scale_in_policy = _VirtualMachineScaleSetScaleInPolicy_08264334(**scale_in_policy)
        if isinstance(upgrade_policy, dict):
            upgrade_policy = _VirtualMachineScaleSetUpgradePolicy_ff7653fe(**upgrade_policy)
        if isinstance(virtual_machine_profile, dict):
            virtual_machine_profile = _VirtualMachineScaleSetVMProfile_ec8f7867(**virtual_machine_profile)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__00af7041975101c1d551651902aa68ac82232f63864cdba29addbf6e3cb16865)
            check_type(argname="argument additional_capabilities", value=additional_capabilities, expected_type=type_hints["additional_capabilities"])
            check_type(argname="argument automatic_repairs_policy", value=automatic_repairs_policy, expected_type=type_hints["automatic_repairs_policy"])
            check_type(argname="argument do_not_run_extensions_on_overprovisioned_v_ms", value=do_not_run_extensions_on_overprovisioned_v_ms, expected_type=type_hints["do_not_run_extensions_on_overprovisioned_v_ms"])
            check_type(argname="argument host_group", value=host_group, expected_type=type_hints["host_group"])
            check_type(argname="argument orchestration_mode", value=orchestration_mode, expected_type=type_hints["orchestration_mode"])
            check_type(argname="argument overprovision", value=overprovision, expected_type=type_hints["overprovision"])
            check_type(argname="argument platform_fault_domain_count", value=platform_fault_domain_count, expected_type=type_hints["platform_fault_domain_count"])
            check_type(argname="argument proximity_placement_group", value=proximity_placement_group, expected_type=type_hints["proximity_placement_group"])
            check_type(argname="argument scale_in_policy", value=scale_in_policy, expected_type=type_hints["scale_in_policy"])
            check_type(argname="argument single_placement_group", value=single_placement_group, expected_type=type_hints["single_placement_group"])
            check_type(argname="argument upgrade_policy", value=upgrade_policy, expected_type=type_hints["upgrade_policy"])
            check_type(argname="argument virtual_machine_profile", value=virtual_machine_profile, expected_type=type_hints["virtual_machine_profile"])
            check_type(argname="argument zone_balance", value=zone_balance, expected_type=type_hints["zone_balance"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if additional_capabilities is not None:
            self._values["additional_capabilities"] = additional_capabilities
        if automatic_repairs_policy is not None:
            self._values["automatic_repairs_policy"] = automatic_repairs_policy
        if do_not_run_extensions_on_overprovisioned_v_ms is not None:
            self._values["do_not_run_extensions_on_overprovisioned_v_ms"] = do_not_run_extensions_on_overprovisioned_v_ms
        if host_group is not None:
            self._values["host_group"] = host_group
        if orchestration_mode is not None:
            self._values["orchestration_mode"] = orchestration_mode
        if overprovision is not None:
            self._values["overprovision"] = overprovision
        if platform_fault_domain_count is not None:
            self._values["platform_fault_domain_count"] = platform_fault_domain_count
        if proximity_placement_group is not None:
            self._values["proximity_placement_group"] = proximity_placement_group
        if scale_in_policy is not None:
            self._values["scale_in_policy"] = scale_in_policy
        if single_placement_group is not None:
            self._values["single_placement_group"] = single_placement_group
        if upgrade_policy is not None:
            self._values["upgrade_policy"] = upgrade_policy
        if virtual_machine_profile is not None:
            self._values["virtual_machine_profile"] = virtual_machine_profile
        if zone_balance is not None:
            self._values["zone_balance"] = zone_balance

    @builtins.property
    def additional_capabilities(
        self,
    ) -> typing.Optional[_AdditionalCapabilities_a2950776]:
        result = self._values.get("additional_capabilities")
        return typing.cast(typing.Optional[_AdditionalCapabilities_a2950776], result)

    @builtins.property
    def automatic_repairs_policy(
        self,
    ) -> typing.Optional[_AutomaticRepairsPolicy_6d70e54f]:
        result = self._values.get("automatic_repairs_policy")
        return typing.cast(typing.Optional[_AutomaticRepairsPolicy_6d70e54f], result)

    @builtins.property
    def do_not_run_extensions_on_overprovisioned_v_ms(
        self,
    ) -> typing.Optional[builtins.bool]:
        result = self._values.get("do_not_run_extensions_on_overprovisioned_v_ms")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def host_group(self) -> typing.Optional[_HostGroupReference_3690e1b0]:
        result = self._values.get("host_group")
        return typing.cast(typing.Optional[_HostGroupReference_3690e1b0], result)

    @builtins.property
    def orchestration_mode(self) -> typing.Optional[builtins.str]:
        result = self._values.get("orchestration_mode")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def overprovision(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("overprovision")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def platform_fault_domain_count(self) -> typing.Optional[jsii.Number]:
        result = self._values.get("platform_fault_domain_count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def proximity_placement_group(
        self,
    ) -> typing.Optional[_ProximityPlacementGroupReference_c34e9a6e]:
        result = self._values.get("proximity_placement_group")
        return typing.cast(typing.Optional[_ProximityPlacementGroupReference_c34e9a6e], result)

    @builtins.property
    def scale_in_policy(
        self,
    ) -> typing.Optional[_VirtualMachineScaleSetScaleInPolicy_08264334]:
        result = self._values.get("scale_in_policy")
        return typing.cast(typing.Optional[_VirtualMachineScaleSetScaleInPolicy_08264334], result)

    @builtins.property
    def single_placement_group(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("single_placement_group")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def upgrade_policy(
        self,
    ) -> typing.Optional[_VirtualMachineScaleSetUpgradePolicy_ff7653fe]:
        result = self._values.get("upgrade_policy")
        return typing.cast(typing.Optional[_VirtualMachineScaleSetUpgradePolicy_ff7653fe], result)

    @builtins.property
    def virtual_machine_profile(
        self,
    ) -> typing.Optional[_VirtualMachineScaleSetVMProfile_ec8f7867]:
        result = self._values.get("virtual_machine_profile")
        return typing.cast(typing.Optional[_VirtualMachineScaleSetVMProfile_ec8f7867], result)

    @builtins.property
    def zone_balance(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("zone_balance")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VirtualMachineScaleSetBodyProperties(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.VirtualMachineScaleSetNetworkProfile",
    jsii_struct_bases=[],
    name_mapping={
        "health_probe": "healthProbe",
        "network_api_version": "networkApiVersion",
        "network_interface_configurations": "networkInterfaceConfigurations",
    },
)
class VirtualMachineScaleSetNetworkProfile:
    def __init__(
        self,
        *,
        health_probe: typing.Optional[typing.Union[_HealthProbeReference_1eac48d7, typing.Dict[builtins.str, typing.Any]]] = None,
        network_api_version: typing.Optional[builtins.str] = None,
        network_interface_configurations: typing.Optional[typing.Sequence[typing.Union[_NetworkInterfaceConfiguration_c5773a40, typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Network profile for VMSS (different from VM).

        :param health_probe: 
        :param network_api_version: The API version to use for network interface configurations. This property is automatically set to the latest Network Interface API version when orchestrationMode is "Flexible" and networkInterfaceConfigurations are specified. You can explicitly provide a version if you need to pin to a specific API version. Default: Latest Network Interface API version (auto-resolved)
        :param network_interface_configurations: 
        '''
        if isinstance(health_probe, dict):
            health_probe = _HealthProbeReference_1eac48d7(**health_probe)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7d3570dfe82a9bde4355d2fe2cddd479bd9b1af1d37c953dda0d83c2d28c3c45)
            check_type(argname="argument health_probe", value=health_probe, expected_type=type_hints["health_probe"])
            check_type(argname="argument network_api_version", value=network_api_version, expected_type=type_hints["network_api_version"])
            check_type(argname="argument network_interface_configurations", value=network_interface_configurations, expected_type=type_hints["network_interface_configurations"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if health_probe is not None:
            self._values["health_probe"] = health_probe
        if network_api_version is not None:
            self._values["network_api_version"] = network_api_version
        if network_interface_configurations is not None:
            self._values["network_interface_configurations"] = network_interface_configurations

    @builtins.property
    def health_probe(self) -> typing.Optional[_HealthProbeReference_1eac48d7]:
        result = self._values.get("health_probe")
        return typing.cast(typing.Optional[_HealthProbeReference_1eac48d7], result)

    @builtins.property
    def network_api_version(self) -> typing.Optional[builtins.str]:
        '''The API version to use for network interface configurations.

        This property is automatically set to the latest Network Interface API version
        when orchestrationMode is "Flexible" and networkInterfaceConfigurations are specified.

        You can explicitly provide a version if you need to pin to a specific API version.

        :default: Latest Network Interface API version (auto-resolved)

        Example::

            "2024-10-01"
        '''
        result = self._values.get("network_api_version")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def network_interface_configurations(
        self,
    ) -> typing.Optional[typing.List[_NetworkInterfaceConfiguration_c5773a40]]:
        result = self._values.get("network_interface_configurations")
        return typing.cast(typing.Optional[typing.List[_NetworkInterfaceConfiguration_c5773a40]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VirtualMachineScaleSetNetworkProfile(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.VirtualMachineScaleSetOSProfile",
    jsii_struct_bases=[],
    name_mapping={
        "admin_password": "adminPassword",
        "admin_username": "adminUsername",
        "allow_extension_operations": "allowExtensionOperations",
        "computer_name_prefix": "computerNamePrefix",
        "custom_data": "customData",
        "linux_configuration": "linuxConfiguration",
        "require_guest_provision_signal": "requireGuestProvisionSignal",
        "secrets": "secrets",
        "windows_configuration": "windowsConfiguration",
    },
)
class VirtualMachineScaleSetOSProfile:
    def __init__(
        self,
        *,
        admin_password: typing.Optional[builtins.str] = None,
        admin_username: typing.Optional[builtins.str] = None,
        allow_extension_operations: typing.Optional[builtins.bool] = None,
        computer_name_prefix: typing.Optional[builtins.str] = None,
        custom_data: typing.Optional[builtins.str] = None,
        linux_configuration: typing.Optional[typing.Union[_VirtualMachineLinuxConfiguration_5f791d4c, typing.Dict[builtins.str, typing.Any]]] = None,
        require_guest_provision_signal: typing.Optional[builtins.bool] = None,
        secrets: typing.Optional[typing.Sequence[typing.Any]] = None,
        windows_configuration: typing.Optional[typing.Union[_VirtualMachineWindowsConfiguration_31cdebe5, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''OS Profile for Virtual Machine Scale Set VMSS uses computerNamePrefix instead of computerName.

        :param admin_password: 
        :param admin_username: 
        :param allow_extension_operations: 
        :param computer_name_prefix: 
        :param custom_data: 
        :param linux_configuration: 
        :param require_guest_provision_signal: 
        :param secrets: 
        :param windows_configuration: 
        '''
        if isinstance(linux_configuration, dict):
            linux_configuration = _VirtualMachineLinuxConfiguration_5f791d4c(**linux_configuration)
        if isinstance(windows_configuration, dict):
            windows_configuration = _VirtualMachineWindowsConfiguration_31cdebe5(**windows_configuration)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__44b4eb24f67df1f81e7313522f89d9cfdb15e4a2971ded702c0ce1efe6f74a6c)
            check_type(argname="argument admin_password", value=admin_password, expected_type=type_hints["admin_password"])
            check_type(argname="argument admin_username", value=admin_username, expected_type=type_hints["admin_username"])
            check_type(argname="argument allow_extension_operations", value=allow_extension_operations, expected_type=type_hints["allow_extension_operations"])
            check_type(argname="argument computer_name_prefix", value=computer_name_prefix, expected_type=type_hints["computer_name_prefix"])
            check_type(argname="argument custom_data", value=custom_data, expected_type=type_hints["custom_data"])
            check_type(argname="argument linux_configuration", value=linux_configuration, expected_type=type_hints["linux_configuration"])
            check_type(argname="argument require_guest_provision_signal", value=require_guest_provision_signal, expected_type=type_hints["require_guest_provision_signal"])
            check_type(argname="argument secrets", value=secrets, expected_type=type_hints["secrets"])
            check_type(argname="argument windows_configuration", value=windows_configuration, expected_type=type_hints["windows_configuration"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if admin_password is not None:
            self._values["admin_password"] = admin_password
        if admin_username is not None:
            self._values["admin_username"] = admin_username
        if allow_extension_operations is not None:
            self._values["allow_extension_operations"] = allow_extension_operations
        if computer_name_prefix is not None:
            self._values["computer_name_prefix"] = computer_name_prefix
        if custom_data is not None:
            self._values["custom_data"] = custom_data
        if linux_configuration is not None:
            self._values["linux_configuration"] = linux_configuration
        if require_guest_provision_signal is not None:
            self._values["require_guest_provision_signal"] = require_guest_provision_signal
        if secrets is not None:
            self._values["secrets"] = secrets
        if windows_configuration is not None:
            self._values["windows_configuration"] = windows_configuration

    @builtins.property
    def admin_password(self) -> typing.Optional[builtins.str]:
        result = self._values.get("admin_password")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def admin_username(self) -> typing.Optional[builtins.str]:
        result = self._values.get("admin_username")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def allow_extension_operations(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("allow_extension_operations")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def computer_name_prefix(self) -> typing.Optional[builtins.str]:
        result = self._values.get("computer_name_prefix")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def custom_data(self) -> typing.Optional[builtins.str]:
        result = self._values.get("custom_data")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def linux_configuration(
        self,
    ) -> typing.Optional[_VirtualMachineLinuxConfiguration_5f791d4c]:
        result = self._values.get("linux_configuration")
        return typing.cast(typing.Optional[_VirtualMachineLinuxConfiguration_5f791d4c], result)

    @builtins.property
    def require_guest_provision_signal(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("require_guest_provision_signal")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def secrets(self) -> typing.Optional[typing.List[typing.Any]]:
        result = self._values.get("secrets")
        return typing.cast(typing.Optional[typing.List[typing.Any]], result)

    @builtins.property
    def windows_configuration(
        self,
    ) -> typing.Optional[_VirtualMachineWindowsConfiguration_31cdebe5]:
        result = self._values.get("windows_configuration")
        return typing.cast(typing.Optional[_VirtualMachineWindowsConfiguration_31cdebe5], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VirtualMachineScaleSetOSProfile(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.VirtualMachineScaleSetProps",
    jsii_struct_bases=[],
    name_mapping={
        "location": "location",
        "name": "name",
        "sku": "sku",
        "additional_capabilities": "additionalCapabilities",
        "api_version": "apiVersion",
        "automatic_repairs_policy": "automaticRepairsPolicy",
        "do_not_run_extensions_on_overprovisioned_v_ms": "doNotRunExtensionsOnOverprovisionedVMs",
        "enable_migration_analysis": "enableMigrationAnalysis",
        "enable_transformation": "enableTransformation",
        "enable_validation": "enableValidation",
        "host_group": "hostGroup",
        "identity": "identity",
        "ignore_changes": "ignoreChanges",
        "monitoring": "monitoring",
        "orchestration_mode": "orchestrationMode",
        "overprovision": "overprovision",
        "plan": "plan",
        "platform_fault_domain_count": "platformFaultDomainCount",
        "proximity_placement_group": "proximityPlacementGroup",
        "resource_group_id": "resourceGroupId",
        "scale_in_policy": "scaleInPolicy",
        "single_placement_group": "singlePlacementGroup",
        "tags": "tags",
        "upgrade_policy": "upgradePolicy",
        "virtual_machine_profile": "virtualMachineProfile",
        "zone_balance": "zoneBalance",
        "zones": "zones",
    },
)
class VirtualMachineScaleSetProps:
    def __init__(
        self,
        *,
        location: builtins.str,
        name: builtins.str,
        sku: typing.Union[_VirtualMachineScaleSetSku_34577b48, typing.Dict[builtins.str, typing.Any]],
        additional_capabilities: typing.Optional[typing.Union[_AdditionalCapabilities_a2950776, typing.Dict[builtins.str, typing.Any]]] = None,
        api_version: typing.Optional[builtins.str] = None,
        automatic_repairs_policy: typing.Optional[typing.Union[_AutomaticRepairsPolicy_6d70e54f, typing.Dict[builtins.str, typing.Any]]] = None,
        do_not_run_extensions_on_overprovisioned_v_ms: typing.Optional[builtins.bool] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        host_group: typing.Optional[typing.Union[_HostGroupReference_3690e1b0, typing.Dict[builtins.str, typing.Any]]] = None,
        identity: typing.Optional[typing.Union[_VirtualMachineIdentity_dc7decb0, typing.Dict[builtins.str, typing.Any]]] = None,
        ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
        monitoring: typing.Any = None,
        orchestration_mode: typing.Optional[builtins.str] = None,
        overprovision: typing.Optional[builtins.bool] = None,
        plan: typing.Optional[typing.Union[_VirtualMachinePlan_2ca6c6de, typing.Dict[builtins.str, typing.Any]]] = None,
        platform_fault_domain_count: typing.Optional[jsii.Number] = None,
        proximity_placement_group: typing.Optional[typing.Union[_ProximityPlacementGroupReference_c34e9a6e, typing.Dict[builtins.str, typing.Any]]] = None,
        resource_group_id: typing.Optional[builtins.str] = None,
        scale_in_policy: typing.Optional[typing.Union[_VirtualMachineScaleSetScaleInPolicy_08264334, typing.Dict[builtins.str, typing.Any]]] = None,
        single_placement_group: typing.Optional[builtins.bool] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        upgrade_policy: typing.Optional[typing.Union[_VirtualMachineScaleSetUpgradePolicy_ff7653fe, typing.Dict[builtins.str, typing.Any]]] = None,
        virtual_machine_profile: typing.Optional[typing.Union[_VirtualMachineScaleSetVMProfile_ec8f7867, typing.Dict[builtins.str, typing.Any]]] = None,
        zone_balance: typing.Optional[builtins.bool] = None,
        zones: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''Properties for the Virtual Machine Scale Set.

        :param location: 
        :param name: 
        :param sku: 
        :param additional_capabilities: 
        :param api_version: 
        :param automatic_repairs_policy: 
        :param do_not_run_extensions_on_overprovisioned_v_ms: 
        :param enable_migration_analysis: 
        :param enable_transformation: 
        :param enable_validation: 
        :param host_group: 
        :param identity: 
        :param ignore_changes: 
        :param monitoring: 
        :param orchestration_mode: 
        :param overprovision: 
        :param plan: 
        :param platform_fault_domain_count: 
        :param proximity_placement_group: 
        :param resource_group_id: 
        :param scale_in_policy: 
        :param single_placement_group: 
        :param tags: 
        :param upgrade_policy: 
        :param virtual_machine_profile: 
        :param zone_balance: 
        :param zones: 
        '''
        if isinstance(sku, dict):
            sku = _VirtualMachineScaleSetSku_34577b48(**sku)
        if isinstance(additional_capabilities, dict):
            additional_capabilities = _AdditionalCapabilities_a2950776(**additional_capabilities)
        if isinstance(automatic_repairs_policy, dict):
            automatic_repairs_policy = _AutomaticRepairsPolicy_6d70e54f(**automatic_repairs_policy)
        if isinstance(host_group, dict):
            host_group = _HostGroupReference_3690e1b0(**host_group)
        if isinstance(identity, dict):
            identity = _VirtualMachineIdentity_dc7decb0(**identity)
        if isinstance(plan, dict):
            plan = _VirtualMachinePlan_2ca6c6de(**plan)
        if isinstance(proximity_placement_group, dict):
            proximity_placement_group = _ProximityPlacementGroupReference_c34e9a6e(**proximity_placement_group)
        if isinstance(scale_in_policy, dict):
            scale_in_policy = _VirtualMachineScaleSetScaleInPolicy_08264334(**scale_in_policy)
        if isinstance(upgrade_policy, dict):
            upgrade_policy = _VirtualMachineScaleSetUpgradePolicy_ff7653fe(**upgrade_policy)
        if isinstance(virtual_machine_profile, dict):
            virtual_machine_profile = _VirtualMachineScaleSetVMProfile_ec8f7867(**virtual_machine_profile)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e2889de8cdd3d9d13397c243f51e33cc0f0408fa32520b61be80ffc6f9d2628a)
            check_type(argname="argument location", value=location, expected_type=type_hints["location"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument sku", value=sku, expected_type=type_hints["sku"])
            check_type(argname="argument additional_capabilities", value=additional_capabilities, expected_type=type_hints["additional_capabilities"])
            check_type(argname="argument api_version", value=api_version, expected_type=type_hints["api_version"])
            check_type(argname="argument automatic_repairs_policy", value=automatic_repairs_policy, expected_type=type_hints["automatic_repairs_policy"])
            check_type(argname="argument do_not_run_extensions_on_overprovisioned_v_ms", value=do_not_run_extensions_on_overprovisioned_v_ms, expected_type=type_hints["do_not_run_extensions_on_overprovisioned_v_ms"])
            check_type(argname="argument enable_migration_analysis", value=enable_migration_analysis, expected_type=type_hints["enable_migration_analysis"])
            check_type(argname="argument enable_transformation", value=enable_transformation, expected_type=type_hints["enable_transformation"])
            check_type(argname="argument enable_validation", value=enable_validation, expected_type=type_hints["enable_validation"])
            check_type(argname="argument host_group", value=host_group, expected_type=type_hints["host_group"])
            check_type(argname="argument identity", value=identity, expected_type=type_hints["identity"])
            check_type(argname="argument ignore_changes", value=ignore_changes, expected_type=type_hints["ignore_changes"])
            check_type(argname="argument monitoring", value=monitoring, expected_type=type_hints["monitoring"])
            check_type(argname="argument orchestration_mode", value=orchestration_mode, expected_type=type_hints["orchestration_mode"])
            check_type(argname="argument overprovision", value=overprovision, expected_type=type_hints["overprovision"])
            check_type(argname="argument plan", value=plan, expected_type=type_hints["plan"])
            check_type(argname="argument platform_fault_domain_count", value=platform_fault_domain_count, expected_type=type_hints["platform_fault_domain_count"])
            check_type(argname="argument proximity_placement_group", value=proximity_placement_group, expected_type=type_hints["proximity_placement_group"])
            check_type(argname="argument resource_group_id", value=resource_group_id, expected_type=type_hints["resource_group_id"])
            check_type(argname="argument scale_in_policy", value=scale_in_policy, expected_type=type_hints["scale_in_policy"])
            check_type(argname="argument single_placement_group", value=single_placement_group, expected_type=type_hints["single_placement_group"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument upgrade_policy", value=upgrade_policy, expected_type=type_hints["upgrade_policy"])
            check_type(argname="argument virtual_machine_profile", value=virtual_machine_profile, expected_type=type_hints["virtual_machine_profile"])
            check_type(argname="argument zone_balance", value=zone_balance, expected_type=type_hints["zone_balance"])
            check_type(argname="argument zones", value=zones, expected_type=type_hints["zones"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "location": location,
            "name": name,
            "sku": sku,
        }
        if additional_capabilities is not None:
            self._values["additional_capabilities"] = additional_capabilities
        if api_version is not None:
            self._values["api_version"] = api_version
        if automatic_repairs_policy is not None:
            self._values["automatic_repairs_policy"] = automatic_repairs_policy
        if do_not_run_extensions_on_overprovisioned_v_ms is not None:
            self._values["do_not_run_extensions_on_overprovisioned_v_ms"] = do_not_run_extensions_on_overprovisioned_v_ms
        if enable_migration_analysis is not None:
            self._values["enable_migration_analysis"] = enable_migration_analysis
        if enable_transformation is not None:
            self._values["enable_transformation"] = enable_transformation
        if enable_validation is not None:
            self._values["enable_validation"] = enable_validation
        if host_group is not None:
            self._values["host_group"] = host_group
        if identity is not None:
            self._values["identity"] = identity
        if ignore_changes is not None:
            self._values["ignore_changes"] = ignore_changes
        if monitoring is not None:
            self._values["monitoring"] = monitoring
        if orchestration_mode is not None:
            self._values["orchestration_mode"] = orchestration_mode
        if overprovision is not None:
            self._values["overprovision"] = overprovision
        if plan is not None:
            self._values["plan"] = plan
        if platform_fault_domain_count is not None:
            self._values["platform_fault_domain_count"] = platform_fault_domain_count
        if proximity_placement_group is not None:
            self._values["proximity_placement_group"] = proximity_placement_group
        if resource_group_id is not None:
            self._values["resource_group_id"] = resource_group_id
        if scale_in_policy is not None:
            self._values["scale_in_policy"] = scale_in_policy
        if single_placement_group is not None:
            self._values["single_placement_group"] = single_placement_group
        if tags is not None:
            self._values["tags"] = tags
        if upgrade_policy is not None:
            self._values["upgrade_policy"] = upgrade_policy
        if virtual_machine_profile is not None:
            self._values["virtual_machine_profile"] = virtual_machine_profile
        if zone_balance is not None:
            self._values["zone_balance"] = zone_balance
        if zones is not None:
            self._values["zones"] = zones

    @builtins.property
    def location(self) -> builtins.str:
        result = self._values.get("location")
        assert result is not None, "Required property 'location' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def name(self) -> builtins.str:
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def sku(self) -> _VirtualMachineScaleSetSku_34577b48:
        result = self._values.get("sku")
        assert result is not None, "Required property 'sku' is missing"
        return typing.cast(_VirtualMachineScaleSetSku_34577b48, result)

    @builtins.property
    def additional_capabilities(
        self,
    ) -> typing.Optional[_AdditionalCapabilities_a2950776]:
        result = self._values.get("additional_capabilities")
        return typing.cast(typing.Optional[_AdditionalCapabilities_a2950776], result)

    @builtins.property
    def api_version(self) -> typing.Optional[builtins.str]:
        result = self._values.get("api_version")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def automatic_repairs_policy(
        self,
    ) -> typing.Optional[_AutomaticRepairsPolicy_6d70e54f]:
        result = self._values.get("automatic_repairs_policy")
        return typing.cast(typing.Optional[_AutomaticRepairsPolicy_6d70e54f], result)

    @builtins.property
    def do_not_run_extensions_on_overprovisioned_v_ms(
        self,
    ) -> typing.Optional[builtins.bool]:
        result = self._values.get("do_not_run_extensions_on_overprovisioned_v_ms")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_migration_analysis(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("enable_migration_analysis")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_transformation(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("enable_transformation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_validation(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("enable_validation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def host_group(self) -> typing.Optional[_HostGroupReference_3690e1b0]:
        result = self._values.get("host_group")
        return typing.cast(typing.Optional[_HostGroupReference_3690e1b0], result)

    @builtins.property
    def identity(self) -> typing.Optional[_VirtualMachineIdentity_dc7decb0]:
        result = self._values.get("identity")
        return typing.cast(typing.Optional[_VirtualMachineIdentity_dc7decb0], result)

    @builtins.property
    def ignore_changes(self) -> typing.Optional[typing.List[builtins.str]]:
        result = self._values.get("ignore_changes")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def monitoring(self) -> typing.Any:
        result = self._values.get("monitoring")
        return typing.cast(typing.Any, result)

    @builtins.property
    def orchestration_mode(self) -> typing.Optional[builtins.str]:
        result = self._values.get("orchestration_mode")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def overprovision(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("overprovision")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def plan(self) -> typing.Optional[_VirtualMachinePlan_2ca6c6de]:
        result = self._values.get("plan")
        return typing.cast(typing.Optional[_VirtualMachinePlan_2ca6c6de], result)

    @builtins.property
    def platform_fault_domain_count(self) -> typing.Optional[jsii.Number]:
        result = self._values.get("platform_fault_domain_count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def proximity_placement_group(
        self,
    ) -> typing.Optional[_ProximityPlacementGroupReference_c34e9a6e]:
        result = self._values.get("proximity_placement_group")
        return typing.cast(typing.Optional[_ProximityPlacementGroupReference_c34e9a6e], result)

    @builtins.property
    def resource_group_id(self) -> typing.Optional[builtins.str]:
        result = self._values.get("resource_group_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def scale_in_policy(
        self,
    ) -> typing.Optional[_VirtualMachineScaleSetScaleInPolicy_08264334]:
        result = self._values.get("scale_in_policy")
        return typing.cast(typing.Optional[_VirtualMachineScaleSetScaleInPolicy_08264334], result)

    @builtins.property
    def single_placement_group(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("single_placement_group")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def upgrade_policy(
        self,
    ) -> typing.Optional[_VirtualMachineScaleSetUpgradePolicy_ff7653fe]:
        result = self._values.get("upgrade_policy")
        return typing.cast(typing.Optional[_VirtualMachineScaleSetUpgradePolicy_ff7653fe], result)

    @builtins.property
    def virtual_machine_profile(
        self,
    ) -> typing.Optional[_VirtualMachineScaleSetVMProfile_ec8f7867]:
        result = self._values.get("virtual_machine_profile")
        return typing.cast(typing.Optional[_VirtualMachineScaleSetVMProfile_ec8f7867], result)

    @builtins.property
    def zone_balance(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("zone_balance")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def zones(self) -> typing.Optional[typing.List[builtins.str]]:
        result = self._values.get("zones")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VirtualMachineScaleSetProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.VirtualMachineScaleSetReference",
    jsii_struct_bases=[],
    name_mapping={"id": "id"},
)
class VirtualMachineScaleSetReference:
    def __init__(self, *, id: typing.Optional[builtins.str] = None) -> None:
        '''Virtual machine scale set reference.

        :param id: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__14a1a21f9af81cc8ea03cb10492d9021bb12e07a369504234925578bf5d648ab)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if id is not None:
            self._values["id"] = id

    @builtins.property
    def id(self) -> typing.Optional[builtins.str]:
        result = self._values.get("id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VirtualMachineScaleSetReference(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.VirtualMachineScaleSetScaleInPolicy",
    jsii_struct_bases=[],
    name_mapping={"force_deletion": "forceDeletion", "rules": "rules"},
)
class VirtualMachineScaleSetScaleInPolicy:
    def __init__(
        self,
        *,
        force_deletion: typing.Optional[builtins.bool] = None,
        rules: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''Scale-in policy.

        :param force_deletion: 
        :param rules: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__99d6936e7f14c906df4687341d906ee82d75321364234ea3b387a3b22be29ff4)
            check_type(argname="argument force_deletion", value=force_deletion, expected_type=type_hints["force_deletion"])
            check_type(argname="argument rules", value=rules, expected_type=type_hints["rules"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if force_deletion is not None:
            self._values["force_deletion"] = force_deletion
        if rules is not None:
            self._values["rules"] = rules

    @builtins.property
    def force_deletion(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("force_deletion")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def rules(self) -> typing.Optional[typing.List[builtins.str]]:
        result = self._values.get("rules")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VirtualMachineScaleSetScaleInPolicy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.VirtualMachineScaleSetScalingConfiguration",
    jsii_struct_bases=[],
    name_mapping={
        "do_not_run_extensions_on_overprovisioned_v_ms": "doNotRunExtensionsOnOverprovisionedVMs",
        "overprovision": "overprovision",
        "platform_fault_domain_count": "platformFaultDomainCount",
        "single_placement_group": "singlePlacementGroup",
        "zone_balance": "zoneBalance",
    },
)
class VirtualMachineScaleSetScalingConfiguration:
    def __init__(
        self,
        *,
        do_not_run_extensions_on_overprovisioned_v_ms: typing.Optional[builtins.bool] = None,
        overprovision: typing.Optional[builtins.bool] = None,
        platform_fault_domain_count: typing.Optional[jsii.Number] = None,
        single_placement_group: typing.Optional[builtins.bool] = None,
        zone_balance: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Scaling configuration.

        :param do_not_run_extensions_on_overprovisioned_v_ms: 
        :param overprovision: 
        :param platform_fault_domain_count: 
        :param single_placement_group: 
        :param zone_balance: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1fa1fbf7c361e94a662b5d5ebde0d0c5270fa4fb8b133c287594497042194561)
            check_type(argname="argument do_not_run_extensions_on_overprovisioned_v_ms", value=do_not_run_extensions_on_overprovisioned_v_ms, expected_type=type_hints["do_not_run_extensions_on_overprovisioned_v_ms"])
            check_type(argname="argument overprovision", value=overprovision, expected_type=type_hints["overprovision"])
            check_type(argname="argument platform_fault_domain_count", value=platform_fault_domain_count, expected_type=type_hints["platform_fault_domain_count"])
            check_type(argname="argument single_placement_group", value=single_placement_group, expected_type=type_hints["single_placement_group"])
            check_type(argname="argument zone_balance", value=zone_balance, expected_type=type_hints["zone_balance"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if do_not_run_extensions_on_overprovisioned_v_ms is not None:
            self._values["do_not_run_extensions_on_overprovisioned_v_ms"] = do_not_run_extensions_on_overprovisioned_v_ms
        if overprovision is not None:
            self._values["overprovision"] = overprovision
        if platform_fault_domain_count is not None:
            self._values["platform_fault_domain_count"] = platform_fault_domain_count
        if single_placement_group is not None:
            self._values["single_placement_group"] = single_placement_group
        if zone_balance is not None:
            self._values["zone_balance"] = zone_balance

    @builtins.property
    def do_not_run_extensions_on_overprovisioned_v_ms(
        self,
    ) -> typing.Optional[builtins.bool]:
        result = self._values.get("do_not_run_extensions_on_overprovisioned_v_ms")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def overprovision(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("overprovision")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def platform_fault_domain_count(self) -> typing.Optional[jsii.Number]:
        result = self._values.get("platform_fault_domain_count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def single_placement_group(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("single_placement_group")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def zone_balance(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("zone_balance")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VirtualMachineScaleSetScalingConfiguration(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.VirtualMachineScaleSetSku",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "capacity": "capacity", "tier": "tier"},
)
class VirtualMachineScaleSetSku:
    def __init__(
        self,
        *,
        name: builtins.str,
        capacity: typing.Optional[jsii.Number] = None,
        tier: typing.Optional[builtins.str] = None,
    ) -> None:
        '''SKU for the Virtual Machine Scale Set.

        :param name: 
        :param capacity: 
        :param tier: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__30c45ebb2abfaa74b408cfee2be7ad67fc0c0bc57bfb4d808fae531ebd31281b)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument capacity", value=capacity, expected_type=type_hints["capacity"])
            check_type(argname="argument tier", value=tier, expected_type=type_hints["tier"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if capacity is not None:
            self._values["capacity"] = capacity
        if tier is not None:
            self._values["tier"] = tier

    @builtins.property
    def name(self) -> builtins.str:
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def capacity(self) -> typing.Optional[jsii.Number]:
        result = self._values.get("capacity")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def tier(self) -> typing.Optional[builtins.str]:
        result = self._values.get("tier")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VirtualMachineScaleSetSku(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.VirtualMachineScaleSetUpgradePolicy",
    jsii_struct_bases=[],
    name_mapping={
        "automatic_os_upgrade_policy": "automaticOSUpgradePolicy",
        "mode": "mode",
        "rolling_upgrade_policy": "rollingUpgradePolicy",
    },
)
class VirtualMachineScaleSetUpgradePolicy:
    def __init__(
        self,
        *,
        automatic_os_upgrade_policy: typing.Optional[typing.Union[_AutomaticOSUpgradePolicy_11c86d38, typing.Dict[builtins.str, typing.Any]]] = None,
        mode: typing.Optional[builtins.str] = None,
        rolling_upgrade_policy: typing.Optional[typing.Union[_RollingUpgradePolicy_9ee9233f, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Upgrade policy for the Virtual Machine Scale Set.

        :param automatic_os_upgrade_policy: 
        :param mode: 
        :param rolling_upgrade_policy: 
        '''
        if isinstance(automatic_os_upgrade_policy, dict):
            automatic_os_upgrade_policy = _AutomaticOSUpgradePolicy_11c86d38(**automatic_os_upgrade_policy)
        if isinstance(rolling_upgrade_policy, dict):
            rolling_upgrade_policy = _RollingUpgradePolicy_9ee9233f(**rolling_upgrade_policy)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6e120f9c2e6fb265d5d3d1ab89ee4f5e92a2e87991268ad039a4a32c4f568f0d)
            check_type(argname="argument automatic_os_upgrade_policy", value=automatic_os_upgrade_policy, expected_type=type_hints["automatic_os_upgrade_policy"])
            check_type(argname="argument mode", value=mode, expected_type=type_hints["mode"])
            check_type(argname="argument rolling_upgrade_policy", value=rolling_upgrade_policy, expected_type=type_hints["rolling_upgrade_policy"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if automatic_os_upgrade_policy is not None:
            self._values["automatic_os_upgrade_policy"] = automatic_os_upgrade_policy
        if mode is not None:
            self._values["mode"] = mode
        if rolling_upgrade_policy is not None:
            self._values["rolling_upgrade_policy"] = rolling_upgrade_policy

    @builtins.property
    def automatic_os_upgrade_policy(
        self,
    ) -> typing.Optional[_AutomaticOSUpgradePolicy_11c86d38]:
        result = self._values.get("automatic_os_upgrade_policy")
        return typing.cast(typing.Optional[_AutomaticOSUpgradePolicy_11c86d38], result)

    @builtins.property
    def mode(self) -> typing.Optional[builtins.str]:
        result = self._values.get("mode")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def rolling_upgrade_policy(self) -> typing.Optional[_RollingUpgradePolicy_9ee9233f]:
        result = self._values.get("rolling_upgrade_policy")
        return typing.cast(typing.Optional[_RollingUpgradePolicy_9ee9233f], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VirtualMachineScaleSetUpgradePolicy(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.VirtualMachineScaleSetVMProfile",
    jsii_struct_bases=[],
    name_mapping={
        "billing_profile": "billingProfile",
        "diagnostics_profile": "diagnosticsProfile",
        "eviction_policy": "evictionPolicy",
        "extension_profile": "extensionProfile",
        "license_type": "licenseType",
        "network_profile": "networkProfile",
        "os_profile": "osProfile",
        "priority": "priority",
        "scheduled_events_profile": "scheduledEventsProfile",
        "security_profile": "securityProfile",
        "storage_profile": "storageProfile",
    },
)
class VirtualMachineScaleSetVMProfile:
    def __init__(
        self,
        *,
        billing_profile: typing.Optional[typing.Union[_VirtualMachineBillingProfile_b57d8936, typing.Dict[builtins.str, typing.Any]]] = None,
        diagnostics_profile: typing.Optional[typing.Union[_VirtualMachineDiagnosticsProfile_05cee027, typing.Dict[builtins.str, typing.Any]]] = None,
        eviction_policy: typing.Optional[builtins.str] = None,
        extension_profile: typing.Optional[typing.Union[_ExtensionProfile_ec55a00c, typing.Dict[builtins.str, typing.Any]]] = None,
        license_type: typing.Optional[builtins.str] = None,
        network_profile: typing.Optional[typing.Union[_VirtualMachineScaleSetNetworkProfile_e3604858, typing.Dict[builtins.str, typing.Any]]] = None,
        os_profile: typing.Optional[typing.Union[_VirtualMachineScaleSetOSProfile_320ebb42, typing.Dict[builtins.str, typing.Any]]] = None,
        priority: typing.Optional[builtins.str] = None,
        scheduled_events_profile: typing.Optional[typing.Union[_ScheduledEventsProfile_f4e5611c, typing.Dict[builtins.str, typing.Any]]] = None,
        security_profile: typing.Optional[typing.Union[_VirtualMachineSecurityProfile_59175751, typing.Dict[builtins.str, typing.Any]]] = None,
        storage_profile: typing.Optional[typing.Union[_VirtualMachineStorageProfile_793daa4a, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''VM profile for the Virtual Machine Scale Set Wraps VM configuration and reuses VM interfaces.

        :param billing_profile: 
        :param diagnostics_profile: 
        :param eviction_policy: 
        :param extension_profile: 
        :param license_type: 
        :param network_profile: 
        :param os_profile: 
        :param priority: 
        :param scheduled_events_profile: 
        :param security_profile: 
        :param storage_profile: 
        '''
        if isinstance(billing_profile, dict):
            billing_profile = _VirtualMachineBillingProfile_b57d8936(**billing_profile)
        if isinstance(diagnostics_profile, dict):
            diagnostics_profile = _VirtualMachineDiagnosticsProfile_05cee027(**diagnostics_profile)
        if isinstance(extension_profile, dict):
            extension_profile = _ExtensionProfile_ec55a00c(**extension_profile)
        if isinstance(network_profile, dict):
            network_profile = _VirtualMachineScaleSetNetworkProfile_e3604858(**network_profile)
        if isinstance(os_profile, dict):
            os_profile = _VirtualMachineScaleSetOSProfile_320ebb42(**os_profile)
        if isinstance(scheduled_events_profile, dict):
            scheduled_events_profile = _ScheduledEventsProfile_f4e5611c(**scheduled_events_profile)
        if isinstance(security_profile, dict):
            security_profile = _VirtualMachineSecurityProfile_59175751(**security_profile)
        if isinstance(storage_profile, dict):
            storage_profile = _VirtualMachineStorageProfile_793daa4a(**storage_profile)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a3cf55421f920dcf6dc4b0edbd58c29544e5b75937315015c50fe3560503de90)
            check_type(argname="argument billing_profile", value=billing_profile, expected_type=type_hints["billing_profile"])
            check_type(argname="argument diagnostics_profile", value=diagnostics_profile, expected_type=type_hints["diagnostics_profile"])
            check_type(argname="argument eviction_policy", value=eviction_policy, expected_type=type_hints["eviction_policy"])
            check_type(argname="argument extension_profile", value=extension_profile, expected_type=type_hints["extension_profile"])
            check_type(argname="argument license_type", value=license_type, expected_type=type_hints["license_type"])
            check_type(argname="argument network_profile", value=network_profile, expected_type=type_hints["network_profile"])
            check_type(argname="argument os_profile", value=os_profile, expected_type=type_hints["os_profile"])
            check_type(argname="argument priority", value=priority, expected_type=type_hints["priority"])
            check_type(argname="argument scheduled_events_profile", value=scheduled_events_profile, expected_type=type_hints["scheduled_events_profile"])
            check_type(argname="argument security_profile", value=security_profile, expected_type=type_hints["security_profile"])
            check_type(argname="argument storage_profile", value=storage_profile, expected_type=type_hints["storage_profile"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if billing_profile is not None:
            self._values["billing_profile"] = billing_profile
        if diagnostics_profile is not None:
            self._values["diagnostics_profile"] = diagnostics_profile
        if eviction_policy is not None:
            self._values["eviction_policy"] = eviction_policy
        if extension_profile is not None:
            self._values["extension_profile"] = extension_profile
        if license_type is not None:
            self._values["license_type"] = license_type
        if network_profile is not None:
            self._values["network_profile"] = network_profile
        if os_profile is not None:
            self._values["os_profile"] = os_profile
        if priority is not None:
            self._values["priority"] = priority
        if scheduled_events_profile is not None:
            self._values["scheduled_events_profile"] = scheduled_events_profile
        if security_profile is not None:
            self._values["security_profile"] = security_profile
        if storage_profile is not None:
            self._values["storage_profile"] = storage_profile

    @builtins.property
    def billing_profile(
        self,
    ) -> typing.Optional[_VirtualMachineBillingProfile_b57d8936]:
        result = self._values.get("billing_profile")
        return typing.cast(typing.Optional[_VirtualMachineBillingProfile_b57d8936], result)

    @builtins.property
    def diagnostics_profile(
        self,
    ) -> typing.Optional[_VirtualMachineDiagnosticsProfile_05cee027]:
        result = self._values.get("diagnostics_profile")
        return typing.cast(typing.Optional[_VirtualMachineDiagnosticsProfile_05cee027], result)

    @builtins.property
    def eviction_policy(self) -> typing.Optional[builtins.str]:
        result = self._values.get("eviction_policy")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def extension_profile(self) -> typing.Optional[_ExtensionProfile_ec55a00c]:
        result = self._values.get("extension_profile")
        return typing.cast(typing.Optional[_ExtensionProfile_ec55a00c], result)

    @builtins.property
    def license_type(self) -> typing.Optional[builtins.str]:
        result = self._values.get("license_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def network_profile(
        self,
    ) -> typing.Optional[_VirtualMachineScaleSetNetworkProfile_e3604858]:
        result = self._values.get("network_profile")
        return typing.cast(typing.Optional[_VirtualMachineScaleSetNetworkProfile_e3604858], result)

    @builtins.property
    def os_profile(self) -> typing.Optional[_VirtualMachineScaleSetOSProfile_320ebb42]:
        result = self._values.get("os_profile")
        return typing.cast(typing.Optional[_VirtualMachineScaleSetOSProfile_320ebb42], result)

    @builtins.property
    def priority(self) -> typing.Optional[builtins.str]:
        result = self._values.get("priority")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def scheduled_events_profile(
        self,
    ) -> typing.Optional[_ScheduledEventsProfile_f4e5611c]:
        result = self._values.get("scheduled_events_profile")
        return typing.cast(typing.Optional[_ScheduledEventsProfile_f4e5611c], result)

    @builtins.property
    def security_profile(
        self,
    ) -> typing.Optional[_VirtualMachineSecurityProfile_59175751]:
        result = self._values.get("security_profile")
        return typing.cast(typing.Optional[_VirtualMachineSecurityProfile_59175751], result)

    @builtins.property
    def storage_profile(
        self,
    ) -> typing.Optional[_VirtualMachineStorageProfile_793daa4a]:
        result = self._values.get("storage_profile")
        return typing.cast(typing.Optional[_VirtualMachineStorageProfile_793daa4a], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VirtualMachineScaleSetVMProfile(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.VirtualMachineSecret",
    jsii_struct_bases=[],
    name_mapping={
        "source_vault": "sourceVault",
        "vault_certificates": "vaultCertificates",
    },
)
class VirtualMachineSecret:
    def __init__(
        self,
        *,
        source_vault: typing.Optional[typing.Union[_VirtualMachineSubResource_f7a6c8fb, typing.Dict[builtins.str, typing.Any]]] = None,
        vault_certificates: typing.Optional[typing.Sequence[typing.Union[_VirtualMachineVaultCertificate_60841248, typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''Secret for OS profile.

        :param source_vault: 
        :param vault_certificates: 
        '''
        if isinstance(source_vault, dict):
            source_vault = _VirtualMachineSubResource_f7a6c8fb(**source_vault)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2dcbb3efd12bb4bcfd467b18f718238bc8c02c5afbd1654b36a538254b7c2763)
            check_type(argname="argument source_vault", value=source_vault, expected_type=type_hints["source_vault"])
            check_type(argname="argument vault_certificates", value=vault_certificates, expected_type=type_hints["vault_certificates"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if source_vault is not None:
            self._values["source_vault"] = source_vault
        if vault_certificates is not None:
            self._values["vault_certificates"] = vault_certificates

    @builtins.property
    def source_vault(self) -> typing.Optional[_VirtualMachineSubResource_f7a6c8fb]:
        result = self._values.get("source_vault")
        return typing.cast(typing.Optional[_VirtualMachineSubResource_f7a6c8fb], result)

    @builtins.property
    def vault_certificates(
        self,
    ) -> typing.Optional[typing.List[_VirtualMachineVaultCertificate_60841248]]:
        result = self._values.get("vault_certificates")
        return typing.cast(typing.Optional[typing.List[_VirtualMachineVaultCertificate_60841248]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VirtualMachineSecret(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.VirtualMachineSecurityProfile",
    jsii_struct_bases=[],
    name_mapping={
        "encryption_at_host": "encryptionAtHost",
        "security_type": "securityType",
        "uefi_settings": "uefiSettings",
    },
)
class VirtualMachineSecurityProfile:
    def __init__(
        self,
        *,
        encryption_at_host: typing.Optional[builtins.bool] = None,
        security_type: typing.Optional[builtins.str] = None,
        uefi_settings: typing.Optional[typing.Union[_VirtualMachineUefiSettings_ba93462d, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Security profile.

        :param encryption_at_host: 
        :param security_type: 
        :param uefi_settings: 
        '''
        if isinstance(uefi_settings, dict):
            uefi_settings = _VirtualMachineUefiSettings_ba93462d(**uefi_settings)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2b93a4e40a67b9a909dfbea523d9336e3ad0897aaa270283ff940d1b5dc1b77a)
            check_type(argname="argument encryption_at_host", value=encryption_at_host, expected_type=type_hints["encryption_at_host"])
            check_type(argname="argument security_type", value=security_type, expected_type=type_hints["security_type"])
            check_type(argname="argument uefi_settings", value=uefi_settings, expected_type=type_hints["uefi_settings"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if encryption_at_host is not None:
            self._values["encryption_at_host"] = encryption_at_host
        if security_type is not None:
            self._values["security_type"] = security_type
        if uefi_settings is not None:
            self._values["uefi_settings"] = uefi_settings

    @builtins.property
    def encryption_at_host(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("encryption_at_host")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def security_type(self) -> typing.Optional[builtins.str]:
        result = self._values.get("security_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def uefi_settings(self) -> typing.Optional[_VirtualMachineUefiSettings_ba93462d]:
        result = self._values.get("uefi_settings")
        return typing.cast(typing.Optional[_VirtualMachineUefiSettings_ba93462d], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VirtualMachineSecurityProfile(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.VirtualMachineSshConfiguration",
    jsii_struct_bases=[],
    name_mapping={"public_keys": "publicKeys"},
)
class VirtualMachineSshConfiguration:
    def __init__(
        self,
        *,
        public_keys: typing.Optional[typing.Sequence[typing.Union[_VirtualMachineSshPublicKey_6551d0b0, typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''SSH configuration.

        :param public_keys: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bd02055a91c6f86aae8497d10e9473836a0ab7af3e0272a529654b43be82368d)
            check_type(argname="argument public_keys", value=public_keys, expected_type=type_hints["public_keys"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if public_keys is not None:
            self._values["public_keys"] = public_keys

    @builtins.property
    def public_keys(
        self,
    ) -> typing.Optional[typing.List[_VirtualMachineSshPublicKey_6551d0b0]]:
        result = self._values.get("public_keys")
        return typing.cast(typing.Optional[typing.List[_VirtualMachineSshPublicKey_6551d0b0]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VirtualMachineSshConfiguration(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.VirtualMachineSshPublicKey",
    jsii_struct_bases=[],
    name_mapping={"key_data": "keyData", "path": "path"},
)
class VirtualMachineSshPublicKey:
    def __init__(self, *, key_data: builtins.str, path: builtins.str) -> None:
        '''SSH public key.

        :param key_data: 
        :param path: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7d33509b6ce67ec15c4d254ea775823f070c0f9e56e312fea5770cd82258ba2b)
            check_type(argname="argument key_data", value=key_data, expected_type=type_hints["key_data"])
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "key_data": key_data,
            "path": path,
        }

    @builtins.property
    def key_data(self) -> builtins.str:
        result = self._values.get("key_data")
        assert result is not None, "Required property 'key_data' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def path(self) -> builtins.str:
        result = self._values.get("path")
        assert result is not None, "Required property 'path' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VirtualMachineSshPublicKey(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.VirtualMachineStorageProfile",
    jsii_struct_bases=[],
    name_mapping={
        "os_disk": "osDisk",
        "data_disks": "dataDisks",
        "image_reference": "imageReference",
    },
)
class VirtualMachineStorageProfile:
    def __init__(
        self,
        *,
        os_disk: typing.Union[_VirtualMachineOSDisk_582a6f94, typing.Dict[builtins.str, typing.Any]],
        data_disks: typing.Optional[typing.Sequence[typing.Union[_VirtualMachineDataDisk_839db3b6, typing.Dict[builtins.str, typing.Any]]]] = None,
        image_reference: typing.Optional[typing.Union[_VirtualMachineImageReference_f5fa193e, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Storage profile for the virtual machine.

        :param os_disk: 
        :param data_disks: 
        :param image_reference: 
        '''
        if isinstance(os_disk, dict):
            os_disk = _VirtualMachineOSDisk_582a6f94(**os_disk)
        if isinstance(image_reference, dict):
            image_reference = _VirtualMachineImageReference_f5fa193e(**image_reference)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ae1313f2db29d370d75fd0d9075b775b70e45ee6f45ba28d8ab0c917a93ce030)
            check_type(argname="argument os_disk", value=os_disk, expected_type=type_hints["os_disk"])
            check_type(argname="argument data_disks", value=data_disks, expected_type=type_hints["data_disks"])
            check_type(argname="argument image_reference", value=image_reference, expected_type=type_hints["image_reference"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "os_disk": os_disk,
        }
        if data_disks is not None:
            self._values["data_disks"] = data_disks
        if image_reference is not None:
            self._values["image_reference"] = image_reference

    @builtins.property
    def os_disk(self) -> _VirtualMachineOSDisk_582a6f94:
        result = self._values.get("os_disk")
        assert result is not None, "Required property 'os_disk' is missing"
        return typing.cast(_VirtualMachineOSDisk_582a6f94, result)

    @builtins.property
    def data_disks(
        self,
    ) -> typing.Optional[typing.List[_VirtualMachineDataDisk_839db3b6]]:
        result = self._values.get("data_disks")
        return typing.cast(typing.Optional[typing.List[_VirtualMachineDataDisk_839db3b6]], result)

    @builtins.property
    def image_reference(
        self,
    ) -> typing.Optional[_VirtualMachineImageReference_f5fa193e]:
        result = self._values.get("image_reference")
        return typing.cast(typing.Optional[_VirtualMachineImageReference_f5fa193e], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VirtualMachineStorageProfile(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.VirtualMachineSubResource",
    jsii_struct_bases=[],
    name_mapping={"id": "id"},
)
class VirtualMachineSubResource:
    def __init__(self, *, id: typing.Optional[builtins.str] = None) -> None:
        '''Sub-resource reference.

        :param id: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__542c5470191453d04b1ce96801a742c2d1e8a7c893190d8c02cad8978402d2f2)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if id is not None:
            self._values["id"] = id

    @builtins.property
    def id(self) -> typing.Optional[builtins.str]:
        result = self._values.get("id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VirtualMachineSubResource(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.VirtualMachineUefiSettings",
    jsii_struct_bases=[],
    name_mapping={
        "secure_boot_enabled": "secureBootEnabled",
        "v_tpm_enabled": "vTpmEnabled",
    },
)
class VirtualMachineUefiSettings:
    def __init__(
        self,
        *,
        secure_boot_enabled: typing.Optional[builtins.bool] = None,
        v_tpm_enabled: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''UEFI settings.

        :param secure_boot_enabled: 
        :param v_tpm_enabled: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0e95479a9b9ec182356e13dc88fd4087b32bd1ebafea2c06dd227e6d23536f1a)
            check_type(argname="argument secure_boot_enabled", value=secure_boot_enabled, expected_type=type_hints["secure_boot_enabled"])
            check_type(argname="argument v_tpm_enabled", value=v_tpm_enabled, expected_type=type_hints["v_tpm_enabled"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if secure_boot_enabled is not None:
            self._values["secure_boot_enabled"] = secure_boot_enabled
        if v_tpm_enabled is not None:
            self._values["v_tpm_enabled"] = v_tpm_enabled

    @builtins.property
    def secure_boot_enabled(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("secure_boot_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def v_tpm_enabled(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("v_tpm_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VirtualMachineUefiSettings(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.VirtualMachineVaultCertificate",
    jsii_struct_bases=[],
    name_mapping={
        "certificate_store": "certificateStore",
        "certificate_url": "certificateUrl",
    },
)
class VirtualMachineVaultCertificate:
    def __init__(
        self,
        *,
        certificate_store: typing.Optional[builtins.str] = None,
        certificate_url: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Vault certificate.

        :param certificate_store: 
        :param certificate_url: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__eb4b590f4c47c3e5578fd6d1513e186a8ccad21fb19b850e27db692226e9bf31)
            check_type(argname="argument certificate_store", value=certificate_store, expected_type=type_hints["certificate_store"])
            check_type(argname="argument certificate_url", value=certificate_url, expected_type=type_hints["certificate_url"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if certificate_store is not None:
            self._values["certificate_store"] = certificate_store
        if certificate_url is not None:
            self._values["certificate_url"] = certificate_url

    @builtins.property
    def certificate_store(self) -> typing.Optional[builtins.str]:
        result = self._values.get("certificate_store")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def certificate_url(self) -> typing.Optional[builtins.str]:
        result = self._values.get("certificate_url")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VirtualMachineVaultCertificate(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.VirtualMachineWinRMConfiguration",
    jsii_struct_bases=[],
    name_mapping={"listeners": "listeners"},
)
class VirtualMachineWinRMConfiguration:
    def __init__(
        self,
        *,
        listeners: typing.Optional[typing.Sequence[typing.Union[_VirtualMachineWinRMListener_85e51ce5, typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''WinRM configuration.

        :param listeners: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__36669ec5328e06a2fe299335b39669c061a0b80c2447da28bb3e953764934dba)
            check_type(argname="argument listeners", value=listeners, expected_type=type_hints["listeners"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if listeners is not None:
            self._values["listeners"] = listeners

    @builtins.property
    def listeners(
        self,
    ) -> typing.Optional[typing.List[_VirtualMachineWinRMListener_85e51ce5]]:
        result = self._values.get("listeners")
        return typing.cast(typing.Optional[typing.List[_VirtualMachineWinRMListener_85e51ce5]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VirtualMachineWinRMConfiguration(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.VirtualMachineWinRMListener",
    jsii_struct_bases=[],
    name_mapping={"protocol": "protocol", "certificate_url": "certificateUrl"},
)
class VirtualMachineWinRMListener:
    def __init__(
        self,
        *,
        protocol: builtins.str,
        certificate_url: typing.Optional[builtins.str] = None,
    ) -> None:
        '''WinRM listener.

        :param protocol: 
        :param certificate_url: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__91e2b5e82005d18d21cbd138461defb81ecb493f35e8267b7d8e5f1688409987)
            check_type(argname="argument protocol", value=protocol, expected_type=type_hints["protocol"])
            check_type(argname="argument certificate_url", value=certificate_url, expected_type=type_hints["certificate_url"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "protocol": protocol,
        }
        if certificate_url is not None:
            self._values["certificate_url"] = certificate_url

    @builtins.property
    def protocol(self) -> builtins.str:
        result = self._values.get("protocol")
        assert result is not None, "Required property 'protocol' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def certificate_url(self) -> typing.Optional[builtins.str]:
        result = self._values.get("certificate_url")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VirtualMachineWinRMListener(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.VirtualMachineWindowsConfiguration",
    jsii_struct_bases=[],
    name_mapping={
        "enable_automatic_updates": "enableAutomaticUpdates",
        "patch_settings": "patchSettings",
        "provision_vm_agent": "provisionVMAgent",
        "time_zone": "timeZone",
        "win_rm": "winRM",
    },
)
class VirtualMachineWindowsConfiguration:
    def __init__(
        self,
        *,
        enable_automatic_updates: typing.Optional[builtins.bool] = None,
        patch_settings: typing.Optional[typing.Union[_VirtualMachineWindowsPatchSettings_18b61ab1, typing.Dict[builtins.str, typing.Any]]] = None,
        provision_vm_agent: typing.Optional[builtins.bool] = None,
        time_zone: typing.Optional[builtins.str] = None,
        win_rm: typing.Optional[typing.Union[_VirtualMachineWinRMConfiguration_1df9a9c3, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Windows configuration.

        :param enable_automatic_updates: 
        :param patch_settings: 
        :param provision_vm_agent: 
        :param time_zone: 
        :param win_rm: 
        '''
        if isinstance(patch_settings, dict):
            patch_settings = _VirtualMachineWindowsPatchSettings_18b61ab1(**patch_settings)
        if isinstance(win_rm, dict):
            win_rm = _VirtualMachineWinRMConfiguration_1df9a9c3(**win_rm)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6222892f54c4fcd5fb989009725cbd313eb34a0e9700b8291482a506171d6580)
            check_type(argname="argument enable_automatic_updates", value=enable_automatic_updates, expected_type=type_hints["enable_automatic_updates"])
            check_type(argname="argument patch_settings", value=patch_settings, expected_type=type_hints["patch_settings"])
            check_type(argname="argument provision_vm_agent", value=provision_vm_agent, expected_type=type_hints["provision_vm_agent"])
            check_type(argname="argument time_zone", value=time_zone, expected_type=type_hints["time_zone"])
            check_type(argname="argument win_rm", value=win_rm, expected_type=type_hints["win_rm"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if enable_automatic_updates is not None:
            self._values["enable_automatic_updates"] = enable_automatic_updates
        if patch_settings is not None:
            self._values["patch_settings"] = patch_settings
        if provision_vm_agent is not None:
            self._values["provision_vm_agent"] = provision_vm_agent
        if time_zone is not None:
            self._values["time_zone"] = time_zone
        if win_rm is not None:
            self._values["win_rm"] = win_rm

    @builtins.property
    def enable_automatic_updates(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("enable_automatic_updates")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def patch_settings(
        self,
    ) -> typing.Optional[_VirtualMachineWindowsPatchSettings_18b61ab1]:
        result = self._values.get("patch_settings")
        return typing.cast(typing.Optional[_VirtualMachineWindowsPatchSettings_18b61ab1], result)

    @builtins.property
    def provision_vm_agent(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("provision_vm_agent")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def time_zone(self) -> typing.Optional[builtins.str]:
        result = self._values.get("time_zone")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def win_rm(self) -> typing.Optional[_VirtualMachineWinRMConfiguration_1df9a9c3]:
        result = self._values.get("win_rm")
        return typing.cast(typing.Optional[_VirtualMachineWinRMConfiguration_1df9a9c3], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VirtualMachineWindowsConfiguration(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.VirtualMachineWindowsPatchSettings",
    jsii_struct_bases=[],
    name_mapping={
        "assessment_mode": "assessmentMode",
        "enable_hotpatching": "enableHotpatching",
        "patch_mode": "patchMode",
    },
)
class VirtualMachineWindowsPatchSettings:
    def __init__(
        self,
        *,
        assessment_mode: typing.Optional[builtins.str] = None,
        enable_hotpatching: typing.Optional[builtins.bool] = None,
        patch_mode: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Windows patch settings.

        :param assessment_mode: 
        :param enable_hotpatching: 
        :param patch_mode: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d35d356136846745ec65dd5bc2d814049f97c9236f4f76b7748beec3c97f9bf3)
            check_type(argname="argument assessment_mode", value=assessment_mode, expected_type=type_hints["assessment_mode"])
            check_type(argname="argument enable_hotpatching", value=enable_hotpatching, expected_type=type_hints["enable_hotpatching"])
            check_type(argname="argument patch_mode", value=patch_mode, expected_type=type_hints["patch_mode"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if assessment_mode is not None:
            self._values["assessment_mode"] = assessment_mode
        if enable_hotpatching is not None:
            self._values["enable_hotpatching"] = enable_hotpatching
        if patch_mode is not None:
            self._values["patch_mode"] = patch_mode

    @builtins.property
    def assessment_mode(self) -> typing.Optional[builtins.str]:
        result = self._values.get("assessment_mode")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def enable_hotpatching(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("enable_hotpatching")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def patch_mode(self) -> typing.Optional[builtins.str]:
        result = self._values.get("patch_mode")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VirtualMachineWindowsPatchSettings(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class VirtualNetwork(
    _AzapiResource_7e7f5b39,
    metaclass=jsii.JSIIMeta,
    jsii_type="@microsoft/terraform-cdk-constructs.VirtualNetwork",
):
    '''Azure Virtual Network implementation.

    This class provides a single, version-aware implementation that replaces
    version-specific Virtual Network classes. It automatically handles version
    resolution, schema validation, and property transformation while maintaining
    full backward compatibility.

    Example::

        // Usage with explicit version pinning:
        const vnet = new VirtualNetwork(this, "vnet", {
          name: "my-vnet",
          location: "eastus",
          apiVersion: "2024-07-01",
          addressSpace: {
            addressPrefixes: ["10.0.0.0/16"]
          }
        });
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        address_space: typing.Union[_VirtualNetworkAddressSpace_f881cca1, typing.Dict[builtins.str, typing.Any]],
        dhcp_options: typing.Optional[typing.Union[_VirtualNetworkDhcpOptions_da8e9a61, typing.Dict[builtins.str, typing.Any]]] = None,
        enable_ddos_protection: typing.Optional[builtins.bool] = None,
        enable_vm_protection: typing.Optional[builtins.bool] = None,
        encryption: typing.Any = None,
        flow_timeout_in_minutes: typing.Optional[jsii.Number] = None,
        ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
        resource_group_id: typing.Optional[builtins.str] = None,
        subnets: typing.Optional[typing.Sequence[typing.Any]] = None,
        api_version: typing.Optional[builtins.str] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        location: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> None:
        '''Creates a new Azure Virtual Network using the AzapiResource framework.

        The constructor automatically handles version resolution, schema registration,
        validation, and resource creation. It maintains full backward compatibility
        with existing Virtual Network implementations.

        :param scope: - The scope in which to define this construct.
        :param id: - The unique identifier for this instance.
        :param address_space: Address space for the virtual network Must contain at least one address prefix.
        :param dhcp_options: DHCP options configuration Optional - configures DNS servers for the VNet.
        :param enable_ddos_protection: Enable DDoS protection for the virtual network Requires a DDoS protection plan. Default: false
        :param enable_vm_protection: Enable VM protection for the virtual network. Default: false
        :param encryption: Encryption settings for the virtual network Optional - configures encryption for the VNet.
        :param flow_timeout_in_minutes: Flow timeout in minutes for the virtual network Valid range: 4-30 minutes.
        :param ignore_changes: The lifecycle rules to ignore changes Useful for properties that are externally managed.
        :param resource_group_id: Resource group ID where the VNet will be created Optional - will use the subscription scope if not provided.
        :param subnets: Subnets to create within the virtual network Optional - subnets can also be created separately.
        :param api_version: Explicit API version to use for this resource. If not specified, the latest active version will be automatically resolved. Use this for version pinning when stability is required over latest features. Default: Latest active version from ApiVersionManager
        :param enable_migration_analysis: Whether to enable migration analysis warnings. When true, the framework will analyze the current version for deprecation status and provide migration recommendations in the deployment output. Default: true
        :param enable_transformation: Whether to apply property transformations automatically. When true, properties will be automatically transformed according to the target schema's transformation rules. This enables backward compatibility. Default: true
        :param enable_validation: Whether to validate properties against the schema. When true, all properties will be validated against the API schema before resource creation. Validation errors will cause deployment failures. Default: true
        :param location: The location where the resource should be created. Default: Varies by resource type - see specific resource documentation
        :param monitoring: Monitoring configuration for this resource. Enables integrated monitoring with diagnostic settings, metric alerts, and activity log alerts. All monitoring is optional and disabled by default.
        :param name: The name of the resource.
        :param tags: Tags to apply to the resource.
        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c451cbadd411e1088316a520222198adddcfdb8eaacfa6dccded4330ad372874)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = _VirtualNetworkProps_b95b42ef(
            address_space=address_space,
            dhcp_options=dhcp_options,
            enable_ddos_protection=enable_ddos_protection,
            enable_vm_protection=enable_vm_protection,
            encryption=encryption,
            flow_timeout_in_minutes=flow_timeout_in_minutes,
            ignore_changes=ignore_changes,
            resource_group_id=resource_group_id,
            subnets=subnets,
            api_version=api_version,
            enable_migration_analysis=enable_migration_analysis,
            enable_transformation=enable_transformation,
            enable_validation=enable_validation,
            location=location,
            monitoring=monitoring,
            name=name,
            tags=tags,
            connection=connection,
            count=count,
            depends_on=depends_on,
            for_each=for_each,
            lifecycle=lifecycle,
            provider=provider,
            provisioners=provisioners,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="addTag")
    def add_tag(self, key: builtins.str, value: builtins.str) -> None:
        '''Add a tag to the Virtual Network Note: This modifies the construct props but requires a new deployment to take effect.

        :param key: -
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1aa5b256fdbdaeefd7eccd283957536fda7c8004ba2371f1b743ce38856525b5)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "addTag", [key, value]))

    @jsii.member(jsii_name="apiSchema")
    def _api_schema(self) -> _ApiSchema_5ce0490e:
        '''Gets the API schema for the resolved version Uses the framework's schema resolution to get the appropriate schema.'''
        return typing.cast(_ApiSchema_5ce0490e, jsii.invoke(self, "apiSchema", []))

    @jsii.member(jsii_name="createResourceBody")
    def _create_resource_body(self, props: typing.Any) -> typing.Any:
        '''Creates the resource body for the Azure API call Transforms the input properties into the JSON format expected by Azure REST API.

        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f6197adca4afd14584815775ab1842de5897b3733c8f2edc1b3d00c170397b72)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Any, jsii.invoke(self, "createResourceBody", [props]))

    @jsii.member(jsii_name="defaultVersion")
    def _default_version(self) -> builtins.str:
        '''Gets the default API version to use when no explicit version is specified Returns the most recent stable version as the default.'''
        return typing.cast(builtins.str, jsii.invoke(self, "defaultVersion", []))

    @jsii.member(jsii_name="removeTag")
    def remove_tag(self, key: builtins.str) -> None:
        '''Remove a tag from the Virtual Network Note: This modifies the construct props but requires a new deployment to take effect.

        :param key: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__be6cfe6281abb67e65670fb58f6f0c129a4eccbf2be71874babaddc958bd8568)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
        return typing.cast(None, jsii.invoke(self, "removeTag", [key]))

    @jsii.member(jsii_name="requiresLocation")
    def _requires_location(self) -> builtins.bool:
        '''Indicates that location is required for Virtual Networks.'''
        return typing.cast(builtins.bool, jsii.invoke(self, "requiresLocation", []))

    @jsii.member(jsii_name="resourceType")
    def _resource_type(self) -> builtins.str:
        '''Gets the Azure resource type for Virtual Networks.'''
        return typing.cast(builtins.str, jsii.invoke(self, "resourceType", []))

    @builtins.property
    @jsii.member(jsii_name="addressSpace")
    def address_space(self) -> builtins.str:
        '''Get the address space output value Returns the Terraform interpolation string for the address space.'''
        return typing.cast(builtins.str, jsii.get(self, "addressSpace"))

    @builtins.property
    @jsii.member(jsii_name="addressSpaceOutput")
    def address_space_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "addressSpaceOutput"))

    @builtins.property
    @jsii.member(jsii_name="idOutput")
    def id_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "idOutput"))

    @builtins.property
    @jsii.member(jsii_name="locationOutput")
    def location_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "locationOutput"))

    @builtins.property
    @jsii.member(jsii_name="nameOutput")
    def name_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "nameOutput"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def props(self) -> _VirtualNetworkProps_b95b42ef:
        '''The input properties for this Virtual Network instance.'''
        return typing.cast(_VirtualNetworkProps_b95b42ef, jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="resourceId")
    def resource_id(self) -> builtins.str:
        '''Get the full resource identifier for use in other Azure resources Alias for the id property to match original interface.'''
        return typing.cast(builtins.str, jsii.get(self, "resourceId"))

    @builtins.property
    @jsii.member(jsii_name="subscriptionId")
    def subscription_id(self) -> builtins.str:
        '''Get the subscription ID from the Virtual Network ID Extracts the subscription ID from the Azure resource ID format.'''
        return typing.cast(builtins.str, jsii.get(self, "subscriptionId"))

    @builtins.property
    @jsii.member(jsii_name="tagsOutput")
    def tags_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "tagsOutput"))


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.VirtualNetworkAddressSpace",
    jsii_struct_bases=[],
    name_mapping={"address_prefixes": "addressPrefixes"},
)
class VirtualNetworkAddressSpace:
    def __init__(self, *, address_prefixes: typing.Sequence[builtins.str]) -> None:
        '''Address space configuration for Virtual Network.

        :param address_prefixes: Array of address prefixes in CIDR notation.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7d77034fb7de6190cf33e4ddaf2c6bfe41f6415ce041250bf570c3b4d7b764dc)
            check_type(argname="argument address_prefixes", value=address_prefixes, expected_type=type_hints["address_prefixes"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "address_prefixes": address_prefixes,
        }

    @builtins.property
    def address_prefixes(self) -> typing.List[builtins.str]:
        '''Array of address prefixes in CIDR notation.

        Example::

            ["10.0.0.0/16", "10.1.0.0/16"]
        '''
        result = self._values.get("address_prefixes")
        assert result is not None, "Required property 'address_prefixes' is missing"
        return typing.cast(typing.List[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VirtualNetworkAddressSpace(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.VirtualNetworkDhcpOptions",
    jsii_struct_bases=[],
    name_mapping={"dns_servers": "dnsServers"},
)
class VirtualNetworkDhcpOptions:
    def __init__(
        self,
        *,
        dns_servers: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''DHCP options configuration for Virtual Network.

        :param dns_servers: Array of DNS server IP addresses.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__014434e91af1d7817a3f40e0f25486d02e69e55e253cd53247b1e62785173528)
            check_type(argname="argument dns_servers", value=dns_servers, expected_type=type_hints["dns_servers"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if dns_servers is not None:
            self._values["dns_servers"] = dns_servers

    @builtins.property
    def dns_servers(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Array of DNS server IP addresses.

        Example::

            ["10.0.0.4", "10.0.0.5"]
        '''
        result = self._values.get("dns_servers")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VirtualNetworkDhcpOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class VirtualNetworkGateway(
    _AzapiResource_7e7f5b39,
    metaclass=jsii.JSIIMeta,
    jsii_type="@microsoft/terraform-cdk-constructs.VirtualNetworkGateway",
):
    '''Azure Virtual Network Gateway implementation.

    This class provides a single, version-aware implementation that replaces
    version-specific Virtual Network Gateway classes. It automatically handles version
    resolution, schema validation, and property transformation while maintaining
    full backward compatibility.

    Virtual Network Gateways are used to send encrypted traffic between Azure virtual
    networks and on-premises locations over the public Internet (VPN) or through
    Azure ExpressRoute circuits (ExpressRoute).

    Example::

        // Active-Active VPN Gateway:
        const vpnGateway = new VirtualNetworkGateway(this, "vpnGateway", {
          name: "my-vpn-gateway-aa",
          location: "eastus",
          resourceGroupId: resourceGroup.id,
          gatewayType: "Vpn",
          vpnType: "RouteBased",
          sku: {
            name: "VpnGw1",
            tier: "VpnGw1"
          },
          activeActive: true,
          ipConfigurations: [
            {
              name: "config1",
              subnetId: gatewaySubnet.id,
              publicIPAddressId: publicIp1.id
            },
            {
              name: "config2",
              subnetId: gatewaySubnet.id,
              publicIPAddressId: publicIp2.id
            }
          ]
        });
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        gateway_type: builtins.str,
        ip_configurations: typing.Sequence[typing.Union[_VirtualNetworkGatewayIpConfiguration_853eed86, typing.Dict[builtins.str, typing.Any]]],
        sku: typing.Union[_VirtualNetworkGatewaySku_46d6411c, typing.Dict[builtins.str, typing.Any]],
        active_active: typing.Optional[builtins.bool] = None,
        bgp_settings: typing.Optional[typing.Union[_VirtualNetworkGatewayBgpSettings_63ddc7c4, typing.Dict[builtins.str, typing.Any]]] = None,
        custom_routes: typing.Optional[typing.Union[_VirtualNetworkGatewayCustomRoutes_7b9fea86, typing.Dict[builtins.str, typing.Any]]] = None,
        enable_bgp: typing.Optional[builtins.bool] = None,
        enable_private_ip_address: typing.Optional[builtins.bool] = None,
        gateway_default_site: typing.Optional[typing.Union[_VirtualNetworkGatewayDefaultSite_7b6991ba, typing.Dict[builtins.str, typing.Any]]] = None,
        ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
        resource_group_id: typing.Optional[builtins.str] = None,
        vpn_client_configuration: typing.Optional[typing.Union[_VirtualNetworkGatewayVpnClientConfiguration_861b9698, typing.Dict[builtins.str, typing.Any]]] = None,
        vpn_gateway_generation: typing.Optional[builtins.str] = None,
        vpn_type: typing.Optional[builtins.str] = None,
        api_version: typing.Optional[builtins.str] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        location: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> None:
        '''Creates a new Azure Virtual Network Gateway using the AzapiResource framework.

        The constructor automatically handles version resolution, schema registration,
        validation, and resource creation. It maintains full backward compatibility
        with existing Virtual Network Gateway implementations.

        :param scope: - The scope in which to define this construct.
        :param id: - The unique identifier for this instance.
        :param gateway_type: Gateway type Must be either "Vpn" or "ExpressRoute".
        :param ip_configurations: IP configurations for the gateway At least one IP configuration is required Two IP configurations are required for active-active mode.
        :param sku: SKU configuration for the gateway.
        :param active_active: Enable active-active mode for the gateway Requires two IP configurations. Default: false
        :param bgp_settings: BGP settings for the gateway Required if enableBgp is true.
        :param custom_routes: Custom routes for the gateway.
        :param enable_bgp: Enable BGP for the gateway. Default: false
        :param enable_private_ip_address: Enable private IP address for the gateway. Default: false
        :param gateway_default_site: Default site for force tunneling.
        :param ignore_changes: The lifecycle rules to ignore changes Useful for properties that are externally managed.
        :param resource_group_id: Resource group ID where the Gateway will be created Optional - will use the subscription scope if not provided.
        :param vpn_client_configuration: VPN client configuration for point-to-site connections.
        :param vpn_gateway_generation: VPN gateway generation.
        :param vpn_type: VPN type for VPN gateways. Default: "RouteBased"
        :param api_version: Explicit API version to use for this resource. If not specified, the latest active version will be automatically resolved. Use this for version pinning when stability is required over latest features. Default: Latest active version from ApiVersionManager
        :param enable_migration_analysis: Whether to enable migration analysis warnings. When true, the framework will analyze the current version for deprecation status and provide migration recommendations in the deployment output. Default: true
        :param enable_transformation: Whether to apply property transformations automatically. When true, properties will be automatically transformed according to the target schema's transformation rules. This enables backward compatibility. Default: true
        :param enable_validation: Whether to validate properties against the schema. When true, all properties will be validated against the API schema before resource creation. Validation errors will cause deployment failures. Default: true
        :param location: The location where the resource should be created. Default: Varies by resource type - see specific resource documentation
        :param monitoring: Monitoring configuration for this resource. Enables integrated monitoring with diagnostic settings, metric alerts, and activity log alerts. All monitoring is optional and disabled by default.
        :param name: The name of the resource.
        :param tags: Tags to apply to the resource.
        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__751b27b357e1e4619b6620f3e46e36981865e1e18e25dc77a8e42c163edef46f)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = _VirtualNetworkGatewayProps_451d4fab(
            gateway_type=gateway_type,
            ip_configurations=ip_configurations,
            sku=sku,
            active_active=active_active,
            bgp_settings=bgp_settings,
            custom_routes=custom_routes,
            enable_bgp=enable_bgp,
            enable_private_ip_address=enable_private_ip_address,
            gateway_default_site=gateway_default_site,
            ignore_changes=ignore_changes,
            resource_group_id=resource_group_id,
            vpn_client_configuration=vpn_client_configuration,
            vpn_gateway_generation=vpn_gateway_generation,
            vpn_type=vpn_type,
            api_version=api_version,
            enable_migration_analysis=enable_migration_analysis,
            enable_transformation=enable_transformation,
            enable_validation=enable_validation,
            location=location,
            monitoring=monitoring,
            name=name,
            tags=tags,
            connection=connection,
            count=count,
            depends_on=depends_on,
            for_each=for_each,
            lifecycle=lifecycle,
            provider=provider,
            provisioners=provisioners,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="addTag")
    def add_tag(self, key: builtins.str, value: builtins.str) -> None:
        '''Add a tag to the Virtual Network Gateway Note: This modifies the construct props but requires a new deployment to take effect.

        :param key: -
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0d0d766e3ede9d84f1066f914a6b21c34424003392f65482e551f7b078b83975)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "addTag", [key, value]))

    @jsii.member(jsii_name="apiSchema")
    def _api_schema(self) -> _ApiSchema_5ce0490e:
        '''Gets the API schema for the resolved version Uses the framework's schema resolution to get the appropriate schema.'''
        return typing.cast(_ApiSchema_5ce0490e, jsii.invoke(self, "apiSchema", []))

    @jsii.member(jsii_name="createResourceBody")
    def _create_resource_body(self, props: typing.Any) -> typing.Any:
        '''Creates the resource body for the Azure API call Transforms the input properties into the JSON format expected by Azure REST API.

        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c847b06e877622dd838f85f1b2f34ebeccc067ff63a11be5fbf1bdfa1961ca7e)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Any, jsii.invoke(self, "createResourceBody", [props]))

    @jsii.member(jsii_name="defaultVersion")
    def _default_version(self) -> builtins.str:
        '''Gets the default API version to use when no explicit version is specified Returns the most recent stable version as the default.'''
        return typing.cast(builtins.str, jsii.invoke(self, "defaultVersion", []))

    @jsii.member(jsii_name="removeTag")
    def remove_tag(self, key: builtins.str) -> None:
        '''Remove a tag from the Virtual Network Gateway Note: This modifies the construct props but requires a new deployment to take effect.

        :param key: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__616331cc8dc16145ec0e643ee21d7fa6dbc3a5d927dcac1ad2e9c39a29525b92)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
        return typing.cast(None, jsii.invoke(self, "removeTag", [key]))

    @jsii.member(jsii_name="requiresLocation")
    def _requires_location(self) -> builtins.bool:
        '''Indicates that location is required for Virtual Network Gateways.'''
        return typing.cast(builtins.bool, jsii.invoke(self, "requiresLocation", []))

    @jsii.member(jsii_name="resourceType")
    def _resource_type(self) -> builtins.str:
        '''Gets the Azure resource type for Virtual Network Gateways.'''
        return typing.cast(builtins.str, jsii.invoke(self, "resourceType", []))

    @builtins.property
    @jsii.member(jsii_name="idOutput")
    def id_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "idOutput"))

    @builtins.property
    @jsii.member(jsii_name="locationOutput")
    def location_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "locationOutput"))

    @builtins.property
    @jsii.member(jsii_name="nameOutput")
    def name_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "nameOutput"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def props(self) -> _VirtualNetworkGatewayProps_451d4fab:
        '''The input properties for this Virtual Network Gateway instance.'''
        return typing.cast(_VirtualNetworkGatewayProps_451d4fab, jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="resourceId")
    def resource_id(self) -> builtins.str:
        '''Get the full resource identifier for use in other Azure resources Alias for the id property to match original interface.'''
        return typing.cast(builtins.str, jsii.get(self, "resourceId"))

    @builtins.property
    @jsii.member(jsii_name="subscriptionId")
    def subscription_id(self) -> builtins.str:
        '''Get the subscription ID from the Virtual Network Gateway ID Extracts the subscription ID from the Azure resource ID format.'''
        return typing.cast(builtins.str, jsii.get(self, "subscriptionId"))

    @builtins.property
    @jsii.member(jsii_name="tagsOutput")
    def tags_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "tagsOutput"))


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.VirtualNetworkGatewayBgpSettings",
    jsii_struct_bases=[],
    name_mapping={
        "asn": "asn",
        "bgp_peering_address": "bgpPeeringAddress",
        "bgp_peering_addresses": "bgpPeeringAddresses",
        "peer_weight": "peerWeight",
    },
)
class VirtualNetworkGatewayBgpSettings:
    def __init__(
        self,
        *,
        asn: typing.Optional[jsii.Number] = None,
        bgp_peering_address: typing.Optional[builtins.str] = None,
        bgp_peering_addresses: typing.Optional[typing.Sequence[typing.Any]] = None,
        peer_weight: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''BGP settings for Virtual Network Gateway.

        :param asn: BGP ASN (Autonomous System Number).
        :param bgp_peering_address: BGP peering address.
        :param bgp_peering_addresses: BGP peering addresses for active-active configuration.
        :param peer_weight: Weight added to routes learned from this BGP speaker.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f12e6b913e6bbf146fc36779fa80f858540c73b886d91b265c0616a7f2e7a746)
            check_type(argname="argument asn", value=asn, expected_type=type_hints["asn"])
            check_type(argname="argument bgp_peering_address", value=bgp_peering_address, expected_type=type_hints["bgp_peering_address"])
            check_type(argname="argument bgp_peering_addresses", value=bgp_peering_addresses, expected_type=type_hints["bgp_peering_addresses"])
            check_type(argname="argument peer_weight", value=peer_weight, expected_type=type_hints["peer_weight"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if asn is not None:
            self._values["asn"] = asn
        if bgp_peering_address is not None:
            self._values["bgp_peering_address"] = bgp_peering_address
        if bgp_peering_addresses is not None:
            self._values["bgp_peering_addresses"] = bgp_peering_addresses
        if peer_weight is not None:
            self._values["peer_weight"] = peer_weight

    @builtins.property
    def asn(self) -> typing.Optional[jsii.Number]:
        '''BGP ASN (Autonomous System Number).

        Example::

            65515
        '''
        result = self._values.get("asn")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def bgp_peering_address(self) -> typing.Optional[builtins.str]:
        '''BGP peering address.'''
        result = self._values.get("bgp_peering_address")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def bgp_peering_addresses(self) -> typing.Optional[typing.List[typing.Any]]:
        '''BGP peering addresses for active-active configuration.'''
        result = self._values.get("bgp_peering_addresses")
        return typing.cast(typing.Optional[typing.List[typing.Any]], result)

    @builtins.property
    def peer_weight(self) -> typing.Optional[jsii.Number]:
        '''Weight added to routes learned from this BGP speaker.'''
        result = self._values.get("peer_weight")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VirtualNetworkGatewayBgpSettings(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class VirtualNetworkGatewayConnection(
    _AzapiResource_7e7f5b39,
    metaclass=jsii.JSIIMeta,
    jsii_type="@microsoft/terraform-cdk-constructs.VirtualNetworkGatewayConnection",
):
    '''Azure Virtual Network Gateway Connection implementation.

    This class provides a single, version-aware implementation that replaces
    version-specific Virtual Network Gateway Connection classes. It automatically handles version
    resolution, schema validation, and property transformation while maintaining
    full backward compatibility.

    Virtual Network Gateway Connections establish connectivity between Virtual Network Gateways
    and other networking endpoints:

    - IPsec: Site-to-Site VPN connections to on-premises networks
    - Vnet2Vnet: VNet-to-VNet connections between Azure virtual networks
    - ExpressRoute: Private connections to Azure via ExpressRoute circuits

    Example::

        // IPsec Connection with Custom IPsec Policies:
        const customConnection = new VirtualNetworkGatewayConnection(this, "customConnection", {
          name: "my-custom-connection",
          location: "eastus",
          resourceGroupId: resourceGroup.id,
          connectionType: "IPsec",
          virtualNetworkGateway1: { id: vpnGateway.id },
          localNetworkGateway2: { id: localGateway.id },
          sharedKey: "mySecureSharedKey123!",
          connectionProtocol: "IKEv2",
          ipsecPolicies: [{
            dhGroup: "DHGroup14",
            ikeEncryption: "AES256",
            ikeIntegrity: "SHA256",
            ipsecEncryption: "AES256",
            ipsecIntegrity: "SHA256",
            pfsGroup: "PFS2048",
            saLifeTimeSeconds: 3600,
            saDataSizeKilobytes: 102400000
          }],
          usePolicyBasedTrafficSelectors: true
        });
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        connection_type: builtins.str,
        resource_group_id: builtins.str,
        virtual_network_gateway1: typing.Union[_GatewayReference_be6ddc95, typing.Dict[builtins.str, typing.Any]],
        authorization_key: typing.Optional[builtins.str] = None,
        connection_mode: typing.Optional[builtins.str] = None,
        connection_protocol: typing.Optional[builtins.str] = None,
        dpd_timeout_seconds: typing.Optional[jsii.Number] = None,
        egress_nat_rules: typing.Optional[typing.Sequence[typing.Union[_NatRuleReference_233246a9, typing.Dict[builtins.str, typing.Any]]]] = None,
        enable_bgp: typing.Optional[builtins.bool] = None,
        ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
        ingress_nat_rules: typing.Optional[typing.Sequence[typing.Union[_NatRuleReference_233246a9, typing.Dict[builtins.str, typing.Any]]]] = None,
        ipsec_policies: typing.Optional[typing.Sequence[typing.Union[_IpsecPolicy_1ea4f1e2, typing.Dict[builtins.str, typing.Any]]]] = None,
        local_network_gateway2: typing.Optional[typing.Union[_GatewayReference_be6ddc95, typing.Dict[builtins.str, typing.Any]]] = None,
        peer: typing.Optional[typing.Union[_PeerReference_619b2bd0, typing.Dict[builtins.str, typing.Any]]] = None,
        routing_weight: typing.Optional[jsii.Number] = None,
        shared_key: typing.Optional[builtins.str] = None,
        use_policy_based_traffic_selectors: typing.Optional[builtins.bool] = None,
        virtual_network_gateway2: typing.Optional[typing.Union[_GatewayReference_be6ddc95, typing.Dict[builtins.str, typing.Any]]] = None,
        api_version: typing.Optional[builtins.str] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        location: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> None:
        '''Creates a new Azure Virtual Network Gateway Connection using the AzapiResource framework.

        The constructor automatically handles version resolution, schema registration,
        validation, and resource creation. It maintains full backward compatibility
        with existing Virtual Network Gateway Connection implementations.

        :param scope: - The scope in which to define this construct.
        :param id: - The unique identifier for this instance.
        :param connection_type: Connection type Must be "IPsec", "Vnet2Vnet", or "ExpressRoute".
        :param resource_group_id: Resource group ID where the connection will be created.
        :param virtual_network_gateway1: Reference to the first virtual network gateway Required for all connection types.
        :param authorization_key: Authorization key for the ExpressRoute circuit Optional - for cross-subscription ExpressRoute connections.
        :param connection_mode: Connection mode. Default: "Default"
        :param connection_protocol: Connection protocol to use. Default: "IKEv2"
        :param dpd_timeout_seconds: DPD timeout in seconds.
        :param egress_nat_rules: Egress NAT rules.
        :param enable_bgp: Enable BGP for the connection. Default: false
        :param ignore_changes: The lifecycle rules to ignore changes.
        :param ingress_nat_rules: Ingress NAT rules.
        :param ipsec_policies: Custom IPsec policies.
        :param local_network_gateway2: Reference to the local network gateway Required for IPsec connections only.
        :param peer: Reference to the ExpressRoute circuit Required for ExpressRoute connections only.
        :param routing_weight: Routing weight for the connection.
        :param shared_key: Shared key for the connection Required for IPsec and Vnet2Vnet connections.
        :param use_policy_based_traffic_selectors: Enable policy-based traffic selectors. Default: false
        :param virtual_network_gateway2: Reference to the second virtual network gateway Required for Vnet2Vnet connections only.
        :param api_version: Explicit API version to use for this resource. If not specified, the latest active version will be automatically resolved. Use this for version pinning when stability is required over latest features. Default: Latest active version from ApiVersionManager
        :param enable_migration_analysis: Whether to enable migration analysis warnings. When true, the framework will analyze the current version for deprecation status and provide migration recommendations in the deployment output. Default: true
        :param enable_transformation: Whether to apply property transformations automatically. When true, properties will be automatically transformed according to the target schema's transformation rules. This enables backward compatibility. Default: true
        :param enable_validation: Whether to validate properties against the schema. When true, all properties will be validated against the API schema before resource creation. Validation errors will cause deployment failures. Default: true
        :param location: The location where the resource should be created. Default: Varies by resource type - see specific resource documentation
        :param monitoring: Monitoring configuration for this resource. Enables integrated monitoring with diagnostic settings, metric alerts, and activity log alerts. All monitoring is optional and disabled by default.
        :param name: The name of the resource.
        :param tags: Tags to apply to the resource.
        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__21a2492d28bdec4e84d3ea191dc20cef795a15aa831b1c8e975c5d30a6845918)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = _VirtualNetworkGatewayConnectionProps_887ddc7c(
            connection_type=connection_type,
            resource_group_id=resource_group_id,
            virtual_network_gateway1=virtual_network_gateway1,
            authorization_key=authorization_key,
            connection_mode=connection_mode,
            connection_protocol=connection_protocol,
            dpd_timeout_seconds=dpd_timeout_seconds,
            egress_nat_rules=egress_nat_rules,
            enable_bgp=enable_bgp,
            ignore_changes=ignore_changes,
            ingress_nat_rules=ingress_nat_rules,
            ipsec_policies=ipsec_policies,
            local_network_gateway2=local_network_gateway2,
            peer=peer,
            routing_weight=routing_weight,
            shared_key=shared_key,
            use_policy_based_traffic_selectors=use_policy_based_traffic_selectors,
            virtual_network_gateway2=virtual_network_gateway2,
            api_version=api_version,
            enable_migration_analysis=enable_migration_analysis,
            enable_transformation=enable_transformation,
            enable_validation=enable_validation,
            location=location,
            monitoring=monitoring,
            name=name,
            tags=tags,
            connection=connection,
            count=count,
            depends_on=depends_on,
            for_each=for_each,
            lifecycle=lifecycle,
            provider=provider,
            provisioners=provisioners,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="addTag")
    def add_tag(self, key: builtins.str, value: builtins.str) -> None:
        '''Add a tag to the Virtual Network Gateway Connection Note: This modifies the construct props but requires a new deployment to take effect.

        :param key: -
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e8d60249a799463a775d8628ca4a063558d0c6765131af3f8d70b52d2abe4625)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "addTag", [key, value]))

    @jsii.member(jsii_name="apiSchema")
    def _api_schema(self) -> _ApiSchema_5ce0490e:
        '''Gets the API schema for the resolved version Uses the framework's schema resolution to get the appropriate schema.'''
        return typing.cast(_ApiSchema_5ce0490e, jsii.invoke(self, "apiSchema", []))

    @jsii.member(jsii_name="createResourceBody")
    def _create_resource_body(self, props: typing.Any) -> typing.Any:
        '''Creates the resource body for the Azure API call Transforms the input properties into the JSON format expected by Azure REST API Handles type-specific properties based on connectionType.

        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__458e68ad25f7a63d51d61ec0ed04891cc6a6a87b9c71a54f215248f0d295c623)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Any, jsii.invoke(self, "createResourceBody", [props]))

    @jsii.member(jsii_name="defaultVersion")
    def _default_version(self) -> builtins.str:
        '''Gets the default API version to use when no explicit version is specified Returns the most recent stable version as the default.'''
        return typing.cast(builtins.str, jsii.invoke(self, "defaultVersion", []))

    @jsii.member(jsii_name="removeTag")
    def remove_tag(self, key: builtins.str) -> None:
        '''Remove a tag from the Virtual Network Gateway Connection Note: This modifies the construct props but requires a new deployment to take effect.

        :param key: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__33af03d2e6f6e0794e75315cf4683cf632e1ba0c6894d0b35a0c7b6596221245)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
        return typing.cast(None, jsii.invoke(self, "removeTag", [key]))

    @jsii.member(jsii_name="requiresLocation")
    def _requires_location(self) -> builtins.bool:
        '''Indicates that location is required for Virtual Network Gateway Connections.'''
        return typing.cast(builtins.bool, jsii.invoke(self, "requiresLocation", []))

    @jsii.member(jsii_name="resourceType")
    def _resource_type(self) -> builtins.str:
        '''Gets the Azure resource type for Virtual Network Gateway Connections.'''
        return typing.cast(builtins.str, jsii.invoke(self, "resourceType", []))

    @builtins.property
    @jsii.member(jsii_name="idOutput")
    def id_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "idOutput"))

    @builtins.property
    @jsii.member(jsii_name="locationOutput")
    def location_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "locationOutput"))

    @builtins.property
    @jsii.member(jsii_name="nameOutput")
    def name_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "nameOutput"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def props(self) -> _VirtualNetworkGatewayConnectionProps_887ddc7c:
        '''The input properties for this Virtual Network Gateway Connection instance.'''
        return typing.cast(_VirtualNetworkGatewayConnectionProps_887ddc7c, jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="resourceId")
    def resource_id(self) -> builtins.str:
        '''Get the full resource identifier for use in other Azure resources Alias for the id property to match original interface.'''
        return typing.cast(builtins.str, jsii.get(self, "resourceId"))

    @builtins.property
    @jsii.member(jsii_name="subscriptionId")
    def subscription_id(self) -> builtins.str:
        '''Get the subscription ID from the Virtual Network Gateway Connection ID Extracts the subscription ID from the Azure resource ID format.'''
        return typing.cast(builtins.str, jsii.get(self, "subscriptionId"))

    @builtins.property
    @jsii.member(jsii_name="tagsOutput")
    def tags_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "tagsOutput"))


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.VirtualNetworkGatewayConnectionProps",
    jsii_struct_bases=[_AzapiResourceProps_141a2340],
    name_mapping={
        "connection": "connection",
        "count": "count",
        "depends_on": "dependsOn",
        "for_each": "forEach",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "provisioners": "provisioners",
        "api_version": "apiVersion",
        "enable_migration_analysis": "enableMigrationAnalysis",
        "enable_transformation": "enableTransformation",
        "enable_validation": "enableValidation",
        "location": "location",
        "monitoring": "monitoring",
        "name": "name",
        "tags": "tags",
        "connection_type": "connectionType",
        "resource_group_id": "resourceGroupId",
        "virtual_network_gateway1": "virtualNetworkGateway1",
        "authorization_key": "authorizationKey",
        "connection_mode": "connectionMode",
        "connection_protocol": "connectionProtocol",
        "dpd_timeout_seconds": "dpdTimeoutSeconds",
        "egress_nat_rules": "egressNatRules",
        "enable_bgp": "enableBgp",
        "ignore_changes": "ignoreChanges",
        "ingress_nat_rules": "ingressNatRules",
        "ipsec_policies": "ipsecPolicies",
        "local_network_gateway2": "localNetworkGateway2",
        "peer": "peer",
        "routing_weight": "routingWeight",
        "shared_key": "sharedKey",
        "use_policy_based_traffic_selectors": "usePolicyBasedTrafficSelectors",
        "virtual_network_gateway2": "virtualNetworkGateway2",
    },
)
class VirtualNetworkGatewayConnectionProps(_AzapiResourceProps_141a2340):
    def __init__(
        self,
        *,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
        api_version: typing.Optional[builtins.str] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        location: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        connection_type: builtins.str,
        resource_group_id: builtins.str,
        virtual_network_gateway1: typing.Union[_GatewayReference_be6ddc95, typing.Dict[builtins.str, typing.Any]],
        authorization_key: typing.Optional[builtins.str] = None,
        connection_mode: typing.Optional[builtins.str] = None,
        connection_protocol: typing.Optional[builtins.str] = None,
        dpd_timeout_seconds: typing.Optional[jsii.Number] = None,
        egress_nat_rules: typing.Optional[typing.Sequence[typing.Union[_NatRuleReference_233246a9, typing.Dict[builtins.str, typing.Any]]]] = None,
        enable_bgp: typing.Optional[builtins.bool] = None,
        ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
        ingress_nat_rules: typing.Optional[typing.Sequence[typing.Union[_NatRuleReference_233246a9, typing.Dict[builtins.str, typing.Any]]]] = None,
        ipsec_policies: typing.Optional[typing.Sequence[typing.Union[_IpsecPolicy_1ea4f1e2, typing.Dict[builtins.str, typing.Any]]]] = None,
        local_network_gateway2: typing.Optional[typing.Union[_GatewayReference_be6ddc95, typing.Dict[builtins.str, typing.Any]]] = None,
        peer: typing.Optional[typing.Union[_PeerReference_619b2bd0, typing.Dict[builtins.str, typing.Any]]] = None,
        routing_weight: typing.Optional[jsii.Number] = None,
        shared_key: typing.Optional[builtins.str] = None,
        use_policy_based_traffic_selectors: typing.Optional[builtins.bool] = None,
        virtual_network_gateway2: typing.Optional[typing.Union[_GatewayReference_be6ddc95, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Properties for the Azure Virtual Network Gateway Connection.

        Supports three connection types: IPsec (Site-to-Site), VNet-to-VNet, and ExpressRoute

        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        :param api_version: Explicit API version to use for this resource. If not specified, the latest active version will be automatically resolved. Use this for version pinning when stability is required over latest features. Default: Latest active version from ApiVersionManager
        :param enable_migration_analysis: Whether to enable migration analysis warnings. When true, the framework will analyze the current version for deprecation status and provide migration recommendations in the deployment output. Default: true
        :param enable_transformation: Whether to apply property transformations automatically. When true, properties will be automatically transformed according to the target schema's transformation rules. This enables backward compatibility. Default: true
        :param enable_validation: Whether to validate properties against the schema. When true, all properties will be validated against the API schema before resource creation. Validation errors will cause deployment failures. Default: true
        :param location: The location where the resource should be created. Default: Varies by resource type - see specific resource documentation
        :param monitoring: Monitoring configuration for this resource. Enables integrated monitoring with diagnostic settings, metric alerts, and activity log alerts. All monitoring is optional and disabled by default.
        :param name: The name of the resource.
        :param tags: Tags to apply to the resource.
        :param connection_type: Connection type Must be "IPsec", "Vnet2Vnet", or "ExpressRoute".
        :param resource_group_id: Resource group ID where the connection will be created.
        :param virtual_network_gateway1: Reference to the first virtual network gateway Required for all connection types.
        :param authorization_key: Authorization key for the ExpressRoute circuit Optional - for cross-subscription ExpressRoute connections.
        :param connection_mode: Connection mode. Default: "Default"
        :param connection_protocol: Connection protocol to use. Default: "IKEv2"
        :param dpd_timeout_seconds: DPD timeout in seconds.
        :param egress_nat_rules: Egress NAT rules.
        :param enable_bgp: Enable BGP for the connection. Default: false
        :param ignore_changes: The lifecycle rules to ignore changes.
        :param ingress_nat_rules: Ingress NAT rules.
        :param ipsec_policies: Custom IPsec policies.
        :param local_network_gateway2: Reference to the local network gateway Required for IPsec connections only.
        :param peer: Reference to the ExpressRoute circuit Required for ExpressRoute connections only.
        :param routing_weight: Routing weight for the connection.
        :param shared_key: Shared key for the connection Required for IPsec and Vnet2Vnet connections.
        :param use_policy_based_traffic_selectors: Enable policy-based traffic selectors. Default: false
        :param virtual_network_gateway2: Reference to the second virtual network gateway Required for Vnet2Vnet connections only.
        '''
        if isinstance(lifecycle, dict):
            lifecycle = _cdktf_9a9027ec.TerraformResourceLifecycle(**lifecycle)
        if isinstance(monitoring, dict):
            monitoring = _MonitoringConfig_7c28df74(**monitoring)
        if isinstance(virtual_network_gateway1, dict):
            virtual_network_gateway1 = _GatewayReference_be6ddc95(**virtual_network_gateway1)
        if isinstance(local_network_gateway2, dict):
            local_network_gateway2 = _GatewayReference_be6ddc95(**local_network_gateway2)
        if isinstance(peer, dict):
            peer = _PeerReference_619b2bd0(**peer)
        if isinstance(virtual_network_gateway2, dict):
            virtual_network_gateway2 = _GatewayReference_be6ddc95(**virtual_network_gateway2)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__35943d06799c0baffb77dee03d12888ae5c88f6da171b7e359c001b83c697296)
            check_type(argname="argument connection", value=connection, expected_type=type_hints["connection"])
            check_type(argname="argument count", value=count, expected_type=type_hints["count"])
            check_type(argname="argument depends_on", value=depends_on, expected_type=type_hints["depends_on"])
            check_type(argname="argument for_each", value=for_each, expected_type=type_hints["for_each"])
            check_type(argname="argument lifecycle", value=lifecycle, expected_type=type_hints["lifecycle"])
            check_type(argname="argument provider", value=provider, expected_type=type_hints["provider"])
            check_type(argname="argument provisioners", value=provisioners, expected_type=type_hints["provisioners"])
            check_type(argname="argument api_version", value=api_version, expected_type=type_hints["api_version"])
            check_type(argname="argument enable_migration_analysis", value=enable_migration_analysis, expected_type=type_hints["enable_migration_analysis"])
            check_type(argname="argument enable_transformation", value=enable_transformation, expected_type=type_hints["enable_transformation"])
            check_type(argname="argument enable_validation", value=enable_validation, expected_type=type_hints["enable_validation"])
            check_type(argname="argument location", value=location, expected_type=type_hints["location"])
            check_type(argname="argument monitoring", value=monitoring, expected_type=type_hints["monitoring"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument connection_type", value=connection_type, expected_type=type_hints["connection_type"])
            check_type(argname="argument resource_group_id", value=resource_group_id, expected_type=type_hints["resource_group_id"])
            check_type(argname="argument virtual_network_gateway1", value=virtual_network_gateway1, expected_type=type_hints["virtual_network_gateway1"])
            check_type(argname="argument authorization_key", value=authorization_key, expected_type=type_hints["authorization_key"])
            check_type(argname="argument connection_mode", value=connection_mode, expected_type=type_hints["connection_mode"])
            check_type(argname="argument connection_protocol", value=connection_protocol, expected_type=type_hints["connection_protocol"])
            check_type(argname="argument dpd_timeout_seconds", value=dpd_timeout_seconds, expected_type=type_hints["dpd_timeout_seconds"])
            check_type(argname="argument egress_nat_rules", value=egress_nat_rules, expected_type=type_hints["egress_nat_rules"])
            check_type(argname="argument enable_bgp", value=enable_bgp, expected_type=type_hints["enable_bgp"])
            check_type(argname="argument ignore_changes", value=ignore_changes, expected_type=type_hints["ignore_changes"])
            check_type(argname="argument ingress_nat_rules", value=ingress_nat_rules, expected_type=type_hints["ingress_nat_rules"])
            check_type(argname="argument ipsec_policies", value=ipsec_policies, expected_type=type_hints["ipsec_policies"])
            check_type(argname="argument local_network_gateway2", value=local_network_gateway2, expected_type=type_hints["local_network_gateway2"])
            check_type(argname="argument peer", value=peer, expected_type=type_hints["peer"])
            check_type(argname="argument routing_weight", value=routing_weight, expected_type=type_hints["routing_weight"])
            check_type(argname="argument shared_key", value=shared_key, expected_type=type_hints["shared_key"])
            check_type(argname="argument use_policy_based_traffic_selectors", value=use_policy_based_traffic_selectors, expected_type=type_hints["use_policy_based_traffic_selectors"])
            check_type(argname="argument virtual_network_gateway2", value=virtual_network_gateway2, expected_type=type_hints["virtual_network_gateway2"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "connection_type": connection_type,
            "resource_group_id": resource_group_id,
            "virtual_network_gateway1": virtual_network_gateway1,
        }
        if connection is not None:
            self._values["connection"] = connection
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if for_each is not None:
            self._values["for_each"] = for_each
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider
        if provisioners is not None:
            self._values["provisioners"] = provisioners
        if api_version is not None:
            self._values["api_version"] = api_version
        if enable_migration_analysis is not None:
            self._values["enable_migration_analysis"] = enable_migration_analysis
        if enable_transformation is not None:
            self._values["enable_transformation"] = enable_transformation
        if enable_validation is not None:
            self._values["enable_validation"] = enable_validation
        if location is not None:
            self._values["location"] = location
        if monitoring is not None:
            self._values["monitoring"] = monitoring
        if name is not None:
            self._values["name"] = name
        if tags is not None:
            self._values["tags"] = tags
        if authorization_key is not None:
            self._values["authorization_key"] = authorization_key
        if connection_mode is not None:
            self._values["connection_mode"] = connection_mode
        if connection_protocol is not None:
            self._values["connection_protocol"] = connection_protocol
        if dpd_timeout_seconds is not None:
            self._values["dpd_timeout_seconds"] = dpd_timeout_seconds
        if egress_nat_rules is not None:
            self._values["egress_nat_rules"] = egress_nat_rules
        if enable_bgp is not None:
            self._values["enable_bgp"] = enable_bgp
        if ignore_changes is not None:
            self._values["ignore_changes"] = ignore_changes
        if ingress_nat_rules is not None:
            self._values["ingress_nat_rules"] = ingress_nat_rules
        if ipsec_policies is not None:
            self._values["ipsec_policies"] = ipsec_policies
        if local_network_gateway2 is not None:
            self._values["local_network_gateway2"] = local_network_gateway2
        if peer is not None:
            self._values["peer"] = peer
        if routing_weight is not None:
            self._values["routing_weight"] = routing_weight
        if shared_key is not None:
            self._values["shared_key"] = shared_key
        if use_policy_based_traffic_selectors is not None:
            self._values["use_policy_based_traffic_selectors"] = use_policy_based_traffic_selectors
        if virtual_network_gateway2 is not None:
            self._values["virtual_network_gateway2"] = virtual_network_gateway2

    @builtins.property
    def connection(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("connection")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]], result)

    @builtins.property
    def count(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]], result)

    @builtins.property
    def depends_on(
        self,
    ) -> typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]], result)

    @builtins.property
    def for_each(self) -> typing.Optional[_cdktf_9a9027ec.ITerraformIterator]:
        '''
        :stability: experimental
        '''
        result = self._values.get("for_each")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.ITerraformIterator], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[_cdktf_9a9027ec.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformProvider], result)

    @builtins.property
    def provisioners(
        self,
    ) -> typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provisioners")
        return typing.cast(typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]], result)

    @builtins.property
    def api_version(self) -> typing.Optional[builtins.str]:
        '''Explicit API version to use for this resource.

        If not specified, the latest active version will be automatically resolved.
        Use this for version pinning when stability is required over latest features.

        :default: Latest active version from ApiVersionManager

        Example::

            "2024-11-01"
        '''
        result = self._values.get("api_version")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def enable_migration_analysis(self) -> typing.Optional[builtins.bool]:
        '''Whether to enable migration analysis warnings.

        When true, the framework will analyze the current version for deprecation
        status and provide migration recommendations in the deployment output.

        :default: true
        '''
        result = self._values.get("enable_migration_analysis")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_transformation(self) -> typing.Optional[builtins.bool]:
        '''Whether to apply property transformations automatically.

        When true, properties will be automatically transformed according to the
        target schema's transformation rules. This enables backward compatibility.

        :default: true
        '''
        result = self._values.get("enable_transformation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_validation(self) -> typing.Optional[builtins.bool]:
        '''Whether to validate properties against the schema.

        When true, all properties will be validated against the API schema before
        resource creation. Validation errors will cause deployment failures.

        :default: true
        '''
        result = self._values.get("enable_validation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def location(self) -> typing.Optional[builtins.str]:
        '''The location where the resource should be created.

        :default: Varies by resource type - see specific resource documentation

        :remarks:

        Location handling varies by resource type:

        - **Top-level resources**: Most require an explicit location (e.g., "eastus", "westus")
        - **Global resources**: Some use "global" as location (e.g., Private DNS Zones)
        - **Child resources**: Inherit location from parent and should NOT set this property

        Each resource type may provide its own default through the ``resolveLocation()`` method.
        If no location is specified and no default exists, resource creation may fail.

        Example::

            // Child resource (Subnet) - do not set location
            // location: undefined (inherited from parent Virtual Network)
        '''
        result = self._values.get("location")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def monitoring(self) -> typing.Optional[_MonitoringConfig_7c28df74]:
        '''Monitoring configuration for this resource.

        Enables integrated monitoring with diagnostic settings, metric alerts,
        and activity log alerts. All monitoring is optional and disabled by default.

        Example::

            monitoring: {
              enabled: true,
              diagnosticSettings: {
                workspaceId: logAnalytics.id,
                metrics: ['AllMetrics'],
                logs: ['AuditLogs']
              },
              metricAlerts: [{
                name: 'high-cpu-alert',
                severity: 2,
                scopes: [], // Automatically set to this resource
                criteria: { ... },
                actions: [{ actionGroupId: actionGroup.id }]
              }]
            }
        '''
        result = self._values.get("monitoring")
        return typing.cast(typing.Optional[_MonitoringConfig_7c28df74], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the resource.'''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Tags to apply to the resource.'''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def connection_type(self) -> builtins.str:
        '''Connection type Must be "IPsec", "Vnet2Vnet", or "ExpressRoute".'''
        result = self._values.get("connection_type")
        assert result is not None, "Required property 'connection_type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def resource_group_id(self) -> builtins.str:
        '''Resource group ID where the connection will be created.'''
        result = self._values.get("resource_group_id")
        assert result is not None, "Required property 'resource_group_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def virtual_network_gateway1(self) -> _GatewayReference_be6ddc95:
        '''Reference to the first virtual network gateway Required for all connection types.'''
        result = self._values.get("virtual_network_gateway1")
        assert result is not None, "Required property 'virtual_network_gateway1' is missing"
        return typing.cast(_GatewayReference_be6ddc95, result)

    @builtins.property
    def authorization_key(self) -> typing.Optional[builtins.str]:
        '''Authorization key for the ExpressRoute circuit Optional - for cross-subscription ExpressRoute connections.'''
        result = self._values.get("authorization_key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def connection_mode(self) -> typing.Optional[builtins.str]:
        '''Connection mode.

        :default: "Default"
        '''
        result = self._values.get("connection_mode")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def connection_protocol(self) -> typing.Optional[builtins.str]:
        '''Connection protocol to use.

        :default: "IKEv2"
        '''
        result = self._values.get("connection_protocol")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def dpd_timeout_seconds(self) -> typing.Optional[jsii.Number]:
        '''DPD timeout in seconds.'''
        result = self._values.get("dpd_timeout_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def egress_nat_rules(
        self,
    ) -> typing.Optional[typing.List[_NatRuleReference_233246a9]]:
        '''Egress NAT rules.'''
        result = self._values.get("egress_nat_rules")
        return typing.cast(typing.Optional[typing.List[_NatRuleReference_233246a9]], result)

    @builtins.property
    def enable_bgp(self) -> typing.Optional[builtins.bool]:
        '''Enable BGP for the connection.

        :default: false
        '''
        result = self._values.get("enable_bgp")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def ignore_changes(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The lifecycle rules to ignore changes.

        Example::

            ["tags"]
        '''
        result = self._values.get("ignore_changes")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def ingress_nat_rules(
        self,
    ) -> typing.Optional[typing.List[_NatRuleReference_233246a9]]:
        '''Ingress NAT rules.'''
        result = self._values.get("ingress_nat_rules")
        return typing.cast(typing.Optional[typing.List[_NatRuleReference_233246a9]], result)

    @builtins.property
    def ipsec_policies(self) -> typing.Optional[typing.List[_IpsecPolicy_1ea4f1e2]]:
        '''Custom IPsec policies.'''
        result = self._values.get("ipsec_policies")
        return typing.cast(typing.Optional[typing.List[_IpsecPolicy_1ea4f1e2]], result)

    @builtins.property
    def local_network_gateway2(self) -> typing.Optional[_GatewayReference_be6ddc95]:
        '''Reference to the local network gateway Required for IPsec connections only.'''
        result = self._values.get("local_network_gateway2")
        return typing.cast(typing.Optional[_GatewayReference_be6ddc95], result)

    @builtins.property
    def peer(self) -> typing.Optional[_PeerReference_619b2bd0]:
        '''Reference to the ExpressRoute circuit Required for ExpressRoute connections only.'''
        result = self._values.get("peer")
        return typing.cast(typing.Optional[_PeerReference_619b2bd0], result)

    @builtins.property
    def routing_weight(self) -> typing.Optional[jsii.Number]:
        '''Routing weight for the connection.'''
        result = self._values.get("routing_weight")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def shared_key(self) -> typing.Optional[builtins.str]:
        '''Shared key for the connection Required for IPsec and Vnet2Vnet connections.'''
        result = self._values.get("shared_key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def use_policy_based_traffic_selectors(self) -> typing.Optional[builtins.bool]:
        '''Enable policy-based traffic selectors.

        :default: false
        '''
        result = self._values.get("use_policy_based_traffic_selectors")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def virtual_network_gateway2(self) -> typing.Optional[_GatewayReference_be6ddc95]:
        '''Reference to the second virtual network gateway Required for Vnet2Vnet connections only.'''
        result = self._values.get("virtual_network_gateway2")
        return typing.cast(typing.Optional[_GatewayReference_be6ddc95], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VirtualNetworkGatewayConnectionProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.VirtualNetworkGatewayCustomRoutes",
    jsii_struct_bases=[],
    name_mapping={"address_prefixes": "addressPrefixes"},
)
class VirtualNetworkGatewayCustomRoutes:
    def __init__(
        self,
        *,
        address_prefixes: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''Custom routes configuration.

        :param address_prefixes: List of address prefixes.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__366de0e9be541f9ed2f0a00ee2d969d395e438d4f341b2a420a61071e9fc3062)
            check_type(argname="argument address_prefixes", value=address_prefixes, expected_type=type_hints["address_prefixes"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if address_prefixes is not None:
            self._values["address_prefixes"] = address_prefixes

    @builtins.property
    def address_prefixes(self) -> typing.Optional[typing.List[builtins.str]]:
        '''List of address prefixes.'''
        result = self._values.get("address_prefixes")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VirtualNetworkGatewayCustomRoutes(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.VirtualNetworkGatewayDefaultSite",
    jsii_struct_bases=[],
    name_mapping={"id": "id"},
)
class VirtualNetworkGatewayDefaultSite:
    def __init__(self, *, id: builtins.str) -> None:
        '''Gateway default site reference.

        :param id: Resource ID of the local network gateway to use as default site.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b3d375e1f6ed1d212c3fb83c0eafd715721e7597f7e96d01e5dd3e29876271fe)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "id": id,
        }

    @builtins.property
    def id(self) -> builtins.str:
        '''Resource ID of the local network gateway to use as default site.'''
        result = self._values.get("id")
        assert result is not None, "Required property 'id' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VirtualNetworkGatewayDefaultSite(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.VirtualNetworkGatewayIpConfiguration",
    jsii_struct_bases=[],
    name_mapping={
        "name": "name",
        "public_ip_address_id": "publicIPAddressId",
        "subnet_id": "subnetId",
        "private_ip_allocation_method": "privateIPAllocationMethod",
    },
)
class VirtualNetworkGatewayIpConfiguration:
    def __init__(
        self,
        *,
        name: builtins.str,
        public_ip_address_id: builtins.str,
        subnet_id: builtins.str,
        private_ip_allocation_method: typing.Optional[builtins.str] = None,
    ) -> None:
        '''IP configuration for Virtual Network Gateway.

        :param name: Name of the IP configuration.
        :param public_ip_address_id: ID of the public IP address to use.
        :param subnet_id: ID of the subnet to use (must be GatewaySubnet).
        :param private_ip_allocation_method: Private IP allocation method. Default: "Dynamic"
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__324eca3aa96d54593a4d62490183d5c50e9703d5efb80ec9185dbb413186a23f)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument public_ip_address_id", value=public_ip_address_id, expected_type=type_hints["public_ip_address_id"])
            check_type(argname="argument subnet_id", value=subnet_id, expected_type=type_hints["subnet_id"])
            check_type(argname="argument private_ip_allocation_method", value=private_ip_allocation_method, expected_type=type_hints["private_ip_allocation_method"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
            "public_ip_address_id": public_ip_address_id,
            "subnet_id": subnet_id,
        }
        if private_ip_allocation_method is not None:
            self._values["private_ip_allocation_method"] = private_ip_allocation_method

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of the IP configuration.'''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def public_ip_address_id(self) -> builtins.str:
        '''ID of the public IP address to use.'''
        result = self._values.get("public_ip_address_id")
        assert result is not None, "Required property 'public_ip_address_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def subnet_id(self) -> builtins.str:
        '''ID of the subnet to use (must be GatewaySubnet).'''
        result = self._values.get("subnet_id")
        assert result is not None, "Required property 'subnet_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def private_ip_allocation_method(self) -> typing.Optional[builtins.str]:
        '''Private IP allocation method.

        :default: "Dynamic"
        '''
        result = self._values.get("private_ip_allocation_method")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VirtualNetworkGatewayIpConfiguration(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.VirtualNetworkGatewayProps",
    jsii_struct_bases=[_AzapiResourceProps_141a2340],
    name_mapping={
        "connection": "connection",
        "count": "count",
        "depends_on": "dependsOn",
        "for_each": "forEach",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "provisioners": "provisioners",
        "api_version": "apiVersion",
        "enable_migration_analysis": "enableMigrationAnalysis",
        "enable_transformation": "enableTransformation",
        "enable_validation": "enableValidation",
        "location": "location",
        "monitoring": "monitoring",
        "name": "name",
        "tags": "tags",
        "gateway_type": "gatewayType",
        "ip_configurations": "ipConfigurations",
        "sku": "sku",
        "active_active": "activeActive",
        "bgp_settings": "bgpSettings",
        "custom_routes": "customRoutes",
        "enable_bgp": "enableBgp",
        "enable_private_ip_address": "enablePrivateIpAddress",
        "gateway_default_site": "gatewayDefaultSite",
        "ignore_changes": "ignoreChanges",
        "resource_group_id": "resourceGroupId",
        "vpn_client_configuration": "vpnClientConfiguration",
        "vpn_gateway_generation": "vpnGatewayGeneration",
        "vpn_type": "vpnType",
    },
)
class VirtualNetworkGatewayProps(_AzapiResourceProps_141a2340):
    def __init__(
        self,
        *,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
        api_version: typing.Optional[builtins.str] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        location: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        gateway_type: builtins.str,
        ip_configurations: typing.Sequence[typing.Union[_VirtualNetworkGatewayIpConfiguration_853eed86, typing.Dict[builtins.str, typing.Any]]],
        sku: typing.Union[_VirtualNetworkGatewaySku_46d6411c, typing.Dict[builtins.str, typing.Any]],
        active_active: typing.Optional[builtins.bool] = None,
        bgp_settings: typing.Optional[typing.Union[_VirtualNetworkGatewayBgpSettings_63ddc7c4, typing.Dict[builtins.str, typing.Any]]] = None,
        custom_routes: typing.Optional[typing.Union[_VirtualNetworkGatewayCustomRoutes_7b9fea86, typing.Dict[builtins.str, typing.Any]]] = None,
        enable_bgp: typing.Optional[builtins.bool] = None,
        enable_private_ip_address: typing.Optional[builtins.bool] = None,
        gateway_default_site: typing.Optional[typing.Union[_VirtualNetworkGatewayDefaultSite_7b6991ba, typing.Dict[builtins.str, typing.Any]]] = None,
        ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
        resource_group_id: typing.Optional[builtins.str] = None,
        vpn_client_configuration: typing.Optional[typing.Union[_VirtualNetworkGatewayVpnClientConfiguration_861b9698, typing.Dict[builtins.str, typing.Any]]] = None,
        vpn_gateway_generation: typing.Optional[builtins.str] = None,
        vpn_type: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for the Azure Virtual Network Gateway.

        Extends AzapiResourceProps with Virtual Network Gateway specific properties

        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        :param api_version: Explicit API version to use for this resource. If not specified, the latest active version will be automatically resolved. Use this for version pinning when stability is required over latest features. Default: Latest active version from ApiVersionManager
        :param enable_migration_analysis: Whether to enable migration analysis warnings. When true, the framework will analyze the current version for deprecation status and provide migration recommendations in the deployment output. Default: true
        :param enable_transformation: Whether to apply property transformations automatically. When true, properties will be automatically transformed according to the target schema's transformation rules. This enables backward compatibility. Default: true
        :param enable_validation: Whether to validate properties against the schema. When true, all properties will be validated against the API schema before resource creation. Validation errors will cause deployment failures. Default: true
        :param location: The location where the resource should be created. Default: Varies by resource type - see specific resource documentation
        :param monitoring: Monitoring configuration for this resource. Enables integrated monitoring with diagnostic settings, metric alerts, and activity log alerts. All monitoring is optional and disabled by default.
        :param name: The name of the resource.
        :param tags: Tags to apply to the resource.
        :param gateway_type: Gateway type Must be either "Vpn" or "ExpressRoute".
        :param ip_configurations: IP configurations for the gateway At least one IP configuration is required Two IP configurations are required for active-active mode.
        :param sku: SKU configuration for the gateway.
        :param active_active: Enable active-active mode for the gateway Requires two IP configurations. Default: false
        :param bgp_settings: BGP settings for the gateway Required if enableBgp is true.
        :param custom_routes: Custom routes for the gateway.
        :param enable_bgp: Enable BGP for the gateway. Default: false
        :param enable_private_ip_address: Enable private IP address for the gateway. Default: false
        :param gateway_default_site: Default site for force tunneling.
        :param ignore_changes: The lifecycle rules to ignore changes Useful for properties that are externally managed.
        :param resource_group_id: Resource group ID where the Gateway will be created Optional - will use the subscription scope if not provided.
        :param vpn_client_configuration: VPN client configuration for point-to-site connections.
        :param vpn_gateway_generation: VPN gateway generation.
        :param vpn_type: VPN type for VPN gateways. Default: "RouteBased"
        '''
        if isinstance(lifecycle, dict):
            lifecycle = _cdktf_9a9027ec.TerraformResourceLifecycle(**lifecycle)
        if isinstance(monitoring, dict):
            monitoring = _MonitoringConfig_7c28df74(**monitoring)
        if isinstance(sku, dict):
            sku = _VirtualNetworkGatewaySku_46d6411c(**sku)
        if isinstance(bgp_settings, dict):
            bgp_settings = _VirtualNetworkGatewayBgpSettings_63ddc7c4(**bgp_settings)
        if isinstance(custom_routes, dict):
            custom_routes = _VirtualNetworkGatewayCustomRoutes_7b9fea86(**custom_routes)
        if isinstance(gateway_default_site, dict):
            gateway_default_site = _VirtualNetworkGatewayDefaultSite_7b6991ba(**gateway_default_site)
        if isinstance(vpn_client_configuration, dict):
            vpn_client_configuration = _VirtualNetworkGatewayVpnClientConfiguration_861b9698(**vpn_client_configuration)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__50362a953dc8a1cc734ee12acc24925a974bc6116208dc5a84beffcb35ba6ece)
            check_type(argname="argument connection", value=connection, expected_type=type_hints["connection"])
            check_type(argname="argument count", value=count, expected_type=type_hints["count"])
            check_type(argname="argument depends_on", value=depends_on, expected_type=type_hints["depends_on"])
            check_type(argname="argument for_each", value=for_each, expected_type=type_hints["for_each"])
            check_type(argname="argument lifecycle", value=lifecycle, expected_type=type_hints["lifecycle"])
            check_type(argname="argument provider", value=provider, expected_type=type_hints["provider"])
            check_type(argname="argument provisioners", value=provisioners, expected_type=type_hints["provisioners"])
            check_type(argname="argument api_version", value=api_version, expected_type=type_hints["api_version"])
            check_type(argname="argument enable_migration_analysis", value=enable_migration_analysis, expected_type=type_hints["enable_migration_analysis"])
            check_type(argname="argument enable_transformation", value=enable_transformation, expected_type=type_hints["enable_transformation"])
            check_type(argname="argument enable_validation", value=enable_validation, expected_type=type_hints["enable_validation"])
            check_type(argname="argument location", value=location, expected_type=type_hints["location"])
            check_type(argname="argument monitoring", value=monitoring, expected_type=type_hints["monitoring"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument gateway_type", value=gateway_type, expected_type=type_hints["gateway_type"])
            check_type(argname="argument ip_configurations", value=ip_configurations, expected_type=type_hints["ip_configurations"])
            check_type(argname="argument sku", value=sku, expected_type=type_hints["sku"])
            check_type(argname="argument active_active", value=active_active, expected_type=type_hints["active_active"])
            check_type(argname="argument bgp_settings", value=bgp_settings, expected_type=type_hints["bgp_settings"])
            check_type(argname="argument custom_routes", value=custom_routes, expected_type=type_hints["custom_routes"])
            check_type(argname="argument enable_bgp", value=enable_bgp, expected_type=type_hints["enable_bgp"])
            check_type(argname="argument enable_private_ip_address", value=enable_private_ip_address, expected_type=type_hints["enable_private_ip_address"])
            check_type(argname="argument gateway_default_site", value=gateway_default_site, expected_type=type_hints["gateway_default_site"])
            check_type(argname="argument ignore_changes", value=ignore_changes, expected_type=type_hints["ignore_changes"])
            check_type(argname="argument resource_group_id", value=resource_group_id, expected_type=type_hints["resource_group_id"])
            check_type(argname="argument vpn_client_configuration", value=vpn_client_configuration, expected_type=type_hints["vpn_client_configuration"])
            check_type(argname="argument vpn_gateway_generation", value=vpn_gateway_generation, expected_type=type_hints["vpn_gateway_generation"])
            check_type(argname="argument vpn_type", value=vpn_type, expected_type=type_hints["vpn_type"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "gateway_type": gateway_type,
            "ip_configurations": ip_configurations,
            "sku": sku,
        }
        if connection is not None:
            self._values["connection"] = connection
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if for_each is not None:
            self._values["for_each"] = for_each
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider
        if provisioners is not None:
            self._values["provisioners"] = provisioners
        if api_version is not None:
            self._values["api_version"] = api_version
        if enable_migration_analysis is not None:
            self._values["enable_migration_analysis"] = enable_migration_analysis
        if enable_transformation is not None:
            self._values["enable_transformation"] = enable_transformation
        if enable_validation is not None:
            self._values["enable_validation"] = enable_validation
        if location is not None:
            self._values["location"] = location
        if monitoring is not None:
            self._values["monitoring"] = monitoring
        if name is not None:
            self._values["name"] = name
        if tags is not None:
            self._values["tags"] = tags
        if active_active is not None:
            self._values["active_active"] = active_active
        if bgp_settings is not None:
            self._values["bgp_settings"] = bgp_settings
        if custom_routes is not None:
            self._values["custom_routes"] = custom_routes
        if enable_bgp is not None:
            self._values["enable_bgp"] = enable_bgp
        if enable_private_ip_address is not None:
            self._values["enable_private_ip_address"] = enable_private_ip_address
        if gateway_default_site is not None:
            self._values["gateway_default_site"] = gateway_default_site
        if ignore_changes is not None:
            self._values["ignore_changes"] = ignore_changes
        if resource_group_id is not None:
            self._values["resource_group_id"] = resource_group_id
        if vpn_client_configuration is not None:
            self._values["vpn_client_configuration"] = vpn_client_configuration
        if vpn_gateway_generation is not None:
            self._values["vpn_gateway_generation"] = vpn_gateway_generation
        if vpn_type is not None:
            self._values["vpn_type"] = vpn_type

    @builtins.property
    def connection(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("connection")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]], result)

    @builtins.property
    def count(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]], result)

    @builtins.property
    def depends_on(
        self,
    ) -> typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]], result)

    @builtins.property
    def for_each(self) -> typing.Optional[_cdktf_9a9027ec.ITerraformIterator]:
        '''
        :stability: experimental
        '''
        result = self._values.get("for_each")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.ITerraformIterator], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[_cdktf_9a9027ec.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformProvider], result)

    @builtins.property
    def provisioners(
        self,
    ) -> typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provisioners")
        return typing.cast(typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]], result)

    @builtins.property
    def api_version(self) -> typing.Optional[builtins.str]:
        '''Explicit API version to use for this resource.

        If not specified, the latest active version will be automatically resolved.
        Use this for version pinning when stability is required over latest features.

        :default: Latest active version from ApiVersionManager

        Example::

            "2024-11-01"
        '''
        result = self._values.get("api_version")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def enable_migration_analysis(self) -> typing.Optional[builtins.bool]:
        '''Whether to enable migration analysis warnings.

        When true, the framework will analyze the current version for deprecation
        status and provide migration recommendations in the deployment output.

        :default: true
        '''
        result = self._values.get("enable_migration_analysis")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_transformation(self) -> typing.Optional[builtins.bool]:
        '''Whether to apply property transformations automatically.

        When true, properties will be automatically transformed according to the
        target schema's transformation rules. This enables backward compatibility.

        :default: true
        '''
        result = self._values.get("enable_transformation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_validation(self) -> typing.Optional[builtins.bool]:
        '''Whether to validate properties against the schema.

        When true, all properties will be validated against the API schema before
        resource creation. Validation errors will cause deployment failures.

        :default: true
        '''
        result = self._values.get("enable_validation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def location(self) -> typing.Optional[builtins.str]:
        '''The location where the resource should be created.

        :default: Varies by resource type - see specific resource documentation

        :remarks:

        Location handling varies by resource type:

        - **Top-level resources**: Most require an explicit location (e.g., "eastus", "westus")
        - **Global resources**: Some use "global" as location (e.g., Private DNS Zones)
        - **Child resources**: Inherit location from parent and should NOT set this property

        Each resource type may provide its own default through the ``resolveLocation()`` method.
        If no location is specified and no default exists, resource creation may fail.

        Example::

            // Child resource (Subnet) - do not set location
            // location: undefined (inherited from parent Virtual Network)
        '''
        result = self._values.get("location")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def monitoring(self) -> typing.Optional[_MonitoringConfig_7c28df74]:
        '''Monitoring configuration for this resource.

        Enables integrated monitoring with diagnostic settings, metric alerts,
        and activity log alerts. All monitoring is optional and disabled by default.

        Example::

            monitoring: {
              enabled: true,
              diagnosticSettings: {
                workspaceId: logAnalytics.id,
                metrics: ['AllMetrics'],
                logs: ['AuditLogs']
              },
              metricAlerts: [{
                name: 'high-cpu-alert',
                severity: 2,
                scopes: [], // Automatically set to this resource
                criteria: { ... },
                actions: [{ actionGroupId: actionGroup.id }]
              }]
            }
        '''
        result = self._values.get("monitoring")
        return typing.cast(typing.Optional[_MonitoringConfig_7c28df74], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the resource.'''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Tags to apply to the resource.'''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def gateway_type(self) -> builtins.str:
        '''Gateway type Must be either "Vpn" or "ExpressRoute".'''
        result = self._values.get("gateway_type")
        assert result is not None, "Required property 'gateway_type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def ip_configurations(
        self,
    ) -> typing.List[_VirtualNetworkGatewayIpConfiguration_853eed86]:
        '''IP configurations for the gateway At least one IP configuration is required Two IP configurations are required for active-active mode.'''
        result = self._values.get("ip_configurations")
        assert result is not None, "Required property 'ip_configurations' is missing"
        return typing.cast(typing.List[_VirtualNetworkGatewayIpConfiguration_853eed86], result)

    @builtins.property
    def sku(self) -> _VirtualNetworkGatewaySku_46d6411c:
        '''SKU configuration for the gateway.'''
        result = self._values.get("sku")
        assert result is not None, "Required property 'sku' is missing"
        return typing.cast(_VirtualNetworkGatewaySku_46d6411c, result)

    @builtins.property
    def active_active(self) -> typing.Optional[builtins.bool]:
        '''Enable active-active mode for the gateway Requires two IP configurations.

        :default: false
        '''
        result = self._values.get("active_active")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def bgp_settings(
        self,
    ) -> typing.Optional[_VirtualNetworkGatewayBgpSettings_63ddc7c4]:
        '''BGP settings for the gateway Required if enableBgp is true.'''
        result = self._values.get("bgp_settings")
        return typing.cast(typing.Optional[_VirtualNetworkGatewayBgpSettings_63ddc7c4], result)

    @builtins.property
    def custom_routes(
        self,
    ) -> typing.Optional[_VirtualNetworkGatewayCustomRoutes_7b9fea86]:
        '''Custom routes for the gateway.'''
        result = self._values.get("custom_routes")
        return typing.cast(typing.Optional[_VirtualNetworkGatewayCustomRoutes_7b9fea86], result)

    @builtins.property
    def enable_bgp(self) -> typing.Optional[builtins.bool]:
        '''Enable BGP for the gateway.

        :default: false
        '''
        result = self._values.get("enable_bgp")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_private_ip_address(self) -> typing.Optional[builtins.bool]:
        '''Enable private IP address for the gateway.

        :default: false
        '''
        result = self._values.get("enable_private_ip_address")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def gateway_default_site(
        self,
    ) -> typing.Optional[_VirtualNetworkGatewayDefaultSite_7b6991ba]:
        '''Default site for force tunneling.'''
        result = self._values.get("gateway_default_site")
        return typing.cast(typing.Optional[_VirtualNetworkGatewayDefaultSite_7b6991ba], result)

    @builtins.property
    def ignore_changes(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The lifecycle rules to ignore changes Useful for properties that are externally managed.

        Example::

            ["tags"]
        '''
        result = self._values.get("ignore_changes")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def resource_group_id(self) -> typing.Optional[builtins.str]:
        '''Resource group ID where the Gateway will be created Optional - will use the subscription scope if not provided.'''
        result = self._values.get("resource_group_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def vpn_client_configuration(
        self,
    ) -> typing.Optional[_VirtualNetworkGatewayVpnClientConfiguration_861b9698]:
        '''VPN client configuration for point-to-site connections.'''
        result = self._values.get("vpn_client_configuration")
        return typing.cast(typing.Optional[_VirtualNetworkGatewayVpnClientConfiguration_861b9698], result)

    @builtins.property
    def vpn_gateway_generation(self) -> typing.Optional[builtins.str]:
        '''VPN gateway generation.

        Example::

            "Generation1", "Generation2"
        '''
        result = self._values.get("vpn_gateway_generation")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def vpn_type(self) -> typing.Optional[builtins.str]:
        '''VPN type for VPN gateways.

        :default: "RouteBased"
        '''
        result = self._values.get("vpn_type")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VirtualNetworkGatewayProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.VirtualNetworkGatewaySku",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "tier": "tier"},
)
class VirtualNetworkGatewaySku:
    def __init__(self, *, name: builtins.str, tier: builtins.str) -> None:
        '''SKU configuration for Virtual Network Gateway.

        :param name: Name of the SKU.
        :param tier: Tier of the SKU.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a26a2fd898af1ef4fa4befe66822fa870fe9c91e3aface32480c37cb6d2140c2)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument tier", value=tier, expected_type=type_hints["tier"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
            "tier": tier,
        }

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of the SKU.

        Example::

            "Basic", "VpnGw1", "VpnGw2", "VpnGw3", "VpnGw4", "VpnGw5", "ErGw1AZ", "ErGw2AZ", "ErGw3AZ"
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def tier(self) -> builtins.str:
        '''Tier of the SKU.

        Example::

            "Basic", "VpnGw1", "VpnGw2", "VpnGw3", "VpnGw4", "VpnGw5", "ErGw1AZ", "ErGw2AZ", "ErGw3AZ"
        '''
        result = self._values.get("tier")
        assert result is not None, "Required property 'tier' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VirtualNetworkGatewaySku(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.VirtualNetworkGatewayVpnClientAddressPool",
    jsii_struct_bases=[],
    name_mapping={"address_prefixes": "addressPrefixes"},
)
class VirtualNetworkGatewayVpnClientAddressPool:
    def __init__(self, *, address_prefixes: typing.Sequence[builtins.str]) -> None:
        '''VPN client address pool configuration.

        :param address_prefixes: List of address prefixes for VPN client connections.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1fb2f0020b01db5fc73fcc6884009a0790ac9707746dfce4c517e27cfb3cf97f)
            check_type(argname="argument address_prefixes", value=address_prefixes, expected_type=type_hints["address_prefixes"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "address_prefixes": address_prefixes,
        }

    @builtins.property
    def address_prefixes(self) -> typing.List[builtins.str]:
        '''List of address prefixes for VPN client connections.'''
        result = self._values.get("address_prefixes")
        assert result is not None, "Required property 'address_prefixes' is missing"
        return typing.cast(typing.List[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VirtualNetworkGatewayVpnClientAddressPool(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.VirtualNetworkGatewayVpnClientConfiguration",
    jsii_struct_bases=[],
    name_mapping={
        "radius_server_address": "radiusServerAddress",
        "radius_server_secret": "radiusServerSecret",
        "vpn_client_address_pool": "vpnClientAddressPool",
        "vpn_client_protocols": "vpnClientProtocols",
        "vpn_client_revoked_certificates": "vpnClientRevokedCertificates",
        "vpn_client_root_certificates": "vpnClientRootCertificates",
    },
)
class VirtualNetworkGatewayVpnClientConfiguration:
    def __init__(
        self,
        *,
        radius_server_address: typing.Optional[builtins.str] = None,
        radius_server_secret: typing.Optional[builtins.str] = None,
        vpn_client_address_pool: typing.Optional[typing.Union[_VirtualNetworkGatewayVpnClientAddressPool_99253f78, typing.Dict[builtins.str, typing.Any]]] = None,
        vpn_client_protocols: typing.Optional[typing.Sequence[builtins.str]] = None,
        vpn_client_revoked_certificates: typing.Optional[typing.Sequence[typing.Any]] = None,
        vpn_client_root_certificates: typing.Optional[typing.Sequence[typing.Any]] = None,
    ) -> None:
        '''VPN client configuration for point-to-site connections.

        :param radius_server_address: Radius server address.
        :param radius_server_secret: Radius server secret.
        :param vpn_client_address_pool: VPN client address pool.
        :param vpn_client_protocols: VPN client protocols.
        :param vpn_client_revoked_certificates: VPN client revoked certificates.
        :param vpn_client_root_certificates: VPN client root certificates.
        '''
        if isinstance(vpn_client_address_pool, dict):
            vpn_client_address_pool = _VirtualNetworkGatewayVpnClientAddressPool_99253f78(**vpn_client_address_pool)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4305a8c17927f25c7f61b0bdde3d3629ba07f851a7654b53a556e646a3560b0b)
            check_type(argname="argument radius_server_address", value=radius_server_address, expected_type=type_hints["radius_server_address"])
            check_type(argname="argument radius_server_secret", value=radius_server_secret, expected_type=type_hints["radius_server_secret"])
            check_type(argname="argument vpn_client_address_pool", value=vpn_client_address_pool, expected_type=type_hints["vpn_client_address_pool"])
            check_type(argname="argument vpn_client_protocols", value=vpn_client_protocols, expected_type=type_hints["vpn_client_protocols"])
            check_type(argname="argument vpn_client_revoked_certificates", value=vpn_client_revoked_certificates, expected_type=type_hints["vpn_client_revoked_certificates"])
            check_type(argname="argument vpn_client_root_certificates", value=vpn_client_root_certificates, expected_type=type_hints["vpn_client_root_certificates"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if radius_server_address is not None:
            self._values["radius_server_address"] = radius_server_address
        if radius_server_secret is not None:
            self._values["radius_server_secret"] = radius_server_secret
        if vpn_client_address_pool is not None:
            self._values["vpn_client_address_pool"] = vpn_client_address_pool
        if vpn_client_protocols is not None:
            self._values["vpn_client_protocols"] = vpn_client_protocols
        if vpn_client_revoked_certificates is not None:
            self._values["vpn_client_revoked_certificates"] = vpn_client_revoked_certificates
        if vpn_client_root_certificates is not None:
            self._values["vpn_client_root_certificates"] = vpn_client_root_certificates

    @builtins.property
    def radius_server_address(self) -> typing.Optional[builtins.str]:
        '''Radius server address.'''
        result = self._values.get("radius_server_address")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def radius_server_secret(self) -> typing.Optional[builtins.str]:
        '''Radius server secret.'''
        result = self._values.get("radius_server_secret")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def vpn_client_address_pool(
        self,
    ) -> typing.Optional[_VirtualNetworkGatewayVpnClientAddressPool_99253f78]:
        '''VPN client address pool.'''
        result = self._values.get("vpn_client_address_pool")
        return typing.cast(typing.Optional[_VirtualNetworkGatewayVpnClientAddressPool_99253f78], result)

    @builtins.property
    def vpn_client_protocols(self) -> typing.Optional[typing.List[builtins.str]]:
        '''VPN client protocols.

        Example::

            ["IkeV2", "SSTP", "OpenVPN"]
        '''
        result = self._values.get("vpn_client_protocols")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def vpn_client_revoked_certificates(
        self,
    ) -> typing.Optional[typing.List[typing.Any]]:
        '''VPN client revoked certificates.'''
        result = self._values.get("vpn_client_revoked_certificates")
        return typing.cast(typing.Optional[typing.List[typing.Any]], result)

    @builtins.property
    def vpn_client_root_certificates(self) -> typing.Optional[typing.List[typing.Any]]:
        '''VPN client root certificates.'''
        result = self._values.get("vpn_client_root_certificates")
        return typing.cast(typing.Optional[typing.List[typing.Any]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VirtualNetworkGatewayVpnClientConfiguration(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class VirtualNetworkManager(
    _AzapiResource_7e7f5b39,
    metaclass=jsii.JSIIMeta,
    jsii_type="@microsoft/terraform-cdk-constructs.VirtualNetworkManager",
):
    '''Azure Virtual Network Manager implementation.

    This class provides a single, version-aware implementation that handles
    version resolution, schema validation, and property transformation while maintaining
    full backward compatibility.

    Example::

        // Usage with explicit version pinning:
        const networkManager = new VirtualNetworkManager(this, "manager", {
          name: "my-network-manager",
          location: "eastus",
          resourceGroupId: resourceGroup.id,
          apiVersion: "2024-05-01",
          networkManagerScopes: {
            subscriptions: ["/subscriptions/00000000-0000-0000-0000-000000000000"]
          },
          networkManagerScopeAccesses: ["Connectivity", "SecurityAdmin"]
        });
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        network_manager_scope_accesses: typing.Sequence[builtins.str],
        network_manager_scopes: typing.Union[_NetworkManagerScopes_d6035bf8, typing.Dict[builtins.str, typing.Any]],
        resource_group_id: builtins.str,
        description: typing.Optional[builtins.str] = None,
        ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
        api_version: typing.Optional[builtins.str] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        location: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> None:
        '''Creates a new Azure Virtual Network Manager using the AzapiResource framework.

        The constructor automatically handles version resolution, schema registration,
        validation, and resource creation. It maintains full backward compatibility
        with existing Virtual Network Manager implementations.

        :param scope: - The scope in which to define this construct.
        :param id: - The unique identifier for this instance.
        :param network_manager_scope_accesses: Array of features enabled for the network manager Valid values: "Connectivity", "SecurityAdmin", "Routing".
        :param network_manager_scopes: Defines the scope of management (management groups and/or subscriptions) At least one of managementGroups or subscriptions must be specified.
        :param resource_group_id: Resource ID of the resource group where the network manager will be created.
        :param description: Optional description of the network manager.
        :param ignore_changes: The lifecycle rules to ignore changes Useful for properties that are externally managed.
        :param api_version: Explicit API version to use for this resource. If not specified, the latest active version will be automatically resolved. Use this for version pinning when stability is required over latest features. Default: Latest active version from ApiVersionManager
        :param enable_migration_analysis: Whether to enable migration analysis warnings. When true, the framework will analyze the current version for deprecation status and provide migration recommendations in the deployment output. Default: true
        :param enable_transformation: Whether to apply property transformations automatically. When true, properties will be automatically transformed according to the target schema's transformation rules. This enables backward compatibility. Default: true
        :param enable_validation: Whether to validate properties against the schema. When true, all properties will be validated against the API schema before resource creation. Validation errors will cause deployment failures. Default: true
        :param location: The location where the resource should be created. Default: Varies by resource type - see specific resource documentation
        :param monitoring: Monitoring configuration for this resource. Enables integrated monitoring with diagnostic settings, metric alerts, and activity log alerts. All monitoring is optional and disabled by default.
        :param name: The name of the resource.
        :param tags: Tags to apply to the resource.
        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__669ef009eed4aa3410b31b0ec11810f13391f1e322c9d848346d1f0801dc34e6)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = _VirtualNetworkManagerProps_3038f7e4(
            network_manager_scope_accesses=network_manager_scope_accesses,
            network_manager_scopes=network_manager_scopes,
            resource_group_id=resource_group_id,
            description=description,
            ignore_changes=ignore_changes,
            api_version=api_version,
            enable_migration_analysis=enable_migration_analysis,
            enable_transformation=enable_transformation,
            enable_validation=enable_validation,
            location=location,
            monitoring=monitoring,
            name=name,
            tags=tags,
            connection=connection,
            count=count,
            depends_on=depends_on,
            for_each=for_each,
            lifecycle=lifecycle,
            provider=provider,
            provisioners=provisioners,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="addConnectivityConfiguration")
    def add_connectivity_configuration(
        self,
        id: builtins.str,
        *,
        applies_to_groups: typing.Sequence[typing.Union[_ConnectivityGroupItem_d310024f, typing.Dict[builtins.str, typing.Any]]],
        connectivity_topology: builtins.str,
        delete_existing_peering: typing.Optional[builtins.bool] = None,
        description: typing.Optional[builtins.str] = None,
        hubs: typing.Optional[typing.Sequence[typing.Union[_Hub_d4efdd65, typing.Dict[builtins.str, typing.Any]]]] = None,
        ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
        is_global: typing.Optional[builtins.bool] = None,
        api_version: typing.Optional[builtins.str] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        location: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> _ConnectivityConfiguration_d2d778e4:
        '''Convenience method to create a ConnectivityConfiguration.

        This is a helper method that creates a ConnectivityConfiguration with the
        networkManagerId automatically set to this Network Manager's ID.

        :param id: - The unique identifier for the connectivity configuration construct.
        :param applies_to_groups: Network groups to apply this configuration to Each item specifies a network group and how it should connect.
        :param connectivity_topology: Connectivity topology type - HubAndSpoke: Central hub with spoke VNets - Mesh: All VNets can communicate directly.
        :param delete_existing_peering: Delete existing peerings when applying this configuration. Default: false
        :param description: Optional description of the connectivity configuration.
        :param hubs: Hub VNets for hub-and-spoke topology Required when connectivityTopology is "HubAndSpoke".
        :param ignore_changes: The lifecycle rules to ignore changes.
        :param is_global: Enable global mesh connectivity Allows mesh connectivity across regions. Default: false
        :param api_version: Explicit API version to use for this resource. If not specified, the latest active version will be automatically resolved. Use this for version pinning when stability is required over latest features. Default: Latest active version from ApiVersionManager
        :param enable_migration_analysis: Whether to enable migration analysis warnings. When true, the framework will analyze the current version for deprecation status and provide migration recommendations in the deployment output. Default: true
        :param enable_transformation: Whether to apply property transformations automatically. When true, properties will be automatically transformed according to the target schema's transformation rules. This enables backward compatibility. Default: true
        :param enable_validation: Whether to validate properties against the schema. When true, all properties will be validated against the API schema before resource creation. Validation errors will cause deployment failures. Default: true
        :param location: The location where the resource should be created. Default: Varies by resource type - see specific resource documentation
        :param monitoring: Monitoring configuration for this resource. Enables integrated monitoring with diagnostic settings, metric alerts, and activity log alerts. All monitoring is optional and disabled by default.
        :param name: The name of the resource.
        :param tags: Tags to apply to the resource.
        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 

        :return: The created ConnectivityConfiguration instance

        Example::

            const hubSpoke = networkManager.addConnectivityConfiguration("hub-spoke", {
              name: "production-hub-spoke",
              connectivityTopology: "HubAndSpoke",
              appliesToGroups: [{ networkGroupId: prodGroup.id }],
              hubs: [{ resourceId: hubVnet.id, resourceType: "Microsoft.Network/virtualNetworks" }]
            });
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b2dbd2f0ea8f96d693783239370c653f9407aaa9c591353523e04530ba84178d)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = _AddConnectivityConfigurationProps_bd7d736a(
            applies_to_groups=applies_to_groups,
            connectivity_topology=connectivity_topology,
            delete_existing_peering=delete_existing_peering,
            description=description,
            hubs=hubs,
            ignore_changes=ignore_changes,
            is_global=is_global,
            api_version=api_version,
            enable_migration_analysis=enable_migration_analysis,
            enable_transformation=enable_transformation,
            enable_validation=enable_validation,
            location=location,
            monitoring=monitoring,
            name=name,
            tags=tags,
            connection=connection,
            count=count,
            depends_on=depends_on,
            for_each=for_each,
            lifecycle=lifecycle,
            provider=provider,
            provisioners=provisioners,
        )

        return typing.cast(_ConnectivityConfiguration_d2d778e4, jsii.invoke(self, "addConnectivityConfiguration", [id, props]))

    @jsii.member(jsii_name="addIpamPool")
    def add_ipam_pool(
        self,
        id: builtins.str,
        *,
        address_prefixes: typing.Sequence[builtins.str],
        description: typing.Optional[builtins.str] = None,
        display_name: typing.Optional[builtins.str] = None,
        ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
        parent_pool_name: typing.Optional[builtins.str] = None,
        api_version: typing.Optional[builtins.str] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        location: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> _IpamPool_7cd9567e:
        '''Convenience method to create an IpamPool.

        This is a helper method that creates an IpamPool with the networkManagerId
        automatically set to this Network Manager's ID. You can also create IpamPools
        directly using: new IpamPool(scope, id, { networkManagerId: vnm.id, ...props })

        :param id: - The unique identifier for the IPAM pool construct.
        :param address_prefixes: IP address prefixes for the pool Must be valid CIDR notation (e.g., "10.0.0.0/8") Multiple prefixes must not overlap.
        :param description: Optional description of the IPAM pool.
        :param display_name: Optional friendly display name.
        :param ignore_changes: The lifecycle rules to ignore changes.
        :param parent_pool_name: Name of parent pool for hierarchical pools Leave empty/undefined for root pools.
        :param api_version: Explicit API version to use for this resource. If not specified, the latest active version will be automatically resolved. Use this for version pinning when stability is required over latest features. Default: Latest active version from ApiVersionManager
        :param enable_migration_analysis: Whether to enable migration analysis warnings. When true, the framework will analyze the current version for deprecation status and provide migration recommendations in the deployment output. Default: true
        :param enable_transformation: Whether to apply property transformations automatically. When true, properties will be automatically transformed according to the target schema's transformation rules. This enables backward compatibility. Default: true
        :param enable_validation: Whether to validate properties against the schema. When true, all properties will be validated against the API schema before resource creation. Validation errors will cause deployment failures. Default: true
        :param location: The location where the resource should be created. Default: Varies by resource type - see specific resource documentation
        :param monitoring: Monitoring configuration for this resource. Enables integrated monitoring with diagnostic settings, metric alerts, and activity log alerts. All monitoring is optional and disabled by default.
        :param name: The name of the resource.
        :param tags: Tags to apply to the resource.
        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 

        :return: The created IpamPool instance

        Example::

            const ipamPool = networkManager.addIpamPool("prod-pool", {
              name: "production-pool",
              location: "eastus",
              addressPrefixes: ["10.0.0.0/8"],
              description: "Production IP address pool",
              displayName: "Production Pool"
            });
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d1203a22194ded8d2fdfe8e202959021a3bde120919b2b23796e1192036c03dc)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = _AddIpamPoolProps_73020ba0(
            address_prefixes=address_prefixes,
            description=description,
            display_name=display_name,
            ignore_changes=ignore_changes,
            parent_pool_name=parent_pool_name,
            api_version=api_version,
            enable_migration_analysis=enable_migration_analysis,
            enable_transformation=enable_transformation,
            enable_validation=enable_validation,
            location=location,
            monitoring=monitoring,
            name=name,
            tags=tags,
            connection=connection,
            count=count,
            depends_on=depends_on,
            for_each=for_each,
            lifecycle=lifecycle,
            provider=provider,
            provisioners=provisioners,
        )

        return typing.cast(_IpamPool_7cd9567e, jsii.invoke(self, "addIpamPool", [id, props]))

    @jsii.member(jsii_name="addNetworkGroup")
    def add_network_group(
        self,
        id: builtins.str,
        *,
        description: typing.Optional[builtins.str] = None,
        ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
        member_type: typing.Optional[builtins.str] = None,
        api_version: typing.Optional[builtins.str] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        location: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> _NetworkGroup_2f776cdc:
        '''Convenience method to create a NetworkGroup.

        This is a helper method that creates a NetworkGroup with the networkManagerId
        automatically set to this Network Manager's ID. You can also create NetworkGroups
        directly using: new NetworkGroup(scope, id, { networkManagerId: vnm.id, ...props })

        :param id: - The unique identifier for the network group construct.
        :param description: Optional description of the network group.
        :param ignore_changes: The lifecycle rules to ignore changes.
        :param member_type: Type of members in this network group. Default: undefined (can contain both VirtualNetwork and Subnet members)
        :param api_version: Explicit API version to use for this resource. If not specified, the latest active version will be automatically resolved. Use this for version pinning when stability is required over latest features. Default: Latest active version from ApiVersionManager
        :param enable_migration_analysis: Whether to enable migration analysis warnings. When true, the framework will analyze the current version for deprecation status and provide migration recommendations in the deployment output. Default: true
        :param enable_transformation: Whether to apply property transformations automatically. When true, properties will be automatically transformed according to the target schema's transformation rules. This enables backward compatibility. Default: true
        :param enable_validation: Whether to validate properties against the schema. When true, all properties will be validated against the API schema before resource creation. Validation errors will cause deployment failures. Default: true
        :param location: The location where the resource should be created. Default: Varies by resource type - see specific resource documentation
        :param monitoring: Monitoring configuration for this resource. Enables integrated monitoring with diagnostic settings, metric alerts, and activity log alerts. All monitoring is optional and disabled by default.
        :param name: The name of the resource.
        :param tags: Tags to apply to the resource.
        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 

        :return: The created NetworkGroup instance

        Example::

            const prodGroup = networkManager.addNetworkGroup("prod-group", {
              name: "production-vnets",
              description: "Production virtual networks",
              memberType: "VirtualNetwork"
            });
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__311b887b043ab3d879d74bfda16f8be6a5afdaca3a49491e2bc393c69911e3d4)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = _AddNetworkGroupProps_b54cf2f3(
            description=description,
            ignore_changes=ignore_changes,
            member_type=member_type,
            api_version=api_version,
            enable_migration_analysis=enable_migration_analysis,
            enable_transformation=enable_transformation,
            enable_validation=enable_validation,
            location=location,
            monitoring=monitoring,
            name=name,
            tags=tags,
            connection=connection,
            count=count,
            depends_on=depends_on,
            for_each=for_each,
            lifecycle=lifecycle,
            provider=provider,
            provisioners=provisioners,
        )

        return typing.cast(_NetworkGroup_2f776cdc, jsii.invoke(self, "addNetworkGroup", [id, props]))

    @jsii.member(jsii_name="addSecurityAdminConfiguration")
    def add_security_admin_configuration(
        self,
        id: builtins.str,
        *,
        apply_on_network_intent_policy_based_services: typing.Optional[typing.Sequence[builtins.str]] = None,
        description: typing.Optional[builtins.str] = None,
        ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
        api_version: typing.Optional[builtins.str] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        location: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    ) -> _SecurityAdminConfiguration_f3492edd:
        '''Convenience method to create a SecurityAdminConfiguration.

        This is a helper method that creates a SecurityAdminConfiguration with the
        networkManagerId automatically set to this Network Manager's ID.

        :param id: - The unique identifier for the security admin configuration construct.
        :param apply_on_network_intent_policy_based_services: Services to apply the security admin configuration on.
        :param description: Optional description of the security admin configuration.
        :param ignore_changes: The lifecycle rules to ignore changes.
        :param api_version: Explicit API version to use for this resource. If not specified, the latest active version will be automatically resolved. Use this for version pinning when stability is required over latest features. Default: Latest active version from ApiVersionManager
        :param enable_migration_analysis: Whether to enable migration analysis warnings. When true, the framework will analyze the current version for deprecation status and provide migration recommendations in the deployment output. Default: true
        :param enable_transformation: Whether to apply property transformations automatically. When true, properties will be automatically transformed according to the target schema's transformation rules. This enables backward compatibility. Default: true
        :param enable_validation: Whether to validate properties against the schema. When true, all properties will be validated against the API schema before resource creation. Validation errors will cause deployment failures. Default: true
        :param location: The location where the resource should be created. Default: Varies by resource type - see specific resource documentation
        :param monitoring: Monitoring configuration for this resource. Enables integrated monitoring with diagnostic settings, metric alerts, and activity log alerts. All monitoring is optional and disabled by default.
        :param name: The name of the resource.
        :param tags: Tags to apply to the resource.
        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 

        :return: The created SecurityAdminConfiguration instance

        Example::

            const securityConfig = networkManager.addSecurityAdminConfiguration("security", {
              name: "production-security",
              description: "High-priority security rules for production"
            });
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3af2440d27eee80b5c885fe00ff72c39a6e5a5e2bb41d6e5cdf46171bca2ce67)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = _AddSecurityAdminConfigurationProps_e1caa5ba(
            apply_on_network_intent_policy_based_services=apply_on_network_intent_policy_based_services,
            description=description,
            ignore_changes=ignore_changes,
            api_version=api_version,
            enable_migration_analysis=enable_migration_analysis,
            enable_transformation=enable_transformation,
            enable_validation=enable_validation,
            location=location,
            monitoring=monitoring,
            name=name,
            tags=tags,
            connection=connection,
            count=count,
            depends_on=depends_on,
            for_each=for_each,
            lifecycle=lifecycle,
            provider=provider,
            provisioners=provisioners,
        )

        return typing.cast(_SecurityAdminConfiguration_f3492edd, jsii.invoke(self, "addSecurityAdminConfiguration", [id, props]))

    @jsii.member(jsii_name="addTag")
    def add_tag(self, key: builtins.str, value: builtins.str) -> None:
        '''Add a tag to the Virtual Network Manager Note: This modifies the construct props but requires a new deployment to take effect.

        :param key: -
        :param value: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a85b00ea36b7f25b9818e7e324d8e9b4c5aa8badd6af23b87129291530ae8270)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(None, jsii.invoke(self, "addTag", [key, value]))

    @jsii.member(jsii_name="apiSchema")
    def _api_schema(self) -> _ApiSchema_5ce0490e:
        '''Gets the API schema for the resolved version Uses the framework's schema resolution to get the appropriate schema.'''
        return typing.cast(_ApiSchema_5ce0490e, jsii.invoke(self, "apiSchema", []))

    @jsii.member(jsii_name="createResourceBody")
    def _create_resource_body(self, props: typing.Any) -> typing.Any:
        '''Creates the resource body for the Azure API call Transforms the input properties into the JSON format expected by Azure REST API.

        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e08e7b0c89c834597ee14679b42cd7be97b7bcd6d4ccb572433c1eea4627d4f2)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.Any, jsii.invoke(self, "createResourceBody", [props]))

    @jsii.member(jsii_name="defaultVersion")
    def _default_version(self) -> builtins.str:
        '''Gets the default API version to use when no explicit version is specified Returns the most recent stable version as the default.'''
        return typing.cast(builtins.str, jsii.invoke(self, "defaultVersion", []))

    @jsii.member(jsii_name="removeTag")
    def remove_tag(self, key: builtins.str) -> None:
        '''Remove a tag from the Virtual Network Manager Note: This modifies the construct props but requires a new deployment to take effect.

        :param key: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3a1a4771cadf53bf74fb5ac3db83098c75a6f6ff577db1429b929cf7929439cc)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
        return typing.cast(None, jsii.invoke(self, "removeTag", [key]))

    @jsii.member(jsii_name="resolveParentId")
    def _resolve_parent_id(self, props: typing.Any) -> builtins.str:
        '''Resolves the parent resource ID for the Network Manager Network Managers are scoped to resource groups.

        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fb275e43bfa6cb8c8754f434d469dd426b8ce726f77255158eff86befe1f7abf)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(builtins.str, jsii.invoke(self, "resolveParentId", [props]))

    @jsii.member(jsii_name="resourceType")
    def _resource_type(self) -> builtins.str:
        '''Gets the Azure resource type for Virtual Network Managers.'''
        return typing.cast(builtins.str, jsii.invoke(self, "resourceType", []))

    @builtins.property
    @jsii.member(jsii_name="idOutput")
    def id_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "idOutput"))

    @builtins.property
    @jsii.member(jsii_name="locationOutput")
    def location_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "locationOutput"))

    @builtins.property
    @jsii.member(jsii_name="nameOutput")
    def name_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "nameOutput"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def props(self) -> _VirtualNetworkManagerProps_3038f7e4:
        '''The input properties for this Virtual Network Manager instance.'''
        return typing.cast(_VirtualNetworkManagerProps_3038f7e4, jsii.get(self, "props"))

    @builtins.property
    @jsii.member(jsii_name="resourceName")
    def resource_name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "resourceName"))

    @builtins.property
    @jsii.member(jsii_name="scopeAccessesOutput")
    def scope_accesses_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "scopeAccessesOutput"))

    @builtins.property
    @jsii.member(jsii_name="scopeOutput")
    def scope_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "scopeOutput"))

    @builtins.property
    @jsii.member(jsii_name="tagsOutput")
    def tags_output(self) -> _cdktf_9a9027ec.TerraformOutput:
        return typing.cast(_cdktf_9a9027ec.TerraformOutput, jsii.get(self, "tagsOutput"))


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.VirtualNetworkManagerBody",
    jsii_struct_bases=[],
    name_mapping={"location": "location", "properties": "properties", "tags": "tags"},
)
class VirtualNetworkManagerBody:
    def __init__(
        self,
        *,
        location: builtins.str,
        properties: typing.Union[_VirtualNetworkManagerProperties_794596ca, typing.Dict[builtins.str, typing.Any]],
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''The resource body interface for Azure Virtual Network Manager API calls.

        :param location: 
        :param properties: 
        :param tags: 
        '''
        if isinstance(properties, dict):
            properties = _VirtualNetworkManagerProperties_794596ca(**properties)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4b1ba156da58fc8b9f62cf1bad1d0db3b882a851182430686f984c3bc847bcd7)
            check_type(argname="argument location", value=location, expected_type=type_hints["location"])
            check_type(argname="argument properties", value=properties, expected_type=type_hints["properties"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "location": location,
            "properties": properties,
        }
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def location(self) -> builtins.str:
        result = self._values.get("location")
        assert result is not None, "Required property 'location' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def properties(self) -> _VirtualNetworkManagerProperties_794596ca:
        result = self._values.get("properties")
        assert result is not None, "Required property 'properties' is missing"
        return typing.cast(_VirtualNetworkManagerProperties_794596ca, result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VirtualNetworkManagerBody(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.VirtualNetworkManagerProperties",
    jsii_struct_bases=[],
    name_mapping={
        "network_manager_scope_accesses": "networkManagerScopeAccesses",
        "network_manager_scopes": "networkManagerScopes",
        "description": "description",
    },
)
class VirtualNetworkManagerProperties:
    def __init__(
        self,
        *,
        network_manager_scope_accesses: typing.Sequence[builtins.str],
        network_manager_scopes: typing.Union[_NetworkManagerScopes_d6035bf8, typing.Dict[builtins.str, typing.Any]],
        description: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for Virtual Network Manager body.

        :param network_manager_scope_accesses: 
        :param network_manager_scopes: 
        :param description: 
        '''
        if isinstance(network_manager_scopes, dict):
            network_manager_scopes = _NetworkManagerScopes_d6035bf8(**network_manager_scopes)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__60f1db564cff206b47ae8d15d4a252e57bf5ec28249a6c285fa23d43583aa9d4)
            check_type(argname="argument network_manager_scope_accesses", value=network_manager_scope_accesses, expected_type=type_hints["network_manager_scope_accesses"])
            check_type(argname="argument network_manager_scopes", value=network_manager_scopes, expected_type=type_hints["network_manager_scopes"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "network_manager_scope_accesses": network_manager_scope_accesses,
            "network_manager_scopes": network_manager_scopes,
        }
        if description is not None:
            self._values["description"] = description

    @builtins.property
    def network_manager_scope_accesses(self) -> typing.List[builtins.str]:
        result = self._values.get("network_manager_scope_accesses")
        assert result is not None, "Required property 'network_manager_scope_accesses' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def network_manager_scopes(self) -> _NetworkManagerScopes_d6035bf8:
        result = self._values.get("network_manager_scopes")
        assert result is not None, "Required property 'network_manager_scopes' is missing"
        return typing.cast(_NetworkManagerScopes_d6035bf8, result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VirtualNetworkManagerProperties(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.VirtualNetworkManagerProps",
    jsii_struct_bases=[_AzapiResourceProps_141a2340],
    name_mapping={
        "connection": "connection",
        "count": "count",
        "depends_on": "dependsOn",
        "for_each": "forEach",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "provisioners": "provisioners",
        "api_version": "apiVersion",
        "enable_migration_analysis": "enableMigrationAnalysis",
        "enable_transformation": "enableTransformation",
        "enable_validation": "enableValidation",
        "location": "location",
        "monitoring": "monitoring",
        "name": "name",
        "tags": "tags",
        "network_manager_scope_accesses": "networkManagerScopeAccesses",
        "network_manager_scopes": "networkManagerScopes",
        "resource_group_id": "resourceGroupId",
        "description": "description",
        "ignore_changes": "ignoreChanges",
    },
)
class VirtualNetworkManagerProps(_AzapiResourceProps_141a2340):
    def __init__(
        self,
        *,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
        api_version: typing.Optional[builtins.str] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        location: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        network_manager_scope_accesses: typing.Sequence[builtins.str],
        network_manager_scopes: typing.Union[_NetworkManagerScopes_d6035bf8, typing.Dict[builtins.str, typing.Any]],
        resource_group_id: builtins.str,
        description: typing.Optional[builtins.str] = None,
        ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''Properties for the Azure Virtual Network Manager.

        Extends AzapiResourceProps with Virtual Network Manager specific properties

        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        :param api_version: Explicit API version to use for this resource. If not specified, the latest active version will be automatically resolved. Use this for version pinning when stability is required over latest features. Default: Latest active version from ApiVersionManager
        :param enable_migration_analysis: Whether to enable migration analysis warnings. When true, the framework will analyze the current version for deprecation status and provide migration recommendations in the deployment output. Default: true
        :param enable_transformation: Whether to apply property transformations automatically. When true, properties will be automatically transformed according to the target schema's transformation rules. This enables backward compatibility. Default: true
        :param enable_validation: Whether to validate properties against the schema. When true, all properties will be validated against the API schema before resource creation. Validation errors will cause deployment failures. Default: true
        :param location: The location where the resource should be created. Default: Varies by resource type - see specific resource documentation
        :param monitoring: Monitoring configuration for this resource. Enables integrated monitoring with diagnostic settings, metric alerts, and activity log alerts. All monitoring is optional and disabled by default.
        :param name: The name of the resource.
        :param tags: Tags to apply to the resource.
        :param network_manager_scope_accesses: Array of features enabled for the network manager Valid values: "Connectivity", "SecurityAdmin", "Routing".
        :param network_manager_scopes: Defines the scope of management (management groups and/or subscriptions) At least one of managementGroups or subscriptions must be specified.
        :param resource_group_id: Resource ID of the resource group where the network manager will be created.
        :param description: Optional description of the network manager.
        :param ignore_changes: The lifecycle rules to ignore changes Useful for properties that are externally managed.
        '''
        if isinstance(lifecycle, dict):
            lifecycle = _cdktf_9a9027ec.TerraformResourceLifecycle(**lifecycle)
        if isinstance(monitoring, dict):
            monitoring = _MonitoringConfig_7c28df74(**monitoring)
        if isinstance(network_manager_scopes, dict):
            network_manager_scopes = _NetworkManagerScopes_d6035bf8(**network_manager_scopes)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0c725a99058fc34090e08f93cef59d39f3374bde6d93e47948bf27de0a9e48b3)
            check_type(argname="argument connection", value=connection, expected_type=type_hints["connection"])
            check_type(argname="argument count", value=count, expected_type=type_hints["count"])
            check_type(argname="argument depends_on", value=depends_on, expected_type=type_hints["depends_on"])
            check_type(argname="argument for_each", value=for_each, expected_type=type_hints["for_each"])
            check_type(argname="argument lifecycle", value=lifecycle, expected_type=type_hints["lifecycle"])
            check_type(argname="argument provider", value=provider, expected_type=type_hints["provider"])
            check_type(argname="argument provisioners", value=provisioners, expected_type=type_hints["provisioners"])
            check_type(argname="argument api_version", value=api_version, expected_type=type_hints["api_version"])
            check_type(argname="argument enable_migration_analysis", value=enable_migration_analysis, expected_type=type_hints["enable_migration_analysis"])
            check_type(argname="argument enable_transformation", value=enable_transformation, expected_type=type_hints["enable_transformation"])
            check_type(argname="argument enable_validation", value=enable_validation, expected_type=type_hints["enable_validation"])
            check_type(argname="argument location", value=location, expected_type=type_hints["location"])
            check_type(argname="argument monitoring", value=monitoring, expected_type=type_hints["monitoring"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument network_manager_scope_accesses", value=network_manager_scope_accesses, expected_type=type_hints["network_manager_scope_accesses"])
            check_type(argname="argument network_manager_scopes", value=network_manager_scopes, expected_type=type_hints["network_manager_scopes"])
            check_type(argname="argument resource_group_id", value=resource_group_id, expected_type=type_hints["resource_group_id"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument ignore_changes", value=ignore_changes, expected_type=type_hints["ignore_changes"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "network_manager_scope_accesses": network_manager_scope_accesses,
            "network_manager_scopes": network_manager_scopes,
            "resource_group_id": resource_group_id,
        }
        if connection is not None:
            self._values["connection"] = connection
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if for_each is not None:
            self._values["for_each"] = for_each
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider
        if provisioners is not None:
            self._values["provisioners"] = provisioners
        if api_version is not None:
            self._values["api_version"] = api_version
        if enable_migration_analysis is not None:
            self._values["enable_migration_analysis"] = enable_migration_analysis
        if enable_transformation is not None:
            self._values["enable_transformation"] = enable_transformation
        if enable_validation is not None:
            self._values["enable_validation"] = enable_validation
        if location is not None:
            self._values["location"] = location
        if monitoring is not None:
            self._values["monitoring"] = monitoring
        if name is not None:
            self._values["name"] = name
        if tags is not None:
            self._values["tags"] = tags
        if description is not None:
            self._values["description"] = description
        if ignore_changes is not None:
            self._values["ignore_changes"] = ignore_changes

    @builtins.property
    def connection(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("connection")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]], result)

    @builtins.property
    def count(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]], result)

    @builtins.property
    def depends_on(
        self,
    ) -> typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]], result)

    @builtins.property
    def for_each(self) -> typing.Optional[_cdktf_9a9027ec.ITerraformIterator]:
        '''
        :stability: experimental
        '''
        result = self._values.get("for_each")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.ITerraformIterator], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[_cdktf_9a9027ec.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformProvider], result)

    @builtins.property
    def provisioners(
        self,
    ) -> typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provisioners")
        return typing.cast(typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]], result)

    @builtins.property
    def api_version(self) -> typing.Optional[builtins.str]:
        '''Explicit API version to use for this resource.

        If not specified, the latest active version will be automatically resolved.
        Use this for version pinning when stability is required over latest features.

        :default: Latest active version from ApiVersionManager

        Example::

            "2024-11-01"
        '''
        result = self._values.get("api_version")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def enable_migration_analysis(self) -> typing.Optional[builtins.bool]:
        '''Whether to enable migration analysis warnings.

        When true, the framework will analyze the current version for deprecation
        status and provide migration recommendations in the deployment output.

        :default: true
        '''
        result = self._values.get("enable_migration_analysis")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_transformation(self) -> typing.Optional[builtins.bool]:
        '''Whether to apply property transformations automatically.

        When true, properties will be automatically transformed according to the
        target schema's transformation rules. This enables backward compatibility.

        :default: true
        '''
        result = self._values.get("enable_transformation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_validation(self) -> typing.Optional[builtins.bool]:
        '''Whether to validate properties against the schema.

        When true, all properties will be validated against the API schema before
        resource creation. Validation errors will cause deployment failures.

        :default: true
        '''
        result = self._values.get("enable_validation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def location(self) -> typing.Optional[builtins.str]:
        '''The location where the resource should be created.

        :default: Varies by resource type - see specific resource documentation

        :remarks:

        Location handling varies by resource type:

        - **Top-level resources**: Most require an explicit location (e.g., "eastus", "westus")
        - **Global resources**: Some use "global" as location (e.g., Private DNS Zones)
        - **Child resources**: Inherit location from parent and should NOT set this property

        Each resource type may provide its own default through the ``resolveLocation()`` method.
        If no location is specified and no default exists, resource creation may fail.

        Example::

            // Child resource (Subnet) - do not set location
            // location: undefined (inherited from parent Virtual Network)
        '''
        result = self._values.get("location")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def monitoring(self) -> typing.Optional[_MonitoringConfig_7c28df74]:
        '''Monitoring configuration for this resource.

        Enables integrated monitoring with diagnostic settings, metric alerts,
        and activity log alerts. All monitoring is optional and disabled by default.

        Example::

            monitoring: {
              enabled: true,
              diagnosticSettings: {
                workspaceId: logAnalytics.id,
                metrics: ['AllMetrics'],
                logs: ['AuditLogs']
              },
              metricAlerts: [{
                name: 'high-cpu-alert',
                severity: 2,
                scopes: [], // Automatically set to this resource
                criteria: { ... },
                actions: [{ actionGroupId: actionGroup.id }]
              }]
            }
        '''
        result = self._values.get("monitoring")
        return typing.cast(typing.Optional[_MonitoringConfig_7c28df74], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the resource.'''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Tags to apply to the resource.'''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def network_manager_scope_accesses(self) -> typing.List[builtins.str]:
        '''Array of features enabled for the network manager Valid values: "Connectivity", "SecurityAdmin", "Routing".

        Example::

            ["Connectivity", "SecurityAdmin"]
        '''
        result = self._values.get("network_manager_scope_accesses")
        assert result is not None, "Required property 'network_manager_scope_accesses' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def network_manager_scopes(self) -> _NetworkManagerScopes_d6035bf8:
        '''Defines the scope of management (management groups and/or subscriptions) At least one of managementGroups or subscriptions must be specified.'''
        result = self._values.get("network_manager_scopes")
        assert result is not None, "Required property 'network_manager_scopes' is missing"
        return typing.cast(_NetworkManagerScopes_d6035bf8, result)

    @builtins.property
    def resource_group_id(self) -> builtins.str:
        '''Resource ID of the resource group where the network manager will be created.

        Example::

            "/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/my-rg"
        '''
        result = self._values.get("resource_group_id")
        assert result is not None, "Required property 'resource_group_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''Optional description of the network manager.

        Example::

            "Central network management for production workloads"
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ignore_changes(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The lifecycle rules to ignore changes Useful for properties that are externally managed.

        Example::

            ["tags"]
        '''
        result = self._values.get("ignore_changes")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VirtualNetworkManagerProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.VirtualNetworkProps",
    jsii_struct_bases=[_AzapiResourceProps_141a2340],
    name_mapping={
        "connection": "connection",
        "count": "count",
        "depends_on": "dependsOn",
        "for_each": "forEach",
        "lifecycle": "lifecycle",
        "provider": "provider",
        "provisioners": "provisioners",
        "api_version": "apiVersion",
        "enable_migration_analysis": "enableMigrationAnalysis",
        "enable_transformation": "enableTransformation",
        "enable_validation": "enableValidation",
        "location": "location",
        "monitoring": "monitoring",
        "name": "name",
        "tags": "tags",
        "address_space": "addressSpace",
        "dhcp_options": "dhcpOptions",
        "enable_ddos_protection": "enableDdosProtection",
        "enable_vm_protection": "enableVmProtection",
        "encryption": "encryption",
        "flow_timeout_in_minutes": "flowTimeoutInMinutes",
        "ignore_changes": "ignoreChanges",
        "resource_group_id": "resourceGroupId",
        "subnets": "subnets",
    },
)
class VirtualNetworkProps(_AzapiResourceProps_141a2340):
    def __init__(
        self,
        *,
        connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
        count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
        depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
        for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
        lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
        provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
        provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
        api_version: typing.Optional[builtins.str] = None,
        enable_migration_analysis: typing.Optional[builtins.bool] = None,
        enable_transformation: typing.Optional[builtins.bool] = None,
        enable_validation: typing.Optional[builtins.bool] = None,
        location: typing.Optional[builtins.str] = None,
        monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        address_space: typing.Union[_VirtualNetworkAddressSpace_f881cca1, typing.Dict[builtins.str, typing.Any]],
        dhcp_options: typing.Optional[typing.Union[_VirtualNetworkDhcpOptions_da8e9a61, typing.Dict[builtins.str, typing.Any]]] = None,
        enable_ddos_protection: typing.Optional[builtins.bool] = None,
        enable_vm_protection: typing.Optional[builtins.bool] = None,
        encryption: typing.Any = None,
        flow_timeout_in_minutes: typing.Optional[jsii.Number] = None,
        ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
        resource_group_id: typing.Optional[builtins.str] = None,
        subnets: typing.Optional[typing.Sequence[typing.Any]] = None,
    ) -> None:
        '''Properties for the Azure Virtual Network.

        Extends AzapiResourceProps with Virtual Network specific properties

        :param connection: 
        :param count: 
        :param depends_on: 
        :param for_each: 
        :param lifecycle: 
        :param provider: 
        :param provisioners: 
        :param api_version: Explicit API version to use for this resource. If not specified, the latest active version will be automatically resolved. Use this for version pinning when stability is required over latest features. Default: Latest active version from ApiVersionManager
        :param enable_migration_analysis: Whether to enable migration analysis warnings. When true, the framework will analyze the current version for deprecation status and provide migration recommendations in the deployment output. Default: true
        :param enable_transformation: Whether to apply property transformations automatically. When true, properties will be automatically transformed according to the target schema's transformation rules. This enables backward compatibility. Default: true
        :param enable_validation: Whether to validate properties against the schema. When true, all properties will be validated against the API schema before resource creation. Validation errors will cause deployment failures. Default: true
        :param location: The location where the resource should be created. Default: Varies by resource type - see specific resource documentation
        :param monitoring: Monitoring configuration for this resource. Enables integrated monitoring with diagnostic settings, metric alerts, and activity log alerts. All monitoring is optional and disabled by default.
        :param name: The name of the resource.
        :param tags: Tags to apply to the resource.
        :param address_space: Address space for the virtual network Must contain at least one address prefix.
        :param dhcp_options: DHCP options configuration Optional - configures DNS servers for the VNet.
        :param enable_ddos_protection: Enable DDoS protection for the virtual network Requires a DDoS protection plan. Default: false
        :param enable_vm_protection: Enable VM protection for the virtual network. Default: false
        :param encryption: Encryption settings for the virtual network Optional - configures encryption for the VNet.
        :param flow_timeout_in_minutes: Flow timeout in minutes for the virtual network Valid range: 4-30 minutes.
        :param ignore_changes: The lifecycle rules to ignore changes Useful for properties that are externally managed.
        :param resource_group_id: Resource group ID where the VNet will be created Optional - will use the subscription scope if not provided.
        :param subnets: Subnets to create within the virtual network Optional - subnets can also be created separately.
        '''
        if isinstance(lifecycle, dict):
            lifecycle = _cdktf_9a9027ec.TerraformResourceLifecycle(**lifecycle)
        if isinstance(monitoring, dict):
            monitoring = _MonitoringConfig_7c28df74(**monitoring)
        if isinstance(address_space, dict):
            address_space = _VirtualNetworkAddressSpace_f881cca1(**address_space)
        if isinstance(dhcp_options, dict):
            dhcp_options = _VirtualNetworkDhcpOptions_da8e9a61(**dhcp_options)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__47b4bee89d3466ecb3ba5b134cdc1701929fee3244064fd6c51a382020912c47)
            check_type(argname="argument connection", value=connection, expected_type=type_hints["connection"])
            check_type(argname="argument count", value=count, expected_type=type_hints["count"])
            check_type(argname="argument depends_on", value=depends_on, expected_type=type_hints["depends_on"])
            check_type(argname="argument for_each", value=for_each, expected_type=type_hints["for_each"])
            check_type(argname="argument lifecycle", value=lifecycle, expected_type=type_hints["lifecycle"])
            check_type(argname="argument provider", value=provider, expected_type=type_hints["provider"])
            check_type(argname="argument provisioners", value=provisioners, expected_type=type_hints["provisioners"])
            check_type(argname="argument api_version", value=api_version, expected_type=type_hints["api_version"])
            check_type(argname="argument enable_migration_analysis", value=enable_migration_analysis, expected_type=type_hints["enable_migration_analysis"])
            check_type(argname="argument enable_transformation", value=enable_transformation, expected_type=type_hints["enable_transformation"])
            check_type(argname="argument enable_validation", value=enable_validation, expected_type=type_hints["enable_validation"])
            check_type(argname="argument location", value=location, expected_type=type_hints["location"])
            check_type(argname="argument monitoring", value=monitoring, expected_type=type_hints["monitoring"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument address_space", value=address_space, expected_type=type_hints["address_space"])
            check_type(argname="argument dhcp_options", value=dhcp_options, expected_type=type_hints["dhcp_options"])
            check_type(argname="argument enable_ddos_protection", value=enable_ddos_protection, expected_type=type_hints["enable_ddos_protection"])
            check_type(argname="argument enable_vm_protection", value=enable_vm_protection, expected_type=type_hints["enable_vm_protection"])
            check_type(argname="argument encryption", value=encryption, expected_type=type_hints["encryption"])
            check_type(argname="argument flow_timeout_in_minutes", value=flow_timeout_in_minutes, expected_type=type_hints["flow_timeout_in_minutes"])
            check_type(argname="argument ignore_changes", value=ignore_changes, expected_type=type_hints["ignore_changes"])
            check_type(argname="argument resource_group_id", value=resource_group_id, expected_type=type_hints["resource_group_id"])
            check_type(argname="argument subnets", value=subnets, expected_type=type_hints["subnets"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "address_space": address_space,
        }
        if connection is not None:
            self._values["connection"] = connection
        if count is not None:
            self._values["count"] = count
        if depends_on is not None:
            self._values["depends_on"] = depends_on
        if for_each is not None:
            self._values["for_each"] = for_each
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if provider is not None:
            self._values["provider"] = provider
        if provisioners is not None:
            self._values["provisioners"] = provisioners
        if api_version is not None:
            self._values["api_version"] = api_version
        if enable_migration_analysis is not None:
            self._values["enable_migration_analysis"] = enable_migration_analysis
        if enable_transformation is not None:
            self._values["enable_transformation"] = enable_transformation
        if enable_validation is not None:
            self._values["enable_validation"] = enable_validation
        if location is not None:
            self._values["location"] = location
        if monitoring is not None:
            self._values["monitoring"] = monitoring
        if name is not None:
            self._values["name"] = name
        if tags is not None:
            self._values["tags"] = tags
        if dhcp_options is not None:
            self._values["dhcp_options"] = dhcp_options
        if enable_ddos_protection is not None:
            self._values["enable_ddos_protection"] = enable_ddos_protection
        if enable_vm_protection is not None:
            self._values["enable_vm_protection"] = enable_vm_protection
        if encryption is not None:
            self._values["encryption"] = encryption
        if flow_timeout_in_minutes is not None:
            self._values["flow_timeout_in_minutes"] = flow_timeout_in_minutes
        if ignore_changes is not None:
            self._values["ignore_changes"] = ignore_changes
        if resource_group_id is not None:
            self._values["resource_group_id"] = resource_group_id
        if subnets is not None:
            self._values["subnets"] = subnets

    @builtins.property
    def connection(
        self,
    ) -> typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("connection")
        return typing.cast(typing.Optional[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, _cdktf_9a9027ec.WinrmProvisionerConnection]], result)

    @builtins.property
    def count(
        self,
    ) -> typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("count")
        return typing.cast(typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]], result)

    @builtins.property
    def depends_on(
        self,
    ) -> typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("depends_on")
        return typing.cast(typing.Optional[typing.List[_cdktf_9a9027ec.ITerraformDependable]], result)

    @builtins.property
    def for_each(self) -> typing.Optional[_cdktf_9a9027ec.ITerraformIterator]:
        '''
        :stability: experimental
        '''
        result = self._values.get("for_each")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.ITerraformIterator], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformResourceLifecycle], result)

    @builtins.property
    def provider(self) -> typing.Optional[_cdktf_9a9027ec.TerraformProvider]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provider")
        return typing.cast(typing.Optional[_cdktf_9a9027ec.TerraformProvider], result)

    @builtins.property
    def provisioners(
        self,
    ) -> typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("provisioners")
        return typing.cast(typing.Optional[typing.List[typing.Union[_cdktf_9a9027ec.FileProvisioner, _cdktf_9a9027ec.LocalExecProvisioner, _cdktf_9a9027ec.RemoteExecProvisioner]]], result)

    @builtins.property
    def api_version(self) -> typing.Optional[builtins.str]:
        '''Explicit API version to use for this resource.

        If not specified, the latest active version will be automatically resolved.
        Use this for version pinning when stability is required over latest features.

        :default: Latest active version from ApiVersionManager

        Example::

            "2024-11-01"
        '''
        result = self._values.get("api_version")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def enable_migration_analysis(self) -> typing.Optional[builtins.bool]:
        '''Whether to enable migration analysis warnings.

        When true, the framework will analyze the current version for deprecation
        status and provide migration recommendations in the deployment output.

        :default: true
        '''
        result = self._values.get("enable_migration_analysis")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_transformation(self) -> typing.Optional[builtins.bool]:
        '''Whether to apply property transformations automatically.

        When true, properties will be automatically transformed according to the
        target schema's transformation rules. This enables backward compatibility.

        :default: true
        '''
        result = self._values.get("enable_transformation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_validation(self) -> typing.Optional[builtins.bool]:
        '''Whether to validate properties against the schema.

        When true, all properties will be validated against the API schema before
        resource creation. Validation errors will cause deployment failures.

        :default: true
        '''
        result = self._values.get("enable_validation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def location(self) -> typing.Optional[builtins.str]:
        '''The location where the resource should be created.

        :default: Varies by resource type - see specific resource documentation

        :remarks:

        Location handling varies by resource type:

        - **Top-level resources**: Most require an explicit location (e.g., "eastus", "westus")
        - **Global resources**: Some use "global" as location (e.g., Private DNS Zones)
        - **Child resources**: Inherit location from parent and should NOT set this property

        Each resource type may provide its own default through the ``resolveLocation()`` method.
        If no location is specified and no default exists, resource creation may fail.

        Example::

            // Child resource (Subnet) - do not set location
            // location: undefined (inherited from parent Virtual Network)
        '''
        result = self._values.get("location")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def monitoring(self) -> typing.Optional[_MonitoringConfig_7c28df74]:
        '''Monitoring configuration for this resource.

        Enables integrated monitoring with diagnostic settings, metric alerts,
        and activity log alerts. All monitoring is optional and disabled by default.

        Example::

            monitoring: {
              enabled: true,
              diagnosticSettings: {
                workspaceId: logAnalytics.id,
                metrics: ['AllMetrics'],
                logs: ['AuditLogs']
              },
              metricAlerts: [{
                name: 'high-cpu-alert',
                severity: 2,
                scopes: [], // Automatically set to this resource
                criteria: { ... },
                actions: [{ actionGroupId: actionGroup.id }]
              }]
            }
        '''
        result = self._values.get("monitoring")
        return typing.cast(typing.Optional[_MonitoringConfig_7c28df74], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the resource.'''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Tags to apply to the resource.'''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def address_space(self) -> _VirtualNetworkAddressSpace_f881cca1:
        '''Address space for the virtual network Must contain at least one address prefix.'''
        result = self._values.get("address_space")
        assert result is not None, "Required property 'address_space' is missing"
        return typing.cast(_VirtualNetworkAddressSpace_f881cca1, result)

    @builtins.property
    def dhcp_options(self) -> typing.Optional[_VirtualNetworkDhcpOptions_da8e9a61]:
        '''DHCP options configuration Optional - configures DNS servers for the VNet.'''
        result = self._values.get("dhcp_options")
        return typing.cast(typing.Optional[_VirtualNetworkDhcpOptions_da8e9a61], result)

    @builtins.property
    def enable_ddos_protection(self) -> typing.Optional[builtins.bool]:
        '''Enable DDoS protection for the virtual network Requires a DDoS protection plan.

        :default: false
        '''
        result = self._values.get("enable_ddos_protection")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_vm_protection(self) -> typing.Optional[builtins.bool]:
        '''Enable VM protection for the virtual network.

        :default: false
        '''
        result = self._values.get("enable_vm_protection")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def encryption(self) -> typing.Any:
        '''Encryption settings for the virtual network Optional - configures encryption for the VNet.'''
        result = self._values.get("encryption")
        return typing.cast(typing.Any, result)

    @builtins.property
    def flow_timeout_in_minutes(self) -> typing.Optional[jsii.Number]:
        '''Flow timeout in minutes for the virtual network Valid range: 4-30 minutes.'''
        result = self._values.get("flow_timeout_in_minutes")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def ignore_changes(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The lifecycle rules to ignore changes Useful for properties that are externally managed.

        Example::

            ["tags", "subnets"]
        '''
        result = self._values.get("ignore_changes")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def resource_group_id(self) -> typing.Optional[builtins.str]:
        '''Resource group ID where the VNet will be created Optional - will use the subscription scope if not provided.'''
        result = self._values.get("resource_group_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def subnets(self) -> typing.Optional[typing.List[typing.Any]]:
        '''Subnets to create within the virtual network Optional - subnets can also be created separately.'''
        result = self._values.get("subnets")
        return typing.cast(typing.Optional[typing.List[typing.Any]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VirtualNetworkProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.VirtualNetworkReference",
    jsii_struct_bases=[],
    name_mapping={"id": "id"},
)
class VirtualNetworkReference:
    def __init__(self, *, id: builtins.str) -> None:
        '''Virtual network reference for private DNS zones.

        :param id: The resource ID of the virtual network.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fc72bce98f07bf10b6c56496009c3cdf4120eca8491ca041ae9d4f03c878fcff)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "id": id,
        }

    @builtins.property
    def id(self) -> builtins.str:
        '''The resource ID of the virtual network.'''
        result = self._values.get("id")
        assert result is not None, "Required property 'id' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VirtualNetworkReference(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.VmssMonitoringOptions",
    jsii_struct_bases=[],
    name_mapping={
        "cpu_alert_severity": "cpuAlertSeverity",
        "cpu_threshold": "cpuThreshold",
        "disk_queue_alert_severity": "diskQueueAlertSeverity",
        "disk_queue_threshold": "diskQueueThreshold",
        "enable_cpu_alert": "enableCpuAlert",
        "enable_deletion_alert": "enableDeletionAlert",
        "enable_disk_queue_alert": "enableDiskQueueAlert",
        "enable_memory_alert": "enableMemoryAlert",
        "memory_alert_severity": "memoryAlertSeverity",
        "memory_threshold": "memoryThreshold",
    },
)
class VmssMonitoringOptions:
    def __init__(
        self,
        *,
        cpu_alert_severity: typing.Optional[jsii.Number] = None,
        cpu_threshold: typing.Optional[jsii.Number] = None,
        disk_queue_alert_severity: typing.Optional[jsii.Number] = None,
        disk_queue_threshold: typing.Optional[jsii.Number] = None,
        enable_cpu_alert: typing.Optional[builtins.bool] = None,
        enable_deletion_alert: typing.Optional[builtins.bool] = None,
        enable_disk_queue_alert: typing.Optional[builtins.bool] = None,
        enable_memory_alert: typing.Optional[builtins.bool] = None,
        memory_alert_severity: typing.Optional[jsii.Number] = None,
        memory_threshold: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Configuration options for Virtual Machine Scale Set monitoring.

        This interface provides options for configuring monitoring alerts and diagnostic
        settings for VMSS resources. All properties are JSII-compliant for multi-language support.

        :param cpu_alert_severity: Severity level for CPU usage alerts. - 0: Critical - 1: Error - 2: Warning - 3: Informational - 4: Verbose Default: 2
        :param cpu_threshold: CPU usage threshold percentage for triggering alerts. VMSS uses a lower default threshold (75%) compared to single VMs (80%) to allow headroom for scaling operations before reaching saturation. Default: 75
        :param disk_queue_alert_severity: Severity level for disk queue depth alerts. - 0: Critical - 1: Error - 2: Warning - 3: Informational - 4: Verbose Default: 2
        :param disk_queue_threshold: Disk queue depth threshold for triggering alerts. High disk queue depth can indicate disk performance bottlenecks. Default: 32
        :param enable_cpu_alert: Enable or disable CPU usage alert. Default: true
        :param enable_deletion_alert: Enable or disable VMSS deletion activity log alert. Default: true
        :param enable_disk_queue_alert: Enable or disable disk queue depth alert. Default: true
        :param enable_memory_alert: Enable or disable memory usage alert. Default: true
        :param memory_alert_severity: Severity level for memory usage alerts. - 0: Critical - 1: Error - 2: Warning - 3: Informational - 4: Verbose Default: 2
        :param memory_threshold: Available memory threshold in bytes for triggering alerts. When available memory drops below this threshold, an alert will be triggered. Default is 1GB (1073741824 bytes). Default: 1073741824
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7726a6c16f96b8c5fad078d3b265d336b0e28e2fef80453d3e4c1c04f3cf70cc)
            check_type(argname="argument cpu_alert_severity", value=cpu_alert_severity, expected_type=type_hints["cpu_alert_severity"])
            check_type(argname="argument cpu_threshold", value=cpu_threshold, expected_type=type_hints["cpu_threshold"])
            check_type(argname="argument disk_queue_alert_severity", value=disk_queue_alert_severity, expected_type=type_hints["disk_queue_alert_severity"])
            check_type(argname="argument disk_queue_threshold", value=disk_queue_threshold, expected_type=type_hints["disk_queue_threshold"])
            check_type(argname="argument enable_cpu_alert", value=enable_cpu_alert, expected_type=type_hints["enable_cpu_alert"])
            check_type(argname="argument enable_deletion_alert", value=enable_deletion_alert, expected_type=type_hints["enable_deletion_alert"])
            check_type(argname="argument enable_disk_queue_alert", value=enable_disk_queue_alert, expected_type=type_hints["enable_disk_queue_alert"])
            check_type(argname="argument enable_memory_alert", value=enable_memory_alert, expected_type=type_hints["enable_memory_alert"])
            check_type(argname="argument memory_alert_severity", value=memory_alert_severity, expected_type=type_hints["memory_alert_severity"])
            check_type(argname="argument memory_threshold", value=memory_threshold, expected_type=type_hints["memory_threshold"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if cpu_alert_severity is not None:
            self._values["cpu_alert_severity"] = cpu_alert_severity
        if cpu_threshold is not None:
            self._values["cpu_threshold"] = cpu_threshold
        if disk_queue_alert_severity is not None:
            self._values["disk_queue_alert_severity"] = disk_queue_alert_severity
        if disk_queue_threshold is not None:
            self._values["disk_queue_threshold"] = disk_queue_threshold
        if enable_cpu_alert is not None:
            self._values["enable_cpu_alert"] = enable_cpu_alert
        if enable_deletion_alert is not None:
            self._values["enable_deletion_alert"] = enable_deletion_alert
        if enable_disk_queue_alert is not None:
            self._values["enable_disk_queue_alert"] = enable_disk_queue_alert
        if enable_memory_alert is not None:
            self._values["enable_memory_alert"] = enable_memory_alert
        if memory_alert_severity is not None:
            self._values["memory_alert_severity"] = memory_alert_severity
        if memory_threshold is not None:
            self._values["memory_threshold"] = memory_threshold

    @builtins.property
    def cpu_alert_severity(self) -> typing.Optional[jsii.Number]:
        '''Severity level for CPU usage alerts.

        - 0: Critical
        - 1: Error
        - 2: Warning
        - 3: Informational
        - 4: Verbose

        :default: 2
        '''
        result = self._values.get("cpu_alert_severity")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def cpu_threshold(self) -> typing.Optional[jsii.Number]:
        '''CPU usage threshold percentage for triggering alerts.

        VMSS uses a lower default threshold (75%) compared to single VMs (80%)
        to allow headroom for scaling operations before reaching saturation.

        :default: 75
        '''
        result = self._values.get("cpu_threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def disk_queue_alert_severity(self) -> typing.Optional[jsii.Number]:
        '''Severity level for disk queue depth alerts.

        - 0: Critical
        - 1: Error
        - 2: Warning
        - 3: Informational
        - 4: Verbose

        :default: 2
        '''
        result = self._values.get("disk_queue_alert_severity")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def disk_queue_threshold(self) -> typing.Optional[jsii.Number]:
        '''Disk queue depth threshold for triggering alerts.

        High disk queue depth can indicate disk performance bottlenecks.

        :default: 32
        '''
        result = self._values.get("disk_queue_threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def enable_cpu_alert(self) -> typing.Optional[builtins.bool]:
        '''Enable or disable CPU usage alert.

        :default: true
        '''
        result = self._values.get("enable_cpu_alert")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_deletion_alert(self) -> typing.Optional[builtins.bool]:
        '''Enable or disable VMSS deletion activity log alert.

        :default: true
        '''
        result = self._values.get("enable_deletion_alert")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_disk_queue_alert(self) -> typing.Optional[builtins.bool]:
        '''Enable or disable disk queue depth alert.

        :default: true
        '''
        result = self._values.get("enable_disk_queue_alert")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_memory_alert(self) -> typing.Optional[builtins.bool]:
        '''Enable or disable memory usage alert.

        :default: true
        '''
        result = self._values.get("enable_memory_alert")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def memory_alert_severity(self) -> typing.Optional[jsii.Number]:
        '''Severity level for memory usage alerts.

        - 0: Critical
        - 1: Error
        - 2: Warning
        - 3: Informational
        - 4: Verbose

        :default: 2
        '''
        result = self._values.get("memory_alert_severity")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def memory_threshold(self) -> typing.Optional[jsii.Number]:
        '''Available memory threshold in bytes for triggering alerts.

        When available memory drops below this threshold, an alert will be triggered.
        Default is 1GB (1073741824 bytes).

        :default: 1073741824
        '''
        result = self._values.get("memory_threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VmssMonitoringOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.VoiceReceiver",
    jsii_struct_bases=[],
    name_mapping={
        "country_code": "countryCode",
        "name": "name",
        "phone_number": "phoneNumber",
    },
)
class VoiceReceiver:
    def __init__(
        self,
        *,
        country_code: builtins.str,
        name: builtins.str,
        phone_number: builtins.str,
    ) -> None:
        '''Voice receiver configuration.

        :param country_code: The country code (e.g., "1" for US).
        :param name: The name of the voice receiver.
        :param phone_number: The phone number to call.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2f15ee8b05608c5fcad984f3743a20c61d24b20140a8916a614b8bf880f1719a)
            check_type(argname="argument country_code", value=country_code, expected_type=type_hints["country_code"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument phone_number", value=phone_number, expected_type=type_hints["phone_number"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "country_code": country_code,
            "name": name,
            "phone_number": phone_number,
        }

    @builtins.property
    def country_code(self) -> builtins.str:
        '''The country code (e.g., "1" for US).'''
        result = self._values.get("country_code")
        assert result is not None, "Required property 'country_code' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the voice receiver.'''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def phone_number(self) -> builtins.str:
        '''The phone number to call.'''
        result = self._values.get("phone_number")
        assert result is not None, "Required property 'phone_number' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VoiceReceiver(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@microsoft/terraform-cdk-constructs.WebhookReceiver",
    jsii_struct_bases=[],
    name_mapping={
        "name": "name",
        "service_uri": "serviceUri",
        "use_common_alert_schema": "useCommonAlertSchema",
    },
)
class WebhookReceiver:
    def __init__(
        self,
        *,
        name: builtins.str,
        service_uri: builtins.str,
        use_common_alert_schema: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Webhook receiver configuration.

        :param name: The name of the webhook receiver.
        :param service_uri: The service URI to send webhooks to.
        :param use_common_alert_schema: Whether to use common alert schema. Default: false
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5ea098047aa5f75bc1e4c4420abf31d69f0692c53311f6f9c04829df4ed3ab5a)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument service_uri", value=service_uri, expected_type=type_hints["service_uri"])
            check_type(argname="argument use_common_alert_schema", value=use_common_alert_schema, expected_type=type_hints["use_common_alert_schema"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
            "service_uri": service_uri,
        }
        if use_common_alert_schema is not None:
            self._values["use_common_alert_schema"] = use_common_alert_schema

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the webhook receiver.'''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def service_uri(self) -> builtins.str:
        '''The service URI to send webhooks to.'''
        result = self._values.get("service_uri")
        assert result is not None, "Required property 'service_uri' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def use_common_alert_schema(self) -> typing.Optional[builtins.bool]:
        '''Whether to use common alert schema.

        :default: false
        '''
        result = self._values.get("use_common_alert_schema")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "WebhookReceiver(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


__all__ = [
    "ActionGroup",
    "ActionGroupBody",
    "ActionGroupBodyProperties",
    "ActionGroupProps",
    "ActivityLogAlert",
    "ActivityLogAlertActionGroup",
    "ActivityLogAlertActions",
    "ActivityLogAlertBody",
    "ActivityLogAlertBodyProperties",
    "ActivityLogAlertCondition",
    "ActivityLogAlertLeafCondition",
    "ActivityLogAlertProps",
    "AddConnectivityConfigurationProps",
    "AddIpamPoolProps",
    "AddNetworkGroupProps",
    "AddSecurityAdminConfigurationProps",
    "AdditionalCapabilities",
    "AddressPrefixItem",
    "AksCluster",
    "AksClusterAadProfile",
    "AksClusterAddonProfile",
    "AksClusterAgentPoolProfile",
    "AksClusterApiServerAccessProfile",
    "AksClusterAutoScalerProfile",
    "AksClusterAzureKeyVaultKms",
    "AksClusterBlobCSIDriver",
    "AksClusterBody",
    "AksClusterBodyProperties",
    "AksClusterDefenderSecurityMonitoring",
    "AksClusterDiskCSIDriver",
    "AksClusterEffectiveOutboundIP",
    "AksClusterFileCSIDriver",
    "AksClusterGmsaProfile",
    "AksClusterHttpProxyConfig",
    "AksClusterIdentity",
    "AksClusterImageCleaner",
    "AksClusterKeda",
    "AksClusterKubeletConfig",
    "AksClusterLinuxOSConfig",
    "AksClusterLinuxProfile",
    "AksClusterLoadBalancerProfile",
    "AksClusterManagedOutboundIPProfile",
    "AksClusterManagedOutboundIPs",
    "AksClusterMonitoringOptions",
    "AksClusterNatGatewayProfile",
    "AksClusterNetworkProfile",
    "AksClusterOidcIssuerProfile",
    "AksClusterOutboundIPPrefixes",
    "AksClusterOutboundIPs",
    "AksClusterProps",
    "AksClusterResourceReference",
    "AksClusterSecurityProfile",
    "AksClusterServicePrincipalProfile",
    "AksClusterSku",
    "AksClusterSnapshotController",
    "AksClusterSshConfiguration",
    "AksClusterSshPublicKey",
    "AksClusterStorageProfile",
    "AksClusterSysctlConfig",
    "AksClusterVerticalPodAutoscaler",
    "AksClusterWindowsProfile",
    "AksClusterWorkloadAutoScalerProfile",
    "AksClusterWorkloadIdentity",
    "ApiSchema",
    "ApiVersionManager",
    "AssertionReturn",
    "AutomaticOSUpgradePolicy",
    "AutomaticRepairsPolicy",
    "AzapiProvider",
    "AzapiProviderConfig",
    "AzapiProviderEndpoint",
    "AzapiResource",
    "AzapiResourceProps",
    "AzapiRoleAssignment",
    "AzapiRoleAssignmentProps",
    "AzureFunctionReceiver",
    "BaseTestStack",
    "BaseTestStackOptions",
    "BreakingChange",
    "BreakingChangeType",
    "CIContext",
    "CidrValidationResult",
    "CleanupOptions",
    "CleanupResult",
    "ConnectivityConfiguration",
    "ConnectivityConfigurationBody",
    "ConnectivityConfigurationProperties",
    "ConnectivityConfigurationProps",
    "ConnectivityGroupItem",
    "DataAzapiClientConfig",
    "DataAzapiClientConfigConfig",
    "DataAzapiClientConfigTimeouts",
    "DataAzapiClientConfigTimeoutsOutputReference",
    "DataAzapiResource",
    "DataAzapiResourceConfig",
    "DataAzapiResourceIdentity",
    "DataAzapiResourceIdentityList",
    "DataAzapiResourceIdentityOutputReference",
    "DataAzapiResourceRetry",
    "DataAzapiResourceRetryOutputReference",
    "DataAzapiResourceTimeouts",
    "DataAzapiResourceTimeoutsOutputReference",
    "DiagnosticLogConfig",
    "DiagnosticMetricConfig",
    "DiagnosticSettings",
    "DiagnosticSettingsBody",
    "DiagnosticSettingsBodyProperties",
    "DiagnosticSettingsProps",
    "DnsForwardingRuleset",
    "DnsForwardingRulesetBody",
    "DnsForwardingRulesetProperties",
    "DnsForwardingRulesetProps",
    "DnsForwardingRulesetVirtualNetworkLink",
    "DnsForwardingRulesetVirtualNetworkLinkBody",
    "DnsForwardingRulesetVirtualNetworkLinkProperties",
    "DnsForwardingRulesetVirtualNetworkLinkProps",
    "DnsForwardingRulesetVirtualNetworkReference",
    "DnsResolver",
    "DnsResolverBody",
    "DnsResolverInboundEndpoint",
    "DnsResolverInboundEndpointBody",
    "DnsResolverInboundEndpointProps",
    "DnsResolverOutboundEndpoint",
    "DnsResolverOutboundEndpointBody",
    "DnsResolverOutboundEndpointProps",
    "DnsResolverOutboundEndpointReference",
    "DnsResolverProps",
    "DnsZone",
    "DnsZoneBody",
    "DnsZoneProps",
    "DynamicThresholdCriteria",
    "EmailReceiver",
    "ExtensionProfile",
    "ForwardingRule",
    "ForwardingRuleBody",
    "ForwardingRuleProperties",
    "ForwardingRuleProps",
    "GatewayReference",
    "HealthProbeReference",
    "HostGroupReference",
    "Hub",
    "IPConfiguration",
    "IPConfigurationProperties",
    "IPConfigurationSubnet",
    "IpamPool",
    "IpamPoolBody",
    "IpamPoolProperties",
    "IpamPoolProps",
    "IpamPoolStaticCidr",
    "IpamPoolStaticCidrBody",
    "IpamPoolStaticCidrProperties",
    "IpamPoolStaticCidrProps",
    "IpsecPolicy",
    "LogicAppReceiver",
    "MetricAlert",
    "MetricAlertAction",
    "MetricAlertBody",
    "MetricAlertBodyProperties",
    "MetricAlertFailingPeriods",
    "MetricAlertProps",
    "MetricDimension",
    "MigrationAnalysis",
    "MigrationEffort",
    "MonitoringConfig",
    "NatRuleReference",
    "NetworkGroup",
    "NetworkGroupBody",
    "NetworkGroupProperties",
    "NetworkGroupProps",
    "NetworkGroupStaticMember",
    "NetworkGroupStaticMemberBody",
    "NetworkGroupStaticMemberProperties",
    "NetworkGroupStaticMemberProps",
    "NetworkInterface",
    "NetworkInterfaceBody",
    "NetworkInterfaceBodyProperties",
    "NetworkInterfaceConfiguration",
    "NetworkInterfaceConfigurationProperties",
    "NetworkInterfaceDnsSettings",
    "NetworkInterfaceIPConfiguration",
    "NetworkInterfaceNSGReference",
    "NetworkInterfaceProps",
    "NetworkInterfacePublicIPReference",
    "NetworkInterfaceSubnetReference",
    "NetworkManagerScopes",
    "NetworkSecurityGroup",
    "NetworkSecurityGroupProps",
    "NetworkSecurityGroupReference",
    "OrphanedResource",
    "ParsedCidr",
    "PeerReference",
    "PolicyAssignment",
    "PolicyAssignmentBody",
    "PolicyAssignmentIdentity",
    "PolicyAssignmentNonComplianceMessage",
    "PolicyAssignmentProperties",
    "PolicyAssignmentProps",
    "PolicyDefinition",
    "PolicyDefinitionBody",
    "PolicyDefinitionProperties",
    "PolicyDefinitionProps",
    "PrivateDnsZone",
    "PrivateDnsZoneBody",
    "PrivateDnsZoneLink",
    "PrivateDnsZoneLinkBody",
    "PrivateDnsZoneLinkProperties",
    "PrivateDnsZoneLinkProps",
    "PrivateDnsZoneLinkVirtualNetworkReference",
    "PrivateDnsZoneProps",
    "PropertyDefinition",
    "PropertyMapping",
    "PropertyTransformationType",
    "PropertyTransformer",
    "PropertyType",
    "PropertyValidation",
    "ProximityPlacementGroupReference",
    "PublicIPAddress",
    "PublicIPAddressConfiguration",
    "PublicIPAddressConfigurationProperties",
    "PublicIPAddressDnsSettings",
    "PublicIPAddressProps",
    "PublicIPAddressSku",
    "PublicIPDnsSettings",
    "Resource",
    "ResourceAction",
    "ResourceActionConfig",
    "ResourceActionRetry",
    "ResourceActionRetryOutputReference",
    "ResourceActionTimeouts",
    "ResourceActionTimeoutsOutputReference",
    "ResourceCleanupService",
    "ResourceConfig",
    "ResourceGroup",
    "ResourceGroupBody",
    "ResourceGroupProps",
    "ResourceIdentity",
    "ResourceIdentityList",
    "ResourceIdentityOutputReference",
    "ResourceMetadata",
    "ResourceReference",
    "ResourceRetry",
    "ResourceRetryOutputReference",
    "ResourceTimeouts",
    "ResourceTimeoutsOutputReference",
    "RetentionPolicyConfig",
    "RoleAssignment",
    "RoleAssignmentBody",
    "RoleAssignmentProperties",
    "RoleAssignmentProps",
    "RoleDefinition",
    "RoleDefinitionBody",
    "RoleDefinitionPermission",
    "RoleDefinitionProperties",
    "RoleDefinitionProps",
    "RollingUpgradePolicy",
    "ScheduledEventsProfile",
    "SchemaMapper",
    "SecurityAdminConfiguration",
    "SecurityAdminConfigurationBody",
    "SecurityAdminConfigurationProperties",
    "SecurityAdminConfigurationProps",
    "SecurityAdminConfigurationRuleGroupItem",
    "SecurityAdminRule",
    "SecurityAdminRuleBody",
    "SecurityAdminRuleCollection",
    "SecurityAdminRuleCollectionBody",
    "SecurityAdminRuleCollectionProperties",
    "SecurityAdminRuleCollectionProps",
    "SecurityAdminRuleProperties",
    "SecurityAdminRuleProps",
    "SecurityRule",
    "SecurityRuleProperties",
    "SmsReceiver",
    "StaticThresholdCriteria",
    "StorageAccount",
    "StorageAccountBody",
    "StorageAccountBodyProperties",
    "StorageAccountEncryption",
    "StorageAccountEncryptionService",
    "StorageAccountEncryptionServices",
    "StorageAccountIdentity",
    "StorageAccountIpRule",
    "StorageAccountMonitoringOptions",
    "StorageAccountNetworkAcls",
    "StorageAccountProps",
    "StorageAccountSku",
    "StorageAccountVirtualNetworkRule",
    "Subnet",
    "SubnetDelegation",
    "SubnetNATGatewayReference",
    "SubnetNSGReference",
    "SubnetProps",
    "SubnetRouteTableReference",
    "SubnetServiceEndpoint",
    "TargetDnsServer",
    "TerminateNotificationProfile",
    "TestRunMetadata",
    "TestRunOptions",
    "UpdateResource",
    "UpdateResourceConfig",
    "UpdateResourceRetry",
    "UpdateResourceRetryOutputReference",
    "UpdateResourceTimeouts",
    "UpdateResourceTimeoutsOutputReference",
    "VMExtension",
    "VMExtensionProperties",
    "ValidationResult",
    "ValidationRule",
    "ValidationRuleType",
    "VerificationResult",
    "VersionChangeLog",
    "VersionConfig",
    "VersionConstraints",
    "VersionLifecycle",
    "VersionPhase",
    "VersionSupportLevel",
    "VirtualMachine",
    "VirtualMachineAdditionalCapabilities",
    "VirtualMachineAvailabilitySetReference",
    "VirtualMachineBillingProfile",
    "VirtualMachineBody",
    "VirtualMachineBodyProperties",
    "VirtualMachineBootDiagnostics",
    "VirtualMachineDataDisk",
    "VirtualMachineDiagnosticsProfile",
    "VirtualMachineDiskEncryptionSetParameters",
    "VirtualMachineHardwareProfile",
    "VirtualMachineHostReference",
    "VirtualMachineIdentity",
    "VirtualMachineImageReference",
    "VirtualMachineLinuxConfiguration",
    "VirtualMachineLinuxPatchSettings",
    "VirtualMachineManagedDiskParameters",
    "VirtualMachineMonitoringOptions",
    "VirtualMachineNetworkInterfaceProperties",
    "VirtualMachineNetworkInterfaceReference",
    "VirtualMachineNetworkProfile",
    "VirtualMachineOSDisk",
    "VirtualMachineOSProfile",
    "VirtualMachinePlan",
    "VirtualMachinePriorityProfile",
    "VirtualMachineProps",
    "VirtualMachineProximityPlacementGroupReference",
    "VirtualMachineScaleSet",
    "VirtualMachineScaleSetBody",
    "VirtualMachineScaleSetBodyProperties",
    "VirtualMachineScaleSetNetworkProfile",
    "VirtualMachineScaleSetOSProfile",
    "VirtualMachineScaleSetProps",
    "VirtualMachineScaleSetReference",
    "VirtualMachineScaleSetScaleInPolicy",
    "VirtualMachineScaleSetScalingConfiguration",
    "VirtualMachineScaleSetSku",
    "VirtualMachineScaleSetUpgradePolicy",
    "VirtualMachineScaleSetVMProfile",
    "VirtualMachineSecret",
    "VirtualMachineSecurityProfile",
    "VirtualMachineSshConfiguration",
    "VirtualMachineSshPublicKey",
    "VirtualMachineStorageProfile",
    "VirtualMachineSubResource",
    "VirtualMachineUefiSettings",
    "VirtualMachineVaultCertificate",
    "VirtualMachineWinRMConfiguration",
    "VirtualMachineWinRMListener",
    "VirtualMachineWindowsConfiguration",
    "VirtualMachineWindowsPatchSettings",
    "VirtualNetwork",
    "VirtualNetworkAddressSpace",
    "VirtualNetworkDhcpOptions",
    "VirtualNetworkGateway",
    "VirtualNetworkGatewayBgpSettings",
    "VirtualNetworkGatewayConnection",
    "VirtualNetworkGatewayConnectionProps",
    "VirtualNetworkGatewayCustomRoutes",
    "VirtualNetworkGatewayDefaultSite",
    "VirtualNetworkGatewayIpConfiguration",
    "VirtualNetworkGatewayProps",
    "VirtualNetworkGatewaySku",
    "VirtualNetworkGatewayVpnClientAddressPool",
    "VirtualNetworkGatewayVpnClientConfiguration",
    "VirtualNetworkManager",
    "VirtualNetworkManagerBody",
    "VirtualNetworkManagerProperties",
    "VirtualNetworkManagerProps",
    "VirtualNetworkProps",
    "VirtualNetworkReference",
    "VmssMonitoringOptions",
    "VoiceReceiver",
    "WebhookReceiver",
    "azure_actiongroup",
    "azure_activitylogalert",
    "azure_aks",
    "azure_diagnosticsettings",
    "azure_dnsforwardingruleset",
    "azure_dnsresolver",
    "azure_dnszone",
    "azure_metricalert",
    "azure_networkinterface",
    "azure_networksecuritygroup",
    "azure_policyassignment",
    "azure_policydefinition",
    "azure_privatednszone",
    "azure_publicipaddress",
    "azure_resourcegroup",
    "azure_roleassignment",
    "azure_roledefinition",
    "azure_storageaccount",
    "azure_subnet",
    "azure_virtualmachine",
    "azure_virtualnetwork",
    "azure_virtualnetworkgateway",
    "azure_virtualnetworkgatewayconnection",
    "azure_virtualnetworkmanager",
    "azure_vmss",
    "core_azure",
    "testing",
]

publication.publish()

# Loading modules to ensure their types are registered with the jsii runtime library
from . import azure_actiongroup
from . import azure_activitylogalert
from . import azure_aks
from . import azure_diagnosticsettings
from . import azure_dnsforwardingruleset
from . import azure_dnsresolver
from . import azure_dnszone
from . import azure_metricalert
from . import azure_networkinterface
from . import azure_networksecuritygroup
from . import azure_policyassignment
from . import azure_policydefinition
from . import azure_privatednszone
from . import azure_publicipaddress
from . import azure_resourcegroup
from . import azure_roleassignment
from . import azure_roledefinition
from . import azure_storageaccount
from . import azure_subnet
from . import azure_virtualmachine
from . import azure_virtualnetwork
from . import azure_virtualnetworkgateway
from . import azure_virtualnetworkgatewayconnection
from . import azure_virtualnetworkmanager
from . import azure_vmss
from . import core_azure
from . import testing

def _typecheckingstub__249937df8388d0f3383cae5aaced42b029e907237e640c240dc9531e63bea72c(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    group_short_name: builtins.str,
    azure_function_receivers: typing.Optional[typing.Sequence[typing.Union[_AzureFunctionReceiver_dfacaeac, typing.Dict[builtins.str, typing.Any]]]] = None,
    email_receivers: typing.Optional[typing.Sequence[typing.Union[_EmailReceiver_32579ca3, typing.Dict[builtins.str, typing.Any]]]] = None,
    enabled: typing.Optional[builtins.bool] = None,
    logic_app_receivers: typing.Optional[typing.Sequence[typing.Union[_LogicAppReceiver_bcf80983, typing.Dict[builtins.str, typing.Any]]]] = None,
    resource_group_id: typing.Optional[builtins.str] = None,
    sms_receivers: typing.Optional[typing.Sequence[typing.Union[_SmsReceiver_8bf8dc4d, typing.Dict[builtins.str, typing.Any]]]] = None,
    voice_receivers: typing.Optional[typing.Sequence[typing.Union[_VoiceReceiver_17e05799, typing.Dict[builtins.str, typing.Any]]]] = None,
    webhook_receivers: typing.Optional[typing.Sequence[typing.Union[_WebhookReceiver_fdbf2c51, typing.Dict[builtins.str, typing.Any]]]] = None,
    api_version: typing.Optional[builtins.str] = None,
    enable_migration_analysis: typing.Optional[builtins.bool] = None,
    enable_transformation: typing.Optional[builtins.bool] = None,
    enable_validation: typing.Optional[builtins.bool] = None,
    location: typing.Optional[builtins.str] = None,
    monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5d07dde9ff7d0e69ded5ecf9d92980ca44ec19064d24b030bf4ef482beb7bbab(
    key: builtins.str,
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1406ce58f83af730c81e74b0ae6da9e4f63d6a8bd43c115bbdaea458cd69f33b(
    props: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__667549f3eb2f0a685123920033149c0647dbe958ddadb2116fefb236c813559b(
    key: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1d1250349f995235808b9dc59ea485a519402582d11eb9f947ec422ec1d693e2(
    *,
    location: builtins.str,
    properties: typing.Union[_ActionGroupBodyProperties_73f4a4cb, typing.Dict[builtins.str, typing.Any]],
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1087478ac591cb32806ce7240269443763f0aa8b24d653f0a31beb856521142f(
    *,
    enabled: builtins.bool,
    group_short_name: builtins.str,
    azure_function_receivers: typing.Optional[typing.Sequence[typing.Union[_AzureFunctionReceiver_dfacaeac, typing.Dict[builtins.str, typing.Any]]]] = None,
    email_receivers: typing.Optional[typing.Sequence[typing.Union[_EmailReceiver_32579ca3, typing.Dict[builtins.str, typing.Any]]]] = None,
    logic_app_receivers: typing.Optional[typing.Sequence[typing.Union[_LogicAppReceiver_bcf80983, typing.Dict[builtins.str, typing.Any]]]] = None,
    sms_receivers: typing.Optional[typing.Sequence[typing.Union[_SmsReceiver_8bf8dc4d, typing.Dict[builtins.str, typing.Any]]]] = None,
    voice_receivers: typing.Optional[typing.Sequence[typing.Union[_VoiceReceiver_17e05799, typing.Dict[builtins.str, typing.Any]]]] = None,
    webhook_receivers: typing.Optional[typing.Sequence[typing.Union[_WebhookReceiver_fdbf2c51, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bc6ad9d7acb5e9615808f8eb1ccdfb802c1f5a0f463e890828b905f9ed033d11(
    *,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    api_version: typing.Optional[builtins.str] = None,
    enable_migration_analysis: typing.Optional[builtins.bool] = None,
    enable_transformation: typing.Optional[builtins.bool] = None,
    enable_validation: typing.Optional[builtins.bool] = None,
    location: typing.Optional[builtins.str] = None,
    monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    group_short_name: builtins.str,
    azure_function_receivers: typing.Optional[typing.Sequence[typing.Union[_AzureFunctionReceiver_dfacaeac, typing.Dict[builtins.str, typing.Any]]]] = None,
    email_receivers: typing.Optional[typing.Sequence[typing.Union[_EmailReceiver_32579ca3, typing.Dict[builtins.str, typing.Any]]]] = None,
    enabled: typing.Optional[builtins.bool] = None,
    logic_app_receivers: typing.Optional[typing.Sequence[typing.Union[_LogicAppReceiver_bcf80983, typing.Dict[builtins.str, typing.Any]]]] = None,
    resource_group_id: typing.Optional[builtins.str] = None,
    sms_receivers: typing.Optional[typing.Sequence[typing.Union[_SmsReceiver_8bf8dc4d, typing.Dict[builtins.str, typing.Any]]]] = None,
    voice_receivers: typing.Optional[typing.Sequence[typing.Union[_VoiceReceiver_17e05799, typing.Dict[builtins.str, typing.Any]]]] = None,
    webhook_receivers: typing.Optional[typing.Sequence[typing.Union[_WebhookReceiver_fdbf2c51, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3bb8f46d40f436e312e40ef0125cffd24ad8fbf161aaedc30c69d58499255c98(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    condition: typing.Union[_ActivityLogAlertCondition_dfb706a4, typing.Dict[builtins.str, typing.Any]],
    scopes: typing.Sequence[builtins.str],
    actions: typing.Optional[typing.Union[_ActivityLogAlertActions_efbd1a87, typing.Dict[builtins.str, typing.Any]]] = None,
    description: typing.Optional[builtins.str] = None,
    enabled: typing.Optional[builtins.bool] = None,
    resource_group_id: typing.Optional[builtins.str] = None,
    api_version: typing.Optional[builtins.str] = None,
    enable_migration_analysis: typing.Optional[builtins.bool] = None,
    enable_transformation: typing.Optional[builtins.bool] = None,
    enable_validation: typing.Optional[builtins.bool] = None,
    location: typing.Optional[builtins.str] = None,
    monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f0410b149c4327db9619c6a629a6cc812d7450c8e909239c527d8ba4faebcf62(
    key: builtins.str,
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1f74bd619a63fb28dbe8fd5986da981a8861217daf67d3a8307446c8a0ff382d(
    props: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ade89bb9fbbf06aca46dcdb9e99f618cc5f8598104ee9684b27a9eaaf01d4aff(
    key: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a01a232e09eb7a38d3d3a28f0b418510ae7f13f1b6f01394c9070ed8101e3455(
    *,
    action_group_id: builtins.str,
    webhook_properties: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f58bbd3ea50947d39bf236958069c1af6c99a6cf9043a563b09fa3c020e21d71(
    *,
    action_groups: typing.Optional[typing.Sequence[typing.Union[_ActivityLogAlertActionGroup_7db22b2a, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d6bb4f8b0989e5a12d5fa7dd7c010098640e9ca3201e1eb16360f6ee582e6cfe(
    *,
    location: builtins.str,
    properties: typing.Union[_ActivityLogAlertBodyProperties_652af2f5, typing.Dict[builtins.str, typing.Any]],
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__52b543ddc96263d647e85abbca37acc72dbf371bb42995e507b16a01b3306541(
    *,
    condition: typing.Union[_ActivityLogAlertCondition_dfb706a4, typing.Dict[builtins.str, typing.Any]],
    enabled: builtins.bool,
    scopes: typing.Sequence[builtins.str],
    actions: typing.Optional[typing.Union[_ActivityLogAlertActions_efbd1a87, typing.Dict[builtins.str, typing.Any]]] = None,
    description: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cb94868f108b893ba16e051709509d6ce15c0b2ef7e633a4bfdb80856920b8f5(
    *,
    all_of: typing.Sequence[typing.Union[_ActivityLogAlertLeafCondition_3bceda39, typing.Dict[builtins.str, typing.Any]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__92db1924b1ffb3e3d5bd8b50c24344162cff6edd637dce2ae736c361fda9559e(
    *,
    equals_value: builtins.str,
    field: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bbee578b252c14e639e21d81ba9e93309d8014338e2f9b57c88b22cbfe599dc2(
    *,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    api_version: typing.Optional[builtins.str] = None,
    enable_migration_analysis: typing.Optional[builtins.bool] = None,
    enable_transformation: typing.Optional[builtins.bool] = None,
    enable_validation: typing.Optional[builtins.bool] = None,
    location: typing.Optional[builtins.str] = None,
    monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    condition: typing.Union[_ActivityLogAlertCondition_dfb706a4, typing.Dict[builtins.str, typing.Any]],
    scopes: typing.Sequence[builtins.str],
    actions: typing.Optional[typing.Union[_ActivityLogAlertActions_efbd1a87, typing.Dict[builtins.str, typing.Any]]] = None,
    description: typing.Optional[builtins.str] = None,
    enabled: typing.Optional[builtins.bool] = None,
    resource_group_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__232fd1352be84d611a018a6e4dff6fef8ed28a1e7db0c824a7cc0c1b13f534cd(
    *,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    api_version: typing.Optional[builtins.str] = None,
    enable_migration_analysis: typing.Optional[builtins.bool] = None,
    enable_transformation: typing.Optional[builtins.bool] = None,
    enable_validation: typing.Optional[builtins.bool] = None,
    location: typing.Optional[builtins.str] = None,
    monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    applies_to_groups: typing.Sequence[typing.Union[_ConnectivityGroupItem_d310024f, typing.Dict[builtins.str, typing.Any]]],
    connectivity_topology: builtins.str,
    delete_existing_peering: typing.Optional[builtins.bool] = None,
    description: typing.Optional[builtins.str] = None,
    hubs: typing.Optional[typing.Sequence[typing.Union[_Hub_d4efdd65, typing.Dict[builtins.str, typing.Any]]]] = None,
    ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
    is_global: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5410170048287adae6d87e4f4720db146c8c61501365c21dead7e8f689d505be(
    *,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    api_version: typing.Optional[builtins.str] = None,
    enable_migration_analysis: typing.Optional[builtins.bool] = None,
    enable_transformation: typing.Optional[builtins.bool] = None,
    enable_validation: typing.Optional[builtins.bool] = None,
    location: typing.Optional[builtins.str] = None,
    monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    address_prefixes: typing.Sequence[builtins.str],
    description: typing.Optional[builtins.str] = None,
    display_name: typing.Optional[builtins.str] = None,
    ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
    parent_pool_name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c5d16e7ab8b61bb6aed807ae8dec1eac59749acb0f94b13c5528b7f32178bdf3(
    *,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    api_version: typing.Optional[builtins.str] = None,
    enable_migration_analysis: typing.Optional[builtins.bool] = None,
    enable_transformation: typing.Optional[builtins.bool] = None,
    enable_validation: typing.Optional[builtins.bool] = None,
    location: typing.Optional[builtins.str] = None,
    monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    description: typing.Optional[builtins.str] = None,
    ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
    member_type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f16cc7d0e77b8cbbea46ce83463363cdad94bc01634f0724b8fdf216531cfb57(
    *,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    api_version: typing.Optional[builtins.str] = None,
    enable_migration_analysis: typing.Optional[builtins.bool] = None,
    enable_transformation: typing.Optional[builtins.bool] = None,
    enable_validation: typing.Optional[builtins.bool] = None,
    location: typing.Optional[builtins.str] = None,
    monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    apply_on_network_intent_policy_based_services: typing.Optional[typing.Sequence[builtins.str]] = None,
    description: typing.Optional[builtins.str] = None,
    ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f816e901bbfded4a49ce09cd8fd0e150065b5a1d0e043823f7f1e6574252676c(
    *,
    ultra_ssd_enabled: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__48f9a631ccdd74bc042be8767da59f1e6cdd6c5f5a73d7bdaf35e74d1a3e69ae(
    *,
    address_prefix: typing.Optional[builtins.str] = None,
    address_prefix_type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f33daf590e0847316d33f2ebe263228803db7110e8d816623c976f158816696a(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    agent_pool_profiles: typing.Sequence[typing.Union[_AksClusterAgentPoolProfile_19702e0d, typing.Dict[builtins.str, typing.Any]]],
    dns_prefix: builtins.str,
    aad_profile: typing.Optional[typing.Union[_AksClusterAadProfile_cbb39e4e, typing.Dict[builtins.str, typing.Any]]] = None,
    addon_profiles: typing.Optional[typing.Mapping[builtins.str, typing.Union[_AksClusterAddonProfile_75e5bc97, typing.Dict[builtins.str, typing.Any]]]] = None,
    api_server_access_profile: typing.Optional[typing.Union[_AksClusterApiServerAccessProfile_a245e705, typing.Dict[builtins.str, typing.Any]]] = None,
    auto_scaler_profile: typing.Optional[typing.Union[_AksClusterAutoScalerProfile_15ae7fd0, typing.Dict[builtins.str, typing.Any]]] = None,
    disable_local_accounts: typing.Optional[builtins.bool] = None,
    disk_encryption_set_id: typing.Optional[builtins.str] = None,
    enable_rbac: typing.Optional[builtins.bool] = None,
    fqdn: typing.Optional[builtins.str] = None,
    http_proxy_config: typing.Optional[typing.Union[_AksClusterHttpProxyConfig_41bff94e, typing.Dict[builtins.str, typing.Any]]] = None,
    identity: typing.Optional[typing.Union[_AksClusterIdentity_92ed97a4, typing.Dict[builtins.str, typing.Any]]] = None,
    ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
    kubernetes_version: typing.Optional[builtins.str] = None,
    linux_profile: typing.Optional[typing.Union[_AksClusterLinuxProfile_516beb3b, typing.Dict[builtins.str, typing.Any]]] = None,
    network_profile: typing.Optional[typing.Union[_AksClusterNetworkProfile_ec57fbab, typing.Dict[builtins.str, typing.Any]]] = None,
    node_resource_group: typing.Optional[builtins.str] = None,
    oidc_issuer_profile: typing.Optional[typing.Union[_AksClusterOidcIssuerProfile_55bd4791, typing.Dict[builtins.str, typing.Any]]] = None,
    private_fqdn: typing.Optional[builtins.str] = None,
    public_network_access: typing.Optional[builtins.str] = None,
    resource_group_id: typing.Optional[builtins.str] = None,
    security_profile: typing.Optional[typing.Union[_AksClusterSecurityProfile_6e20ee0b, typing.Dict[builtins.str, typing.Any]]] = None,
    service_principal_profile: typing.Optional[typing.Union[_AksClusterServicePrincipalProfile_5638b9c4, typing.Dict[builtins.str, typing.Any]]] = None,
    sku: typing.Optional[typing.Union[_AksClusterSku_746ad049, typing.Dict[builtins.str, typing.Any]]] = None,
    storage_profile: typing.Optional[typing.Union[_AksClusterStorageProfile_cc359e1f, typing.Dict[builtins.str, typing.Any]]] = None,
    support_plan: typing.Optional[builtins.str] = None,
    windows_profile: typing.Optional[typing.Union[_AksClusterWindowsProfile_bf96f6e4, typing.Dict[builtins.str, typing.Any]]] = None,
    workload_auto_scaler_profile: typing.Optional[typing.Union[_AksClusterWorkloadAutoScalerProfile_ec94d7bc, typing.Dict[builtins.str, typing.Any]]] = None,
    api_version: typing.Optional[builtins.str] = None,
    enable_migration_analysis: typing.Optional[builtins.bool] = None,
    enable_transformation: typing.Optional[builtins.bool] = None,
    enable_validation: typing.Optional[builtins.bool] = None,
    location: typing.Optional[builtins.str] = None,
    monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__46b10b26cc64577f7e85914bec65b8bf51daa122e1c3307b6844e52aaf855112(
    action_group_id: builtins.str,
    workspace_id: typing.Optional[builtins.str] = None,
    *,
    enable_deletion_alert: typing.Optional[builtins.bool] = None,
    enable_failed_pod_alert: typing.Optional[builtins.bool] = None,
    enable_node_cpu_alert: typing.Optional[builtins.bool] = None,
    enable_node_memory_alert: typing.Optional[builtins.bool] = None,
    failed_pod_alert_severity: typing.Optional[jsii.Number] = None,
    failed_pod_threshold: typing.Optional[jsii.Number] = None,
    node_cpu_alert_severity: typing.Optional[jsii.Number] = None,
    node_cpu_threshold: typing.Optional[jsii.Number] = None,
    node_memory_alert_severity: typing.Optional[jsii.Number] = None,
    node_memory_threshold: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e89f76fd8d364f429beb2a9e81ab74f5fc48ec61651e4cd34370af716f4a1601(
    key: builtins.str,
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__914408e7b4492bb143cc0ce341d6ed178a8e79996e50e44b9e7b76f8e0be2339(
    props: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7e362cc4e1ceb23d2c6011b2917cb1b83c6cb3ac3099e4ca3b5258d8a28c17de(
    key: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6dab5a457ca1a76fb41c7e089a6b600f5e8fda479824f671d11be22df9f72bb1(
    *,
    admin_group_object_i_ds: typing.Optional[typing.Sequence[builtins.str]] = None,
    client_app_id: typing.Optional[builtins.str] = None,
    enable_azure_rbac: typing.Optional[builtins.bool] = None,
    managed: typing.Optional[builtins.bool] = None,
    server_app_id: typing.Optional[builtins.str] = None,
    server_app_secret: typing.Optional[builtins.str] = None,
    tenant_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__64c09473f2c1532767f020b17c88a71b930b2460ff7081c98b807d7f0a6e5a1c(
    *,
    enabled: builtins.bool,
    config: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a537a7b05f8178e87b5d86b3e5f623ef8bb89ab52bf6408326036e738f9a971a(
    *,
    name: builtins.str,
    vm_size: builtins.str,
    availability_zones: typing.Optional[typing.Sequence[builtins.str]] = None,
    count: typing.Optional[jsii.Number] = None,
    enable_auto_scaling: typing.Optional[builtins.bool] = None,
    enable_encryption_at_host: typing.Optional[builtins.bool] = None,
    enable_fips: typing.Optional[builtins.bool] = None,
    enable_node_public_ip: typing.Optional[builtins.bool] = None,
    enable_ultra_ssd: typing.Optional[builtins.bool] = None,
    kubelet_config: typing.Optional[typing.Union[_AksClusterKubeletConfig_b1842d3f, typing.Dict[builtins.str, typing.Any]]] = None,
    linux_os_config: typing.Optional[typing.Union[_AksClusterLinuxOSConfig_c1e15359, typing.Dict[builtins.str, typing.Any]]] = None,
    max_count: typing.Optional[jsii.Number] = None,
    max_pods: typing.Optional[jsii.Number] = None,
    min_count: typing.Optional[jsii.Number] = None,
    mode: typing.Optional[builtins.str] = None,
    node_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    node_public_ip_prefix_id: typing.Optional[builtins.str] = None,
    node_taints: typing.Optional[typing.Sequence[builtins.str]] = None,
    os_disk_size_gb: typing.Optional[jsii.Number] = None,
    os_disk_type: typing.Optional[builtins.str] = None,
    os_type: typing.Optional[builtins.str] = None,
    pod_subnet_id: typing.Optional[builtins.str] = None,
    scale_set_eviction_policy: typing.Optional[builtins.str] = None,
    scale_set_priority: typing.Optional[builtins.str] = None,
    spot_max_price: typing.Optional[jsii.Number] = None,
    type: typing.Optional[builtins.str] = None,
    vnet_subnet_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c52a67f1465078a2e392f0027207382c4bcaeafbfa02bb3f3ca6b868bdf54136(
    *,
    authorized_ip_ranges: typing.Optional[typing.Sequence[builtins.str]] = None,
    disable_run_command: typing.Optional[builtins.bool] = None,
    enable_private_cluster: typing.Optional[builtins.bool] = None,
    enable_private_cluster_public_fqdn: typing.Optional[builtins.bool] = None,
    enable_vnet_integration: typing.Optional[builtins.bool] = None,
    private_dns_zone: typing.Optional[builtins.str] = None,
    subnet_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__27d44cd231d1581bf04ba0c78d68d733df318083d72d37dbb667a88cdd672265(
    *,
    balance_similar_node_groups: typing.Optional[builtins.str] = None,
    expander: typing.Optional[builtins.str] = None,
    max_empty_bulk_delete: typing.Optional[builtins.str] = None,
    max_graceful_termination_sec: typing.Optional[builtins.str] = None,
    max_node_provision_time: typing.Optional[builtins.str] = None,
    max_total_unready_percentage: typing.Optional[builtins.str] = None,
    new_pod_scale_up_delay: typing.Optional[builtins.str] = None,
    ok_total_unready_count: typing.Optional[builtins.str] = None,
    scale_down_delay_after_add: typing.Optional[builtins.str] = None,
    scale_down_delay_after_delete: typing.Optional[builtins.str] = None,
    scale_down_delay_after_failure: typing.Optional[builtins.str] = None,
    scale_down_unneeded_time: typing.Optional[builtins.str] = None,
    scale_down_unready_time: typing.Optional[builtins.str] = None,
    scale_down_utilization_threshold: typing.Optional[builtins.str] = None,
    scan_interval: typing.Optional[builtins.str] = None,
    skip_nodes_with_local_storage: typing.Optional[builtins.str] = None,
    skip_nodes_with_system_pods: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__35c1a80cd984ed49f9ef34d1ef9ffba7d83c37059888c8cdd57e29a03eff8621(
    *,
    enabled: typing.Optional[builtins.bool] = None,
    key_id: typing.Optional[builtins.str] = None,
    key_vault_network_access: typing.Optional[builtins.str] = None,
    key_vault_resource_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__68f72dd3c4005788434cd0b5f90061523421acfc118adba70877c587d489a350(
    *,
    enabled: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f3b56b82118e0e0a86a210d8472a2228a98e7ce4084a46dc2d71d51d48114e51(
    *,
    location: builtins.str,
    properties: typing.Union[_AksClusterBodyProperties_ba40e5e9, typing.Dict[builtins.str, typing.Any]],
    identity: typing.Optional[typing.Union[_AksClusterIdentity_92ed97a4, typing.Dict[builtins.str, typing.Any]]] = None,
    sku: typing.Optional[typing.Union[_AksClusterSku_746ad049, typing.Dict[builtins.str, typing.Any]]] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4e106b503aa414d1dfd91bba7d4a82f01848d7d4717f25b951e74ff27b8e39d6(
    *,
    agent_pool_profiles: typing.Sequence[typing.Union[_AksClusterAgentPoolProfile_19702e0d, typing.Dict[builtins.str, typing.Any]]],
    dns_prefix: builtins.str,
    aad_profile: typing.Optional[typing.Union[_AksClusterAadProfile_cbb39e4e, typing.Dict[builtins.str, typing.Any]]] = None,
    addon_profiles: typing.Optional[typing.Mapping[builtins.str, typing.Union[_AksClusterAddonProfile_75e5bc97, typing.Dict[builtins.str, typing.Any]]]] = None,
    api_server_access_profile: typing.Optional[typing.Union[_AksClusterApiServerAccessProfile_a245e705, typing.Dict[builtins.str, typing.Any]]] = None,
    auto_scaler_profile: typing.Optional[typing.Union[_AksClusterAutoScalerProfile_15ae7fd0, typing.Dict[builtins.str, typing.Any]]] = None,
    disable_local_accounts: typing.Optional[builtins.bool] = None,
    disk_encryption_set_id: typing.Optional[builtins.str] = None,
    enable_rbac: typing.Optional[builtins.bool] = None,
    fqdn: typing.Optional[builtins.str] = None,
    http_proxy_config: typing.Optional[typing.Union[_AksClusterHttpProxyConfig_41bff94e, typing.Dict[builtins.str, typing.Any]]] = None,
    kubernetes_version: typing.Optional[builtins.str] = None,
    linux_profile: typing.Optional[typing.Union[_AksClusterLinuxProfile_516beb3b, typing.Dict[builtins.str, typing.Any]]] = None,
    network_profile: typing.Optional[typing.Union[_AksClusterNetworkProfile_ec57fbab, typing.Dict[builtins.str, typing.Any]]] = None,
    node_resource_group: typing.Optional[builtins.str] = None,
    oidc_issuer_profile: typing.Optional[typing.Union[_AksClusterOidcIssuerProfile_55bd4791, typing.Dict[builtins.str, typing.Any]]] = None,
    private_fqdn: typing.Optional[builtins.str] = None,
    public_network_access: typing.Optional[builtins.str] = None,
    security_profile: typing.Optional[typing.Union[_AksClusterSecurityProfile_6e20ee0b, typing.Dict[builtins.str, typing.Any]]] = None,
    service_principal_profile: typing.Optional[typing.Union[_AksClusterServicePrincipalProfile_5638b9c4, typing.Dict[builtins.str, typing.Any]]] = None,
    storage_profile: typing.Optional[typing.Union[_AksClusterStorageProfile_cc359e1f, typing.Dict[builtins.str, typing.Any]]] = None,
    support_plan: typing.Optional[builtins.str] = None,
    windows_profile: typing.Optional[typing.Union[_AksClusterWindowsProfile_bf96f6e4, typing.Dict[builtins.str, typing.Any]]] = None,
    workload_auto_scaler_profile: typing.Optional[typing.Union[_AksClusterWorkloadAutoScalerProfile_ec94d7bc, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__db582d372bda5b0c4f6541f71249900e793083bb7f2fa3b05314b109bf16d8d0(
    *,
    enabled: typing.Optional[builtins.bool] = None,
    log_analytics_workspace_resource_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4f37cc0750c8590721b86f6d19449762d6d47f31af07525869406189468411d4(
    *,
    enabled: typing.Optional[builtins.bool] = None,
    version: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__494f0c110da03b74452556f1df84417a06ed9cbb2cc4a06f0586adf10cec2217(
    *,
    id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bc0cf1b74d10fda0180174f32f6a71b2b8c08bdcb08239636ca4a8aebb0c9ca1(
    *,
    enabled: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d4b142213bb017b49581f4edeec068878730471cc7b1af7a8ae90c660537ca59(
    *,
    dns_server: typing.Optional[builtins.str] = None,
    enabled: typing.Optional[builtins.bool] = None,
    root_domain_name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__837d9d10fa920b0307d1bbefe42cb4e019d1b014646e74b4b2868922e3eb357f(
    *,
    http_proxy: typing.Optional[builtins.str] = None,
    https_proxy: typing.Optional[builtins.str] = None,
    no_proxy: typing.Optional[typing.Sequence[builtins.str]] = None,
    trusted_ca: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b2f93d602a9db23cffe481bd74d13ad6a787d2fa29a0baf4f7673830cef786c6(
    *,
    type: builtins.str,
    user_assigned_identities: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__44117e43999544b2e0024148758296d06ff1b21c7a14361c659e0d12ab330c4c(
    *,
    enabled: typing.Optional[builtins.bool] = None,
    interval_hours: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__230844b390be36756e18465d98e79ccdd11c5d1f1b988f986815e0c45f18f056(
    *,
    enabled: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__52485dadde9b8e33a6ebba2c097ea04238eaa94867e7c1d0871b03974a652ff2(
    *,
    allowed_unsafe_sysctls: typing.Optional[typing.Sequence[builtins.str]] = None,
    container_log_max_files: typing.Optional[jsii.Number] = None,
    container_log_max_size_mb: typing.Optional[jsii.Number] = None,
    cpu_cfs_quota: typing.Optional[builtins.bool] = None,
    cpu_cfs_quota_period: typing.Optional[builtins.str] = None,
    cpu_manager_policy: typing.Optional[builtins.str] = None,
    fail_swap_on: typing.Optional[builtins.bool] = None,
    image_gc_high_threshold: typing.Optional[jsii.Number] = None,
    image_gc_low_threshold: typing.Optional[jsii.Number] = None,
    pod_max_pids: typing.Optional[jsii.Number] = None,
    topology_manager_policy: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__19c09d66963506efb76580b47de012451709d2d422a0d9b5094a57bbbce7b1d3(
    *,
    swap_file_size_mb: typing.Optional[jsii.Number] = None,
    sysctls: typing.Optional[typing.Union[_AksClusterSysctlConfig_ebc83aec, typing.Dict[builtins.str, typing.Any]]] = None,
    transparent_huge_page_defrag: typing.Optional[builtins.str] = None,
    transparent_huge_page_enabled: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__df72fc4ac06c06da1dd2b4e4f58122da50fc02bf4d23cee82b28e3dcb9d9d02e(
    *,
    admin_username: builtins.str,
    ssh: typing.Union[_AksClusterSshConfiguration_a24a3e25, typing.Dict[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d2e854a0465b530bcaade92e8e9ee5298ad619320c49724c85a4b337d46f667e(
    *,
    allocated_outbound_ports: typing.Optional[jsii.Number] = None,
    effective_outbound_i_ps: typing.Optional[typing.Sequence[typing.Union[_AksClusterEffectiveOutboundIP_a56a4ba3, typing.Dict[builtins.str, typing.Any]]]] = None,
    enable_multiple_standard_load_balancers: typing.Optional[builtins.bool] = None,
    idle_timeout_in_minutes: typing.Optional[jsii.Number] = None,
    managed_outbound_i_ps: typing.Optional[typing.Union[_AksClusterManagedOutboundIPs_7800bd02, typing.Dict[builtins.str, typing.Any]]] = None,
    outbound_ip_prefixes: typing.Optional[typing.Union[_AksClusterOutboundIPPrefixes_998c4e88, typing.Dict[builtins.str, typing.Any]]] = None,
    outbound_i_ps: typing.Optional[typing.Union[_AksClusterOutboundIPs_fa40a921, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a6e907b0b416debf597d5de597d32a45533a45129bb7d03d3e24be5af589c948(
    *,
    count: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__86aebe6063e973b1181d8c9a3c2c5bfd9786669fe9abceda19632cc8ce5a4ca8(
    *,
    count: typing.Optional[jsii.Number] = None,
    count_i_pv6: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ffe0f30bf33894f524169bd7e08fe716d7753fc93c0a40bec921bab5ec5e17de(
    *,
    enable_deletion_alert: typing.Optional[builtins.bool] = None,
    enable_failed_pod_alert: typing.Optional[builtins.bool] = None,
    enable_node_cpu_alert: typing.Optional[builtins.bool] = None,
    enable_node_memory_alert: typing.Optional[builtins.bool] = None,
    failed_pod_alert_severity: typing.Optional[jsii.Number] = None,
    failed_pod_threshold: typing.Optional[jsii.Number] = None,
    node_cpu_alert_severity: typing.Optional[jsii.Number] = None,
    node_cpu_threshold: typing.Optional[jsii.Number] = None,
    node_memory_alert_severity: typing.Optional[jsii.Number] = None,
    node_memory_threshold: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6ae6562b2cc909ccf6673b41738d4d2f845196ad2c6b459d36d769007dfc8ba7(
    *,
    effective_outbound_i_ps: typing.Optional[typing.Sequence[typing.Union[_AksClusterEffectiveOutboundIP_a56a4ba3, typing.Dict[builtins.str, typing.Any]]]] = None,
    idle_timeout_in_minutes: typing.Optional[jsii.Number] = None,
    managed_outbound_ip_profile: typing.Optional[typing.Union[_AksClusterManagedOutboundIPProfile_ce484d83, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__35f0ef2e686c0dbc3abebc7ad7fa034827866793fa9bdd6d917e230e6a0d65d1(
    *,
    dns_service_ip: typing.Optional[builtins.str] = None,
    docker_bridge_cidr: typing.Optional[builtins.str] = None,
    ip_families: typing.Optional[typing.Sequence[builtins.str]] = None,
    load_balancer_profile: typing.Optional[typing.Union[_AksClusterLoadBalancerProfile_67c2ac62, typing.Dict[builtins.str, typing.Any]]] = None,
    load_balancer_sku: typing.Optional[builtins.str] = None,
    nat_gateway_profile: typing.Optional[typing.Union[_AksClusterNatGatewayProfile_b267c658, typing.Dict[builtins.str, typing.Any]]] = None,
    network_mode: typing.Optional[builtins.str] = None,
    network_plugin: typing.Optional[builtins.str] = None,
    network_policy: typing.Optional[builtins.str] = None,
    outbound_type: typing.Optional[builtins.str] = None,
    pod_cidr: typing.Optional[builtins.str] = None,
    pod_cidrs: typing.Optional[typing.Sequence[builtins.str]] = None,
    service_cidr: typing.Optional[builtins.str] = None,
    service_cidrs: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__769e0d4e0354eeca55eb2e3defadfb699662d029c96be3f2163a4185cf3a26f0(
    *,
    enabled: typing.Optional[builtins.bool] = None,
    issuer_url: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bb22d6751205fce0489be9a096b51f45af7baa7b2689d8fb9844986440dafc76(
    *,
    public_ip_prefixes: typing.Optional[typing.Sequence[typing.Union[_AksClusterResourceReference_66302c1f, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__feb2e76618eb7b66e836d8578d30920bef06d943408974d71ffc9c4ef78184a1(
    *,
    public_i_ps: typing.Optional[typing.Sequence[typing.Union[_AksClusterResourceReference_66302c1f, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__02cf4290e0f9c8763c64b10ea0a58b46c07cdcf0eeb00d09bc64fa075c3ebfe0(
    *,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    api_version: typing.Optional[builtins.str] = None,
    enable_migration_analysis: typing.Optional[builtins.bool] = None,
    enable_transformation: typing.Optional[builtins.bool] = None,
    enable_validation: typing.Optional[builtins.bool] = None,
    location: typing.Optional[builtins.str] = None,
    monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    agent_pool_profiles: typing.Sequence[typing.Union[_AksClusterAgentPoolProfile_19702e0d, typing.Dict[builtins.str, typing.Any]]],
    dns_prefix: builtins.str,
    aad_profile: typing.Optional[typing.Union[_AksClusterAadProfile_cbb39e4e, typing.Dict[builtins.str, typing.Any]]] = None,
    addon_profiles: typing.Optional[typing.Mapping[builtins.str, typing.Union[_AksClusterAddonProfile_75e5bc97, typing.Dict[builtins.str, typing.Any]]]] = None,
    api_server_access_profile: typing.Optional[typing.Union[_AksClusterApiServerAccessProfile_a245e705, typing.Dict[builtins.str, typing.Any]]] = None,
    auto_scaler_profile: typing.Optional[typing.Union[_AksClusterAutoScalerProfile_15ae7fd0, typing.Dict[builtins.str, typing.Any]]] = None,
    disable_local_accounts: typing.Optional[builtins.bool] = None,
    disk_encryption_set_id: typing.Optional[builtins.str] = None,
    enable_rbac: typing.Optional[builtins.bool] = None,
    fqdn: typing.Optional[builtins.str] = None,
    http_proxy_config: typing.Optional[typing.Union[_AksClusterHttpProxyConfig_41bff94e, typing.Dict[builtins.str, typing.Any]]] = None,
    identity: typing.Optional[typing.Union[_AksClusterIdentity_92ed97a4, typing.Dict[builtins.str, typing.Any]]] = None,
    ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
    kubernetes_version: typing.Optional[builtins.str] = None,
    linux_profile: typing.Optional[typing.Union[_AksClusterLinuxProfile_516beb3b, typing.Dict[builtins.str, typing.Any]]] = None,
    network_profile: typing.Optional[typing.Union[_AksClusterNetworkProfile_ec57fbab, typing.Dict[builtins.str, typing.Any]]] = None,
    node_resource_group: typing.Optional[builtins.str] = None,
    oidc_issuer_profile: typing.Optional[typing.Union[_AksClusterOidcIssuerProfile_55bd4791, typing.Dict[builtins.str, typing.Any]]] = None,
    private_fqdn: typing.Optional[builtins.str] = None,
    public_network_access: typing.Optional[builtins.str] = None,
    resource_group_id: typing.Optional[builtins.str] = None,
    security_profile: typing.Optional[typing.Union[_AksClusterSecurityProfile_6e20ee0b, typing.Dict[builtins.str, typing.Any]]] = None,
    service_principal_profile: typing.Optional[typing.Union[_AksClusterServicePrincipalProfile_5638b9c4, typing.Dict[builtins.str, typing.Any]]] = None,
    sku: typing.Optional[typing.Union[_AksClusterSku_746ad049, typing.Dict[builtins.str, typing.Any]]] = None,
    storage_profile: typing.Optional[typing.Union[_AksClusterStorageProfile_cc359e1f, typing.Dict[builtins.str, typing.Any]]] = None,
    support_plan: typing.Optional[builtins.str] = None,
    windows_profile: typing.Optional[typing.Union[_AksClusterWindowsProfile_bf96f6e4, typing.Dict[builtins.str, typing.Any]]] = None,
    workload_auto_scaler_profile: typing.Optional[typing.Union[_AksClusterWorkloadAutoScalerProfile_ec94d7bc, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9721a52865abf32be2154b73382db9dfc693c958006565c429853323f86309e3(
    *,
    id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ebe32299153e5a1cbc70d5fcd6b51487dd08e2d52da35569e0968407e90d3cd0(
    *,
    azure_key_vault_kms: typing.Optional[typing.Union[_AksClusterAzureKeyVaultKms_91079d0f, typing.Dict[builtins.str, typing.Any]]] = None,
    defender: typing.Optional[typing.Union[_AksClusterDefenderSecurityMonitoring_5f628d72, typing.Dict[builtins.str, typing.Any]]] = None,
    image_cleaner: typing.Optional[typing.Union[_AksClusterImageCleaner_eb3f0d8f, typing.Dict[builtins.str, typing.Any]]] = None,
    workload_identity: typing.Optional[typing.Union[_AksClusterWorkloadIdentity_98ca3ec0, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fdce2e9a78b12aa4d370ec1e8a9a4e2759c41ad9355c41f0a903fffb970769c0(
    *,
    client_id: builtins.str,
    secret: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c0f6196323b6d6ff995c641ccd047b533fd26e6aab9f17e5f3dcbe2f94412f5a(
    *,
    name: typing.Optional[builtins.str] = None,
    tier: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1d74a534a33d0aa51d3b52ce58081a5780e612b609e3ee788dc0934622d710e4(
    *,
    enabled: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6eb37030cd5022a3c4cfdc9fae626596d2e3b9717ecc86764ab57e04a3f961e1(
    *,
    public_keys: typing.Sequence[typing.Union[_AksClusterSshPublicKey_6ec15741, typing.Dict[builtins.str, typing.Any]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c6686dd9eceb77f35799e000146402f48d0c7112da791d9c684be5d4c4a7baa5(
    *,
    key_data: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c47115f298723ba199b2f723683ed5b71b9182466cf38ae6992aad1e328df3e4(
    *,
    blob_csi_driver: typing.Optional[typing.Union[_AksClusterBlobCSIDriver_ad59fbc0, typing.Dict[builtins.str, typing.Any]]] = None,
    disk_csi_driver: typing.Optional[typing.Union[_AksClusterDiskCSIDriver_f506f2f6, typing.Dict[builtins.str, typing.Any]]] = None,
    file_csi_driver: typing.Optional[typing.Union[_AksClusterFileCSIDriver_5ce3ba90, typing.Dict[builtins.str, typing.Any]]] = None,
    snapshot_controller: typing.Optional[typing.Union[_AksClusterSnapshotController_1593a1b6, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e7be45ea53e0cd0cf3ed6cc2b878bb6829a3962c486093ab39b1eba8eb855f17(
    *,
    fs_aio_max_nr: typing.Optional[jsii.Number] = None,
    fs_file_max: typing.Optional[jsii.Number] = None,
    fs_inotify_max_user_watches: typing.Optional[jsii.Number] = None,
    fs_nr_open: typing.Optional[jsii.Number] = None,
    kernel_threads_max: typing.Optional[jsii.Number] = None,
    net_core_netdev_max_backlog: typing.Optional[jsii.Number] = None,
    net_core_optmem_max: typing.Optional[jsii.Number] = None,
    net_core_rmem_default: typing.Optional[jsii.Number] = None,
    net_core_rmem_max: typing.Optional[jsii.Number] = None,
    net_core_somaxconn: typing.Optional[jsii.Number] = None,
    net_core_wmem_default: typing.Optional[jsii.Number] = None,
    net_core_wmem_max: typing.Optional[jsii.Number] = None,
    net_ipv4_ip_local_port_range: typing.Optional[builtins.str] = None,
    net_ipv4_neigh_default_gc_thresh1: typing.Optional[jsii.Number] = None,
    net_ipv4_neigh_default_gc_thresh2: typing.Optional[jsii.Number] = None,
    net_ipv4_neigh_default_gc_thresh3: typing.Optional[jsii.Number] = None,
    net_ipv4_tcp_fin_timeout: typing.Optional[jsii.Number] = None,
    net_ipv4_tcpkeepalive_intvl: typing.Optional[jsii.Number] = None,
    net_ipv4_tcp_keepalive_probes: typing.Optional[jsii.Number] = None,
    net_ipv4_tcp_keepalive_time: typing.Optional[jsii.Number] = None,
    net_ipv4_tcp_max_syn_backlog: typing.Optional[jsii.Number] = None,
    net_ipv4_tcp_tw_reuse: typing.Optional[builtins.bool] = None,
    net_netfilter_nf_conntrack_buckets: typing.Optional[jsii.Number] = None,
    net_netfilter_nf_conntrack_max: typing.Optional[jsii.Number] = None,
    vm_max_map_count: typing.Optional[jsii.Number] = None,
    vm_swappiness: typing.Optional[jsii.Number] = None,
    vm_vfs_cache_pressure: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3c83b9bef4e22c8f160596c60b45d9f2a6ee49e5892ff321ddcee8f7e469fbde(
    *,
    enabled: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__afa95326b68be75a8390f6e0166dd38c57c7aa8347426d8555cac4719e7d21d9(
    *,
    admin_username: builtins.str,
    admin_password: typing.Optional[builtins.str] = None,
    enable_csi_proxy: typing.Optional[builtins.bool] = None,
    gmsa_profile: typing.Optional[typing.Union[_AksClusterGmsaProfile_c0e9a445, typing.Dict[builtins.str, typing.Any]]] = None,
    license_type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a81614dd8aa091d61c534212debd456d85aeb71bcf9f71e9d9a3f9b9374b996b(
    *,
    keda: typing.Optional[typing.Union[_AksClusterKeda_9143ef79, typing.Dict[builtins.str, typing.Any]]] = None,
    vertical_pod_autoscaler: typing.Optional[typing.Union[_AksClusterVerticalPodAutoscaler_9805c99b, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3f707f80d3695339710c710be1293383b3cfb67c195c3198ec03bf5dbb237249(
    *,
    enabled: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__12fabbb87f64a0ee51c6e5006ff938a67747ed83b3a25fa560ecafd1b8899108(
    *,
    properties: typing.Mapping[builtins.str, typing.Union[_PropertyDefinition_2a5c46ac, typing.Dict[builtins.str, typing.Any]]],
    required: typing.Sequence[builtins.str],
    resource_type: builtins.str,
    version: builtins.str,
    deprecated: typing.Optional[typing.Sequence[builtins.str]] = None,
    optional: typing.Optional[typing.Sequence[builtins.str]] = None,
    transformation_rules: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    validation_rules: typing.Optional[typing.Sequence[typing.Union[_PropertyValidation_bb241cd7, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__eae53c766f9143385cfa30da80231b50dafd818f3080b18188f5f0c916ecfc50(
    resource_type: builtins.str,
    from_version: builtins.str,
    to_version: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__636a56ca751ba2dbf19051f851f23072e2784c7160fa0cf0bc98210f88b6c1b8(
    resource_type: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5b2e2a21286a265793ba7669b609f098592d5d32196c0618854904f1287e1a21(
    resource_type: builtins.str,
    versions: typing.Sequence[typing.Union[_VersionConfig_ddf991d0, typing.Dict[builtins.str, typing.Any]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__66ce75bb791d3e413bf8c7023c3badc4380fc73c590dc3961bfe4124188fd11f(
    resource_type: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c443670bc20deea13ae38f8902750eec74d9107e2b48beda38016054c3dd3672(
    resource_type: builtins.str,
    version: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__adb294d786c98dfa983d0e38016c245d2dfd857f5389f013bd207654e42e710e(
    resource_type: builtins.str,
    version: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__01628a4957865cbca6342955dff8dba00e1fbcdfa7802c315b2771e4966560df(
    resource_type: builtins.str,
    version: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ae7fe073015cf56686463e87ff5ad30357ed73941be698087bfebc604eadd783(
    message: builtins.str,
    success: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__194415315dbd09ee2b97f91a9ac98f99fec1d41d8249f48d4aa444a47fcb20ed(
    *,
    disable_automatic_rollback: typing.Optional[builtins.bool] = None,
    enable_automatic_os_upgrade: typing.Optional[builtins.bool] = None,
    use_rolling_upgrade_policy: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2871bbbebfc2e7a57f303cea5e9e724a0a67630b4a3d4d1da16441dce722006c(
    *,
    enabled: typing.Optional[builtins.bool] = None,
    grace_period: typing.Optional[builtins.str] = None,
    repair_action: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a5f9cea36880d03010cb1b70995ef9fd0e5cedc71505f6aef89623a0725d0876(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    alias: typing.Optional[builtins.str] = None,
    auxiliary_tenant_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
    client_certificate: typing.Optional[builtins.str] = None,
    client_certificate_password: typing.Optional[builtins.str] = None,
    client_certificate_path: typing.Optional[builtins.str] = None,
    client_id: typing.Optional[builtins.str] = None,
    client_id_file_path: typing.Optional[builtins.str] = None,
    client_secret: typing.Optional[builtins.str] = None,
    client_secret_file_path: typing.Optional[builtins.str] = None,
    custom_correlation_request_id: typing.Optional[builtins.str] = None,
    default_location: typing.Optional[builtins.str] = None,
    default_name: typing.Optional[builtins.str] = None,
    default_tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    disable_correlation_request_id: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    disable_default_output: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    disable_instance_discovery: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    disable_terraform_partner_id: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    enable_preflight: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    endpoint: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AzapiProviderEndpoint, typing.Dict[builtins.str, typing.Any]]]]] = None,
    environment: typing.Optional[builtins.str] = None,
    ignore_no_op_changes: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    maximum_busy_retry_attempts: typing.Optional[jsii.Number] = None,
    oidc_azure_service_connection_id: typing.Optional[builtins.str] = None,
    oidc_request_token: typing.Optional[builtins.str] = None,
    oidc_request_url: typing.Optional[builtins.str] = None,
    oidc_token: typing.Optional[builtins.str] = None,
    oidc_token_file_path: typing.Optional[builtins.str] = None,
    partner_id: typing.Optional[builtins.str] = None,
    skip_provider_registration: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    subscription_id: typing.Optional[builtins.str] = None,
    tenant_id: typing.Optional[builtins.str] = None,
    use_aks_workload_identity: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    use_cli: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    use_msi: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    use_oidc: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3ba65bc39809a5dcaa18f8aae1d1b9aedcff69a7e24e3f885fba93873889ad49(
    scope: _constructs_77d1e7e8.Construct,
    import_to_id: builtins.str,
    import_from_id: builtins.str,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cbef319cbcdc3b9dfed2873506369c085c58a0826d99821619eda6a00e63d6f3(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6f472f50f39b8c5d3dc772e69c963fc12088f62ca8f09c473fdf03761e4673ee(
    value: typing.Optional[typing.List[builtins.str]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3ad1f6fdd24fe8a50dfde5c253049b8d770be9c3fda1ec388d2053c26b903891(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4eac6824e9452d947248f9082f53a122107f4981d6de6e80ebfbca26d559937b(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__192c91d1a15d7c3aa7cb9ffc3640f29223bf07b18b3bda3c242e234eb61e3cd3(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__07a96d3b700872ab930bc5bc74d7e95c2a03ac08e4b48ee97104cfdaea9d557c(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c1e26b5ab83abea93c12873ad7b4ddc95472bef166758e3566bad231d92039ba(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bd283365e4165768209d1912540e5298fe369dd30b0ad23a4541b89b3bb6014f(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d83dc22d1320b596539f411a49de0f7b349627a9f7cac5f8d555a53c37f87fe4(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3ae69862791437eeedf34a23931f1fe7f9742c3ef45a1557464e02e38f7c7133(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cc13316d308c9305ce821a04f8475df7362ceaede7807ea85b72c3a6532d3d86(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c157e91f959779058738f1fded056d71eda2afe7f0174b505e1916c94f9b3a11(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4bd10e19356173cb75790606ab1aa3649a7c8e9e3e4924fbf255d51acd55af0a(
    value: typing.Optional[typing.Mapping[builtins.str, builtins.str]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0046b25253dafd8a4443d551411111e3a1684cf24b68b1dcd027a25b2c354087(
    value: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3083546a2444fcec43137c39dd049dec6e81c21684000a2478a9be8a0434c63b(
    value: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c399e874c1ab99108de9b47f3f1a53991cdd5a0eb3f9202ae6d6cebbfe46ff3c(
    value: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dd0d21b3536e3afb9ff76c5ae5585e1628151a0074c2e241bed4ead00ca7b818(
    value: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__32607907e38170d3c83198fd00249aac8572000e382e2dc0a3334fb8153a9282(
    value: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__91f6968bc0a4a51723460748c8091fbfc788473f329c4c3ad744a9daf8156751(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[AzapiProviderEndpoint]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d2585570a5b3332ac856dc8da712d5b32119817dc1eaacd15cc3e29f5b8b9225(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f5e900c1f939f76e9bc5870d4ec316991c06cab7fb9f242e3650f58820592ff8(
    value: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9dd31d3a0f7809f3abfadefd5f8c5542fd03b4c1a17913dcb59e66975fbdd988(
    value: typing.Optional[jsii.Number],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6612fee56d135557c55748e3c5c39dba0aaa7b8cf46b0de36c271a6567552c8c(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a89f375b050cf3e54f1c6b611c1ee8e60258a30a95c449ad98414afcc7a6dda4(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c356fea0ba2de63e2e00a20fe59cb3f10954316bb48e1d9fd545683f1238fb9b(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__de78f75019c74030e70ee1520b66bdd57d3db25e9e003d269b728e0e02bf7206(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ab4379fc35fa0c77469fa8239a886b77d559aee70e7e3ca2bd9525eb7cb236b4(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7a65e284b5b33953f3d2ab11b53df3314df9260a2f68e90c3e0fe26af5703f1d(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9683081adbac3650d402b3d5c1a41f67eb0194bece8af01490468efbdf9efe67(
    value: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c2c1d3492caa78bee03ff6abde16e0e65a42bd2c1d421f8f5bf61d9d6dce9893(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c7d85fee89293f961ee7e797adfe2d2796df11659432f35596e2eb5ea26897e2(
    value: typing.Optional[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ffb44e3f261fb44fb26cf681e3ed1685e8e6268fba092a9e6e4d53408b021dc9(
    value: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__efc142c4fc0ed9dbe988481a16304ceb12d9ca7056877fc582def8e535d839fc(
    value: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6970f455abde7e9b23b5245b4ef11346898ab51acc7fe841ae216f3f2c1cb897(
    value: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2a96ef46b735f91b71ef9183f55300d732d6eb9d1478ab35e4d31f38bd0bb151(
    value: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e7d692e84c0367b0bd21eafe6eb47edbb4983681b82743ac15b73d3c33c2e11f(
    *,
    alias: typing.Optional[builtins.str] = None,
    auxiliary_tenant_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
    client_certificate: typing.Optional[builtins.str] = None,
    client_certificate_password: typing.Optional[builtins.str] = None,
    client_certificate_path: typing.Optional[builtins.str] = None,
    client_id: typing.Optional[builtins.str] = None,
    client_id_file_path: typing.Optional[builtins.str] = None,
    client_secret: typing.Optional[builtins.str] = None,
    client_secret_file_path: typing.Optional[builtins.str] = None,
    custom_correlation_request_id: typing.Optional[builtins.str] = None,
    default_location: typing.Optional[builtins.str] = None,
    default_name: typing.Optional[builtins.str] = None,
    default_tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    disable_correlation_request_id: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    disable_default_output: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    disable_instance_discovery: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    disable_terraform_partner_id: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    enable_preflight: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    endpoint: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[AzapiProviderEndpoint, typing.Dict[builtins.str, typing.Any]]]]] = None,
    environment: typing.Optional[builtins.str] = None,
    ignore_no_op_changes: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    maximum_busy_retry_attempts: typing.Optional[jsii.Number] = None,
    oidc_azure_service_connection_id: typing.Optional[builtins.str] = None,
    oidc_request_token: typing.Optional[builtins.str] = None,
    oidc_request_url: typing.Optional[builtins.str] = None,
    oidc_token: typing.Optional[builtins.str] = None,
    oidc_token_file_path: typing.Optional[builtins.str] = None,
    partner_id: typing.Optional[builtins.str] = None,
    skip_provider_registration: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    subscription_id: typing.Optional[builtins.str] = None,
    tenant_id: typing.Optional[builtins.str] = None,
    use_aks_workload_identity: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    use_cli: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    use_msi: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    use_oidc: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__851cbf09da93a2f7da6f5df43609d143ac73c1c5c700dd702e268a8a9655aa6c(
    *,
    active_directory_authority_host: typing.Optional[builtins.str] = None,
    resource_manager_audience: typing.Optional[builtins.str] = None,
    resource_manager_endpoint: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a3d3c58c42b41b398803c4efbf0772e4a0c8784d47b74c87dd9ebf23d9d738a1(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    api_version: typing.Optional[builtins.str] = None,
    enable_migration_analysis: typing.Optional[builtins.bool] = None,
    enable_transformation: typing.Optional[builtins.bool] = None,
    enable_validation: typing.Optional[builtins.bool] = None,
    location: typing.Optional[builtins.str] = None,
    monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cf9f6337079df9eb970b9ad080311376c6164a0dce9d7c1d809e4636d3c6e000(
    resource_type: builtins.str,
    versions: typing.Sequence[typing.Union[_VersionConfig_ddf991d0, typing.Dict[builtins.str, typing.Any]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f4ceb970ba75ee62b0297d00ddb7ae9f80bbe8dfed04665ca5ac0918f20f697f(
    object_id: builtins.str,
    role_definition_name: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c68a84cebf10cce28dc776128d9fe29d809c2c82d60fe425d0c70628635e8eb9(
    key: builtins.str,
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__238050e80b865d80a0d7c8e5a26741c84d5a802fc7496802ec85f097ef48ad07(
    target_version: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__83e5393f73b29a9c8e15e27771f790289e23467d98ec01c6de05e6c376dc7035(
    resource_id: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a404c6dee43160589c1a592d4c91470f8bc17a406da1d37b670f3f4d7fe00f53(
    properties: typing.Mapping[builtins.str, typing.Any],
    parent_id: builtins.str,
    name: builtins.str,
    location: typing.Optional[builtins.str] = None,
    parent_resource: typing.Optional[_AzapiResource_7e7f5b39] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cc42b99cf502face5ee1f35101499a4f83e9c4977fc6a3e5290ec43eead5a095(
    config: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0f4da57c858d29cc3485cd8769a7c9c26ad5686c46b8919d7b5cde5a17ff2d4b(
    props: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3049a84daed50c8ec29f4ae37b33f5f4495e2a3b712158dcc6f0c7b6bf15dd71(
    properties: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b91a33d29131d7ab402a65df456389e901806e839a3487c32234d121e24540f8(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5857bd3dd3c5748437251edd5ba9165c55519b7e27cec8aede95ae6a3a19dbef(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0fb0f58401a9dff57c19347d990f1c4b67552ebdb9753625690ed1a4809672b8(
    value: _ApiSchema_5ce0490e,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1fec2795df9e0c4f2b5fa75ff33324d735773ce6d94e46bea101a8717a85e2f2(
    value: _cdktf_9a9027ec.TerraformResource,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6e58eeb6020167da6a9493fdbd06f3f8eacd108b6ae212570991c11b94a0dc11(
    value: _VersionConfig_ddf991d0,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7f528df0ff7249fb6afc5c73601b6f5b16a73c88ac3d27c75173e1cf915a4c34(
    value: typing.Optional[_MigrationAnalysis_aa719f40],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f84b4af5084c31757c50d9f1259dfff939670d44a84c39a671aa1ea6f9330ad9(
    value: typing.Optional[_ValidationResult_87269226],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8b528c66806e6c4d819f260a5384e8b851df8221b890e5cb4ff575de78472b1c(
    props: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3d93af01845ca8c4fccb8df898596d1e45bcb9c1695be8e9787e78e62e393dfa(
    *,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    api_version: typing.Optional[builtins.str] = None,
    enable_migration_analysis: typing.Optional[builtins.bool] = None,
    enable_transformation: typing.Optional[builtins.bool] = None,
    enable_validation: typing.Optional[builtins.bool] = None,
    location: typing.Optional[builtins.str] = None,
    monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__89a5f56067301c27b4a88c97c0bd8eb62b4ad952688cae6c4f4430ff1375d4ad(
    scope_: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    object_id: builtins.str,
    role_definition_name: builtins.str,
    scope: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__333820b506b51590b5eebe73fd9c0f718a72a7642876a758352f5ef516c7e6ba(
    *,
    object_id: builtins.str,
    role_definition_name: builtins.str,
    scope: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c85861f0d4a940a106186a175c34fae8bc741b46644dcb5be999d94ef7f1c0a8(
    *,
    function_app_resource_id: builtins.str,
    function_name: builtins.str,
    http_trigger_url: builtins.str,
    name: builtins.str,
    use_common_alert_schema: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__16460280811f9f2724ccd3b87254ebd16f53c2d53bb01bf9756133f158791eb7(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    test_run_options: typing.Optional[typing.Union[TestRunOptions, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__81e4c9adfc4da93a3c11e11036f4464715cef73d8184d2d1a797db0a9a992aac(
    resource_type: builtins.str,
    custom_identifier: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bcdd0e0aa15b47800d501644be23172374bc8f8b4ab62d39724a9980bd130b34(
    resource_id: builtins.str,
    resource_type: builtins.str,
    name: builtins.str,
    location: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__754523de47175eab260ebc6066f389361a572594eb7c1228e4fac5a665526a3f(
    *,
    test_run_options: typing.Optional[typing.Union[TestRunOptions, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d8294b7173ae32b733a72e6bd891a22906cfb0103b787259df438fea598a74df(
    *,
    change_type: builtins.str,
    description: builtins.str,
    migration_path: typing.Optional[builtins.str] = None,
    new_value: typing.Optional[builtins.str] = None,
    old_value: typing.Optional[builtins.str] = None,
    property: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1ec023d37c6f1585bf2ba961327d5c12143dbf473919ab5029082cece733b95c(
    *,
    platform: builtins.str,
    branch: typing.Optional[builtins.str] = None,
    commit_sha: typing.Optional[builtins.str] = None,
    commit_sha_short: typing.Optional[builtins.str] = None,
    pipeline_id: typing.Optional[builtins.str] = None,
    repository: typing.Optional[builtins.str] = None,
    run_id: typing.Optional[builtins.str] = None,
    run_number: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__55fd44e885c5ef5f1b1e8f2ff314fc705d9474c215a41e2a19022b7597a276bd(
    *,
    errors: typing.Sequence[builtins.str],
    valid: builtins.bool,
    warnings: typing.Sequence[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__09c49f049abc2780c902c1a7737c5c054044ade357f6dd9cd8fa6fa4171515aa(
    *,
    dry_run: builtins.bool,
    min_age_hours: jsii.Number,
    max_resources: typing.Optional[jsii.Number] = None,
    resource_groups: typing.Optional[typing.Sequence[builtins.str]] = None,
    subscription: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__eed79dbe42a796f5dca7242cf50bae5f47475cf9b28b985583f004bb4fa04d1e(
    *,
    deleted: jsii.Number,
    failed: jsii.Number,
    skipped: jsii.Number,
    errors: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bb63d7912d498d993295b04451dc117e1e8dbc215978e4ec6945e12fa1d657f4(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    applies_to_groups: typing.Sequence[typing.Union[_ConnectivityGroupItem_d310024f, typing.Dict[builtins.str, typing.Any]]],
    connectivity_topology: builtins.str,
    network_manager_id: builtins.str,
    delete_existing_peering: typing.Optional[builtins.bool] = None,
    description: typing.Optional[builtins.str] = None,
    hubs: typing.Optional[typing.Sequence[typing.Union[_Hub_d4efdd65, typing.Dict[builtins.str, typing.Any]]]] = None,
    ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
    is_global: typing.Optional[builtins.bool] = None,
    api_version: typing.Optional[builtins.str] = None,
    enable_migration_analysis: typing.Optional[builtins.bool] = None,
    enable_transformation: typing.Optional[builtins.bool] = None,
    enable_validation: typing.Optional[builtins.bool] = None,
    location: typing.Optional[builtins.str] = None,
    monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0fd68c1eb064a90a196cb1012011da15c432f44082a1a723b4e9fc50a5870862(
    props: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5c77220258d119867457f1f77fb9d3259949ebfafa74999bcf1bf26a6f3ef207(
    props: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__32c51cf29761b526ad9e8a1bcb451ace788251bd292bbac46bdd896b3dc5f987(
    *,
    properties: typing.Union[_ConnectivityConfigurationProperties_87ca695a, typing.Dict[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__868c54a4cc2cb6b45f53eb11129356366ce8afe795ffa3503ee6dedcc5b11833(
    *,
    applies_to_groups: typing.Sequence[typing.Union[_ConnectivityGroupItem_d310024f, typing.Dict[builtins.str, typing.Any]]],
    connectivity_topology: builtins.str,
    delete_existing_peering: typing.Optional[builtins.bool] = None,
    description: typing.Optional[builtins.str] = None,
    hubs: typing.Optional[typing.Sequence[typing.Union[_Hub_d4efdd65, typing.Dict[builtins.str, typing.Any]]]] = None,
    is_global: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e8751f6e357e5fde8ef0a95f373d72e5bba216bde94d30235bbd73e60264acb7(
    *,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    api_version: typing.Optional[builtins.str] = None,
    enable_migration_analysis: typing.Optional[builtins.bool] = None,
    enable_transformation: typing.Optional[builtins.bool] = None,
    enable_validation: typing.Optional[builtins.bool] = None,
    location: typing.Optional[builtins.str] = None,
    monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    applies_to_groups: typing.Sequence[typing.Union[_ConnectivityGroupItem_d310024f, typing.Dict[builtins.str, typing.Any]]],
    connectivity_topology: builtins.str,
    network_manager_id: builtins.str,
    delete_existing_peering: typing.Optional[builtins.bool] = None,
    description: typing.Optional[builtins.str] = None,
    hubs: typing.Optional[typing.Sequence[typing.Union[_Hub_d4efdd65, typing.Dict[builtins.str, typing.Any]]]] = None,
    ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
    is_global: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bca2000a633d7e43296ca48227153c939b0cd1b0978ddee28633518123f8dad7(
    *,
    network_group_id: builtins.str,
    group_connectivity: typing.Optional[builtins.str] = None,
    is_global: typing.Optional[builtins.bool] = None,
    use_hub_gateway: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__34f4021e722333d7f25f2e4702396e5276828ffb21525238dd3c45563e02b6a3(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    timeouts: typing.Optional[typing.Union[DataAzapiClientConfigTimeouts, typing.Dict[builtins.str, typing.Any]]] = None,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f43f7445d243271bb445d650158c0a6cd22ba9fd8ea9970670f0cea11d5394fc(
    scope: _constructs_77d1e7e8.Construct,
    import_to_id: builtins.str,
    import_from_id: builtins.str,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3c9f620c2016730f9330066fb5a51d70a38250d6e21a8b8f1ce23836d805be79(
    *,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    timeouts: typing.Optional[typing.Union[DataAzapiClientConfigTimeouts, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__559899a120c7542a83bac439c0c3f3d9e28ae76e687898d3d992b6f5b929a74d(
    *,
    read: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__74702f390141f764fdf6ec8eb155f7eb2c824e59e3b141fa3196ed4a5350f0c7(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__63da91f92c12e34f842a43a27ea2bc2c2c3df1463eb79efb44c1003d8e44ce93(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__58c110e2e7a2d356e44dd596702a266c4aaf9a93226e8ed3699bf16cf421ad08(
    value: typing.Optional[typing.Union[DataAzapiClientConfigTimeouts, _cdktf_9a9027ec.IResolvable]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c7adc2f8d37c7c562f56758085ff1ec8beb6d7c11a4cfcb4d36e46f4146dda82(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    type: builtins.str,
    headers: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ignore_not_found: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    name: typing.Optional[builtins.str] = None,
    parent_id: typing.Optional[builtins.str] = None,
    query_parameters: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.Sequence[builtins.str]]]] = None,
    resource_id: typing.Optional[builtins.str] = None,
    response_export_values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    retry: typing.Optional[typing.Union[DataAzapiResourceRetry, typing.Dict[builtins.str, typing.Any]]] = None,
    timeouts: typing.Optional[typing.Union[DataAzapiResourceTimeouts, typing.Dict[builtins.str, typing.Any]]] = None,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d4c438be36fd54e6c7c284316721e6699fe2e8e9bbba08d512fe1507a1049fef(
    scope: _constructs_77d1e7e8.Construct,
    import_to_id: builtins.str,
    import_from_id: builtins.str,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__532d97aa870529660c4bb38e18637d27a329afd791f69324d29e8c23918feacc(
    value: typing.Mapping[builtins.str, builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7c7b6ba90e6525a0888421f65f18cd2160c9ab5bffd8b8ae5840becb3d9c3e33(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a49f04a156217b464936ec6285683f722fe2e88d24de4855728301de3368faf2(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__33be1f50f28912350c4a22da8b162035af549991b54c487195c8fdb4960586f5(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0b491d5f9a457e87acb9042e9b853667cbeb9fb2cd21cecef5065a2fb4e71ea7(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.List[builtins.str]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__356cd5f181512a85cfff66fa3db791df26401c7b2d626de6392f2519ff9c557a(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f9c01a34e566c6937403b0fafb4a100e3abbcc1db069dd1caf8e855db42bdef5(
    value: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__47046806ff469369bcac6d1865435c667e47641d7c3204ae81407a1285900fdd(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c81d39048b6d0968fcf6fbef1d7ef5bb78330c8ca8858fed7fc798fcffac245b(
    *,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    type: builtins.str,
    headers: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ignore_not_found: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    name: typing.Optional[builtins.str] = None,
    parent_id: typing.Optional[builtins.str] = None,
    query_parameters: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.Sequence[builtins.str]]]] = None,
    resource_id: typing.Optional[builtins.str] = None,
    response_export_values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    retry: typing.Optional[typing.Union[DataAzapiResourceRetry, typing.Dict[builtins.str, typing.Any]]] = None,
    timeouts: typing.Optional[typing.Union[DataAzapiResourceTimeouts, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1af1f16ee49f8f1eb006892654b067335c5615e2119218c5b463d4cd44423f71(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d73de6bb31eacadea85076048396d22000065823db94ddd1398c0ebc6196b7ae(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c7755a917cdb6be8ff581071fa397721555e704f38079240354d4f1cc8cf58cd(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e59e0c1efdfe9e360a8b160c99e164413d90aa08c76354ad57231e66646bf5e9(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ce708e452384cc56e89d6a8aa944455b4c1097e39e75cafaefe7183c36be1830(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ea14b6293e41393e2fd23f7e4a73431cd1e1137ffb7c53758a4cf2a2fd74affb(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ce9040397215b4f9cc31e4481741d637cc116b2b4aa4a6bedbce6a1f3336c142(
    value: typing.Optional[DataAzapiResourceIdentity],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7df04d06c2cc51fbca413d1c00ad46d2a1231995725232a29cf8c42c404b954e(
    *,
    error_message_regex: typing.Sequence[builtins.str],
    interval_seconds: typing.Optional[jsii.Number] = None,
    max_interval_seconds: typing.Optional[jsii.Number] = None,
    multiplier: typing.Optional[jsii.Number] = None,
    randomization_factor: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2093914b52815f6c9f8f992df1e490405d2fb0eb3ed92c9d12ecd78f76c683d0(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7a08560fae648b3b5587da5a173b5f7b330ee74ec71188926d8006dd1bc43e84(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a2813ac3834b9d62cab14b97312422f75191219f69e06ef89e97110a04930650(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5f61a85e616e3222353b76f2e6ba60eb38b06dac1f282e0175f8b23a6ae69827(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1ef580c9234e481bb8cb64902ced476c99a940aa92a2e32553f1b1eb4b7fdd9d(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__db016357007f9e31917cffe65e419e26e724e9164b120cb8f4825e4cbc07df46(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e4f27b8b9a04ee51a1b03e59d5efdc7997eb9cc45d244898d6cc9af1d08e2587(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, DataAzapiResourceRetry]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b14e05c954c1083e933078931799aaca03614921080ec3501a0a4da372188b05(
    *,
    read: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__183f068e9cac6c72ba2e3837cc9bcc89ba93501fd5abf5143b74944927e66735(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__396e5079c2a95967f0c3551f59fb096a3ea2e0a28556d951c2e7f9bf9e3f67e9(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9843de41b9274baf366d7a3297247ff082f08ded71e4a69545bf5833e132cd45(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, DataAzapiResourceTimeouts]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__96fea199b663d9dbe1256ea8303c743d790a1bb46e0ef9a6183d574a3bd2f34b(
    *,
    enabled: builtins.bool,
    category: typing.Optional[builtins.str] = None,
    category_group: typing.Optional[builtins.str] = None,
    retention_policy: typing.Optional[typing.Union[_RetentionPolicyConfig_13c42ec6, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ad20bcfb2d477281861ea968578dce4848dbca7c10255e4d7a1f910c686b0785(
    *,
    enabled: builtins.bool,
    category: typing.Optional[builtins.str] = None,
    retention_policy: typing.Optional[typing.Union[_RetentionPolicyConfig_13c42ec6, typing.Dict[builtins.str, typing.Any]]] = None,
    time_grain: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__51d0e5fc2996d16bd2c2198e13321b1d5aff2b2cacfb88f4fc4ca19b1367c9c0(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    target_resource_id: builtins.str,
    event_hub_authorization_rule_id: typing.Optional[builtins.str] = None,
    event_hub_name: typing.Optional[builtins.str] = None,
    log_analytics_destination_type: typing.Optional[builtins.str] = None,
    logs: typing.Optional[typing.Sequence[typing.Union[_DiagnosticLogConfig_990fcbff, typing.Dict[builtins.str, typing.Any]]]] = None,
    metrics: typing.Optional[typing.Sequence[typing.Union[_DiagnosticMetricConfig_29c0add1, typing.Dict[builtins.str, typing.Any]]]] = None,
    storage_account_id: typing.Optional[builtins.str] = None,
    workspace_id: typing.Optional[builtins.str] = None,
    api_version: typing.Optional[builtins.str] = None,
    enable_migration_analysis: typing.Optional[builtins.bool] = None,
    enable_transformation: typing.Optional[builtins.bool] = None,
    enable_validation: typing.Optional[builtins.bool] = None,
    location: typing.Optional[builtins.str] = None,
    monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3fe421ace719ca938403552f41dee71478e4ec59c28858c0f7989f45dae22041(
    props: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e499a0d9d2a8e7aeb996796c4846e409a3e3a5cfc33db36be01c2a6eb5da8156(
    props: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__70cf2c8bb788e97cd49f2f7be4bcbe9c091d185987c80aafe5fe2d77e826863f(
    *,
    properties: typing.Union[_DiagnosticSettingsBodyProperties_ed65245b, typing.Dict[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d077af97d422aed9b806a9f1edeecdf9d99b667cd617271f9a12cc4e9ab30479(
    *,
    event_hub_authorization_rule_id: typing.Optional[builtins.str] = None,
    event_hub_name: typing.Optional[builtins.str] = None,
    log_analytics_destination_type: typing.Optional[builtins.str] = None,
    logs: typing.Optional[typing.Sequence[typing.Union[_DiagnosticLogConfig_990fcbff, typing.Dict[builtins.str, typing.Any]]]] = None,
    metrics: typing.Optional[typing.Sequence[typing.Union[_DiagnosticMetricConfig_29c0add1, typing.Dict[builtins.str, typing.Any]]]] = None,
    storage_account_id: typing.Optional[builtins.str] = None,
    workspace_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d6ea315f7f318cca71dba75218c4fcd80970e2821f918caa34dcdc09d2f863ed(
    *,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    api_version: typing.Optional[builtins.str] = None,
    enable_migration_analysis: typing.Optional[builtins.bool] = None,
    enable_transformation: typing.Optional[builtins.bool] = None,
    enable_validation: typing.Optional[builtins.bool] = None,
    location: typing.Optional[builtins.str] = None,
    monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    target_resource_id: builtins.str,
    event_hub_authorization_rule_id: typing.Optional[builtins.str] = None,
    event_hub_name: typing.Optional[builtins.str] = None,
    log_analytics_destination_type: typing.Optional[builtins.str] = None,
    logs: typing.Optional[typing.Sequence[typing.Union[_DiagnosticLogConfig_990fcbff, typing.Dict[builtins.str, typing.Any]]]] = None,
    metrics: typing.Optional[typing.Sequence[typing.Union[_DiagnosticMetricConfig_29c0add1, typing.Dict[builtins.str, typing.Any]]]] = None,
    storage_account_id: typing.Optional[builtins.str] = None,
    workspace_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__caf754a9ba2508d367fa5f31c17d63f6739d53b7908d43004115b31323dc2b23(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    dns_resolver_outbound_endpoint_ids: typing.Sequence[builtins.str],
    ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
    resource_group_id: typing.Optional[builtins.str] = None,
    api_version: typing.Optional[builtins.str] = None,
    enable_migration_analysis: typing.Optional[builtins.bool] = None,
    enable_transformation: typing.Optional[builtins.bool] = None,
    enable_validation: typing.Optional[builtins.bool] = None,
    location: typing.Optional[builtins.str] = None,
    monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__785dbeb27ef9a99a31c197035a4dd8bda6f7a25f6b5e7ed96b3ed4ccc4d4ea95(
    key: builtins.str,
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f2faf5f4cc0bb624cfd8391ae6878eb64ff0e110f40419b7dda5ff15957f58f8(
    props: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__231996d50e7742c31611f9f16f2e3d8277579f6cd753ce470a8d9763a4c5536c(
    key: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0a2e2bd51043e438050bea03d411b40c993b7e32ca52f70bee201120f3f568fc(
    *,
    location: builtins.str,
    properties: typing.Union[_DnsForwardingRulesetProperties_2e4f976e, typing.Dict[builtins.str, typing.Any]],
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__14d5a8e161fae5bbcba539b2f92920730ccd6fb5fcde2b9fd060ab335e41be17(
    *,
    dns_resolver_outbound_endpoints: typing.Sequence[typing.Union[_DnsResolverOutboundEndpointReference_c6bd5513, typing.Dict[builtins.str, typing.Any]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ba211b5061f5f5b0965e8279044a08e05445029ed7ff4e710eaf8c4433936154(
    *,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    api_version: typing.Optional[builtins.str] = None,
    enable_migration_analysis: typing.Optional[builtins.bool] = None,
    enable_transformation: typing.Optional[builtins.bool] = None,
    enable_validation: typing.Optional[builtins.bool] = None,
    location: typing.Optional[builtins.str] = None,
    monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    dns_resolver_outbound_endpoint_ids: typing.Sequence[builtins.str],
    ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
    resource_group_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__76c13541401dcdbff5f5f3080526f13d5b1233ab4db741b9cb6770aea3e63abb(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    dns_forwarding_ruleset_id: builtins.str,
    virtual_network_id: builtins.str,
    ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
    metadata: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    api_version: typing.Optional[builtins.str] = None,
    enable_migration_analysis: typing.Optional[builtins.bool] = None,
    enable_transformation: typing.Optional[builtins.bool] = None,
    enable_validation: typing.Optional[builtins.bool] = None,
    location: typing.Optional[builtins.str] = None,
    monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__db1ff57177b88b743d765aa8547942d134a9ca001c7b385c2aa809b75d6bf945(
    props: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__83958202f42de62bdff5a1e508f0c4b1f1f4d975e018eb701b23f0fc47acfdce(
    props: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3d500bfc608bae79acbf86e8eab9deab9ea3620f597c7b5616a111f49e3c3f09(
    *,
    properties: typing.Union[_DnsForwardingRulesetVirtualNetworkLinkProperties_c0ccbf67, typing.Dict[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bdad081330f0e605cfc7d3ab115ecc5a6f2d6d6a72a1e4c6f641d136ee5bbb18(
    *,
    virtual_network: typing.Union[_DnsForwardingRulesetVirtualNetworkReference_4806dc52, typing.Dict[builtins.str, typing.Any]],
    metadata: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8aaf2aa9cfbcbef306c0fa40dc17e86b12e38dbdcf94d8e6189b8746a639f1d2(
    *,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    api_version: typing.Optional[builtins.str] = None,
    enable_migration_analysis: typing.Optional[builtins.bool] = None,
    enable_transformation: typing.Optional[builtins.bool] = None,
    enable_validation: typing.Optional[builtins.bool] = None,
    location: typing.Optional[builtins.str] = None,
    monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    dns_forwarding_ruleset_id: builtins.str,
    virtual_network_id: builtins.str,
    ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
    metadata: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__934f8d19affdf51ded32eb6a6a3d795e26529dc5b7faf07f3746eebee302c06a(
    *,
    id: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3c7442e9510fce65b844fde372cd7cc8a1a8f606ee9e9d3eca4760ff7a6dedc5(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    virtual_network_id: builtins.str,
    ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
    resource_group_id: typing.Optional[builtins.str] = None,
    api_version: typing.Optional[builtins.str] = None,
    enable_migration_analysis: typing.Optional[builtins.bool] = None,
    enable_transformation: typing.Optional[builtins.bool] = None,
    enable_validation: typing.Optional[builtins.bool] = None,
    location: typing.Optional[builtins.str] = None,
    monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__aeaa7c4898193896e5b1d278ad915ecf0c06fa46081241524f9c439652080940(
    key: builtins.str,
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ff3c3d5e34bbfa210970579d63ed38b4c926ba97364bcd9cca1e05ef5a231219(
    props: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3a0430449fc63d4ec11fe077562024e83fdec71b251b2d4c35eddf0ac4cd9934(
    key: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ad5e247fb3984fdc0f371c3ab66b41cfd24998c0f13397a25e48982f3142aec0(
    *,
    location: builtins.str,
    properties: typing.Any = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9a901647f22f035f96463234e2080c4ee07bdd60bc4810c43ef0ea817f170419(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    dns_resolver_id: builtins.str,
    subnet_id: builtins.str,
    ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
    private_ip_address: typing.Optional[builtins.str] = None,
    private_ip_allocation_method: typing.Optional[builtins.str] = None,
    api_version: typing.Optional[builtins.str] = None,
    enable_migration_analysis: typing.Optional[builtins.bool] = None,
    enable_transformation: typing.Optional[builtins.bool] = None,
    enable_validation: typing.Optional[builtins.bool] = None,
    location: typing.Optional[builtins.str] = None,
    monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1c7f9fb1309f6da100e276138cf149a6d8ccd81248180fca8c522a507c35ebb3(
    key: builtins.str,
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3283ce810a8da2fbb9d6e3878fb747372871d36b8ec1c6d62c4045f9174852c5(
    props: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ef97a4822ba45c9cc177ac912041a467e75d3ce4c8cf3dc155eeb25139f1ab15(
    key: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__66f8a7a71a1bea270ad689eabbb36dca95b84a9d7c5b41fcce2499d0fdc98b0c(
    props: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__33df3464fcafe1dd8635001f474671d784e4c52fabc025b14c548e939036614b(
    *,
    location: builtins.str,
    properties: typing.Any = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a147c7794712e3bc50425e2346ba0cb5ce36bd56cc4f3e09ec9ccfd6bcbfb6b8(
    *,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    api_version: typing.Optional[builtins.str] = None,
    enable_migration_analysis: typing.Optional[builtins.bool] = None,
    enable_transformation: typing.Optional[builtins.bool] = None,
    enable_validation: typing.Optional[builtins.bool] = None,
    location: typing.Optional[builtins.str] = None,
    monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    dns_resolver_id: builtins.str,
    subnet_id: builtins.str,
    ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
    private_ip_address: typing.Optional[builtins.str] = None,
    private_ip_allocation_method: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5eebe8817bdacd476de7a5fd806dee8b0caeb5eb9524a6581fa3c24168110996(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    dns_resolver_id: builtins.str,
    subnet_id: builtins.str,
    ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
    api_version: typing.Optional[builtins.str] = None,
    enable_migration_analysis: typing.Optional[builtins.bool] = None,
    enable_transformation: typing.Optional[builtins.bool] = None,
    enable_validation: typing.Optional[builtins.bool] = None,
    location: typing.Optional[builtins.str] = None,
    monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3d15a3ee5f3ab6164e072033f6111414072eb73b63efc5a8525d5cc886b1bab3(
    key: builtins.str,
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__87c147165896c4ecd2ee526f8de682c101bed21b358fd3b32ec2dd06a0226dc2(
    props: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e6d7455f4f9b9651f6c968ba166fd8ec1476e1eca481cc9133aae4f67c1edb29(
    key: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c07ed0deadbd7dd61e1f2ff2f2fd4a2622fdaa0a97a4f2dd5e3c5b9e9994c1ea(
    props: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a8cb7b0ca5706826db06ce43de5fa28f9be4f3a3e0e60a7829dbdcd31c732cf2(
    *,
    location: builtins.str,
    properties: typing.Any = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bc086e7c010bdfc5521087a817616cfd80ee9f96c8b843ee0709104c483b92df(
    *,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    api_version: typing.Optional[builtins.str] = None,
    enable_migration_analysis: typing.Optional[builtins.bool] = None,
    enable_transformation: typing.Optional[builtins.bool] = None,
    enable_validation: typing.Optional[builtins.bool] = None,
    location: typing.Optional[builtins.str] = None,
    monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    dns_resolver_id: builtins.str,
    subnet_id: builtins.str,
    ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2c53eca7cf4e5bf300890582b96e0fde622b84dacd342dfc89043c36a9875ac2(
    *,
    id: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8a35108416bae4beb987e0f3d1796ea58ac0e838b7c55fd4432531d9deed926c(
    *,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    api_version: typing.Optional[builtins.str] = None,
    enable_migration_analysis: typing.Optional[builtins.bool] = None,
    enable_transformation: typing.Optional[builtins.bool] = None,
    enable_validation: typing.Optional[builtins.bool] = None,
    location: typing.Optional[builtins.str] = None,
    monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    virtual_network_id: builtins.str,
    ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
    resource_group_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5731b0055d9b8a9cf5a27a4def7635cce8511c1a42dafff59886be904488bf5e(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
    registration_virtual_networks: typing.Optional[typing.Sequence[typing.Union[_VirtualNetworkReference_d6a6c338, typing.Dict[builtins.str, typing.Any]]]] = None,
    resolution_virtual_networks: typing.Optional[typing.Sequence[typing.Union[_VirtualNetworkReference_d6a6c338, typing.Dict[builtins.str, typing.Any]]]] = None,
    resource_group_id: typing.Optional[builtins.str] = None,
    zone_type: typing.Optional[builtins.str] = None,
    api_version: typing.Optional[builtins.str] = None,
    enable_migration_analysis: typing.Optional[builtins.bool] = None,
    enable_transformation: typing.Optional[builtins.bool] = None,
    enable_validation: typing.Optional[builtins.bool] = None,
    location: typing.Optional[builtins.str] = None,
    monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__32defd73e514ad305ce83b421d3da4f873a5cd17d26ef93432d61198f9c1f45e(
    key: builtins.str,
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__80079bfce735c9fde26ac5b4e3c7856de22766d90f4fb5ead45b08da170a8159(
    props: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c0deb5b00bdc175c517e381205c1b9dacfb45973f693b0547edfe6893ba68a86(
    key: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b086c081746a2eb53611ce1a28f9644cba9a7a094ec356b6d1f8a0bf343890dd(
    *,
    location: builtins.str,
    properties: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__12a3ad79b351d036f13c3f172408401e66ecb525e64284ba7006bead44d7b279(
    *,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    api_version: typing.Optional[builtins.str] = None,
    enable_migration_analysis: typing.Optional[builtins.bool] = None,
    enable_transformation: typing.Optional[builtins.bool] = None,
    enable_validation: typing.Optional[builtins.bool] = None,
    location: typing.Optional[builtins.str] = None,
    monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
    registration_virtual_networks: typing.Optional[typing.Sequence[typing.Union[_VirtualNetworkReference_d6a6c338, typing.Dict[builtins.str, typing.Any]]]] = None,
    resolution_virtual_networks: typing.Optional[typing.Sequence[typing.Union[_VirtualNetworkReference_d6a6c338, typing.Dict[builtins.str, typing.Any]]]] = None,
    resource_group_id: typing.Optional[builtins.str] = None,
    zone_type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__907b80e73375e97e11e1927ff5317d693849a47e4ad192ce8c965950ee6f3bac(
    *,
    alert_sensitivity: builtins.str,
    failing_periods: typing.Union[_MetricAlertFailingPeriods_93398eb2, typing.Dict[builtins.str, typing.Any]],
    metric_name: builtins.str,
    operator: builtins.str,
    time_aggregation: builtins.str,
    type: builtins.str,
    dimensions: typing.Optional[typing.Sequence[typing.Union[_MetricDimension_8611b872, typing.Dict[builtins.str, typing.Any]]]] = None,
    ignore_data_before: typing.Optional[builtins.str] = None,
    metric_namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f7216c9d36730b62fc10f9a8f68d553286b25849d4741f71052c712c2c7e1c60(
    *,
    email_address: builtins.str,
    name: builtins.str,
    use_common_alert_schema: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c6f90bef51087e1fe9c31219de2eb5db10632cdda59e4e403fbc6668bc5fe424(
    *,
    extensions: typing.Optional[typing.Sequence[typing.Union[_VMExtension_034783ba, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1fce519bf6849e2756dfb9553796c9a8a5e3bf287f1a97e05e20d38371d1ff51(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    dns_forwarding_ruleset_id: builtins.str,
    domain_name: builtins.str,
    target_dns_servers: typing.Sequence[typing.Union[_TargetDnsServer_14a5d2e0, typing.Dict[builtins.str, typing.Any]]],
    forwarding_rule_state: typing.Optional[builtins.str] = None,
    ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
    metadata: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    api_version: typing.Optional[builtins.str] = None,
    enable_migration_analysis: typing.Optional[builtins.bool] = None,
    enable_transformation: typing.Optional[builtins.bool] = None,
    enable_validation: typing.Optional[builtins.bool] = None,
    location: typing.Optional[builtins.str] = None,
    monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3cc0fa0354b7e47bb56377d70bd882598239b08db450a33860b57a7b6b645433(
    props: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bfdf449f0fc3131a540cc61727ca5bad460bf2811910df8c8b87dfbd867fc7d7(
    props: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9953dfb08b2641fd5fd501c2e94a6a97134cdcc81fccc466878167faa6b02efa(
    *,
    properties: typing.Union[_ForwardingRuleProperties_244c500c, typing.Dict[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__968984f429d75a718f20e84d37a3d719d928c6cb4d2805f000db4d12447193c9(
    *,
    domain_name: builtins.str,
    target_dns_servers: typing.Sequence[typing.Union[_TargetDnsServer_14a5d2e0, typing.Dict[builtins.str, typing.Any]]],
    forwarding_rule_state: typing.Optional[builtins.str] = None,
    metadata: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__218affeb3062092cb208cc7ddbba6245a5567bbe2538168b70702b8afc390463(
    *,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    api_version: typing.Optional[builtins.str] = None,
    enable_migration_analysis: typing.Optional[builtins.bool] = None,
    enable_transformation: typing.Optional[builtins.bool] = None,
    enable_validation: typing.Optional[builtins.bool] = None,
    location: typing.Optional[builtins.str] = None,
    monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    dns_forwarding_ruleset_id: builtins.str,
    domain_name: builtins.str,
    target_dns_servers: typing.Sequence[typing.Union[_TargetDnsServer_14a5d2e0, typing.Dict[builtins.str, typing.Any]]],
    forwarding_rule_state: typing.Optional[builtins.str] = None,
    ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
    metadata: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b57b28498b9ca3bdb3c659218c40effe5ce7f0f460416e863a8a9059c18a1b01(
    *,
    id: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f4a8f5a203702a85aaf08f022db1be834fae6ef4e0d0ad501ec4af11d7801c08(
    *,
    id: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b2bb61df160c5b503673ff36f45ba57832f4d44bcbb2cf9ddd1d7c749a4ab09b(
    *,
    id: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__29e25e92fadf378f0d69ad0e8105c70dcc60e22faddc3f850957d813f26048b9(
    *,
    resource_id: builtins.str,
    resource_type: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c9ff9e44b292c2a0bcb84efb870f9059a6295981c4f7315f66b26458d3c3794b(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    address_prefixes: typing.Sequence[builtins.str],
    network_manager_id: builtins.str,
    description: typing.Optional[builtins.str] = None,
    display_name: typing.Optional[builtins.str] = None,
    ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
    parent_pool_name: typing.Optional[builtins.str] = None,
    api_version: typing.Optional[builtins.str] = None,
    enable_migration_analysis: typing.Optional[builtins.bool] = None,
    enable_transformation: typing.Optional[builtins.bool] = None,
    enable_validation: typing.Optional[builtins.bool] = None,
    location: typing.Optional[builtins.str] = None,
    monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__803568da2df208fc8b94a8706db225c4e7bc39f9463881e0ff29d7b1cd306ce6(
    props: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4d478d2f961c34ab37a4dbf7a585954365bb7a0fc9cf86611747355957f033e4(
    props: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e3afcf0fef4c03dc600b357d809ccbf5eecad8bb6f1aae3b45f54f4497350428(
    *,
    location: builtins.str,
    properties: typing.Union[_IpamPoolProperties_2b6465ac, typing.Dict[builtins.str, typing.Any]],
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__639153e92ba53b278cc75e424e32ced0bb46aadd2097c2c1f1b5ea69ef9076ef(
    *,
    address_prefixes: typing.Sequence[builtins.str],
    description: typing.Optional[builtins.str] = None,
    display_name: typing.Optional[builtins.str] = None,
    parent_pool_name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__28ddcaa274b7ea77249135a293d76cb8001eb985f7b31ea75e84c7f3e7c5b95c(
    *,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    api_version: typing.Optional[builtins.str] = None,
    enable_migration_analysis: typing.Optional[builtins.bool] = None,
    enable_transformation: typing.Optional[builtins.bool] = None,
    enable_validation: typing.Optional[builtins.bool] = None,
    location: typing.Optional[builtins.str] = None,
    monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    address_prefixes: typing.Sequence[builtins.str],
    network_manager_id: builtins.str,
    description: typing.Optional[builtins.str] = None,
    display_name: typing.Optional[builtins.str] = None,
    ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
    parent_pool_name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9bab4767fcd01d506366995b14fafdf805ead5acb7f2e568af9c5399310b19db(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    address_prefixes: typing.Sequence[builtins.str],
    ipam_pool_id: builtins.str,
    description: typing.Optional[builtins.str] = None,
    ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
    api_version: typing.Optional[builtins.str] = None,
    enable_migration_analysis: typing.Optional[builtins.bool] = None,
    enable_transformation: typing.Optional[builtins.bool] = None,
    enable_validation: typing.Optional[builtins.bool] = None,
    location: typing.Optional[builtins.str] = None,
    monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__87e9ae62fe9291aa907de223dbd2bc749dd3a433d23b064970de8e23824b091c(
    props: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4c05bf7a720831203723b922cfbd29fecf3e6baa05cf6f0f4f1f7107652cfcc8(
    props: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__54efe4527c56a7805702ecb1579e4cf495ca796ef437d4c744bc0feade4fdaf1(
    *,
    properties: typing.Union[_IpamPoolStaticCidrProperties_794c371f, typing.Dict[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9a1afe665cd05cc80be183218566ef30141e797e7be85ea267fb49db1da365f3(
    *,
    address_prefixes: typing.Sequence[builtins.str],
    description: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2875835d0cec8aa2ab6445aaa5455c1d6877789bd85b35f04261345a036121cf(
    *,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    api_version: typing.Optional[builtins.str] = None,
    enable_migration_analysis: typing.Optional[builtins.bool] = None,
    enable_transformation: typing.Optional[builtins.bool] = None,
    enable_validation: typing.Optional[builtins.bool] = None,
    location: typing.Optional[builtins.str] = None,
    monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    address_prefixes: typing.Sequence[builtins.str],
    ipam_pool_id: builtins.str,
    description: typing.Optional[builtins.str] = None,
    ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__25a6f130c465a86bd30bd551cd74a3c538afc1314acc2c7b3c8491261bd8d8bf(
    *,
    dh_group: builtins.str,
    ike_encryption: builtins.str,
    ike_integrity: builtins.str,
    ipsec_encryption: builtins.str,
    ipsec_integrity: builtins.str,
    pfs_group: builtins.str,
    sa_data_size_kilobytes: jsii.Number,
    sa_life_time_seconds: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cb69355060b3fd1d4c8b9b4af26633550be917d50a4589f76912cb7a6f5a56d9(
    *,
    callback_url: builtins.str,
    name: builtins.str,
    resource_id: builtins.str,
    use_common_alert_schema: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e1f36654b877ca5dcfe242e3b797b90d182f6fb1dd68d213e3adbba075df654c(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    criteria: typing.Union[typing.Union[_StaticThresholdCriteria_e446085b, typing.Dict[builtins.str, typing.Any]], typing.Union[_DynamicThresholdCriteria_a75d1b26, typing.Dict[builtins.str, typing.Any]]],
    scopes: typing.Sequence[builtins.str],
    severity: jsii.Number,
    actions: typing.Optional[typing.Sequence[typing.Union[_MetricAlertAction_2c2527f4, typing.Dict[builtins.str, typing.Any]]]] = None,
    auto_mitigate: typing.Optional[builtins.bool] = None,
    description: typing.Optional[builtins.str] = None,
    enabled: typing.Optional[builtins.bool] = None,
    evaluation_frequency: typing.Optional[builtins.str] = None,
    resource_group_id: typing.Optional[builtins.str] = None,
    target_resource_region: typing.Optional[builtins.str] = None,
    target_resource_type: typing.Optional[builtins.str] = None,
    window_size: typing.Optional[builtins.str] = None,
    api_version: typing.Optional[builtins.str] = None,
    enable_migration_analysis: typing.Optional[builtins.bool] = None,
    enable_transformation: typing.Optional[builtins.bool] = None,
    enable_validation: typing.Optional[builtins.bool] = None,
    location: typing.Optional[builtins.str] = None,
    monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6ae5d59e661be750b3bc3b0a2531ff2dc2a81ebaf7ed6bb3dd7ed155fd1e3a60(
    key: builtins.str,
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f12aeebf97e5d729cbfc80b96445383e3a7b07bdd19ab43e2c352aae0ee9b055(
    props: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dab885a09e266a5d33461ae9e5d4f0f63e616fe37185a3fdd1b284b4416350a5(
    key: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2d4a18d552893dfcc3c7437fb5f01775ef561ffe108fc245bc1cba58d068ac67(
    *,
    action_group_id: builtins.str,
    web_hook_properties: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9b051cf9c1014315e4a4c0a7276e9c0cc45e28efe6f80bf3b75e727b8978587f(
    *,
    location: builtins.str,
    properties: typing.Union[_MetricAlertBodyProperties_8cfa84e9, typing.Dict[builtins.str, typing.Any]],
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__24b289e0a7554b03b9a72850656c8cd44172bd07569ec7cf1007c97c5562ff80(
    *,
    auto_mitigate: builtins.bool,
    criteria: typing.Any,
    enabled: builtins.bool,
    evaluation_frequency: builtins.str,
    scopes: typing.Sequence[builtins.str],
    severity: jsii.Number,
    window_size: builtins.str,
    actions: typing.Optional[typing.Sequence[typing.Union[_MetricAlertAction_2c2527f4, typing.Dict[builtins.str, typing.Any]]]] = None,
    description: typing.Optional[builtins.str] = None,
    target_resource_region: typing.Optional[builtins.str] = None,
    target_resource_type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a1a00e4a06cd3cf887a51deb7a7a474af9bbb39b9c06925de83bd1a888701465(
    *,
    min_failing_periods_to_alert: jsii.Number,
    number_of_evaluation_periods: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__620e753236b590df8ff25fe95c84a81b8c12d963bd6efc4628e360c2dc42648b(
    *,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    api_version: typing.Optional[builtins.str] = None,
    enable_migration_analysis: typing.Optional[builtins.bool] = None,
    enable_transformation: typing.Optional[builtins.bool] = None,
    enable_validation: typing.Optional[builtins.bool] = None,
    location: typing.Optional[builtins.str] = None,
    monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    criteria: typing.Union[typing.Union[_StaticThresholdCriteria_e446085b, typing.Dict[builtins.str, typing.Any]], typing.Union[_DynamicThresholdCriteria_a75d1b26, typing.Dict[builtins.str, typing.Any]]],
    scopes: typing.Sequence[builtins.str],
    severity: jsii.Number,
    actions: typing.Optional[typing.Sequence[typing.Union[_MetricAlertAction_2c2527f4, typing.Dict[builtins.str, typing.Any]]]] = None,
    auto_mitigate: typing.Optional[builtins.bool] = None,
    description: typing.Optional[builtins.str] = None,
    enabled: typing.Optional[builtins.bool] = None,
    evaluation_frequency: typing.Optional[builtins.str] = None,
    resource_group_id: typing.Optional[builtins.str] = None,
    target_resource_region: typing.Optional[builtins.str] = None,
    target_resource_type: typing.Optional[builtins.str] = None,
    window_size: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fc2ba8b8be11d71526f7ede737d04c11aec98571db06d7a10e26445e3cb14cce(
    *,
    name: builtins.str,
    operator: builtins.str,
    values: typing.Sequence[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6f99329161317c6ea230489d13d3b312b6a9a38e9284fb0793d516aea95891c7(
    *,
    automatic_upgrade_possible: builtins.bool,
    breaking_changes: typing.Sequence[typing.Union[_BreakingChange_5dc94c31, typing.Dict[builtins.str, typing.Any]]],
    compatible: builtins.bool,
    estimated_effort: builtins.str,
    from_version: builtins.str,
    to_version: builtins.str,
    warnings: typing.Sequence[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__979125830a88d993d06bf79feb8aff88c075ba55b44bd7a5f15d635319dd55ea(
    *,
    action_groups: typing.Optional[typing.Sequence[typing.Union[_ActionGroupProps_572d2b68, typing.Dict[builtins.str, typing.Any]]]] = None,
    activity_log_alerts: typing.Optional[typing.Sequence[typing.Union[_ActivityLogAlertProps_f1779054, typing.Dict[builtins.str, typing.Any]]]] = None,
    diagnostic_settings: typing.Optional[typing.Union[_DiagnosticSettingsProps_cc0fa615, typing.Dict[builtins.str, typing.Any]]] = None,
    enabled: typing.Optional[builtins.bool] = None,
    metric_alerts: typing.Optional[typing.Sequence[typing.Union[_MetricAlertProps_a18d777f, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__69f704d3ae38a0287bfb1fe9e4f5d2dfc42c97750aa6df5cc1005951520c041d(
    *,
    id: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4256e7d6c58d1c573c451d8cf8cbc8446da4a4db7db4d38160829217fd991a35(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    network_manager_id: builtins.str,
    description: typing.Optional[builtins.str] = None,
    ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
    member_type: typing.Optional[builtins.str] = None,
    api_version: typing.Optional[builtins.str] = None,
    enable_migration_analysis: typing.Optional[builtins.bool] = None,
    enable_transformation: typing.Optional[builtins.bool] = None,
    enable_validation: typing.Optional[builtins.bool] = None,
    location: typing.Optional[builtins.str] = None,
    monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__67f389cd02edc28ede599ab958ee2f79cfdd5ab21e18e2bc34e6d00a727e05d2(
    props: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__44e8f461b4bc88dc5b57a00f404f4615ea7e185838f84a390e3bd754d16ad745(
    props: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e712f43b52b1ddf2d7095dc5db75e0327cd47cb8a2e23ebef6325a770f153df6(
    *,
    properties: typing.Optional[typing.Union[_NetworkGroupProperties_c6b41db0, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c7efd4afff5c4edef2897dd94ecda1d64f847e9ba6a2c6412fa9d6376a76e6f1(
    *,
    description: typing.Optional[builtins.str] = None,
    member_type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__526d250ad02b55550baba64a45601b0c5e709cb0e11deaae763ede5a94e31830(
    *,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    api_version: typing.Optional[builtins.str] = None,
    enable_migration_analysis: typing.Optional[builtins.bool] = None,
    enable_transformation: typing.Optional[builtins.bool] = None,
    enable_validation: typing.Optional[builtins.bool] = None,
    location: typing.Optional[builtins.str] = None,
    monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    network_manager_id: builtins.str,
    description: typing.Optional[builtins.str] = None,
    ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
    member_type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b62375c8cde6d82adab9c55922a655da1cd477202491b11ebf65026966be4843(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    network_group_id: builtins.str,
    resource_id: builtins.str,
    ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
    api_version: typing.Optional[builtins.str] = None,
    enable_migration_analysis: typing.Optional[builtins.bool] = None,
    enable_transformation: typing.Optional[builtins.bool] = None,
    enable_validation: typing.Optional[builtins.bool] = None,
    location: typing.Optional[builtins.str] = None,
    monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ef4de65205598d10b4e9d7f16ce03a6cce62a22b5c2ce24d3bafbe53c0d2f82f(
    props: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cb73bbb60834a00bae2b89bc371d37e30afb4e2aa640588d04b11ba5d8afb5ea(
    props: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__55042b6ef1f36b0e230f73b0c8c8ec01e6dc9d770c59618366378a2f69de25eb(
    *,
    properties: typing.Union[_NetworkGroupStaticMemberProperties_808adefa, typing.Dict[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b21a9d08d280f30c44ff695d7955532e4a8d013bc0039bc140c93c973a2049f4(
    *,
    resource_id: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a373fac0ede7102051c7c429906e301dba46f20a8fecbd216227e34f0e5f0d62(
    *,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    api_version: typing.Optional[builtins.str] = None,
    enable_migration_analysis: typing.Optional[builtins.bool] = None,
    enable_transformation: typing.Optional[builtins.bool] = None,
    enable_validation: typing.Optional[builtins.bool] = None,
    location: typing.Optional[builtins.str] = None,
    monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    network_group_id: builtins.str,
    resource_id: builtins.str,
    ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__09f24e8a4ed5b6010c73fb48fcc49e41185a1ecb27ed676869d691bcfcec13ad(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    ip_configurations: typing.Sequence[typing.Union[_NetworkInterfaceIPConfiguration_c63cf7d5, typing.Dict[builtins.str, typing.Any]]],
    dns_settings: typing.Optional[typing.Union[_NetworkInterfaceDnsSettings_c9406208, typing.Dict[builtins.str, typing.Any]]] = None,
    enable_accelerated_networking: typing.Optional[builtins.bool] = None,
    enable_ip_forwarding: typing.Optional[builtins.bool] = None,
    ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
    network_security_group: typing.Optional[typing.Union[_NetworkInterfaceNSGReference_c2c81f03, typing.Dict[builtins.str, typing.Any]]] = None,
    resource_group_id: typing.Optional[builtins.str] = None,
    api_version: typing.Optional[builtins.str] = None,
    enable_migration_analysis: typing.Optional[builtins.bool] = None,
    enable_transformation: typing.Optional[builtins.bool] = None,
    enable_validation: typing.Optional[builtins.bool] = None,
    location: typing.Optional[builtins.str] = None,
    monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b26b2d91d3520b70301b4b4baab675412e5fe7285b5b811f2ce822198e421f5e(
    key: builtins.str,
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2c38515d7524ce5755d99ed7c591365c4bedb90d935aa2502122914ad4782a0a(
    props: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b1fcf4f51860b105e4a2f71012d9425b32dd7cbd92bb500cdffc147a6af53679(
    key: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8bb617678ee71da5d07f9204eaf936fb282c8ab86c93718c47b0ff1628ef32f7(
    *,
    location: builtins.str,
    properties: typing.Union[_NetworkInterfaceBodyProperties_1ebf3a2a, typing.Dict[builtins.str, typing.Any]],
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__610ddd82dbb41ce589c52ab6f951a37d2af801871eb269d5f42a1ff6d4ab3402(
    *,
    ip_configurations: typing.Sequence[typing.Union[_NetworkInterfaceIPConfiguration_c63cf7d5, typing.Dict[builtins.str, typing.Any]]],
    dns_settings: typing.Optional[typing.Union[_NetworkInterfaceDnsSettings_c9406208, typing.Dict[builtins.str, typing.Any]]] = None,
    enable_accelerated_networking: typing.Optional[builtins.bool] = None,
    enable_ip_forwarding: typing.Optional[builtins.bool] = None,
    network_security_group: typing.Optional[typing.Union[_NetworkInterfaceNSGReference_c2c81f03, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6c36ad636e3e52b9c7243e3a3554c193aa4652f3b91b6b817bfc31a67c2e2e99(
    *,
    name: builtins.str,
    properties: typing.Optional[typing.Union[_NetworkInterfaceConfigurationProperties_5b8d6a5d, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0256863ae08652983c60bcb0528ac53283c86a24bf5f59250d73eb4a7ed0854c(
    *,
    ip_configurations: typing.Sequence[_IPConfiguration_3c957377],
    dns_settings: typing.Optional[typing.Union[_NetworkInterfaceDnsSettings_c9406208, typing.Dict[builtins.str, typing.Any]]] = None,
    enable_accelerated_networking: typing.Optional[builtins.bool] = None,
    enable_ip_forwarding: typing.Optional[builtins.bool] = None,
    network_security_group: typing.Optional[typing.Union[_NetworkSecurityGroupReference_681673f0, typing.Dict[builtins.str, typing.Any]]] = None,
    primary: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__00cabfc566701b2f86ad59bd566748822838cf5e1aac533e5b09b41f4cab0222(
    *,
    dns_servers: typing.Optional[typing.Sequence[builtins.str]] = None,
    internal_dns_name_label: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d9d86acd268dc09376d88ff5a680644364416ccb56777745cc74728036ec77ed(
    *,
    name: builtins.str,
    subnet: typing.Union[_NetworkInterfaceSubnetReference_12eff6ea, typing.Dict[builtins.str, typing.Any]],
    primary: typing.Optional[builtins.bool] = None,
    private_ip_address: typing.Optional[builtins.str] = None,
    private_ip_allocation_method: typing.Optional[builtins.str] = None,
    public_ip_address: typing.Optional[typing.Union[_NetworkInterfacePublicIPReference_3c09f670, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__77f05f145e7dc125e229e469e7f83892dff066ac5f3fe233c710bf5a132fadb8(
    *,
    id: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3cbf85f4b7cf1de4c36f7e71a6506713428abb4553ba775e90d85a820b88ec8f(
    *,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    api_version: typing.Optional[builtins.str] = None,
    enable_migration_analysis: typing.Optional[builtins.bool] = None,
    enable_transformation: typing.Optional[builtins.bool] = None,
    enable_validation: typing.Optional[builtins.bool] = None,
    location: typing.Optional[builtins.str] = None,
    monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ip_configurations: typing.Sequence[typing.Union[_NetworkInterfaceIPConfiguration_c63cf7d5, typing.Dict[builtins.str, typing.Any]]],
    dns_settings: typing.Optional[typing.Union[_NetworkInterfaceDnsSettings_c9406208, typing.Dict[builtins.str, typing.Any]]] = None,
    enable_accelerated_networking: typing.Optional[builtins.bool] = None,
    enable_ip_forwarding: typing.Optional[builtins.bool] = None,
    ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
    network_security_group: typing.Optional[typing.Union[_NetworkInterfaceNSGReference_c2c81f03, typing.Dict[builtins.str, typing.Any]]] = None,
    resource_group_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5e0d6db7759e56b82f512e467124d6d9962bd66cc7d048367db044d5bbaabffc(
    *,
    id: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__45d004bcf1c8c57368b99769bdb78d785b6b9c1e3b134a074dc6e768a471aa7f(
    *,
    id: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0beb176443403aee32dd756890c36035fedd23e33f5d949be1d9f0284cb2aa1b(
    *,
    management_groups: typing.Optional[typing.Sequence[builtins.str]] = None,
    subscriptions: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__506933c2da7febf7b8856e205c8fcaf391678f60849c57da6b57d9f919cb5ec6(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    flush_connection: typing.Optional[builtins.bool] = None,
    ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
    resource_group_id: typing.Optional[builtins.str] = None,
    security_rules: typing.Optional[typing.Sequence[typing.Union[_SecurityRule_e3229718, typing.Dict[builtins.str, typing.Any]]]] = None,
    api_version: typing.Optional[builtins.str] = None,
    enable_migration_analysis: typing.Optional[builtins.bool] = None,
    enable_transformation: typing.Optional[builtins.bool] = None,
    enable_validation: typing.Optional[builtins.bool] = None,
    location: typing.Optional[builtins.str] = None,
    monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c45843a987f1cf901f2aef607d07d4f1056765c1d75bb28b46382f40de9ee42a(
    key: builtins.str,
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__882f27e6ef60d9417d0e0d39afbdd409ee589dc25cdd46d9b9807ecfab942a1b(
    props: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__06a9fe506be3033921dce6a338d855445aceac25815451484ec9747c7dc3cc0f(
    key: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__19d2e80f419bb6cfa512812679637ec83446320cc205994d33c24b74eb249259(
    *,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    api_version: typing.Optional[builtins.str] = None,
    enable_migration_analysis: typing.Optional[builtins.bool] = None,
    enable_transformation: typing.Optional[builtins.bool] = None,
    enable_validation: typing.Optional[builtins.bool] = None,
    location: typing.Optional[builtins.str] = None,
    monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    flush_connection: typing.Optional[builtins.bool] = None,
    ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
    resource_group_id: typing.Optional[builtins.str] = None,
    security_rules: typing.Optional[typing.Sequence[typing.Union[_SecurityRule_e3229718, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1a555cce2948e017ec61958da229e0a0dc1d4797bc134c93f5080d3392629d67(
    *,
    id: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3fd4532e9f020cb8ce5937cff38aed8544a3a7f7653708edd323e5e844d9c270(
    *,
    age_hours: jsii.Number,
    cleanup_after: datetime.datetime,
    created_at: datetime.datetime,
    location: builtins.str,
    name: builtins.str,
    resource_group: builtins.str,
    resource_id: builtins.str,
    resource_type: builtins.str,
    test_name: builtins.str,
    test_run_id: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7ece58b6ac4575ffe65caa0fcf3a34c5383f2a2fa0f13c98ce22aac8ea4d0058(
    *,
    cidr: builtins.str,
    first_ip: builtins.str,
    last_ip: builtins.str,
    netmask: builtins.str,
    network: builtins.str,
    prefix: jsii.Number,
    total_addresses: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9d29b5d22b446692fa2724fe1522567141dd9618138ab3814d1937144bb4ba5d(
    *,
    id: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d2c42c23bcbc9ee5023539b60474c1d15ea36bf325210ba5634a79227c065800(
    scope_: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    policy_definition_id: builtins.str,
    scope: builtins.str,
    description: typing.Optional[builtins.str] = None,
    display_name: typing.Optional[builtins.str] = None,
    enforcement_mode: typing.Optional[builtins.str] = None,
    identity: typing.Optional[typing.Union[_PolicyAssignmentIdentity_49ed2b2a, typing.Dict[builtins.str, typing.Any]]] = None,
    ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
    metadata: typing.Any = None,
    non_compliance_messages: typing.Optional[typing.Sequence[typing.Union[_PolicyAssignmentNonComplianceMessage_4bb37598, typing.Dict[builtins.str, typing.Any]]]] = None,
    not_scopes: typing.Optional[typing.Sequence[builtins.str]] = None,
    parameters: typing.Any = None,
    api_version: typing.Optional[builtins.str] = None,
    enable_migration_analysis: typing.Optional[builtins.bool] = None,
    enable_transformation: typing.Optional[builtins.bool] = None,
    enable_validation: typing.Optional[builtins.bool] = None,
    location: typing.Optional[builtins.str] = None,
    monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__12b64aaa6ce46755e3169e4949f798c3d165650d2fdc7f7108d783faab58fc5b(
    props: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d6282aa498497d261887eefab3bd960e4bca659f980dd28230cad0d2c7da0fd2(
    props: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fdba77223193d2e1d9223e95ce59ef33c0d47ee6c5a29b10f0bb56828243fbe4(
    *,
    properties: typing.Union[_PolicyAssignmentProperties_59266900, typing.Dict[builtins.str, typing.Any]],
    identity: typing.Optional[typing.Union[_PolicyAssignmentIdentity_49ed2b2a, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__109d90a74a83d552b8a5257ff586414ce5ec55656cc4a7d8509dc95f8e93f690(
    *,
    type: builtins.str,
    user_assigned_identities: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a9c104f18f37c530023b58be39530c64feccffd8b1b2a7413c3ccb44d60752a8(
    *,
    message: builtins.str,
    policy_definition_reference_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dabda0ef97df86973c1dfadd3274e121ffd5b01f2e09d9af829becfc8b50c1e8(
    *,
    policy_definition_id: builtins.str,
    scope: builtins.str,
    description: typing.Optional[builtins.str] = None,
    display_name: typing.Optional[builtins.str] = None,
    enforcement_mode: typing.Optional[builtins.str] = None,
    metadata: typing.Any = None,
    non_compliance_messages: typing.Optional[typing.Sequence[typing.Union[_PolicyAssignmentNonComplianceMessage_4bb37598, typing.Dict[builtins.str, typing.Any]]]] = None,
    not_scopes: typing.Optional[typing.Sequence[builtins.str]] = None,
    parameters: typing.Any = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dd988acdedd9a8cf0053f138bc442108d5cdf6766d1585768dd76f59e385fa5b(
    *,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    api_version: typing.Optional[builtins.str] = None,
    enable_migration_analysis: typing.Optional[builtins.bool] = None,
    enable_transformation: typing.Optional[builtins.bool] = None,
    enable_validation: typing.Optional[builtins.bool] = None,
    location: typing.Optional[builtins.str] = None,
    monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    policy_definition_id: builtins.str,
    scope: builtins.str,
    description: typing.Optional[builtins.str] = None,
    display_name: typing.Optional[builtins.str] = None,
    enforcement_mode: typing.Optional[builtins.str] = None,
    identity: typing.Optional[typing.Union[_PolicyAssignmentIdentity_49ed2b2a, typing.Dict[builtins.str, typing.Any]]] = None,
    ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
    metadata: typing.Any = None,
    non_compliance_messages: typing.Optional[typing.Sequence[typing.Union[_PolicyAssignmentNonComplianceMessage_4bb37598, typing.Dict[builtins.str, typing.Any]]]] = None,
    not_scopes: typing.Optional[typing.Sequence[builtins.str]] = None,
    parameters: typing.Any = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__32ade476b8cbca4e3521fe6be3b2d3e62398ec6cb44fb5185a02406784ac0da0(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    policy_rule: typing.Any,
    description: typing.Optional[builtins.str] = None,
    display_name: typing.Optional[builtins.str] = None,
    ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
    metadata: typing.Any = None,
    mode: typing.Optional[builtins.str] = None,
    parameters: typing.Any = None,
    parent_id: typing.Optional[builtins.str] = None,
    policy_type: typing.Optional[builtins.str] = None,
    api_version: typing.Optional[builtins.str] = None,
    enable_migration_analysis: typing.Optional[builtins.bool] = None,
    enable_transformation: typing.Optional[builtins.bool] = None,
    enable_validation: typing.Optional[builtins.bool] = None,
    location: typing.Optional[builtins.str] = None,
    monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__28fc303be9b2468d75f6bc0aca70dddeab372c0b98ce951df82d5c8a14e08ad3(
    props: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a36d716d00273ea6a6af571a1c37fbb7d796ec85b026ce6ee72b0cd90e97bca0(
    config: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__578b265b90b8718a4c38a1538fd2c5c20601d7325814a578d432b92c44ab93aa(
    props: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cb92598a4c3a4da2786ee5794feea197a9e519cd7b198cd953c0dbef404e1fe1(
    *,
    properties: typing.Union[_PolicyDefinitionProperties_ff703616, typing.Dict[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6a8e37f6f9f9ffe4d95bca34f655f1baa69008b7ea89e26aee955ab54c582b62(
    *,
    policy_rule: typing.Any,
    description: typing.Optional[builtins.str] = None,
    display_name: typing.Optional[builtins.str] = None,
    metadata: typing.Any = None,
    mode: typing.Optional[builtins.str] = None,
    parameters: typing.Any = None,
    policy_type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c41e2bcae5dca3227727f47f99543edcf6e042d4b4512da008f7559fed1d3eb0(
    *,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    api_version: typing.Optional[builtins.str] = None,
    enable_migration_analysis: typing.Optional[builtins.bool] = None,
    enable_transformation: typing.Optional[builtins.bool] = None,
    enable_validation: typing.Optional[builtins.bool] = None,
    location: typing.Optional[builtins.str] = None,
    monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    policy_rule: typing.Any,
    description: typing.Optional[builtins.str] = None,
    display_name: typing.Optional[builtins.str] = None,
    ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
    metadata: typing.Any = None,
    mode: typing.Optional[builtins.str] = None,
    parameters: typing.Any = None,
    parent_id: typing.Optional[builtins.str] = None,
    policy_type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4013cecceffa70445b14fca8b752d2c9e8bb35c494e18c319538c87d152d14c7(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
    resource_group_id: typing.Optional[builtins.str] = None,
    api_version: typing.Optional[builtins.str] = None,
    enable_migration_analysis: typing.Optional[builtins.bool] = None,
    enable_transformation: typing.Optional[builtins.bool] = None,
    enable_validation: typing.Optional[builtins.bool] = None,
    location: typing.Optional[builtins.str] = None,
    monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9a728271ad9b694e0d4b8fbb9c51912380fb962a640239a39bae0ae09a8841e2(
    key: builtins.str,
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0080d271dc9afbec1bb324c2846d504d192e35a1343b5085e1734d72d27dbb85(
    _props: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b167befb596349c9185e561940fb1281e5a0078f1303e2fb09a3c2dada18a38d(
    key: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f5a9467ea61b11537f191c80338e19a8e1f4977cf24b8483e2b7efd098ac1228(
    *,
    location: builtins.str,
    properties: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e7aa756fabc10aa58ef6c698b5771137128eebce78265cdc5f69aa3df6d95a7e(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    private_dns_zone_id: builtins.str,
    virtual_network_id: builtins.str,
    ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
    registration_enabled: typing.Optional[builtins.bool] = None,
    resolution_policy: typing.Optional[builtins.str] = None,
    api_version: typing.Optional[builtins.str] = None,
    enable_migration_analysis: typing.Optional[builtins.bool] = None,
    enable_transformation: typing.Optional[builtins.bool] = None,
    enable_validation: typing.Optional[builtins.bool] = None,
    location: typing.Optional[builtins.str] = None,
    monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4e5e51efdf3fbac039f07b212e78c8da76b14e015113625649b8a380dfea20e6(
    key: builtins.str,
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__938e3b1fe4fd201d4656757b4eb5bffd0cd81d19903c10bc155060f05801bd16(
    props: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2e2ed6576e2c99737a1c83d4591c959829cb9be95e10f11d9c85bf339d5e6579(
    key: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__13099f2d8ec8969e3ce0bb5ae9ea9c77bda03bd4b145e03a2b47aacbcaf29c22(
    props: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9e1e4fb69313e6a29250b410cfe9cdc2e9734ce777de0970c1f0b9aa951bcf50(
    *,
    location: builtins.str,
    properties: typing.Union[PrivateDnsZoneLinkProperties, typing.Dict[builtins.str, typing.Any]],
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b40c534580ec6eb1a7635d235939cc577bef47f66037fb95c665189cd6ee66f5(
    *,
    virtual_network: typing.Union[PrivateDnsZoneLinkVirtualNetworkReference, typing.Dict[builtins.str, typing.Any]],
    registration_enabled: typing.Optional[builtins.bool] = None,
    resolution_policy: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9a565bde41e348de491415272aa1d9cfabc2b63d5e329dc223ca41fd63da6c84(
    *,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    api_version: typing.Optional[builtins.str] = None,
    enable_migration_analysis: typing.Optional[builtins.bool] = None,
    enable_transformation: typing.Optional[builtins.bool] = None,
    enable_validation: typing.Optional[builtins.bool] = None,
    location: typing.Optional[builtins.str] = None,
    monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    private_dns_zone_id: builtins.str,
    virtual_network_id: builtins.str,
    ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
    registration_enabled: typing.Optional[builtins.bool] = None,
    resolution_policy: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9ddad4abd6fa4bbc9c8ab2e7d03c0952b534694bb8173edfccbee9c97a731e1d(
    *,
    id: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b0d5f6e0513082e6b82c7a2b3bd783ebd7bf620f2d08d092b8eb4642e51f9755(
    *,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    api_version: typing.Optional[builtins.str] = None,
    enable_migration_analysis: typing.Optional[builtins.bool] = None,
    enable_transformation: typing.Optional[builtins.bool] = None,
    enable_validation: typing.Optional[builtins.bool] = None,
    location: typing.Optional[builtins.str] = None,
    monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
    resource_group_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__873687013997a56dc83a159d5ec3b08ecea6e26cf9d0e9412bfe53c038a3f8ee(
    *,
    data_type: builtins.str,
    added_in_version: typing.Optional[builtins.str] = None,
    default_value: typing.Any = None,
    deprecated: typing.Optional[builtins.bool] = None,
    description: typing.Optional[builtins.str] = None,
    removed_in_version: typing.Optional[builtins.str] = None,
    required: typing.Optional[builtins.bool] = None,
    validation: typing.Optional[typing.Sequence[typing.Union[_ValidationRule_f1913ed6, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e646261d26230a31efdf6cc86475e2770b333f18140390e5aec8538d4780530b(
    *,
    source_property: builtins.str,
    target_property: builtins.str,
    default_value: typing.Any = None,
    required: typing.Optional[builtins.bool] = None,
    transformer: typing.Optional[typing.Union[_PropertyTransformer_9b876b7f, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9eb55571415bfbdd70d0e9d0a78c13122ab931b54ab8c79380c0fe0044d09e27(
    *,
    transformation_type: builtins.str,
    config: typing.Any = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__84adfcff60680f878147cacc881873aa8c2fe2987cde811b86790842bf32bba9(
    *,
    property: builtins.str,
    rules: typing.Sequence[typing.Union[_ValidationRule_f1913ed6, typing.Dict[builtins.str, typing.Any]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__074f8c88a5dc47fb3db6e7bdbf3b8606decb68e6e59cad237d0ddf973adfc7ce(
    *,
    id: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c03ad4acff40fc4658670045a9322dc7f2219aa34386282169bd844ec7c8e1bd(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    dns_settings: typing.Optional[typing.Union[_PublicIPAddressDnsSettings_d3ef5a04, typing.Dict[builtins.str, typing.Any]]] = None,
    idle_timeout_in_minutes: typing.Optional[jsii.Number] = None,
    ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
    public_ip_address_version: typing.Optional[builtins.str] = None,
    public_ip_allocation_method: typing.Optional[builtins.str] = None,
    resource_group_id: typing.Optional[builtins.str] = None,
    sku: typing.Optional[typing.Union[_PublicIPAddressSku_00870b2b, typing.Dict[builtins.str, typing.Any]]] = None,
    zones: typing.Optional[typing.Sequence[builtins.str]] = None,
    api_version: typing.Optional[builtins.str] = None,
    enable_migration_analysis: typing.Optional[builtins.bool] = None,
    enable_transformation: typing.Optional[builtins.bool] = None,
    enable_validation: typing.Optional[builtins.bool] = None,
    location: typing.Optional[builtins.str] = None,
    monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__67b1d3e66ec14784f55898a76b4b08fe917e2fa06b244fe1163442d5632357c8(
    key: builtins.str,
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__83211c70c033f81b39b5eae00a0fee94b7b6463ebf64387dcaf0c0382afbb7bc(
    props: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e10aac97b72a9b63ee509be163fbecb06d028fe26f6512e7d52ad432de773af1(
    key: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__97686cace8cf5d2d38bcd4b13bb66bb58b3c1ef11ad59a4b96adc5c7fa8919ef(
    *,
    name: builtins.str,
    properties: typing.Optional[typing.Union[_PublicIPAddressConfigurationProperties_2d1f2680, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f19f2b46ee6e8628db0b94aa1c2164aac316a89d5f9d667e462cc198a48c1ff9(
    *,
    dns_settings: typing.Optional[typing.Union[_PublicIPDnsSettings_cb1a7a4f, typing.Dict[builtins.str, typing.Any]]] = None,
    idle_timeout_in_minutes: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9de4fbe9ea6e8713b5260f467c334f43141e9c159bad946f63b00c461165e2e6(
    *,
    domain_name_label: typing.Optional[builtins.str] = None,
    fqdn: typing.Optional[builtins.str] = None,
    reverse_fqdn: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d2fbbe2222753076e7e89f45db902e0ef226bccf28d39dc640b4460d09f9a369(
    *,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    api_version: typing.Optional[builtins.str] = None,
    enable_migration_analysis: typing.Optional[builtins.bool] = None,
    enable_transformation: typing.Optional[builtins.bool] = None,
    enable_validation: typing.Optional[builtins.bool] = None,
    location: typing.Optional[builtins.str] = None,
    monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    dns_settings: typing.Optional[typing.Union[_PublicIPAddressDnsSettings_d3ef5a04, typing.Dict[builtins.str, typing.Any]]] = None,
    idle_timeout_in_minutes: typing.Optional[jsii.Number] = None,
    ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
    public_ip_address_version: typing.Optional[builtins.str] = None,
    public_ip_allocation_method: typing.Optional[builtins.str] = None,
    resource_group_id: typing.Optional[builtins.str] = None,
    sku: typing.Optional[typing.Union[_PublicIPAddressSku_00870b2b, typing.Dict[builtins.str, typing.Any]]] = None,
    zones: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5547f3c5345d103f57b7971fc8305a522920acdaf12309e272a3f667c2fc978d(
    *,
    name: builtins.str,
    tier: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__145c9c955d12d6a133f90260230ef0309c9fb578c896d0c37f0d156d19c4d2a4(
    *,
    domain_name_label: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__360cf756a18f01faf6eea402730f531aef83cf5f1f419da649a2e9b5928d74ad(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    type: builtins.str,
    body: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    create_headers: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    create_query_parameters: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.Sequence[builtins.str]]]] = None,
    delete_headers: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    delete_query_parameters: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.Sequence[builtins.str]]]] = None,
    identity: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ResourceIdentity, typing.Dict[builtins.str, typing.Any]]]]] = None,
    ignore_casing: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    ignore_missing_property: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    ignore_null_property: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    location: typing.Optional[builtins.str] = None,
    locks: typing.Optional[typing.Sequence[builtins.str]] = None,
    name: typing.Optional[builtins.str] = None,
    parent_id: typing.Optional[builtins.str] = None,
    read_headers: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    read_query_parameters: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.Sequence[builtins.str]]]] = None,
    replace_triggers_external_values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    replace_triggers_refs: typing.Optional[typing.Sequence[builtins.str]] = None,
    response_export_values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    retry: typing.Optional[typing.Union[ResourceRetry, typing.Dict[builtins.str, typing.Any]]] = None,
    schema_validation_enabled: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    sensitive_body: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    sensitive_body_version: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    timeouts: typing.Optional[typing.Union[ResourceTimeouts, typing.Dict[builtins.str, typing.Any]]] = None,
    update_headers: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    update_query_parameters: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.Sequence[builtins.str]]]] = None,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__edff1d2f5265b2950973771424e150a68c06c9041437e44ee8be96cb9b192995(
    scope: _constructs_77d1e7e8.Construct,
    import_to_id: builtins.str,
    import_from_id: builtins.str,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6f150919e21a56a085faf5046991755e5048d66d84d4b475e7fe138f81dbc7be(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ResourceIdentity, typing.Dict[builtins.str, typing.Any]]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__98edd861ded07fa7bbcb64cbb23535c57c7912b9ea044420e57e4ab49aa2f676(
    value: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e5bc5a1a4b0c645ec8f5b08757f4da96be098885bb6fcc8a04471cf13ccd1974(
    value: typing.Mapping[builtins.str, builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1b0cb7f0c1c1b9b4eafd1bb02195514e3a9b02c438cdf43b145ba46350d14af9(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.List[builtins.str]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0b854cd284c7651abfa4dca18251d596d0ac808fa1daeb955602022f1d36881f(
    value: typing.Mapping[builtins.str, builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__af650baa6c89b699d2aaeb9dae047a1ab73f14735ea5566040864cc31b9a10de(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.List[builtins.str]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7c330a3da38779fdfde9ce7876aee87039a107dd1abf1ad4a70965d7f6ac24c6(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__45eb6abb157ab6d63e1946c17ac812308f7b4d3d395a192022c6b5672892d0c7(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4f29ee916ad478f0f1c3d6eec138b84bc516b8bbf1688f25c659ac0a959395ec(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__40de70c0c8f1eff71f3465ca96a211867eda879e736c0cdd0dd8721bf2d5eae8(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__41946711b488d86ee4066511bd326ba8fae0292a07da47b826ea818e435cc601(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9e8c2a738ac0a7e986617e7c476e73a630939a10ea67d5631700063935a529e3(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4702438dc870ea43d45f3b2e9b7d7e15df9b998e7e4eb78bd0ab2f3165f95998(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__38d805fbcbb389aafed2b0a7e878ea19eaa04ace49cc995fbe48daad165cf782(
    value: typing.Mapping[builtins.str, builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f8604726bdf155a156d6c5024a7ec71e5a60cd842b7b9edf9ef6891e8bde8be5(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.List[builtins.str]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3d60c8fdfa7bcf46fee2e9e31f278fe66ee35ff6a452d2cd492b936672bf08df(
    value: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c3ba278ec6bc25bc8f200ac1f3aad8f7e7278ebb9ed40968b75dc5924cc2f86a(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b141e7bfa993c4527bb95583fb32e65e1c81ec037a0f4c87ba003e74231a0335(
    value: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3988d4dcdc80fe58d6bfe5b0833246562b217d8f9103298f3c08cf563ac4e6ab(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a823ed51d1ce9ba6c69a4c8b3a7c22a9c794ed9aaf9df9b3d97fb6b3ea0a36d5(
    value: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__837e68941d7639aceeb0dcd7db90ae3688b8ce5c6711934421026b3538e55f54(
    value: typing.Mapping[builtins.str, builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a6889b4d7b37bf070255471d414ce1869f19c41af6a3132e05b7ae71ae022133(
    value: typing.Mapping[builtins.str, builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__22aad63a3939465809abf1ce8416c25ba8fe259012c462900fcccb00d1b613fa(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ca3eb787ce2c0134489014db653c496820e374931e9387e965898d0a3d74292f(
    value: typing.Mapping[builtins.str, builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__665b7816c8fb83eb81099827eba36497d576d48a89b25694c45b88f3faff00ea(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.List[builtins.str]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__da027795a53c827c06f63ae41ff835cffcd5a4ec2fddea4d23dd77566dcdced2(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    resource_id: builtins.str,
    type: builtins.str,
    action: typing.Optional[builtins.str] = None,
    body: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    headers: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    locks: typing.Optional[typing.Sequence[builtins.str]] = None,
    method: typing.Optional[builtins.str] = None,
    query_parameters: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.Sequence[builtins.str]]]] = None,
    response_export_values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    retry: typing.Optional[typing.Union[ResourceActionRetry, typing.Dict[builtins.str, typing.Any]]] = None,
    sensitive_response_export_values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    timeouts: typing.Optional[typing.Union[ResourceActionTimeouts, typing.Dict[builtins.str, typing.Any]]] = None,
    when: typing.Optional[builtins.str] = None,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__29bc96a955f54b134c6e853a1b24de207626f1c35467a147d769bf69d5687b6c(
    scope: _constructs_77d1e7e8.Construct,
    import_to_id: builtins.str,
    import_from_id: builtins.str,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e6cf10e33b1f20cd2e69e1c8e976bd035ef6b55b4ce733d91ee6d726e849ecd3(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__29829d45a45a8dab2ef641af59ea0c16d8cba8b01a5760d0aba179f21f37b581(
    value: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9c649c2389d6150c86086659a272921793bdac1d01a17818729a718634d5f78c(
    value: typing.Mapping[builtins.str, builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ecface4d64f727299378773d22d6aad179566c3b318ab8fb886bf08c1109be0a(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a004d1d6767d31a29dfc6842432afb2b2c56123d78ad2d4dffe7443d09510de1(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__75003ceeeba04467530caba827b8e3acf689d4f714b06fced16ecc43b42f4dba(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.List[builtins.str]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__618428c81e64ca9dc3b28ddbd0a2caa3b488ba4899431c70afde207e779a49ae(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__357b0007148e00bdf7bd48788e9dd50264c0b7decb944dd954983ed045d16fe0(
    value: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0319798eb06f4e230b99dd90a3a0392620aff4947336e180d07cd99eb67ef2a5(
    value: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__595b452dc41ac6e1e18f9f594cf05df16be57566288f18e8c538b35de247eff3(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7e4e242bce02e6a930efa9bfc9ebdf4c1dda6e62bbae50d41d9dd940c2dfdac7(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f8e2bb85c6fbed66627658d3e8222936052424f03b9388708ba0e28309d48ca7(
    *,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    resource_id: builtins.str,
    type: builtins.str,
    action: typing.Optional[builtins.str] = None,
    body: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    headers: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    locks: typing.Optional[typing.Sequence[builtins.str]] = None,
    method: typing.Optional[builtins.str] = None,
    query_parameters: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.Sequence[builtins.str]]]] = None,
    response_export_values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    retry: typing.Optional[typing.Union[ResourceActionRetry, typing.Dict[builtins.str, typing.Any]]] = None,
    sensitive_response_export_values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    timeouts: typing.Optional[typing.Union[ResourceActionTimeouts, typing.Dict[builtins.str, typing.Any]]] = None,
    when: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__28e46efabfe16eb872f9211500b5dd2f673943819499d88429251542fb87d608(
    *,
    error_message_regex: typing.Sequence[builtins.str],
    interval_seconds: typing.Optional[jsii.Number] = None,
    max_interval_seconds: typing.Optional[jsii.Number] = None,
    multiplier: typing.Optional[jsii.Number] = None,
    randomization_factor: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__00c2b505e65ddc5b0eab80b8e3925e063da0ba2a162cf555ff1da5fa728f859b(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__baae077936ab43a7958119c062b9fad9e223deb4cc1a0c05b8edbdeae1418a7c(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9f364015da412ddbcdf7e825f3063adc0b3de3bf9363d68e147722bc2411f8aa(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d40beb561bc4af16cab276bed7ab791d6d3478f692640f472415e88be5ea03dd(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e2262c316736506a51d44f860c32ba79aa990b17c43b3c3479e47992738912a4(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bd6be8daf53287e67ad06aa69e56938d7f91719ed089167a362e1cbe5d2391c2(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__026803ddbdf7b5454fdd2d1dac7f26b97cdd33f24166845a5f1bbb406c6ca40e(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ResourceActionRetry]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3ee5eacfd46440ebfb5470174494f3da3d2ea98c95731344f7e0794305cdb15e(
    *,
    create: typing.Optional[builtins.str] = None,
    delete: typing.Optional[builtins.str] = None,
    read: typing.Optional[builtins.str] = None,
    update: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f0d0cb9794de2331a0700fc234c67c1c997de1bccf68794aff848a45872aab72(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a656c1a2a49619464df067705a34ecc7311594a109ac428f21d5180142e5262e(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__06a44b9c7e024ce8ba9a65de2a1d2e3b83c16e2175cf074a964fe2ea8df03783(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__31257aab74109d3af4698313da9c73e0d185636e06e2c9bee106bf22de94e89f(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__35e531b763c8e10f3decbaf7a5738cf248e9ea7b21a2bc3001de3b1fe735d065(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__eb8f61d9dfa427401bb0a23cb0dc1488c437e857a759fbe4368ce74f670b549d(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ResourceActionTimeouts]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dd1b7579dcc308ca524a96cd6ee4b87bde571b1c101a9599fc573123069a9fd3(
    tags: typing.Mapping[builtins.str, builtins.str],
    subscription: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0dba8b11025af1cd1bb936835c3223213bf9904b11157b2cd5518ae03dd90289(
    *,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    type: builtins.str,
    body: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    create_headers: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    create_query_parameters: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.Sequence[builtins.str]]]] = None,
    delete_headers: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    delete_query_parameters: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.Sequence[builtins.str]]]] = None,
    identity: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Sequence[typing.Union[ResourceIdentity, typing.Dict[builtins.str, typing.Any]]]]] = None,
    ignore_casing: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    ignore_missing_property: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    ignore_null_property: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    location: typing.Optional[builtins.str] = None,
    locks: typing.Optional[typing.Sequence[builtins.str]] = None,
    name: typing.Optional[builtins.str] = None,
    parent_id: typing.Optional[builtins.str] = None,
    read_headers: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    read_query_parameters: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.Sequence[builtins.str]]]] = None,
    replace_triggers_external_values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    replace_triggers_refs: typing.Optional[typing.Sequence[builtins.str]] = None,
    response_export_values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    retry: typing.Optional[typing.Union[ResourceRetry, typing.Dict[builtins.str, typing.Any]]] = None,
    schema_validation_enabled: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    sensitive_body: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    sensitive_body_version: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    timeouts: typing.Optional[typing.Union[ResourceTimeouts, typing.Dict[builtins.str, typing.Any]]] = None,
    update_headers: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    update_query_parameters: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.Sequence[builtins.str]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__29b0473f748c77e8cf5a499a8a1cb9dbd38d71e9f891bc8febb8ed132057b1ce(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
    managed_by: typing.Optional[builtins.str] = None,
    api_version: typing.Optional[builtins.str] = None,
    enable_migration_analysis: typing.Optional[builtins.bool] = None,
    enable_transformation: typing.Optional[builtins.bool] = None,
    enable_validation: typing.Optional[builtins.bool] = None,
    location: typing.Optional[builtins.str] = None,
    monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3fc32ce7cf0743f4d9783f3fb0755941fbe96b318c5653c79f3bc1f3f8af25ec(
    props: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__86cf1ed103d6b382f226e0453cfef8a9f3700fa2fc06e6a37620e72c2f207aed(
    _props: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1323ac136a1170344d1118d9c54f81085344d6968ef0d2d115e69fc0fa8254d0(
    *,
    location: builtins.str,
    managed_by: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__00f9d149205e57c257371a1ebedf9fed7fb1e90db72bae0538c3d2fec74c45be(
    *,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    api_version: typing.Optional[builtins.str] = None,
    enable_migration_analysis: typing.Optional[builtins.bool] = None,
    enable_transformation: typing.Optional[builtins.bool] = None,
    enable_validation: typing.Optional[builtins.bool] = None,
    location: typing.Optional[builtins.str] = None,
    monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
    managed_by: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__52c12ff10ae1f91ea81406a63ac44465db1733866e3b4e573c96fbd491e8396a(
    *,
    type: builtins.str,
    identity_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ad8d5bcf536a2bf97e7c786ae80ebde8ed0263faaa0da60aafb6a9c34bbfbd28(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    wraps_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e2853f8e17a0492754c88e8f76e6da89db331a4e7d3b433ba9398c406c8945d5(
    index: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7d91140734b86f4427853447aab47a37a2eb5d7e0f178adec228df8c4e915a5d(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__41f84f167da33ddaf69687ffe06bbe94c7ea1b052b6d03296eb6452ee6349386(
    value: _cdktf_9a9027ec.IInterpolatingParent,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1eb795e3b089bdae4f19ca0c05ca50f165c61d0240fbcc4f7eabf33bcca4e631(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e52ebd7e8bcbdea5dc89cc5b9b0867832aa098d2fa4dffe77bf6bbd0a9e7cb42(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.List[ResourceIdentity]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f19617e93a12cd6b0421753d1b24a2c4b49d02f4b495c1e5e300d0d8792480db(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
    complex_object_index: jsii.Number,
    complex_object_is_from_set: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8ac80f65161d5f9550a7fd12ec9c6e719abfd6ba606e52b7eb5ff5b7dcc057da(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6426f4c03ae3bdae7cab4d741f9740345086ca56b44437ac0a6798b395a95f5d(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a86e85302b9b79b20851effe0af9250a8f5a2e902618a3df8ae46e57f8d38a18(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ResourceIdentity]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8dc0552c1058af02495c191fda190e66ff4124a4219458020996a232874af644(
    *,
    created_at: datetime.datetime,
    name: builtins.str,
    resource_id: builtins.str,
    resource_type: builtins.str,
    tags: typing.Mapping[builtins.str, builtins.str],
    test_run_id: builtins.str,
    destroyed: typing.Optional[builtins.bool] = None,
    destroyed_at: typing.Optional[datetime.datetime] = None,
    location: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__70371c572990fdd62753e30fddf8cbdb1e488a2f9f26d52b0d3e2b5ad28656d2(
    *,
    id: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__024e91c8b12ce75919dbcc4b5e0b1db9094d70c07451c163b0e308801852c9c3(
    *,
    error_message_regex: typing.Sequence[builtins.str],
    interval_seconds: typing.Optional[jsii.Number] = None,
    max_interval_seconds: typing.Optional[jsii.Number] = None,
    multiplier: typing.Optional[jsii.Number] = None,
    randomization_factor: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6bb64d0a72a186c4863d2a4a71b30ac970083c75f978e112917a733263aebb1c(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__25b8230f793ecd56b881e62949fd842e67d99df864648976c2e13bed7a938654(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7ed0e0aa54dc53eabceb33268d39eafa992b77b554a143f773ffea7445730a1f(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7acfe1be0d5b1089b93b5281bbe4ddfa35b311b3dd4e77b9c22294f4bfacd6c8(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7f98bbdc89b58f2d423b303e43458dfb5fe88d3fe28fc532cf16cb892d747907(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0282de5cab879cf45313e14134319b2259b2e50de1343cdf51a84c04e2e9677d(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e3c2a4029bce73af4eecab3710e0bbcab30af3631ca57e4d7221bc1c2931134f(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ResourceRetry]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d5eda75602061bb145f3d35070438044c4bbb7ca7feb7df8adf7b438026f3d9b(
    *,
    create: typing.Optional[builtins.str] = None,
    delete: typing.Optional[builtins.str] = None,
    read: typing.Optional[builtins.str] = None,
    update: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e9dd0b4cb6319942940e117e4eb08f8fe2c13aa394c52a85206e8600f9dace0b(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fd8df8efdf1749681e653a7efce9f5db55b5e525f066e2754f6c287f9ae3d92c(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5ad77ecbaeba8f59286342f048f3683cfdbd1115ab10ee2a355bc41584fa0b03(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d1275a9ef5ffb9ab2fcb7563a67feee38f587d99ba4cae8e65b7493c9d4786d1(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5281d50a62ebece318860e00e21dbae13c791abdb339dc50b4c46bac442c7019(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5fb549b00fd4a8c6de83658597b657b96b3d7c272740e27a65c20ccc7187d868(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, ResourceTimeouts]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7638bfc6d836a3bc87e0b0222bc338bd510d5d7a354220a29559904376c0a1a1(
    *,
    days: jsii.Number,
    enabled: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__de7c84fb5d7023a0c1d8714ddb2555fb8c828f0d555ec53d0a106f5ff424a00e(
    scope_: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    principal_id: builtins.str,
    role_definition_id: builtins.str,
    scope: builtins.str,
    condition: typing.Optional[builtins.str] = None,
    condition_version: typing.Optional[builtins.str] = None,
    delegated_managed_identity_resource_id: typing.Optional[builtins.str] = None,
    description: typing.Optional[builtins.str] = None,
    ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
    principal_type: typing.Optional[builtins.str] = None,
    api_version: typing.Optional[builtins.str] = None,
    enable_migration_analysis: typing.Optional[builtins.bool] = None,
    enable_transformation: typing.Optional[builtins.bool] = None,
    enable_validation: typing.Optional[builtins.bool] = None,
    location: typing.Optional[builtins.str] = None,
    monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__892baaabfaeac525108fd2ea2509bdf800e2d6a80330a9394be8833254550fb4(
    props: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c74758db67483e4c40c59626b2fff87a0a49d58a9b10971e3c15c9cbf273f45c(
    props: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2331091adabf612d55e87abaac20314dd1de60c7643c51f5d8f8a9694cd4a099(
    *,
    properties: typing.Union[_RoleAssignmentProperties_d993b254, typing.Dict[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5d31fbcf67760bd526f6587e38b01ec2f20f6f498a5c461f9491eed7eb508312(
    *,
    principal_id: builtins.str,
    role_definition_id: builtins.str,
    scope: builtins.str,
    condition: typing.Optional[builtins.str] = None,
    condition_version: typing.Optional[builtins.str] = None,
    delegated_managed_identity_resource_id: typing.Optional[builtins.str] = None,
    description: typing.Optional[builtins.str] = None,
    principal_type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__03bec8e53dcf8b41eb1af764c332139e5b12d09c43a8ba1da148faae07c6aa81(
    *,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    api_version: typing.Optional[builtins.str] = None,
    enable_migration_analysis: typing.Optional[builtins.bool] = None,
    enable_transformation: typing.Optional[builtins.bool] = None,
    enable_validation: typing.Optional[builtins.bool] = None,
    location: typing.Optional[builtins.str] = None,
    monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    principal_id: builtins.str,
    role_definition_id: builtins.str,
    scope: builtins.str,
    condition: typing.Optional[builtins.str] = None,
    condition_version: typing.Optional[builtins.str] = None,
    delegated_managed_identity_resource_id: typing.Optional[builtins.str] = None,
    description: typing.Optional[builtins.str] = None,
    ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
    principal_type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7969d4ecafedd4e6f4e222892616c115671138615d280f6ed3ea5c9644e8634d(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    assignable_scopes: typing.Sequence[builtins.str],
    permissions: typing.Sequence[typing.Union[_RoleDefinitionPermission_5623a628, typing.Dict[builtins.str, typing.Any]]],
    role_name: builtins.str,
    description: typing.Optional[builtins.str] = None,
    ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
    type: typing.Optional[builtins.str] = None,
    api_version: typing.Optional[builtins.str] = None,
    enable_migration_analysis: typing.Optional[builtins.bool] = None,
    enable_transformation: typing.Optional[builtins.bool] = None,
    enable_validation: typing.Optional[builtins.bool] = None,
    location: typing.Optional[builtins.str] = None,
    monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__822850a3d6fa75a5a482c4d91310ac609d9577ab55b90b3c5cdff61cebc5e01c(
    props: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d4d45dba934decb4422008139afaab5935b2006a344616638e5ea0cd237cf870(
    *,
    properties: typing.Union[_RoleDefinitionProperties_f78101b5, typing.Dict[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__67f9f50e66dc6c020f5644a83d37fb90365639676ed04c2747b68fd64abfb510(
    *,
    actions: typing.Optional[typing.Sequence[builtins.str]] = None,
    data_actions: typing.Optional[typing.Sequence[builtins.str]] = None,
    not_actions: typing.Optional[typing.Sequence[builtins.str]] = None,
    not_data_actions: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__45ceef2ceaeb8b1820103fcc378e380971cb312363bcbbfd6990cbefb71dd973(
    *,
    assignable_scopes: typing.Sequence[builtins.str],
    permissions: typing.Sequence[typing.Union[_RoleDefinitionPermission_5623a628, typing.Dict[builtins.str, typing.Any]]],
    role_name: builtins.str,
    description: typing.Optional[builtins.str] = None,
    type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__425e6ab1f308fd7935b72c47c3fdb8eea9f21615aaa59c995487510e0cbfa9e9(
    *,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    api_version: typing.Optional[builtins.str] = None,
    enable_migration_analysis: typing.Optional[builtins.bool] = None,
    enable_transformation: typing.Optional[builtins.bool] = None,
    enable_validation: typing.Optional[builtins.bool] = None,
    location: typing.Optional[builtins.str] = None,
    monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    assignable_scopes: typing.Sequence[builtins.str],
    permissions: typing.Sequence[typing.Union[_RoleDefinitionPermission_5623a628, typing.Dict[builtins.str, typing.Any]]],
    role_name: builtins.str,
    description: typing.Optional[builtins.str] = None,
    ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
    type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__df6b20ff165ab2880d6ca51efd072153f9051d7b651f87eb2ba62ef357f72df3(
    *,
    enable_cross_zone_upgrade: typing.Optional[builtins.bool] = None,
    max_batch_instance_percent: typing.Optional[jsii.Number] = None,
    max_unhealthy_instance_percent: typing.Optional[jsii.Number] = None,
    max_unhealthy_upgraded_instance_percent: typing.Optional[jsii.Number] = None,
    pause_time_between_batches: typing.Optional[builtins.str] = None,
    prioritize_unhealthy_instances: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__eb815f1ddbef62464da1d3f01d48c73e3ce3256bad192161d078e91f6c80260f(
    *,
    terminate_notification_profile: typing.Optional[typing.Union[_TerminateNotificationProfile_f8017676, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9bc74f355d7d1fbc5878fd5086f6a928f240de6ff73782a583c218a10d828715(
    properties: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__43d584f170c18d0a1f9ce4ebea063952f341a4fd5428b535de04954db03508bc(
    property_name: builtins.str,
    value: typing.Any,
    *,
    data_type: builtins.str,
    added_in_version: typing.Optional[builtins.str] = None,
    default_value: typing.Any = None,
    deprecated: typing.Optional[builtins.bool] = None,
    description: typing.Optional[builtins.str] = None,
    removed_in_version: typing.Optional[builtins.str] = None,
    required: typing.Optional[builtins.bool] = None,
    validation: typing.Optional[typing.Sequence[typing.Union[_ValidationRule_f1913ed6, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ed7a2ae22d9d62578b80294cb5e2742132463bddece8df681e869f07c4734680(
    source_props: typing.Any,
    *,
    properties: typing.Mapping[builtins.str, typing.Union[_PropertyDefinition_2a5c46ac, typing.Dict[builtins.str, typing.Any]]],
    required: typing.Sequence[builtins.str],
    resource_type: builtins.str,
    version: builtins.str,
    deprecated: typing.Optional[typing.Sequence[builtins.str]] = None,
    optional: typing.Optional[typing.Sequence[builtins.str]] = None,
    transformation_rules: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    validation_rules: typing.Optional[typing.Sequence[typing.Union[_PropertyValidation_bb241cd7, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bfa13727f782f0851343415e4c43c40889fbd50653114d5f10bee312362db43d(
    properties: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__de61fe958c4b0171491310738ade5f0227a9c661d15266c7f0028d4aaebbdfd4(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    network_manager_id: builtins.str,
    apply_on_network_intent_policy_based_services: typing.Optional[typing.Sequence[builtins.str]] = None,
    description: typing.Optional[builtins.str] = None,
    ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
    api_version: typing.Optional[builtins.str] = None,
    enable_migration_analysis: typing.Optional[builtins.bool] = None,
    enable_transformation: typing.Optional[builtins.bool] = None,
    enable_validation: typing.Optional[builtins.bool] = None,
    location: typing.Optional[builtins.str] = None,
    monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e27270e9fcf85d1d2dd06cb6d667f38782533c8bd36c5f4a0fa7dd3e3ac52575(
    props: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1032027af6f7301310e227b215de01ad8ab106f1b689ba05173b978499244026(
    props: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__97a69def9965f85ff89a91e78a3caedb33b082787554e90c7cfb50646fba6301(
    *,
    properties: typing.Optional[typing.Union[_SecurityAdminConfigurationProperties_fd4a713c, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8e875f0959e7256829407724a2ba59f009a7e9f58526170ac921e82e788ea648(
    *,
    apply_on_network_intent_policy_based_services: typing.Optional[typing.Sequence[builtins.str]] = None,
    description: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6568fd3da447c201ff0306e003022c09bb59c49c4fcaf9a9b77341e32c82fc30(
    *,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    api_version: typing.Optional[builtins.str] = None,
    enable_migration_analysis: typing.Optional[builtins.bool] = None,
    enable_transformation: typing.Optional[builtins.bool] = None,
    enable_validation: typing.Optional[builtins.bool] = None,
    location: typing.Optional[builtins.str] = None,
    monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    network_manager_id: builtins.str,
    apply_on_network_intent_policy_based_services: typing.Optional[typing.Sequence[builtins.str]] = None,
    description: typing.Optional[builtins.str] = None,
    ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d3a8b1facce470a2ebaf2b76b878968a076431c8b77317aafc77f751fe1e3ced(
    *,
    network_group_id: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5a5095cc1460831c453af44e07d7a1abad954a0de1963edc46658783e34a677d(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    action: builtins.str,
    direction: builtins.str,
    priority: jsii.Number,
    protocol: builtins.str,
    rule_collection_id: builtins.str,
    description: typing.Optional[builtins.str] = None,
    destination_port_ranges: typing.Optional[typing.Sequence[builtins.str]] = None,
    destinations: typing.Optional[typing.Sequence[typing.Union[_AddressPrefixItem_ccd8b167, typing.Dict[builtins.str, typing.Any]]]] = None,
    ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
    source_port_ranges: typing.Optional[typing.Sequence[builtins.str]] = None,
    sources: typing.Optional[typing.Sequence[typing.Union[_AddressPrefixItem_ccd8b167, typing.Dict[builtins.str, typing.Any]]]] = None,
    api_version: typing.Optional[builtins.str] = None,
    enable_migration_analysis: typing.Optional[builtins.bool] = None,
    enable_transformation: typing.Optional[builtins.bool] = None,
    enable_validation: typing.Optional[builtins.bool] = None,
    location: typing.Optional[builtins.str] = None,
    monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4ec77f664aac5fb11ba29b818bbc137bbf2179762800afb578fa4ccb81e2162e(
    props: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9d2b07377060555b8f6ca4cac3e28b5a9afee515d9d7a12b4b04ed8b10dfb47e(
    props: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__254d3e38448eb991f949ad52f0ebff3416a2234864fd2a19577d8b41f0e78f05(
    *,
    kind: builtins.str,
    properties: typing.Union[_SecurityAdminRuleProperties_239a5478, typing.Dict[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1f4e16d7ea09625415c4be9adda694ea176dde4d202ca6e97c81301109656ca5(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    applies_to_groups: typing.Sequence[typing.Union[_SecurityAdminConfigurationRuleGroupItem_29d670e4, typing.Dict[builtins.str, typing.Any]]],
    security_admin_configuration_id: builtins.str,
    description: typing.Optional[builtins.str] = None,
    ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
    api_version: typing.Optional[builtins.str] = None,
    enable_migration_analysis: typing.Optional[builtins.bool] = None,
    enable_transformation: typing.Optional[builtins.bool] = None,
    enable_validation: typing.Optional[builtins.bool] = None,
    location: typing.Optional[builtins.str] = None,
    monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__41c0459860a5857517050caf3a7d806ab4ec84d0aa7e822a9a7fa85d240b3f22(
    props: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1c4fcd4db527474d25c37242924aba05682089bd694ee2b2950869ffef18d656(
    props: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__31433914b4ab9d7d00aecc2cdce2ac720a13951b3a9b0d72a1ce51f2cc7fe676(
    *,
    properties: typing.Union[_SecurityAdminRuleCollectionProperties_40adae7c, typing.Dict[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__64b2f7b55fcb3a37d072669265f49a99097781d561169a7a6ea8f61546024cba(
    *,
    applies_to_groups: typing.Sequence[typing.Union[_SecurityAdminConfigurationRuleGroupItem_29d670e4, typing.Dict[builtins.str, typing.Any]]],
    description: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1e8659f827657eb4a4053397a6d45ac8383eacd32b01abd27ef416df560ac923(
    *,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    api_version: typing.Optional[builtins.str] = None,
    enable_migration_analysis: typing.Optional[builtins.bool] = None,
    enable_transformation: typing.Optional[builtins.bool] = None,
    enable_validation: typing.Optional[builtins.bool] = None,
    location: typing.Optional[builtins.str] = None,
    monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    applies_to_groups: typing.Sequence[typing.Union[_SecurityAdminConfigurationRuleGroupItem_29d670e4, typing.Dict[builtins.str, typing.Any]]],
    security_admin_configuration_id: builtins.str,
    description: typing.Optional[builtins.str] = None,
    ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__41add7f24d9488e49e4dd4c555d06394c0b3a9a90b9236ee62f446e898d68d25(
    *,
    action: builtins.str,
    direction: builtins.str,
    priority: jsii.Number,
    protocol: builtins.str,
    description: typing.Optional[builtins.str] = None,
    destination_port_ranges: typing.Optional[typing.Sequence[builtins.str]] = None,
    destinations: typing.Optional[typing.Sequence[typing.Union[_AddressPrefixItem_ccd8b167, typing.Dict[builtins.str, typing.Any]]]] = None,
    source_port_ranges: typing.Optional[typing.Sequence[builtins.str]] = None,
    sources: typing.Optional[typing.Sequence[typing.Union[_AddressPrefixItem_ccd8b167, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7ce34db17a650321bfe258e1fdfb1187d08cf202f660ac7eb0b648defb0cce6e(
    *,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    api_version: typing.Optional[builtins.str] = None,
    enable_migration_analysis: typing.Optional[builtins.bool] = None,
    enable_transformation: typing.Optional[builtins.bool] = None,
    enable_validation: typing.Optional[builtins.bool] = None,
    location: typing.Optional[builtins.str] = None,
    monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    action: builtins.str,
    direction: builtins.str,
    priority: jsii.Number,
    protocol: builtins.str,
    rule_collection_id: builtins.str,
    description: typing.Optional[builtins.str] = None,
    destination_port_ranges: typing.Optional[typing.Sequence[builtins.str]] = None,
    destinations: typing.Optional[typing.Sequence[typing.Union[_AddressPrefixItem_ccd8b167, typing.Dict[builtins.str, typing.Any]]]] = None,
    ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
    source_port_ranges: typing.Optional[typing.Sequence[builtins.str]] = None,
    sources: typing.Optional[typing.Sequence[typing.Union[_AddressPrefixItem_ccd8b167, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6f8e843ecbf8c77df48f0c18b5485511e2fd4bbc551c07c170736ebd7fbff8c5(
    *,
    name: builtins.str,
    properties: typing.Union[_SecurityRuleProperties_74ae9ffc, typing.Dict[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9010680f24da9b75b135d487c22fb1a34d2186be8eb4ac50211c88d0baedacd9(
    *,
    access: builtins.str,
    direction: builtins.str,
    priority: jsii.Number,
    protocol: builtins.str,
    description: typing.Optional[builtins.str] = None,
    destination_address_prefix: typing.Optional[builtins.str] = None,
    destination_address_prefixes: typing.Optional[typing.Sequence[builtins.str]] = None,
    destination_application_security_groups: typing.Optional[typing.Sequence[typing.Any]] = None,
    destination_port_range: typing.Optional[builtins.str] = None,
    destination_port_ranges: typing.Optional[typing.Sequence[builtins.str]] = None,
    source_address_prefix: typing.Optional[builtins.str] = None,
    source_address_prefixes: typing.Optional[typing.Sequence[builtins.str]] = None,
    source_application_security_groups: typing.Optional[typing.Sequence[typing.Any]] = None,
    source_port_range: typing.Optional[builtins.str] = None,
    source_port_ranges: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3f72d3c5e298cfb8d90a585110b05576250f5363f70271a9523b6b778ef11bdd(
    *,
    country_code: builtins.str,
    name: builtins.str,
    phone_number: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__de75fdfc2f64711aa418cf1c1b2d776002bc24fc97d891d024f17835fd4c5109(
    *,
    metric_name: builtins.str,
    operator: builtins.str,
    threshold: jsii.Number,
    time_aggregation: builtins.str,
    type: builtins.str,
    dimensions: typing.Optional[typing.Sequence[typing.Union[_MetricDimension_8611b872, typing.Dict[builtins.str, typing.Any]]]] = None,
    metric_namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b723ffd4e5207ba4fcafe0e1ca19c61dbe7d2cfea410be368c89585a651db31c(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    sku: typing.Union[_StorageAccountSku_fa953b33, typing.Dict[builtins.str, typing.Any]],
    access_tier: typing.Optional[builtins.str] = None,
    allow_blob_public_access: typing.Optional[builtins.bool] = None,
    enable_https_traffic_only: typing.Optional[builtins.bool] = None,
    encryption: typing.Optional[typing.Union[_StorageAccountEncryption_77d27837, typing.Dict[builtins.str, typing.Any]]] = None,
    identity: typing.Optional[typing.Union[_StorageAccountIdentity_d6b6a344, typing.Dict[builtins.str, typing.Any]]] = None,
    ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
    kind: typing.Optional[builtins.str] = None,
    minimum_tls_version: typing.Optional[builtins.str] = None,
    network_acls: typing.Optional[typing.Union[_StorageAccountNetworkAcls_768fda36, typing.Dict[builtins.str, typing.Any]]] = None,
    resource_group_id: typing.Optional[builtins.str] = None,
    api_version: typing.Optional[builtins.str] = None,
    enable_migration_analysis: typing.Optional[builtins.bool] = None,
    enable_transformation: typing.Optional[builtins.bool] = None,
    enable_validation: typing.Optional[builtins.bool] = None,
    location: typing.Optional[builtins.str] = None,
    monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dfe98404a0c2a4f096cc78d7bea2dff324cd4fb672f7954e0a5fa71bd80dd182(
    action_group_id: builtins.str,
    workspace_id: typing.Optional[builtins.str] = None,
    *,
    availability_alert_severity: typing.Optional[jsii.Number] = None,
    availability_threshold: typing.Optional[jsii.Number] = None,
    egress_alert_severity: typing.Optional[jsii.Number] = None,
    egress_threshold: typing.Optional[jsii.Number] = None,
    enable_availability_alert: typing.Optional[builtins.bool] = None,
    enable_deletion_alert: typing.Optional[builtins.bool] = None,
    enable_egress_alert: typing.Optional[builtins.bool] = None,
    enable_transactions_alert: typing.Optional[builtins.bool] = None,
    transactions_alert_severity: typing.Optional[jsii.Number] = None,
    transactions_threshold: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6d4e890b88be1047ae9d17f768064bd1e8113534b01c70eadffeedde9929441b(
    key: builtins.str,
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ba54a1f3260d1a10e0e0845ba8ad70caf3468f8b4c2ef774f8198d9f228b1e11(
    props: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__900410703cbb9d837c440ac28e508c62fba57a49e5ebfcc50111c14f14238d7b(
    key: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b57d5b316754bbd430424592c26503e0ccd012f480d21900f4dad4d48b1398b2(
    *,
    kind: builtins.str,
    location: builtins.str,
    sku: typing.Union[_StorageAccountSku_fa953b33, typing.Dict[builtins.str, typing.Any]],
    identity: typing.Optional[typing.Union[_StorageAccountIdentity_d6b6a344, typing.Dict[builtins.str, typing.Any]]] = None,
    properties: typing.Optional[typing.Union[_StorageAccountBodyProperties_4d550b33, typing.Dict[builtins.str, typing.Any]]] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__40f569c3e3a12c7436014caf94387a09bff2f9c6f171ccb9d8f510fc2f60ec1b(
    *,
    access_tier: typing.Optional[builtins.str] = None,
    allow_blob_public_access: typing.Optional[builtins.bool] = None,
    encryption: typing.Optional[typing.Union[_StorageAccountEncryption_77d27837, typing.Dict[builtins.str, typing.Any]]] = None,
    minimum_tls_version: typing.Optional[builtins.str] = None,
    network_acls: typing.Optional[typing.Union[_StorageAccountNetworkAcls_768fda36, typing.Dict[builtins.str, typing.Any]]] = None,
    supports_https_traffic_only: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8ed14d2e557eb2340e8a610a56556e2f85a87f10993561aa732e622fda9d4dce(
    *,
    key_source: typing.Optional[builtins.str] = None,
    services: typing.Optional[typing.Union[_StorageAccountEncryptionServices_8a1bf271, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a6d0ec7498167d2e53cc6b520284093055f4a44fab1eb71da6132dfb50211bb6(
    *,
    enabled: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b7563a9805c7ad8fed6c30d58d9736388e5ad53e0f156ba7c14a77e9561b0a38(
    *,
    blob: typing.Optional[typing.Union[_StorageAccountEncryptionService_aaadb7be, typing.Dict[builtins.str, typing.Any]]] = None,
    file: typing.Optional[typing.Union[_StorageAccountEncryptionService_aaadb7be, typing.Dict[builtins.str, typing.Any]]] = None,
    queue: typing.Optional[typing.Union[_StorageAccountEncryptionService_aaadb7be, typing.Dict[builtins.str, typing.Any]]] = None,
    table: typing.Optional[typing.Union[_StorageAccountEncryptionService_aaadb7be, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__502fa19b120d6e7109eec152cd494ff2ee5ddbe633cca88345174662345345f4(
    *,
    type: builtins.str,
    user_assigned_identities: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4b79a21076dc9f14021e21bf25e1dc488ee8035373bd2369979335116b3cfabb(
    *,
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__af21ea8d212053d955f2593f7cfb6cd52f76c26564e2b215737b02cf6b5b4dfc(
    *,
    availability_alert_severity: typing.Optional[jsii.Number] = None,
    availability_threshold: typing.Optional[jsii.Number] = None,
    egress_alert_severity: typing.Optional[jsii.Number] = None,
    egress_threshold: typing.Optional[jsii.Number] = None,
    enable_availability_alert: typing.Optional[builtins.bool] = None,
    enable_deletion_alert: typing.Optional[builtins.bool] = None,
    enable_egress_alert: typing.Optional[builtins.bool] = None,
    enable_transactions_alert: typing.Optional[builtins.bool] = None,
    transactions_alert_severity: typing.Optional[jsii.Number] = None,
    transactions_threshold: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1f28dba6ea2cd128a19e73772f7563bbbde15eba3f292a0b0bf9b031557ae004(
    *,
    bypass: typing.Optional[builtins.str] = None,
    default_action: typing.Optional[builtins.str] = None,
    ip_rules: typing.Optional[typing.Sequence[typing.Union[_StorageAccountIpRule_83a6da4e, typing.Dict[builtins.str, typing.Any]]]] = None,
    virtual_network_rules: typing.Optional[typing.Sequence[typing.Union[_StorageAccountVirtualNetworkRule_825a3860, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__50747e225fb92dcb75801bf29a578ecfd07d5458a3f1b792b469a0235e8c5a49(
    *,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    api_version: typing.Optional[builtins.str] = None,
    enable_migration_analysis: typing.Optional[builtins.bool] = None,
    enable_transformation: typing.Optional[builtins.bool] = None,
    enable_validation: typing.Optional[builtins.bool] = None,
    location: typing.Optional[builtins.str] = None,
    monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    sku: typing.Union[_StorageAccountSku_fa953b33, typing.Dict[builtins.str, typing.Any]],
    access_tier: typing.Optional[builtins.str] = None,
    allow_blob_public_access: typing.Optional[builtins.bool] = None,
    enable_https_traffic_only: typing.Optional[builtins.bool] = None,
    encryption: typing.Optional[typing.Union[_StorageAccountEncryption_77d27837, typing.Dict[builtins.str, typing.Any]]] = None,
    identity: typing.Optional[typing.Union[_StorageAccountIdentity_d6b6a344, typing.Dict[builtins.str, typing.Any]]] = None,
    ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
    kind: typing.Optional[builtins.str] = None,
    minimum_tls_version: typing.Optional[builtins.str] = None,
    network_acls: typing.Optional[typing.Union[_StorageAccountNetworkAcls_768fda36, typing.Dict[builtins.str, typing.Any]]] = None,
    resource_group_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f170c62cdf8fb6a8a124b20e1b48a309ba2dc3cbbdf6ddc5798be9e101de4ba1(
    *,
    name: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3073662893bd85c109decc801fdb5b5d9ef7d2f526570fb1f6dcf9bc82edbd9a(
    *,
    id: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3b023144ff1b17084bab6dd3d98a222c67d354dd086b8c85dd65b4638ab29ab7(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    address_prefix: builtins.str,
    resource_group_id: builtins.str,
    virtual_network_name: builtins.str,
    delegations: typing.Optional[typing.Sequence[typing.Union[_SubnetDelegation_c6136dfd, typing.Dict[builtins.str, typing.Any]]]] = None,
    ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
    ip_allocations: typing.Optional[typing.Sequence[typing.Any]] = None,
    nat_gateway: typing.Optional[typing.Union[_SubnetNATGatewayReference_cf82a70c, typing.Dict[builtins.str, typing.Any]]] = None,
    network_security_group: typing.Optional[typing.Union[_SubnetNSGReference_02d94a8f, typing.Dict[builtins.str, typing.Any]]] = None,
    private_endpoint_network_policies: typing.Optional[builtins.str] = None,
    private_link_service_network_policies: typing.Optional[builtins.str] = None,
    route_table: typing.Optional[typing.Union[_SubnetRouteTableReference_5c30e955, typing.Dict[builtins.str, typing.Any]]] = None,
    service_endpoints: typing.Optional[typing.Sequence[typing.Union[_SubnetServiceEndpoint_ada81b5d, typing.Dict[builtins.str, typing.Any]]]] = None,
    virtual_network_id: typing.Optional[builtins.str] = None,
    api_version: typing.Optional[builtins.str] = None,
    enable_migration_analysis: typing.Optional[builtins.bool] = None,
    enable_transformation: typing.Optional[builtins.bool] = None,
    enable_validation: typing.Optional[builtins.bool] = None,
    location: typing.Optional[builtins.str] = None,
    monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5112d9b24205b916ceefb4b41cc5316eab3c8e358f96d0d46a6172ab10d3cff6(
    props: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e5972640e46e09acc53ddf0b0c905522d1f781f5b76444682c5e30295b3d37b7(
    props: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3760530bed36cfa1f705b6e798ab662d62d22a5194bc2a40c8587dba4bba9122(
    *,
    name: builtins.str,
    service_name: builtins.str,
    actions: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0abdc93f08f1ad260f5d16f954fc1ff5924049ca242cf8f1dc775d31ee461fbb(
    *,
    id: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7d8c36e05b330717745616b73eb1d7111c3b1b4005e15c9215c2fa2ba7da1b9c(
    *,
    id: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fb7eb17865b91080d67f982d72efdd403124f996da63284cbe00e79529a552ee(
    *,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    api_version: typing.Optional[builtins.str] = None,
    enable_migration_analysis: typing.Optional[builtins.bool] = None,
    enable_transformation: typing.Optional[builtins.bool] = None,
    enable_validation: typing.Optional[builtins.bool] = None,
    location: typing.Optional[builtins.str] = None,
    monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    address_prefix: builtins.str,
    resource_group_id: builtins.str,
    virtual_network_name: builtins.str,
    delegations: typing.Optional[typing.Sequence[typing.Union[_SubnetDelegation_c6136dfd, typing.Dict[builtins.str, typing.Any]]]] = None,
    ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
    ip_allocations: typing.Optional[typing.Sequence[typing.Any]] = None,
    nat_gateway: typing.Optional[typing.Union[_SubnetNATGatewayReference_cf82a70c, typing.Dict[builtins.str, typing.Any]]] = None,
    network_security_group: typing.Optional[typing.Union[_SubnetNSGReference_02d94a8f, typing.Dict[builtins.str, typing.Any]]] = None,
    private_endpoint_network_policies: typing.Optional[builtins.str] = None,
    private_link_service_network_policies: typing.Optional[builtins.str] = None,
    route_table: typing.Optional[typing.Union[_SubnetRouteTableReference_5c30e955, typing.Dict[builtins.str, typing.Any]]] = None,
    service_endpoints: typing.Optional[typing.Sequence[typing.Union[_SubnetServiceEndpoint_ada81b5d, typing.Dict[builtins.str, typing.Any]]]] = None,
    virtual_network_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__317803f224ae6350bc978cf483787d91b9bd6c2cc10f09d9f6219cb00b5d6e39(
    *,
    id: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6d23087bd71b7dfc6f6e16a1cb6352021382cae9e2a59822134183f1aded153f(
    *,
    service: builtins.str,
    locations: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__680757806b3f5351ed32f42bbfedb07ecf76650dc452a0bfa3271f6674a6fcc5(
    *,
    ip_address: builtins.str,
    port: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7963aec77ea6a0aa80222651c1ba8727cb0ba96c25efde2582b65a5197de0945(
    *,
    enable: typing.Optional[builtins.bool] = None,
    not_before_timeout: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a6c18b06c791d78911a393c9173c6d46c9a0e4a914a08076ceaba401c0fb92bf(
    test_name: builtins.str,
    *,
    auto_cleanup: typing.Optional[builtins.bool] = None,
    cleanup_policy: typing.Optional[builtins.str] = None,
    max_age_hours: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f14b21ffc6b4749e52e86ae8c68fe0f10f8dfc035fe5da79fc5360498ba01525(
    now: typing.Optional[datetime.datetime] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5d0e17f0c4411328210dedb3abad7c9f9a33f55a5cdb0c104a18addab8a90c00(
    *,
    auto_cleanup: typing.Optional[builtins.bool] = None,
    cleanup_policy: typing.Optional[builtins.str] = None,
    max_age_hours: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__281208bd5979459b2fb9c40473b7e56ff3827a001dfdab3f367e6d9fa584f1ad(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    type: builtins.str,
    body: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    ignore_casing: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    ignore_missing_property: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    locks: typing.Optional[typing.Sequence[builtins.str]] = None,
    name: typing.Optional[builtins.str] = None,
    parent_id: typing.Optional[builtins.str] = None,
    read_headers: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    read_query_parameters: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.Sequence[builtins.str]]]] = None,
    resource_id: typing.Optional[builtins.str] = None,
    response_export_values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    retry: typing.Optional[typing.Union[UpdateResourceRetry, typing.Dict[builtins.str, typing.Any]]] = None,
    sensitive_body: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    sensitive_body_version: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    timeouts: typing.Optional[typing.Union[UpdateResourceTimeouts, typing.Dict[builtins.str, typing.Any]]] = None,
    update_headers: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    update_query_parameters: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.Sequence[builtins.str]]]] = None,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fefd091115ceafa7b98d61be5296b58a51fb8f395595c3e55e9e8dbc42318865(
    scope: _constructs_77d1e7e8.Construct,
    import_to_id: builtins.str,
    import_from_id: builtins.str,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__24bd794bbb1c46f8402e96bc858c8b28a4df0590b2d7ec745bbffb768c3d3470(
    value: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4cb8639f9a6c82b24ae25e590163132a7c1792f25db19e5af27ec1b7260c0c2a(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c927810abfe7b4a93a2fbe970cda9edc52458cfc55d325dd0bef1eb10166d266(
    value: typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c66cc57c5c940069dfa83f81f2b057d8eeb97eb23f6e8f5e612a20d1ca2bfbe0(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e5509c8c583dfd37eb7060c7ea283c0d48a6db05c143e44b8d74f03a717ab06c(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0ee27014ec34d7df609c5d4d737f963f47a932978b48529be68eeaf583b3b30d(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2f5f4a4fbb1be9992450563aa07816a421096eead03aff37e8c856bd42467c48(
    value: typing.Mapping[builtins.str, builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8382baf5d98d087a6f342e3de120650f84a781f601d9d3e0c0a8e9436658ccb1(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.List[builtins.str]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__724528297e435ecd5d272c296a481cf0035199c8fa6e59f6e8d50de64b1be84d(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bc2704da0c80b3eff015e9306a550af5fb677bdca419c256e384ef41c206f576(
    value: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4a601f943176f52cfd86bece65a02257c652ca356e0a5d03633156ccf00c8ca1(
    value: typing.Mapping[builtins.str, typing.Any],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d1e5a9bd6f57eefda1dc9ffe8f8e3220c35d087ac5d6fc3a2a7fd0fb1e01b432(
    value: typing.Mapping[builtins.str, builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6faff092d7698d576ca2125b85d264d346e87923aa86938a05cc59b365f562bc(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1df2ecf47fdda34769a609afd2ff064f7dba437a340acaa5c572ac5ee66ae164(
    value: typing.Mapping[builtins.str, builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__997323a4824c206e270959d8c13005833d29789e2c841658d98259d3e2ee0fe0(
    value: typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.List[builtins.str]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7b47a964a364d29e6295c7e65c99c8a54cd1962f0bd798c23d32ee91f00e4a13(
    *,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    type: builtins.str,
    body: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    ignore_casing: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    ignore_missing_property: typing.Optional[typing.Union[builtins.bool, _cdktf_9a9027ec.IResolvable]] = None,
    locks: typing.Optional[typing.Sequence[builtins.str]] = None,
    name: typing.Optional[builtins.str] = None,
    parent_id: typing.Optional[builtins.str] = None,
    read_headers: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    read_query_parameters: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.Sequence[builtins.str]]]] = None,
    resource_id: typing.Optional[builtins.str] = None,
    response_export_values: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    retry: typing.Optional[typing.Union[UpdateResourceRetry, typing.Dict[builtins.str, typing.Any]]] = None,
    sensitive_body: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
    sensitive_body_version: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    timeouts: typing.Optional[typing.Union[UpdateResourceTimeouts, typing.Dict[builtins.str, typing.Any]]] = None,
    update_headers: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    update_query_parameters: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, typing.Mapping[builtins.str, typing.Sequence[builtins.str]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__87d45f83b2ad1d82c585e1dba7904d689304a9d3f8e8b83aaafd685ddc575771(
    *,
    error_message_regex: typing.Sequence[builtins.str],
    interval_seconds: typing.Optional[jsii.Number] = None,
    max_interval_seconds: typing.Optional[jsii.Number] = None,
    multiplier: typing.Optional[jsii.Number] = None,
    randomization_factor: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c41206770fa357fa9709c92d018356f71b2e869135d9fe2861d8157847223556(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__da62c45d5fbf12579507780b8c2183bd172b80225c48b831e041bd16e9303cb2(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__edb395a935210b210773fbc5a92da77cafde2ae6c7bca0e8af9442c17428f48e(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f47cf8c7b3f381923d0a2daadd5b1874533029c21befa0ec4128fcb287e1fca1(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dc6aeca07ac69489c9dfeac49dd53309a5fe591b3332385ff32f64d17c8296dc(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0e34b85505a5ed45c25bc4b00f058a7820d2104f28f306ab039fcd3e9b1c1131(
    value: jsii.Number,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a1858a84871a0495501923f0e43383c66682ba256e531363d48c31ef7505b6aa(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, UpdateResourceRetry]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7beb3d1c9cf97f822976fb8d91dde2779b79c5b2568e7e5917e16c666376c6c7(
    *,
    create: typing.Optional[builtins.str] = None,
    delete: typing.Optional[builtins.str] = None,
    read: typing.Optional[builtins.str] = None,
    update: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4cdb2be43cdb81266407e287f64c0f7ead06e2cc7b0af479133afe8a3f8e5441(
    terraform_resource: _cdktf_9a9027ec.IInterpolatingParent,
    terraform_attribute: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2ea0c0435ad4f0bbc6334e33680c82d307017baf1d3faa288e184f9b6012b7cb(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__97fa4065ed423e575c7441b8d3cd5824905feeaf4af1151d6c8335a357aa6572(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__62808aa669eed1a514c445c8d9b9dcdc6910194f865509913e8cfc403a1071ed(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__500c9941017ee642f6d6664026835932d4644c05cfe9f19f28f00529e6bf3f8b(
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2ce912d4ee4c6f42dd550125ccdf206b15eb5503da49fd7c4e1709b5283de27a(
    value: typing.Optional[typing.Union[_cdktf_9a9027ec.IResolvable, UpdateResourceTimeouts]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__976911fa6b440fa7cd43d95335c5f85c6f9261e14e1cce9f48c917411ba9c1c1(
    *,
    name: builtins.str,
    properties: typing.Optional[typing.Union[_VMExtensionProperties_a1e3e947, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__73d97dbf61395f5a606d108b452766d13480c62a19108fb4866b15ed4baf7753(
    *,
    publisher: builtins.str,
    type: builtins.str,
    type_handler_version: builtins.str,
    auto_upgrade_minor_version: typing.Optional[builtins.bool] = None,
    protected_settings: typing.Any = None,
    settings: typing.Any = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e65d20f8430765c4156f0a11302091f5baf85b0f70db34bdcaf4ed8dc8365404(
    *,
    errors: typing.Sequence[builtins.str],
    valid: builtins.bool,
    warnings: typing.Sequence[builtins.str],
    property_errors: typing.Optional[typing.Mapping[builtins.str, typing.Sequence[builtins.str]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__74fd92c71ed2c1615886631f31c8b508b206e72f93a2b7fd1c30a52a199f0892(
    *,
    rule_type: builtins.str,
    message: typing.Optional[builtins.str] = None,
    value: typing.Any = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5a88718c046cb975240b02c9d6085c9511848add6f515337450eaa7bc1aa595b(
    *,
    message: builtins.str,
    orphaned_resources: typing.Sequence[builtins.str],
    success: builtins.bool,
    expected_count: typing.Optional[jsii.Number] = None,
    found_count: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b56a9bd32e04dbce9a4e8ec5d6350fb902c7dd6cdab1c292b8f0a593c3227531(
    *,
    change_type: builtins.str,
    description: builtins.str,
    affected_property: typing.Optional[builtins.str] = None,
    breaking: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__189788820aa0902240f9afa632bd5e213fdd9ff8bd2341f60745e78e53a0c91d(
    *,
    release_date: builtins.str,
    schema: typing.Union[_ApiSchema_5ce0490e, typing.Dict[builtins.str, typing.Any]],
    support_level: builtins.str,
    version: builtins.str,
    breaking_changes: typing.Optional[typing.Sequence[typing.Union[_BreakingChange_5dc94c31, typing.Dict[builtins.str, typing.Any]]]] = None,
    change_log: typing.Optional[typing.Sequence[typing.Union[_VersionChangeLog_3bfd366b, typing.Dict[builtins.str, typing.Any]]]] = None,
    deprecation_date: typing.Optional[builtins.str] = None,
    migration_guide: typing.Optional[builtins.str] = None,
    sunset_date: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2bcebf3be9934a89eabf09669afb151e0510d3510b90c22489549fe756ea9dec(
    *,
    exclude_deprecated: typing.Optional[builtins.bool] = None,
    not_older_than: typing.Optional[datetime.datetime] = None,
    required_features: typing.Optional[typing.Sequence[builtins.str]] = None,
    support_level: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c362404295e2dc7aaf0aa2e4f14ad45e2149d98426448c16ef6d42342d88ef0d(
    *,
    phase: builtins.str,
    version: builtins.str,
    estimated_sunset_date: typing.Optional[builtins.str] = None,
    next_phase: typing.Optional[builtins.str] = None,
    transition_date: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2a8c7ec48ec4c580f86685320413e261bdd956469c30532ce086539fb09726de(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    hardware_profile: typing.Union[_VirtualMachineHardwareProfile_cb34f918, typing.Dict[builtins.str, typing.Any]],
    network_profile: typing.Union[_VirtualMachineNetworkProfile_42959f1d, typing.Dict[builtins.str, typing.Any]],
    storage_profile: typing.Union[_VirtualMachineStorageProfile_793daa4a, typing.Dict[builtins.str, typing.Any]],
    additional_capabilities: typing.Optional[typing.Union[_VirtualMachineAdditionalCapabilities_22a84ae8, typing.Dict[builtins.str, typing.Any]]] = None,
    availability_set: typing.Optional[typing.Union[_VirtualMachineAvailabilitySetReference_639f580a, typing.Dict[builtins.str, typing.Any]]] = None,
    billing_profile: typing.Optional[typing.Union[_VirtualMachineBillingProfile_b57d8936, typing.Dict[builtins.str, typing.Any]]] = None,
    diagnostics_profile: typing.Optional[typing.Union[_VirtualMachineDiagnosticsProfile_05cee027, typing.Dict[builtins.str, typing.Any]]] = None,
    eviction_policy: typing.Optional[builtins.str] = None,
    host: typing.Optional[typing.Union[_VirtualMachineHostReference_f551629f, typing.Dict[builtins.str, typing.Any]]] = None,
    identity: typing.Optional[typing.Union[_VirtualMachineIdentity_dc7decb0, typing.Dict[builtins.str, typing.Any]]] = None,
    ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
    license_type: typing.Optional[builtins.str] = None,
    os_profile: typing.Optional[typing.Union[_VirtualMachineOSProfile_6980e298, typing.Dict[builtins.str, typing.Any]]] = None,
    plan: typing.Optional[typing.Union[_VirtualMachinePlan_2ca6c6de, typing.Dict[builtins.str, typing.Any]]] = None,
    priority: typing.Optional[builtins.str] = None,
    proximity_placement_group: typing.Optional[typing.Union[_VirtualMachineProximityPlacementGroupReference_b821dec8, typing.Dict[builtins.str, typing.Any]]] = None,
    resource_group_id: typing.Optional[builtins.str] = None,
    security_profile: typing.Optional[typing.Union[_VirtualMachineSecurityProfile_59175751, typing.Dict[builtins.str, typing.Any]]] = None,
    virtual_machine_scale_set: typing.Optional[typing.Union[_VirtualMachineScaleSetReference_c6dfc840, typing.Dict[builtins.str, typing.Any]]] = None,
    zones: typing.Optional[typing.Sequence[builtins.str]] = None,
    api_version: typing.Optional[builtins.str] = None,
    enable_migration_analysis: typing.Optional[builtins.bool] = None,
    enable_transformation: typing.Optional[builtins.bool] = None,
    enable_validation: typing.Optional[builtins.bool] = None,
    location: typing.Optional[builtins.str] = None,
    monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c4a13f8a02410aa36113d3e2b666a05b8ed4bc1e6d207ea02b65de81685d60b4(
    action_group_id: builtins.str,
    workspace_id: typing.Optional[builtins.str] = None,
    *,
    cpu_alert_severity: typing.Optional[jsii.Number] = None,
    cpu_threshold: typing.Optional[jsii.Number] = None,
    disk_queue_alert_severity: typing.Optional[jsii.Number] = None,
    disk_queue_threshold: typing.Optional[jsii.Number] = None,
    enable_cpu_alert: typing.Optional[builtins.bool] = None,
    enable_deletion_alert: typing.Optional[builtins.bool] = None,
    enable_disk_queue_alert: typing.Optional[builtins.bool] = None,
    enable_memory_alert: typing.Optional[builtins.bool] = None,
    memory_alert_severity: typing.Optional[jsii.Number] = None,
    memory_threshold: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d552b7c2f460cd9d250e77f5bcd29916d0cdaf0433be39af9444a30ae0fa3dda(
    key: builtins.str,
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5b2b92a8952b59c50e3cd7d4f7e035a021faab82078a5bcb97905c3a63092927(
    props: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a519b26e2dcadec5007f2a705c9789919e22e6e78909b1e14da041690500883c(
    key: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__26adea4125ec451a718e48288e9ee76968a6ed717d6ebe7b73fc875697bdda9a(
    *,
    hibernation_enabled: typing.Optional[builtins.bool] = None,
    ultra_ssd_enabled: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__16465a013c8c370ce1d88d5e07f5d136b74f25774195406a1774919d43d29e15(
    *,
    id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b677f33cf11acf85506356854befbf59fde682453ea3da7884270ac8c2638e1d(
    *,
    max_price: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1284f2fc4472af8d852cbb6be0ba4f2ca83aa2cf93b5763efb7e218748ad7ad0(
    *,
    location: builtins.str,
    properties: typing.Union[_VirtualMachineBodyProperties_b30829f2, typing.Dict[builtins.str, typing.Any]],
    identity: typing.Optional[typing.Union[_VirtualMachineIdentity_dc7decb0, typing.Dict[builtins.str, typing.Any]]] = None,
    plan: typing.Optional[typing.Union[_VirtualMachinePlan_2ca6c6de, typing.Dict[builtins.str, typing.Any]]] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    zones: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__525da36b7d33e8b5227746a951c2f21a99dbf791a30a47b61fc2a9225b2c88ec(
    *,
    hardware_profile: typing.Union[_VirtualMachineHardwareProfile_cb34f918, typing.Dict[builtins.str, typing.Any]],
    network_profile: typing.Union[_VirtualMachineNetworkProfile_42959f1d, typing.Dict[builtins.str, typing.Any]],
    storage_profile: typing.Union[_VirtualMachineStorageProfile_793daa4a, typing.Dict[builtins.str, typing.Any]],
    additional_capabilities: typing.Optional[typing.Union[_VirtualMachineAdditionalCapabilities_22a84ae8, typing.Dict[builtins.str, typing.Any]]] = None,
    availability_set: typing.Optional[typing.Union[_VirtualMachineAvailabilitySetReference_639f580a, typing.Dict[builtins.str, typing.Any]]] = None,
    billing_profile: typing.Optional[typing.Union[_VirtualMachineBillingProfile_b57d8936, typing.Dict[builtins.str, typing.Any]]] = None,
    diagnostics_profile: typing.Optional[typing.Union[_VirtualMachineDiagnosticsProfile_05cee027, typing.Dict[builtins.str, typing.Any]]] = None,
    eviction_policy: typing.Optional[builtins.str] = None,
    host: typing.Optional[typing.Union[_VirtualMachineHostReference_f551629f, typing.Dict[builtins.str, typing.Any]]] = None,
    license_type: typing.Optional[builtins.str] = None,
    os_profile: typing.Optional[typing.Union[_VirtualMachineOSProfile_6980e298, typing.Dict[builtins.str, typing.Any]]] = None,
    priority: typing.Optional[builtins.str] = None,
    proximity_placement_group: typing.Optional[typing.Union[_VirtualMachineProximityPlacementGroupReference_b821dec8, typing.Dict[builtins.str, typing.Any]]] = None,
    security_profile: typing.Optional[typing.Union[_VirtualMachineSecurityProfile_59175751, typing.Dict[builtins.str, typing.Any]]] = None,
    virtual_machine_scale_set: typing.Optional[typing.Union[_VirtualMachineScaleSetReference_c6dfc840, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__953747cd15556d517cddfe8025f0c48d7ad9e5763f1be53358c24335509cb411(
    *,
    enabled: typing.Optional[builtins.bool] = None,
    storage_uri: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__951c7ad99b7715ad57eaa2f260eeb8f689895869e0084ca7a461748872b14183(
    *,
    create_option: builtins.str,
    lun: jsii.Number,
    caching: typing.Optional[builtins.str] = None,
    disk_size_gb: typing.Optional[jsii.Number] = None,
    managed_disk: typing.Optional[typing.Union[_VirtualMachineManagedDiskParameters_0c76a786, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__da4169752c2c1e98e6fc9e95cb4b274453833aebf92d16b43991fdb0173327e3(
    *,
    boot_diagnostics: typing.Optional[typing.Union[_VirtualMachineBootDiagnostics_51400f7e, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__95ecc859635dcb34792f2768641828d034732ac69218eb08e44ec2543a2a7160(
    *,
    id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__59eab7fd2aa85e829716bd35b8b7d9ec556e972a438fde1d69f55a3815443e71(
    *,
    vm_size: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__99af5e01959856487fa4929b901e1ad0cab8483e139f972526efcf2452f7a980(
    *,
    id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5b2ecca209d80aec6bc9261a8563ec397215f2eca1ad76b53eda3ed2b67bffd8(
    *,
    type: builtins.str,
    user_assigned_identities: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d32a2b64a02c22b9421a7b3db44deda6a7a880211d88852f4ad52b9bbd1023f6(
    *,
    id: typing.Optional[builtins.str] = None,
    offer: typing.Optional[builtins.str] = None,
    publisher: typing.Optional[builtins.str] = None,
    sku: typing.Optional[builtins.str] = None,
    version: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__be86fc92efe31b6f35dbeef3ca3d359887aaf1566cc38155f8cb396f8d93cbb4(
    *,
    disable_password_authentication: typing.Optional[builtins.bool] = None,
    patch_settings: typing.Optional[typing.Union[_VirtualMachineLinuxPatchSettings_171efe8f, typing.Dict[builtins.str, typing.Any]]] = None,
    provision_vm_agent: typing.Optional[builtins.bool] = None,
    ssh: typing.Optional[typing.Union[_VirtualMachineSshConfiguration_7da21948, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1843b7001ff1dab82d7a77070bc2b2b9e3e8839038e185b12757671caad992cd(
    *,
    assessment_mode: typing.Optional[builtins.str] = None,
    patch_mode: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ce19973e85e5907fee21b00be4ba64aa45b8fbe2497bf3fad067f57f7e73d2de(
    *,
    disk_encryption_set: typing.Optional[typing.Union[_VirtualMachineDiskEncryptionSetParameters_804f37ce, typing.Dict[builtins.str, typing.Any]]] = None,
    id: typing.Optional[builtins.str] = None,
    storage_account_type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__67a8c7fc59da4b92ee2e7102987556299b6894a48f0289303e62a99fe0b2caa4(
    *,
    cpu_alert_severity: typing.Optional[jsii.Number] = None,
    cpu_threshold: typing.Optional[jsii.Number] = None,
    disk_queue_alert_severity: typing.Optional[jsii.Number] = None,
    disk_queue_threshold: typing.Optional[jsii.Number] = None,
    enable_cpu_alert: typing.Optional[builtins.bool] = None,
    enable_deletion_alert: typing.Optional[builtins.bool] = None,
    enable_disk_queue_alert: typing.Optional[builtins.bool] = None,
    enable_memory_alert: typing.Optional[builtins.bool] = None,
    memory_alert_severity: typing.Optional[jsii.Number] = None,
    memory_threshold: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__acd6aacf643662630b2a25abd973908e33a21c6983b4214d8db9b4d7504d9f84(
    *,
    primary: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c937df4c3e06601e97789dc600226548577f28467ea74b53b317667ed2f3600a(
    *,
    id: builtins.str,
    properties: typing.Optional[typing.Union[_VirtualMachineNetworkInterfaceProperties_d2a4bcfa, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__144bbceaf31a370710e099c6114f76bec174198900948bf4eba616963a5a21a1(
    *,
    network_interfaces: typing.Sequence[typing.Union[_VirtualMachineNetworkInterfaceReference_67cea400, typing.Dict[builtins.str, typing.Any]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e24d8ece99591c7f3bf5395bd91f355d99bf1d43f05ce4a5df8da71361d876db(
    *,
    create_option: builtins.str,
    caching: typing.Optional[builtins.str] = None,
    disk_size_gb: typing.Optional[jsii.Number] = None,
    managed_disk: typing.Optional[typing.Union[_VirtualMachineManagedDiskParameters_0c76a786, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
    os_type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__349655f3da2830f7da9accb559e7334b21b5d1151ed4b7a9db9d95ed8161f5e0(
    *,
    admin_username: builtins.str,
    computer_name: builtins.str,
    admin_password: typing.Optional[builtins.str] = None,
    allow_extension_operations: typing.Optional[builtins.bool] = None,
    custom_data: typing.Optional[builtins.str] = None,
    linux_configuration: typing.Optional[typing.Union[_VirtualMachineLinuxConfiguration_5f791d4c, typing.Dict[builtins.str, typing.Any]]] = None,
    secrets: typing.Optional[typing.Sequence[typing.Union[_VirtualMachineSecret_47d96616, typing.Dict[builtins.str, typing.Any]]]] = None,
    windows_configuration: typing.Optional[typing.Union[_VirtualMachineWindowsConfiguration_31cdebe5, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__35630fe41fd120fe35b4c0db61a9d05beb2e9b54a5cce9ca3e98f7f52806712b(
    *,
    name: typing.Optional[builtins.str] = None,
    product: typing.Optional[builtins.str] = None,
    promotion_code: typing.Optional[builtins.str] = None,
    publisher: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6d46795c7b225d47751b88466c07ce694a17f10bd5f0a02cce28e95a6f5b7d2e(
    *,
    billing_profile: typing.Optional[typing.Union[_VirtualMachineBillingProfile_b57d8936, typing.Dict[builtins.str, typing.Any]]] = None,
    eviction_policy: typing.Optional[builtins.str] = None,
    priority: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__34a7c945f01f3ffeb4fe733b91c2faa1a06a4e4cadd1e4d5c147770c5ad1e400(
    *,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    api_version: typing.Optional[builtins.str] = None,
    enable_migration_analysis: typing.Optional[builtins.bool] = None,
    enable_transformation: typing.Optional[builtins.bool] = None,
    enable_validation: typing.Optional[builtins.bool] = None,
    location: typing.Optional[builtins.str] = None,
    monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    hardware_profile: typing.Union[_VirtualMachineHardwareProfile_cb34f918, typing.Dict[builtins.str, typing.Any]],
    network_profile: typing.Union[_VirtualMachineNetworkProfile_42959f1d, typing.Dict[builtins.str, typing.Any]],
    storage_profile: typing.Union[_VirtualMachineStorageProfile_793daa4a, typing.Dict[builtins.str, typing.Any]],
    additional_capabilities: typing.Optional[typing.Union[_VirtualMachineAdditionalCapabilities_22a84ae8, typing.Dict[builtins.str, typing.Any]]] = None,
    availability_set: typing.Optional[typing.Union[_VirtualMachineAvailabilitySetReference_639f580a, typing.Dict[builtins.str, typing.Any]]] = None,
    billing_profile: typing.Optional[typing.Union[_VirtualMachineBillingProfile_b57d8936, typing.Dict[builtins.str, typing.Any]]] = None,
    diagnostics_profile: typing.Optional[typing.Union[_VirtualMachineDiagnosticsProfile_05cee027, typing.Dict[builtins.str, typing.Any]]] = None,
    eviction_policy: typing.Optional[builtins.str] = None,
    host: typing.Optional[typing.Union[_VirtualMachineHostReference_f551629f, typing.Dict[builtins.str, typing.Any]]] = None,
    identity: typing.Optional[typing.Union[_VirtualMachineIdentity_dc7decb0, typing.Dict[builtins.str, typing.Any]]] = None,
    ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
    license_type: typing.Optional[builtins.str] = None,
    os_profile: typing.Optional[typing.Union[_VirtualMachineOSProfile_6980e298, typing.Dict[builtins.str, typing.Any]]] = None,
    plan: typing.Optional[typing.Union[_VirtualMachinePlan_2ca6c6de, typing.Dict[builtins.str, typing.Any]]] = None,
    priority: typing.Optional[builtins.str] = None,
    proximity_placement_group: typing.Optional[typing.Union[_VirtualMachineProximityPlacementGroupReference_b821dec8, typing.Dict[builtins.str, typing.Any]]] = None,
    resource_group_id: typing.Optional[builtins.str] = None,
    security_profile: typing.Optional[typing.Union[_VirtualMachineSecurityProfile_59175751, typing.Dict[builtins.str, typing.Any]]] = None,
    virtual_machine_scale_set: typing.Optional[typing.Union[_VirtualMachineScaleSetReference_c6dfc840, typing.Dict[builtins.str, typing.Any]]] = None,
    zones: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__82bf5177dc9562ea6e13381a0ee8e6416d195eccb3825639f155f6a11ffef234(
    *,
    id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6dd41697378c19cc11378623e9bc97db6bb3ba92efdb45d6824862ee02889419(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    location: builtins.str,
    name: builtins.str,
    sku: typing.Union[_VirtualMachineScaleSetSku_34577b48, typing.Dict[builtins.str, typing.Any]],
    additional_capabilities: typing.Optional[typing.Union[_AdditionalCapabilities_a2950776, typing.Dict[builtins.str, typing.Any]]] = None,
    api_version: typing.Optional[builtins.str] = None,
    automatic_repairs_policy: typing.Optional[typing.Union[_AutomaticRepairsPolicy_6d70e54f, typing.Dict[builtins.str, typing.Any]]] = None,
    do_not_run_extensions_on_overprovisioned_v_ms: typing.Optional[builtins.bool] = None,
    enable_migration_analysis: typing.Optional[builtins.bool] = None,
    enable_transformation: typing.Optional[builtins.bool] = None,
    enable_validation: typing.Optional[builtins.bool] = None,
    host_group: typing.Optional[typing.Union[_HostGroupReference_3690e1b0, typing.Dict[builtins.str, typing.Any]]] = None,
    identity: typing.Optional[typing.Union[_VirtualMachineIdentity_dc7decb0, typing.Dict[builtins.str, typing.Any]]] = None,
    ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
    monitoring: typing.Any = None,
    orchestration_mode: typing.Optional[builtins.str] = None,
    overprovision: typing.Optional[builtins.bool] = None,
    plan: typing.Optional[typing.Union[_VirtualMachinePlan_2ca6c6de, typing.Dict[builtins.str, typing.Any]]] = None,
    platform_fault_domain_count: typing.Optional[jsii.Number] = None,
    proximity_placement_group: typing.Optional[typing.Union[_ProximityPlacementGroupReference_c34e9a6e, typing.Dict[builtins.str, typing.Any]]] = None,
    resource_group_id: typing.Optional[builtins.str] = None,
    scale_in_policy: typing.Optional[typing.Union[_VirtualMachineScaleSetScaleInPolicy_08264334, typing.Dict[builtins.str, typing.Any]]] = None,
    single_placement_group: typing.Optional[builtins.bool] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    upgrade_policy: typing.Optional[typing.Union[_VirtualMachineScaleSetUpgradePolicy_ff7653fe, typing.Dict[builtins.str, typing.Any]]] = None,
    virtual_machine_profile: typing.Optional[typing.Union[_VirtualMachineScaleSetVMProfile_ec8f7867, typing.Dict[builtins.str, typing.Any]]] = None,
    zone_balance: typing.Optional[builtins.bool] = None,
    zones: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8cf87579583cfa02c6a9eb91584ef30cf16ccd42e0456b7bcfcd40c487148558(
    action_group_id: builtins.str,
    workspace_id: typing.Optional[builtins.str] = None,
    *,
    cpu_alert_severity: typing.Optional[jsii.Number] = None,
    cpu_threshold: typing.Optional[jsii.Number] = None,
    disk_queue_alert_severity: typing.Optional[jsii.Number] = None,
    disk_queue_threshold: typing.Optional[jsii.Number] = None,
    enable_cpu_alert: typing.Optional[builtins.bool] = None,
    enable_deletion_alert: typing.Optional[builtins.bool] = None,
    enable_disk_queue_alert: typing.Optional[builtins.bool] = None,
    enable_memory_alert: typing.Optional[builtins.bool] = None,
    memory_alert_severity: typing.Optional[jsii.Number] = None,
    memory_threshold: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__657c9068a1ac2f64155887cbbae0f395c6a8d05869dd84ae8527abe23175127c(
    key: builtins.str,
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__93897854661b55f6093497152d6cb55ae9b78e0153f79a8c56009a2e0b9271c7(
    props: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__061fa6ba3d8de22be01727b5757f50f2d6e4a7cc99be16ffd389a66ded26b131(
    key: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__91b88b373f7453efb4cc762f7b890b1565b1f0d1a0bf20bb26b0dcb0fc0d1763(
    *,
    location: builtins.str,
    properties: typing.Union[_VirtualMachineScaleSetBodyProperties_4f71389b, typing.Dict[builtins.str, typing.Any]],
    sku: typing.Union[_VirtualMachineScaleSetSku_34577b48, typing.Dict[builtins.str, typing.Any]],
    identity: typing.Optional[typing.Union[_VirtualMachineIdentity_dc7decb0, typing.Dict[builtins.str, typing.Any]]] = None,
    plan: typing.Optional[typing.Union[_VirtualMachinePlan_2ca6c6de, typing.Dict[builtins.str, typing.Any]]] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    zones: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__00af7041975101c1d551651902aa68ac82232f63864cdba29addbf6e3cb16865(
    *,
    additional_capabilities: typing.Optional[typing.Union[_AdditionalCapabilities_a2950776, typing.Dict[builtins.str, typing.Any]]] = None,
    automatic_repairs_policy: typing.Optional[typing.Union[_AutomaticRepairsPolicy_6d70e54f, typing.Dict[builtins.str, typing.Any]]] = None,
    do_not_run_extensions_on_overprovisioned_v_ms: typing.Optional[builtins.bool] = None,
    host_group: typing.Optional[typing.Union[_HostGroupReference_3690e1b0, typing.Dict[builtins.str, typing.Any]]] = None,
    orchestration_mode: typing.Optional[builtins.str] = None,
    overprovision: typing.Optional[builtins.bool] = None,
    platform_fault_domain_count: typing.Optional[jsii.Number] = None,
    proximity_placement_group: typing.Optional[typing.Union[_ProximityPlacementGroupReference_c34e9a6e, typing.Dict[builtins.str, typing.Any]]] = None,
    scale_in_policy: typing.Optional[typing.Union[_VirtualMachineScaleSetScaleInPolicy_08264334, typing.Dict[builtins.str, typing.Any]]] = None,
    single_placement_group: typing.Optional[builtins.bool] = None,
    upgrade_policy: typing.Optional[typing.Union[_VirtualMachineScaleSetUpgradePolicy_ff7653fe, typing.Dict[builtins.str, typing.Any]]] = None,
    virtual_machine_profile: typing.Optional[typing.Union[_VirtualMachineScaleSetVMProfile_ec8f7867, typing.Dict[builtins.str, typing.Any]]] = None,
    zone_balance: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7d3570dfe82a9bde4355d2fe2cddd479bd9b1af1d37c953dda0d83c2d28c3c45(
    *,
    health_probe: typing.Optional[typing.Union[_HealthProbeReference_1eac48d7, typing.Dict[builtins.str, typing.Any]]] = None,
    network_api_version: typing.Optional[builtins.str] = None,
    network_interface_configurations: typing.Optional[typing.Sequence[typing.Union[_NetworkInterfaceConfiguration_c5773a40, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__44b4eb24f67df1f81e7313522f89d9cfdb15e4a2971ded702c0ce1efe6f74a6c(
    *,
    admin_password: typing.Optional[builtins.str] = None,
    admin_username: typing.Optional[builtins.str] = None,
    allow_extension_operations: typing.Optional[builtins.bool] = None,
    computer_name_prefix: typing.Optional[builtins.str] = None,
    custom_data: typing.Optional[builtins.str] = None,
    linux_configuration: typing.Optional[typing.Union[_VirtualMachineLinuxConfiguration_5f791d4c, typing.Dict[builtins.str, typing.Any]]] = None,
    require_guest_provision_signal: typing.Optional[builtins.bool] = None,
    secrets: typing.Optional[typing.Sequence[typing.Any]] = None,
    windows_configuration: typing.Optional[typing.Union[_VirtualMachineWindowsConfiguration_31cdebe5, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e2889de8cdd3d9d13397c243f51e33cc0f0408fa32520b61be80ffc6f9d2628a(
    *,
    location: builtins.str,
    name: builtins.str,
    sku: typing.Union[_VirtualMachineScaleSetSku_34577b48, typing.Dict[builtins.str, typing.Any]],
    additional_capabilities: typing.Optional[typing.Union[_AdditionalCapabilities_a2950776, typing.Dict[builtins.str, typing.Any]]] = None,
    api_version: typing.Optional[builtins.str] = None,
    automatic_repairs_policy: typing.Optional[typing.Union[_AutomaticRepairsPolicy_6d70e54f, typing.Dict[builtins.str, typing.Any]]] = None,
    do_not_run_extensions_on_overprovisioned_v_ms: typing.Optional[builtins.bool] = None,
    enable_migration_analysis: typing.Optional[builtins.bool] = None,
    enable_transformation: typing.Optional[builtins.bool] = None,
    enable_validation: typing.Optional[builtins.bool] = None,
    host_group: typing.Optional[typing.Union[_HostGroupReference_3690e1b0, typing.Dict[builtins.str, typing.Any]]] = None,
    identity: typing.Optional[typing.Union[_VirtualMachineIdentity_dc7decb0, typing.Dict[builtins.str, typing.Any]]] = None,
    ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
    monitoring: typing.Any = None,
    orchestration_mode: typing.Optional[builtins.str] = None,
    overprovision: typing.Optional[builtins.bool] = None,
    plan: typing.Optional[typing.Union[_VirtualMachinePlan_2ca6c6de, typing.Dict[builtins.str, typing.Any]]] = None,
    platform_fault_domain_count: typing.Optional[jsii.Number] = None,
    proximity_placement_group: typing.Optional[typing.Union[_ProximityPlacementGroupReference_c34e9a6e, typing.Dict[builtins.str, typing.Any]]] = None,
    resource_group_id: typing.Optional[builtins.str] = None,
    scale_in_policy: typing.Optional[typing.Union[_VirtualMachineScaleSetScaleInPolicy_08264334, typing.Dict[builtins.str, typing.Any]]] = None,
    single_placement_group: typing.Optional[builtins.bool] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    upgrade_policy: typing.Optional[typing.Union[_VirtualMachineScaleSetUpgradePolicy_ff7653fe, typing.Dict[builtins.str, typing.Any]]] = None,
    virtual_machine_profile: typing.Optional[typing.Union[_VirtualMachineScaleSetVMProfile_ec8f7867, typing.Dict[builtins.str, typing.Any]]] = None,
    zone_balance: typing.Optional[builtins.bool] = None,
    zones: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__14a1a21f9af81cc8ea03cb10492d9021bb12e07a369504234925578bf5d648ab(
    *,
    id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__99d6936e7f14c906df4687341d906ee82d75321364234ea3b387a3b22be29ff4(
    *,
    force_deletion: typing.Optional[builtins.bool] = None,
    rules: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1fa1fbf7c361e94a662b5d5ebde0d0c5270fa4fb8b133c287594497042194561(
    *,
    do_not_run_extensions_on_overprovisioned_v_ms: typing.Optional[builtins.bool] = None,
    overprovision: typing.Optional[builtins.bool] = None,
    platform_fault_domain_count: typing.Optional[jsii.Number] = None,
    single_placement_group: typing.Optional[builtins.bool] = None,
    zone_balance: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__30c45ebb2abfaa74b408cfee2be7ad67fc0c0bc57bfb4d808fae531ebd31281b(
    *,
    name: builtins.str,
    capacity: typing.Optional[jsii.Number] = None,
    tier: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6e120f9c2e6fb265d5d3d1ab89ee4f5e92a2e87991268ad039a4a32c4f568f0d(
    *,
    automatic_os_upgrade_policy: typing.Optional[typing.Union[_AutomaticOSUpgradePolicy_11c86d38, typing.Dict[builtins.str, typing.Any]]] = None,
    mode: typing.Optional[builtins.str] = None,
    rolling_upgrade_policy: typing.Optional[typing.Union[_RollingUpgradePolicy_9ee9233f, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a3cf55421f920dcf6dc4b0edbd58c29544e5b75937315015c50fe3560503de90(
    *,
    billing_profile: typing.Optional[typing.Union[_VirtualMachineBillingProfile_b57d8936, typing.Dict[builtins.str, typing.Any]]] = None,
    diagnostics_profile: typing.Optional[typing.Union[_VirtualMachineDiagnosticsProfile_05cee027, typing.Dict[builtins.str, typing.Any]]] = None,
    eviction_policy: typing.Optional[builtins.str] = None,
    extension_profile: typing.Optional[typing.Union[_ExtensionProfile_ec55a00c, typing.Dict[builtins.str, typing.Any]]] = None,
    license_type: typing.Optional[builtins.str] = None,
    network_profile: typing.Optional[typing.Union[_VirtualMachineScaleSetNetworkProfile_e3604858, typing.Dict[builtins.str, typing.Any]]] = None,
    os_profile: typing.Optional[typing.Union[_VirtualMachineScaleSetOSProfile_320ebb42, typing.Dict[builtins.str, typing.Any]]] = None,
    priority: typing.Optional[builtins.str] = None,
    scheduled_events_profile: typing.Optional[typing.Union[_ScheduledEventsProfile_f4e5611c, typing.Dict[builtins.str, typing.Any]]] = None,
    security_profile: typing.Optional[typing.Union[_VirtualMachineSecurityProfile_59175751, typing.Dict[builtins.str, typing.Any]]] = None,
    storage_profile: typing.Optional[typing.Union[_VirtualMachineStorageProfile_793daa4a, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2dcbb3efd12bb4bcfd467b18f718238bc8c02c5afbd1654b36a538254b7c2763(
    *,
    source_vault: typing.Optional[typing.Union[_VirtualMachineSubResource_f7a6c8fb, typing.Dict[builtins.str, typing.Any]]] = None,
    vault_certificates: typing.Optional[typing.Sequence[typing.Union[_VirtualMachineVaultCertificate_60841248, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2b93a4e40a67b9a909dfbea523d9336e3ad0897aaa270283ff940d1b5dc1b77a(
    *,
    encryption_at_host: typing.Optional[builtins.bool] = None,
    security_type: typing.Optional[builtins.str] = None,
    uefi_settings: typing.Optional[typing.Union[_VirtualMachineUefiSettings_ba93462d, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bd02055a91c6f86aae8497d10e9473836a0ab7af3e0272a529654b43be82368d(
    *,
    public_keys: typing.Optional[typing.Sequence[typing.Union[_VirtualMachineSshPublicKey_6551d0b0, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7d33509b6ce67ec15c4d254ea775823f070c0f9e56e312fea5770cd82258ba2b(
    *,
    key_data: builtins.str,
    path: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ae1313f2db29d370d75fd0d9075b775b70e45ee6f45ba28d8ab0c917a93ce030(
    *,
    os_disk: typing.Union[_VirtualMachineOSDisk_582a6f94, typing.Dict[builtins.str, typing.Any]],
    data_disks: typing.Optional[typing.Sequence[typing.Union[_VirtualMachineDataDisk_839db3b6, typing.Dict[builtins.str, typing.Any]]]] = None,
    image_reference: typing.Optional[typing.Union[_VirtualMachineImageReference_f5fa193e, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__542c5470191453d04b1ce96801a742c2d1e8a7c893190d8c02cad8978402d2f2(
    *,
    id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0e95479a9b9ec182356e13dc88fd4087b32bd1ebafea2c06dd227e6d23536f1a(
    *,
    secure_boot_enabled: typing.Optional[builtins.bool] = None,
    v_tpm_enabled: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__eb4b590f4c47c3e5578fd6d1513e186a8ccad21fb19b850e27db692226e9bf31(
    *,
    certificate_store: typing.Optional[builtins.str] = None,
    certificate_url: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__36669ec5328e06a2fe299335b39669c061a0b80c2447da28bb3e953764934dba(
    *,
    listeners: typing.Optional[typing.Sequence[typing.Union[_VirtualMachineWinRMListener_85e51ce5, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__91e2b5e82005d18d21cbd138461defb81ecb493f35e8267b7d8e5f1688409987(
    *,
    protocol: builtins.str,
    certificate_url: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6222892f54c4fcd5fb989009725cbd313eb34a0e9700b8291482a506171d6580(
    *,
    enable_automatic_updates: typing.Optional[builtins.bool] = None,
    patch_settings: typing.Optional[typing.Union[_VirtualMachineWindowsPatchSettings_18b61ab1, typing.Dict[builtins.str, typing.Any]]] = None,
    provision_vm_agent: typing.Optional[builtins.bool] = None,
    time_zone: typing.Optional[builtins.str] = None,
    win_rm: typing.Optional[typing.Union[_VirtualMachineWinRMConfiguration_1df9a9c3, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d35d356136846745ec65dd5bc2d814049f97c9236f4f76b7748beec3c97f9bf3(
    *,
    assessment_mode: typing.Optional[builtins.str] = None,
    enable_hotpatching: typing.Optional[builtins.bool] = None,
    patch_mode: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c451cbadd411e1088316a520222198adddcfdb8eaacfa6dccded4330ad372874(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    address_space: typing.Union[_VirtualNetworkAddressSpace_f881cca1, typing.Dict[builtins.str, typing.Any]],
    dhcp_options: typing.Optional[typing.Union[_VirtualNetworkDhcpOptions_da8e9a61, typing.Dict[builtins.str, typing.Any]]] = None,
    enable_ddos_protection: typing.Optional[builtins.bool] = None,
    enable_vm_protection: typing.Optional[builtins.bool] = None,
    encryption: typing.Any = None,
    flow_timeout_in_minutes: typing.Optional[jsii.Number] = None,
    ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
    resource_group_id: typing.Optional[builtins.str] = None,
    subnets: typing.Optional[typing.Sequence[typing.Any]] = None,
    api_version: typing.Optional[builtins.str] = None,
    enable_migration_analysis: typing.Optional[builtins.bool] = None,
    enable_transformation: typing.Optional[builtins.bool] = None,
    enable_validation: typing.Optional[builtins.bool] = None,
    location: typing.Optional[builtins.str] = None,
    monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1aa5b256fdbdaeefd7eccd283957536fda7c8004ba2371f1b743ce38856525b5(
    key: builtins.str,
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f6197adca4afd14584815775ab1842de5897b3733c8f2edc1b3d00c170397b72(
    props: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__be6cfe6281abb67e65670fb58f6f0c129a4eccbf2be71874babaddc958bd8568(
    key: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7d77034fb7de6190cf33e4ddaf2c6bfe41f6415ce041250bf570c3b4d7b764dc(
    *,
    address_prefixes: typing.Sequence[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__014434e91af1d7817a3f40e0f25486d02e69e55e253cd53247b1e62785173528(
    *,
    dns_servers: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__751b27b357e1e4619b6620f3e46e36981865e1e18e25dc77a8e42c163edef46f(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    gateway_type: builtins.str,
    ip_configurations: typing.Sequence[typing.Union[_VirtualNetworkGatewayIpConfiguration_853eed86, typing.Dict[builtins.str, typing.Any]]],
    sku: typing.Union[_VirtualNetworkGatewaySku_46d6411c, typing.Dict[builtins.str, typing.Any]],
    active_active: typing.Optional[builtins.bool] = None,
    bgp_settings: typing.Optional[typing.Union[_VirtualNetworkGatewayBgpSettings_63ddc7c4, typing.Dict[builtins.str, typing.Any]]] = None,
    custom_routes: typing.Optional[typing.Union[_VirtualNetworkGatewayCustomRoutes_7b9fea86, typing.Dict[builtins.str, typing.Any]]] = None,
    enable_bgp: typing.Optional[builtins.bool] = None,
    enable_private_ip_address: typing.Optional[builtins.bool] = None,
    gateway_default_site: typing.Optional[typing.Union[_VirtualNetworkGatewayDefaultSite_7b6991ba, typing.Dict[builtins.str, typing.Any]]] = None,
    ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
    resource_group_id: typing.Optional[builtins.str] = None,
    vpn_client_configuration: typing.Optional[typing.Union[_VirtualNetworkGatewayVpnClientConfiguration_861b9698, typing.Dict[builtins.str, typing.Any]]] = None,
    vpn_gateway_generation: typing.Optional[builtins.str] = None,
    vpn_type: typing.Optional[builtins.str] = None,
    api_version: typing.Optional[builtins.str] = None,
    enable_migration_analysis: typing.Optional[builtins.bool] = None,
    enable_transformation: typing.Optional[builtins.bool] = None,
    enable_validation: typing.Optional[builtins.bool] = None,
    location: typing.Optional[builtins.str] = None,
    monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0d0d766e3ede9d84f1066f914a6b21c34424003392f65482e551f7b078b83975(
    key: builtins.str,
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c847b06e877622dd838f85f1b2f34ebeccc067ff63a11be5fbf1bdfa1961ca7e(
    props: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__616331cc8dc16145ec0e643ee21d7fa6dbc3a5d927dcac1ad2e9c39a29525b92(
    key: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f12e6b913e6bbf146fc36779fa80f858540c73b886d91b265c0616a7f2e7a746(
    *,
    asn: typing.Optional[jsii.Number] = None,
    bgp_peering_address: typing.Optional[builtins.str] = None,
    bgp_peering_addresses: typing.Optional[typing.Sequence[typing.Any]] = None,
    peer_weight: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__21a2492d28bdec4e84d3ea191dc20cef795a15aa831b1c8e975c5d30a6845918(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    connection_type: builtins.str,
    resource_group_id: builtins.str,
    virtual_network_gateway1: typing.Union[_GatewayReference_be6ddc95, typing.Dict[builtins.str, typing.Any]],
    authorization_key: typing.Optional[builtins.str] = None,
    connection_mode: typing.Optional[builtins.str] = None,
    connection_protocol: typing.Optional[builtins.str] = None,
    dpd_timeout_seconds: typing.Optional[jsii.Number] = None,
    egress_nat_rules: typing.Optional[typing.Sequence[typing.Union[_NatRuleReference_233246a9, typing.Dict[builtins.str, typing.Any]]]] = None,
    enable_bgp: typing.Optional[builtins.bool] = None,
    ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
    ingress_nat_rules: typing.Optional[typing.Sequence[typing.Union[_NatRuleReference_233246a9, typing.Dict[builtins.str, typing.Any]]]] = None,
    ipsec_policies: typing.Optional[typing.Sequence[typing.Union[_IpsecPolicy_1ea4f1e2, typing.Dict[builtins.str, typing.Any]]]] = None,
    local_network_gateway2: typing.Optional[typing.Union[_GatewayReference_be6ddc95, typing.Dict[builtins.str, typing.Any]]] = None,
    peer: typing.Optional[typing.Union[_PeerReference_619b2bd0, typing.Dict[builtins.str, typing.Any]]] = None,
    routing_weight: typing.Optional[jsii.Number] = None,
    shared_key: typing.Optional[builtins.str] = None,
    use_policy_based_traffic_selectors: typing.Optional[builtins.bool] = None,
    virtual_network_gateway2: typing.Optional[typing.Union[_GatewayReference_be6ddc95, typing.Dict[builtins.str, typing.Any]]] = None,
    api_version: typing.Optional[builtins.str] = None,
    enable_migration_analysis: typing.Optional[builtins.bool] = None,
    enable_transformation: typing.Optional[builtins.bool] = None,
    enable_validation: typing.Optional[builtins.bool] = None,
    location: typing.Optional[builtins.str] = None,
    monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e8d60249a799463a775d8628ca4a063558d0c6765131af3f8d70b52d2abe4625(
    key: builtins.str,
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__458e68ad25f7a63d51d61ec0ed04891cc6a6a87b9c71a54f215248f0d295c623(
    props: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__33af03d2e6f6e0794e75315cf4683cf632e1ba0c6894d0b35a0c7b6596221245(
    key: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__35943d06799c0baffb77dee03d12888ae5c88f6da171b7e359c001b83c697296(
    *,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    api_version: typing.Optional[builtins.str] = None,
    enable_migration_analysis: typing.Optional[builtins.bool] = None,
    enable_transformation: typing.Optional[builtins.bool] = None,
    enable_validation: typing.Optional[builtins.bool] = None,
    location: typing.Optional[builtins.str] = None,
    monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    connection_type: builtins.str,
    resource_group_id: builtins.str,
    virtual_network_gateway1: typing.Union[_GatewayReference_be6ddc95, typing.Dict[builtins.str, typing.Any]],
    authorization_key: typing.Optional[builtins.str] = None,
    connection_mode: typing.Optional[builtins.str] = None,
    connection_protocol: typing.Optional[builtins.str] = None,
    dpd_timeout_seconds: typing.Optional[jsii.Number] = None,
    egress_nat_rules: typing.Optional[typing.Sequence[typing.Union[_NatRuleReference_233246a9, typing.Dict[builtins.str, typing.Any]]]] = None,
    enable_bgp: typing.Optional[builtins.bool] = None,
    ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
    ingress_nat_rules: typing.Optional[typing.Sequence[typing.Union[_NatRuleReference_233246a9, typing.Dict[builtins.str, typing.Any]]]] = None,
    ipsec_policies: typing.Optional[typing.Sequence[typing.Union[_IpsecPolicy_1ea4f1e2, typing.Dict[builtins.str, typing.Any]]]] = None,
    local_network_gateway2: typing.Optional[typing.Union[_GatewayReference_be6ddc95, typing.Dict[builtins.str, typing.Any]]] = None,
    peer: typing.Optional[typing.Union[_PeerReference_619b2bd0, typing.Dict[builtins.str, typing.Any]]] = None,
    routing_weight: typing.Optional[jsii.Number] = None,
    shared_key: typing.Optional[builtins.str] = None,
    use_policy_based_traffic_selectors: typing.Optional[builtins.bool] = None,
    virtual_network_gateway2: typing.Optional[typing.Union[_GatewayReference_be6ddc95, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__366de0e9be541f9ed2f0a00ee2d969d395e438d4f341b2a420a61071e9fc3062(
    *,
    address_prefixes: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b3d375e1f6ed1d212c3fb83c0eafd715721e7597f7e96d01e5dd3e29876271fe(
    *,
    id: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__324eca3aa96d54593a4d62490183d5c50e9703d5efb80ec9185dbb413186a23f(
    *,
    name: builtins.str,
    public_ip_address_id: builtins.str,
    subnet_id: builtins.str,
    private_ip_allocation_method: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__50362a953dc8a1cc734ee12acc24925a974bc6116208dc5a84beffcb35ba6ece(
    *,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    api_version: typing.Optional[builtins.str] = None,
    enable_migration_analysis: typing.Optional[builtins.bool] = None,
    enable_transformation: typing.Optional[builtins.bool] = None,
    enable_validation: typing.Optional[builtins.bool] = None,
    location: typing.Optional[builtins.str] = None,
    monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    gateway_type: builtins.str,
    ip_configurations: typing.Sequence[typing.Union[_VirtualNetworkGatewayIpConfiguration_853eed86, typing.Dict[builtins.str, typing.Any]]],
    sku: typing.Union[_VirtualNetworkGatewaySku_46d6411c, typing.Dict[builtins.str, typing.Any]],
    active_active: typing.Optional[builtins.bool] = None,
    bgp_settings: typing.Optional[typing.Union[_VirtualNetworkGatewayBgpSettings_63ddc7c4, typing.Dict[builtins.str, typing.Any]]] = None,
    custom_routes: typing.Optional[typing.Union[_VirtualNetworkGatewayCustomRoutes_7b9fea86, typing.Dict[builtins.str, typing.Any]]] = None,
    enable_bgp: typing.Optional[builtins.bool] = None,
    enable_private_ip_address: typing.Optional[builtins.bool] = None,
    gateway_default_site: typing.Optional[typing.Union[_VirtualNetworkGatewayDefaultSite_7b6991ba, typing.Dict[builtins.str, typing.Any]]] = None,
    ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
    resource_group_id: typing.Optional[builtins.str] = None,
    vpn_client_configuration: typing.Optional[typing.Union[_VirtualNetworkGatewayVpnClientConfiguration_861b9698, typing.Dict[builtins.str, typing.Any]]] = None,
    vpn_gateway_generation: typing.Optional[builtins.str] = None,
    vpn_type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a26a2fd898af1ef4fa4befe66822fa870fe9c91e3aface32480c37cb6d2140c2(
    *,
    name: builtins.str,
    tier: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1fb2f0020b01db5fc73fcc6884009a0790ac9707746dfce4c517e27cfb3cf97f(
    *,
    address_prefixes: typing.Sequence[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4305a8c17927f25c7f61b0bdde3d3629ba07f851a7654b53a556e646a3560b0b(
    *,
    radius_server_address: typing.Optional[builtins.str] = None,
    radius_server_secret: typing.Optional[builtins.str] = None,
    vpn_client_address_pool: typing.Optional[typing.Union[_VirtualNetworkGatewayVpnClientAddressPool_99253f78, typing.Dict[builtins.str, typing.Any]]] = None,
    vpn_client_protocols: typing.Optional[typing.Sequence[builtins.str]] = None,
    vpn_client_revoked_certificates: typing.Optional[typing.Sequence[typing.Any]] = None,
    vpn_client_root_certificates: typing.Optional[typing.Sequence[typing.Any]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__669ef009eed4aa3410b31b0ec11810f13391f1e322c9d848346d1f0801dc34e6(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    network_manager_scope_accesses: typing.Sequence[builtins.str],
    network_manager_scopes: typing.Union[_NetworkManagerScopes_d6035bf8, typing.Dict[builtins.str, typing.Any]],
    resource_group_id: builtins.str,
    description: typing.Optional[builtins.str] = None,
    ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
    api_version: typing.Optional[builtins.str] = None,
    enable_migration_analysis: typing.Optional[builtins.bool] = None,
    enable_transformation: typing.Optional[builtins.bool] = None,
    enable_validation: typing.Optional[builtins.bool] = None,
    location: typing.Optional[builtins.str] = None,
    monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b2dbd2f0ea8f96d693783239370c653f9407aaa9c591353523e04530ba84178d(
    id: builtins.str,
    *,
    applies_to_groups: typing.Sequence[typing.Union[_ConnectivityGroupItem_d310024f, typing.Dict[builtins.str, typing.Any]]],
    connectivity_topology: builtins.str,
    delete_existing_peering: typing.Optional[builtins.bool] = None,
    description: typing.Optional[builtins.str] = None,
    hubs: typing.Optional[typing.Sequence[typing.Union[_Hub_d4efdd65, typing.Dict[builtins.str, typing.Any]]]] = None,
    ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
    is_global: typing.Optional[builtins.bool] = None,
    api_version: typing.Optional[builtins.str] = None,
    enable_migration_analysis: typing.Optional[builtins.bool] = None,
    enable_transformation: typing.Optional[builtins.bool] = None,
    enable_validation: typing.Optional[builtins.bool] = None,
    location: typing.Optional[builtins.str] = None,
    monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d1203a22194ded8d2fdfe8e202959021a3bde120919b2b23796e1192036c03dc(
    id: builtins.str,
    *,
    address_prefixes: typing.Sequence[builtins.str],
    description: typing.Optional[builtins.str] = None,
    display_name: typing.Optional[builtins.str] = None,
    ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
    parent_pool_name: typing.Optional[builtins.str] = None,
    api_version: typing.Optional[builtins.str] = None,
    enable_migration_analysis: typing.Optional[builtins.bool] = None,
    enable_transformation: typing.Optional[builtins.bool] = None,
    enable_validation: typing.Optional[builtins.bool] = None,
    location: typing.Optional[builtins.str] = None,
    monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__311b887b043ab3d879d74bfda16f8be6a5afdaca3a49491e2bc393c69911e3d4(
    id: builtins.str,
    *,
    description: typing.Optional[builtins.str] = None,
    ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
    member_type: typing.Optional[builtins.str] = None,
    api_version: typing.Optional[builtins.str] = None,
    enable_migration_analysis: typing.Optional[builtins.bool] = None,
    enable_transformation: typing.Optional[builtins.bool] = None,
    enable_validation: typing.Optional[builtins.bool] = None,
    location: typing.Optional[builtins.str] = None,
    monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3af2440d27eee80b5c885fe00ff72c39a6e5a5e2bb41d6e5cdf46171bca2ce67(
    id: builtins.str,
    *,
    apply_on_network_intent_policy_based_services: typing.Optional[typing.Sequence[builtins.str]] = None,
    description: typing.Optional[builtins.str] = None,
    ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
    api_version: typing.Optional[builtins.str] = None,
    enable_migration_analysis: typing.Optional[builtins.bool] = None,
    enable_transformation: typing.Optional[builtins.bool] = None,
    enable_validation: typing.Optional[builtins.bool] = None,
    location: typing.Optional[builtins.str] = None,
    monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a85b00ea36b7f25b9818e7e324d8e9b4c5aa8badd6af23b87129291530ae8270(
    key: builtins.str,
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e08e7b0c89c834597ee14679b42cd7be97b7bcd6d4ccb572433c1eea4627d4f2(
    props: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3a1a4771cadf53bf74fb5ac3db83098c75a6f6ff577db1429b929cf7929439cc(
    key: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fb275e43bfa6cb8c8754f434d469dd426b8ce726f77255158eff86befe1f7abf(
    props: typing.Any,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4b1ba156da58fc8b9f62cf1bad1d0db3b882a851182430686f984c3bc847bcd7(
    *,
    location: builtins.str,
    properties: typing.Union[_VirtualNetworkManagerProperties_794596ca, typing.Dict[builtins.str, typing.Any]],
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__60f1db564cff206b47ae8d15d4a252e57bf5ec28249a6c285fa23d43583aa9d4(
    *,
    network_manager_scope_accesses: typing.Sequence[builtins.str],
    network_manager_scopes: typing.Union[_NetworkManagerScopes_d6035bf8, typing.Dict[builtins.str, typing.Any]],
    description: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0c725a99058fc34090e08f93cef59d39f3374bde6d93e47948bf27de0a9e48b3(
    *,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    api_version: typing.Optional[builtins.str] = None,
    enable_migration_analysis: typing.Optional[builtins.bool] = None,
    enable_transformation: typing.Optional[builtins.bool] = None,
    enable_validation: typing.Optional[builtins.bool] = None,
    location: typing.Optional[builtins.str] = None,
    monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    network_manager_scope_accesses: typing.Sequence[builtins.str],
    network_manager_scopes: typing.Union[_NetworkManagerScopes_d6035bf8, typing.Dict[builtins.str, typing.Any]],
    resource_group_id: builtins.str,
    description: typing.Optional[builtins.str] = None,
    ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__47b4bee89d3466ecb3ba5b134cdc1701929fee3244064fd6c51a382020912c47(
    *,
    connection: typing.Optional[typing.Union[typing.Union[_cdktf_9a9027ec.SSHProvisionerConnection, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.WinrmProvisionerConnection, typing.Dict[builtins.str, typing.Any]]]] = None,
    count: typing.Optional[typing.Union[jsii.Number, _cdktf_9a9027ec.TerraformCount]] = None,
    depends_on: typing.Optional[typing.Sequence[_cdktf_9a9027ec.ITerraformDependable]] = None,
    for_each: typing.Optional[_cdktf_9a9027ec.ITerraformIterator] = None,
    lifecycle: typing.Optional[typing.Union[_cdktf_9a9027ec.TerraformResourceLifecycle, typing.Dict[builtins.str, typing.Any]]] = None,
    provider: typing.Optional[_cdktf_9a9027ec.TerraformProvider] = None,
    provisioners: typing.Optional[typing.Sequence[typing.Union[typing.Union[_cdktf_9a9027ec.FileProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.LocalExecProvisioner, typing.Dict[builtins.str, typing.Any]], typing.Union[_cdktf_9a9027ec.RemoteExecProvisioner, typing.Dict[builtins.str, typing.Any]]]]] = None,
    api_version: typing.Optional[builtins.str] = None,
    enable_migration_analysis: typing.Optional[builtins.bool] = None,
    enable_transformation: typing.Optional[builtins.bool] = None,
    enable_validation: typing.Optional[builtins.bool] = None,
    location: typing.Optional[builtins.str] = None,
    monitoring: typing.Optional[typing.Union[_MonitoringConfig_7c28df74, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    address_space: typing.Union[_VirtualNetworkAddressSpace_f881cca1, typing.Dict[builtins.str, typing.Any]],
    dhcp_options: typing.Optional[typing.Union[_VirtualNetworkDhcpOptions_da8e9a61, typing.Dict[builtins.str, typing.Any]]] = None,
    enable_ddos_protection: typing.Optional[builtins.bool] = None,
    enable_vm_protection: typing.Optional[builtins.bool] = None,
    encryption: typing.Any = None,
    flow_timeout_in_minutes: typing.Optional[jsii.Number] = None,
    ignore_changes: typing.Optional[typing.Sequence[builtins.str]] = None,
    resource_group_id: typing.Optional[builtins.str] = None,
    subnets: typing.Optional[typing.Sequence[typing.Any]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fc72bce98f07bf10b6c56496009c3cdf4120eca8491ca041ae9d4f03c878fcff(
    *,
    id: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7726a6c16f96b8c5fad078d3b265d336b0e28e2fef80453d3e4c1c04f3cf70cc(
    *,
    cpu_alert_severity: typing.Optional[jsii.Number] = None,
    cpu_threshold: typing.Optional[jsii.Number] = None,
    disk_queue_alert_severity: typing.Optional[jsii.Number] = None,
    disk_queue_threshold: typing.Optional[jsii.Number] = None,
    enable_cpu_alert: typing.Optional[builtins.bool] = None,
    enable_deletion_alert: typing.Optional[builtins.bool] = None,
    enable_disk_queue_alert: typing.Optional[builtins.bool] = None,
    enable_memory_alert: typing.Optional[builtins.bool] = None,
    memory_alert_severity: typing.Optional[jsii.Number] = None,
    memory_threshold: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2f15ee8b05608c5fcad984f3743a20c61d24b20140a8916a614b8bf880f1719a(
    *,
    country_code: builtins.str,
    name: builtins.str,
    phone_number: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5ea098047aa5f75bc1e4c4420abf31d69f0692c53311f6f9c04829df4ed3ab5a(
    *,
    name: builtins.str,
    service_uri: builtins.str,
    use_common_alert_schema: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

for cls in [IPConfiguration, IPConfigurationProperties, IPConfigurationSubnet]:
    typing.cast(typing.Any, cls).__protocol_attrs__ = typing.cast(typing.Any, cls).__protocol_attrs__ - set(['__jsii_proxy_class__', '__jsii_type__'])
