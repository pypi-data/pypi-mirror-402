"""
Building blocks for all schemas

All objects for the schema description of function signatures are here
represented as Pydantic BaseModel classes.
"""
import warnings
from enum import Enum
from typing import Any, Annotated, Type, Mapping

from pydantic import ConfigDict, BaseModel, constr, Field, model_validator

from pydantic.json_schema import (
    GenerateJsonSchema, DEFAULT_REF_TEMPLATE, JsonSchemaMode, JsonSchemaValue, CoreSchema
)


# Custom JSON schema generators to create schemas with '$schema' identifier
# -> copied from: https://github.com/pydantic/pydantic/blob/73373c3e08fe5fe23e4b05f549ea34e0da6a16b7/tests/test_json_schema.py#L3090-L3116

class GenerateJsonSchemaWithDialect(GenerateJsonSchema):
    def generate(self, schema: CoreSchema, mode: JsonSchemaMode = 'validation') -> JsonSchemaValue:
        json_schema = super().generate(schema)
        json_schema['$schema'] = self.schema_dialect
        return json_schema


class BaseModelWithSchema(BaseModel):
    @classmethod
    def model_json_schema(
            cls,
            by_alias: bool = True,
            ref_template: str = DEFAULT_REF_TEMPLATE,
            schema_generator: Type[GenerateJsonSchema] = GenerateJsonSchemaWithDialect,
            mode: JsonSchemaMode = 'validation'
    ) -> dict[str, Any]:
        return super().model_json_schema(by_alias, ref_template, schema_generator, mode)


# Models defining the structure of the "manifest" generated by the "signature" command
class DataslotModel(BaseModel):
    """Description of a single DataSlot"""
    name: str
    title: str
    description: str
    mediatype: str
    metadata: dict
    min_slots: Annotated[int, Field(ge=0, strict=True, serialization_alias='minSlots')]
    max_slots: Annotated[int | None, Field(ge=1, strict=True, serialization_alias='maxSlots')]


class FunctionModel(BaseModel):
    """Structure of a Step-function manifest"""
    version: Annotated[str, Field(min_length=0, max_length=40)]
    function_name: Annotated[str, Field(min_length=1, max_length=100)]
    short_description: str
    long_description: str
    parameters: Any = None  # 'DynamicParameters' actually, but embedded at runtime as schema
    returns: Any = None  # 'DynamicReturns' actually, but embedded at runtime as schema
    input_dataslots: list[DataslotModel]
    output_dataslots: list[DataslotModel]
    procon_version: str


class DynamicParameters(BaseModelWithSchema):
    """Basis for a dynamically created model of the functions parameters."""
    model_config = ConfigDict(
        arbitrary_types_allowed=True,
        extra="forbid",
        strict=True,
    )

    @model_validator(mode="before")
    @classmethod
    def _convert_enums(cls, values: Mapping[str, Any]) -> Mapping[str, Any]:
        values = dict(values)  # Ensure mutable dict
        for field_name, model_field in cls.model_fields.items():
            field_type = model_field.annotation
            if isinstance(field_type, type) and issubclass(field_type, Enum):
                value = values.get(field_name)
                if isinstance(value, str):
                    try:
                        values[field_name] = field_type(value)
                    except ValueError:
                        warnings.warn(
                            f"Failed to convert '{value}' to '{field_type.__name__}' for field '{field_name}'."
                        )
        return values




class DynamicReturns(BaseModelWithSchema):
    """Basis for a dynamically created model of the functions return value."""
    model_config = ConfigDict(
        arbitrary_types_allowed=True,
        extra="ignore",
        strict=True,
    )
