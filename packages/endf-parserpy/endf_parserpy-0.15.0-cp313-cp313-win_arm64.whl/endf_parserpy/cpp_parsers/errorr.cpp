// File generated by endf_parserpy.compiler.endf2cpp.py::generate_cpp_module_code
// MD5 hash of file content below this line: 39044f014a487def1e5da94c9b2e1267
#define PYTHON_COMPILE
#ifndef CPP_ENDF_FLOAT_HPP
#define CPP_ENDF_FLOAT_HPP


#include <pybind11/pybind11.h>
#include <iostream>
#include <string>


namespace py = pybind11;


#define DOUBLE_TYPE EndfFloatCpp


// This class must be in sync with the
// Python class EndfFloat class in endf_parserpy.utils.math_utils

class EndfFloatCpp {
public:
    EndfFloatCpp()
        : _value(0.0), _orig_str("") {}

    EndfFloatCpp(double value)
        : _value(value), _orig_str("") {}

    EndfFloatCpp(double value, const std::string& orig_str)
        : _value(value), _orig_str(orig_str) {}

    EndfFloatCpp(const EndfFloatCpp& other)
        : _value(other._value), _orig_str(other._orig_str) {}

    std::string get_original_string() const {
        return _orig_str; }
    bool operator==(const EndfFloatCpp& other) const {
        return static_cast<double>(_value) == static_cast<double>(other._value);
    }

    bool operator!=(const EndfFloatCpp& other) const {
        return static_cast<double>(_value) != static_cast<double>(other._value);
    }

    bool operator<(const EndfFloatCpp& other) const {
        return static_cast<double>(_value) < static_cast<double>(other._value);
    }


    template<typename T>
    bool operator==(T other) const {
        return static_cast<double>(_value) == static_cast<double>(other);
    }

    template<typename T>
    bool operator!=(T other) const {
        return static_cast<double>(_value) != static_cast<double>(other);
    }

    template<typename T>
    bool operator<(T other) const {
        return static_cast<double>(_value) < static_cast<double>(other);
    }

    friend std::ostream& operator<<(std::ostream& os, const EndfFloatCpp& obj) {
        os << static_cast<double>(obj);
        return os;
    }

    operator double() const {
        return _value;
    }

    operator int() const {
        return static_cast<int>(_value);
    }

private:
    double _value;
    std::string _orig_str;
};


namespace PYBIND11_NAMESPACE { namespace detail {

    // Establish conversion between Python float and EndfFloatCpp
    template <> struct type_caster<EndfFloatCpp> {
    public:
        PYBIND11_TYPE_CASTER(EndfFloatCpp, const_name("EndfFloatCpp"));

        bool load(handle src, bool) {
            static py::object PyEndfFloat = (
                py::module::import("endf_parserpy.utils.math_utils").attr("EndfFloat")
            );
            // case 1: cast Python float to EndfFloatCpp
            if (py::isinstance<py::float_>(src)) {
                py::float_ tmp = py::cast<py::float_>(src);
                double float_value = tmp.cast<double>();
                value = EndfFloatCpp(float_value);
                return !(float_value == -1 && PyErr_Occurred());
            }

            // case 2: cast Python int to EndfFloatCpp
            else if (py::isinstance<py::int_>(src)) {
                py::int_ tmp = py::cast<py::int_>(src);
                double int_value = tmp.cast<double>() ;
                value = EndfFloatCpp(int_value);
                return true;
            }

            // case 3: cast Python float to EndfFloatCpp
            else if (py::isinstance(src, PyEndfFloat)) {
				auto float_method = src.attr("__float__");
				double float_value = float_method().cast<double>();
				std::string orig_str = src.attr("get_original_string")().cast<std::string>();
				value = EndfFloatCpp(float_value, orig_str);
                return true;
            }
            return false;
        }

        static handle cast(const EndfFloatCpp& src, return_value_policy, handle) {
            static py::object PyEndfFloat = (
                py::module::import("endf_parserpy.utils.math_utils").attr("EndfFloat")
            );
            double float_value = static_cast<double>(src);
            std::string orig_str = src.get_original_string();
            if (orig_str.empty()) {
                return py::float_(static_cast<double>(src)).release();
            } else {
                py::object endf_float = PyEndfFloat(
                   py::float_(float_value), py::str(orig_str)
                );
                return endf_float.release();
            }
        }
    };


}} // namespace PYBIND11_NAMESPACE::detail


#endif // CPP_ENDF_FLOAT_HPP
#ifndef INDEX_SHIFTER_HPP
#define INDEX_SHIFTER_HPP


#include <pybind11/pybind11.h>
#include <pybind11/stl.h>
#include <map>
#include <string>


namespace py = pybind11;


class IndexShifter {

private:
    int start_index;
    bool accessed;
    bool list_mode;
    std::vector<IndexShifter> next_level;

    IndexShifter& get_next_level(int idx) {
        if (idx == next_level.size()) {
            next_level.push_back(IndexShifter(list_mode));
        }
        return next_level[idx];
    }

    bool key_exists(py::list obj, int key) {
        return key < obj.size();
    }

    bool key_exists(py::dict obj, int key) {
        return obj.contains(py::cast(key));
    }

    void insert_obj(py::list pyobj, int key, py::object elem) {
        if (key == pyobj.size()) {
            pyobj.append(elem);
        } else {
            pyobj[key] = elem;
        }
    }

    void insert_obj(py::dict pyobj, int key, py::object elem) {
        pyobj[py::cast(key)] = elem;
    }

    template <typename V>
    py::object setdefault_i(
        V pyobj, const std::vector<int>& recipe_indices, py::object defval, int i
    ) {
        int py_index_value = recipe_indices[i];
        if (!accessed) {
            accessed = true;
            start_index = py_index_value;
        }
        int index_value = py_index_value - start_index;
        if (list_mode) {
            py_index_value = index_value;
            if (py_index_value < 0) {
                throw std::out_of_range("list index out of range");
            }
        }
        if (i+1 < recipe_indices.size()) {
            auto& next_level = get_next_level(index_value);
            if (! defval.is_none() & ! key_exists(pyobj, py_index_value)) {
                insert_obj(pyobj, py_index_value, V());
            }
            return next_level.setdefault_i(
                py::cast<V>(pyobj[py::cast(py_index_value)]), recipe_indices, defval, i+1
            );
        } else {
            if (! defval.is_none() & ! key_exists(pyobj, py_index_value)) {
                insert_obj(pyobj, py_index_value, defval);
            }
            return pyobj[py::cast(py_index_value)];
        }
    }

public:
    IndexShifter()
        : start_index(0), accessed(false), list_mode(false) {}

    IndexShifter(bool list_mode)
        : start_index(0), accessed(false), list_mode(list_mode) {}

    IndexShifter(const IndexShifter &other)
        : start_index(other.start_index), accessed(other.accessed),
          list_mode(other.list_mode), next_level(other.next_level) {}

    IndexShifter& operator=(const IndexShifter& other) {
        if (this != &other) {
            start_index = other.start_index;
            accessed = other.accessed;
            list_mode = other.list_mode;
            next_level = other.next_level;
        }
        return *this;
    }

    py::object setdefault(py::object pyobj, const std::vector<int> recipe_indices, py::object defval) {
        if (list_mode) {
            return setdefault_i(pyobj.cast<py::list>(), recipe_indices, defval, 0);
        } else {
            return setdefault_i(pyobj.cast<py::dict>(), recipe_indices, defval, 0);
        }
    }

    py::object get_value(py::object pyobj, const std::vector<int> recipe_indices) {
        return setdefault(pyobj, recipe_indices, py::none());
    }

};


class IndexShifterStore {

private:
    using IndexShifterMap = std::map<std::string, IndexShifter>;

    bool list_mode;
    py::dict refdict;
    IndexShifterMap index_shifter_map;

public:
    IndexShifterStore()
        : list_mode(false) {}

    IndexShifterStore(py::dict refdict, bool list_mode)
        : refdict(refdict), list_mode(list_mode) {}

    IndexShifterStore(const IndexShifterStore &other)
        : list_mode(other.list_mode), refdict(other.refdict),
          index_shifter_map(other.index_shifter_map) {}

    IndexShifterStore& operator=(const IndexShifterStore &other) {
        if (this != &other) {
            list_mode = other.list_mode;
            refdict = other.refdict;
            index_shifter_map = other.index_shifter_map;
        }
        return *this;
    }

    py::object setdefault(std::string varname, std::vector<int> indices, py::object defval) {
        if (!defval.is_none() && !refdict.contains(varname)) {
            if (indices.empty()) {
                refdict[py::cast(varname)] = defval;
                return defval;
            } else if (list_mode) {
                refdict[py::cast(varname)] = py::list();
            } else {
                refdict[py::cast(varname)] = py::dict();
            }
        }
        auto pyobj = refdict[py::cast(varname)];
        if (indices.empty()) {
            return pyobj;
        }
        IndexShifterMap::iterator it = index_shifter_map.find(varname);
        if (it == index_shifter_map.end()) {
            index_shifter_map[varname] = IndexShifter(list_mode);
        }
        auto &index_shifter = index_shifter_map[varname];
        return index_shifter.setdefault(pyobj, indices, defval);
    }

    py::object get_value(std::string varname, std::vector<int> indices, py::object defval=py::none()) {
        if (! defval.is_none() & ! refdict.contains(varname)) {
            return defval;
        }
        return setdefault(varname, indices, py::none());
    }

};


#endif // INDEX_SHIFTER_HPP
#ifndef MODULE_HEADER_HPP
#define MODULE_HEADER_HPP


#include <pybind11/pybind11.h>
#include <pybind11/stl.h> // Necessary for STL containers like std::map

#include <stdexcept>
#include <iostream>
#include <sstream>
#include <fstream>
#include <iomanip>
#include <vector>
#include <string>
#include <cassert>
#include <algorithm>  // for std::sort
#include <cstddef>

// When Python merges the various
// C++ files, there is no need
// to include them here
#ifndef PYTHON_COMPILE
#include "endf_float_cpp.hpp"
#include "index_shifter.hpp"
#endif

namespace py = pybind11;


#ifndef DOUBLE_TYPE
#define DOUBLE_TYPE double
#endif


struct Tab1Body {
  std::vector<int> INT;
  std::vector<int> NBT;
  std::vector<DOUBLE_TYPE> X;
  std::vector<DOUBLE_TYPE> Y;
};


struct Tab2Body {
  std::vector<int> INT;
  std::vector<int> NBT;
};


bool seq_contains(py::sequence seq, py::object value) {
  int i = 0;
  for (const auto& item : seq) {
    if (py::cast<py::object>(item).equal(value)) {
      return true;
    }
  }
  return false;
}


bool should_parse_section(int mf, int mt, py::object& exclude, py::object& include) {
  py::tuple mf_mt_tup = py::make_tuple(mf, mt);
  if (! exclude.is_none()) {
    if (! py::isinstance<py::sequence>(exclude)) {
      throw std::runtime_error("`exclude` argument must be of sequence type");
    }
    if (seq_contains(exclude, py::int_(mf)) || seq_contains(exclude, mf_mt_tup)) {
      return false;
    } else {
      return true;
    }
  } else if (! include.is_none()) {
    if (! py::isinstance<py::sequence>(include)) {
      throw std::runtime_error("`include` argument must be of sequence type");
    }
    if (seq_contains(include, py::int_(mf)) || seq_contains(include, mf_mt_tup)) {
      return true;
    } else {
      return false;
    }
  } else {
    return true;
  }
}

#endif // MODULE_HEADER_HPP
#ifndef MODULE_HEADER_READING_HPP
#define MODULE_HEADER_READING_HPP

// When Python merges the various
// C++ files, there is no need
// to include them here
#ifndef PYTHON_COMPILE
#include "module_header.hpp"
#endif

#ifndef DOUBLE_TYPE
#define DOUBLE_TYPE double
#endif


struct ParsingOptions {
  bool ignore_number_mismatch;
  bool ignore_zero_mismatch;
  bool ignore_varspec_mismatch;
  bool accept_spaces;
  bool ignore_blank_lines;
  bool ignore_send_records;
  bool ignore_missing_tpid;
  bool preserve_value_strings;
  bool validate_control_records;
  std::string array_type;
};


ParsingOptions default_parsing_options() {
  return ParsingOptions{
    false,  // ignore_number_mismatch
    true,  // ignore_zero_mismatch
    true,  // ignore_varspec_mismatch
    true,  // accept_spaces
    false,  // ignore_blank_lines
    false,  // ignore_send_records
    false,  // ignore_missing_tpid
    false,  // preserve_value_strings
    false,  // validate_control_records
    "dict"  // array_type
  };
}


namespace pybind11 { namespace detail {
  template <> struct type_caster<ParsingOptions> {
  public:
    PYBIND11_TYPE_CASTER(ParsingOptions, _("ParsingOptions"));

    // conversion from Python to C++
    bool load(handle src, bool) {
      if (!py::isinstance<py::dict>(src))
        return false;
      auto d = reinterpret_borrow<py::dict>(src);
      py::object keys = d.attr("keys")();
      for (auto key : keys) {
        std::string key_str = py::str(key);
        if (key_str == "ignore_number_mismatch")
          value.ignore_number_mismatch = d["ignore_number_mismatch"].cast<bool>();
        else if (key_str == "ignore_zero_mismatch")
          value.ignore_zero_mismatch = d["ignore_zero_mismatch"].cast<bool>();
        else if (key_str == "ignore_varspec_mismatch")
          value.ignore_varspec_mismatch = d["ignore_varspec_mismatch"].cast<bool>();
        else if (key_str == "accept_spaces")
          value.accept_spaces = d["accept_spaces"].cast<bool>();
        else if (key_str == "ignore_blank_lines")
          value.ignore_blank_lines = d["ignore_blank_lines"].cast<bool>();
        else if (key_str == "ignore_send_records")
          value.ignore_send_records = d["ignore_send_records"].cast<bool>();
        else if (key_str == "ignore_missing_tpid")
          value.ignore_missing_tpid = d["ignore_missing_tpid"].cast<bool>();
        else if (key_str == "preserve_value_strings")
          value.preserve_value_strings = d["preserve_value_strings"].cast<bool>();
        else if (key_str == "validate_control_records")
          value.validate_control_records = d["validate_control_records"].cast<bool>();
        else if (key_str == "array_type")
          value.array_type = d["array_type"].cast<std::string>();
        else
          throw std::runtime_error("unknown option `" + key_str + "` provided");
      }

      // use default values for missing options
      ParsingOptions default_opts = default_parsing_options();

      if (! d.contains("ignore_number_mismatch")) {
        value.ignore_number_mismatch = default_opts.ignore_number_mismatch;
      }

      if (! d.contains("ignore_zero_mismatch")) {
        value.ignore_zero_mismatch = default_opts.ignore_zero_mismatch;
      }

      if (! d.contains("ignore_varspec_mismatch")) {
        value.ignore_varspec_mismatch = default_opts.ignore_varspec_mismatch;
      }

      if (! d.contains("accept_spaces")) {
        value.accept_spaces = default_opts.accept_spaces;
      }

      if (! d.contains("ignore_blank_lines")) {
        value.ignore_blank_lines = default_opts.ignore_blank_lines;
      }

      if (! d.contains("ignore_send_records")) {
        value.ignore_send_records = default_opts.ignore_send_records;
      }

      if (! d.contains("ignore_missing_tpid")) {
        value.ignore_missing_tpid = default_opts.ignore_missing_tpid;
      }

      if (! d.contains("preserve_value_strings")) {
        value.preserve_value_strings = default_opts.preserve_value_strings;
      }

      if (! d.contains("validate_control_records")) {
        value.validate_control_records = default_opts.validate_control_records;
      }

      if (! d.contains("array_type")) {
        value.array_type = default_opts.array_type;
      }

      return true;
    }

    // conversion from C++ to Python
    static handle cast(const ParsingOptions &src, return_value_policy, handle) {
      py::dict d;
      d["ignore_number_mismatch"] = src.ignore_number_mismatch;
      d["ignore_zero_mismatch"] = src.ignore_zero_mismatch;
      d["ignore_varspec_mismatch"] = src.ignore_varspec_mismatch;
      d["accept_spaces"] = src.accept_spaces;
      d["ignore_blank_lines"] = src.ignore_blank_lines;
      d["ignore_send_records"] = src.ignore_send_records;
      d["ignore_missing_tpid"] = src.ignore_missing_tpid;
      d["preserve_value_strings"] = src.preserve_value_strings;
      d["validate_control_records"] = src.validate_control_records;
      d["array_type"] = src.array_type;
      return d.release();
    }

  };
}}


py::object py_create_container(bool list_mode) {
    if (list_mode) {
        return py::list();
    } else {
        return py::dict();
    }
}


py::object py_append_container(py::object pyobj, int key, bool list_mode, py::object elem=py::none()) {
    if (list_mode) {
        if (elem.is_none()) {
            elem = py::list();
        }
        py::list list = pyobj;
        list.append(elem);
        return elem;
    } else {
        if (elem.is_none()) {
            elem = py::dict();
        }
        return pyobj.attr("setdefault")(py::cast(key), elem);
    }
}


template<typename U, typename V, typename W>
void throw_mismatch_error(
  U quantity, V expected_value, W actual_value,
  std::string line, std::string template_line
) {
  std::stringstream errmsg;
  errmsg << "Invalid " << quantity << " encountered! "
         << "Expected " << quantity << "=" << expected_value
         << " but found " << quantity <<"=" << actual_value << std::endl;
  if (template_line.size() > 0) {
    errmsg << "Template: " << template_line << std::endl;
  }
  if (line.size() > 0) {
    errmsg << "Line: " << line << std::endl;
  }
  throw std::runtime_error(errmsg.str());
}


template<typename V, typename W>
void throw_number_mismatch_error(
  V expected_value, W actual_value,
  std::string line, std::string template_line
) {
  std::stringstream errmsg;
  errmsg << "Expected a field to contain the value " << expected_value
         << " but found instead the value " << actual_value << "." << std::endl;
  if (template_line.size() > 0) {
    errmsg << "Template: " << template_line << std::endl;
  }
  if (line.size() > 0) {
    errmsg << "Line: " << line << std::endl;
  }
  throw std::runtime_error(errmsg.str());
}


double endfstr2float(const char* str, ParsingOptions &parse_opts) {
  char tbuf[13];
  int j = 0;
  bool in_number = false;
  bool in_exponent = false;
  int last_nonspace_pos=-1;
  for (int i=10; i >= 0; i--) {
    if (str[i] != ' ') {
      last_nonspace_pos = i;
      break;
    }
  }
  if (last_nonspace_pos == -1) {
    return 0.0;
  }
  for (int i=0; i <= last_nonspace_pos; i++) {
    char c = str[i];
    if (c == ' ') {
      if (parse_opts.accept_spaces || ! in_number) {
        continue;
      } else {
        std::stringstream errmsg;
        errmsg << "encontered number with spaces: \""
               << std::string(str, 11) << "\"" << std::endl;
        throw std::runtime_error(errmsg.str());
      }
    }
    if (in_number) {
      if (!in_exponent) {
        if (c=='+' || c=='-') {
          tbuf[j++] = 'e';
          in_exponent = true;
        } else if (c=='e' || c=='E') {
          in_exponent = true;
        }
      }
    } else {
      if (c == '.' || (c >= '0' && c <= '9') || c == '-' || c == '+') {
        in_number = true;
      }
    }
    tbuf[j++] = c;
  }
  if (j==0) tbuf[j++] = '0';
  tbuf[j++] = '\0';
  return std::stod(tbuf);
}


int endfstr2int(const char* str, ParsingOptions &parse_opts) {
  char strzero[12];
  std::memcpy(strzero, str, 11);
  strzero[11] = '\0';
  for (int i=0; i < 11; i++) {
    if (str[i] != ' ') {
      return std::atoi(strzero);
    }
  }
  return 0;
}

// case for EndfFloatCpp
EndfFloatCpp cpp_read_field_EndfFloatCpp(
  const char *str, const char fieldnum, ParsingOptions &parse_opts
) {
  double float_value = endfstr2float(str+fieldnum*11, parse_opts);
  if (parse_opts.preserve_value_strings) {
    std::string orig_str(str+fieldnum*11, 11);
    return EndfFloatCpp(float_value, orig_str);
  } else {
    return EndfFloatCpp(float_value);
  }
}


template<typename T>
T cpp_read_field(const char *str, const char fieldnum, ParsingOptions &parse_opts) {
  static_assert(
    std::is_same<T, EndfFloatCpp>::value
    || std::is_same<T, int>::value
    || std::is_same<T, double>::value
    , "T must be int or double"
  );
  if (std::is_same<T, double>::value) {
    return endfstr2float(str+fieldnum*11, parse_opts);
  } if (std::is_same<T, EndfFloatCpp>::value) {
    return cpp_read_field_EndfFloatCpp(str, fieldnum, parse_opts);
  } else {
    return endfstr2int(str+fieldnum*11, parse_opts);
  }
}


// the next couple of functions are for handling
// are auxiliary functions to amek cpp_validate_field
// for different types (in particular std::vector and std::string)

template<typename T>
typename std::enable_if<std::is_scalar<T>::value, bool>::type
is_zero_check(const T value) {
  return value == 0;
}


template<typename T>
typename std::enable_if<! std::is_scalar<T>::value, bool>::type
is_zero_check(const T value) {
  return false;
}


template<typename U, typename V>
typename std::enable_if<
  (!std::is_scalar<U>::value && !std::is_same<U, DOUBLE_TYPE>::value)
  || (!std::is_scalar<V>::value && !std::is_same<V, DOUBLE_TYPE>::value), void
>::type
cpp_validate_field(
  U expected_value,
  V actual_value,
  bool contains_variable,
  bool contains_desired_number,
  bool contains_inconsistent_varspec,
  std::string exprstr,
  std::string &line_template,
  std::string &line,
  ParsingOptions &parse_opts
) {
  std::stringstream errmsg;
  errmsg << "Both the expected and actual value are vectors --- "
         << "not implemented at the moment" << std::endl;
  throw std::runtime_error(errmsg.str());
}


template<typename U, typename V>
typename std::enable_if<
  (std::is_scalar<U>::value || std::is_same<U, DOUBLE_TYPE>::value)
   && (std::is_scalar<V>::value || std::is_same<V, DOUBLE_TYPE>::value), void
>::type
cpp_validate_field(
  U expected_value,
  V actual_value,
  bool contains_variable,
  bool contains_desired_number,
  bool contains_inconsistent_varspec,
  std::string exprstr,
  std::string &line_template,
  std::string &line,
  ParsingOptions &parse_opts
) {
  if (static_cast<double>(expected_value) == static_cast<double>(actual_value)) return;

  // inconsistency detected
  if (! contains_variable) {
    // dealing with a number
    // ignore zero mismatch only active for scalar data types
    if (is_zero_check(expected_value) && parse_opts.ignore_zero_mismatch) return;
    if (contains_desired_number && parse_opts.ignore_number_mismatch) return;
    throw_number_mismatch_error(expected_value, actual_value, line, line_template);
  } else {
    // dealing with an expression with variables
    if (contains_inconsistent_varspec && parse_opts.ignore_varspec_mismatch) return;
    throw_mismatch_error(exprstr, expected_value, actual_value, line, line_template);
  }
}

// we are done with the cpp_validate_field related functionality

int cpp_read_custom_int_field(const char *str, int start_pos, int length) {
  std::vector<char> strzero(length+1);
  std::memcpy(strzero.data(), str+start_pos, length);
  strzero[length] = '\0';
  for (int i=0; i < length; i++) {
    if (strzero[i] != ' ') {
      return std::atoi(strzero.data());
    }
  }
  return 0;
}


int cpp_read_mat_number(const char *str) {
  return cpp_read_custom_int_field(str, 66, 4);
}


int cpp_read_mf_number(const char *str) {
  return cpp_read_custom_int_field(str, 70, 2);
}


int cpp_read_mt_number(const char *str) {
  return cpp_read_custom_int_field(str, 72, 3);
}


bool cpp_is_blank_line(std::string line) {
  for (int i=0; i < line.size(); i++) {
    if (line[i] != ' ') return false;
  }
  return true;
}


std::string cpp_read_raw_line(std::istream& cont) {
  std::string line;
  std::getline(cont, line);
  return line;
}


std::string cpp_read_line(
  std::istream& cont, int mat, int mf, int mt, ParsingOptions &parse_opts
) {
  std::string line;
  std::getline(cont, line);
  if (parse_opts.ignore_blank_lines) {
    cpp_is_blank_line(line);
    while (cpp_is_blank_line(line) && std::getline(cont, line)) {
      // skip blank lines
    }
  }
  if (cpp_is_blank_line(line)) {
    throw std::runtime_error(
      "Blank line detected: Correct file or use `ignore_blank_lines` option"
    );
  }

  if (parse_opts.validate_control_records) {
    int curmat = cpp_read_mat_number(line.c_str());
    int curmf = cpp_read_mf_number(line.c_str());
    int curmt = cpp_read_mt_number(line.c_str());
    if (curmat != mat)
      throw_mismatch_error("MAT", mat, curmat, line, "");
    if (curmf != mf)
      throw_mismatch_error("MF", mf, curmf, line, "");
    if (curmt != mt)
      throw_mismatch_error("MT", mt, curmt, line, "");
  }
  return line;
}


std::string cpp_read_send(std::istream& cont, int mat, int mf, ParsingOptions &parse_opts) {
  std::string line = cpp_read_line(cont, mat, mf, 0, parse_opts);
  int mtnum = cpp_read_mt_number(line.c_str());
  if (cpp_read_field<DOUBLE_TYPE>(line.c_str(), 0, parse_opts) != 0.0 ||
    cpp_read_field<DOUBLE_TYPE>(line.c_str(), 1, parse_opts) != 0.0 ||
    cpp_read_field<int>(line.c_str(), 2, parse_opts) != 0 ||
    cpp_read_field<int>(line.c_str(), 3, parse_opts) != 0 ||
    cpp_read_field<int>(line.c_str(), 4, parse_opts) != 0 ||
    cpp_read_field<int>(line.c_str(), 5, parse_opts) != 0 ||
    mtnum != 0) {

    std::stringstream errmsg;
    errmsg << "Expected SEND record does not contain one!" << std::endl
           << "Line: " << line << std::endl;
    throw std::runtime_error(errmsg.str());
  }
  if (parse_opts.validate_control_records) {
    int curmat = cpp_read_mat_number(line.c_str());
    int curmf = cpp_read_mf_number(line.c_str());
    if (curmat != mat)
      throw_mismatch_error("MAT", mat, curmat, line, "");
    if (curmf != mf)
      throw_mismatch_error("MF", mf, curmf, line, "");
  }
  return line;
}


bool cpp_is_fend_record(std::string line, int mat, ParsingOptions &parse_opts) {
  int curmat = cpp_read_mat_number(line.c_str());
  if (mat != curmat && parse_opts.validate_control_records) {
      throw_mismatch_error("MAT", mat, curmat, line, "");
  }
  int mf = cpp_read_mf_number(line.c_str());
  int mt = cpp_read_mt_number(line.c_str());
  double c1 = cpp_read_field<DOUBLE_TYPE>(line.c_str(), 0, parse_opts);
  double c2 = cpp_read_field<DOUBLE_TYPE>(line.c_str(), 1, parse_opts);
  int n1 = cpp_read_field<int>(line.c_str(), 2, parse_opts);
  int n2 = cpp_read_field<int>(line.c_str(), 3, parse_opts);
  int l1 = cpp_read_field<int>(line.c_str(), 4, parse_opts);
  int l2 = cpp_read_field<int>(line.c_str(), 5, parse_opts);
  bool cond = (c1 == 0.0 && c2 == 0.0 && n1 == 0 && n2 == 0);
  cond &= (l1 == 0 && l2 == 0 && mf == 0 && mt == 0);
  return cond;
}


bool cpp_is_mend_record(std::string line, ParsingOptions &parse_opts) {
  int mat = cpp_read_mat_number(line.c_str());
  bool cond = cpp_is_fend_record(line, 0, parse_opts);
  cond &= (mat == 0);
  return cond;
}


bool cpp_is_tend_record(std::string line, ParsingOptions &parse_opts) {
  int mat = cpp_read_mat_number(line.c_str());
  bool cond = cpp_is_fend_record(line, -1, parse_opts);
  cond &= (mat == -1);
  return cond;
}


template<typename T>
std::vector<T> cpp_read_vec(
  std::istream& cont, const int numel, int mat, int mf, int mt, ParsingOptions &parse_opts
) {
  int j = 0;
  std::vector<T> res;
  std::string line = cpp_read_line(cont, mat, mf, mt, parse_opts);
  for (int i=0; i < numel; i++) {
    res.push_back(cpp_read_field<T>(line.c_str(), j++, parse_opts));
    if (j > 5 && i+1 < numel) {
      line = cpp_read_line(cont, mat, mf, mt, parse_opts);
      j = 0;
    }
  }
  return res;
}


template<typename T>
std::vector<T> cpp_read_vec_debug(
  std::istream& cont, std::string& line, const int numel, int mat, int mf, int mt, ParsingOptions &parse_opts
) {
  int j = 0;
  std::vector<T> res;
  std::ostringstream oss;
  std::string curline = cpp_read_line(cont, mat, mf, mt, parse_opts);
  for (int i=0; i < numel; i++) {
    res.push_back(cpp_read_field<T>(curline.c_str(), j++, parse_opts));
    if (j > 5 && i+1 < numel) {
      oss << curline << std::endl;
      curline = cpp_read_line(cont, mat, mf, mt, parse_opts);
      j = 0;
    }
  }
  oss << curline << std::endl;
  line = oss.str();
  return res;
}


Tab2Body read_tab2_body_debug(
  std::istream& cont, std::string& line, int nr, int mat, int mf, int mt, ParsingOptions &parse_opts
) {
  std::ostringstream oss;
  std::string tmpline;
  Tab2Body tab_body;
  std::vector<int> interp = cpp_read_vec_debug<int>(cont, tmpline, 2*nr, mat, mf, mt, parse_opts);
  oss << tmpline;
  int j = 0;
  for (int i=0; i < nr; i++) {
    tab_body.NBT.push_back(interp[j++]);
    tab_body.INT.push_back(interp[j++]);
  }
  line = oss.str();
  return tab_body;
}


Tab2Body read_tab2_body(
  std::istream& cont, int nr, int mat, int mf, int mt, ParsingOptions &parse_opts
) {
  Tab2Body tab_body;
  std::vector<int> interp = cpp_read_vec<int>(cont, 2*nr, mat, mf, mt, parse_opts);
  int j = 0;
  for (int i=0; i < nr; i++) {
    tab_body.NBT.push_back(interp[j++]);
    tab_body.INT.push_back(interp[j++]);
  }
  return tab_body;
}


Tab1Body read_tab1_body_debug(
  std::istream& cont, std::string& line, int nr, int np,
  int mat, int mf, int mt, ParsingOptions &parse_opts
) {
  std::ostringstream oss;
  std::string tmpline;
  Tab1Body tab_body;
  std::vector<int> interp = cpp_read_vec_debug<int>(cont, tmpline, 2*nr, mat, mf, mt, parse_opts);
  oss << tmpline;
  int j = 0;
  for (int i=0; i < nr; i++) {
    tab_body.NBT.push_back(interp[j++]);
    tab_body.INT.push_back(interp[j++]);
  }
  std::vector<DOUBLE_TYPE> data = cpp_read_vec_debug<DOUBLE_TYPE>(cont, tmpline, 2*np, mat, mf, mt, parse_opts);
  oss << tmpline;
  j = 0;
  for (int i=0; i < np; i++) {
    tab_body.X.push_back(data[j++]);
    tab_body.Y.push_back(data[j++]);
  }
  line = oss.str();
  return tab_body;
}


Tab1Body read_tab1_body(
  std::istream& cont, int nr, int np,
  int mat, int mf, int mt, ParsingOptions &parse_opts
) {
  Tab1Body tab_body;
  std::vector<int> interp = cpp_read_vec<int>(cont, 2*nr, mat, mf, mt, parse_opts);
  int j = 0;
  for (int i=0; i < nr; i++) {
    tab_body.NBT.push_back(interp[j++]);
    tab_body.INT.push_back(interp[j++]);
  }
  std::vector<DOUBLE_TYPE> data = cpp_read_vec<DOUBLE_TYPE>(cont, 2*np, mat, mf, mt, parse_opts);
  j = 0;
  for (int i=0; i < np; i++) {
    tab_body.X.push_back(data[j++]);
    tab_body.Y.push_back(data[j++]);
  }
  return tab_body;
}


std::vector<std::string> read_section_verbatim(
    int mat, int mf, int mt, std::istream& cont, bool is_first, ParsingOptions &parse_opts
) {
  std::streampos curpos;
  std::string line;
  std::vector<std::string> secvec;
  int curmf;
  int curmt;
  size_t lastpos;
  while (! cont.eof()) {
    line = cpp_read_line(cont, mat, mf, mt, parse_opts);
    // remove trailing \r that we may
    // get from reading win-style line endings
    lastpos = line.size() - 1;
    if (line[lastpos] == '\r') {
      line.erase(lastpos);
    }
    curmf = std::stoi(line.substr(70, 2));
    curmt = std::stoi(line.substr(72, 3));
    if (curmf != mf || curmt != mt) break;
    // the newline for compatibility with the Python parser
    secvec.push_back(line + "\n");
    curpos = cont.tellg();
  }
  if (! is_first && (curmf != mf || curmt != 0)) {
     std::string errmsg = "expected SEND of MF/MT " +
                          std::to_string(mf) + "/" + std::to_string(mt);
     throw std::runtime_error(errmsg);
  }
  if (is_first) {
    // we rewind one line because in the case of MF0/MT0 (tapeid)
    // we have also consumed the HEAD record of the next section
    cont.seekg(curpos);
  }
  return secvec;
}

#endif // MODULE_HEADER_READING_HPP
#ifndef MODULE_HEADER_WRITING_HPP
#define MODULE_HEADER_WRITING_HPP

// When Python merges the various
// C++ files, there is no need
// to include it here
#ifndef PYTHON_COMPILE
#include "module_header.hpp"
#endif

#ifndef DOUBLE_TYPE
#define DOUBLE_TYPE double
#endif


struct WritingOptions {
  bool abuse_signpos;
  bool keep_E;
  bool prefer_noexp;
  bool skip_intzero;
  bool preserve_value_strings;
  bool include_linenum;
  std::string array_type;
};


WritingOptions default_writing_options() {
  return WritingOptions{
    false,  // abuse_signpos
    false,  // keep_E
    false,  // prefer_noexp
    false,  // skip_intzero
    false,  // preserve_value_strings
    true,   // include_linenum
    "dict"  // array_type
  };
}


namespace pybind11 { namespace detail {
  template <> struct type_caster<WritingOptions> {
  public:
    PYBIND11_TYPE_CASTER(WritingOptions, _("WritingOptions"));

    // conversion from Python to C++
    bool load(handle src, bool) {
      if (!py::isinstance<py::dict>(src))
        return false;
      auto d = reinterpret_borrow<py::dict>(src);
      py::object keys = d.attr("keys")();
      for (auto key : keys) {
        std::string key_str = py::str(key);
        if (key_str == "abuse_signpos")
          value.abuse_signpos = d["abuse_signpos"].cast<bool>();
        else if (key_str == "keep_E")
          value.keep_E = d["keep_E"].cast<bool>();
        else if (key_str == "prefer_noexp")
          value.prefer_noexp = d["prefer_noexp"].cast<bool>();
        else if (key_str == "skip_intzero")
          value.skip_intzero = d["skip_intzero"].cast<bool>();
        else if (key_str == "include_linenum")
          value.include_linenum = d["include_linenum"].cast<bool>();
        else if (key_str == "preserve_value_strings")
          value.preserve_value_strings = d["preserve_value_strings"].cast<bool>();
        else if (key_str == "array_type")
          value.array_type = d["array_type"].cast<std::string>();
        else
          throw std::runtime_error("unknown option `" + key_str + "` provided");
      }

      // use default values for missing options
      WritingOptions default_opts = default_writing_options();

      if (! d.contains("abuse_signpos")) {
        value.abuse_signpos = default_opts.abuse_signpos;
      }
      if (! d.contains("keep_E")) {
        value.keep_E = default_opts.keep_E;
      }
      if (! d.contains("prefer_noexp")) {
        value.prefer_noexp = default_opts.prefer_noexp;
      }
      if (! d.contains("skip_intzero")) {
        value.skip_intzero = default_opts.skip_intzero;
      }
      if (! d.contains("preserve_value_strings")) {
        value.preserve_value_strings = default_opts.preserve_value_strings;
      }
      if (! d.contains("include_linenum")) {
        value.include_linenum = default_opts.include_linenum;
      }
      if (! d.contains("array_type")) {
        value.array_type = default_opts.array_type;
      }
      return true;
    }

    // conversion from C++ to Python
    static handle cast(const WritingOptions &src, return_value_policy, handle) {
      py::dict d;
      d["abuse_signpos"] = src.abuse_signpos;
      d["keep_E"] = src.keep_E;
      d["prefer_noexp"] = src.prefer_noexp;
      d["skip_intzero"] = src.skip_intzero;
      d["preserve_value_strings"] = src.preserve_value_strings;
      d["include_linenum"] = src.include_linenum;
      d["array_type"] = src.array_type;
      return d.release();
    }

  };
}}


void cpp_write_custom_int_field(std::string &str, int start, int length, int value) {
  std::ostringstream oss;
  oss << std::right << std::setw(length) << value;
  str.replace(start, length, oss.str());
}


void cpp_write_mat_number(std::string& str, int value) {
  cpp_write_custom_int_field(str, 66, 4, value);
}


void cpp_write_mf_number(std::string& str, int value) {
  cpp_write_custom_int_field(str, 70, 2, value);
}


void cpp_write_mt_number(std::string& str, int value) {
  cpp_write_custom_int_field(str, 72, 3, value);
}


void cpp_write_line_number(std::string& str, int value) {
  cpp_write_custom_int_field(str, 75, 5, value);
}


std::string cpp_prepare_line(
  int mat, int mf, int mt, int &linenum, WritingOptions &write_opts
) {
  int line_width = (write_opts.include_linenum) ? 80 : 75;
  std::string line(line_width, ' ');
  line += '\n';
  cpp_write_mat_number(line, mat);
  cpp_write_mf_number(line, mf);
  cpp_write_mt_number(line, mt);
  if (write_opts.include_linenum) {
    cpp_write_line_number(line, (linenum % 99999)+1);
  }
  linenum++;
  return line;
}


void normalize_exponent(std::string& numstr) {
  size_t strsize = numstr.size();
  size_t zerostart = std::string::npos;
  size_t exp_pos = numstr.find("e");
  if (exp_pos == std::string::npos) {
    throw std::runtime_error("`e` character not found");
  }
  size_t expnum_start = exp_pos+2;
  for (int i=expnum_start; i < strsize; i++) {
    if (numstr[i] != '0') {
      numstr.erase(expnum_start, i-expnum_start);
      return;
    } else if (i+1 == strsize) {
      numstr.erase(expnum_start, i-expnum_start);
      return;
    }
  }
}


std::string get_scientific_numstr(double value, int precision, bool abuse_signpos) {
  std::ostringstream oss;
  oss << std::scientific << std::setprecision(precision) << value;
  std::string numstr = oss.str();
  normalize_exponent(numstr);
  if (! abuse_signpos && value >= 0) {
    numstr.insert(0, " ");
  }
  return numstr;
}


std::string float2endfstr_helper(double value, size_t width, WritingOptions &write_opts)
{
  std::string numstr = get_scientific_numstr(value, 6, write_opts.abuse_signpos);
  // re-calculate precision to match width specification
  size_t prec = 6 - (numstr.size() - width);
  numstr = get_scientific_numstr(value, prec, write_opts.abuse_signpos);
  // in rare cases, we may still be off the desired width due to
  // situations like 9.9999e-10 vs 1.000e-9
  if (numstr.size() < width) {
    std::string old_numstr;
    do {
      old_numstr = numstr;
      numstr = get_scientific_numstr(value, ++prec, write_opts.abuse_signpos);
    } while (numstr.size() <= width);
    numstr = old_numstr;
    if (numstr.size() < width) {
      numstr.insert(0, " ");
    }
  } else if (numstr.size() > width) {
    do {
      numstr = get_scientific_numstr(value, --prec, write_opts.abuse_signpos);
    } while (numstr.size() > width);
  }
  return numstr;
}


std::string float2endfstr_decimal_helper(
  double value, int width, WritingOptions &write_opts
) {
  std::stringstream ss;
  std::string numstr;
  int commapos;
  ss << std::fixed << std::setprecision(16) << value;
  numstr = ss.str();
  commapos = numstr.find('.');
  if (commapos == std::string::npos) {
    throw std::runtime_error("error occured while converting float to string");
  }
  bool is_intzero_case = (
    write_opts.skip_intzero && static_cast<int>(value) == 0
  );
  int prec = width - commapos - 1;
  if (value >= 0 && ! write_opts.abuse_signpos) {
    prec--;
  }
  if (is_intzero_case) {
    prec++;
  }
  if (prec < 0) {
    prec = 0;
  }
  std::stringstream ss2;
  ss2 << std::fixed << std::setprecision(prec) << value;
  // strip insignificant trailing zeros for compatibility with Python output
  std::string sout = ss2.str();
  commapos = numstr.find('.');
  if (commapos != std::string::npos) {
    int last_nonzero_pos = sout.substr(commapos).find_last_not_of('0');
    sout.erase(commapos + last_nonzero_pos + 1);
    if (sout.back() == '.') {
      sout.pop_back();
    } else if (is_intzero_case) {
      // strip unnecessary integer zero
      if (numstr[commapos-1] != '0') {
        throw std::runtime_error("integer zero matching failed");
      }
      sout.erase(commapos-1, 1);
    }
  }
  if (! write_opts.abuse_signpos && value >= 0) {
    sout.insert(0, " ");
  }
  // right-adjust the number
  std::ostringstream oss3;
  oss3 << std::right << std::setw(width) << sout;
  return oss3.str();
}


std::string float2endfstr(double value, WritingOptions &write_opts) {
  std::ostringstream oss;
  std::string numstr;
  int width = 11;
  int effwidth = width;
  if (! write_opts.keep_E) {
      effwidth++;
  }
  numstr = float2endfstr_helper(
    value, effwidth, write_opts
  );
  if (write_opts.prefer_noexp) {
    std::string numstr_noexp = float2endfstr_decimal_helper(
      value, width, write_opts
    );
    if (numstr_noexp.size() <= width) {
      double recon_value = std::stod(numstr);
      double recon_value_noexp = std::stod(numstr_noexp);
      double recon_value_diff = std::abs(recon_value - value);
      double recon_value_reldiff = recon_value_diff / (std::abs(value)+1e-12);
      double recon_value_noexp_diff = std::abs(recon_value_noexp - value);
      double recon_value_noexp_reldiff =  recon_value_noexp_diff / (std::abs(value)+1e-12);
      if (recon_value_reldiff >= recon_value_noexp_reldiff) {
          return numstr_noexp;
      }
    }
  }
  // delete exp character if demanded
  if (! write_opts.keep_E) {
    size_t exp_pos = numstr.find('e');
    numstr.erase(exp_pos, 1);
  }
  return numstr;
}


std::string int2endfstr(int value) {
  std::ostringstream oss;
  oss << std::right << std::setw(11) << value;
  return oss.str();
}


void field_size_check(const std::string& field) {
  if (field.size() != 11) {
    throw std::runtime_error(
      std::string("wrong size")
      + std::to_string(field.size())
      + std::string("  ") + field
    );
  }
}


// value is float case
void cpp_write_field_double(
  std::string& line, const char fieldnum, const double& value,
  WritingOptions& write_opts
) {
  std::string fieldstr = float2endfstr(value, write_opts);
  field_size_check(fieldstr);
  line.replace(fieldnum*11, 11, fieldstr);
}


// value is EndfFloatCpp case
void cpp_write_field_EndfFloatCpp(
  std::string& line, const char fieldnum, const EndfFloatCpp& value,
  WritingOptions& write_opts
) {
  std::string fieldstr;
  std::string orig_str = value.get_original_string();
  if (orig_str.empty() || !write_opts.preserve_value_strings) {
    fieldstr = float2endfstr(value, write_opts);
  } else {
    fieldstr = orig_str;
  }
  field_size_check(fieldstr);
  line.replace(fieldnum*11, 11, fieldstr);
}


// value is int case
void cpp_write_field_int(
  std::string& line, const char fieldnum, const int& value,
  WritingOptions& write_opts
) {
  std::string fieldstr = int2endfstr(value);
  line.replace(fieldnum*11, 11, fieldstr);
}


// templated cpp_write_field
template<typename T>
 void cpp_write_field(
  std::string& line, const char fieldnum, const T& value,
  WritingOptions& write_opts
) {
  static_assert(
    std::is_same<T, double>::value
    || std::is_same<T, EndfFloatCpp>::value
    || std::is_same<T, int>::value
    , "T must be int, double or EndfFloatCpp"
  );
  if (std::is_same<T, double>::value) {
    return cpp_write_field_double(line, fieldnum, value, write_opts);
  } else if (std::is_same<T, EndfFloatCpp>::value) {
    return cpp_write_field_EndfFloatCpp(line, fieldnum, value, write_opts);
  } else {
    return cpp_write_field_int(line, fieldnum, value, write_opts);
  }
}


void write_tab1_body(
  std::string& line, Tab1Body tab_body, int mat, int mf, int mt, int& linenum, WritingOptions &write_opts
) {
  assert(tab_body.INT.size() == tab_body.NBT.size() && "INT and NBT must have same size");
  assert(tab_body.X.size() == tab_body.Y.size() && "X and Y must have same size");
  int nr = tab_body.INT.size();
  int np = tab_body.X.size();
  std::ostringstream oss;
  std::string curline = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
  int j = 0;
  for (int i=0; i < nr; i++) {
    cpp_write_field(curline, j++, tab_body.NBT[i], write_opts);
    cpp_write_field(curline, j++, tab_body.INT[i], write_opts);
    if (j > 5 && i+1 < nr) {
      oss << curline;
      curline = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
      j = 0;
    }
  }
  oss << curline;

  j = 0;
  curline = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
  for (int i=0; i < np; i++) {
    cpp_write_field(curline, j++, tab_body.X[i], write_opts);
    cpp_write_field(curline, j++, tab_body.Y[i], write_opts);
    if (j > 5 && i+1 < np) {
      oss << curline;
      curline = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
      j = 0;
    }
  }
  oss << curline;
  line = oss.str();
}


void write_tab2_body(
  std::string& line, Tab2Body tab_body, int mat, int mf, int mt, int& linenum, WritingOptions &write_opts
) {
  assert(tab_body.INT.size() == tab_body.NBT.size() && "INT and NBT must have same size");
  int nr = tab_body.INT.size();
  std::ostringstream oss;
  std::string curline = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
  int j = 0;
  for (int i=0; i < nr; i++) {
    cpp_write_field(curline, j++, tab_body.NBT[i], write_opts);
    cpp_write_field(curline, j++, tab_body.INT[i], write_opts);
    if (j > 5 && i+1 < nr) {
      oss << curline;
      curline = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
      j = 0;
    }
  }
  oss << curline;
  line = oss.str();
}


std::string cpp_prepare_send(
  int mat, int mf, WritingOptions &write_opts, bool newline=true) {
  int line_width = (write_opts.include_linenum) ? 80 : 75;
  std::string line(line_width, ' ');
  if (newline) {
      line += '\n';
  }
  cpp_write_mat_number(line, mat);
  cpp_write_mf_number(line, mf);
  cpp_write_mt_number(line, 0);
  cpp_write_field<DOUBLE_TYPE>(line, 0, 0.0, write_opts);
  cpp_write_field<DOUBLE_TYPE>(line, 1, 0.0, write_opts);
  cpp_write_field<int>(line, 2, 0, write_opts);
  cpp_write_field<int>(line, 3, 0, write_opts);
  cpp_write_field<int>(line, 4, 0, write_opts);
  cpp_write_field<int>(line, 5, 0, write_opts);
  if (write_opts.include_linenum) {
    if (mf == 0) {
      // for writing FEND/MEND/TEND record
      cpp_write_line_number(line, 0);
    } else {
      cpp_write_line_number(line, 99999);
    }
  }
  return line;
}


int get_mat_from_mfmt_section(py::object mfmt_section) {
  int mat;
  if (py::isinstance<py::dict>(mfmt_section)) {
    py::dict mfmt_section_dict = py::cast<py::dict>(mfmt_section);
    mat = py::cast<int>(mfmt_section_dict["MAT"]);
    return mat;
  }
  if (! py::isinstance<py::list>(mfmt_section)) {
    throw std::runtime_error(
      "expect section to be represented by `list` or `dict`"
    );
  }
  py::list mfmt_section_list = py::cast<py::list>(mfmt_section);
  if (mfmt_section_list.size() == 0) {
    throw std::runtime_error("list representing section is empty");
  }
  std::string first_line = py::cast<std::string>(mfmt_section_list[0]);
  std::string matstr = first_line.substr(66, 4);
  mat = std::stoi(matstr);
  return mat;
}


void write_section_verbatim(
  std::ostream& oss, py::list mfmt_section, WritingOptions &write_opts
) {
  if (mfmt_section.size() == 0) {
    throw std::runtime_error("an MF/MT section must not be represented by an empty list");
  }
  std::string first_line = py::cast<std::string>(mfmt_section[0]);
  int mat = cpp_read_mat_number(first_line.c_str());
  int mf = cpp_read_mf_number(first_line.c_str());
  int mt = cpp_read_mt_number(first_line.c_str());
  int linenum = (mf != 0) ? 1 : 0;  // linenum starts at 0 for tape head
  for (const auto& item : mfmt_section) {
    std::string linestr = py::cast<std::string>(item);
    if (write_opts.include_linenum) {
      linestr.resize(80);
      cpp_write_line_number(linestr, linenum++);
    } else {
      linestr.erase(75, std::string::npos);
    }
    if (linestr.back() != '\n') {
      linestr.push_back('\n');
    }
    oss << linestr;
  }
  if (mf != 0) {
      std::string send_line = cpp_prepare_send(mat, mf, write_opts);
      oss << send_line;
  }
}

#endif // MODULE_HEADER_WRITING_HPP

enum vartype {
  MATRIX2D_DOUBLE,
  MATRIX2D_FLOATVEC,
  MATRIX2D_INT,
  MATRIX2D_INTVEC,
  MATRIX2D_STRING,
  NESTEDVECTOR_DOUBLE,
  NESTEDVECTOR_FLOATVEC,
  NESTEDVECTOR_INT,
  NESTEDVECTOR_INTVEC,
  NESTEDVECTOR_STRING,
  SCALAR_DOUBLE,
  SCALAR_FLOATVEC,
  SCALAR_INT,
  SCALAR_INTVEC,
  SCALAR_STRING,
  UNKNOWN
};

std::string vartype2str(vartype vt) {
    switch (vt) {
        case MATRIX2D_DOUBLE:  return "MATRIX2D_DOUBLE";
        case MATRIX2D_INT:  return "MATRIX2D_INT";
        case MATRIX2D_STRING:  return "MATRIX2D_STRING";
        case MATRIX2D_INTVEC:  return "MATRIX2D_INTVEC";
        case MATRIX2D_FLOATVEC:  return "MATRIX2D_FLOATVEC";
        case NESTEDVECTOR_DOUBLE:  return "NESTEDVECTOR_DOUBLE";
        case NESTEDVECTOR_INT:  return "NESTEDVECTOR_INT";
        case NESTEDVECTOR_STRING:  return "NESTEDVECTOR_STRING";
        case NESTEDVECTOR_INTVEC:  return "NESTEDVECTOR_INTVEC";
        case NESTEDVECTOR_FLOATVEC:  return "NESTEDVECTOR_FLOATVEC";
        case SCALAR_DOUBLE:  return "SCALAR_DOUBLE";
        case SCALAR_INT:  return "SCALAR_INT";
        case SCALAR_STRING:  return "SCALAR_STRING";
        case SCALAR_INTVEC:  return "SCALAR_INTVEC";
        case SCALAR_FLOATVEC:  return "SCALAR_FLOATVEC";
    }
    throw std::runtime_error("should not arrivere here");
    return "should not arrive here";
}


void validate_vartype_consistency(std::string varname, vartype current_type, vartype expected_type) {
  if (current_type != expected_type && expected_type != UNKNOWN) {
    std::string current_type_str = vartype2str(current_type);
    std::string expected_type_str = vartype2str(expected_type);
    std::stringstream errmsg;
    errmsg << "variable `" << varname << "` is now encountered "
          << "with type `" << current_type_str << "` but was "
          << "previously encountered with type `" << expected_type_str << ". "
          << "Either the ENDF recipe is wrongly specified or the ENDF file "
          << "contains some forbidden flag values." << std::endl;
    throw std::runtime_error(errmsg.str());
  }
}

template<typename T>
class Matrix2d {

  private:
    std::vector<T> data;
    size_t num_rows;
    size_t num_cols;
    size_t row_start;
    size_t col_start;
    bool initialized;
    bool accessed;
    bool triagonal;
    bool lower;

  public:

    Matrix2d() : initialized(false), accessed(false),
                 triagonal(false), lower(false) {};

    void init(size_t first_row_idx, size_t last_row_idx,
              size_t first_col_idx, size_t last_col_idx,
              bool triagonal=false, bool lower=false) {
      this->num_rows = last_row_idx - first_row_idx + 1;
      this->num_cols = last_col_idx - first_col_idx + 1;
      this->row_start = first_row_idx;
      this->col_start = first_col_idx;
      this->data.resize(this->num_rows * this->num_cols);
      this->initialized = true;
      this->triagonal = triagonal;
      this->lower = lower;
    }

    bool is_initialized() {
      return initialized;
    }

    bool did_read() {
      return accessed;
    }

    T& operator()(size_t i, size_t j) {
      accessed = true;
      return data.at((i-row_start)*num_cols + (j-col_start));
    }

    int get_row_start_index() const {
      return row_start;
    }

    int get_row_last_index() const {
      return row_start + num_rows - 1;
    }

    int get_col_start_index() const {
      return col_start;
    }

    int get_col_start_index(int i) const {
      if (! triagonal || lower) {
        return col_start;
      } else {
        return col_start + (i - row_start);
      }
    }

    int get_col_last_index() const {
      return col_start + num_cols - 1;
    }

    int get_col_last_index(int i) {
      if (! triagonal || ! lower) {
        return col_start + num_cols - 1;
      } else {
        return col_start + (i - row_start);
      }
    }

    py::object to_pyobj(bool list_mode) {
      if (list_mode) {
        py::list ret;
        int rsidx = get_row_start_index();
        int rfidx = get_row_last_index();
        for (int i=rsidx; i <= rfidx; ++i) {
          py::list row_list;
          int csidx = get_col_start_index(i);
          int cfidx = get_col_last_index(i);
          for (int j=csidx; j <= cfidx; ++j) {
            row_list.append(Matrix2d::operator()(i, j));
          }
          ret.append(row_list);
        }
        return ret;
      } else {
        py::dict ret;
        int rsidx = get_row_start_index();
        int rfidx = get_row_last_index();
        for (int i=rsidx; i <= rfidx; ++i) {
          py::dict row_dict;
          int csidx = get_col_start_index(i);
          int cfidx = get_col_last_index(i);
          for (int j=csidx; j <= cfidx; ++j) {
            row_dict[py::cast(j)] = Matrix2d::operator()(i, j);
          }
          ret[py::cast(i)] = row_dict;
        }
        return ret;
      }
    }
};

template<typename T>
class NestedVector : public std::vector<T> {
  private:
    int startIndex;
    int lastIndex;

  public:
    // default constructor
    NestedVector() : startIndex(0), lastIndex(-1) {}

    // copy constructor
    NestedVector(const NestedVector<T>& other) :
      std::vector<T>(other), startIndex(other.startIndex),
      lastIndex(other.lastIndex) {}

    // assignment constructor
    NestedVector<T>& operator=(const NestedVector<T>& other) {
      if (this != &other) {
        std::vector<T>::operator=(other);
        startIndex = other.startIndex;
        lastIndex = other.lastIndex;
      }
      return *this;
    }

    void set_start_index(int start) {
      this->startIndex = start;
    }

    int get_start_index() const {
      return this->startIndex;
    }

    void set_last_index(int lastIndex) {
      this->lastIndex = lastIndex;
    }

    int get_last_index() const {
      return this->lastIndex;
    }

    T& operator[](int index) {
      if (! contains(index)) {
        throw std::out_of_range("index out of range 1");
      }
      return std::vector<T>::operator[](index - startIndex);
    }

    T& at(int index) {
      return std::vector<T>::at(index - startIndex);
    }

    T* prepare(int index) {
      if (contains(index)) return &((*this)[index]);
      T cpp_curel;
      set(index, cpp_curel);
      return &(*this)[index];
    }

    void set(int index, const T& value) {
      bool is_first = false;
      if (this->lastIndex == -1) {
        this->startIndex = index;
        this->lastIndex = index;
        is_first = true;
      }
      if (index == startIndex + (int)this->size()) {
        std::vector<T>::push_back(value);
        if (! is_first) {
          this->lastIndex++;
        }
      } else if (index >= startIndex && index < startIndex + (int)this->size())  {
        std::vector<T>::operator[](index - startIndex) = value;
      } else {
        throw std::out_of_range("index out of range 2");
      }
    }

    bool contains(int index) {
      return (this->startIndex <= index && index <= this->lastIndex);
    }

    py::object to_pyobj(bool list_mode) {
      if (list_mode) {
        py::list ret;
        to_pylist(ret, (*this));
        return ret;
      } else {
        py::dict ret;
        to_pydict(ret, (*this));
        return ret;
      }
    }

    template <typename U>
    void to_pylist(py::list cur, const NestedVector<NestedVector<U>>& curvec) {
      for (const auto& elem : curvec) {
        py::list sublist;
        to_pylist(sublist, elem);
        cur.append(sublist);
      }
    }

    template <typename U>
    void to_pylist(py::list cur, const NestedVector<U>& curvec) {
      for (const auto& elem : curvec) {
          cur.append(py::cast(elem));
      }
    }

    template <typename U>
    void to_pydict(py::dict cur, const NestedVector<NestedVector<U>>& curvec) {
      int cnt = curvec.get_start_index();
      for (const auto& elem : curvec) {
        py::dict subdict;
        to_pydict(subdict, elem);
        cur[py::cast(cnt++)] = subdict;
      }
    }

    template <typename U>
    void to_pydict(py::dict cur, const NestedVector<U>& curvec) {
      int cnt = curvec.get_start_index();
      for (const auto& elem : curvec) {
        cur[py::cast(cnt++)] = py::cast(elem);
      }
    }

};


// MD5 hash of ENDF recipe underlying the following function: a38e6e76968fb4463ab67282d5c7f80d
// MD5 hash of the following function definition: 86632c4e57f453e615c07e60c802d408
py::dict parse_mf0mt0_istream(
  std::istream& cont, ParsingOptions &parse_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  bool list_mode = parse_opts.array_type != "dict";  py::dict cpp_parent_dict;
  py::dict cpp_current_dict;
  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  std::string var_TAPEDESCR_0d_string_Scalar;
  bool aux_TAPEDESCR_read = false;
  vartype aux_last_type_read_for_TAPEDESCR = UNKNOWN;
  std::streampos cpp_startpos = cont.tellg();
  std::string cpp_temp_line;
  cpp_temp_line = cpp_read_raw_line(cont);
  int mat = cpp_read_mat_number(cpp_temp_line.c_str());
  int mf = 0;
  int mt = 0;
  cont.seekg(cpp_startpos);
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = cpp_read_mat_number(cpp_temp_line.c_str());
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 0;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = 0;
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  // store variable MAT in endf dictionary
  cpp_current_dict[py::cast("MAT")] = var_MAT_0d_int_Scalar;
  // store variable MF in endf dictionary
  cpp_current_dict[py::cast("MF")] = var_MF_0d_int_Scalar;
  // store variable MT in endf dictionary
  cpp_current_dict[py::cast("MT")] = var_MT_0d_int_Scalar;
  std::string cpp_line;
  cpp_template = "[ MAT , 0 , 0 / TAPEDESCR ] TEXT";
  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
  // assign expression to variable TAPEDESCR
  var_TAPEDESCR_0d_string_Scalar = cpp_line.substr(0, 66);
  aux_TAPEDESCR_read = true;
  validate_vartype_consistency("TAPEDESCR", SCALAR_STRING, aux_last_type_read_for_TAPEDESCR);
  aux_last_type_read_for_TAPEDESCR = SCALAR_STRING;
  // store data in Python dictionary
  if (((aux_last_type_read_for_MAT == SCALAR_INT) && (aux_MAT_read == true))) {
    cpp_current_dict["MAT"] = var_MAT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MF == SCALAR_INT) && (aux_MF_read == true))) {
    cpp_current_dict["MF"] = var_MF_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MT == SCALAR_INT) && (aux_MT_read == true))) {
    cpp_current_dict["MT"] = var_MT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_TAPEDESCR == SCALAR_STRING) && (aux_TAPEDESCR_read == true))) {
    cpp_current_dict["TAPEDESCR"] = var_TAPEDESCR_0d_string_Scalar;
  }
  return cpp_current_dict;
}


// MD5 hash of ENDF recipe underlying the following function: 1aa496513dcfa0260b0a6404b7a0ea5a
// MD5 hash of the following function definition: ca116fe1edafa5bb7b45a0dfa1701b57
py::dict parse_mf1mt451_istream(
  std::istream& cont, ParsingOptions &parse_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  bool list_mode = parse_opts.array_type != "dict";  py::dict cpp_parent_dict;
  py::dict cpp_current_dict;
  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  EndfFloatCpp var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  EndfFloatCpp var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_IVER_0d_int_Scalar;
  bool aux_IVER_read = false;
  vartype aux_last_type_read_for_IVER = UNKNOWN;
  int var_IRELCO_0d_int_Scalar;
  bool aux_IRELCO_read = false;
  vartype aux_last_type_read_for_IRELCO = UNKNOWN;
  EndfFloatCpp var_TEMPIN_0d_double_Scalar;
  bool aux_TEMPIN_read = false;
  vartype aux_last_type_read_for_TEMPIN = UNKNOWN;
  int var_NG_0d_int_Scalar;
  bool aux_NG_read = false;
  vartype aux_last_type_read_for_NG = UNKNOWN;
  int cpp_int_val;
  bool aux_cpp_int_val_read = false;
  vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
  NestedVector<EndfFloatCpp> var_EG_1d_double_NestedVector;
  vartype aux_last_type_read_for_EG = UNKNOWN;
  std::streampos cpp_startpos = cont.tellg();
  std::string cpp_temp_line;
  cpp_temp_line = cpp_read_raw_line(cont);
  int mat = cpp_read_mat_number(cpp_temp_line.c_str());
  int mf = 1;
  int mt = 451;
  cont.seekg(cpp_startpos);
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = cpp_read_mat_number(cpp_temp_line.c_str());
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 1;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = 451;
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  // store variable MAT in endf dictionary
  cpp_current_dict[py::cast("MAT")] = var_MAT_0d_int_Scalar;
  // store variable MF in endf dictionary
  cpp_current_dict[py::cast("MF")] = var_MF_0d_int_Scalar;
  // store variable MT in endf dictionary
  cpp_current_dict[py::cast("MT")] = var_MT_0d_int_Scalar;
  std::string cpp_line;
  cpp_template = "[ MAT , 1 , MT / ZA , AWR , IVER , IRELCO , (-11) , 0 ] CONT";
  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
  // read CONT record
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  // assign expression to variable IVER
  var_IVER_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
  aux_IVER_read = true;
  validate_vartype_consistency("IVER", SCALAR_INT, aux_last_type_read_for_IVER);
  aux_last_type_read_for_IVER = SCALAR_INT;
  // assign expression to variable IRELCO
  var_IRELCO_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
  aux_IRELCO_read = true;
  validate_vartype_consistency("IRELCO", SCALAR_INT, aux_last_type_read_for_IRELCO);
  aux_last_type_read_for_IRELCO = SCALAR_INT;
  cpp_validate_field((-11), cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "(-11)",
    cpp_template, cpp_line, parse_opts);
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  cpp_template = "[ MAT , 1 , MT / TEMPIN , 0.0 , NG , 0 , (NG+1) , 0 / { EG } { i = 1 to (NG+1) } ] LIST";
  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
  // read LIST record
  // assign expression to variable TEMPIN
  var_TEMPIN_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
  aux_TEMPIN_read = true;
  validate_vartype_consistency("TEMPIN", SCALAR_DOUBLE, aux_last_type_read_for_TEMPIN);
  aux_last_type_read_for_TEMPIN = SCALAR_DOUBLE;
  cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
    cpp_template, cpp_line, parse_opts);
  // assign expression to variable NG
  var_NG_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
  aux_NG_read = true;
  validate_vartype_consistency("NG", SCALAR_INT, aux_last_type_read_for_NG);
  aux_last_type_read_for_NG = SCALAR_INT;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  if ((! (aux_NG_read == true))) {
    // assign expression to variable cpp_int_val
    cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
    aux_cpp_int_val_read = true;
    validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
    aux_last_type_read_for_cpp_int_val = SCALAR_INT;
    // assign expression to variable NG
    var_NG_0d_int_Scalar = static_cast<int>(std::round((cpp_int_val+(-1))));
    aux_NG_read = true;
    validate_vartype_consistency("NG", SCALAR_INT, aux_last_type_read_for_NG);
    aux_last_type_read_for_NG = SCALAR_INT;
  } else {
    cpp_validate_field((var_NG_0d_int_Scalar+1), cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  true, false, false, "(NG+1)",
      cpp_template, cpp_line, parse_opts);
  }
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  {
    int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
    int cpp_i = 0;
    int cpp_j = 0;
    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
    // read LIST body

    for (int var_i_0d_int_Scalar = 1;
       var_i_0d_int_Scalar <= (var_NG_0d_int_Scalar+1); var_i_0d_int_Scalar++) {
      bool aux_i_read = true;
      // read LIST body
      // assign expression to variable EG
      var_EG_1d_double_NestedVector.set(var_i_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
      validate_vartype_consistency("EG", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_EG);
      aux_last_type_read_for_EG = NESTEDVECTOR_DOUBLE;
      cpp_i++;
      cpp_j++;
      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
        cpp_j = 0;
      }
    }
    if (cpp_i != cpp_npl) {
      throw std::runtime_error("not exactly NPL elements consumed");
    }
  }
  cpp_read_send(cont, mat, mf, parse_opts);
  // store data in Python dictionary
  if (((aux_last_type_read_for_MAT == SCALAR_INT) && (aux_MAT_read == true))) {
    cpp_current_dict["MAT"] = var_MAT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MF == SCALAR_INT) && (aux_MF_read == true))) {
    cpp_current_dict["MF"] = var_MF_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MT == SCALAR_INT) && (aux_MT_read == true))) {
    cpp_current_dict["MT"] = var_MT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_ZA == SCALAR_DOUBLE) && (aux_ZA_read == true))) {
    cpp_current_dict["ZA"] = var_ZA_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_AWR == SCALAR_DOUBLE) && (aux_AWR_read == true))) {
    cpp_current_dict["AWR"] = var_AWR_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_IVER == SCALAR_INT) && (aux_IVER_read == true))) {
    cpp_current_dict["IVER"] = var_IVER_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_IRELCO == SCALAR_INT) && (aux_IRELCO_read == true))) {
    cpp_current_dict["IRELCO"] = var_IRELCO_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_TEMPIN == SCALAR_DOUBLE) && (aux_TEMPIN_read == true))) {
    cpp_current_dict["TEMPIN"] = var_TEMPIN_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_NG == SCALAR_INT) && (aux_NG_read == true))) {
    cpp_current_dict["NG"] = var_NG_0d_int_Scalar;
  }
  if ((var_EG_1d_double_NestedVector.get_last_index() != -1)) {
    cpp_current_dict["EG"] = var_EG_1d_double_NestedVector.to_pyobj(list_mode);
  }
  return cpp_current_dict;
}


// MD5 hash of ENDF recipe underlying the following function: 7f60f82614e2c4adcb5481133b02f23e
// MD5 hash of the following function definition: 8802c5f3d627d37b59425c4d29b3d671
py::dict parse_mf3_istream(
  std::istream& cont, ParsingOptions &parse_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  bool list_mode = parse_opts.array_type != "dict";  py::dict cpp_parent_dict;
  py::dict cpp_current_dict;
  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  EndfFloatCpp var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  int var_NG_0d_int_Scalar;
  bool aux_NG_read = false;
  vartype aux_last_type_read_for_NG = UNKNOWN;
  NestedVector<EndfFloatCpp> var_SIG_1d_double_NestedVector;
  vartype aux_last_type_read_for_SIG = UNKNOWN;
  std::streampos cpp_startpos = cont.tellg();
  std::string cpp_temp_line;
  cpp_temp_line = cpp_read_raw_line(cont);
  int mat = cpp_read_mat_number(cpp_temp_line.c_str());
  int mf = 3;
  int mt = cpp_read_mt_number(cpp_temp_line.c_str());
  cont.seekg(cpp_startpos);
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = cpp_read_mat_number(cpp_temp_line.c_str());
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 3;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = cpp_read_mt_number(cpp_temp_line.c_str());
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  // store variable MAT in endf dictionary
  cpp_current_dict[py::cast("MAT")] = var_MAT_0d_int_Scalar;
  // store variable MF in endf dictionary
  cpp_current_dict[py::cast("MF")] = var_MF_0d_int_Scalar;
  // store variable MT in endf dictionary
  cpp_current_dict[py::cast("MT")] = var_MT_0d_int_Scalar;
  std::string cpp_line;
  cpp_template = "[ MAT , 3 , MT / ZA , 0.0 , 0 , 0 , NG , 0 / \n { SIG } { i = 1 to NG } ] LIST";
  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
  // read LIST record
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, true, false, "0.0",
    cpp_template, cpp_line, parse_opts);
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  // assign expression to variable NG
  var_NG_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
  aux_NG_read = true;
  validate_vartype_consistency("NG", SCALAR_INT, aux_last_type_read_for_NG);
  aux_last_type_read_for_NG = SCALAR_INT;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  {
    int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
    int cpp_i = 0;
    int cpp_j = 0;
    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
    // read LIST body

    for (int var_i_0d_int_Scalar = 1;
       var_i_0d_int_Scalar <= var_NG_0d_int_Scalar; var_i_0d_int_Scalar++) {
      bool aux_i_read = true;
      // read LIST body
      // assign expression to variable SIG
      var_SIG_1d_double_NestedVector.set(var_i_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
      validate_vartype_consistency("SIG", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_SIG);
      aux_last_type_read_for_SIG = NESTEDVECTOR_DOUBLE;
      cpp_i++;
      cpp_j++;
      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
        cpp_j = 0;
      }
    }
    if (cpp_i != cpp_npl) {
      throw std::runtime_error("not exactly NPL elements consumed");
    }
  }
  cpp_read_send(cont, mat, mf, parse_opts);
  // store data in Python dictionary
  if (((aux_last_type_read_for_MAT == SCALAR_INT) && (aux_MAT_read == true))) {
    cpp_current_dict["MAT"] = var_MAT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MF == SCALAR_INT) && (aux_MF_read == true))) {
    cpp_current_dict["MF"] = var_MF_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MT == SCALAR_INT) && (aux_MT_read == true))) {
    cpp_current_dict["MT"] = var_MT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_ZA == SCALAR_DOUBLE) && (aux_ZA_read == true))) {
    cpp_current_dict["ZA"] = var_ZA_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_NG == SCALAR_INT) && (aux_NG_read == true))) {
    cpp_current_dict["NG"] = var_NG_0d_int_Scalar;
  }
  if ((var_SIG_1d_double_NestedVector.get_last_index() != -1)) {
    cpp_current_dict["SIG"] = var_SIG_1d_double_NestedVector.to_pyobj(list_mode);
  }
  return cpp_current_dict;
}


// MD5 hash of ENDF recipe underlying the following function: fd7b6b53d7fe662e9cfa0b44f31f58f9
// MD5 hash of the following function definition: 412ecc51c312f40293c7d461b88a3f78
py::dict parse_mf33_istream(
  std::istream& cont, ParsingOptions &parse_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  bool list_mode = parse_opts.array_type != "dict";  py::dict cpp_parent_dict;
  py::dict cpp_current_dict;
  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  EndfFloatCpp var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  EndfFloatCpp var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_MTL_0d_int_Scalar;
  bool aux_MTL_read = false;
  vartype aux_last_type_read_for_MTL = UNKNOWN;
  int var_NK_0d_int_Scalar;
  bool aux_NK_read = false;
  vartype aux_last_type_read_for_NK = UNKNOWN;
  std::streampos cpp_startpos = cont.tellg();
  std::string cpp_temp_line;
  cpp_temp_line = cpp_read_raw_line(cont);
  int mat = cpp_read_mat_number(cpp_temp_line.c_str());
  int mf = 33;
  int mt = cpp_read_mt_number(cpp_temp_line.c_str());
  cont.seekg(cpp_startpos);
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = cpp_read_mat_number(cpp_temp_line.c_str());
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 33;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = cpp_read_mt_number(cpp_temp_line.c_str());
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  // store variable MAT in endf dictionary
  cpp_current_dict[py::cast("MAT")] = var_MAT_0d_int_Scalar;
  // store variable MF in endf dictionary
  cpp_current_dict[py::cast("MF")] = var_MF_0d_int_Scalar;
  // store variable MT in endf dictionary
  cpp_current_dict[py::cast("MT")] = var_MT_0d_int_Scalar;
  std::string cpp_line;
  cpp_template = "[ MAT , 33 , MT / ZA , AWR , 0 , MTL , 0 , NK ] CONT";
  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
  // read CONT record
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  // assign expression to variable MTL
  var_MTL_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
  aux_MTL_read = true;
  validate_vartype_consistency("MTL", SCALAR_INT, aux_last_type_read_for_MTL);
  aux_last_type_read_for_MTL = SCALAR_INT;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  // assign expression to variable NK
  var_NK_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
  aux_NK_read = true;
  validate_vartype_consistency("NK", SCALAR_INT, aux_last_type_read_for_NK);
  aux_last_type_read_for_NK = SCALAR_INT;

  for (int var_k_0d_int_Scalar = 1;
     var_k_0d_int_Scalar <= var_NK_0d_int_Scalar; var_k_0d_int_Scalar++) {
    bool aux_k_read = true;
    // open section subsection
    {
      py::dict cpp_parent_dict = cpp_current_dict;
      cpp_current_dict = cpp_index_shifter_store.setdefault("subsection", std::vector<int>({var_k_0d_int_Scalar}), py::dict());
      IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
      // variable declarations
      int var_MAT1_0d_int_Scalar;
      bool aux_MAT1_read = false;
      vartype aux_last_type_read_for_MAT1 = UNKNOWN;
      int var_MT1_0d_int_Scalar;
      bool aux_MT1_read = false;
      vartype aux_last_type_read_for_MT1 = UNKNOWN;
      int var_NG_0d_int_Scalar;
      bool aux_NG_read = false;
      vartype aux_last_type_read_for_NG = UNKNOWN;
      NestedVector<int> var_NG1_1d_int_NestedVector;
      vartype aux_last_type_read_for_NG1 = UNKNOWN;
      NestedVector<int> var_IG1_1d_int_NestedVector;
      vartype aux_last_type_read_for_IG1 = UNKNOWN;
      NestedVector<int> var_IG_1d_int_NestedVector;
      vartype aux_last_type_read_for_IG = UNKNOWN;
      NestedVector<NestedVector<EndfFloatCpp>> var_COV_2d_double_NestedVector;
      NestedVector<EndfFloatCpp>* ptr_COV_2d_idx0;
      vartype aux_last_type_read_for_COV = UNKNOWN;
      cpp_template = "[ MAT , 33 , MT / 0.0 , 0.0 , MAT1 , MT1 , 0 , NG ] CONT";
      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
      // read CONT record
      cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
        cpp_template, cpp_line, parse_opts);
      cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
        cpp_template, cpp_line, parse_opts);
      // assign expression to variable MAT1
      var_MAT1_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
      aux_MAT1_read = true;
      validate_vartype_consistency("MAT1", SCALAR_INT, aux_last_type_read_for_MAT1);
      aux_last_type_read_for_MAT1 = SCALAR_INT;
      // assign expression to variable MT1
      var_MT1_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
      aux_MT1_read = true;
      validate_vartype_consistency("MT1", SCALAR_INT, aux_last_type_read_for_MT1);
      aux_last_type_read_for_MT1 = SCALAR_INT;
      cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "0",
        cpp_template, cpp_line, parse_opts);
      // assign expression to variable NG
      var_NG_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
      aux_NG_read = true;
      validate_vartype_consistency("NG", SCALAR_INT, aux_last_type_read_for_NG);
      aux_last_type_read_for_NG = SCALAR_INT;

      for (int var_i_0d_int_Scalar = 1;; var_i_0d_int_Scalar++) {
        bool aux_i_read = true;
        cpp_template = "[ MAT , 33 , MT / 0.0 , 0.0 , NG1 , IG1 , NG1 , IG / \n { COV } { j = 1 to NG1 } ] LIST";
        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
        // read LIST record
        cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
          cpp_template, cpp_line, parse_opts);
        cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
          cpp_template, cpp_line, parse_opts);
        // assign expression to variable NG1
        var_NG1_1d_int_NestedVector.set(var_i_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts));
        validate_vartype_consistency("NG1", NESTEDVECTOR_INT, aux_last_type_read_for_NG1);
        aux_last_type_read_for_NG1 = NESTEDVECTOR_INT;
        // assign expression to variable IG1
        var_IG1_1d_int_NestedVector.set(var_i_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts));
        validate_vartype_consistency("IG1", NESTEDVECTOR_INT, aux_last_type_read_for_IG1);
        aux_last_type_read_for_IG1 = NESTEDVECTOR_INT;
        if ((! var_NG1_1d_int_NestedVector.contains(var_i_0d_int_Scalar))) {
          // assign expression to variable NG1
          var_NG1_1d_int_NestedVector.set(var_i_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts));
          validate_vartype_consistency("NG1", NESTEDVECTOR_INT, aux_last_type_read_for_NG1);
          aux_last_type_read_for_NG1 = NESTEDVECTOR_INT;
        } else {
          cpp_validate_field(var_NG1_1d_int_NestedVector[var_i_0d_int_Scalar], cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  true, false, false, "NG1",
            cpp_template, cpp_line, parse_opts);
        }
        // assign expression to variable IG
        var_IG_1d_int_NestedVector.set(var_i_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts));
        validate_vartype_consistency("IG", NESTEDVECTOR_INT, aux_last_type_read_for_IG);
        aux_last_type_read_for_IG = NESTEDVECTOR_INT;
        {
          int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
          int cpp_i = 0;
          int cpp_j = 0;
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          // read LIST body
          ptr_COV_2d_idx0 = var_COV_2d_double_NestedVector.prepare(var_i_0d_int_Scalar);

          for (int var_j_0d_int_Scalar = 1;
             var_j_0d_int_Scalar <= var_NG1_1d_int_NestedVector[var_i_0d_int_Scalar]; var_j_0d_int_Scalar++) {
            bool aux_j_read = true;
            // read LIST body
            // assign expression to variable COV
            ptr_COV_2d_idx0->set(var_j_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
            validate_vartype_consistency("COV", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_COV);
            aux_last_type_read_for_COV = NESTEDVECTOR_DOUBLE;
            cpp_i++;
            cpp_j++;
            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              cpp_j = 0;
            }
          }
          if (cpp_i != cpp_npl) {
            throw std::runtime_error("not exactly NPL elements consumed");
          }
        }
        if (((((((var_IG_1d_int_NestedVector.contains(var_i_0d_int_Scalar)) && ((var_IG_1d_int_NestedVector[var_i_0d_int_Scalar])==(var_NG_0d_int_Scalar)))))))) {
          break;
        }
      }
      // store data in Python dictionary
      if (((aux_last_type_read_for_MAT1 == SCALAR_INT) && (aux_MAT1_read == true))) {
        cpp_current_dict["MAT1"] = var_MAT1_0d_int_Scalar;
      }
      if (((aux_last_type_read_for_MT1 == SCALAR_INT) && (aux_MT1_read == true))) {
        cpp_current_dict["MT1"] = var_MT1_0d_int_Scalar;
      }
      if (((aux_last_type_read_for_NG == SCALAR_INT) && (aux_NG_read == true))) {
        cpp_current_dict["NG"] = var_NG_0d_int_Scalar;
      }
      if ((var_NG1_1d_int_NestedVector.get_last_index() != -1)) {
        cpp_current_dict["NG1"] = var_NG1_1d_int_NestedVector.to_pyobj(list_mode);
      }
      if ((var_IG1_1d_int_NestedVector.get_last_index() != -1)) {
        cpp_current_dict["IG1"] = var_IG1_1d_int_NestedVector.to_pyobj(list_mode);
      }
      if ((var_IG_1d_int_NestedVector.get_last_index() != -1)) {
        cpp_current_dict["IG"] = var_IG_1d_int_NestedVector.to_pyobj(list_mode);
      }
      if ((var_COV_2d_double_NestedVector.get_last_index() != -1)) {
        cpp_current_dict["COV"] = var_COV_2d_double_NestedVector.to_pyobj(list_mode);
      }
      cpp_current_dict = cpp_parent_dict;
    }
  }
  cpp_read_send(cont, mat, mf, parse_opts);
  // store data in Python dictionary
  if (((aux_last_type_read_for_MAT == SCALAR_INT) && (aux_MAT_read == true))) {
    cpp_current_dict["MAT"] = var_MAT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MF == SCALAR_INT) && (aux_MF_read == true))) {
    cpp_current_dict["MF"] = var_MF_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MT == SCALAR_INT) && (aux_MT_read == true))) {
    cpp_current_dict["MT"] = var_MT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_ZA == SCALAR_DOUBLE) && (aux_ZA_read == true))) {
    cpp_current_dict["ZA"] = var_ZA_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_AWR == SCALAR_DOUBLE) && (aux_AWR_read == true))) {
    cpp_current_dict["AWR"] = var_AWR_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_MTL == SCALAR_INT) && (aux_MTL_read == true))) {
    cpp_current_dict["MTL"] = var_MTL_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_NK == SCALAR_INT) && (aux_NK_read == true))) {
    cpp_current_dict["NK"] = var_NK_0d_int_Scalar;
  }
  return cpp_current_dict;
}

void _check_end_records(bool after_fend, bool after_mend, bool after_tend, bool mat, bool mf, bool mt, bool last_mat, bool last_mf, bool last_mt, bool section_encountered, bool found_tpid, ParsingOptions parse_opts) {
  if (parse_opts.ignore_send_records == false) {
    if ((after_mend == true || after_tend == true)) {
      throw std::runtime_error("No MF/MT section allowed after MEND/TEND record");
    }
    if ((after_fend == true && section_encountered == false)) {
      throw std::runtime_error("FEND record without preceding MF/MT section encountered");
    }
    if ((after_fend == true && last_mf >= mf)) {
      throw std::runtime_error("MF sections must be in ascending order");
    }
  }
  if ((found_tpid == false && parse_opts.ignore_missing_tpid == false)) {
    throw std::runtime_error("Tape ID (TPID) record missing in first line");
  }
}

py::dict parse_endf_istream(std::istream& cont, py::object exclude, py::object include, ParsingOptions parse_opts=default_parsing_options()) {
  bool is_firstline = true;
  std::streampos curpos;
  py::dict mfmt_dict;
  py::dict curdict;
  int mat;
  int mf;
  int mt;
  bool section_encountered = false;
  int last_mat;
  int last_mf;
  int last_mt;
  std::string cpp_line;
  std::vector<std::string> verbatim_section;
  bool found_tpid = false;
  bool after_fend = false;
  bool after_mend = false;
  bool after_tend = false;
  curpos = cont.tellg();
  while (std::getline(cont, cpp_line)) {
    if (cpp_is_blank_line(cpp_line)) {
      if ((after_tend || parse_opts.ignore_blank_lines)) {
        continue;
      } else {
        throw std::runtime_error("Blank line detected: Correct file or use `ignore_blank_lines` option");
      }
    }
    mat = cpp_read_custom_int_field(cpp_line.c_str(), 66, 4);
    mf = cpp_read_custom_int_field(cpp_line.c_str(), 70, 2);
    mt = cpp_read_custom_int_field(cpp_line.c_str(), 72, 3);
    if ((mf == 0 && mt == 0 && is_firstline)) {
      found_tpid = true;
      _check_end_records(after_fend, after_mend, after_tend, mat, mf, mt, last_mat, last_mf, last_mt, section_encountered, found_tpid, parse_opts);
      after_fend = false;
      section_encountered = true;
      cont.seekg(curpos);
      if (mt != 0) {
        is_firstline = false;
      }
      if (should_parse_section(mf, mt, exclude, include)) {
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = parse_mf0mt0_istream(cont, parse_opts);
        }
      } else {
        verbatim_section = read_section_verbatim(mat, mf, mt, cont, is_firstline, parse_opts);
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = verbatim_section;
        }
      }
    } else if (mf == 1 && mt == 451) {
      _check_end_records(after_fend, after_mend, after_tend, mat, mf, mt, last_mat, last_mf, last_mt, section_encountered, found_tpid, parse_opts);
      after_fend = false;
      section_encountered = true;
      cont.seekg(curpos);
      if (mt != 0) {
        is_firstline = false;
      }
      if (should_parse_section(mf, mt, exclude, include)) {
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = parse_mf1mt451_istream(cont, parse_opts);
        }
      } else {
        verbatim_section = read_section_verbatim(mat, mf, mt, cont, is_firstline, parse_opts);
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = verbatim_section;
        }
      }
    } else if (mf == 3) {
      _check_end_records(after_fend, after_mend, after_tend, mat, mf, mt, last_mat, last_mf, last_mt, section_encountered, found_tpid, parse_opts);
      after_fend = false;
      section_encountered = true;
      cont.seekg(curpos);
      if (mt != 0) {
        is_firstline = false;
      }
      if (should_parse_section(mf, mt, exclude, include)) {
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = parse_mf3_istream(cont, parse_opts);
        }
      } else {
        verbatim_section = read_section_verbatim(mat, mf, mt, cont, is_firstline, parse_opts);
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = verbatim_section;
        }
      }
    } else if (mf == 33) {
      _check_end_records(after_fend, after_mend, after_tend, mat, mf, mt, last_mat, last_mf, last_mt, section_encountered, found_tpid, parse_opts);
      after_fend = false;
      section_encountered = true;
      cont.seekg(curpos);
      if (mt != 0) {
        is_firstline = false;
      }
      if (should_parse_section(mf, mt, exclude, include)) {
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = parse_mf33_istream(cont, parse_opts);
        }
      } else {
        verbatim_section = read_section_verbatim(mat, mf, mt, cont, is_firstline, parse_opts);
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = verbatim_section;
        }
      }
    } else if ((mf != 0 && mt != 0)) {
      verbatim_section = read_section_verbatim(mat, mf, mt, cont, is_firstline, parse_opts);
      {
        py::dict curdict = mfmt_dict;
        if (! curdict.contains(py::cast(mf))) {
          curdict[py::cast(mf)] = py::dict();
        }
        curdict = curdict[py::cast(mf)];
        curdict[py::cast(mt)] = verbatim_section;
      }
    } else if ((after_mend == true && cpp_is_tend_record(cpp_line, parse_opts))) {
      after_mend = false;
      after_tend = true;
    } else if ((after_fend == true && cpp_is_mend_record(cpp_line, parse_opts))) {
      after_mend = true;
    } else if (cpp_is_fend_record(cpp_line, mat, parse_opts)) {
      after_fend = true;
    } else {
      throw std::runtime_error(
        std::string("Invalid line encountered! This line is outside any MF/MT section.\n")
        + "Line: " + cpp_line
      );
    }
    last_mat = mat;
    last_mf = mf;
    last_mt = mt;
    curpos = cont.tellg();
    is_firstline = false;
  }
  return mfmt_dict;
}

py::dict parse_mf0mt0(std::string& strcont, ParsingOptions parse_opts) {
  std::istringstream iss(strcont);
  return parse_mf0mt0_istream(iss, parse_opts);
}

py::dict parse_mf1mt451(std::string& strcont, ParsingOptions parse_opts) {
  std::istringstream iss(strcont);
  return parse_mf1mt451_istream(iss, parse_opts);
}

py::dict parse_mf3(std::string& strcont, ParsingOptions parse_opts) {
  std::istringstream iss(strcont);
  return parse_mf3_istream(iss, parse_opts);
}

py::dict parse_mf33(std::string& strcont, ParsingOptions parse_opts) {
  std::istringstream iss(strcont);
  return parse_mf33_istream(iss, parse_opts);
}

py::dict parse_endf(std::string& strcont, py::object exclude, py::object include, ParsingOptions parse_opts) {
  std::istringstream iss(strcont);
  return parse_endf_istream(iss, exclude, include, parse_opts);
}

py::dict parse_mf0mt0_file(std::string& filename, ParsingOptions parse_opts) {
  std::ifstream inpfile(filename, std::ios::binary);
if ((! inpfile.is_open())) {
  throw std::ifstream::failure("failed to open file " + filename);
}
  return parse_mf0mt0_istream(inpfile, parse_opts);
}

py::dict parse_mf1mt451_file(std::string& filename, ParsingOptions parse_opts) {
  std::ifstream inpfile(filename, std::ios::binary);
if ((! inpfile.is_open())) {
  throw std::ifstream::failure("failed to open file " + filename);
}
  return parse_mf1mt451_istream(inpfile, parse_opts);
}

py::dict parse_mf3_file(std::string& filename, ParsingOptions parse_opts) {
  std::ifstream inpfile(filename, std::ios::binary);
if ((! inpfile.is_open())) {
  throw std::ifstream::failure("failed to open file " + filename);
}
  return parse_mf3_istream(inpfile, parse_opts);
}

py::dict parse_mf33_file(std::string& filename, ParsingOptions parse_opts) {
  std::ifstream inpfile(filename, std::ios::binary);
if ((! inpfile.is_open())) {
  throw std::ifstream::failure("failed to open file " + filename);
}
  return parse_mf33_istream(inpfile, parse_opts);
}

py::dict parse_endf_file(std::string& filename, py::object exclude, py::object include, ParsingOptions parse_opts) {
  std::ifstream inpfile(filename, std::ios::binary);
if ((! inpfile.is_open())) {
  throw std::ifstream::failure("failed to open file " + filename);
}
  return parse_endf_istream(inpfile, exclude, include, parse_opts);
}



// MD5 hash of ENDF recipe underlying the following function: a38e6e76968fb4463ab67282d5c7f80d
// MD5 hash of the following function definition: 9ff583f3d69360039fd954893548056a
void write_mf0mt0_ostream(
  std::ostream& cont, py::dict endf_dict, WritingOptions &write_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  Tab1Body tab1_body;
  Tab2Body tab2_body;
  bool list_mode = write_opts.array_type != "dict";  py::dict cpp_parent_dict;
  py::dict cpp_current_dict = endf_dict;
  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  std::string var_TAPEDESCR_0d_string_Scalar;
  bool aux_TAPEDESCR_read = false;
  vartype aux_last_type_read_for_TAPEDESCR = UNKNOWN;
  int mat = py::cast<int>(cpp_index_shifter_store.get_value("MAT", std::vector<int>({}), py::none()));
  int mf = 0;
  int mt = 0;
  cpp_current_dict["MAT"] = mat;
  cpp_current_dict["MF"] = mf;
  cpp_current_dict["MT"] = mt;
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MAT", std::vector<int>({}), py::none()));
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 0;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = 0;
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  std::string cpp_line;
  std::string cpp_draft_line;
  int linenum = 0;
  if ((mf == 0 && mt == 0)) {
    linenum = -1;
  }
  cpp_template = "[ MAT , 0 , 0 / TAPEDESCR ] TEXT";
  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
  cpp_draft_line.replace(0, 66, py::cast<std::string>(cpp_index_shifter_store.get_value("TAPEDESCR", std::vector<int>({}), py::none())));
  // assign expression to variable TAPEDESCR
  var_TAPEDESCR_0d_string_Scalar = py::cast<std::string>(cpp_index_shifter_store.get_value("TAPEDESCR", std::vector<int>({}), py::none()));
  aux_TAPEDESCR_read = true;
  validate_vartype_consistency("TAPEDESCR", SCALAR_STRING, aux_last_type_read_for_TAPEDESCR);
  aux_last_type_read_for_TAPEDESCR = SCALAR_STRING;
  cont << cpp_draft_line;
}


// MD5 hash of ENDF recipe underlying the following function: 1aa496513dcfa0260b0a6404b7a0ea5a
// MD5 hash of the following function definition: 513dde45725937793f574bacb9eb97c6
void write_mf1mt451_ostream(
  std::ostream& cont, py::dict endf_dict, WritingOptions &write_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  Tab1Body tab1_body;
  Tab2Body tab2_body;
  bool list_mode = write_opts.array_type != "dict";  py::dict cpp_parent_dict;
  py::dict cpp_current_dict = endf_dict;
  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  EndfFloatCpp var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  EndfFloatCpp var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_IVER_0d_int_Scalar;
  bool aux_IVER_read = false;
  vartype aux_last_type_read_for_IVER = UNKNOWN;
  int var_IRELCO_0d_int_Scalar;
  bool aux_IRELCO_read = false;
  vartype aux_last_type_read_for_IRELCO = UNKNOWN;
  EndfFloatCpp var_TEMPIN_0d_double_Scalar;
  bool aux_TEMPIN_read = false;
  vartype aux_last_type_read_for_TEMPIN = UNKNOWN;
  int var_NG_0d_int_Scalar;
  bool aux_NG_read = false;
  vartype aux_last_type_read_for_NG = UNKNOWN;
  int cpp_int_val;
  bool aux_cpp_int_val_read = false;
  vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
  NestedVector<EndfFloatCpp> var_EG_1d_double_NestedVector;
  vartype aux_last_type_read_for_EG = UNKNOWN;
  int mat = py::cast<int>(cpp_index_shifter_store.get_value("MAT", std::vector<int>({}), py::none()));
  int mf = 1;
  int mt = 451;
  cpp_current_dict["MAT"] = mat;
  cpp_current_dict["MF"] = mf;
  cpp_current_dict["MT"] = mt;
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MAT", std::vector<int>({}), py::none()));
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 1;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = 451;
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  std::string cpp_line;
  std::string cpp_draft_line;
  int linenum = 0;
  if ((mf == 0 && mt == 0)) {
    linenum = -1;
  }
  cpp_template = "[ MAT , 1 , MT / ZA , AWR , IVER , IRELCO , (-11) , 0 ] CONT";
  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
  // read CONT record
  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::none()));
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::none()));
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("IVER", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable IVER
  var_IVER_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("IVER", std::vector<int>({}), py::none()));
  aux_IVER_read = true;
  validate_vartype_consistency("IVER", SCALAR_INT, aux_last_type_read_for_IVER);
  aux_last_type_read_for_IVER = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("IRELCO", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable IRELCO
  var_IRELCO_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("IRELCO", std::vector<int>({}), py::none()));
  aux_IRELCO_read = true;
  validate_vartype_consistency("IRELCO", SCALAR_INT, aux_last_type_read_for_IRELCO);
  aux_last_type_read_for_IRELCO = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 4, (-11), write_opts);
  cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
  cont << cpp_draft_line;
  cpp_template = "[ MAT , 1 , MT / TEMPIN , 0.0 , NG , 0 , (NG+1) , 0 / { EG } { i = 1 to (NG+1) } ] LIST";
  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
  // read LIST record
  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("TEMPIN", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable TEMPIN
  var_TEMPIN_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("TEMPIN", std::vector<int>({}), py::none()));
  aux_TEMPIN_read = true;
  validate_vartype_consistency("TEMPIN", SCALAR_DOUBLE, aux_last_type_read_for_TEMPIN);
  aux_last_type_read_for_TEMPIN = SCALAR_DOUBLE;
  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("NG", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable NG
  var_NG_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NG", std::vector<int>({}), py::none()));
  aux_NG_read = true;
  validate_vartype_consistency("NG", SCALAR_INT, aux_last_type_read_for_NG);
  aux_last_type_read_for_NG = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 4, (py::cast<int>(cpp_index_shifter_store.get_value("NG", std::vector<int>({}), py::none()))+1), write_opts);
  if ((! (aux_NG_read == true))) {
    // assign expression to variable cpp_int_val
    cpp_int_val = (py::cast<int>(cpp_index_shifter_store.get_value("NG", std::vector<int>({}), py::none()))+1);
    aux_cpp_int_val_read = true;
    validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
    aux_last_type_read_for_cpp_int_val = SCALAR_INT;
    // assign expression to variable NG
    var_NG_0d_int_Scalar = static_cast<int>(std::round((cpp_int_val+(-1))));
    aux_NG_read = true;
    validate_vartype_consistency("NG", SCALAR_INT, aux_last_type_read_for_NG);
    aux_last_type_read_for_NG = SCALAR_INT;
  } else {
  }
  cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 4, (py::cast<int>(cpp_index_shifter_store.get_value("NG", std::vector<int>({}), py::none()))+1), write_opts);
  cont << cpp_draft_line;
  {
    int cpp_npl = (py::cast<int>(cpp_index_shifter_store.get_value("NG", std::vector<int>({}), py::none()))+1);
    int cpp_i = 0;
    int cpp_j = 0;
    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
    // read LIST body

    for (int var_i_0d_int_Scalar = 1;
       var_i_0d_int_Scalar <= (var_NG_0d_int_Scalar+1); var_i_0d_int_Scalar++) {
      bool aux_i_read = true;
      // read LIST body
      cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("EG", std::vector<int>({var_i_0d_int_Scalar}), py::none())), write_opts);
      // assign expression to variable EG
      var_EG_1d_double_NestedVector.set(var_i_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("EG", std::vector<int>({var_i_0d_int_Scalar}), py::none())));
      validate_vartype_consistency("EG", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_EG);
      aux_last_type_read_for_EG = NESTEDVECTOR_DOUBLE;
      cpp_i++;
      cpp_j++;
      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
        cont << cpp_draft_line;
        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
        cpp_j = 0;
      }
    }
    if (cpp_i != cpp_npl) {
      throw std::runtime_error("not exactly NPL elements consumed");
    }
  }
  cont << cpp_draft_line;
  cpp_draft_line = cpp_prepare_send(mat, mf, write_opts);
  cont << cpp_draft_line;
}


// MD5 hash of ENDF recipe underlying the following function: 7f60f82614e2c4adcb5481133b02f23e
// MD5 hash of the following function definition: 351f6801ab12a1c416d70dbf33d9106f
void write_mf3_ostream(
  std::ostream& cont, py::dict endf_dict, WritingOptions &write_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  Tab1Body tab1_body;
  Tab2Body tab2_body;
  bool list_mode = write_opts.array_type != "dict";  py::dict cpp_parent_dict;
  py::dict cpp_current_dict = endf_dict;
  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  EndfFloatCpp var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  int var_NG_0d_int_Scalar;
  bool aux_NG_read = false;
  vartype aux_last_type_read_for_NG = UNKNOWN;
  NestedVector<EndfFloatCpp> var_SIG_1d_double_NestedVector;
  vartype aux_last_type_read_for_SIG = UNKNOWN;
  int mat = py::cast<int>(cpp_index_shifter_store.get_value("MAT", std::vector<int>({}), py::none()));
  int mf = 3;
  int mt = py::cast<int>(cpp_index_shifter_store.get_value("MT", std::vector<int>({}), py::none()));
  cpp_current_dict["MAT"] = mat;
  cpp_current_dict["MF"] = mf;
  cpp_current_dict["MT"] = mt;
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MAT", std::vector<int>({}), py::none()));
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 3;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MT", std::vector<int>({}), py::none()));
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  std::string cpp_line;
  std::string cpp_draft_line;
  int linenum = 0;
  if ((mf == 0 && mt == 0)) {
    linenum = -1;
  }
  cpp_template = "[ MAT , 3 , MT / ZA , 0.0 , 0 , 0 , NG , 0 / \n { SIG } { i = 1 to NG } ] LIST";
  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
  // read LIST record
  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::none()));
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NG", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable NG
  var_NG_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NG", std::vector<int>({}), py::none()));
  aux_NG_read = true;
  validate_vartype_consistency("NG", SCALAR_INT, aux_last_type_read_for_NG);
  aux_last_type_read_for_NG = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NG", std::vector<int>({}), py::none())), write_opts);
  cont << cpp_draft_line;
  {
    int cpp_npl = py::cast<int>(cpp_index_shifter_store.get_value("NG", std::vector<int>({}), py::none()));
    int cpp_i = 0;
    int cpp_j = 0;
    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
    // read LIST body

    for (int var_i_0d_int_Scalar = 1;
       var_i_0d_int_Scalar <= var_NG_0d_int_Scalar; var_i_0d_int_Scalar++) {
      bool aux_i_read = true;
      // read LIST body
      cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("SIG", std::vector<int>({var_i_0d_int_Scalar}), py::none())), write_opts);
      // assign expression to variable SIG
      var_SIG_1d_double_NestedVector.set(var_i_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("SIG", std::vector<int>({var_i_0d_int_Scalar}), py::none())));
      validate_vartype_consistency("SIG", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_SIG);
      aux_last_type_read_for_SIG = NESTEDVECTOR_DOUBLE;
      cpp_i++;
      cpp_j++;
      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
        cont << cpp_draft_line;
        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
        cpp_j = 0;
      }
    }
    if (cpp_i != cpp_npl) {
      throw std::runtime_error("not exactly NPL elements consumed");
    }
  }
  cont << cpp_draft_line;
  cpp_draft_line = cpp_prepare_send(mat, mf, write_opts);
  cont << cpp_draft_line;
}


// MD5 hash of ENDF recipe underlying the following function: fd7b6b53d7fe662e9cfa0b44f31f58f9
// MD5 hash of the following function definition: b92542b01e68b3fd0aaaa778f087e129
void write_mf33_ostream(
  std::ostream& cont, py::dict endf_dict, WritingOptions &write_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  Tab1Body tab1_body;
  Tab2Body tab2_body;
  bool list_mode = write_opts.array_type != "dict";  py::dict cpp_parent_dict;
  py::dict cpp_current_dict = endf_dict;
  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  EndfFloatCpp var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  EndfFloatCpp var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_MTL_0d_int_Scalar;
  bool aux_MTL_read = false;
  vartype aux_last_type_read_for_MTL = UNKNOWN;
  int var_NK_0d_int_Scalar;
  bool aux_NK_read = false;
  vartype aux_last_type_read_for_NK = UNKNOWN;
  int mat = py::cast<int>(cpp_index_shifter_store.get_value("MAT", std::vector<int>({}), py::none()));
  int mf = 33;
  int mt = py::cast<int>(cpp_index_shifter_store.get_value("MT", std::vector<int>({}), py::none()));
  cpp_current_dict["MAT"] = mat;
  cpp_current_dict["MF"] = mf;
  cpp_current_dict["MT"] = mt;
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MAT", std::vector<int>({}), py::none()));
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 33;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MT", std::vector<int>({}), py::none()));
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  std::string cpp_line;
  std::string cpp_draft_line;
  int linenum = 0;
  if ((mf == 0 && mt == 0)) {
    linenum = -1;
  }
  cpp_template = "[ MAT , 33 , MT / ZA , AWR , 0 , MTL , 0 , NK ] CONT";
  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
  // read CONT record
  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::none()));
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::none()));
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("MTL", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable MTL
  var_MTL_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MTL", std::vector<int>({}), py::none()));
  aux_MTL_read = true;
  validate_vartype_consistency("MTL", SCALAR_INT, aux_last_type_read_for_MTL);
  aux_last_type_read_for_MTL = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 4, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NK", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable NK
  var_NK_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NK", std::vector<int>({}), py::none()));
  aux_NK_read = true;
  validate_vartype_consistency("NK", SCALAR_INT, aux_last_type_read_for_NK);
  aux_last_type_read_for_NK = SCALAR_INT;
  cont << cpp_draft_line;

  for (int var_k_0d_int_Scalar = 1;
     var_k_0d_int_Scalar <= var_NK_0d_int_Scalar; var_k_0d_int_Scalar++) {
    bool aux_k_read = true;
    // open section subsection
    {
      py::dict cpp_parent_dict = cpp_current_dict;
      cpp_current_dict = cpp_index_shifter_store.get_value("subsection", std::vector<int>({var_k_0d_int_Scalar}), py::dict());
      IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
      // variable declarations
      int var_MAT1_0d_int_Scalar;
      bool aux_MAT1_read = false;
      vartype aux_last_type_read_for_MAT1 = UNKNOWN;
      int var_MT1_0d_int_Scalar;
      bool aux_MT1_read = false;
      vartype aux_last_type_read_for_MT1 = UNKNOWN;
      int var_NG_0d_int_Scalar;
      bool aux_NG_read = false;
      vartype aux_last_type_read_for_NG = UNKNOWN;
      NestedVector<int> var_NG1_1d_int_NestedVector;
      vartype aux_last_type_read_for_NG1 = UNKNOWN;
      NestedVector<int> var_IG1_1d_int_NestedVector;
      vartype aux_last_type_read_for_IG1 = UNKNOWN;
      NestedVector<int> var_IG_1d_int_NestedVector;
      vartype aux_last_type_read_for_IG = UNKNOWN;
      NestedVector<NestedVector<EndfFloatCpp>> var_COV_2d_double_NestedVector;
      NestedVector<EndfFloatCpp>* ptr_COV_2d_idx0;
      vartype aux_last_type_read_for_COV = UNKNOWN;
      cpp_template = "[ MAT , 33 , MT / 0.0 , 0.0 , MAT1 , MT1 , 0 , NG ] CONT";
      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
      // read CONT record
      cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
      cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
      cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("MAT1", std::vector<int>({}), py::none())), write_opts);
      // assign expression to variable MAT1
      var_MAT1_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MAT1", std::vector<int>({}), py::none()));
      aux_MAT1_read = true;
      validate_vartype_consistency("MAT1", SCALAR_INT, aux_last_type_read_for_MAT1);
      aux_last_type_read_for_MAT1 = SCALAR_INT;
      cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("MT1", std::vector<int>({}), py::none())), write_opts);
      // assign expression to variable MT1
      var_MT1_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MT1", std::vector<int>({}), py::none()));
      aux_MT1_read = true;
      validate_vartype_consistency("MT1", SCALAR_INT, aux_last_type_read_for_MT1);
      aux_last_type_read_for_MT1 = SCALAR_INT;
      cpp_write_field<int>(cpp_draft_line, 4, 0, write_opts);
      cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NG", std::vector<int>({}), py::none())), write_opts);
      // assign expression to variable NG
      var_NG_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NG", std::vector<int>({}), py::none()));
      aux_NG_read = true;
      validate_vartype_consistency("NG", SCALAR_INT, aux_last_type_read_for_NG);
      aux_last_type_read_for_NG = SCALAR_INT;
      cont << cpp_draft_line;

      for (int var_i_0d_int_Scalar = 1;; var_i_0d_int_Scalar++) {
        bool aux_i_read = true;
        cpp_template = "[ MAT , 33 , MT / 0.0 , 0.0 , NG1 , IG1 , NG1 , IG / \n { COV } { j = 1 to NG1 } ] LIST";
        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
        // read LIST record
        cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
        cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
        cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("NG1", std::vector<int>({var_i_0d_int_Scalar}), py::none())), write_opts);
        // assign expression to variable NG1
        var_NG1_1d_int_NestedVector.set(var_i_0d_int_Scalar, py::cast<int>(cpp_index_shifter_store.get_value("NG1", std::vector<int>({var_i_0d_int_Scalar}), py::none())));
        validate_vartype_consistency("NG1", NESTEDVECTOR_INT, aux_last_type_read_for_NG1);
        aux_last_type_read_for_NG1 = NESTEDVECTOR_INT;
        cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("IG1", std::vector<int>({var_i_0d_int_Scalar}), py::none())), write_opts);
        // assign expression to variable IG1
        var_IG1_1d_int_NestedVector.set(var_i_0d_int_Scalar, py::cast<int>(cpp_index_shifter_store.get_value("IG1", std::vector<int>({var_i_0d_int_Scalar}), py::none())));
        validate_vartype_consistency("IG1", NESTEDVECTOR_INT, aux_last_type_read_for_IG1);
        aux_last_type_read_for_IG1 = NESTEDVECTOR_INT;
        cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NG1", std::vector<int>({var_i_0d_int_Scalar}), py::none())), write_opts);
        if ((! var_NG1_1d_int_NestedVector.contains(var_i_0d_int_Scalar))) {
          // assign expression to variable NG1
          var_NG1_1d_int_NestedVector.set(var_i_0d_int_Scalar, py::cast<int>(cpp_index_shifter_store.get_value("NG1", std::vector<int>({var_i_0d_int_Scalar}), py::none())));
          validate_vartype_consistency("NG1", NESTEDVECTOR_INT, aux_last_type_read_for_NG1);
          aux_last_type_read_for_NG1 = NESTEDVECTOR_INT;
        } else {
        }
        cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("IG", std::vector<int>({var_i_0d_int_Scalar}), py::none())), write_opts);
        // assign expression to variable IG
        var_IG_1d_int_NestedVector.set(var_i_0d_int_Scalar, py::cast<int>(cpp_index_shifter_store.get_value("IG", std::vector<int>({var_i_0d_int_Scalar}), py::none())));
        validate_vartype_consistency("IG", NESTEDVECTOR_INT, aux_last_type_read_for_IG);
        aux_last_type_read_for_IG = NESTEDVECTOR_INT;
        cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NG1", std::vector<int>({var_i_0d_int_Scalar}), py::none())), write_opts);
        cont << cpp_draft_line;
        {
          int cpp_npl = py::cast<int>(cpp_index_shifter_store.get_value("NG1", std::vector<int>({var_i_0d_int_Scalar}), py::none()));
          int cpp_i = 0;
          int cpp_j = 0;
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
          // read LIST body
          ptr_COV_2d_idx0 = var_COV_2d_double_NestedVector.prepare(var_i_0d_int_Scalar);

          for (int var_j_0d_int_Scalar = 1;
             var_j_0d_int_Scalar <= var_NG1_1d_int_NestedVector[var_i_0d_int_Scalar]; var_j_0d_int_Scalar++) {
            bool aux_j_read = true;
            // read LIST body
            cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("COV", std::vector<int>({var_i_0d_int_Scalar, var_j_0d_int_Scalar}), py::none())), write_opts);
            // assign expression to variable COV
            ptr_COV_2d_idx0->set(var_j_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("COV", std::vector<int>({var_i_0d_int_Scalar, var_j_0d_int_Scalar}), py::none())));
            validate_vartype_consistency("COV", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_COV);
            aux_last_type_read_for_COV = NESTEDVECTOR_DOUBLE;
            cpp_i++;
            cpp_j++;
            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
              cont << cpp_draft_line;
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
              cpp_j = 0;
            }
          }
          if (cpp_i != cpp_npl) {
            throw std::runtime_error("not exactly NPL elements consumed");
          }
        }
        cont << cpp_draft_line;
        if (((((((var_IG_1d_int_NestedVector.contains(var_i_0d_int_Scalar)) && ((var_IG_1d_int_NestedVector[var_i_0d_int_Scalar])==(var_NG_0d_int_Scalar)))))))) {
          break;
        }
      }
      cpp_current_dict = cpp_parent_dict;
    }
  }
  cpp_draft_line = cpp_prepare_send(mat, mf, write_opts);
  cont << cpp_draft_line;
}
void write_endf_ostream(std::ostream& cont, py::dict endf_dict, py::object exclude, py::object include, WritingOptions write_opts=default_writing_options()) {
  int mat;
  int mf;
  int mt;
  int last_mat = -9999;
  int last_mf = -9999;
  int last_mt = -9999;
  bool section_encountered = false;
  bool found_tpid = false;
  auto d = py::reinterpret_borrow<py::dict>(endf_dict);
  py::object mf_keys = d.attr("keys")();
  std::vector<int> sorted_mf_keys;
  for (auto mf_key : mf_keys) {
    sorted_mf_keys.push_back(py::cast<int>(mf_key));
  }
  std::sort(sorted_mf_keys.begin(), sorted_mf_keys.end());
  std::map<int, std::vector<int>> sorted_mfmt_keys;
  for (auto mf_key : sorted_mf_keys) {
    py::object mt_keys = d[py::cast(mf_key)].attr("keys")();
  std::vector<int> sorted_mt_keys;
    for (auto mt_key : mt_keys) {
      sorted_mt_keys.push_back(py::cast<int>(mt_key));
    }
    std::sort(sorted_mt_keys.begin(), sorted_mt_keys.end());
    sorted_mfmt_keys[mf_key] = sorted_mt_keys;
  }
  for (auto mf_key : sorted_mf_keys) {
    py::dict mf_dict = d[py::cast(mf_key)];
    std::vector<int> sorted_mt_keys = sorted_mfmt_keys[mf_key];
    for (auto mt_key : sorted_mt_keys) {
      py::object mt_dict = mf_dict[py::cast(mt_key)];
      mf = mf_key;
      mt = mt_key;
      if ((! should_parse_section(mf, mt, exclude, include))) {
        continue;
      }
      if ((section_encountered && mf != last_mf && mf != 0 && last_mf != 0)) {
        cont << cpp_prepare_send(mat, 0, write_opts);
      }
      if (mf == 0 && mt == 0) {
        if (py::isinstance<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)])) {
          if ((! mt_dict.contains("MF"))) {
            mt_dict["MF"] = mf;
          }
          if ((! mt_dict.contains("MT"))) {
            mt_dict["MT"] = mt;
          }
          write_mf0mt0_ostream(cont, py::cast<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        } else {
          write_section_verbatim(cont, py::cast<py::list>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        }
        mat = get_mat_from_mfmt_section(mt_dict);
        section_encountered = true;
      } else if (mf == 1 && mt == 451) {
        if (py::isinstance<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)])) {
          if ((! mt_dict.contains("MF"))) {
            mt_dict["MF"] = mf;
          }
          if ((! mt_dict.contains("MT"))) {
            mt_dict["MT"] = mt;
          }
          write_mf1mt451_ostream(cont, py::cast<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        } else {
          write_section_verbatim(cont, py::cast<py::list>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        }
        mat = get_mat_from_mfmt_section(mt_dict);
        section_encountered = true;
      } else if (mf == 3) {
        if (py::isinstance<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)])) {
          if ((! mt_dict.contains("MF"))) {
            mt_dict["MF"] = mf;
          }
          if ((! mt_dict.contains("MT"))) {
            mt_dict["MT"] = mt;
          }
          write_mf3_ostream(cont, py::cast<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        } else {
          write_section_verbatim(cont, py::cast<py::list>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        }
        mat = get_mat_from_mfmt_section(mt_dict);
        section_encountered = true;
      } else if (mf == 33) {
        if (py::isinstance<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)])) {
          if ((! mt_dict.contains("MF"))) {
            mt_dict["MF"] = mf;
          }
          if ((! mt_dict.contains("MT"))) {
            mt_dict["MT"] = mt;
          }
          write_mf33_ostream(cont, py::cast<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        } else {
          write_section_verbatim(cont, py::cast<py::list>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        }
        mat = get_mat_from_mfmt_section(mt_dict);
        section_encountered = true;
      } else {
        write_section_verbatim(cont, py::cast<py::list>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
      }
      last_mat = mat;
      last_mf = mf;
      last_mt = mt;
    }
  }
  cont << cpp_prepare_send(mat, 0, write_opts);
  cont << cpp_prepare_send(0, 0, write_opts);
  cont << cpp_prepare_send(-1, 0, write_opts, false);
}

std::string write_mf0mt0(py::dict endf_dict, WritingOptions write_opts) {
  std::ostringstream oss;
  write_mf0mt0_ostream(oss, endf_dict, write_opts);
  return oss.str();
}

std::string write_mf1mt451(py::dict endf_dict, WritingOptions write_opts) {
  std::ostringstream oss;
  write_mf1mt451_ostream(oss, endf_dict, write_opts);
  return oss.str();
}

std::string write_mf3(py::dict endf_dict, WritingOptions write_opts) {
  std::ostringstream oss;
  write_mf3_ostream(oss, endf_dict, write_opts);
  return oss.str();
}

std::string write_mf33(py::dict endf_dict, WritingOptions write_opts) {
  std::ostringstream oss;
  write_mf33_ostream(oss, endf_dict, write_opts);
  return oss.str();
}

std::string write_endf(py::dict endf_dict, py::object exclude, py::object include, WritingOptions write_opts) {
  std::ostringstream oss;
  write_endf_ostream(oss, endf_dict, exclude, include, write_opts);
  return oss.str();
}

void write_mf0mt0_file(std::string& filename, py::dict endf_dict, WritingOptions write_opts) {
  std::ofstream outfile(filename, std::ios::binary);
  if ((! outfile.is_open())) {
    throw std::ofstream::failure("failed to open file " + filename);
  }
  write_mf0mt0_ostream(outfile, endf_dict, write_opts);
  outfile.close();
}

void write_mf1mt451_file(std::string& filename, py::dict endf_dict, WritingOptions write_opts) {
  std::ofstream outfile(filename, std::ios::binary);
  if ((! outfile.is_open())) {
    throw std::ofstream::failure("failed to open file " + filename);
  }
  write_mf1mt451_ostream(outfile, endf_dict, write_opts);
  outfile.close();
}

void write_mf3_file(std::string& filename, py::dict endf_dict, WritingOptions write_opts) {
  std::ofstream outfile(filename, std::ios::binary);
  if ((! outfile.is_open())) {
    throw std::ofstream::failure("failed to open file " + filename);
  }
  write_mf3_ostream(outfile, endf_dict, write_opts);
  outfile.close();
}

void write_mf33_file(std::string& filename, py::dict endf_dict, WritingOptions write_opts) {
  std::ofstream outfile(filename, std::ios::binary);
  if ((! outfile.is_open())) {
    throw std::ofstream::failure("failed to open file " + filename);
  }
  write_mf33_ostream(outfile, endf_dict, write_opts);
  outfile.close();
}

void write_endf_file(std::string& filename, py::dict endf_dict, py::object exclude, py::object include, WritingOptions write_opts) {
  std::ofstream outfile(filename, std::ios::binary);
  if ((! outfile.is_open())) {
    throw std::ofstream::failure("failed to open file " + filename);
  }
  write_endf_ostream(outfile, endf_dict, exclude, include, write_opts);
  outfile.close();
}



PYBIND11_MODULE(errorr, m) {

  // static bool parsing_options_registered = false;
  // if (! parsing_options_registered) {
  //   py::class_<ParsingOptions>(m, "ParsingOptions")
  //     .def(py::init<>())
  //     .def_readwrite("ignore_number_mismatch", &ParsingOptions::ignore_number_mismatch)
  //     .def_readwrite("ignore_zero_mismatch", &ParsingOptions::ignore_zero_mismatch)
  //     .def_readwrite("ignore_varspec_mismatch", &ParsingOptions::ignore_varspec_mismatch)
  //     .def_readwrite("accept_spaces", &ParsingOptions::accept_spaces)
  //     .def_readwrite("ignore_blank_lines", &ParsingOptions::ignore_blank_lines)
  //     .def_readwrite("ignore_send_records", &ParsingOptions::ignore_send_records)
  //     .def_readwrite("ignore_missing_tpid", &ParsingOptions::ignore_missing_tpid)
  //     .def_readwrite("validate_control_records", &ParsingOptions::validate_control_records);
  //   parsing_options_registered = true;
  // }
  m.def("parse_endf", &parse_endf, "parsing function", py::arg("cont"), py::arg("exclude") = py::none(), py::arg("include") = py::none(), py::arg("parse_opts") = false);
  m.def("parse_endf_file", &parse_endf_file, "parsing function", py::arg("filename"), py::arg("exclude") = py::none(), py::arg("include") = py::none(), py::arg("parse_opts") = default_parsing_options());
  m.def("write_endf", &write_endf, "parsing function", py::arg("endf_dict"), py::arg("exclude") = py::none(), py::arg("include") = py::none(), py::arg("WritingOptions") = false);
  m.def("write_endf_file", &write_endf_file, "parsing function", py::arg("filename"), py::arg("endf_dict"), py::arg("exclude") = py::none(), py::arg("include") = py::none(), py::arg("write_opts") = default_writing_options());
}
