# This file was auto-generated by Fern from our API Definition.

import datetime as dt
import typing
from json.decoder import JSONDecodeError

from ...commons.errors.bad_request import BadRequest
from ...commons.errors.conflict import Conflict
from ...commons.errors.forbidden import Forbidden
from ...commons.errors.internal_server_error import InternalServerError
from ...commons.errors.not_found import NotFound
from ...commons.errors.unauthorized import Unauthorized
from ...commons.errors.unimplemented import Unimplemented
from ...commons.types.bulk_download_format import BulkDownloadFormat
from ...commons.types.bulk_download_response import BulkDownloadResponse
from ...commons.types.order_direction import OrderDirection
from ...core.api_error import ApiError
from ...core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ...core.datetime_utils import serialize_datetime
from ...core.http_response import AsyncHttpResponse, HttpResponse
from ...core.jsonable_encoder import jsonable_encoder
from ...core.pydantic_utilities import parse_obj_as
from ...core.request_options import RequestOptions
from ...core.serialization import convert_and_respect_annotation_metadata
from ...entity_types.types.entity_id import EntityId
from ...entity_types.types.entity_user_id import EntityUserId
from ...invoice_types.types.approver_action import ApproverAction
from ...invoice_types.types.find_invoice_response import FindInvoiceResponse
from ...invoice_types.types.invoice_date_filter import InvoiceDateFilter
from ...invoice_types.types.invoice_id import InvoiceId
from ...invoice_types.types.invoice_metrics_group_by import InvoiceMetricsGroupBy
from ...invoice_types.types.invoice_metrics_per_date_frequency import InvoiceMetricsPerDateFrequency
from ...invoice_types.types.invoice_metrics_per_date_group_by import InvoiceMetricsPerDateGroupBy
from ...invoice_types.types.invoice_metrics_response import InvoiceMetricsResponse
from ...invoice_types.types.invoice_order_by_field import InvoiceOrderByField
from ...invoice_types.types.invoice_status import InvoiceStatus
from ...invoice_types.types.metadata_filter import MetadataFilter
from ...invoice_types.types.payment_type import PaymentType
from ...payment_method_types.types.currency_code import CurrencyCode


class RawInvoiceClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def find(
        self,
        entity_id: EntityId,
        *,
        exclude_payables: typing.Optional[bool] = None,
        exclude_receivables: typing.Optional[bool] = None,
        start_date: typing.Optional[dt.datetime] = None,
        end_date: typing.Optional[dt.datetime] = None,
        date_type: typing.Optional[InvoiceDateFilter] = None,
        order_by: typing.Optional[InvoiceOrderByField] = None,
        order_direction: typing.Optional[OrderDirection] = None,
        limit: typing.Optional[int] = None,
        starting_after: typing.Optional[InvoiceId] = None,
        metadata: typing.Optional[typing.Union[MetadataFilter, typing.Sequence[MetadataFilter]]] = None,
        line_item_metadata: typing.Optional[typing.Union[MetadataFilter, typing.Sequence[MetadataFilter]]] = None,
        line_item_gl_account_id: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        search: typing.Optional[str] = None,
        payer_id: typing.Optional[typing.Union[EntityId, typing.Sequence[EntityId]]] = None,
        vendor_id: typing.Optional[typing.Union[EntityId, typing.Sequence[EntityId]]] = None,
        creator_user_id: typing.Optional[typing.Union[EntityUserId, typing.Sequence[EntityUserId]]] = None,
        approver_id: typing.Optional[typing.Union[EntityUserId, typing.Sequence[EntityUserId]]] = None,
        approver_action: typing.Optional[typing.Union[ApproverAction, typing.Sequence[ApproverAction]]] = None,
        approver_count: typing.Optional[str] = None,
        invoice_id: typing.Optional[typing.Union[InvoiceId, typing.Sequence[InvoiceId]]] = None,
        status: typing.Optional[typing.Union[InvoiceStatus, typing.Sequence[InvoiceStatus]]] = None,
        payment_type: typing.Optional[typing.Sequence[PaymentType]] = None,
        return_payer_metadata: typing.Optional[bool] = None,
        return_vendor_metadata: typing.Optional[bool] = None,
        return_payment_timing: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[FindInvoiceResponse]:
        """
        Get invoices for an entity with the given filters.

        Parameters
        ----------
        entity_id : EntityId
            Entity ID or Entity ForeignID

        exclude_payables : typing.Optional[bool]
            Return only invoices that are receivable by the entity.

        exclude_receivables : typing.Optional[bool]
            Return only invoices that are payable by the entity.

        start_date : typing.Optional[dt.datetime]
            Start date filter. Defaults to CREATED_AT unless specified the dateType is specified

        end_date : typing.Optional[dt.datetime]
            End date filter. Defaults to CREATED_AT unless specified the dateType is specified

        date_type : typing.Optional[InvoiceDateFilter]
            Type of date to filter by if startDate and endDate filters are provided. Defaults to CREATED_AT.

        order_by : typing.Optional[InvoiceOrderByField]
            Field to order invoices by. Defaults to CREATED_AT.

        order_direction : typing.Optional[OrderDirection]
            Direction to order invoices by. Defaults to asc.

        limit : typing.Optional[int]
            Number of invoices to return. Limit can range between 1 and 100, and the default is 10.

        starting_after : typing.Optional[InvoiceId]
            The ID of the invoice to start after. If not provided, the first page of invoices will be returned.

        metadata : typing.Optional[typing.Union[MetadataFilter, typing.Sequence[MetadataFilter]]]
            Filter invoices by metadata. Each filter will be applied as an AND condition. Duplicate keys will be ignored.

        line_item_metadata : typing.Optional[typing.Union[MetadataFilter, typing.Sequence[MetadataFilter]]]
            Filter invoices by line item metadata. Each filter will be applied as an AND condition. Duplicate keys will be ignored.

        line_item_gl_account_id : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            Filter invoices by line item GL account ID. Each filter will be applied as an OR condition. Duplicate keys will be ignored.

        search : typing.Optional[str]
            Find invoices by vendor name, invoice number, check number, or amount. Partial matches are supported.

        payer_id : typing.Optional[typing.Union[EntityId, typing.Sequence[EntityId]]]
            Filter invoices by payer ID or payer foreign ID.

        vendor_id : typing.Optional[typing.Union[EntityId, typing.Sequence[EntityId]]]
            Filter invoices by vendor ID or vendor foreign ID.

        creator_user_id : typing.Optional[typing.Union[EntityUserId, typing.Sequence[EntityUserId]]]
            Filter invoices by the ID or foreign ID of the user that created the invoice.

        approver_id : typing.Optional[typing.Union[EntityUserId, typing.Sequence[EntityUserId]]]
            Filter invoices by assigned approver user ID.

        approver_action : typing.Optional[typing.Union[ApproverAction, typing.Sequence[ApproverAction]]]
            Filter invoices by approver action. Needs to be used with approverId. For example, if you want to find all invoices that have been approved by a specific user, you would use approverId and approverAction=APPROVE.

        approver_count : typing.Optional[str]
            Filter invoices by the number of approvers. Use exact number (e.g., 3) or range (e.g., ">3", "<5", ">=2", "<=4").

        invoice_id : typing.Optional[typing.Union[InvoiceId, typing.Sequence[InvoiceId]]]
            Filter invoices by invoice ID or invoice foreign ID.

        status : typing.Optional[typing.Union[InvoiceStatus, typing.Sequence[InvoiceStatus]]]
            Invoice status to filter on.

        payment_type : typing.Optional[typing.Sequence[PaymentType]]
            Filter invoices by payment type.

        return_payer_metadata : typing.Optional[bool]
            Whether to return payer metadata in the response

        return_vendor_metadata : typing.Optional[bool]
            Whether to return vendor metadata in the response

        return_payment_timing : typing.Optional[bool]
            Whether to return payment timing in the response

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[FindInvoiceResponse]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"entity/{jsonable_encoder(entity_id)}/invoices",
            method="GET",
            params={
                "excludePayables": exclude_payables,
                "excludeReceivables": exclude_receivables,
                "startDate": serialize_datetime(start_date) if start_date is not None else None,
                "endDate": serialize_datetime(end_date) if end_date is not None else None,
                "dateType": date_type,
                "orderBy": order_by,
                "orderDirection": order_direction,
                "limit": limit,
                "startingAfter": starting_after,
                "metadata": convert_and_respect_annotation_metadata(
                    object_=metadata, annotation=MetadataFilter, direction="write"
                ),
                "lineItemMetadata": convert_and_respect_annotation_metadata(
                    object_=line_item_metadata, annotation=MetadataFilter, direction="write"
                ),
                "lineItemGlAccountId": line_item_gl_account_id,
                "search": search,
                "payerId": payer_id,
                "vendorId": vendor_id,
                "creatorUserId": creator_user_id,
                "approverId": approver_id,
                "approverAction": approver_action,
                "approverCount": approver_count,
                "invoiceId": invoice_id,
                "status": status,
                "paymentType": payment_type,
                "returnPayerMetadata": return_payer_metadata,
                "returnVendorMetadata": return_vendor_metadata,
                "returnPaymentTiming": return_payment_timing,
            },
            request_options=request_options,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        if 200 <= _response.status_code < 300:
            _data = typing.cast(
                FindInvoiceResponse,
                parse_obj_as(
                    type_=FindInvoiceResponse,  # type: ignore
                    object_=_response_json,
                ),
            )
            return HttpResponse(response=_response, data=_data)
        if "errorName" in _response_json:
            if _response_json["errorName"] == "BadRequest":
                raise BadRequest(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        str,
                        parse_obj_as(
                            type_=str,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
            if _response_json["errorName"] == "Unauthorized":
                raise Unauthorized(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        str,
                        parse_obj_as(
                            type_=str,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
            if _response_json["errorName"] == "Forbidden":
                raise Forbidden(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        str,
                        parse_obj_as(
                            type_=str,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
            if _response_json["errorName"] == "NotFound":
                raise NotFound(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        str,
                        parse_obj_as(
                            type_=str,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
            if _response_json["errorName"] == "Conflict":
                raise Conflict(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        str,
                        parse_obj_as(
                            type_=str,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
            if _response_json["errorName"] == "InternalServerError":
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        str,
                        parse_obj_as(
                            type_=str,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
            if _response_json["errorName"] == "Unimplemented":
                raise Unimplemented(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        str,
                        parse_obj_as(
                            type_=str,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def metrics(
        self,
        entity_id: EntityId,
        *,
        search: typing.Optional[str] = None,
        exclude_payables: typing.Optional[bool] = None,
        exclude_receivables: typing.Optional[bool] = None,
        return_by_date: typing.Optional[InvoiceMetricsPerDateGroupBy] = None,
        return_by_date_frequency: typing.Optional[InvoiceMetricsPerDateFrequency] = None,
        group_by: typing.Optional[typing.Union[InvoiceMetricsGroupBy, typing.Sequence[InvoiceMetricsGroupBy]]] = None,
        payer_id: typing.Optional[typing.Union[EntityId, typing.Sequence[EntityId]]] = None,
        vendor_id: typing.Optional[typing.Union[EntityId, typing.Sequence[EntityId]]] = None,
        approver_id: typing.Optional[typing.Union[EntityUserId, typing.Sequence[EntityUserId]]] = None,
        approver_count: typing.Optional[str] = None,
        invoice_id: typing.Optional[typing.Union[InvoiceId, typing.Sequence[InvoiceId]]] = None,
        status: typing.Optional[typing.Union[InvoiceStatus, typing.Sequence[InvoiceStatus]]] = None,
        start_date: typing.Optional[dt.datetime] = None,
        end_date: typing.Optional[dt.datetime] = None,
        date_type: typing.Optional[InvoiceDateFilter] = None,
        currency: typing.Optional[typing.Union[CurrencyCode, typing.Sequence[CurrencyCode]]] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.List[InvoiceMetricsResponse]]:
        """
        Get invoice metrics for an entity with the given filters. Invoices will always be grouped by currency. If none of excludePayables, excludeReceivables, payerId, vendorId, or invoiceId status filters are provided, excludeReceivables will be set to true.

        Parameters
        ----------
        entity_id : EntityId
            Entity ID or Entity ForeignID

        search : typing.Optional[str]
            Find invoices by vendor name, invoice number, check number, or amount. Partial matches are supported.

        exclude_payables : typing.Optional[bool]
            Only return invoices that are not payable by the entity. This will return only invoices that are receivable by the entity.

        exclude_receivables : typing.Optional[bool]
            Only return invoices that are not receivable by the entity. This will return only invoices that are payable by the entity.

        return_by_date : typing.Optional[InvoiceMetricsPerDateGroupBy]
            Return invoice metrics grouped by date.

        return_by_date_frequency : typing.Optional[InvoiceMetricsPerDateFrequency]
            Return invoice metrics grouped by date. Defaults to daily.

        group_by : typing.Optional[typing.Union[InvoiceMetricsGroupBy, typing.Sequence[InvoiceMetricsGroupBy]]]
            Return invoice metrics grouped by.

        payer_id : typing.Optional[typing.Union[EntityId, typing.Sequence[EntityId]]]
            Filter invoices by payer ID.

        vendor_id : typing.Optional[typing.Union[EntityId, typing.Sequence[EntityId]]]
            Filter invoices by vendor ID.

        approver_id : typing.Optional[typing.Union[EntityUserId, typing.Sequence[EntityUserId]]]
            Filter invoices by assigned approver user ID.

        approver_count : typing.Optional[str]
            Filter invoices by the number of approvers. Use exact number (e.g., 3) or range (e.g., ">3", "<5", ">=2", "<=4").

        invoice_id : typing.Optional[typing.Union[InvoiceId, typing.Sequence[InvoiceId]]]
            Filter invoices by invoice ID or invoice foreign ID.

        status : typing.Optional[typing.Union[InvoiceStatus, typing.Sequence[InvoiceStatus]]]
            Invoice status to filter on

        start_date : typing.Optional[dt.datetime]
            Start date filter. Defaults to CREATED_AT unless specified the dateType is specified

        end_date : typing.Optional[dt.datetime]
            End date filter. Defaults to CREATED_AT unless specified the dateType is specified

        date_type : typing.Optional[InvoiceDateFilter]
            Type of date to filter by if startDate and endDate filters are provided. Defaults to CREATED_AT.

        currency : typing.Optional[typing.Union[CurrencyCode, typing.Sequence[CurrencyCode]]]
            Currency to filter on

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[InvoiceMetricsResponse]]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"entity/{jsonable_encoder(entity_id)}/invoice-metrics",
            method="GET",
            params={
                "search": search,
                "excludePayables": exclude_payables,
                "excludeReceivables": exclude_receivables,
                "returnByDate": return_by_date,
                "returnByDateFrequency": return_by_date_frequency,
                "groupBy": group_by,
                "payerId": payer_id,
                "vendorId": vendor_id,
                "approverId": approver_id,
                "approverCount": approver_count,
                "invoiceId": invoice_id,
                "status": status,
                "startDate": serialize_datetime(start_date) if start_date is not None else None,
                "endDate": serialize_datetime(end_date) if end_date is not None else None,
                "dateType": date_type,
                "currency": currency,
            },
            request_options=request_options,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        if 200 <= _response.status_code < 300:
            _data = typing.cast(
                typing.List[InvoiceMetricsResponse],
                parse_obj_as(
                    type_=typing.List[InvoiceMetricsResponse],  # type: ignore
                    object_=_response_json,
                ),
            )
            return HttpResponse(response=_response, data=_data)
        if "errorName" in _response_json:
            if _response_json["errorName"] == "BadRequest":
                raise BadRequest(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        str,
                        parse_obj_as(
                            type_=str,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
            if _response_json["errorName"] == "Unauthorized":
                raise Unauthorized(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        str,
                        parse_obj_as(
                            type_=str,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
            if _response_json["errorName"] == "Forbidden":
                raise Forbidden(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        str,
                        parse_obj_as(
                            type_=str,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
            if _response_json["errorName"] == "NotFound":
                raise NotFound(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        str,
                        parse_obj_as(
                            type_=str,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
            if _response_json["errorName"] == "Conflict":
                raise Conflict(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        str,
                        parse_obj_as(
                            type_=str,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
            if _response_json["errorName"] == "InternalServerError":
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        str,
                        parse_obj_as(
                            type_=str,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
            if _response_json["errorName"] == "Unimplemented":
                raise Unimplemented(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        str,
                        parse_obj_as(
                            type_=str,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def download(
        self,
        entity_id: EntityId,
        *,
        format: typing.Optional[BulkDownloadFormat] = None,
        exclude_payables: typing.Optional[bool] = None,
        exclude_receivables: typing.Optional[bool] = None,
        start_date: typing.Optional[dt.datetime] = None,
        end_date: typing.Optional[dt.datetime] = None,
        date_type: typing.Optional[InvoiceDateFilter] = None,
        order_by: typing.Optional[InvoiceOrderByField] = None,
        order_direction: typing.Optional[OrderDirection] = None,
        search: typing.Optional[str] = None,
        metadata: typing.Optional[typing.Union[MetadataFilter, typing.Sequence[MetadataFilter]]] = None,
        line_item_metadata: typing.Optional[typing.Union[MetadataFilter, typing.Sequence[MetadataFilter]]] = None,
        line_item_gl_account_id: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        payer_id: typing.Optional[typing.Union[EntityId, typing.Sequence[EntityId]]] = None,
        vendor_id: typing.Optional[typing.Union[EntityId, typing.Sequence[EntityId]]] = None,
        creator_user_id: typing.Optional[typing.Union[EntityUserId, typing.Sequence[EntityUserId]]] = None,
        approver_id: typing.Optional[typing.Union[EntityUserId, typing.Sequence[EntityUserId]]] = None,
        approver_action: typing.Optional[typing.Union[ApproverAction, typing.Sequence[ApproverAction]]] = None,
        invoice_id: typing.Optional[typing.Union[InvoiceId, typing.Sequence[InvoiceId]]] = None,
        status: typing.Optional[typing.Union[InvoiceStatus, typing.Sequence[InvoiceStatus]]] = None,
        payment_type: typing.Optional[typing.Sequence[PaymentType]] = None,
        return_payer_metadata: typing.Optional[bool] = None,
        return_vendor_metadata: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[BulkDownloadResponse]:
        """
        Get a URL to download invoices for an entity as a CSV/JSON file.

        Parameters
        ----------
        entity_id : EntityId
            Entity ID or Entity ForeignID

        format : typing.Optional[BulkDownloadFormat]
            Format of the file to download. Defaults to CSV.

        exclude_payables : typing.Optional[bool]
            Return only invoices that are receivable by the entity.

        exclude_receivables : typing.Optional[bool]
            Return only invoices that are payable by the entity.

        start_date : typing.Optional[dt.datetime]
            Start date filter. Defaults to CREATED_AT unless specified the dateType is specified

        end_date : typing.Optional[dt.datetime]
            End date filter. Defaults to CREATED_AT unless specified the dateType is specified

        date_type : typing.Optional[InvoiceDateFilter]
            Type of date to filter by if startDate and endDate filters are provided. Defaults to CREATED_AT.

        order_by : typing.Optional[InvoiceOrderByField]
            Field to order invoices by. Defaults to CREATED_AT.

        order_direction : typing.Optional[OrderDirection]
            Direction to order invoices by. Defaults to asc.

        search : typing.Optional[str]
            Find invoices by vendor name, invoice number, check number, or amount. Partial matches are supported.

        metadata : typing.Optional[typing.Union[MetadataFilter, typing.Sequence[MetadataFilter]]]
            Filter invoices by metadata. Each filter will be applied as an AND condition. Duplicate keys will be ignored.

        line_item_metadata : typing.Optional[typing.Union[MetadataFilter, typing.Sequence[MetadataFilter]]]
            Filter invoices by line item metadata. Each filter will be applied as an AND condition. Duplicate keys will be ignored.

        line_item_gl_account_id : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            Filter invoices by line item GL account ID. Each filter will be applied as an OR condition. Duplicate keys will be ignored.

        payer_id : typing.Optional[typing.Union[EntityId, typing.Sequence[EntityId]]]
            Filter invoices by payer ID or payer foreign ID.

        vendor_id : typing.Optional[typing.Union[EntityId, typing.Sequence[EntityId]]]
            Filter invoices by vendor ID or vendor foreign ID.

        creator_user_id : typing.Optional[typing.Union[EntityUserId, typing.Sequence[EntityUserId]]]
            Filter invoices by the ID or foreign ID of the user that created the invoice.

        approver_id : typing.Optional[typing.Union[EntityUserId, typing.Sequence[EntityUserId]]]
            Filter invoices by assigned approver user ID.

        approver_action : typing.Optional[typing.Union[ApproverAction, typing.Sequence[ApproverAction]]]
            Filter invoices by approver action. Needs to be used with approverId. For example, if you want to find all invoices that have been approved by a specific user, you would use approverId and approverAction=APPROVE.

        invoice_id : typing.Optional[typing.Union[InvoiceId, typing.Sequence[InvoiceId]]]
            Filter invoices by invoice ID or invoice foreign ID.

        status : typing.Optional[typing.Union[InvoiceStatus, typing.Sequence[InvoiceStatus]]]
            Invoice status to filter on.

        payment_type : typing.Optional[typing.Sequence[PaymentType]]
            Filter invoices by payment type.

        return_payer_metadata : typing.Optional[bool]
            Whether to return payer metadata in the response

        return_vendor_metadata : typing.Optional[bool]
            Whether to return vendor metadata in the response

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[BulkDownloadResponse]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"entity/{jsonable_encoder(entity_id)}/invoices/download",
            method="GET",
            params={
                "format": format,
                "excludePayables": exclude_payables,
                "excludeReceivables": exclude_receivables,
                "startDate": serialize_datetime(start_date) if start_date is not None else None,
                "endDate": serialize_datetime(end_date) if end_date is not None else None,
                "dateType": date_type,
                "orderBy": order_by,
                "orderDirection": order_direction,
                "search": search,
                "metadata": convert_and_respect_annotation_metadata(
                    object_=metadata, annotation=MetadataFilter, direction="write"
                ),
                "lineItemMetadata": convert_and_respect_annotation_metadata(
                    object_=line_item_metadata, annotation=MetadataFilter, direction="write"
                ),
                "lineItemGlAccountId": line_item_gl_account_id,
                "payerId": payer_id,
                "vendorId": vendor_id,
                "creatorUserId": creator_user_id,
                "approverId": approver_id,
                "approverAction": approver_action,
                "invoiceId": invoice_id,
                "status": status,
                "paymentType": payment_type,
                "returnPayerMetadata": return_payer_metadata,
                "returnVendorMetadata": return_vendor_metadata,
            },
            request_options=request_options,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        if 200 <= _response.status_code < 300:
            _data = typing.cast(
                BulkDownloadResponse,
                parse_obj_as(
                    type_=BulkDownloadResponse,  # type: ignore
                    object_=_response_json,
                ),
            )
            return HttpResponse(response=_response, data=_data)
        if "errorName" in _response_json:
            if _response_json["errorName"] == "BadRequest":
                raise BadRequest(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        str,
                        parse_obj_as(
                            type_=str,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
            if _response_json["errorName"] == "Unauthorized":
                raise Unauthorized(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        str,
                        parse_obj_as(
                            type_=str,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
            if _response_json["errorName"] == "Forbidden":
                raise Forbidden(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        str,
                        parse_obj_as(
                            type_=str,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
            if _response_json["errorName"] == "NotFound":
                raise NotFound(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        str,
                        parse_obj_as(
                            type_=str,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
            if _response_json["errorName"] == "Conflict":
                raise Conflict(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        str,
                        parse_obj_as(
                            type_=str,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
            if _response_json["errorName"] == "InternalServerError":
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        str,
                        parse_obj_as(
                            type_=str,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
            if _response_json["errorName"] == "Unimplemented":
                raise Unimplemented(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        str,
                        parse_obj_as(
                            type_=str,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawInvoiceClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def find(
        self,
        entity_id: EntityId,
        *,
        exclude_payables: typing.Optional[bool] = None,
        exclude_receivables: typing.Optional[bool] = None,
        start_date: typing.Optional[dt.datetime] = None,
        end_date: typing.Optional[dt.datetime] = None,
        date_type: typing.Optional[InvoiceDateFilter] = None,
        order_by: typing.Optional[InvoiceOrderByField] = None,
        order_direction: typing.Optional[OrderDirection] = None,
        limit: typing.Optional[int] = None,
        starting_after: typing.Optional[InvoiceId] = None,
        metadata: typing.Optional[typing.Union[MetadataFilter, typing.Sequence[MetadataFilter]]] = None,
        line_item_metadata: typing.Optional[typing.Union[MetadataFilter, typing.Sequence[MetadataFilter]]] = None,
        line_item_gl_account_id: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        search: typing.Optional[str] = None,
        payer_id: typing.Optional[typing.Union[EntityId, typing.Sequence[EntityId]]] = None,
        vendor_id: typing.Optional[typing.Union[EntityId, typing.Sequence[EntityId]]] = None,
        creator_user_id: typing.Optional[typing.Union[EntityUserId, typing.Sequence[EntityUserId]]] = None,
        approver_id: typing.Optional[typing.Union[EntityUserId, typing.Sequence[EntityUserId]]] = None,
        approver_action: typing.Optional[typing.Union[ApproverAction, typing.Sequence[ApproverAction]]] = None,
        approver_count: typing.Optional[str] = None,
        invoice_id: typing.Optional[typing.Union[InvoiceId, typing.Sequence[InvoiceId]]] = None,
        status: typing.Optional[typing.Union[InvoiceStatus, typing.Sequence[InvoiceStatus]]] = None,
        payment_type: typing.Optional[typing.Sequence[PaymentType]] = None,
        return_payer_metadata: typing.Optional[bool] = None,
        return_vendor_metadata: typing.Optional[bool] = None,
        return_payment_timing: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[FindInvoiceResponse]:
        """
        Get invoices for an entity with the given filters.

        Parameters
        ----------
        entity_id : EntityId
            Entity ID or Entity ForeignID

        exclude_payables : typing.Optional[bool]
            Return only invoices that are receivable by the entity.

        exclude_receivables : typing.Optional[bool]
            Return only invoices that are payable by the entity.

        start_date : typing.Optional[dt.datetime]
            Start date filter. Defaults to CREATED_AT unless specified the dateType is specified

        end_date : typing.Optional[dt.datetime]
            End date filter. Defaults to CREATED_AT unless specified the dateType is specified

        date_type : typing.Optional[InvoiceDateFilter]
            Type of date to filter by if startDate and endDate filters are provided. Defaults to CREATED_AT.

        order_by : typing.Optional[InvoiceOrderByField]
            Field to order invoices by. Defaults to CREATED_AT.

        order_direction : typing.Optional[OrderDirection]
            Direction to order invoices by. Defaults to asc.

        limit : typing.Optional[int]
            Number of invoices to return. Limit can range between 1 and 100, and the default is 10.

        starting_after : typing.Optional[InvoiceId]
            The ID of the invoice to start after. If not provided, the first page of invoices will be returned.

        metadata : typing.Optional[typing.Union[MetadataFilter, typing.Sequence[MetadataFilter]]]
            Filter invoices by metadata. Each filter will be applied as an AND condition. Duplicate keys will be ignored.

        line_item_metadata : typing.Optional[typing.Union[MetadataFilter, typing.Sequence[MetadataFilter]]]
            Filter invoices by line item metadata. Each filter will be applied as an AND condition. Duplicate keys will be ignored.

        line_item_gl_account_id : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            Filter invoices by line item GL account ID. Each filter will be applied as an OR condition. Duplicate keys will be ignored.

        search : typing.Optional[str]
            Find invoices by vendor name, invoice number, check number, or amount. Partial matches are supported.

        payer_id : typing.Optional[typing.Union[EntityId, typing.Sequence[EntityId]]]
            Filter invoices by payer ID or payer foreign ID.

        vendor_id : typing.Optional[typing.Union[EntityId, typing.Sequence[EntityId]]]
            Filter invoices by vendor ID or vendor foreign ID.

        creator_user_id : typing.Optional[typing.Union[EntityUserId, typing.Sequence[EntityUserId]]]
            Filter invoices by the ID or foreign ID of the user that created the invoice.

        approver_id : typing.Optional[typing.Union[EntityUserId, typing.Sequence[EntityUserId]]]
            Filter invoices by assigned approver user ID.

        approver_action : typing.Optional[typing.Union[ApproverAction, typing.Sequence[ApproverAction]]]
            Filter invoices by approver action. Needs to be used with approverId. For example, if you want to find all invoices that have been approved by a specific user, you would use approverId and approverAction=APPROVE.

        approver_count : typing.Optional[str]
            Filter invoices by the number of approvers. Use exact number (e.g., 3) or range (e.g., ">3", "<5", ">=2", "<=4").

        invoice_id : typing.Optional[typing.Union[InvoiceId, typing.Sequence[InvoiceId]]]
            Filter invoices by invoice ID or invoice foreign ID.

        status : typing.Optional[typing.Union[InvoiceStatus, typing.Sequence[InvoiceStatus]]]
            Invoice status to filter on.

        payment_type : typing.Optional[typing.Sequence[PaymentType]]
            Filter invoices by payment type.

        return_payer_metadata : typing.Optional[bool]
            Whether to return payer metadata in the response

        return_vendor_metadata : typing.Optional[bool]
            Whether to return vendor metadata in the response

        return_payment_timing : typing.Optional[bool]
            Whether to return payment timing in the response

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[FindInvoiceResponse]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"entity/{jsonable_encoder(entity_id)}/invoices",
            method="GET",
            params={
                "excludePayables": exclude_payables,
                "excludeReceivables": exclude_receivables,
                "startDate": serialize_datetime(start_date) if start_date is not None else None,
                "endDate": serialize_datetime(end_date) if end_date is not None else None,
                "dateType": date_type,
                "orderBy": order_by,
                "orderDirection": order_direction,
                "limit": limit,
                "startingAfter": starting_after,
                "metadata": convert_and_respect_annotation_metadata(
                    object_=metadata, annotation=MetadataFilter, direction="write"
                ),
                "lineItemMetadata": convert_and_respect_annotation_metadata(
                    object_=line_item_metadata, annotation=MetadataFilter, direction="write"
                ),
                "lineItemGlAccountId": line_item_gl_account_id,
                "search": search,
                "payerId": payer_id,
                "vendorId": vendor_id,
                "creatorUserId": creator_user_id,
                "approverId": approver_id,
                "approverAction": approver_action,
                "approverCount": approver_count,
                "invoiceId": invoice_id,
                "status": status,
                "paymentType": payment_type,
                "returnPayerMetadata": return_payer_metadata,
                "returnVendorMetadata": return_vendor_metadata,
                "returnPaymentTiming": return_payment_timing,
            },
            request_options=request_options,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        if 200 <= _response.status_code < 300:
            _data = typing.cast(
                FindInvoiceResponse,
                parse_obj_as(
                    type_=FindInvoiceResponse,  # type: ignore
                    object_=_response_json,
                ),
            )
            return AsyncHttpResponse(response=_response, data=_data)
        if "errorName" in _response_json:
            if _response_json["errorName"] == "BadRequest":
                raise BadRequest(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        str,
                        parse_obj_as(
                            type_=str,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
            if _response_json["errorName"] == "Unauthorized":
                raise Unauthorized(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        str,
                        parse_obj_as(
                            type_=str,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
            if _response_json["errorName"] == "Forbidden":
                raise Forbidden(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        str,
                        parse_obj_as(
                            type_=str,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
            if _response_json["errorName"] == "NotFound":
                raise NotFound(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        str,
                        parse_obj_as(
                            type_=str,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
            if _response_json["errorName"] == "Conflict":
                raise Conflict(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        str,
                        parse_obj_as(
                            type_=str,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
            if _response_json["errorName"] == "InternalServerError":
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        str,
                        parse_obj_as(
                            type_=str,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
            if _response_json["errorName"] == "Unimplemented":
                raise Unimplemented(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        str,
                        parse_obj_as(
                            type_=str,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def metrics(
        self,
        entity_id: EntityId,
        *,
        search: typing.Optional[str] = None,
        exclude_payables: typing.Optional[bool] = None,
        exclude_receivables: typing.Optional[bool] = None,
        return_by_date: typing.Optional[InvoiceMetricsPerDateGroupBy] = None,
        return_by_date_frequency: typing.Optional[InvoiceMetricsPerDateFrequency] = None,
        group_by: typing.Optional[typing.Union[InvoiceMetricsGroupBy, typing.Sequence[InvoiceMetricsGroupBy]]] = None,
        payer_id: typing.Optional[typing.Union[EntityId, typing.Sequence[EntityId]]] = None,
        vendor_id: typing.Optional[typing.Union[EntityId, typing.Sequence[EntityId]]] = None,
        approver_id: typing.Optional[typing.Union[EntityUserId, typing.Sequence[EntityUserId]]] = None,
        approver_count: typing.Optional[str] = None,
        invoice_id: typing.Optional[typing.Union[InvoiceId, typing.Sequence[InvoiceId]]] = None,
        status: typing.Optional[typing.Union[InvoiceStatus, typing.Sequence[InvoiceStatus]]] = None,
        start_date: typing.Optional[dt.datetime] = None,
        end_date: typing.Optional[dt.datetime] = None,
        date_type: typing.Optional[InvoiceDateFilter] = None,
        currency: typing.Optional[typing.Union[CurrencyCode, typing.Sequence[CurrencyCode]]] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.List[InvoiceMetricsResponse]]:
        """
        Get invoice metrics for an entity with the given filters. Invoices will always be grouped by currency. If none of excludePayables, excludeReceivables, payerId, vendorId, or invoiceId status filters are provided, excludeReceivables will be set to true.

        Parameters
        ----------
        entity_id : EntityId
            Entity ID or Entity ForeignID

        search : typing.Optional[str]
            Find invoices by vendor name, invoice number, check number, or amount. Partial matches are supported.

        exclude_payables : typing.Optional[bool]
            Only return invoices that are not payable by the entity. This will return only invoices that are receivable by the entity.

        exclude_receivables : typing.Optional[bool]
            Only return invoices that are not receivable by the entity. This will return only invoices that are payable by the entity.

        return_by_date : typing.Optional[InvoiceMetricsPerDateGroupBy]
            Return invoice metrics grouped by date.

        return_by_date_frequency : typing.Optional[InvoiceMetricsPerDateFrequency]
            Return invoice metrics grouped by date. Defaults to daily.

        group_by : typing.Optional[typing.Union[InvoiceMetricsGroupBy, typing.Sequence[InvoiceMetricsGroupBy]]]
            Return invoice metrics grouped by.

        payer_id : typing.Optional[typing.Union[EntityId, typing.Sequence[EntityId]]]
            Filter invoices by payer ID.

        vendor_id : typing.Optional[typing.Union[EntityId, typing.Sequence[EntityId]]]
            Filter invoices by vendor ID.

        approver_id : typing.Optional[typing.Union[EntityUserId, typing.Sequence[EntityUserId]]]
            Filter invoices by assigned approver user ID.

        approver_count : typing.Optional[str]
            Filter invoices by the number of approvers. Use exact number (e.g., 3) or range (e.g., ">3", "<5", ">=2", "<=4").

        invoice_id : typing.Optional[typing.Union[InvoiceId, typing.Sequence[InvoiceId]]]
            Filter invoices by invoice ID or invoice foreign ID.

        status : typing.Optional[typing.Union[InvoiceStatus, typing.Sequence[InvoiceStatus]]]
            Invoice status to filter on

        start_date : typing.Optional[dt.datetime]
            Start date filter. Defaults to CREATED_AT unless specified the dateType is specified

        end_date : typing.Optional[dt.datetime]
            End date filter. Defaults to CREATED_AT unless specified the dateType is specified

        date_type : typing.Optional[InvoiceDateFilter]
            Type of date to filter by if startDate and endDate filters are provided. Defaults to CREATED_AT.

        currency : typing.Optional[typing.Union[CurrencyCode, typing.Sequence[CurrencyCode]]]
            Currency to filter on

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[InvoiceMetricsResponse]]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"entity/{jsonable_encoder(entity_id)}/invoice-metrics",
            method="GET",
            params={
                "search": search,
                "excludePayables": exclude_payables,
                "excludeReceivables": exclude_receivables,
                "returnByDate": return_by_date,
                "returnByDateFrequency": return_by_date_frequency,
                "groupBy": group_by,
                "payerId": payer_id,
                "vendorId": vendor_id,
                "approverId": approver_id,
                "approverCount": approver_count,
                "invoiceId": invoice_id,
                "status": status,
                "startDate": serialize_datetime(start_date) if start_date is not None else None,
                "endDate": serialize_datetime(end_date) if end_date is not None else None,
                "dateType": date_type,
                "currency": currency,
            },
            request_options=request_options,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        if 200 <= _response.status_code < 300:
            _data = typing.cast(
                typing.List[InvoiceMetricsResponse],
                parse_obj_as(
                    type_=typing.List[InvoiceMetricsResponse],  # type: ignore
                    object_=_response_json,
                ),
            )
            return AsyncHttpResponse(response=_response, data=_data)
        if "errorName" in _response_json:
            if _response_json["errorName"] == "BadRequest":
                raise BadRequest(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        str,
                        parse_obj_as(
                            type_=str,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
            if _response_json["errorName"] == "Unauthorized":
                raise Unauthorized(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        str,
                        parse_obj_as(
                            type_=str,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
            if _response_json["errorName"] == "Forbidden":
                raise Forbidden(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        str,
                        parse_obj_as(
                            type_=str,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
            if _response_json["errorName"] == "NotFound":
                raise NotFound(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        str,
                        parse_obj_as(
                            type_=str,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
            if _response_json["errorName"] == "Conflict":
                raise Conflict(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        str,
                        parse_obj_as(
                            type_=str,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
            if _response_json["errorName"] == "InternalServerError":
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        str,
                        parse_obj_as(
                            type_=str,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
            if _response_json["errorName"] == "Unimplemented":
                raise Unimplemented(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        str,
                        parse_obj_as(
                            type_=str,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def download(
        self,
        entity_id: EntityId,
        *,
        format: typing.Optional[BulkDownloadFormat] = None,
        exclude_payables: typing.Optional[bool] = None,
        exclude_receivables: typing.Optional[bool] = None,
        start_date: typing.Optional[dt.datetime] = None,
        end_date: typing.Optional[dt.datetime] = None,
        date_type: typing.Optional[InvoiceDateFilter] = None,
        order_by: typing.Optional[InvoiceOrderByField] = None,
        order_direction: typing.Optional[OrderDirection] = None,
        search: typing.Optional[str] = None,
        metadata: typing.Optional[typing.Union[MetadataFilter, typing.Sequence[MetadataFilter]]] = None,
        line_item_metadata: typing.Optional[typing.Union[MetadataFilter, typing.Sequence[MetadataFilter]]] = None,
        line_item_gl_account_id: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        payer_id: typing.Optional[typing.Union[EntityId, typing.Sequence[EntityId]]] = None,
        vendor_id: typing.Optional[typing.Union[EntityId, typing.Sequence[EntityId]]] = None,
        creator_user_id: typing.Optional[typing.Union[EntityUserId, typing.Sequence[EntityUserId]]] = None,
        approver_id: typing.Optional[typing.Union[EntityUserId, typing.Sequence[EntityUserId]]] = None,
        approver_action: typing.Optional[typing.Union[ApproverAction, typing.Sequence[ApproverAction]]] = None,
        invoice_id: typing.Optional[typing.Union[InvoiceId, typing.Sequence[InvoiceId]]] = None,
        status: typing.Optional[typing.Union[InvoiceStatus, typing.Sequence[InvoiceStatus]]] = None,
        payment_type: typing.Optional[typing.Sequence[PaymentType]] = None,
        return_payer_metadata: typing.Optional[bool] = None,
        return_vendor_metadata: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[BulkDownloadResponse]:
        """
        Get a URL to download invoices for an entity as a CSV/JSON file.

        Parameters
        ----------
        entity_id : EntityId
            Entity ID or Entity ForeignID

        format : typing.Optional[BulkDownloadFormat]
            Format of the file to download. Defaults to CSV.

        exclude_payables : typing.Optional[bool]
            Return only invoices that are receivable by the entity.

        exclude_receivables : typing.Optional[bool]
            Return only invoices that are payable by the entity.

        start_date : typing.Optional[dt.datetime]
            Start date filter. Defaults to CREATED_AT unless specified the dateType is specified

        end_date : typing.Optional[dt.datetime]
            End date filter. Defaults to CREATED_AT unless specified the dateType is specified

        date_type : typing.Optional[InvoiceDateFilter]
            Type of date to filter by if startDate and endDate filters are provided. Defaults to CREATED_AT.

        order_by : typing.Optional[InvoiceOrderByField]
            Field to order invoices by. Defaults to CREATED_AT.

        order_direction : typing.Optional[OrderDirection]
            Direction to order invoices by. Defaults to asc.

        search : typing.Optional[str]
            Find invoices by vendor name, invoice number, check number, or amount. Partial matches are supported.

        metadata : typing.Optional[typing.Union[MetadataFilter, typing.Sequence[MetadataFilter]]]
            Filter invoices by metadata. Each filter will be applied as an AND condition. Duplicate keys will be ignored.

        line_item_metadata : typing.Optional[typing.Union[MetadataFilter, typing.Sequence[MetadataFilter]]]
            Filter invoices by line item metadata. Each filter will be applied as an AND condition. Duplicate keys will be ignored.

        line_item_gl_account_id : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            Filter invoices by line item GL account ID. Each filter will be applied as an OR condition. Duplicate keys will be ignored.

        payer_id : typing.Optional[typing.Union[EntityId, typing.Sequence[EntityId]]]
            Filter invoices by payer ID or payer foreign ID.

        vendor_id : typing.Optional[typing.Union[EntityId, typing.Sequence[EntityId]]]
            Filter invoices by vendor ID or vendor foreign ID.

        creator_user_id : typing.Optional[typing.Union[EntityUserId, typing.Sequence[EntityUserId]]]
            Filter invoices by the ID or foreign ID of the user that created the invoice.

        approver_id : typing.Optional[typing.Union[EntityUserId, typing.Sequence[EntityUserId]]]
            Filter invoices by assigned approver user ID.

        approver_action : typing.Optional[typing.Union[ApproverAction, typing.Sequence[ApproverAction]]]
            Filter invoices by approver action. Needs to be used with approverId. For example, if you want to find all invoices that have been approved by a specific user, you would use approverId and approverAction=APPROVE.

        invoice_id : typing.Optional[typing.Union[InvoiceId, typing.Sequence[InvoiceId]]]
            Filter invoices by invoice ID or invoice foreign ID.

        status : typing.Optional[typing.Union[InvoiceStatus, typing.Sequence[InvoiceStatus]]]
            Invoice status to filter on.

        payment_type : typing.Optional[typing.Sequence[PaymentType]]
            Filter invoices by payment type.

        return_payer_metadata : typing.Optional[bool]
            Whether to return payer metadata in the response

        return_vendor_metadata : typing.Optional[bool]
            Whether to return vendor metadata in the response

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[BulkDownloadResponse]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"entity/{jsonable_encoder(entity_id)}/invoices/download",
            method="GET",
            params={
                "format": format,
                "excludePayables": exclude_payables,
                "excludeReceivables": exclude_receivables,
                "startDate": serialize_datetime(start_date) if start_date is not None else None,
                "endDate": serialize_datetime(end_date) if end_date is not None else None,
                "dateType": date_type,
                "orderBy": order_by,
                "orderDirection": order_direction,
                "search": search,
                "metadata": convert_and_respect_annotation_metadata(
                    object_=metadata, annotation=MetadataFilter, direction="write"
                ),
                "lineItemMetadata": convert_and_respect_annotation_metadata(
                    object_=line_item_metadata, annotation=MetadataFilter, direction="write"
                ),
                "lineItemGlAccountId": line_item_gl_account_id,
                "payerId": payer_id,
                "vendorId": vendor_id,
                "creatorUserId": creator_user_id,
                "approverId": approver_id,
                "approverAction": approver_action,
                "invoiceId": invoice_id,
                "status": status,
                "paymentType": payment_type,
                "returnPayerMetadata": return_payer_metadata,
                "returnVendorMetadata": return_vendor_metadata,
            },
            request_options=request_options,
        )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        if 200 <= _response.status_code < 300:
            _data = typing.cast(
                BulkDownloadResponse,
                parse_obj_as(
                    type_=BulkDownloadResponse,  # type: ignore
                    object_=_response_json,
                ),
            )
            return AsyncHttpResponse(response=_response, data=_data)
        if "errorName" in _response_json:
            if _response_json["errorName"] == "BadRequest":
                raise BadRequest(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        str,
                        parse_obj_as(
                            type_=str,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
            if _response_json["errorName"] == "Unauthorized":
                raise Unauthorized(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        str,
                        parse_obj_as(
                            type_=str,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
            if _response_json["errorName"] == "Forbidden":
                raise Forbidden(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        str,
                        parse_obj_as(
                            type_=str,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
            if _response_json["errorName"] == "NotFound":
                raise NotFound(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        str,
                        parse_obj_as(
                            type_=str,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
            if _response_json["errorName"] == "Conflict":
                raise Conflict(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        str,
                        parse_obj_as(
                            type_=str,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
            if _response_json["errorName"] == "InternalServerError":
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        str,
                        parse_obj_as(
                            type_=str,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
            if _response_json["errorName"] == "Unimplemented":
                raise Unimplemented(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        str,
                        parse_obj_as(
                            type_=str,  # type: ignore
                            object_=_response_json["content"],
                        ),
                    ),
                )
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)
