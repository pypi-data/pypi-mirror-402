from __future__ import annotations

from typing import TYPE_CHECKING, cast, Literal

from hpcflow.sdk.core.enums import InputSourceType, TaskSourceType
from hpcflow.sdk.core.errors import NoAvailableElementSetsError
from hpcflow.sdk.core.utils import get_relative_path, split_param_label
from hpcflow.sdk.core.errors import (
    InapplicableInputSourceElementIters,
    UnavailableInputSource,
)

if TYPE_CHECKING:
    from collections.abc import Sequence
    from .parameters import InputSource
    from .task import WorkflowTask, Task
    from ..app import BaseApp
    from .element import ElementParameter, _ElementPrefixedParameter as EPP
    from .rule import Rule
    from .workflow import Workflow


def get_task_out_available_src_insert_idx(
    app,
    param_typ: str,
    existing_sources: list[InputSource],
    source_tasks: Sequence[WorkflowTask] = (),
) -> int:
    """Decide where to place a new task-output input source in the list of available
    sources.

    Available sources should be ordered by precedence. In general, task-type input
    sources from tasks closer to the new task should take precedence, and for
    task-type input sources from a given task, task-output sources should take
    precedence over task-input sources. However, task-output sources that are further
    away (more upstream) should also take precedence over task-input source that are
    closer (more downstream) in the case where the task-input sources do not point to
    any local inputs.

    For example, consider finding the list of available input sources for task t3,
    given these tasks and input/output parameters:

    t1: p1 -> p2
    t2: p2 -> p3
    t3: p2 -> p4

    There are two possible sources for p2 in task t3: t1(output) and t2(input). If the
    input source of p2 within task t2 is t1(output) as well, it makes sense for the
    t1(output) source for p2 in task t3 to take precedence over the t2(input) source.
    For example, we might define a sequence on task t2, which would mean the input
    source t2(input) for p2 in t3 would then have multiple values, which could be
    unexpected, given that only one value was generated by t1. On the other hand, if
    the user include some local input source for p2 within task t2 (a single value or
    a sequence, perhaps combined with other sources), then it arguably makes more
    sense for the t2(input) source to take precedence, because it is explicitly
    defined.

    """
    src_tasks = {task.insert_ID: task for task in source_tasks}
    num_existing = len(existing_sources)
    new_idx = num_existing
    for rev_idx, ex_src in enumerate(existing_sources[::-1]):

        # stop once we reach another task-output source or a local source:
        if (
            ex_src.task_source_type == TaskSourceType.OUTPUT
            or ex_src.source_type == InputSourceType.LOCAL
        ):
            return num_existing - rev_idx

        elif ex_src.task_source_type == TaskSourceType.INPUT:
            assert ex_src.task_ref is not None
            has_local = app.InputSource.local() in [
                src
                for es in src_tasks[ex_src.task_ref].template.element_sets
                for src in es.input_sources.get(param_typ, [])
            ]
            if has_local:
                return num_existing - rev_idx
            else:
                # new task-output source should be inserted before this task-input
                # source, even though the task-input source is closer to the new task:
                new_idx = num_existing - rev_idx - 1

    return new_idx


def __get_common_path(labelled_path: str, inputs_path: str) -> str | None:
    lab_s = labelled_path.split(".")
    inp_s = inputs_path.split(".")
    try:
        get_relative_path(lab_s, inp_s)
        return labelled_path
    except ValueError:
        pass
    try:
        get_relative_path(inp_s, lab_s)
        return inputs_path
    except ValueError:
        # no intersection between paths
        return None


def __filtered_iters(wk_task: WorkflowTask, where: Rule) -> list[int]:
    param_path = cast("str", where.path)
    param_prefix, param_name, *param_tail = param_path.split(".")
    src_elem_iters: list[int] = []

    for elem in wk_task.elements:
        params: EPP = getattr(elem, param_prefix)
        param: ElementParameter = getattr(params, param_name)
        param_dat = param.value

        # for remaining paths components try both getattr and
        # getitem:
        for path_k in param_tail:
            try:
                param_dat = param_dat[path_k]
            except TypeError:
                param_dat = getattr(param_dat, path_k)

        if where._valida_check(param_dat):
            src_elem_iters.append(elem.iterations[0].id_)

    return src_elem_iters


def get_task_source_element_iters(
    in_or_out: Literal["input", "output", "any"],
    src_task: Task,
    labelled_path: str,
    sourceable_elem_iters: list[int] | None,
) -> list[int]:
    """Get a sorted list of element iteration IDs that provide either inputs or
    outputs from the provided source task."""

    if in_or_out == "input":
        # input parameter might not be provided e.g. if it is only used
        # to generate an input file, and that input file is passed
        # directly, so consider only source task element sets that
        # provide the input locally:
        es_idx = src_task.get_param_provided_element_sets(labelled_path)
        for es_i in src_task.element_sets:
            # add any element set that has task sources for this parameter
            es_i_idx = es_i.index
            if (
                es_i_idx is not None
                and es_i_idx not in es_idx
                and any(
                    inp_src_i.source_type is InputSourceType.TASK
                    for inp_src_i in es_i.input_sources.get(labelled_path, ())
                )
            ):
                es_idx.append(es_i_idx)
    else:
        # outputs are always available, so consider all source task
        # element sets:
        es_idx = list(range(src_task.num_element_sets))

    if not es_idx:
        raise NoAvailableElementSetsError()

    src_elem_iters: list[int] = []
    for es_i_idx in es_idx:
        es_i = src_task.element_sets[es_i_idx]
        src_elem_iters.extend(es_i.elem_iter_IDs)  # should be sorted already

    if sourceable_elem_iters is not None:
        # can only use a subset of element iterations (this is the
        # case where this element set is generated from an upstream
        # element set, in which case we only want to consider newly
        # added upstream elements when adding elements from this
        # element set):
        src_elem_iters = sorted(set(sourceable_elem_iters).intersection(src_elem_iters))

    return src_elem_iters


def get_available_task_sources(
    app: BaseApp,
    inputs_path: str,
    source_tasks: list[WorkflowTask],
    available: dict[str, list[InputSource]],
    sourceable_elem_iters: list[int] | None = None,
):
    """Locate possible task-type sources for the specified input parameter."""
    for src_wk_task_i in source_tasks:
        # ensure we process output types before input types, so they appear in the
        # available sources list first, meaning they take precedence when choosing
        # an input source:
        src_task_i = src_wk_task_i.template
        for in_or_out, labelled_path in sorted(
            src_task_i.provides_parameters(),
            key=lambda x: x[0],
            reverse=True,
        ):
            src_elem_iters: list[int] = []
            common = __get_common_path(labelled_path, inputs_path)
            if common is not None:
                avail_src_path = common
            else:
                # no intersection between paths
                inputs_path_label = None
                out_label = None
                unlabelled, inputs_path_label = split_param_label(inputs_path)
                if unlabelled is None:
                    continue
                try:
                    get_relative_path(unlabelled.split("."), labelled_path.split("."))
                    avail_src_path = inputs_path
                except ValueError:
                    continue
                if not inputs_path_label:
                    continue
                for out_lab_i in src_task_i.output_labels:
                    if out_lab_i.label == inputs_path_label:
                        out_label = out_lab_i

                # consider output labels
                if out_label and in_or_out == "output":
                    # find element iteration IDs that match the output label
                    # filter:
                    if out_label.where:
                        src_elem_iters = __filtered_iters(src_wk_task_i, out_label.where)
                    else:
                        src_elem_iters = [
                            elem_i.iterations[0].id_ for elem_i in src_wk_task_i.elements
                        ]

            if not src_elem_iters:
                try:
                    src_elem_iters = get_task_source_element_iters(
                        in_or_out=in_or_out,
                        src_task=src_task_i,
                        labelled_path=labelled_path,
                        sourceable_elem_iters=sourceable_elem_iters,
                    )
                except NoAvailableElementSetsError:
                    continue
                if not src_elem_iters:
                    continue

            if in_or_out == "output":
                insert_idx = get_task_out_available_src_insert_idx(
                    app=app,
                    existing_sources=available.get(avail_src_path, []),
                    source_tasks=source_tasks,
                    param_typ=avail_src_path,
                )
            else:
                insert_idx = len(available.get(avail_src_path, []))

            available.setdefault(avail_src_path, []).insert(
                insert_idx,
                app.InputSource.task(
                    task_ref=src_task_i.insert_ID,
                    task_source_type=in_or_out,
                    element_iters=src_elem_iters,
                ),
            )


def validate_specified_source(
    specified: InputSource,
    available: Sequence[InputSource],
    workflow: Workflow,
    input_path: str,
    task_uq_name: str = "",
) -> InputSource:
    """Check a specified input source is valid, given the list of available sources."""

    workflow._resolve_input_source_task_reference(specified, task_uq_name)
    workflow.template._resolve_input_source_import_reference(specified)
    avail_idx = specified.is_in(available)
    if avail_idx is None:
        raise UnavailableInputSource(specified, input_path, available)
    valid_src: InputSource
    try:
        valid_src = available[avail_idx]
    except TypeError:
        raise UnavailableInputSource(specified, input_path, available) from None

    elem_iters_IDs = valid_src.element_iters
    if specified.element_iters:
        # user-specified iter IDs; these must be a subset of available
        # element_iters:
        if not set(specified.element_iters).issubset(elem_iters_IDs or ()):
            raise InapplicableInputSourceElementIters(specified, elem_iters_IDs)
        elem_iters_IDs = specified.element_iters

    if specified.where:
        # filter iter IDs by user-specified rules, maintaining order:
        elem_iters = workflow.get_element_iterations_from_IDs(elem_iters_IDs or ())
        elem_iters_IDs = [ei.id_ for ei in specified.where.filter(elem_iters)]

    valid_src.element_iters = elem_iters_IDs
    return valid_src
