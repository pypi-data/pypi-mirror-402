#!/usr/bin/env python3

###########################################################################################
#  package:   Gtools
#  file:      ggetZiforCosmoSims
#  brief:
#  copyright: GPLv3
#             Copyright (C) 2019 EPFL (Ecole Polytechnique Federale de Lausanne)
#             LASTRO - Laboratory of Astrophysics of EPFL
#  author:    Yves Revaz <yves.revaz@epfl.ch>
#
# This file is part of Gtools.
###########################################################################################


import argparse

import numpy as np
import scipy.integrate as si
from scipy import optimize

from pNbody import units, plot
from pNbody.Cosmology import cosmicpy


def parse_options():
    """
    Parse command-line options.

    Returns
    -------
    tuple
        A tuple containing the list of input files and the parsed options namespace.
    """

    description = "Compute initial redshift (zinit) for a cosmological simulation."
    examples = """
Examples
--------
# Example 1: High-resolution zoom-in with N1=1024 and N2=16384 in a small box (L=6.884 Mpc/h)
#            Also specifies the code units for pNbody.
cosmo_getZiforCosmoSims \\
    --N1 1024 --N2 16384 -L 6.884 \\
    --UnitLength_in_cm 3.0856775814913673e+21 \\
    --UnitMass_in_g 1.988409870698051e+43 \\
    --UnitVelocity_in_cm_per_s 1e5

# Example 2: Ultra high-resolution zoom-in (N2=32768)
cosmo_getZiforCosmoSims \\
    --N1 1024 --N2 32768 -L 6.884 \\
    --UnitLength_in_cm 3.0856775814913673e+21 \\
    --UnitMass_in_g 1.988409870698051e+43 \\
    --UnitVelocity_in_cm_per_s 1e5
    """
    parser = argparse.ArgumentParser(description=description,
                                     epilog=examples,
                                     formatter_class=argparse.RawDescriptionHelpFormatter)

    parser.add_argument(
        "--N1",
        action="store",
        dest="N1",
        type=float,
        default=512,
        help="Number of particles for the highest level along one dimension.",
    )

    parser.add_argument(
        "--N2",
        action="store",
        dest="N2",
        type=float,
        default=None,
        help="Number of particles for the second level along one dimension (if multi-resolution).",
    )

    parser.add_argument(
        "-L",
        action="store",
        dest="L",
        type=float,
        default=100,
        help="Box size in Mpc/h.",
    )

    # Cosmological parameters
    parser.add_argument(
        "--sigma8",
        action="store",
        dest="sigma8",
        type=float,
        default=0.829,
        help="Density fluctuation amplitude on 8 Mpc/h scale (sigma8).",
    )

    parser.add_argument(
        "--n",
        action="store",
        dest="n",
        type=float,
        default=0.9603,
        help="Primordial power spectrum index (n).",
    )

    parser.add_argument("--Omega_b",
                        action="store",
                        dest="Omega_b",
                        type=float,
                        default=0.0486,
                        help="Baryon density parameter (Omega_b)")

    parser.add_argument("--Omega_m",
                        action="store",
                        dest="Omega_m",
                        type=float,
                        default=0.315,
                        help="Matter density parameter (Omega_m)")

    parser.add_argument("--Omega_de",
                        action="store",
                        dest="Omega_de",
                        type=float,
                        default=0.685,
                        help="Dark energy density parameter (Omega_de)")

    parser.add_argument("--h",
                        action="store",
                        dest="h",
                        type=float,
                        default=0.673,
                        help="Hubble parameter (h)")

    parser = plot.add_arguments_units(parser)

    options = parser.parse_args()

    return options


########################################################################
# MAIN
########################################################################


def MakePlot(opt):
    # Define local units
    unit_params = plot.apply_arguments_units(opt)
    system_of_units = units.Set_SystemUnits_From_Params(unit_params)

    # convert a to Myrs
    out_units = units.UnitSystem(
        "local", [units.Unit_cm, units.Unit_Msol, units.Unit_Myr, units.Unit_K]
    )

    kwargs = {}

    if opt.h is not None:
        kwargs["h"]       = opt.h
    else:
        kwargs["h"] = unit_params["HubbleParam"]

    if opt.Omega_b is not None:
        kwargs["Omega_b"] = opt.Omega_b
    else:
        kwargs["Omega_b"] = unit_params["OmegaBaryon"]

    if opt.Omega_m is not None:
        kwargs["Omega_m"] = opt.Omega_m
    else:
        kwargs["Omega_m"] = unit_params["Omega0"]

    if opt.Omega_de is not None:
        kwargs["Omega_de"]= opt.Omega_de
    else:
        kwargs["Omega_de"] = unit_params["OmegaLambda"]

    kwargs["n"]       = opt.n
    kwargs["sigma8"]  = opt.sigma8

    cosmo = cosmicpy.cosmology(**kwargs)

    def _sigmasq_integrand_log_l(logk, z):
        """Integrand used internally by the sigma_r function."""
        k = np.exp(logk)
        # The 1e-10 factor in the integrand is added to avoid roundoff
        # error warnings. It is divided out later.

        # print k,power_spectrum(k, z, **cosmology),z

        a = cosmicpy.z2a(z)

        return (
            k
            * (1.0e-10 / (2.0 * np.pi**2.0))
            * k**2.0
            * cosmo.pk_lin(k, a, type="eisenhu")
        )

    def compute_Sigma(kmin, kmax, z):

        # Integrate over logk from -infinity to infinity.
        integral, _ = si.quad(
            _sigmasq_integrand_log_l, np.log(kmin), np.log(kmax), args=(z), limit=10000
        )  # , epsabs=1e-9, epsrel=1e-9)

        sigma = np.sqrt(1.0e10 * integral)

        return sigma

    def getZ(z, kmin, kmax, sigma):
        return compute_Sigma(kmin, kmax, z) - sigma

    #######################
    # first level
    #######################

    kmin = 2 * np.pi / opt.L
    kmax = np.pi * opt.N1 / opt.L

    zi1 = optimize.bisect(
        getZ, a=5, b=500, args=(kmin, kmax, 0.1), xtol=1e-3, maxiter=500
    )
    zi2 = optimize.bisect(
        getZ, a=5, b=500, args=(kmin, kmax, 0.2), xtol=1e-3, maxiter=500
    )

    print(("N=%5d zinit(max)=%5.1f zinit(min)=%5.1f" % (opt.N1, zi1, zi2)))

    #######################
    # second level
    #######################

    if opt.N2 is not None:

        kmin = 2 * np.pi / opt.L
        kmax = np.pi * opt.N2 / opt.L

        zi1b = optimize.bisect(
            getZ, a=5, b=500, args=(kmin, kmax, 0.1), xtol=1e-3, maxiter=500
        )
        zi2b = optimize.bisect(
            getZ, a=5, b=500, args=(kmin, kmax, 0.2), xtol=1e-3, maxiter=500
        )

        print(("N=%5d zinit(max)=%5.1f zinit(min)=%5.1f" % (opt.N2, zi1b, zi2b)))

        # find the intersection
        print()
        if opt.N1 < opt.N2:
            print(("zinit should be in [%5.1f,%5.1f]" % (zi2b, zi1)))
        else:
            print(("zinit should be in [%5.1f,%5.1f]" % (zi2, zi1b)))
            print()


if __name__ == "__main__":
    opt = parse_options()

    # opt.N1 = int(opt.N1)
    # opt.N2 = int(opt.N2)

    MakePlot(opt)
