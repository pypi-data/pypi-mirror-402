# This file was auto-generated by Fern from our API Definition.

import typing
from json.decoder import JSONDecodeError

from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.http_response import AsyncHttpResponse, HttpResponse
from ..core.pydantic_utilities import parse_obj_as
from ..core.request_options import RequestOptions
from ..core.serialization import convert_and_respect_annotation_metadata
from ..errors.bad_request_error import BadRequestError
from ..errors.conflict_error import ConflictError
from ..errors.forbidden_error import ForbiddenError
from ..errors.internal_server_error import InternalServerError
from ..errors.not_found_error import NotFoundError
from ..errors.unauthorized_error import UnauthorizedError
from ..types.conflict_error_body import ConflictErrorBody
from ..types.error_response import ErrorResponse
from .types.add_domain_provisioning_response import AddDomainProvisioningResponse
from .types.change_plan_provisioning_response import ChangePlanProvisioningResponse
from .types.create_provisioning_response import CreateProvisioningResponse
from .types.create_webhook_provisioning_response import CreateWebhookProvisioningResponse
from .types.delete_provisioning_response import DeleteProvisioningResponse
from .types.delete_webhook_provisioning_response import DeleteWebhookProvisioningResponse
from .types.export_data_provisioning_response import ExportDataProvisioningResponse
from .types.get_billing_provisioning_response import GetBillingProvisioningResponse
from .types.get_ownership_provisioning_response import GetOwnershipProvisioningResponse
from .types.get_usage_provisioning_response import GetUsageProvisioningResponse
from .types.invite_team_provisioning_request_members_item import InviteTeamProvisioningRequestMembersItem
from .types.invite_team_provisioning_response import InviteTeamProvisioningResponse
from .types.list_domains_provisioning_response import ListDomainsProvisioningResponse
from .types.list_provisioning_response import ListProvisioningResponse
from .types.list_team_provisioning_response import ListTeamProvisioningResponse
from .types.list_webhooks_provisioning_response import ListWebhooksProvisioningResponse
from .types.login_provisioning_response import LoginProvisioningResponse
from .types.regenerate_api_key_provisioning_response import RegenerateApiKeyProvisioningResponse
from .types.register_provisioning_response import RegisterProvisioningResponse
from .types.remove_domain_provisioning_response import RemoveDomainProvisioningResponse
from .types.remove_team_member_provisioning_response import RemoveTeamMemberProvisioningResponse
from .types.transfer_ownership_provisioning_response import TransferOwnershipProvisioningResponse
from .types.update_provisioning_response import UpdateProvisioningResponse
from .types.update_webhook_provisioning_response import UpdateWebhookProvisioningResponse
from .types.upgrade_instance_plan import UpgradeInstancePlan

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawProvisioningClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def list(
        self,
        *,
        provisioning_key: str,
        handle: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[ListProvisioningResponse]:
        """
        Retrieve all instances owned by the authenticated user. Use the `handle` query parameter to get a single instance with its API key.

        Parameters
        ----------
        provisioning_key : str
            User provisioning key for platform-level instance management

        handle : typing.Optional[str]
            Optional handle to get a single instance

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ListProvisioningResponse]
            Success
        """
        _response = self._client_wrapper.httpx_client.request(
            "provisioning/instances",
            method="GET",
            params={
                "handle": handle,
            },
            headers={
                "x-provisioning-key": str(provisioning_key) if provisioning_key is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ListProvisioningResponse,
                    parse_obj_as(
                        type_=ListProvisioningResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def create(
        self, *, provisioning_key: str, name: str, handle: str, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[CreateProvisioningResponse]:
        """
        Create a new forum instance. Returns the instance details including the API key for accessing the forum API.

        Parameters
        ----------
        provisioning_key : str
            User provisioning key for platform-level instance management

        name : str
            Display name for the instance

        handle : str
            URL-friendly identifier (slug)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[CreateProvisioningResponse]
            Created
        """
        _response = self._client_wrapper.httpx_client.request(
            "provisioning/instances",
            method="POST",
            json={
                "name": name,
                "handle": handle,
            },
            headers={
                "content-type": "application/json",
                "x-provisioning-key": str(provisioning_key) if provisioning_key is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CreateProvisioningResponse,
                    parse_obj_as(
                        type_=CreateProvisioningResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def update(
        self,
        *,
        provisioning_key: str,
        handle: str,
        name: typing.Optional[str] = OMIT,
        new_handle: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[UpdateProvisioningResponse]:
        """
        Update an instance's name or handle. The `handle` field identifies which instance to update.

        Parameters
        ----------
        provisioning_key : str
            User provisioning key for platform-level instance management

        handle : str
            Current handle to identify the instance

        name : typing.Optional[str]
            New display name

        new_handle : typing.Optional[str]
            New URL-friendly identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[UpdateProvisioningResponse]
            Updated
        """
        _response = self._client_wrapper.httpx_client.request(
            "provisioning/instances",
            method="PUT",
            json={
                "handle": handle,
                "name": name,
                "newHandle": new_handle,
            },
            headers={
                "content-type": "application/json",
                "x-provisioning-key": str(provisioning_key) if provisioning_key is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    UpdateProvisioningResponse,
                    parse_obj_as(
                        type_=UpdateProvisioningResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def delete(
        self, *, provisioning_key: str, handle: str, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[DeleteProvisioningResponse]:
        """
        Permanently delete an instance. This action cannot be undone.

        Parameters
        ----------
        provisioning_key : str
            User provisioning key for platform-level instance management

        handle : str
            Handle of the instance to delete

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DeleteProvisioningResponse]
            Deleted
        """
        _response = self._client_wrapper.httpx_client.request(
            "provisioning/instances",
            method="DELETE",
            json={
                "handle": handle,
            },
            headers={
                "content-type": "application/json",
                "x-provisioning-key": str(provisioning_key) if provisioning_key is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DeleteProvisioningResponse,
                    parse_obj_as(
                        type_=DeleteProvisioningResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_billing(
        self, *, handle: str, provisioning_key: str, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[GetBillingProvisioningResponse]:
        """
        Retrieve billing and subscription information for an instance.

        Parameters
        ----------
        handle : str
            Instance handle

        provisioning_key : str
            User provisioning key for platform-level instance management

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetBillingProvisioningResponse]
            Success
        """
        _response = self._client_wrapper.httpx_client.request(
            "provisioning/instances/billing",
            method="GET",
            params={
                "handle": handle,
            },
            headers={
                "x-provisioning-key": str(provisioning_key) if provisioning_key is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetBillingProvisioningResponse,
                    parse_obj_as(
                        type_=GetBillingProvisioningResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def change_plan(
        self,
        *,
        provisioning_key: str,
        handle: str,
        plan: UpgradeInstancePlan,
        is_annual: typing.Optional[bool] = OMIT,
        return_url: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[ChangePlanProvisioningResponse]:
        """
        Change an instance's subscription plan. Returns a checkout URL for upgrades or a billing portal URL for downgrades.

        Parameters
        ----------
        provisioning_key : str
            User provisioning key for platform-level instance management

        handle : str
            Instance handle

        plan : UpgradeInstancePlan
            Target plan

        is_annual : typing.Optional[bool]
            Use annual billing (default: true)

        return_url : typing.Optional[str]
            URL to return to after checkout/portal

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ChangePlanProvisioningResponse]
            Success
        """
        _response = self._client_wrapper.httpx_client.request(
            "provisioning/instances/billing",
            method="POST",
            json={
                "handle": handle,
                "plan": plan,
                "isAnnual": is_annual,
                "returnUrl": return_url,
            },
            headers={
                "content-type": "application/json",
                "x-provisioning-key": str(provisioning_key) if provisioning_key is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ChangePlanProvisioningResponse,
                    parse_obj_as(
                        type_=ChangePlanProvisioningResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def regenerate_api_key(
        self, *, provisioning_key: str, handle: str, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[RegenerateApiKeyProvisioningResponse]:
        """
        Generate a new API key for the instance. The old key will be invalidated.

        Parameters
        ----------
        provisioning_key : str
            User provisioning key for platform-level instance management

        handle : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[RegenerateApiKeyProvisioningResponse]
            Success
        """
        _response = self._client_wrapper.httpx_client.request(
            "provisioning/instances/api-key",
            method="POST",
            json={
                "handle": handle,
            },
            headers={
                "content-type": "application/json",
                "x-provisioning-key": str(provisioning_key) if provisioning_key is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    RegenerateApiKeyProvisioningResponse,
                    parse_obj_as(
                        type_=RegenerateApiKeyProvisioningResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_usage(
        self, *, handle: str, provisioning_key: str, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[GetUsageProvisioningResponse]:
        """
        Retrieve usage statistics for an instance including API requests, storage, and content counts.

        Parameters
        ----------
        handle : str
            Instance handle

        provisioning_key : str
            User provisioning key for platform-level instance management

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetUsageProvisioningResponse]
            Success
        """
        _response = self._client_wrapper.httpx_client.request(
            "provisioning/instances/usage",
            method="GET",
            params={
                "handle": handle,
            },
            headers={
                "x-provisioning-key": str(provisioning_key) if provisioning_key is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetUsageProvisioningResponse,
                    parse_obj_as(
                        type_=GetUsageProvisioningResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def list_team(
        self, *, handle: str, provisioning_key: str, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[ListTeamProvisioningResponse]:
        """
        Retrieve all team members for an instance.

        Parameters
        ----------
        handle : str
            Instance handle

        provisioning_key : str
            User provisioning key for platform-level instance management

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ListTeamProvisioningResponse]
            Success
        """
        _response = self._client_wrapper.httpx_client.request(
            "provisioning/instances/team",
            method="GET",
            params={
                "handle": handle,
            },
            headers={
                "x-provisioning-key": str(provisioning_key) if provisioning_key is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ListTeamProvisioningResponse,
                    parse_obj_as(
                        type_=ListTeamProvisioningResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def invite_team(
        self,
        *,
        provisioning_key: str,
        handle: str,
        members: typing.Sequence[InviteTeamProvisioningRequestMembersItem],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[InviteTeamProvisioningResponse]:
        """
        Invite new team members to an instance.

        Parameters
        ----------
        provisioning_key : str
            User provisioning key for platform-level instance management

        handle : str

        members : typing.Sequence[InviteTeamProvisioningRequestMembersItem]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[InviteTeamProvisioningResponse]
            Created
        """
        _response = self._client_wrapper.httpx_client.request(
            "provisioning/instances/team",
            method="POST",
            json={
                "handle": handle,
                "members": convert_and_respect_annotation_metadata(
                    object_=members,
                    annotation=typing.Sequence[InviteTeamProvisioningRequestMembersItem],
                    direction="write",
                ),
            },
            headers={
                "content-type": "application/json",
                "x-provisioning-key": str(provisioning_key) if provisioning_key is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InviteTeamProvisioningResponse,
                    parse_obj_as(
                        type_=InviteTeamProvisioningResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def remove_team_member(
        self, *, provisioning_key: str, handle: str, email: str, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[RemoveTeamMemberProvisioningResponse]:
        """
        Remove a team member from an instance.

        Parameters
        ----------
        provisioning_key : str
            User provisioning key for platform-level instance management

        handle : str

        email : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[RemoveTeamMemberProvisioningResponse]
            Success
        """
        _response = self._client_wrapper.httpx_client.request(
            "provisioning/instances/team",
            method="DELETE",
            json={
                "handle": handle,
                "email": email,
            },
            headers={
                "content-type": "application/json",
                "x-provisioning-key": str(provisioning_key) if provisioning_key is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    RemoveTeamMemberProvisioningResponse,
                    parse_obj_as(
                        type_=RemoveTeamMemberProvisioningResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def list_domains(
        self, *, handle: str, provisioning_key: str, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[ListDomainsProvisioningResponse]:
        """
        Retrieve all custom domains for an instance.

        Parameters
        ----------
        handle : str
            Instance handle

        provisioning_key : str
            User provisioning key for platform-level instance management

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ListDomainsProvisioningResponse]
            Success
        """
        _response = self._client_wrapper.httpx_client.request(
            "provisioning/instances/domains",
            method="GET",
            params={
                "handle": handle,
            },
            headers={
                "x-provisioning-key": str(provisioning_key) if provisioning_key is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ListDomainsProvisioningResponse,
                    parse_obj_as(
                        type_=ListDomainsProvisioningResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def add_domain(
        self,
        *,
        provisioning_key: str,
        handle: str,
        name: str,
        subdomain: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[AddDomainProvisioningResponse]:
        """
        Add a custom domain to an instance.

        Parameters
        ----------
        provisioning_key : str
            User provisioning key for platform-level instance management

        handle : str

        name : str
            Domain name (e.g., forum.example.com)

        subdomain : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[AddDomainProvisioningResponse]
            Created
        """
        _response = self._client_wrapper.httpx_client.request(
            "provisioning/instances/domains",
            method="POST",
            json={
                "handle": handle,
                "name": name,
                "subdomain": subdomain,
            },
            headers={
                "content-type": "application/json",
                "x-provisioning-key": str(provisioning_key) if provisioning_key is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    AddDomainProvisioningResponse,
                    parse_obj_as(
                        type_=AddDomainProvisioningResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def remove_domain(
        self, *, provisioning_key: str, handle: str, name: str, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[RemoveDomainProvisioningResponse]:
        """
        Remove a custom domain from an instance.

        Parameters
        ----------
        provisioning_key : str
            User provisioning key for platform-level instance management

        handle : str

        name : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[RemoveDomainProvisioningResponse]
            Success
        """
        _response = self._client_wrapper.httpx_client.request(
            "provisioning/instances/domains",
            method="DELETE",
            json={
                "handle": handle,
                "name": name,
            },
            headers={
                "content-type": "application/json",
                "x-provisioning-key": str(provisioning_key) if provisioning_key is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    RemoveDomainProvisioningResponse,
                    parse_obj_as(
                        type_=RemoveDomainProvisioningResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def export_data(
        self, *, provisioning_key: str, handle: str, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[ExportDataProvisioningResponse]:
        """
        Export all data from an instance including threads, posts, users, tags, etc.

        Parameters
        ----------
        provisioning_key : str
            User provisioning key for platform-level instance management

        handle : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ExportDataProvisioningResponse]
            Success
        """
        _response = self._client_wrapper.httpx_client.request(
            "provisioning/instances/export",
            method="POST",
            json={
                "handle": handle,
            },
            headers={
                "content-type": "application/json",
                "x-provisioning-key": str(provisioning_key) if provisioning_key is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ExportDataProvisioningResponse,
                    parse_obj_as(
                        type_=ExportDataProvisioningResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def list_webhooks(
        self, *, handle: str, provisioning_key: str, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[ListWebhooksProvisioningResponse]:
        """
        Retrieve all webhooks configured for an instance.

        Parameters
        ----------
        handle : str
            Instance handle

        provisioning_key : str
            User provisioning key for platform-level instance management

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ListWebhooksProvisioningResponse]
            Success
        """
        _response = self._client_wrapper.httpx_client.request(
            "provisioning/instances/webhooks",
            method="GET",
            params={
                "handle": handle,
            },
            headers={
                "x-provisioning-key": str(provisioning_key) if provisioning_key is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ListWebhooksProvisioningResponse,
                    parse_obj_as(
                        type_=ListWebhooksProvisioningResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def create_webhook(
        self,
        *,
        provisioning_key: str,
        handle: str,
        url: str,
        events: typing.Sequence[str],
        secret: typing.Optional[str] = OMIT,
        active: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[CreateWebhookProvisioningResponse]:
        """
        Create a new webhook for an instance.

        Parameters
        ----------
        provisioning_key : str
            User provisioning key for platform-level instance management

        handle : str

        url : str

        events : typing.Sequence[str]

        secret : typing.Optional[str]

        active : typing.Optional[bool]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[CreateWebhookProvisioningResponse]
            Created
        """
        _response = self._client_wrapper.httpx_client.request(
            "provisioning/instances/webhooks",
            method="POST",
            json={
                "handle": handle,
                "url": url,
                "events": events,
                "secret": secret,
                "active": active,
            },
            headers={
                "content-type": "application/json",
                "x-provisioning-key": str(provisioning_key) if provisioning_key is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CreateWebhookProvisioningResponse,
                    parse_obj_as(
                        type_=CreateWebhookProvisioningResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def update_webhook(
        self,
        *,
        provisioning_key: str,
        handle: str,
        webhook_id: str,
        url: typing.Optional[str] = OMIT,
        events: typing.Optional[typing.Sequence[str]] = OMIT,
        secret: typing.Optional[str] = OMIT,
        active: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[UpdateWebhookProvisioningResponse]:
        """
        Update an existing webhook.

        Parameters
        ----------
        provisioning_key : str
            User provisioning key for platform-level instance management

        handle : str

        webhook_id : str

        url : typing.Optional[str]

        events : typing.Optional[typing.Sequence[str]]

        secret : typing.Optional[str]

        active : typing.Optional[bool]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[UpdateWebhookProvisioningResponse]
            Success
        """
        _response = self._client_wrapper.httpx_client.request(
            "provisioning/instances/webhooks",
            method="PUT",
            json={
                "handle": handle,
                "webhookId": webhook_id,
                "url": url,
                "events": events,
                "secret": secret,
                "active": active,
            },
            headers={
                "content-type": "application/json",
                "x-provisioning-key": str(provisioning_key) if provisioning_key is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    UpdateWebhookProvisioningResponse,
                    parse_obj_as(
                        type_=UpdateWebhookProvisioningResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def delete_webhook(
        self,
        *,
        provisioning_key: str,
        handle: str,
        webhook_id: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[DeleteWebhookProvisioningResponse]:
        """
        Delete a webhook from an instance.

        Parameters
        ----------
        provisioning_key : str
            User provisioning key for platform-level instance management

        handle : str

        webhook_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DeleteWebhookProvisioningResponse]
            Success
        """
        _response = self._client_wrapper.httpx_client.request(
            "provisioning/instances/webhooks",
            method="DELETE",
            json={
                "handle": handle,
                "webhookId": webhook_id,
            },
            headers={
                "content-type": "application/json",
                "x-provisioning-key": str(provisioning_key) if provisioning_key is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DeleteWebhookProvisioningResponse,
                    parse_obj_as(
                        type_=DeleteWebhookProvisioningResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_ownership(
        self, *, handle: str, provisioning_key: str, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[GetOwnershipProvisioningResponse]:
        """
        Retrieve owner and creator information for an instance.

        Parameters
        ----------
        handle : str
            Instance handle

        provisioning_key : str
            User provisioning key for platform-level instance management

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetOwnershipProvisioningResponse]
            Success
        """
        _response = self._client_wrapper.httpx_client.request(
            "provisioning/instances/ownership",
            method="GET",
            params={
                "handle": handle,
            },
            headers={
                "x-provisioning-key": str(provisioning_key) if provisioning_key is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetOwnershipProvisioningResponse,
                    parse_obj_as(
                        type_=GetOwnershipProvisioningResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def transfer_ownership(
        self,
        *,
        provisioning_key: str,
        handle: str,
        new_owner_email: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[TransferOwnershipProvisioningResponse]:
        """
        Transfer instance ownership to another user. Only the current owner can transfer ownership.

        Parameters
        ----------
        provisioning_key : str
            User provisioning key for platform-level instance management

        handle : str

        new_owner_email : str
            Email of the new owner

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[TransferOwnershipProvisioningResponse]
            Success
        """
        _response = self._client_wrapper.httpx_client.request(
            "provisioning/instances/ownership",
            method="POST",
            json={
                "handle": handle,
                "newOwnerEmail": new_owner_email,
            },
            headers={
                "content-type": "application/json",
                "x-provisioning-key": str(provisioning_key) if provisioning_key is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    TransferOwnershipProvisioningResponse,
                    parse_obj_as(
                        type_=TransferOwnershipProvisioningResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def register(
        self,
        *,
        email: str,
        password: str,
        name: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[RegisterProvisioningResponse]:
        """
        Create a new account and receive a provisioning key for API access. Use this key to create and manage instances.

        Parameters
        ----------
        email : str
            Email address for the account

        password : str
            Password (minimum 8 characters)

        name : typing.Optional[str]
            Display name (optional)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[RegisterProvisioningResponse]
            Account created successfully
        """
        _response = self._client_wrapper.httpx_client.request(
            "provisioning/register",
            method="POST",
            json={
                "email": email,
                "password": password,
                "name": name,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    RegisterProvisioningResponse,
                    parse_obj_as(
                        type_=RegisterProvisioningResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ConflictErrorBody,
                        parse_obj_as(
                            type_=ConflictErrorBody,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def login(
        self, *, email: str, password: str, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[LoginProvisioningResponse]:
        """
        Login with email and password to retrieve your provisioning key.

        Parameters
        ----------
        email : str
            Account email

        password : str
            Account password

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[LoginProvisioningResponse]
            Login successful
        """
        _response = self._client_wrapper.httpx_client.request(
            "provisioning/login",
            method="POST",
            json={
                "email": email,
                "password": password,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    LoginProvisioningResponse,
                    parse_obj_as(
                        type_=LoginProvisioningResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawProvisioningClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def list(
        self,
        *,
        provisioning_key: str,
        handle: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[ListProvisioningResponse]:
        """
        Retrieve all instances owned by the authenticated user. Use the `handle` query parameter to get a single instance with its API key.

        Parameters
        ----------
        provisioning_key : str
            User provisioning key for platform-level instance management

        handle : typing.Optional[str]
            Optional handle to get a single instance

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ListProvisioningResponse]
            Success
        """
        _response = await self._client_wrapper.httpx_client.request(
            "provisioning/instances",
            method="GET",
            params={
                "handle": handle,
            },
            headers={
                "x-provisioning-key": str(provisioning_key) if provisioning_key is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ListProvisioningResponse,
                    parse_obj_as(
                        type_=ListProvisioningResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def create(
        self, *, provisioning_key: str, name: str, handle: str, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[CreateProvisioningResponse]:
        """
        Create a new forum instance. Returns the instance details including the API key for accessing the forum API.

        Parameters
        ----------
        provisioning_key : str
            User provisioning key for platform-level instance management

        name : str
            Display name for the instance

        handle : str
            URL-friendly identifier (slug)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[CreateProvisioningResponse]
            Created
        """
        _response = await self._client_wrapper.httpx_client.request(
            "provisioning/instances",
            method="POST",
            json={
                "name": name,
                "handle": handle,
            },
            headers={
                "content-type": "application/json",
                "x-provisioning-key": str(provisioning_key) if provisioning_key is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CreateProvisioningResponse,
                    parse_obj_as(
                        type_=CreateProvisioningResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def update(
        self,
        *,
        provisioning_key: str,
        handle: str,
        name: typing.Optional[str] = OMIT,
        new_handle: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[UpdateProvisioningResponse]:
        """
        Update an instance's name or handle. The `handle` field identifies which instance to update.

        Parameters
        ----------
        provisioning_key : str
            User provisioning key for platform-level instance management

        handle : str
            Current handle to identify the instance

        name : typing.Optional[str]
            New display name

        new_handle : typing.Optional[str]
            New URL-friendly identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[UpdateProvisioningResponse]
            Updated
        """
        _response = await self._client_wrapper.httpx_client.request(
            "provisioning/instances",
            method="PUT",
            json={
                "handle": handle,
                "name": name,
                "newHandle": new_handle,
            },
            headers={
                "content-type": "application/json",
                "x-provisioning-key": str(provisioning_key) if provisioning_key is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    UpdateProvisioningResponse,
                    parse_obj_as(
                        type_=UpdateProvisioningResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def delete(
        self, *, provisioning_key: str, handle: str, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[DeleteProvisioningResponse]:
        """
        Permanently delete an instance. This action cannot be undone.

        Parameters
        ----------
        provisioning_key : str
            User provisioning key for platform-level instance management

        handle : str
            Handle of the instance to delete

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DeleteProvisioningResponse]
            Deleted
        """
        _response = await self._client_wrapper.httpx_client.request(
            "provisioning/instances",
            method="DELETE",
            json={
                "handle": handle,
            },
            headers={
                "content-type": "application/json",
                "x-provisioning-key": str(provisioning_key) if provisioning_key is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DeleteProvisioningResponse,
                    parse_obj_as(
                        type_=DeleteProvisioningResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_billing(
        self, *, handle: str, provisioning_key: str, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[GetBillingProvisioningResponse]:
        """
        Retrieve billing and subscription information for an instance.

        Parameters
        ----------
        handle : str
            Instance handle

        provisioning_key : str
            User provisioning key for platform-level instance management

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetBillingProvisioningResponse]
            Success
        """
        _response = await self._client_wrapper.httpx_client.request(
            "provisioning/instances/billing",
            method="GET",
            params={
                "handle": handle,
            },
            headers={
                "x-provisioning-key": str(provisioning_key) if provisioning_key is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetBillingProvisioningResponse,
                    parse_obj_as(
                        type_=GetBillingProvisioningResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def change_plan(
        self,
        *,
        provisioning_key: str,
        handle: str,
        plan: UpgradeInstancePlan,
        is_annual: typing.Optional[bool] = OMIT,
        return_url: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[ChangePlanProvisioningResponse]:
        """
        Change an instance's subscription plan. Returns a checkout URL for upgrades or a billing portal URL for downgrades.

        Parameters
        ----------
        provisioning_key : str
            User provisioning key for platform-level instance management

        handle : str
            Instance handle

        plan : UpgradeInstancePlan
            Target plan

        is_annual : typing.Optional[bool]
            Use annual billing (default: true)

        return_url : typing.Optional[str]
            URL to return to after checkout/portal

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ChangePlanProvisioningResponse]
            Success
        """
        _response = await self._client_wrapper.httpx_client.request(
            "provisioning/instances/billing",
            method="POST",
            json={
                "handle": handle,
                "plan": plan,
                "isAnnual": is_annual,
                "returnUrl": return_url,
            },
            headers={
                "content-type": "application/json",
                "x-provisioning-key": str(provisioning_key) if provisioning_key is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ChangePlanProvisioningResponse,
                    parse_obj_as(
                        type_=ChangePlanProvisioningResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def regenerate_api_key(
        self, *, provisioning_key: str, handle: str, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[RegenerateApiKeyProvisioningResponse]:
        """
        Generate a new API key for the instance. The old key will be invalidated.

        Parameters
        ----------
        provisioning_key : str
            User provisioning key for platform-level instance management

        handle : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[RegenerateApiKeyProvisioningResponse]
            Success
        """
        _response = await self._client_wrapper.httpx_client.request(
            "provisioning/instances/api-key",
            method="POST",
            json={
                "handle": handle,
            },
            headers={
                "content-type": "application/json",
                "x-provisioning-key": str(provisioning_key) if provisioning_key is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    RegenerateApiKeyProvisioningResponse,
                    parse_obj_as(
                        type_=RegenerateApiKeyProvisioningResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_usage(
        self, *, handle: str, provisioning_key: str, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[GetUsageProvisioningResponse]:
        """
        Retrieve usage statistics for an instance including API requests, storage, and content counts.

        Parameters
        ----------
        handle : str
            Instance handle

        provisioning_key : str
            User provisioning key for platform-level instance management

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetUsageProvisioningResponse]
            Success
        """
        _response = await self._client_wrapper.httpx_client.request(
            "provisioning/instances/usage",
            method="GET",
            params={
                "handle": handle,
            },
            headers={
                "x-provisioning-key": str(provisioning_key) if provisioning_key is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetUsageProvisioningResponse,
                    parse_obj_as(
                        type_=GetUsageProvisioningResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def list_team(
        self, *, handle: str, provisioning_key: str, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[ListTeamProvisioningResponse]:
        """
        Retrieve all team members for an instance.

        Parameters
        ----------
        handle : str
            Instance handle

        provisioning_key : str
            User provisioning key for platform-level instance management

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ListTeamProvisioningResponse]
            Success
        """
        _response = await self._client_wrapper.httpx_client.request(
            "provisioning/instances/team",
            method="GET",
            params={
                "handle": handle,
            },
            headers={
                "x-provisioning-key": str(provisioning_key) if provisioning_key is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ListTeamProvisioningResponse,
                    parse_obj_as(
                        type_=ListTeamProvisioningResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def invite_team(
        self,
        *,
        provisioning_key: str,
        handle: str,
        members: typing.Sequence[InviteTeamProvisioningRequestMembersItem],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[InviteTeamProvisioningResponse]:
        """
        Invite new team members to an instance.

        Parameters
        ----------
        provisioning_key : str
            User provisioning key for platform-level instance management

        handle : str

        members : typing.Sequence[InviteTeamProvisioningRequestMembersItem]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[InviteTeamProvisioningResponse]
            Created
        """
        _response = await self._client_wrapper.httpx_client.request(
            "provisioning/instances/team",
            method="POST",
            json={
                "handle": handle,
                "members": convert_and_respect_annotation_metadata(
                    object_=members,
                    annotation=typing.Sequence[InviteTeamProvisioningRequestMembersItem],
                    direction="write",
                ),
            },
            headers={
                "content-type": "application/json",
                "x-provisioning-key": str(provisioning_key) if provisioning_key is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    InviteTeamProvisioningResponse,
                    parse_obj_as(
                        type_=InviteTeamProvisioningResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def remove_team_member(
        self, *, provisioning_key: str, handle: str, email: str, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[RemoveTeamMemberProvisioningResponse]:
        """
        Remove a team member from an instance.

        Parameters
        ----------
        provisioning_key : str
            User provisioning key for platform-level instance management

        handle : str

        email : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[RemoveTeamMemberProvisioningResponse]
            Success
        """
        _response = await self._client_wrapper.httpx_client.request(
            "provisioning/instances/team",
            method="DELETE",
            json={
                "handle": handle,
                "email": email,
            },
            headers={
                "content-type": "application/json",
                "x-provisioning-key": str(provisioning_key) if provisioning_key is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    RemoveTeamMemberProvisioningResponse,
                    parse_obj_as(
                        type_=RemoveTeamMemberProvisioningResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def list_domains(
        self, *, handle: str, provisioning_key: str, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[ListDomainsProvisioningResponse]:
        """
        Retrieve all custom domains for an instance.

        Parameters
        ----------
        handle : str
            Instance handle

        provisioning_key : str
            User provisioning key for platform-level instance management

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ListDomainsProvisioningResponse]
            Success
        """
        _response = await self._client_wrapper.httpx_client.request(
            "provisioning/instances/domains",
            method="GET",
            params={
                "handle": handle,
            },
            headers={
                "x-provisioning-key": str(provisioning_key) if provisioning_key is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ListDomainsProvisioningResponse,
                    parse_obj_as(
                        type_=ListDomainsProvisioningResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def add_domain(
        self,
        *,
        provisioning_key: str,
        handle: str,
        name: str,
        subdomain: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[AddDomainProvisioningResponse]:
        """
        Add a custom domain to an instance.

        Parameters
        ----------
        provisioning_key : str
            User provisioning key for platform-level instance management

        handle : str

        name : str
            Domain name (e.g., forum.example.com)

        subdomain : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[AddDomainProvisioningResponse]
            Created
        """
        _response = await self._client_wrapper.httpx_client.request(
            "provisioning/instances/domains",
            method="POST",
            json={
                "handle": handle,
                "name": name,
                "subdomain": subdomain,
            },
            headers={
                "content-type": "application/json",
                "x-provisioning-key": str(provisioning_key) if provisioning_key is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    AddDomainProvisioningResponse,
                    parse_obj_as(
                        type_=AddDomainProvisioningResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def remove_domain(
        self, *, provisioning_key: str, handle: str, name: str, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[RemoveDomainProvisioningResponse]:
        """
        Remove a custom domain from an instance.

        Parameters
        ----------
        provisioning_key : str
            User provisioning key for platform-level instance management

        handle : str

        name : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[RemoveDomainProvisioningResponse]
            Success
        """
        _response = await self._client_wrapper.httpx_client.request(
            "provisioning/instances/domains",
            method="DELETE",
            json={
                "handle": handle,
                "name": name,
            },
            headers={
                "content-type": "application/json",
                "x-provisioning-key": str(provisioning_key) if provisioning_key is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    RemoveDomainProvisioningResponse,
                    parse_obj_as(
                        type_=RemoveDomainProvisioningResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def export_data(
        self, *, provisioning_key: str, handle: str, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[ExportDataProvisioningResponse]:
        """
        Export all data from an instance including threads, posts, users, tags, etc.

        Parameters
        ----------
        provisioning_key : str
            User provisioning key for platform-level instance management

        handle : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ExportDataProvisioningResponse]
            Success
        """
        _response = await self._client_wrapper.httpx_client.request(
            "provisioning/instances/export",
            method="POST",
            json={
                "handle": handle,
            },
            headers={
                "content-type": "application/json",
                "x-provisioning-key": str(provisioning_key) if provisioning_key is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ExportDataProvisioningResponse,
                    parse_obj_as(
                        type_=ExportDataProvisioningResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def list_webhooks(
        self, *, handle: str, provisioning_key: str, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[ListWebhooksProvisioningResponse]:
        """
        Retrieve all webhooks configured for an instance.

        Parameters
        ----------
        handle : str
            Instance handle

        provisioning_key : str
            User provisioning key for platform-level instance management

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ListWebhooksProvisioningResponse]
            Success
        """
        _response = await self._client_wrapper.httpx_client.request(
            "provisioning/instances/webhooks",
            method="GET",
            params={
                "handle": handle,
            },
            headers={
                "x-provisioning-key": str(provisioning_key) if provisioning_key is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ListWebhooksProvisioningResponse,
                    parse_obj_as(
                        type_=ListWebhooksProvisioningResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def create_webhook(
        self,
        *,
        provisioning_key: str,
        handle: str,
        url: str,
        events: typing.Sequence[str],
        secret: typing.Optional[str] = OMIT,
        active: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[CreateWebhookProvisioningResponse]:
        """
        Create a new webhook for an instance.

        Parameters
        ----------
        provisioning_key : str
            User provisioning key for platform-level instance management

        handle : str

        url : str

        events : typing.Sequence[str]

        secret : typing.Optional[str]

        active : typing.Optional[bool]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[CreateWebhookProvisioningResponse]
            Created
        """
        _response = await self._client_wrapper.httpx_client.request(
            "provisioning/instances/webhooks",
            method="POST",
            json={
                "handle": handle,
                "url": url,
                "events": events,
                "secret": secret,
                "active": active,
            },
            headers={
                "content-type": "application/json",
                "x-provisioning-key": str(provisioning_key) if provisioning_key is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CreateWebhookProvisioningResponse,
                    parse_obj_as(
                        type_=CreateWebhookProvisioningResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def update_webhook(
        self,
        *,
        provisioning_key: str,
        handle: str,
        webhook_id: str,
        url: typing.Optional[str] = OMIT,
        events: typing.Optional[typing.Sequence[str]] = OMIT,
        secret: typing.Optional[str] = OMIT,
        active: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[UpdateWebhookProvisioningResponse]:
        """
        Update an existing webhook.

        Parameters
        ----------
        provisioning_key : str
            User provisioning key for platform-level instance management

        handle : str

        webhook_id : str

        url : typing.Optional[str]

        events : typing.Optional[typing.Sequence[str]]

        secret : typing.Optional[str]

        active : typing.Optional[bool]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[UpdateWebhookProvisioningResponse]
            Success
        """
        _response = await self._client_wrapper.httpx_client.request(
            "provisioning/instances/webhooks",
            method="PUT",
            json={
                "handle": handle,
                "webhookId": webhook_id,
                "url": url,
                "events": events,
                "secret": secret,
                "active": active,
            },
            headers={
                "content-type": "application/json",
                "x-provisioning-key": str(provisioning_key) if provisioning_key is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    UpdateWebhookProvisioningResponse,
                    parse_obj_as(
                        type_=UpdateWebhookProvisioningResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def delete_webhook(
        self,
        *,
        provisioning_key: str,
        handle: str,
        webhook_id: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[DeleteWebhookProvisioningResponse]:
        """
        Delete a webhook from an instance.

        Parameters
        ----------
        provisioning_key : str
            User provisioning key for platform-level instance management

        handle : str

        webhook_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DeleteWebhookProvisioningResponse]
            Success
        """
        _response = await self._client_wrapper.httpx_client.request(
            "provisioning/instances/webhooks",
            method="DELETE",
            json={
                "handle": handle,
                "webhookId": webhook_id,
            },
            headers={
                "content-type": "application/json",
                "x-provisioning-key": str(provisioning_key) if provisioning_key is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DeleteWebhookProvisioningResponse,
                    parse_obj_as(
                        type_=DeleteWebhookProvisioningResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_ownership(
        self, *, handle: str, provisioning_key: str, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[GetOwnershipProvisioningResponse]:
        """
        Retrieve owner and creator information for an instance.

        Parameters
        ----------
        handle : str
            Instance handle

        provisioning_key : str
            User provisioning key for platform-level instance management

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetOwnershipProvisioningResponse]
            Success
        """
        _response = await self._client_wrapper.httpx_client.request(
            "provisioning/instances/ownership",
            method="GET",
            params={
                "handle": handle,
            },
            headers={
                "x-provisioning-key": str(provisioning_key) if provisioning_key is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetOwnershipProvisioningResponse,
                    parse_obj_as(
                        type_=GetOwnershipProvisioningResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def transfer_ownership(
        self,
        *,
        provisioning_key: str,
        handle: str,
        new_owner_email: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[TransferOwnershipProvisioningResponse]:
        """
        Transfer instance ownership to another user. Only the current owner can transfer ownership.

        Parameters
        ----------
        provisioning_key : str
            User provisioning key for platform-level instance management

        handle : str

        new_owner_email : str
            Email of the new owner

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[TransferOwnershipProvisioningResponse]
            Success
        """
        _response = await self._client_wrapper.httpx_client.request(
            "provisioning/instances/ownership",
            method="POST",
            json={
                "handle": handle,
                "newOwnerEmail": new_owner_email,
            },
            headers={
                "content-type": "application/json",
                "x-provisioning-key": str(provisioning_key) if provisioning_key is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    TransferOwnershipProvisioningResponse,
                    parse_obj_as(
                        type_=TransferOwnershipProvisioningResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def register(
        self,
        *,
        email: str,
        password: str,
        name: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[RegisterProvisioningResponse]:
        """
        Create a new account and receive a provisioning key for API access. Use this key to create and manage instances.

        Parameters
        ----------
        email : str
            Email address for the account

        password : str
            Password (minimum 8 characters)

        name : typing.Optional[str]
            Display name (optional)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[RegisterProvisioningResponse]
            Account created successfully
        """
        _response = await self._client_wrapper.httpx_client.request(
            "provisioning/register",
            method="POST",
            json={
                "email": email,
                "password": password,
                "name": name,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    RegisterProvisioningResponse,
                    parse_obj_as(
                        type_=RegisterProvisioningResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ConflictErrorBody,
                        parse_obj_as(
                            type_=ConflictErrorBody,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def login(
        self, *, email: str, password: str, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[LoginProvisioningResponse]:
        """
        Login with email and password to retrieve your provisioning key.

        Parameters
        ----------
        email : str
            Account email

        password : str
            Account password

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[LoginProvisioningResponse]
            Login successful
        """
        _response = await self._client_wrapper.httpx_client.request(
            "provisioning/login",
            method="POST",
            json={
                "email": email,
                "password": password,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    LoginProvisioningResponse,
                    parse_obj_as(
                        type_=LoginProvisioningResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)
