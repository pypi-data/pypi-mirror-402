"""CLI tool for ceil-dlp"""

from pathlib import Path

import typer
import yaml
from rich.console import Console
from rich.panel import Panel
from rich.table import Table
from rich.text import Text

from ceil_dlp.config import Config
from ceil_dlp.detectors.doctr_ocr import get_doctr_heavy_ocr_engine, get_doctr_ocr_engine
from ceil_dlp.detectors.image_detector import detect_pii_in_image
from ceil_dlp.detectors.pdf_detector import detect_pii_in_pdf
from ceil_dlp.detectors.presidio_adapter import detect_with_presidio
from ceil_dlp.detectors.text_detector import detect_pii_in_text
from ceil_dlp.redaction import redact_image, redact_pdf, redact_text
from ceil_dlp.utils import image_to_pil_image

console = Console()

app = typer.Typer(help="ceil-dlp: Open-Source DLP for LLMs and Agentic Workflows")


@app.callback(invoke_without_command=True)
def main_callback(ctx: typer.Context) -> None:
    """ceil-dlp: Open-Source DLP for LLMs and Agentic Workflows"""
    if ctx.invoked_subcommand is None:
        typer.echo(ctx.get_help())


CALLBACK_WRAPPER_TEMPLATE = '''"""Local callback wrapper for ceil-dlp.

This file is auto-generated by 'ceil-dlp install'. It provides a local import
path for LiteLLM to use ceil-dlp as a callback.
"""

import os
import sys
from pathlib import Path

# Add this directory to sys.path so LiteLLM can import this module
# regardless of where it's run from
_config_dir = Path(__file__).parent
if str(_config_dir) not in sys.path:
    sys.path.insert(0, str(_config_dir))

# Import from the installed ceil-dlp package
# This import is needed for LiteLLM to discover the handler instance
from ceil_dlp.ceil_dlp_callback import (  # noqa: E402
    proxy_handler_instance,  # noqa: F401  # type: ignore[unused-import]
)

# Set CEIL_DLP_CONFIG_PATH to use ceil-dlp.yaml in the same directory as this file
_config_file = _config_dir / "ceil-dlp.yaml"

if _config_file.exists():
    os.environ["CEIL_DLP_CONFIG_PATH"] = str(_config_file)
'''

DEFAULT_CEIL_DLP_CONFIG = """# ceil-dlp Configuration
# This file was auto-generated by 'ceil-dlp install'
# Customize as needed for your environment

mode: enforce  # observe | enforce

policies:
  # High-risk items - block by default
  credit_card:
    action: block
    enabled: true
  ssn:
    action: block
    enabled: true
  api_key:
    action: block
    enabled: true
  pem_key:
    action: block
    enabled: true
  jwt_token:
    action: block
    enabled: true

  # Medium-risk items - mask by default
  email:
    action: mask
    enabled: true
  phone:
    action: mask
    enabled: true

# Audit logging (optional)
# audit_log_path: /var/log/ceil-dlp/audit.log

# PII types to detect (if not specified, all are enabled)
# enabled_pii_types:
#   - credit_card
#   - ssn
#   - email
#   - phone
#   - api_key
"""


@app.command()
def install(
    litellm_config: Path = typer.Argument(
        ...,
        help="Path to LiteLLM config.yaml file",
        exists=True,
        file_okay=True,
        dir_okay=False,
    ),
    update_config: bool = typer.Option(
        True,
        "--update-config/--no-update-config",
        help="Automatically update LiteLLM config.yaml to include ceil-dlp callback",
    ),
) -> None:
    """Install ceil-dlp in the same directory as LiteLLM config file.

    This command:
    1. Creates a local ceil_dlp_callback.py wrapper in the config directory
    2. Creates a starter ceil-dlp.yaml if it doesn't exist
    3. Optionally updates LiteLLM config.yaml to include the callback
    """
    config_dir = litellm_config.parent
    callback_file = config_dir / "ceil_dlp_callback.py"
    ceil_dlp_config = config_dir / "ceil-dlp.yaml"

    console.print("\n[bold blue]installing ceil-dlp[/bold blue]")
    console.print(f"config directory: [cyan]{config_dir}[/cyan]")
    console.print(f"litellm config: [cyan]{litellm_config}[/cyan]\n")

    # create callback wrapper
    if callback_file.exists():
        console.print(f"[dim]{callback_file.name}[/dim] already exists, skipping...")
    else:
        callback_file.write_text(CALLBACK_WRAPPER_TEMPLATE)
        console.print(f"created [cyan]{callback_file.name}[/cyan]")

    # create ceil-dlp.yaml if it doesn't exist
    if ceil_dlp_config.exists():
        console.print(f"[dim]{ceil_dlp_config.name}[/dim] already exists, skipping...")
    else:
        ceil_dlp_config.write_text(DEFAULT_CEIL_DLP_CONFIG)
        console.print(f"created [cyan]{ceil_dlp_config.name}[/cyan]")

    # update LiteLLM config if requested
    if update_config:
        # calculate callback path
        # The wrapper adds its directory to sys.path, so we can always use
        # the simple module name regardless of where LiteLLM is run from
        callback_path = "ceil_dlp_callback.proxy_handler_instance"

        try:
            with litellm_config.open() as f:
                config = yaml.safe_load(f) or {}

            # check if callback is already configured
            callbacks = config.get("litellm_settings", {}).get("callbacks", [])

            if isinstance(callbacks, str):
                callbacks = [callbacks]

            # check if already configured (handle both string and list formats)
            already_configured = False
            if isinstance(callbacks, list):
                already_configured = any(
                    callback_path in str(cb) or "ceil_dlp_callback" in str(cb) for cb in callbacks
                )
            elif isinstance(callbacks, str):
                already_configured = callback_path in callbacks or "ceil_dlp_callback" in callbacks

            if already_configured:
                console.print(
                    f"callback already configured in [cyan]{litellm_config.name}[/cyan], skipping..."
                )
            else:
                # add callback
                if "litellm_settings" not in config:
                    config["litellm_settings"] = {}
                if "callbacks" not in config["litellm_settings"]:
                    config["litellm_settings"]["callbacks"] = []

                current_callbacks = config["litellm_settings"]["callbacks"]
                if isinstance(current_callbacks, str):
                    config["litellm_settings"]["callbacks"] = [current_callbacks]

                config["litellm_settings"]["callbacks"].append(callback_path)

                # write back
                with litellm_config.open("w") as f:
                    yaml.dump(config, f, default_flow_style=False, sort_keys=False)

                console.print(
                    f"updated [cyan]{litellm_config.name}[/cyan] to include ceil-dlp callback"
                )
                console.print(f"   [dim]Callback path:[/dim] [cyan]{callback_path}[/cyan]")
        except Exception as e:
            console.print(f"could not update [cyan]{litellm_config.name}[/cyan]: [red]{e}[/red]")
            console.print(
                f"   [dim]please manually add to litellm_settings.callbacks:[/dim] [cyan]{callback_path}[/cyan]"
            )

    console.print()
    console.print(
        Panel.fit("[bold green]installation complete![/bold green]", border_style="green")
    )

    next_steps = Text()
    next_steps.append("1. ", style="bold")
    next_steps.append("review and customize ", style="")
    next_steps.append(f"{ceil_dlp_config.name}", style="cyan")
    next_steps.append(" to suit your needs\n", style="")
    next_steps.append("2. ", style="bold")
    next_steps.append("run ", style="")
    next_steps.append(f"litellm --config {litellm_config} --port 4000", style="cyan")
    next_steps.append(" to start LiteLLM", style="")

    console.print("\n[bold]next steps:[/bold]\n")
    console.print(next_steps)
    console.print()


@app.command()
def remove(
    litellm_config: Path = typer.Argument(
        ...,
        help="Path to LiteLLM config.yaml file",
        exists=True,
        file_okay=True,
        dir_okay=False,
    ),
    remove_callback_file: bool = typer.Option(
        True,
        "--remove-callback-file/--keep-callback-file",
        help="Remove the ceil_dlp_callback.py wrapper file",
    ),
    remove_config_file: bool = typer.Option(
        False,
        "--remove-config-file/--keep-config-file",
        help="Remove the ceil-dlp.yaml config file",
    ),
    update_config: bool = typer.Option(
        True,
        "--update-config/--no-update-config",
        help="Automatically update LiteLLM config.yaml to remove ceil-dlp callback",
    ),
) -> None:
    """Remove ceil-dlp from the LiteLLM configuration.

    This command:
    1. Removes the callback from LiteLLM config.yaml
    2. Optionally removes the ceil_dlp_callback.py wrapper file
    3. Optionally removes the ceil-dlp.yaml config file
    """
    config_dir = litellm_config.parent
    callback_file = config_dir / "ceil_dlp_callback.py"
    ceil_dlp_config = config_dir / "ceil-dlp.yaml"

    console.print("\n[bold red]removing ceil-dlp[/bold red]")
    console.print(f"config directory: [cyan]{config_dir}[/cyan]")
    console.print(f"litellm config: [cyan]{litellm_config}[/cyan]\n")

    # remove callback from LiteLLM config if requested
    if update_config:
        try:
            with litellm_config.open() as f:
                config = yaml.safe_load(f) or {}

            callback_path = "ceil_dlp_callback.proxy_handler_instance"
            callbacks = config.get("litellm_settings", {}).get("callbacks", [])

            if not callbacks:
                console.print(
                    f"no callbacks configured in [cyan]{litellm_config.name}[/cyan], skipping..."
                )
            else:
                # normalize to list format
                if isinstance(callbacks, str):
                    callbacks = [callbacks]

                # find and remove ceil-dlp callbacks
                original_count = len(callbacks)
                callbacks = [
                    cb
                    for cb in callbacks
                    if callback_path not in str(cb) and "ceil_dlp_callback" not in str(cb)
                ]

                removed_count = original_count - len(callbacks)

                if removed_count > 0:
                    # update config
                    if len(callbacks) == 0:
                        # remove callbacks key if empty
                        if (
                            "litellm_settings" in config
                            and "callbacks" in config["litellm_settings"]
                        ):
                            del config["litellm_settings"]["callbacks"]
                            # remove litellm_settings if empty
                            if not config["litellm_settings"]:
                                del config["litellm_settings"]
                    else:
                        # convert back to string if only one callback remains
                        if len(callbacks) == 1:
                            config["litellm_settings"]["callbacks"] = callbacks[0]
                        else:
                            config["litellm_settings"]["callbacks"] = callbacks

                    # write back
                    with litellm_config.open("w") as f:
                        yaml.dump(config, f, default_flow_style=False, sort_keys=False)

                    console.print(
                        f"removed ceil-dlp callback from [cyan]{litellm_config.name}[/cyan]"
                    )
                else:
                    console.print(
                        f"ceil-dlp callback not found in [cyan]{litellm_config.name}[/cyan], skipping..."
                    )
        except Exception as e:
            console.print(f"could not update [cyan]{litellm_config.name}[/cyan]: [red]{e}[/red]")
            console.print(
                "   [dim]please manually remove ceil-dlp from litellm_settings.callbacks[/dim]"
            )

    # remove callback wrapper file if requested
    if remove_callback_file:
        if callback_file.exists():
            try:
                callback_file.unlink()
                console.print(f"removed [cyan]{callback_file.name}[/cyan]")
            except Exception as e:
                console.print(f"could not remove [cyan]{callback_file.name}[/cyan]: [red]{e}[/red]")
        else:
            console.print(f"[dim]{callback_file.name}[/dim] not found, skipping...")
    else:
        if callback_file.exists():
            console.print(f"[dim]keeping {callback_file.name}[/dim]")

    # remove ceil-dlp.yaml config file if requested
    if remove_config_file:
        if ceil_dlp_config.exists():
            try:
                ceil_dlp_config.unlink()
                console.print(f"removed [cyan]{ceil_dlp_config.name}[/cyan]")
            except Exception as e:
                console.print(
                    f"could not remove [cyan]{ceil_dlp_config.name}[/cyan]: [red]{e}[/red]"
                )
        else:
            console.print(f"[dim]{ceil_dlp_config.name}[/dim] not found, skipping...")
    else:
        if ceil_dlp_config.exists():
            console.print(f"[dim]keeping {ceil_dlp_config.name}[/dim]")

    console.print()
    console.print(Panel.fit("[bold green]removal complete![/bold green]", border_style="green"))


@app.command()
def test(
    input_file: Path = typer.Argument(..., help="File to test (text, image, or PDF)", exists=True),
    config_path: Path = typer.Option(
        None, "--config", "-c", help="Path to ceil-dlp.yaml config file"
    ),
    model: str = typer.Option(
        "test-model", "--model", "-m", help="Model name to use for model-aware policies"
    ),
    output_file: Path = typer.Option(
        None, "--output", "-o", help="Save redacted output to file (for images/PDFs)"
    ),
) -> None:
    """
    Test what ceil-dlp would do with a given file.

    Shows whether the file would be:
    - ACCEPTED: No PII detected or all PII is allowed
    - BLOCKED: Contains PII that would be blocked
    - MASKED: Contains PII that would be masked (shows redacted version)

    Supports text files, images (PNG, JPEG, etc.), and PDFs.
    """
    # Load config
    config = Config.from_yaml(config_path) if config_path and config_path.exists() else Config()

    # Determine file type
    file_ext = input_file.suffix.lower()
    is_text = file_ext in (".txt", ".md", ".py", ".js", ".json", ".yaml", ".yml", ".csv")
    is_image = file_ext in (".png", ".jpg", ".jpeg", ".gif", ".bmp", ".webp")
    is_pdf = file_ext == ".pdf"

    if not (is_text or is_image or is_pdf):
        console.print(f"[red]Error:[/red] Unsupported file type: {file_ext}")
        console.print(
            "Supported types: text files (.txt, .md, etc.), images (.png, .jpg, etc.), PDFs (.pdf)"
        )
        raise typer.Exit(1)

    console.print(f"\n[bold blue]Testing file:[/bold blue] {input_file}")
    console.print(f"[dim]Model:[/dim] {model}")
    console.print(f"[dim]Mode:[/dim] {config.mode}\n")

    # Get enabled types for PII detection
    enabled_types = set(config.enabled_pii_types) if config.enabled_pii_types else None

    # Detect PII based on file type
    detections: dict[str, list[tuple[str, int, int]]] = {}
    file_content: str | bytes | None = None
    text_content: str | None = None

    if is_text:
        # Read text file
        text_content = input_file.read_text(encoding="utf-8", errors="ignore")
        file_content = text_content
        detections = detect_pii_in_text(
            text_content, enabled_types=enabled_types, ner_strength=config.ner_strength
        )
    elif is_image:
        # Read image file
        image_bytes = input_file.read_bytes()
        file_content = image_bytes
        detections = detect_pii_in_image(image_bytes, enabled_types=enabled_types)
    elif is_pdf:
        # Read PDF file
        pdf_bytes = input_file.read_bytes()
        file_content = pdf_bytes
        detections = detect_pii_in_pdf(pdf_bytes, enabled_types=enabled_types)

    # Process detections based on policies
    blocked_types = []
    masked_types = {}

    for pii_type, matches in detections.items():
        policy = config.get_policy(pii_type)
        if not policy or not policy.enabled:
            continue

        # Check model-aware policy (simplified - would need model_matcher import)
        # For now, assume policy applies
        if policy.action == "block":
            blocked_types.append(pii_type)
        elif policy.action == "mask":
            masked_types[pii_type] = matches

    # Display results
    if not detections:
        console.print(
            Panel.fit("[bold green]ACCEPTED[/bold green]\nNo PII detected.", border_style="green")
        )
        return

    # Create results table
    table = Table(title="Detection Results", show_header=True, header_style="bold magenta")
    table.add_column("PII Type", style="cyan")
    table.add_column("Count", justify="right")
    table.add_column("Action", style="yellow")
    table.add_column("Examples", style="dim")

    for pii_type, matches in detections.items():
        policy = config.get_policy(pii_type)
        action = policy.action if policy and policy.enabled else "observe"
        count = len(matches)
        examples = ", ".join(
            [match[0][:30] + "..." if len(match[0]) > 30 else match[0] for match in matches[:3]]
        )
        if count > 3:
            examples += f" ... (+{count - 3} more)"
        table.add_row(pii_type, str(count), action.upper(), examples)

    console.print(table)
    console.print()

    # Determine final action
    if blocked_types:
        console.print(
            Panel.fit(
                f"[bold red]BLOCKED[/bold red]\n\n"
                f"This file would be blocked by ceil-dlp due to detected sensitive data:\n"
                f"{', '.join(blocked_types)}\n\n"
                f"Mode: {config.mode}",
                border_style="red",
            )
        )
    elif masked_types:
        # Show redacted version
        if is_text and text_content:
            redacted_text, redacted_items = redact_text(
                text_content, detections=masked_types, ner_strength=config.ner_strength
            )
            console.print(Panel.fit("[bold yellow]MASKED[/bold yellow]", border_style="yellow"))
            console.print("\n[bold]Original:[/bold]")
            console.print(
                f"[dim]{text_content[:200]}{'...' if len(text_content) > 200 else ''}[/dim]"
            )
            console.print("\n[bold]Redacted:[/bold]")
            console.print(f"{redacted_text[:200]}{'...' if len(redacted_text) > 200 else ''}")
        elif is_image and file_content:
            console.print(Panel.fit("[bold yellow]MASKED[/bold yellow]", border_style="yellow"))
            console.print("\n[bold]Redacting image...[/bold]")
            types_to_redact = list(masked_types.keys())
            try:
                redacted_image = redact_image(
                    file_content,
                    pii_types=types_to_redact,
                    ocr_strength=config.ocr_strength,
                    ner_strength=config.ner_strength,
                )
                if output_file:
                    output_file.write_bytes(redacted_image)
                    console.print(f"[green]Redacted image saved to:[/green] {output_file}")
                else:
                    console.print("[dim]Use --output to save the redacted image[/dim]")
            except Exception as e:
                console.print(f"[red]Error redacting image:[/red] {e}")
        elif is_pdf and file_content:
            console.print(Panel.fit("[bold yellow]MASKED[/bold yellow]", border_style="yellow"))
            console.print("\n[bold]Redacting PDF...[/bold]")
            types_to_redact = list(masked_types.keys())
            try:
                redacted_pdf = redact_pdf(
                    file_content,
                    pii_types=types_to_redact,
                    ocr_strength=config.ocr_strength,
                    ner_strength=config.ner_strength,
                )
                if output_file:
                    output_file.write_bytes(redacted_pdf)
                    console.print(f"[green]Redacted PDF saved to:[/green] {output_file}")
                else:
                    console.print("[dim]Use --output to save the redacted PDF[/dim]")
            except Exception as e:
                console.print(f"[red]Error redacting PDF:[/red] {e}")
    else:
        # Detected but not blocked/masked (observe mode or disabled policies)
        console.print(
            Panel.fit("[bold cyan]DETECTED (not blocked/masked)[/bold cyan]", border_style="cyan")
        )


@app.command()
def diagnose(
    input_file: Path = typer.Argument(..., help="Image file to diagnose", exists=True),
    ocr_strength: int = typer.Option(
        3,
        "--ocr-strength",
        "-o",
        help="OCR strength to test (1=light docTR, 2=+Tesseract, 3=+heavy docTR)",
    ),
    ner_strength: int = typer.Option(
        1, "--ner-strength", "-n", help="NER model strength to test (1=lg, 2=trf, 3=transformer)"
    ),
) -> None:
    """
    Diagnose OCR and NER performance on an image.

    Shows:
    1. OCR text extracted by each engine (based on ocr_strength)
    2. NER entities detected in each OCR text using specified NER strength
    3. Helps identify if issue is OCR (text not extracted) or NER (text extracted but not detected)

    OCR strength:
    - 1: Use only light docTR OCR (fastest)
    - 2: Use light docTR + Tesseract OCR (balanced)
    - 3: Use all three models including heavy docTR (slowest, most accurate, default)

    NER strength:
    - 1: en_core_web_lg (fastest, good accuracy)
    - 2: transformer NER model (default, best accuracy, slower)
    """

    # Check if it's an image
    if input_file.suffix.lower() not in [".png", ".jpg", ".jpeg", ".gif", ".bmp", ".webp"]:
        console.print(f"[red]Error:[/red] {input_file} is not an image file")
        return

    console.print(Panel.fit("[bold blue]OCR & NER Diagnostic[/bold blue]", border_style="blue"))
    console.print(f"\n[bold]Image:[/bold] {input_file}\n")

    try:
        image = image_to_pil_image(input_file)
    except Exception as e:
        console.print(f"[red]Error loading image:[/red] {e}")
        return

    # Test OCR engines based on ocr_strength
    from typing import Any

    ocr_strength_val = max(1, min(3, ocr_strength))  # Clamp to valid range
    ocr_engines: list[tuple[str, Any]] = []

    if ocr_strength_val >= 1:
        ocr_engines.append(("docTR (light)", get_doctr_ocr_engine()))
    if ocr_strength_val >= 2:
        # Add Tesseract if available
        try:
            import pytesseract  # type: ignore[import-untyped]

            ocr_engines.append(("Tesseract", "tesseract"))
        except ImportError:
            pass
    if ocr_strength_val >= 3:
        ocr_engines.append(("docTR (heavy)", get_doctr_heavy_ocr_engine()))

    for engine_name, ocr_engine_or_marker in ocr_engines:
        console.print(f"\n[bold yellow]{'=' * 60}[/bold yellow]")
        console.print(f"[bold yellow]OCR Engine: {engine_name}[/bold yellow]")
        console.print(f"[bold yellow]{'=' * 60}[/bold yellow]\n")

        # Extract OCR text
        try:
            if ocr_engine_or_marker == "tesseract":
                # Use pytesseract directly
                import pytesseract

                ocr_text = pytesseract.image_to_string(image)
            else:
                # Use docTR OCR engine
                ocr_result = ocr_engine_or_marker.perform_ocr(image)

                # Extract text from OCR result
                if isinstance(ocr_result, dict) and "text" in ocr_result:
                    # docTR format: list of words
                    if isinstance(ocr_result["text"], list):
                        ocr_text = " ".join(ocr_result["text"])
                    else:
                        ocr_text = str(ocr_result["text"])
                else:
                    ocr_text = str(ocr_result)

            if not ocr_text or not ocr_text.strip():
                console.print("[yellow]No text extracted by OCR[/yellow]")
                continue

            console.print("[bold]Extracted OCR Text:[/bold]")
            console.print(f"[dim]{ocr_text[:500]}{'...' if len(ocr_text) > 500 else ''}[/dim]")
            console.print(f"[dim]Total length: {len(ocr_text)} characters[/dim]\n")

            # Run NER on extracted text with specified strength
            console.print(f"[bold]NER Detection Results (strength={ner_strength}):[/bold]")
            ner_results = detect_with_presidio(ocr_text, ner_strength=ner_strength)

            if ner_results:
                table = Table(show_header=True, header_style="bold magenta")
                table.add_column("PII Type", style="cyan")
                table.add_column("Matches", style="green")

                for pii_type, matches in ner_results.items():
                    match_texts = [match[0] for match in matches[:5]]  # Show first 5
                    match_str = ", ".join(match_texts)
                    if len(matches) > 5:
                        match_str += f" ... (+{len(matches) - 5} more)"
                    table.add_row(pii_type, match_str)

                console.print(table)
            else:
                console.print("[yellow]No PII entities detected by NER[/yellow]")

        except Exception as e:
            console.print(f"[red]Error with {engine_name}:[/red] {e}")
            import traceback

            console.print(f"[dim]{traceback.format_exc()}[/dim]")


def main() -> None:
    """Main entry point for the CLI."""
    app()


if __name__ == "__main__":
    main()
