from __future__ import annotations
from dataclasses import dataclass, field
from pathlib import Path
from typing import ClassVar, TypedDict, cast
from instaui import custom
from instaui.internal.ui.event import EventMixin
from instaui.internal.ui.ref_base import RefBase

_STATIC_DIR = Path(__file__).parent / "static"
_MERMAID_JS_FILE = _STATIC_DIR / "mermaid.esm.min.mjs"
_INSTAUI_MERMAID_JS_FILE = _STATIC_DIR / "instaui-mermaid.js"

_IMPORT_MAPS = {"mermaid": _MERMAID_JS_FILE}


class Mermaid(
    custom.element,
    esm=_INSTAUI_MERMAID_JS_FILE,
    externals=_IMPORT_MAPS,
):
    """
    A UI component to render Mermaid diagrams from text-based syntax.

    Args:
        graph (str): A string containing the Mermaid diagram definition.
                     This defines the structure and appearance of the diagram using Mermaid's syntax.
        node_clickables (list[NodeClickable] | NodeClickable | None, optional): A list of NodeClickable objects or a single NodeClickable object that defines the clickable nodes in the diagram. Defaults to None.
        error_ref (str | None, optional): A reference to a string state that will be updated with any error messages generated by the Mermaid component. Defaults to None.

    Example:
    .. code-block:: python
        from instaui import ui
        from instaui_mermaid import Mermaid

        @ui.page()
        def home():
            graph = '''
            graph TB
            FullFirstSquad-->StripedFirstSquad
            '''
            Mermaid(graph)
    """

    MERMAID_INIT_CONFIG: ClassVar[TMermaidConfig | None] = None

    def __init__(
        self,
        graph: str,
        *,
        node_click_configs: list[TNodeClickConfig]
        | NodeClickConfigBuilder
        | None = None,
        error_ref: str | None = None,
    ):
        super().__init__()

        error_ref_name = None
        if error_ref:
            assert isinstance(error_ref, RefBase), "error_ref must be a RefBase"
            error_ref_name = custom.convert_reference(error_ref)

        node_click_configs = (
            node_click_configs.configs
            if isinstance(node_click_configs, NodeClickConfigBuilder)
            else node_click_configs
        )
        self.props(
            {
                "graph": graph,
                "clickConfigs": node_click_configs,
                "initConfig": self.MERMAID_INIT_CONFIG or None,
                "errorRefName": error_ref_name,
            }
        )

    def on_node_click(self, handler: EventMixin):
        """
        Register a handler for Mermaid node click events.

        Args:
            handler:
                An EventMixin-compatible callable that will be invoked when
                a configured node is clicked.
        """
        return self.on("node:click", handler)


def set_mermaid_config(*, theme: str | None = None):
    """
    Configure global Mermaid initialization options for all Mermaid components.

    This function mutates the class-level ``Mermaid.CONFIG`` and therefore
    affects all Mermaid components created after this call.

    Args:
        theme:
            Mermaid theme name (e.g. ``"default"``, ``"dark"``, ``"neutral"``,
            ``"forest"``).

    Example:
    .. code-block:: python
        set_mermaid_config(theme="dark")
    """
    config = {}
    if theme:
        config["theme"] = theme

    if config:
        Mermaid.MERMAID_INIT_CONFIG = cast(TMermaidConfig, config)


class TMermaidConfig(TypedDict, total=False):
    theme: str


@dataclass
class NodeClickConfigBuilder:
    configs: list[TNodeClickConfig] = field(default_factory=list)

    @classmethod
    def create(cls, node: str, arg: str | None = None) -> NodeClickConfigBuilder:
        """
        Create a new NodeClickConfigBuilder instance and add a new clickable node

        Args:
            node:
                Mermaid node id to bind click events to.

            arg:
                Optional argument passed back to the click handler when this
                node is clicked.
        """
        ins = cls()
        ins.configs = [*cls.configs, {"node": node, "arg": arg}]
        return ins


class TNodeClickConfig(TypedDict, total=False):
    node: str
    arg: str | None
