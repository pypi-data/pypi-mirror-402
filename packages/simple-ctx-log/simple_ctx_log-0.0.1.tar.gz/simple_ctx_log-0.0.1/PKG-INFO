Metadata-Version: 2.4
Name: simple_ctx_log
Version: 0.0.1
Summary: Simple contextual logger
Project-URL: Documentation, https://github.com/Hactys/simple_ctx_log#readme
Project-URL: Issues, https://github.com/Hactys/simple_ctx_log/issues
Project-URL: Source, https://github.com/Hactys/simple_ctx_log
Author: Hactys
License-Expression: MIT
License-File: LICENSE.txt
Classifier: Development Status :: 4 - Beta
Classifier: Programming Language :: Python
Classifier: Programming Language :: Python :: 3.10
Classifier: Programming Language :: Python :: 3.11
Classifier: Programming Language :: Python :: 3.12
Classifier: Programming Language :: Python :: 3.13
Classifier: Programming Language :: Python :: 3.14
Classifier: Programming Language :: Python :: Implementation :: CPython
Classifier: Programming Language :: Python :: Implementation :: PyPy
Requires-Python: >=3.10
Description-Content-Type: text/markdown

# simple_ctx_log

[![PyPI - Version](https://img.shields.io/pypi/v/simple_ctx_log.svg)](https://pypi.org/project/simple_ctx_log)
[![PyPI - Python Version](https://img.shields.io/pypi/pyversions/simple_ctx_log.svg)](https://pypi.org/project/simple_ctx_log)

A lightweight but **deeply introspective logger** for Python.

`simple_ctx_log` focuses on **context reconstruction**, not just file/line logging.
It is designed to answer the question:

> *â€œFrom which object, through which call stack, did this log originate?â€*

No external dependencies.
No global state.
No magic decorators.
Just frames, objects, and clarity.

---

## Key Features

- ğŸ” Full **call stack reconstruction** (functions and methods)
- ğŸ§  **Object context traversal** (parent objects, nested architectures)
- ğŸ§µ Safe with recursion, deep nesting, and complex object graphs
- ğŸ›‘ Configurable limits:
  - maximum depth
  - stop at module boundary
- ğŸ“ Highly readable **tree-style output**
- âš¡ High performance (uses `sys._getframe`, no `inspect.stack`)
- ğŸ§ª Designed to be test-friendly
- ğŸ“¦ Standard library only

This logger is particularly useful for:
- debugging complex object-oriented flows
- understanding â€œwho called whatâ€ in large systems
- forensic-style debugging
- frameworks, factories, and deeply nested architectures

---

## Table of Contents

- [Installation](#installation)
- [Quick Start](#quick-start)
- [Example Output](#example-output)
- [Configuration](#configuration)
- [Design Philosophy](#design-philosophy)
- [Limitations](#limitations)
- [License](#license)

---

## Installation

```console
pip install simple_ctx_log
````

---

## Quick Start

```python
from simple_ctx_log import Logger

logger = Logger()

def my_function(x):
    logger.log("Hello from my_function")

my_function(42)
```

---

## Example Output

For a deeply nested and recursive call:

```text
[2026-01-xxThh:mm:ss.mls] [INFO] [thread=MainThread]
â”‚ module: tests.test_logger_nested_hell
â”‚ call stack:
â”‚ â”œâ”€ ExternalArchitect.<unknown>
â”‚ â”‚  attrs:
â”‚ â”‚    creator = 'Hell'
â”‚ â”‚    data = 'Data'
â”‚ â”œâ”€ test_logger_called_from_function(capsys=<_pytest.capture.CaptureFixture>)
â”‚ â”œâ”€ InternProcess.recursive_log_call(depth=3, msg='Entropy is inevitable.')
â”‚ â”‚  attrs:
â”‚ â”‚    parent = <ExternalArchitect>
â”‚ â”œâ”€ InternProcess.recursive_log_call(depth=2, msg='Entropy is inevitable.')
â”‚ â”‚  attrs:
â”‚ â”‚    parent = <ExternalArchitect>
â”‚ â”œâ”€ InternProcess.recursive_log_call(depth=1, msg='Entropy is inevitable.')
â”‚ â”‚  attrs:
â”‚ â”‚    parent = <ExternalArchitect>
â”‚ â””â”€ InternProcess.recursive_log_call(depth=0, msg='Entropy is inevitable.')
â”‚    attrs:
â”‚      parent = <ExternalArchitect>
â”‚
â””â”€ message:
   Retrieved message : Entropy is inevitable.
```

This output shows:

* the full call stack (module â†’ logger call)
* recursive calls
* object hierarchy
* method arguments
* instance attributes
* a clean separation between context and message

---

## Configuration

### Logger options

```python
Logger(
    name: str | None = None,
    log_args: bool = True,
    log_attrs: bool = True,
    log_private_attrs: bool = False,
    max_depth: int | None = None,
)
```

| Option              | Description                                     |
| ------------------- | ----------------------------------------------- |
| `name`              | Logger name (informational)                     |
| `log_args`          | Log function/method arguments                   |
| `log_attrs`         | Log instance attributes                         |
| `log_private_attrs` | Include private attributes (`_attr`)            |
| `max_depth`         | Maximum depth for call stack + object traversal |

### Module boundary safety

The logger **does not cross module boundaries** by default.
This prevents polluting logs with internals such as:

* `asyncio`
* `threading`
* framework internals

The context stops at the last object belonging to the calling module.

---

## Design Philosophy

`simple_ctx_log` intentionally does **not**:

* wrap or replace `logging`
* rely on decorators
* inject global hooks
* inspect the heap (`gc`)
* traverse object graphs downward

Instead, it:

* walks **upward** through frames
* reconstructs **logical ownership**
* remains deterministic and bounded

The goal is **understanding**, not verbosity.

---

## Limitations

* Uses `sys._getframe` (CPython only)
* Output is currently text-based (no JSON yet)
* No built-in log levels filtering (by design, for now)
* No file handler yet (planned)

These are deliberate trade-offs to preserve performances.

---

## License

`simple_ctx_log` is distributed under the terms of the
[MIT](https://spdx.org/licenses/MIT.html) license.
