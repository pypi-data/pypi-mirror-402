from __future__ import annotations
from dataclasses import dataclass, field
from typing import List, Optional, Sequence, Tuple, Union
import random
import math

from .utils import Atom, distance

# Covalent radii (simplified) in angstroms for bond guessing
_COV_RAD = {
    "H": 0.31,
    "C": 0.76,
    "N": 0.71,
    "O": 0.66,
    "F": 0.57,
    "S": 1.05,
    "P": 1.07,
    "CL": 1.02,
    "NA": 1.66,
    "K": 2.03,
}


# --- Labeling helpers ---

def _formula(atoms: List[Atom]) -> str:
    counts: dict[str, int] = {}
    for a in atoms:
        el = a.element.capitalize()
        counts[el] = counts.get(el, 0) + 1
    return "".join(f"{el}{counts[el]}" for el in sorted(counts))


def _label_fragment(atoms: List[Atom], comp_size: int) -> Tuple[str, bool]:
    formula = _formula(atoms)
    upper_els = [a.element.upper() for a in atoms]

    # quick ion check: single atom and typical ionic species
    if comp_size == 1:
        el = upper_els[0]
        if el in ("NA", "CL", "K", "F", "BR", "I"):
            return "ion", True

    if formula == "H2O1" or sorted(upper_els) == ["H", "H", "O"]:
        return "water", False
    if formula == "C1H4O1" and comp_size == 6:
        return "methanol", False
    if formula == "C2H6O1" and comp_size == 9:
        return "ethanol", False
    if formula == "C6H6" and comp_size == 12:
        return "benzene", False

    return "unknown", False

@dataclass
class XYZ:
    comment: str
    atoms: List[Atom]

@dataclass
class FragmentRecord:
    atoms: List[Atom]
    label: str = "unknown"
    special: bool = False
    charge_hint: Optional[int] = None
    centroid: Tuple[float, float, float] = field(init=False)

    def __post_init__(self) -> None:
        if not self.atoms:
            raise ValueError("Fragment cannot be empty")
        n = float(len(self.atoms))
        sx = sum(a.x for a in self.atoms)
        sy = sum(a.y for a in self.atoms)
        sz = sum(a.z for a in self.atoms)
        self.centroid = (sx / n, sy / n, sz / n)


Fragment = List[Atom]
FragmentLike = Union[Fragment, FragmentRecord]

def read_xyz(path: str) -> XYZ:
    with open(path, "r", encoding="utf-8") as f:
        lines = [ln.rstrip("\n") for ln in f.readlines()]
    if len(lines) < 2:
        raise ValueError("XYZ file too short.")
    try:
        n = int(lines[0].split()[0])
    except Exception as e:
        raise ValueError(f"Invalid XYZ first line: {lines[0]!r}") from e
    comment = lines[1] if len(lines) > 1 else ""
    atom_lines = lines[2:2+n]
    if len(atom_lines) < n:
        raise ValueError(f"XYZ atom count mismatch: header={n}, lines={len(atom_lines)}")
    atoms: List[Atom] = []
    for ln in atom_lines:
        parts = ln.split()
        if len(parts) < 4:
            raise ValueError(f"Bad atom line: {ln!r}")
        el = parts[0]
        x, y, z = map(float, parts[1:4])
        atoms.append(Atom(el, x, y, z))
    return XYZ(comment=comment, atoms=atoms)

def _atoms_of(fragment: FragmentLike) -> List[Atom]:
    return list(fragment.atoms) if isinstance(fragment, FragmentRecord) else list(fragment)


def write_xyz(path: str, fragments: Sequence[FragmentLike], comment: str = "") -> None:
    atoms: List[Atom] = []
    for frag in fragments:
        atoms.extend(_atoms_of(frag))
    with open(path, "w", encoding="utf-8") as f:
        f.write(f"{len(atoms)}\n")
        f.write((comment or "Generated by mbe-tools") + "\n")
        for a in atoms:
            f.write(f"{a.element:2s} {a.x: .10f} {a.y: .10f} {a.z: .10f}\n")

def fragment_by_water_heuristic(xyz: XYZ, oh_cutoff: float = 1.25) -> List[FragmentRecord]:
    """Heuristic fragmentation for water clusters (+ possible single-atom ions).

    Rule:
    - For each oxygen O, find its two nearest H within oh_cutoff and form a water fragment [O,H,H].
    - Any remaining atoms (e.g., ions) become single-atom fragments.

    Notes:
    - This assumes typical water ordering is *not* guaranteed, so we match by geometry.
    - If hydrogens are shared/ambiguous, unmatched atoms fall back to single fragments.
    """
    atoms = xyz.atoms
    O_idx = [i for i,a in enumerate(atoms) if a.element.upper() == "O"]
    H_idx = [i for i,a in enumerate(atoms) if a.element.upper() == "H"]
    used = set()

    fragments: List[FragmentRecord] = []
    for oi in O_idx:
        o = atoms[oi]
        # Find candidate H within cutoff
        hs = [(distance(o, atoms[hi]), hi) for hi in H_idx if hi not in used]
        hs = [t for t in hs if t[0] <= oh_cutoff]
        hs.sort(key=lambda x: x[0])
        if len(hs) >= 2:
            h1 = hs[0][1]; h2 = hs[1][1]
            used.add(oi); used.add(h1); used.add(h2)
            fragments.append(FragmentRecord([atoms[oi], atoms[h1], atoms[h2]], label="water", special=False))

    # Remaining atoms -> single fragments
    for i,a in enumerate(atoms):
        if i not in used:
            label = "ion" if len(a.element) <= 3 else "unknown"
            fragments.append(FragmentRecord([a], label=label, special=True))

    return fragments


def _guess_bonds(atoms: List[Atom], scale: float = 1.2) -> List[Tuple[int, int]]:
    bonds: List[Tuple[int, int]] = []
    for i, a in enumerate(atoms):
        ra = _COV_RAD.get(a.element.upper(), 0.7)
        for j in range(i + 1, len(atoms)):
            b = atoms[j]
            rb = _COV_RAD.get(b.element.upper(), 0.7)
            cutoff = scale * (ra + rb)
            if distance(a, b) <= cutoff:
                bonds.append((i, j))
    return bonds


def _connected_components(n: int, edges: List[Tuple[int, int]]) -> List[List[int]]:
    parent = list(range(n))

    def find(x: int) -> int:
        while parent[x] != x:
            parent[x] = parent[parent[x]]
            x = parent[x]
        return x

    def union(a: int, b: int) -> None:
        ra, rb = find(a), find(b)
        if ra != rb:
            parent[rb] = ra

    for a, b in edges:
        union(a, b)

    comps: dict[int, List[int]] = {}
    for i in range(n):
        r = find(i)
        comps.setdefault(r, []).append(i)
    return list(comps.values())


def fragment_by_connectivity(xyz: XYZ, scale: float = 1.2) -> List[FragmentRecord]:
    atoms = xyz.atoms
    bonds = _guess_bonds(atoms, scale=scale)
    comps = _connected_components(len(atoms), bonds)
    fragments: List[FragmentRecord] = []
    for comp in comps:
        frag_atoms = [atoms[i] for i in comp]
        label, special = _label_fragment(frag_atoms, comp_size=len(comp))
        frag = FragmentRecord(frag_atoms, label=label, special=special)
        fragments.append(frag)
    return fragments

def sample_fragments(
    fragments: Sequence[FragmentLike], n: int, seed: Optional[int] = None,
    require_ion: bool = False
) -> List[FragmentRecord]:
    """Randomly sample n fragments (metadata-aware).

    If require_ion=True, ensure at least one special fragment (or non-water if metadata missing) is included if present.
    """
    if n <= 0:
        raise ValueError("n must be > 0")
    if n > len(fragments):
        raise ValueError(f"n={n} is larger than available fragments={len(fragments)}")

    rng = random.Random(seed)

    def is_special(frag: FragmentLike) -> bool:
        if isinstance(frag, FragmentRecord):
            return frag.special
        # heuristic fallback
        if len(frag) != 3:
            return True
        els = sorted([a.element.upper() for a in frag])
        return els != ["H","H","O"]

    indices = list(range(len(fragments)))
    rng.shuffle(indices)

    if not require_ion:
        picked = indices[:n]
        return _as_records([fragments[i] for i in picked])

    # require_ion=True
    ion_indices = [i for i,f in enumerate(fragments) if is_special(f)]
    if not ion_indices:
        # no ions exist; just sample normally
        picked = indices[:n]
        return _as_records([fragments[i] for i in picked])

    # enforce at least one ion
    ion_i = rng.choice(ion_indices)
    rest = [i for i in indices if i != ion_i]
    picked = [ion_i] + rest[:n-1]
    rng.shuffle(picked)
    return _as_records([fragments[i] for i in picked])


def _as_records(fragments: Sequence[FragmentLike]) -> List[FragmentRecord]:
    records: List[FragmentRecord] = []
    for frag in fragments:
        if isinstance(frag, FragmentRecord):
            records.append(frag)
        else:
            records.append(FragmentRecord(list(frag)))
    return records


def spatial_sample_fragments(
    fragments: Sequence[FragmentLike],
    n: int,
    seed: Optional[int] = None,
    prefer_special: bool = True,
    k_neighbors: int = 4,
    start: str = "random",
    start_index: Optional[int] = None,
) -> List[FragmentRecord]:
    """Spatially compact sampling using centroids and greedy nearest selection."""

    if n <= 0:
        raise ValueError("n must be > 0")

    records = _as_records(fragments)
    if n > len(records):
        raise ValueError(f"n={n} exceeds available fragments={len(records)}")

    rng = random.Random(seed)
    idx_all = list(range(len(records)))

    special_indices = [i for i, r in enumerate(records) if r.special]

    # choose start
    if start == "index" and start_index is not None:
        start_i = start_index
    elif start == "special" and special_indices:
        start_i = special_indices[0]
    else:
        start_i = rng.randrange(len(records))

    if start_i < 0 or start_i >= len(records):
        raise ValueError("start_index out of range")

    picked = [start_i]

    # ensure at least one special if requested
    if prefer_special and special_indices and start_i not in special_indices and len(picked) < n:
        picked.append(special_indices[0])

    def centroid_distance(i: int, j: int) -> float:
        ci = records[i].centroid
        cj = records[j].centroid
        dx = ci[0] - cj[0]
        dy = ci[1] - cj[1]
        dz = ci[2] - cj[2]
        return math.sqrt(dx * dx + dy * dy + dz * dz)

    while len(picked) < n:
        remaining = [i for i in idx_all if i not in picked]
        if not remaining:
            break

        candidate_pool = set()
        for pi in picked:
            neighbors = sorted(remaining, key=lambda j: centroid_distance(pi, j))
            if k_neighbors > 0:
                neighbors = neighbors[: min(k_neighbors, len(neighbors))]
            candidate_pool.update(neighbors)
        if not candidate_pool:
            candidate_pool = set(remaining)

        if prefer_special and not any(records[i].special for i in picked):
            specials_in_pool = [j for j in candidate_pool if records[j].special]
            if specials_in_pool:
                best_special = min(
                    specials_in_pool,
                    key=lambda j: min(centroid_distance(j, p) for p in picked),
                )
                picked.append(best_special)
                continue

        def score(j: int) -> float:
            return min(centroid_distance(j, p) for p in picked)

        best = min(candidate_pool, key=score)
        best_score = score(best)
        tied = [c for c in candidate_pool if abs(score(c) - best_score) <= 1e-9]
        choice = rng.choice(tied)
        picked.append(choice)

    return [records[i] for i in picked[:n]]
