"""ContractVisualizer - Architecture Document Generator.

Generates comprehensive architecture documentation from NodeRegistry
contracts, including Mermaid diagrams for visual representation.
"""
from __future__ import annotations

import inspect
import os
import sys
from collections import defaultdict
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from langgraph.graph.state import CompiledStateGraph
    from agent_contracts.registry import NodeRegistry
    from agent_contracts.contracts import NodeContract, TriggerCondition


class ContractVisualizer:
    """Generate architecture documentation from NodeRegistry contracts.
    
    Example:
        visualizer = ContractVisualizer(registry)
        doc = visualizer.generate_architecture_doc()
        with open("ARCHITECTURE.md", "w") as f:
            f.write(doc)
    """
    
    def __init__(self, registry: "NodeRegistry", graph: "CompiledStateGraph | None" = None):
        """Initialize visualizer.
        
        Args:
            registry: NodeRegistry with registered nodes
            graph: Optional compiled LangGraph for flow visualization
        """
        self.registry = registry
        self.graph = graph
    
    def generate_architecture_doc(self) -> str:
        """Generate complete architecture document.
        
        Returns:
            Markdown document with all sections
        """
        sections = [
            self._generate_header(),
            self.generate_langgraph_flow(),  # Added LangGraph flow
            self.generate_state_slices_section(),
            self.generate_hierarchy_diagram(),
            self.generate_dataflow_diagram(),
            self.generate_trigger_hierarchy(),
            self.generate_nodes_reference(),
            self._generate_footer(),
        ]
        return "\n\n---\n\n".join(s for s in sections if s)
    
    def _generate_header(self) -> str:
        """Generate document header."""
        return """# üèóÔ∏è Agent Architecture

> Auto-generated from `NodeRegistry` contracts"""
    
    def _generate_footer(self) -> str:
        """Generate document footer."""
        return "<sub>Generated by `agent-contracts` visualizer</sub>"
    
    def generate_langgraph_flow(self) -> str:
        """Generate LangGraph flow visualization from compiled graph."""
        if not self.graph:
            self._debug("LangGraph flow skipped: graph is None")
            return ""

        mermaid = self._try_render_langgraph_mermaid()
        if not mermaid:
            self._debug("LangGraph flow skipped: mermaid rendering returned empty")
            return ""

        return f"""## üîó LangGraph Node Flow

> Auto-generated from compiled LangGraph

```mermaid
{mermaid}
```"""

    def _try_render_langgraph_mermaid(self) -> str:
        candidates: list[object] = []
        get_graph = getattr(self.graph, "get_graph", None)
        if callable(get_graph):
            try:
                candidates.append(self._call_get_graph(get_graph))
            except Exception as e:
                self._debug(
                    f"LangGraph get_graph() failed: {type(e).__name__}: {e}"
                )
                pass
        candidates.append(self.graph)

        for obj in candidates:
            for method_name in ("draw_mermaid", "to_mermaid"):
                method = getattr(obj, method_name, None)
                if not callable(method):
                    continue
                try:
                    rendered = method()
                except Exception as e:
                    self._debug(
                        f"LangGraph {type(obj).__name__}.{method_name}() failed: "
                        f"{type(e).__name__}: {e}"
                    )
                    continue

                if isinstance(rendered, bytes):
                    try:
                        rendered = rendered.decode("utf-8")
                    except Exception:
                        rendered = rendered.decode()
                elif not isinstance(rendered, str):
                    self._debug(
                        f"LangGraph {type(obj).__name__}.{method_name}() returned non-string; ignored"
                    )
                    continue

                rendered = rendered.strip()
                if rendered:
                    self._debug(f"LangGraph mermaid rendered via {type(obj).__name__}.{method_name}()")
                    return rendered

        return ""

    def _debug(self, message: str) -> None:
        if os.getenv("AGENT_CONTRACTS_DEBUG", "").strip().lower() in {"1", "true", "yes", "on"}:
            print(f"[agent-contracts][debug] {message}", file=sys.stderr)

    def _call_get_graph(self, get_graph) -> object:
        try:
            return get_graph()
        except TypeError as e:
            try:
                signature = inspect.signature(get_graph)
            except (TypeError, ValueError):
                raise e

            required = [
                p
                for p in signature.parameters.values()
                if p.default is inspect.Parameter.empty
                and p.kind
                in (inspect.Parameter.POSITIONAL_ONLY, inspect.Parameter.POSITIONAL_OR_KEYWORD)
            ]
            if len(required) == 1:
                return get_graph({})
            raise e

    
    # =========================================================================
    # State Slices Section
    # =========================================================================
    
    def generate_state_slices_section(self) -> str:
        """Generate State Slices documentation.
        
        Collects all slices from node contracts and creates documentation.
        """
        # Collect slices from all nodes
        all_reads: set[str] = set()
        all_writes: set[str] = set()
        
        for name in self.registry.get_all_nodes():
            contract = self.registry.get_contract(name)
            if contract:
                all_reads.update(contract.reads)
                all_writes.update(contract.writes)
        
        all_slices = sorted(all_reads | all_writes)
        
        if not all_slices:
            return ""
        
        # Build table
        lines = [
            "## üì¶ State Slices",
            "",
            "State is organized into isolated **slices** for separation of concerns.",
            "",
            "| Slice | Read By | Written By |",
            "|:------|:--------|:-----------|",
        ]
        
        for slice_name in all_slices:
            readers = [n for n in self.registry.get_all_nodes() 
                      if slice_name in (self.registry.get_contract(n).reads or [])]
            writers = [n for n in self.registry.get_all_nodes()
                      if slice_name in (self.registry.get_contract(n).writes or [])]
            
            readers_str = ", ".join(f"`{r}`" for r in readers)
            writers_str = ", ".join(f"`{w}`" for w in writers)
                
            lines.append(f"| `{slice_name}` | {readers_str or '-'} | {writers_str or '-'} |")
        
        return "\n".join(lines)
    
    def _build_slice_relationships(self) -> list[tuple[str, str, str]]:
        """Build slice relationships from node I/O patterns."""
        # Count how many nodes transform from one slice to another
        transform_counts: dict[tuple[str, str], int] = defaultdict(int)
        
        for name in self.registry.get_all_nodes():
            contract = self.registry.get_contract(name)
            if not contract:
                continue
            
            for read_slice in contract.reads:
                for write_slice in contract.writes:
                    if read_slice != write_slice:
                        transform_counts[(read_slice, write_slice)] += 1
        
        # Sort by count and take top relationships
        sorted_transforms = sorted(
            transform_counts.items(), 
            key=lambda x: x[1], 
            reverse=True
        )[:10]  # Limit to 10 most common to avoid diagram clutter
        
        return [
            (src, dst, f"{count} nodes")
            for (src, dst), count in sorted_transforms
        ]
    
    # =========================================================================
    # Hierarchy Diagram
    # =========================================================================
    
    def generate_hierarchy_diagram(self) -> str:
        """Generate Supervisor-Node hierarchy diagram."""
        # Group nodes by supervisor
        supervisors: dict[str, list[str]] = defaultdict(list)
        
        for name in self.registry.get_all_nodes():
            contract = self.registry.get_contract(name)
            if contract:
                supervisors[contract.supervisor].append(name)
        
        if not supervisors:
            return ""
        
        lines = [
            "## üéØ System Hierarchy",
            "",
            "```mermaid",
            "flowchart TB",
        ]
        
        # Generate subgraphs for each supervisor
        for sup_name, nodes in sorted(supervisors.items()):
            safe_sup = self._safe_id(sup_name)
            lines.append(f'    subgraph {safe_sup}["üéØ {sup_name.replace("_", " ").title()}"]')
            lines.append("        direction LR")
            
            for node_name in nodes:
                contract = self.registry.get_contract(node_name)
                icon = self._get_node_icon(contract)
                safe_node = self._safe_id(node_name)
                lines.append(f'        {safe_node}["{icon} {node_name}"]')
            
            lines.append("    end")
        
        # Add terminal node styling
        terminal_nodes = [
            self._safe_id(n) for n in self.registry.get_all_nodes()
            if self.registry.get_contract(n) and self.registry.get_contract(n).is_terminal
        ]
        if terminal_nodes:
            lines.append("")
            lines.append("    classDef terminal fill:#e94560,stroke:#16213e,color:#fff")
            lines.append(f"    class {','.join(terminal_nodes)} terminal")
        
        lines.append("```")
        
        return "\n".join(lines)
    
    def _get_node_icon(self, contract: "NodeContract | None") -> str:
        """Get emoji icon for node based on its properties.
        
        Priority: 
        1. Custom icon from contract
        2. Terminal node icon
        3. LLM indicator + base icon
        4. Default icon based on common node name patterns
        """
        if not contract:
            return "üì¶"
        
        # 1. Use custom icon if provided
        if contract.icon:
            base_icon = contract.icon
        # 2. Terminal nodes
        elif contract.is_terminal:
            base_icon = "üîö"
        # 3. Common patterns (generic)
        elif "search" in contract.name.lower():
            base_icon = "üîç"
        elif "process" in contract.name.lower():
            base_icon = "‚öôÔ∏è"
        elif "validate" in contract.name.lower():
            base_icon = "‚úÖ"
        elif "notify" in contract.name.lower():
            base_icon = "üì¢"
        else:
            base_icon = "üì¶"
            
        # Add LLM indicator if applicable
        if contract.requires_llm:
            return f"ü§ñ{base_icon}"
            
        return base_icon
    
    def _safe_id(self, name: str) -> str:
        """Convert name to safe Mermaid ID."""
        return name.replace("-", "_").replace(" ", "_")
    
    # =========================================================================
    # Data Flow Diagram
    # =========================================================================
    
    def generate_dataflow_diagram(self) -> str:
        """Generate data flow diagram showing key data paths.
        
        Shows:
        - Slices as central data stores
        - Entry points (nodes reading request)
        - Terminal nodes (marked with is_terminal)
        - Cross-supervisor data connections
        """
        # Group nodes by supervisor
        supervisors: dict[str, list[str]] = defaultdict(list)
        for name in self.registry.get_all_nodes():
            contract = self.registry.get_contract(name)
            if contract:
                supervisors[contract.supervisor].append(name)
        
        if not supervisors:
            return ""
        
        lines = [
            "## üîÄ Data Flow",
            "",
            "> Key data paths through the system",
            "",
            "```mermaid",
            "flowchart TB",
        ]
        
        # Find key nodes: entry points (read request) and terminals
        entry_nodes: list[str] = []
        terminal_nodes: list[str] = []
        for name in self.registry.get_all_nodes():
            contract = self.registry.get_contract(name)
            if contract:
                if "request" in contract.reads:
                    entry_nodes.append(name)
                if contract.is_terminal:
                    terminal_nodes.append(name)
        
        # Add slices (excluding _internal)
        key_slices = ["request", "response"]
        for name in self.registry.get_all_nodes():
            contract = self.registry.get_contract(name)
            if contract:
                for s in contract.reads + contract.writes:
                    if not s.startswith('_') and s not in key_slices:
                        key_slices.append(s)
        
        # Slices subgraph
        lines.append('    subgraph slices["üì¶ State"]')
        for slice_name in sorted(set(key_slices)):
            icon = "üì•" if slice_name == "request" else "üì§" if slice_name == "response" else "üìÅ"
            slice_id = f"slice_{self._safe_id(slice_name)}"
            lines.append(f'        {slice_id}[("{icon} {slice_name}")]')
        lines.append("    end")
        lines.append("")
        
        # Add supervisor subgraphs with their nodes
        for sup_name, nodes in sorted(supervisors.items()):
            safe_sup = f"sup_{self._safe_id(sup_name)}"
            lines.append(f'    subgraph {safe_sup}["üéØ {sup_name}"]')
            lines.append("        direction LR")
            for node_name in nodes:
                contract = self.registry.get_contract(node_name)
                icon = self._get_node_icon(contract)
                safe_node = self._safe_id(node_name)
                lines.append(f'        {safe_node}["{icon} {node_name}"]')
            lines.append("    end")
        
        lines.append("")
        
        # Add edges: request -> entry nodes
        lines.append("    %% Entry points")
        for node_name in entry_nodes:  # Show all entry points
            lines.append(f"    slice_request --> {self._safe_id(node_name)}")
        
        # Add edges: nodes writing to response -> response
        lines.append("    %% Response outputs")
        response_writers: list[str] = []
        for name in self.registry.get_all_nodes():
            contract = self.registry.get_contract(name)
            if contract and "response" in contract.writes:
                response_writers.append(name)
        for node_name in response_writers:  # Show all response writers
            lines.append(f"    {self._safe_id(node_name)} --> slice_response")
        
        # Add edges for other slices (excluding request/response/_internal)
        lines.append("    %% Slice data flows")
        other_slices = [s for s in key_slices if s not in ["request", "response"]]
        for slice_name in other_slices:
            slice_id = f"slice_{self._safe_id(slice_name)}"
            # Find readers and writers for this slice
            readers: list[str] = []
            writers: list[str] = []
            for name in self.registry.get_all_nodes():
                contract = self.registry.get_contract(name)
                if contract:
                    if slice_name in contract.reads:
                        readers.append(name)
                    if slice_name in contract.writes:
                        writers.append(name)
            # Add writer -> slice edges
            for node_name in writers:
                lines.append(f"    {self._safe_id(node_name)} -.-> {slice_id}")
            # Add slice -> reader edges
            for node_name in readers:
                lines.append(f"    {slice_id} -.-> {self._safe_id(node_name)}")
        
        # Styling
        lines.extend([
            "",
            "    classDef slice fill:#f5f5f5,stroke:#999",
            "    classDef terminal fill:#e94560,stroke:#16213e,color:#fff",
        ])
        terminal_ids = [self._safe_id(n) for n in terminal_nodes]
        if terminal_ids:
            lines.append(f"    class {','.join(terminal_ids)} terminal")
        
        lines.append("```")
        
        # Add detailed node dependencies in collapsible section
        lines.extend([
            "",
            "<details>",
            "<summary>üìä Detailed Node Dependencies</summary>",
            "",
        ])
        
        # Build dependency table grouped by supervisor
        dependencies = self.registry.analyze_data_flow()
        
        for sup_name, nodes in sorted(supervisors.items()):
            sup_deps = [(n, dependencies.get(n, [])) for n in nodes if dependencies.get(n)]
            if not sup_deps:
                continue
                
            lines.append(f"**{sup_name}**")
            lines.append("")
            lines.append("| Node | Depends On (via shared slices) |")
            lines.append("|:-----|:-------------------------------|")
            
            for node_name, deps in sup_deps:
                if deps:
                    # Find shared slices for each dependency
                    dep_info = []
                    node_contract = self.registry.get_contract(node_name)
                    for dep in deps:  # Show all dependencies
                        dep_contract = self.registry.get_contract(dep)
                        if node_contract and dep_contract:
                            shared = set(node_contract.reads) & set(dep_contract.writes)
                            shared_str = ", ".join(sorted(s for s in shared if not s.startswith('_')))
                            if shared_str:
                                dep_info.append(f"`{dep}` ({shared_str})")
                            else:
                                dep_info.append(f"`{dep}`")
                    if dep_info:
                        lines.append(f"| `{node_name}` | {', '.join(dep_info)} |")
            
            lines.append("")
        
        lines.extend([
            "</details>",
        ])
        
        return "\n".join(lines)
    
    # =========================================================================
    # Trigger Hierarchy
    # =========================================================================
    
    def generate_trigger_hierarchy(self) -> str:
        """Generate trigger hierarchy documentation."""
        # Group by supervisor
        supervisors: dict[str, list[tuple[str, "NodeContract"]]] = defaultdict(list)
        
        for name in self.registry.get_all_nodes():
            contract = self.registry.get_contract(name)
            if contract:
                supervisors[contract.supervisor].append((name, contract))
        
        if not supervisors:
            return ""
        
        lines = [
            "## ‚ö° Trigger Hierarchy",
            "",
            "> Nodes are evaluated by **priority** (highest first)",
        ]
        
        for sup_name, nodes in sorted(supervisors.items()):
            lines.extend([
                "",
                f"### üéØ {sup_name.replace('_', ' ').title()}",
                "",
                "| Priority | Node | Condition | Hint |",
                "|:--------:|:-----|:----------|:-----|",
            ])
            
            # Sort nodes by highest trigger priority
            def get_max_priority(item: tuple[str, "NodeContract"]) -> int:
                _, contract = item
                if not contract.trigger_conditions:
                    return -1
                return max(c.priority for c in contract.trigger_conditions)
            
            sorted_nodes = sorted(nodes, key=get_max_priority, reverse=True)
            
            for name, contract in sorted_nodes:
                if not contract.trigger_conditions:
                    # No trigger conditions - default node
                    lines.append(f"| üü¢ _(default)_ | `{name}` | _(default)_ | - |")
                else:
                    # Sort conditions by priority (highest first)
                    sorted_conditions = sorted(
                        contract.trigger_conditions,
                        key=lambda c: c.priority,
                        reverse=True
                    )
                    
                    # First condition: show node name
                    first_cond = sorted_conditions[0]
                    priority_icon = self._get_priority_icon(first_cond.priority)
                    condition_str = self._format_single_condition(first_cond)
                    hint = first_cond.llm_hint or "-"
                    
                    lines.append(
                        f"| {priority_icon} **{first_cond.priority}** | "
                        f"`{name}` | {condition_str} | {hint} |"
                    )
                    
                    # Remaining conditions: use continuation symbol
                    for cond in sorted_conditions[1:]:
                        priority_icon = self._get_priority_icon(cond.priority)
                        condition_str = self._format_single_condition(cond)
                        hint = cond.llm_hint or "-"
                        
                        lines.append(
                            f"| {priority_icon} **{cond.priority}** | "
                            f"‚Ü≥ | {condition_str} | {hint} |"
                        )
            
            # Add Mermaid diagram for this supervisor
            lines.extend([
                "",
                "<details>",
                f"<summary>üìä {sup_name} Priority Chain</summary>",
                "",
                "```mermaid",
                "flowchart TD",
                f'    subgraph {self._safe_id(sup_name)}["{sup_name}"]',
                "        direction TB",
            ])
            
            prev_node = None
            for name, contract in sorted_nodes:
                if not contract.trigger_conditions:
                    # Default node
                    safe_name = self._safe_id(name)
                    lines.append(f'        {safe_name}["üü¢ P-1: {name}"]')
                    if prev_node:
                        lines.append(f'        {prev_node} -->|"not matched"| {safe_name}')
                    prev_node = safe_name
                else:
                    # Node with multiple conditions - show all in diagram
                    sorted_conditions = sorted(
                        contract.trigger_conditions,
                        key=lambda c: c.priority,
                        reverse=True
                    )
                    
                    for idx, cond in enumerate(sorted_conditions):
                        priority_icon = self._get_priority_icon(cond.priority)
                        safe_name = self._safe_id(f"{name}_cond{idx}")
                        condition_label = self._format_single_condition(cond)
                        # Escape quotes and use <br/> for line break
                        condition_label = condition_label.replace('"', "'")
                        node_label = f"{priority_icon} P{cond.priority}: {name}"
                        if len(sorted_conditions) > 1:
                            node_label += f" [{idx+1}/{len(sorted_conditions)}]"
                        lines.append(f'        {safe_name}["{node_label}<br/>{condition_label}"]')
                        
                        if prev_node:
                            lines.append(f'        {prev_node} -->|"not matched"| {safe_name}')
                        prev_node = safe_name
            
            lines.extend([
                "    end",
                "```",
                "",
                "</details>",
            ])
        
        return "\n".join(lines)
    
    def _get_priority_icon(self, priority: int) -> str:
        """Get priority indicator icon."""
        if priority >= 100:
            return "üî¥"
        elif priority >= 50:
            return "üü°"
        elif priority >= 10:
            return "üü¢"
        else:
            return "‚ö™"
    
    def _format_single_condition(self, condition: "TriggerCondition") -> str:
        """Format a single trigger condition for display.
        
        Args:
            condition: The trigger condition to format
            
        Returns:
            Formatted condition string
        """
        if not condition.when and not condition.when_not:
            return "_(always)_"
        
        parts = []
        if condition.when:
            for key, value in list(condition.when.items())[:2]:
                parts.append(f"`{key}={value}`")
        if condition.when_not:
            for key, value in list(condition.when_not.items())[:1]:
                parts.append(f"`{key}‚â†{value}`")
        
        result = ", ".join(parts) if parts else "_(always)_"
        
        # Show count if truncated
        total_items = len(condition.when or {}) + len(condition.when_not or {})
        if total_items > 3:
            result += f" _(+{total_items - 3} more)_"
        
        return result
    
    def _summarize_conditions(self, conditions: list["TriggerCondition"]) -> str:
        """Summarize trigger conditions for display.
        
        DEPRECATED: Use _format_single_condition() for individual conditions.
        This method only returns the highest priority condition.
        """
        if not conditions:
            return "_(default)_"
        
        # Get highest priority condition
        highest = max(conditions, key=lambda c: c.priority)
        return self._format_single_condition(highest)
    
    # =========================================================================
    # Nodes Reference
    # =========================================================================
    
    def generate_nodes_reference(self) -> str:
        """Generate nodes reference table."""
        nodes = self.registry.get_all_nodes()
        
        if not nodes:
            return ""
        
        lines = [
            "## üìö Nodes Reference",
            "",
            "| Node | Supervisor | Reads | Writes | LLM | Terminal |",
            "|:-----|:-----------|:------|:-------|:---:|:--------:|",
        ]
        
        for name in sorted(nodes):
            contract = self.registry.get_contract(name)
            if not contract:
                continue
            
            reads = ", ".join(f"`{r}`" for r in contract.reads) or "-"
            writes = ", ".join(f"`{w}`" for w in contract.writes) or "-"
            llm = "‚úÖ" if contract.requires_llm else ""
            terminal = "üîö" if contract.is_terminal else ""
            
            lines.append(f"| `{name}` | {contract.supervisor} | {reads} | {writes} | {llm} | {terminal} |")
        
        lines.extend([
            "",
            "<details>",
            "<summary>üîç Legend</summary>",
            "",
            "- ‚úÖ = Requires LLM",
            "- üîö = Terminal node (exits to END)",
            "- Reads/Writes = State slices accessed",
            "",
            "</details>",
        ])
        
        return "\n".join(lines)
