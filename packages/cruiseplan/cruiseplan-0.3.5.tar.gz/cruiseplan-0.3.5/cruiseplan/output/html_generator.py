"""
HTML Schedule Generation System.

Generates comprehensive HTML reports with summary tables and detailed activity listings
for cruise planning and execution. Provides human-readable visualizations of cruise
schedules including statistics, timelines, and operational details.

Notes
-----
The HTML generator creates self-contained HTML files with embedded CSS styling,
requiring no external dependencies for viewing. Output includes summary statistics
for different activity types (moorings, stations, surveys, areas) and detailed
tables for each operation type.
"""

import logging
from pathlib import Path

from cruiseplan.calculators.scheduler import (
    ActivityRecord,
    calculate_timeline_statistics,
)
from cruiseplan.output.output_utils import (
    format_activity_type,
    get_activity_depth,
    get_activity_position,
)
from cruiseplan.schema import CruiseConfig
from cruiseplan.utils.units import NM_PER_KM, hours_to_days

logger = logging.getLogger(__name__)


def _convert_decimal_to_deg_min_html(decimal_degrees):
    """
    Convert decimal degrees to DD MM.mmm format for HTML display.

    Parameters
    ----------
    decimal_degrees : float
        Latitude or longitude in decimal degrees.

    Returns
    -------
    str
        Formatted coordinate string in DD MM.mmm format with leading zeros.
    """
    degrees = int(abs(decimal_degrees))
    minutes = abs((abs(decimal_degrees) - degrees) * 60)

    if decimal_degrees >= 0:
        return f"{degrees:02d} {minutes:06.3f}"
    else:
        return f"-{degrees:02d} {minutes:06.3f}"
    degrees = int(abs(decimal_degrees))
    minutes = abs((abs(decimal_degrees) - degrees) * 60)

    if decimal_degrees >= 0:
        return f"{degrees:02d} {minutes:06.3f}"
    else:
        return f"-{degrees:02d} {minutes:06.3f}"


class HTMLGenerator:
    """
    Manages HTML generation for cruise schedules with summary tables and detailed listings.

    This class provides methods to generate comprehensive HTML reports from cruise
    schedule data, including summary statistics and detailed activity breakdowns.
    """

    def __init__(self):
        """Initialize the HTML generator."""
        pass

    def generate_schedule_report(
        self, config: CruiseConfig, timeline: list[ActivityRecord], output_file: Path
    ) -> Path:
        """
        Generate comprehensive HTML schedule report.

        Parameters
        ----------
        config : CruiseConfig
            The cruise configuration object
        timeline : List[ActivityRecord]
            Timeline generated by the scheduler
        output_file : Path
            Path to output HTML file

        Returns
        -------
        Path
            Path to generated HTML file
        """
        # Calculate summary statistics using scheduler function
        stats = calculate_timeline_statistics(timeline)

        # Calculate total statistics - use simple sum like CLI to avoid categorization errors
        total_duration_h = (
            sum(activity["duration_minutes"] for activity in timeline) / 60.0
        )
        total_duration_days = hours_to_days(total_duration_h)

        # Create HTML content
        html_content = f"""<!DOCTYPE html>
<html>
<head>
    <title>Schedule for {config.cruise_name}</title>
    <style>
        body {{ font-family: Arial, sans-serif; margin: 20px; }}
        table {{ border-collapse: collapse; width: 100%; margin-bottom: 20px; }}
        th, td {{ border: 1px solid #ddd; padding: 5px; text-align: left; }}
        th {{ background-color: #f2f2f2; }}
        .number {{ text-align: right; }}
        h1, h2 {{ color: #333; }}
        .description {{ font-style: italic; color: #666; }}
    </style>
</head>
<body>
    <h1>{config.cruise_name}</h1>
    {f'<p class="description">{config.description}</p>' if config.description else ''}

    <h2>1. Cruise Schedule</h2>
    <table cellpadding="5" cellspacing="0" border="1">
        <tr>
            <th>Activity</th>
            <th>Description</th>
            <th>Hours</th>
            <th>Days</th>
        </tr>
"""

        # Moorings row
        if stats["moorings"]["count"] > 0:
            html_content += f"""
        <tr>
            <td>Moorings</td>
            <td>{stats["moorings"]["count"]} operations, avg {stats["moorings"]["avg_duration_h"]:.1f} hrs each</td>
            <td class="number">{stats["moorings"]["total_duration_h"]:.1f}</td>
            <td class="number">{stats["moorings"]["total_duration_days"]:.1f}</td>
        </tr>
"""

        # CTD Profiles row
        if stats["stations"]["count"] > 0:
            html_content += f"""
        <tr>
            <td>CTD Profiles</td>
            <td>{stats["stations"]["count"]} stations, avg depth {stats["stations"]["avg_depth_m"]:.0f} m, avg {stats["stations"]["avg_duration_h"]:.1f} hrs each</td>
            <td class="number">{stats["stations"]["total_duration_h"]:.1f}</td>
            <td class="number">{stats["stations"]["total_duration_days"]:.1f}</td>
        </tr>
"""

        # Survey operations row
        if stats["surveys"]["count"] > 0:
            html_content += f"""
        <tr>
            <td>Survey operations</td>
            <td>{stats["surveys"]["count"]} operations, avg distance {stats["surveys"]["avg_distance_nm"]:.1f} nm, avg {stats["surveys"]["avg_duration_h"]:.1f} hrs each</td>
            <td class="number">{stats["surveys"]["total_duration_h"]:.1f}</td>
            <td class="number">{stats["surveys"]["total_duration_days"]:.1f}</td>
        </tr>
"""

        # Area operations row
        if stats["areas"]["count"] > 0:
            html_content += f"""
        <tr>
            <td>Area operations</td>
            <td>{stats["areas"]["count"]} operations, avg {stats["areas"]["avg_duration_h"]:.1f} hrs each</td>
            <td class="number">{stats["areas"]["total_duration_h"]:.1f}</td>
            <td class="number">{stats["areas"]["total_duration_days"]:.1f}</td>
        </tr>
"""

        # Transit within area row
        if stats["within_area_transits"]["total_distance_nm"] > 0:
            html_content += f"""
        <tr>
            <td>Transit within area</td>
            <td>{stats["within_area_transits"]["total_distance_nm"]:.1f} nm, avg {stats["within_area_transits"]["avg_speed_kt"]:.1f} kts</td>
            <td class="number">{stats["within_area_transits"]["total_duration_h"]:.1f}</td>
            <td class="number">{stats["within_area_transits"]["total_duration_days"]:.1f}</td>
        </tr>
"""

        # Transit to/from working area row (combine both directions)
        total_port_distance_nm = (
            stats["port_transits_to_area"]["total_distance_nm"]
            + stats["port_transits_from_area"]["total_distance_nm"]
        )
        total_port_duration_h = (
            stats["port_transits_to_area"]["total_duration_h"]
            + stats["port_transits_from_area"]["total_duration_h"]
        )
        total_port_duration_days = (
            stats["port_transits_to_area"]["total_duration_days"]
            + stats["port_transits_from_area"]["total_duration_days"]
        )
        avg_port_speed_kt = (
            total_port_distance_nm / total_port_duration_h
            if total_port_duration_h > 0
            else 0
        )

        if total_port_distance_nm > 0:
            html_content += f"""
        <tr>
            <td>Transit to/from working area</td>
            <td>{total_port_distance_nm:.1f} nm, avg {avg_port_speed_kt:.1f} kts</td>
            <td class="number">{total_port_duration_h:.1f}</td>
            <td class="number">{total_port_duration_days:.1f}</td>
        </tr>
"""

        # All activities are now accounted for in the timeline-based categorization

        # Total row
        html_content += f"""
        <tr style="font-weight: bold;">
            <td>Total Cruise</td>
            <td>{stats["total_scientific"]} operations</td>
            <td class="number">{total_duration_h:.1f}</td>
            <td class="number">{total_duration_days:.1f}</td>
        </tr>
    </table>
"""

        # Moorings detail table
        html_content += """
    <h2>2. Moorings</h2>
    <table cellpadding="5" cellspacing="0" border="1">
        <tr>
            <th>Name</th>
            <th>Comment</th>
            <th>Position (Decimal)</th>
            <th>Position (DD MM.mmm)</th>
            <th>Depth (m)</th>
            <th>Duration (hrs)</th>
            <th>Action</th>
        </tr>
"""

        if stats["mooring_activities"]:
            for mooring in stats["mooring_activities"]:
                lat, lon = get_activity_position(mooring)
                lat_ddm = _convert_decimal_to_deg_min_html(lat)
                lon_ddm = _convert_decimal_to_deg_min_html(lon)
                comment = mooring.get("comment", "")
                depth = get_activity_depth(mooring)
                action = mooring.get("action", "N/A")

                html_content += f"""
        <tr>
            <td>{mooring['label']}</td>
            <td>{comment}</td>
            <td>{lat:.6f}, {lon:.6f}</td>
            <td>{lat_ddm}, {lon_ddm}</td>
            <td class="number">{depth:.0f}</td>
            <td class="number">{mooring['duration_minutes']/60:.1f}</td>
            <td>{action}</td>
        </tr>
"""
        else:
            html_content += """
        <tr>
            <td colspan="7">No moorings defined</td>
        </tr>
"""

        html_content += """
    </table>
"""

        # Add leg schedule section
        html_content += self._generate_leg_schedules(config, timeline, stats)

        # Try to link to the cruise track map if it exists
        map_filename = f"{config.cruise_name}_schedule.png"
        map_path = output_file.parent / map_filename
        if map_path.exists():
            html_content += f"""
    <h2>4. Cruise Track Map</h2>
    <div style="text-align: center; margin: 20px 0;">
        <img src="{map_filename}"
             alt="Cruise Track Map for {config.cruise_name}"
             style="max-width: 100%; height: auto; border: 1px solid #ccc; box-shadow: 2px 2px 8px rgba(0,0,0,0.1);">
        <p style="font-style: italic; color: #666; margin-top: 10px;">
            Figure 1: Cruise track map showing station locations, bathymetric context, and planned route.
        </p>
    </div>
"""

        html_content += """
</body>
</html>
"""

        # Write to file
        output_file.parent.mkdir(parents=True, exist_ok=True)
        with open(output_file, "w", encoding="utf-8") as f:
            f.write(html_content)

        return output_file

    def _generate_leg_schedules(
        self, config: CruiseConfig, timeline: list[ActivityRecord], stats: dict
    ) -> str:
        """
        Generate HTML section with per-leg schedule tables.

        Parameters
        ----------
        config : CruiseConfig
            Cruise configuration
        timeline : List[ActivityRecord]
            Complete timeline from scheduler
        stats : dict
            Statistics from summary calculation

        Returns
        -------
        str
            HTML content for leg schedules section
        """
        html_content = """
    <h2>3. Leg Schedules</h2>
    <p>Individual leg schedules including transit connections between legs.</p>
"""

        # Group activities by leg
        legs_data = self._group_activities_by_leg(config, timeline)

        # Generate table for each leg
        for i, (leg_name, leg_data) in enumerate(legs_data.items(), 1):
            leg_letter = chr(ord("a") + i - 1)  # a, b, c, ...

            html_content += f"""
    <h3>3{leg_letter}. {leg_name}</h3>
    <table cellpadding="5" cellspacing="0" border="1">
        <tr>
            <th>Activity</th>
            <th>Type</th>
            <th>Entry Position</th>
            <th>Exit Position</th>
            <th>Distance (nm)</th>
            <th>Duration (hrs)</th>
            <th>Comments</th>
        </tr>
"""

            total_leg_duration = 0

            # Transit information is now handled by scheduler Port_Departure/Port_Arrival activities
            # No need to add separate transit rows as they would be duplicated

            # Add leg activities
            activities = leg_data["activities"]
            for i, activity in enumerate(activities):
                duration_hrs = activity.get("duration_minutes", 0) / 60
                total_leg_duration += duration_hrs

                # Determine entry and exit positions based on activity type
                entry_position, exit_position, distance_nm = (
                    self._get_activity_entry_exit_distance(activity, activities, i)
                )

                # Determine activity type using shared utility
                activity_type = format_activity_type(activity)

                html_content += f"""
        <tr>
            <td>{activity.get('label', 'Unknown')}</td>
            <td>{activity_type}</td>
            <td>{entry_position}</td>
            <td>{exit_position}</td>
            <td class="number">{distance_nm}</td>
            <td class="number">{duration_hrs:.1f}</td>
            <td>{activity.get('comment', '')}</td>
        </tr>
"""

            # Transit to arrival port is now handled by scheduler Port_Arrival activities

            # Get scientific operations count from scheduler stats instead of recalculating
            leg_stats = stats.get("leg_stats", {})
            leg_stat = leg_stats.get(leg_name, {})
            scientific_operations_count = leg_stat.get("total_scientific", 0)

            # Add leg total row
            html_content += f"""
        <tr style="font-weight: bold; background-color: #f2f2f2;">
            <td>Leg Total</td>
            <td>{scientific_operations_count} operations</td>
            <td></td>
            <td></td>
            <td></td>
            <td class="number">{total_leg_duration:.1f}</td>
            <td>{hours_to_days(total_leg_duration):.1f} days</td>
        </tr>
    </table>
"""

        return html_content

    def _group_activities_by_leg(
        self, config: CruiseConfig, timeline: list[ActivityRecord]
    ) -> dict:
        """
        Group timeline activities by leg and add appropriate transit connections.

        Parameters
        ----------
        config : CruiseConfig
            Cruise configuration
        timeline : List[ActivityRecord]
            Complete timeline from scheduler

        Returns
        -------
        dict
            Dictionary mapping leg names to leg data including activities and transits
        """
        legs_data = {}

        # Get leg names from config
        leg_names = (
            [leg.name for leg in config.legs]
            if hasattr(config, "legs") and config.legs
            else []
        )

        if not leg_names:
            # If no legs defined, create a single "Main Cruise" leg
            main_activities = []
            for activity in timeline:
                if isinstance(activity, dict):
                    main_activities.append(activity)
                elif hasattr(activity, "__dict__"):
                    main_activities.append(vars(activity))
                else:
                    main_activities.append(
                        {
                            "label": getattr(activity, "label", "Unknown"),
                            "lat": getattr(activity, "lat", 0.0),
                            "lon": getattr(activity, "lon", 0.0),
                            "duration_minutes": getattr(
                                activity, "duration_minutes", 0
                            ),
                            "activity": getattr(activity, "activity", "Unknown"),
                            "operation_type": getattr(
                                activity, "operation_type", "Unknown"
                            ),
                            "action": getattr(activity, "action", ""),
                            "comment": getattr(activity, "comment", ""),
                        }
                    )

            legs_data["Main Cruise"] = {
                "activities": main_activities,
            }
            return legs_data

        # Initialize legs
        for leg_name in leg_names:
            legs_data[leg_name] = {
                "activities": [],
            }

        # Group activities by leg using leg_name field
        for activity in timeline:
            # ActivityRecord is a dict, so use .get() instead of getattr()
            leg_name = (
                activity.get("leg_name", None)
                if isinstance(activity, dict)
                else getattr(activity, "leg_name", None)
            )

            # Convert activity to dict safely - ActivityRecord is already a dict
            if isinstance(activity, dict):
                activity_dict = activity
            elif hasattr(activity, "__dict__"):
                activity_dict = vars(activity)
            else:
                # Fallback for objects without __dict__
                activity_dict = {
                    "label": getattr(activity, "label", "Unknown"),
                    "lat": getattr(activity, "lat", 0.0),
                    "lon": getattr(activity, "lon", 0.0),
                    "duration_minutes": getattr(activity, "duration_minutes", 0),
                    "activity": getattr(activity, "activity", "Unknown"),
                    "operation_type": getattr(activity, "operation_type", "Unknown"),
                    "action": getattr(activity, "action", ""),
                    "comment": getattr(activity, "comment", ""),
                }

            if leg_name and leg_name in legs_data:
                legs_data[leg_name]["activities"].append(activity_dict)
            # If no leg_name, assign to first leg or create default
            elif leg_names:
                legs_data[leg_names[0]]["activities"].append(activity_dict)
            else:
                legs_data.setdefault(
                    "Main Cruise",
                    {
                        "activities": [],
                    },
                )
                legs_data["Main Cruise"]["activities"].append(activity_dict)

        # Add transit connections between legs
        self._add_leg_transits(legs_data, config)

        return legs_data

    def _get_activity_entry_exit_distance(self, activity, activities, index):
        """
        Determine entry position, exit position, and distance for an activity.

        Parameters
        ----------
        activity : dict
            Current activity record
        activities : list
            List of all activities in this leg
        index : int
            Index of current activity in the activities list

        Returns
        -------
        tuple
            (entry_position, exit_position, distance_nm) as formatted strings and float
        """
        # Get current activity position
        if "lat" in activity and "lon" in activity:
            current_pos = f"{activity['lat']:.4f}, {activity['lon']:.4f}"
        else:
            current_pos = "N/A"

        # Get operation class for extensible categorization
        operation_class = activity.get("operation_class", "Unknown")

        # For PointOperations: entry = exit = activity position
        if operation_class == "PointOperation":
            # Use entry/exit coordinates if available, otherwise fall back to lat/lon
            if "entry_lat" in activity and "entry_lon" in activity:
                entry_position = (
                    f"{activity['entry_lat']:.4f}, {activity['entry_lon']:.4f}"
                )
                exit_position = (
                    f"{activity['exit_lat']:.4f}, {activity['exit_lon']:.4f}"
                )
            else:
                entry_position = current_pos
                exit_position = current_pos

            # All operations use the unified distance field
            distance_nm = activity.get("dist_nm", 0.0)

        # For LineOperations and AreaOperations: use entry/exit coordinates
        elif (
            operation_class in ["LineOperation", "AreaOperation"]
            or operation_class == "NavigationalTransit"
        ):
            if "entry_lat" in activity and "entry_lon" in activity:
                entry_position = (
                    f"{activity['entry_lat']:.4f}, {activity['entry_lon']:.4f}"
                )
                exit_position = (
                    f"{activity['exit_lat']:.4f}, {activity['exit_lon']:.4f}"
                )
            else:
                entry_position = current_pos
                exit_position = current_pos
            # All operations use the unified distance field
            distance_nm = activity.get("dist_nm", 0.0)

        else:
            # Unknown operation class: use current position for both
            entry_position = current_pos
            exit_position = current_pos
            distance_nm = activity.get("dist_nm", 0.0)

        # Format distance
        if distance_nm == 0.0:
            distance_str = "-"
        else:
            distance_str = f"{distance_nm:.1f}"

        return entry_position, exit_position, distance_str

    def _add_leg_transits(self, legs_data: dict, config: CruiseConfig):
        """
        Add transit connections between legs.

        Parameters
        ----------
        legs_data : dict
            Leg data dictionary to modify
        config : CruiseConfig
            Cruise configuration
        """
        from cruiseplan.calculators.distance import haversine_distance

        def calculate_transit_duration(
            start_pos: str, end_pos: str, vessel_speed_knots: float = 8.0
        ) -> float:
            """Calculate transit duration in minutes based on distance and vessel speed."""
            try:
                # Parse position strings like "12.3456, -67.8901"
                start_lat, start_lon = map(float, start_pos.split(", "))
                end_lat, end_lon = map(float, end_pos.split(", "))

                # Calculate distance in km
                distance_km = haversine_distance(
                    (start_lat, start_lon), (end_lat, end_lon)
                )

                # Convert to nautical miles and calculate duration
                distance_nm = distance_km * NM_PER_KM  # km to nautical miles
                duration_hours = distance_nm / vessel_speed_knots
                return duration_hours * 60  # convert to minutes
            except (ValueError, AttributeError):
                # Fallback to reasonable default if parsing fails
                return 120.0  # 2 hours default

        # Transit calculations removed - now handled by scheduler Port_Departure/Port_Arrival activities
        # This eliminates duplication between scheduler activities and HTML generator calculations


def generate_html_schedule(
    config: CruiseConfig, timeline: list[ActivityRecord], output_file: Path
) -> Path:
    """
    Main interface to generate HTML schedule from scheduler timeline.

    Parameters
    ----------
    config : CruiseConfig
        The cruise configuration object
    timeline : List[ActivityRecord]
        Timeline generated by the scheduler
    output_file : Path
        Path to output HTML file

    Returns
    -------
    Path
        Path to generated HTML file
    """
    logger.info(f"üåê HTML Generator: Starting generation of {output_file}")
    logger.info(f"   Timeline contains {len(timeline)} activities")

    generator = HTMLGenerator()
    return generator.generate_schedule_report(config, timeline, output_file)
