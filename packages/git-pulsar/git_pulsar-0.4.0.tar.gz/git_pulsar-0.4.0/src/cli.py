import os
import shutil
import subprocess
import sys
import textwrap
from pathlib import Path

from . import service

REGISTRY_FILE = Path.home() / ".git_pulsar_registry"
BACKUP_BRANCH = "wip/pulsar"


def bootstrap_env() -> None:
    """
    Scaffolds a macOS Python environment: uv, direnv, and VS Code.
    Triggered by `git-pulsar --env`.
    """
    if sys.platform != "darwin":
        print("‚ùå The --env workflow is currently optimized for macOS.")
        return

    cwd = Path.cwd()
    print(f"‚ö° Setting up dev environment in {cwd.name}...")

    # 1. Dependency Check
    missing = []
    if not shutil.which("uv"):
        missing.append("uv")
    if not shutil.which("direnv"):
        missing.append("direnv")

    if missing:
        print(f"‚ùå Missing tools: {', '.join(missing)}")
        print("   Please run:")
        print(f"     brew install {' '.join(missing)}")
        sys.exit(1)

    # 2. Project Scaffold (uv)
    if not (cwd / "pyproject.toml").exists():
        print("üì¶ Initializing Python project...")
        # 'uv init' is safe; it creates a standard pyproject.toml
        subprocess.run(["uv", "init", "--no-workspace", "--python", "3.12"], check=True)
    else:
        print("   Existing pyproject.toml found. Skipping init.")

    # 3. Direnv Configuration
    envrc_path = cwd / ".envrc"
    if not envrc_path.exists():
        print("üîå Creating .envrc...")
        # We use a simplified config that handles the venv creation
        envrc_content = textwrap.dedent("""\
            # Auto-generated by git-pulsar
            if [ ! -d ".venv" ]; then
                echo "Creating virtual environment..."
                uv sync
            fi
            source .venv/bin/activate
            
            source_env_if_exists .envrc.local
        """)
        with open(envrc_path, "w") as f:
            f.write(envrc_content)

        subprocess.run(["direnv", "allow"], check=True)
    else:
        print("   .envrc exists. Skipping.")

    # 4. VS Code Settings (Optimized for Students)
    vscode_dir = cwd / ".vscode"
    settings_path = vscode_dir / "settings.json"

    if not settings_path.exists():
        vscode_dir.mkdir(exist_ok=True)
        print("‚öôÔ∏è  Configuring VS Code...")
        settings_content = textwrap.dedent("""\
            {
                "python.defaultInterpreterPath": ".venv/bin/python",
                "python.terminal.activateEnvironment": true,
                "files.exclude": {
                    "**/__pycache__": true,
                    "**/.ipynb_checkpoints": true,
                    "**/.DS_Store": true,
                    "**/.venv": true
                },
                "search.exclude": {
                    "**/.venv": true
                }
            }
        """)
        with open(settings_path, "w") as f:
            f.write(settings_content)

    print("\n‚úÖ Environment ready.")

    # 5. The "Manual" Hook
    # Check if direnv is likely hooked by checking for the env var it sets
    if "DIRENV_DIR" not in os.environ:
        print("\nüëâ Action Required: Enable direnv")
        print("   1. Open your config:")
        print("      code ~/.zshrc  (or nano ~/.zshrc)")
        print("   2. Add this line to the bottom:")
        print('      eval "$(direnv hook zsh)"')
        print("   3. Reload:")
        print("      source ~/.zshrc")


def setup_repo(registry_path: Path = REGISTRY_FILE) -> None:
    cwd = Path.cwd()
    print(f"üî≠ Git Pulsar: activating for {cwd.name}...")

    # 1. Ensure it's a git repo
    if not (cwd / ".git").exists():
        print(f"Initializing git in {cwd}...")
        subprocess.run(["git", "init"], check=True)

    # 2. Check/Create .gitignore
    gitignore = cwd / ".gitignore"
    defaults = [
        "__pycache__/",
        "*.ipynb_checkpoints",
        "*.pdf",
        "*.aux",
        "*.log",
        ".DS_Store",
    ]

    if not gitignore.exists():
        print("Creating basic .gitignore...")
        with open(gitignore, "w") as f:
            f.write("\n".join(defaults) + "\n")
    else:
        print("Existing .gitignore found. Skipping creation.")

    # 3. Create/Switch to the backup branch
    print(f"Switching to {BACKUP_BRANCH}...")
    try:
        subprocess.run(
            ["git", "checkout", BACKUP_BRANCH], check=True, stderr=subprocess.DEVNULL
        )
    except subprocess.CalledProcessError:
        try:
            # Create orphan if main doesn't exist, or branch off current
            subprocess.run(["git", "checkout", "-b", BACKUP_BRANCH], check=True)
        except subprocess.CalledProcessError as e:
            print(f"‚ùå Error switching branches: {e}")
            sys.exit(1)

    # 4. Add to Registry
    print("Registering path...")
    if not registry_path.exists():
        registry_path.touch()

    with open(registry_path, "r+") as f:
        content = f.read()
        if str(cwd) not in content:
            f.write(f"{cwd}\n")
            print(f"Registered: {cwd}")
        else:
            print("Already registered.")

    print("\n‚úÖ Pulsar Active.")

    try:
        # Check if we can verify credentials (only if remote exists)
        remotes = subprocess.check_output(["git", "remote"], cwd=cwd, text=True).strip()
        if remotes:
            print("Verifying git access...")
            subprocess.run(
                ["git", "push", "--dry-run"],
                cwd=cwd,
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
                check=True,
            )
    except subprocess.CalledProcessError:
        print(
            "‚ö†Ô∏è  WARNING: Git push failed. Ensure you have SSH keys set up or "
            "credentials cached."
        )
        print(
            "   Background backups will fail if authentication requires a password "
            "prompt."
        )

    print("1. Add remote: git remote add origin <url>")
    print("2. Work loop: code -> code (auto-commits happen)")
    print(f"3. Milestone: git checkout main -> git merge --squash {BACKUP_BRANCH}")


def main() -> None:
    if len(sys.argv) > 1:
        cmd = sys.argv[1]

        # Service management
        if cmd == "install-service":
            service.install()
            return
        elif cmd == "uninstall-service":
            service.uninstall()
            return

        # Environment Setup
        elif cmd in ["--env", "-e"]:
            bootstrap_env()
            # Fall through to setup_repo so the user gets both
            # environment setup AND git backup in one go.

    setup_repo()


if __name__ == "__main__":
    main()
