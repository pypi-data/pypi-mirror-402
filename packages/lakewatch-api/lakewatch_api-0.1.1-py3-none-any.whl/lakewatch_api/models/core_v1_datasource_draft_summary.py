# coding: utf-8

"""
    Antimatter Security Lakehouse Public API

    Interact with the Antimatter ASL API.

    The version of the OpenAPI document: 0.0.1
    Contact: support@antimatter.io
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from typing import Optional, Set
from typing_extensions import Self

class CoreV1DatasourceDraftSummary(BaseModel):
    """
    A summary of a datasource draft containing key metadata without the full datasource specification. 
    """ # noqa: E501
    name: StrictStr = Field(description="The name of the draft.")
    version: StrictInt = Field(description="The version of the draft, from its metadata.version.")
    datasource_version: Optional[StrictInt] = Field(default=None, description="The version of the associated DataSource, from its metadata.version, if it exists.", alias="datasourceVersion")
    changes_applied: Optional[StrictBool] = Field(default=None, description="True if the changes to the draft spec have been applied to a DataSource.", alias="changesApplied")
    ephemeral: Optional[StrictBool] = Field(default=None, description="True if this draft is ephemeral and cannot be applied to a DataSource.")
    created_timestamp: Optional[datetime] = Field(default=None, description="The timestamp when the draft was created.", alias="createdTimestamp")
    modified_timestamp: Optional[datetime] = Field(default=None, description="The timestamp when the draft was last modified.", alias="modifiedTimestamp")
    annotations: Optional[Dict[str, Optional[StrictStr]]] = Field(default=None, description="Annotations for the Datasource draft as key-value pairs")
    preset_name: Optional[StrictStr] = Field(default=None, description="The name of the preset used by this Datasource.", alias="presetName")
    preset_version: Optional[StrictInt] = Field(default=None, description="The version of the preset.", alias="presetVersion")
    source: Optional[StrictStr] = Field(default=None, description="The source (cloud provider, etc.) of the data.")
    source_type: Optional[StrictStr] = Field(default=None, description="The type of data (e.g. Route53, etc.). This can also be viewed as the service provided by the source.", alias="sourceType")
    __properties: ClassVar[List[str]] = ["name", "version", "datasourceVersion", "changesApplied", "ephemeral", "createdTimestamp", "modifiedTimestamp", "annotations", "presetName", "presetVersion", "source", "sourceType"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of CoreV1DatasourceDraftSummary from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # set to None if datasource_version (nullable) is None
        # and model_fields_set contains the field
        if self.datasource_version is None and "datasource_version" in self.model_fields_set:
            _dict['datasourceVersion'] = None

        # set to None if changes_applied (nullable) is None
        # and model_fields_set contains the field
        if self.changes_applied is None and "changes_applied" in self.model_fields_set:
            _dict['changesApplied'] = None

        # set to None if ephemeral (nullable) is None
        # and model_fields_set contains the field
        if self.ephemeral is None and "ephemeral" in self.model_fields_set:
            _dict['ephemeral'] = None

        # set to None if created_timestamp (nullable) is None
        # and model_fields_set contains the field
        if self.created_timestamp is None and "created_timestamp" in self.model_fields_set:
            _dict['createdTimestamp'] = None

        # set to None if modified_timestamp (nullable) is None
        # and model_fields_set contains the field
        if self.modified_timestamp is None and "modified_timestamp" in self.model_fields_set:
            _dict['modifiedTimestamp'] = None

        # set to None if annotations (nullable) is None
        # and model_fields_set contains the field
        if self.annotations is None and "annotations" in self.model_fields_set:
            _dict['annotations'] = None

        # set to None if preset_name (nullable) is None
        # and model_fields_set contains the field
        if self.preset_name is None and "preset_name" in self.model_fields_set:
            _dict['presetName'] = None

        # set to None if preset_version (nullable) is None
        # and model_fields_set contains the field
        if self.preset_version is None and "preset_version" in self.model_fields_set:
            _dict['presetVersion'] = None

        # set to None if source (nullable) is None
        # and model_fields_set contains the field
        if self.source is None and "source" in self.model_fields_set:
            _dict['source'] = None

        # set to None if source_type (nullable) is None
        # and model_fields_set contains the field
        if self.source_type is None and "source_type" in self.model_fields_set:
            _dict['sourceType'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of CoreV1DatasourceDraftSummary from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "name": obj.get("name"),
            "version": obj.get("version"),
            "datasourceVersion": obj.get("datasourceVersion"),
            "changesApplied": obj.get("changesApplied"),
            "ephemeral": obj.get("ephemeral"),
            "createdTimestamp": obj.get("createdTimestamp"),
            "modifiedTimestamp": obj.get("modifiedTimestamp"),
            "annotations": obj.get("annotations"),
            "presetName": obj.get("presetName"),
            "presetVersion": obj.get("presetVersion"),
            "source": obj.get("source"),
            "sourceType": obj.get("sourceType")
        })
        return _obj


