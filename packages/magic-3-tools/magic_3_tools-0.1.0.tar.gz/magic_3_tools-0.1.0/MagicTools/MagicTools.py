import copy
import os
import random
import re
import subprocess
from collections import OrderedDict

import numpy as np

from . import DF
from . import MTException as MTE
from .DFset import DFset
from .MolType import MolType
from .System import System

default_title = "Kind.Type.Name.DFsetName"
default_legend = "Kind.Type.Name.DFsetName"


def PlotAllDFs(listDFs, **kwargs):
    """OBSOLETE. Only kept for compatibility reasons.

    Plot distribution functions grouped by their order in a input list of DFsets.
    hardcopy - create eps-copy of the plot,
    coinciding - Plot only coinciding functions (by Atom Types, Mol)
    figsize, dpi - size and resolution of the resulting plot in inches and dpi
    linetype - define type of line using same syntax as matplotlib.pyplot

    """
    print("Warning! The PlotAllDFs function is obsolete and is replaced by MultPlot")
    print("Keywords linetype, oneatatime, nolegendintra - have no meaning")
    # kwargs_ = {'dpi':dpi, 'figsize':figsize, 'hardcopy':hardcopy, 'title':title}
    MultPlot(input=listDFs, **kwargs)


def OnePlot(
    DFs,
    figsize=(10, 7),
    dpi=80,
    hardcopy=False,
    outfile=None,
    title=None,
    title_template=default_title,
    legend_template=default_legend,
    _multiplot=False,
    legend_fontsize=14,
    legend_transparency=0,
    title_fontsize=18,
    x_lim=None,
    y_lim=None,
    xlabel=None,
    ylabel=None,
    xylabel_fontsize=12,
    baseline=False,
):
    """Plot all functions from the given list of DFs on a single plot.

    Args:
        DFs: DFset, list of functions (DF-class instances) or even a single DF.
        figsize ((int, int)): Size of the plot in inches, (x,y)
        dpi (int): Resolution of the plot
        hardcopy (bool): If true, do not show the plot, just save it to eps.
        outfile (str): Name of the file to save the plot
        title (str): The plot's title. if None, it will be autogenerated using provided title_template string.
        title_template (str): Template to generate the title. Default is 'Kind.Type.Name.DFsetName'
        legend_template (str): Template to generate legend for each function. Default is 'Kind.Type.Name.DFsetName'
        y_lim ((float, float)): Range for y-axis, (y_min, y_max), e.g. ``y_lim=(0.0, 10.0)``
        x_lim ((float, float)): Range for x-axis (x_min, x_max)
        legend_fontsize (int): Font size in legend
        title_fontsize (int): Font size in title
        legend_transparency (float): Transparency of the legend's background, in range [0:1], where 0 is transparent and 1 is opaque.
        _multiplot (bool): set to True, when need to make multiple plots
        xlabel (str): Label for X axis
        ylabel (str): Label for Y axis
        xylabel_fontsize (int): Font size of axis labels
        baseline (bool): If true, will also plot baseline to guide the eye: y=1.0 for RDF, and y=0.0 for potentials. Default False


    Example:
        ``OnePlot([DF1, DF2], figsize=(10,7), dpi=80, hardcopy=False)``

    """
    from sys import version_info

    import matplotlib.pyplot as plt

    def _template2dict(template_str, df):
        assert isinstance(template_str, str)
        template_list = template_str.split(".")
        odict = OrderedDict()
        for template_ in template_list:
            assert isinstance(template_, str)
            try:  # try access as if it is a field
                odict[template_] = str(getattr(df, template_))
            except AttributeError:  # just string
                odict[template_] = template_
        return odict

    if DFs == []:
        return
    if isinstance(DFs, DFset):
        DFs = DFs.DFs
    if not isinstance(DFs, list):  # Single object provided
        assert isinstance(DFs, DF.DF), "Expecting to receive DF-class instance"
        DFs = [DFs]
    assert len(DFs) > 0, (
        "Error in the input function-list: Expecting to have at least one function"
    )
    for df in DFs:
        assert isinstance(df, DF.DF), "Expecting to receive DF-class instances"

    if title:
        title_dict = _template2dict(title, title)
    else:
        title_dict = _template2dict(title_template, DFs[0])

    fig = plt.figure(figsize=figsize, dpi=dpi)
    if version_info[0] < 3:  # if python 2
        plt.hold(False)

    for df in DFs:
        if "legend" in df.plot_kwargs.keys():  # if user defined legend
            df.plot_legend_dict = {"label": df.plot_kwargs["legend"]}
        else:  # make one from template-string
            df.plot_legend_dict = _template2dict(legend_template, df)

    # filtering legends:
    if len(DFs) > 1:
        # Filtering based on title-template
        for title_key_, title_val_ in title_dict.items():
            if all([title_key_ in df.plot_legend_dict for df in DFs]):
                if all([df.plot_legend_dict[title_key_] == title_val_ for df in DFs]):
                    for df in DFs:
                        del df.plot_legend_dict[title_key_]
        # Filtering based on title-content and legend templates.
        all_legend_items = set(
            [item for df in DFs for item in df.plot_legend_dict.items()],
        )
        for item in all_legend_items:
            if (
                all([item in df.plot_legend_dict.items() for df in DFs])
                and item[1] in title_dict.values()
            ):
                for df in DFs:
                    del df.plot_legend_dict[item[0]]

    for df in DFs:
        df.plot_kwargs["label"] = ".".join(df.plot_legend_dict.values())
        del df.plot_legend_dict
        if df.plot_kwargs["label"] == "":
            del df.plot_kwargs["label"]

    for df in DFs:
        plot_filtered_kwargs = {
            key: value
            for key, value in df.plot_kwargs.items()
            if key not in ("xlabel", "ylabel", "linetype", "xlim", "ylim", "legend")
        }

        plt.plot(*df.plot_args, **plot_filtered_kwargs)
        if version_info[0] < 3:  # if python 2
            plt.hold(True)

    if not title:
        title = ".".join(title_dict.values())

    plt.title(title, fontsize=title_fontsize)
    fig.canvas.manager.set_window_title(title)
    plt.xlabel(
        xlabel if xlabel else DFs[0].plot_kwargs["xlabel"],
        fontsize=xylabel_fontsize,
    )
    plt.ylabel(
        ylabel if ylabel else DFs[0].plot_kwargs["ylabel"],
        fontsize=xylabel_fontsize,
    )
    if x_lim:
        assert isinstance(x_lim, tuple)
        assert len(x_lim) == 2
        plt.xlim(x_lim)
    if y_lim:
        assert isinstance(y_lim, tuple)
        assert len(y_lim) == 2
        plt.ylim(y_lim)

    leg = plt.legend(loc=0, fancybox=True, fontsize=legend_fontsize, frameon=1)
    if leg is not None:
        leg.get_frame().set_alpha(legend_transparency)

    if baseline:
        plt.hlines(
            1.0 if isinstance(DFs[0], DF.RDF) else 0.0,
            *plt.xlim(),
            colors="black",
            linestyles="--",
        )
    outfile_ = outfile if outfile is not None else title
    if hardcopy:
        outfile_ = f"{outfile_}.eps"
        if os.path.isfile(outfile_):  # if file exists
            print(
                f"Warning! The file {outfile_} already exists and will be overwritten",
            )
        plt.savefig(outfile_)
        plt.close()
    if not _multiplot:
        plt.show()


def MultPlot(
    input,
    coinciding=True,
    atonce=False,
    show_sameasbond=False,
    *args,
    **kwargs,
):
    """Plots distribution functions from the list of DFset grouped by the type of interacting beads or bond number.

    Also can be used as universal plotting interface for DF, list(DF), DFset or list(DFset).

    Args:
        input: DF-objects (and sets of such) to be plotted
        coinciding: if true - only plot similar that are present in all DFsets of the list, otherwise plot depending on existence of the function
        atonce: Plot all DFs from the list on a single figure
        show_sameasbond: Plot bond-related functions which are linked to other functions, by default - false: just plot the original function
        *args: Arguments for OnePlot
        **kwargs: Arguments for OnePlot

            - figsize=(10, 7)
            - dpi=80
            - hardcopy=False
            - outfile=None
            - title=None
            - multiplot=False
            - title_template
            - legend_fontsize=14
            - legend_transparency=0,
            - title_fontsize=18
            - x_lim=None, y_lim=None,
            - xlabel=None, ylabel=None
            - xylabel_fontsize=12

    Example::

        MultPlot(
            [RDFset1, RDFset2],
            coinciding=True,
            atonce=False,
            show_sameasbond=False,
            title_template="Kind.Type.Name",
            title_fontsize=18,
            legend_template="Kind.Type.Name.DFsetName",
            legend_fontsize=14,
            xlabel="R",
            ylabel="RDF",
            xylabel_fontsize=12,
        )

    """
    import matplotlib.pyplot as plt

    try:
        plt.rcParams["figure.max_open_warning"] = (
            100  # Suppress warning of too many plots.
        )
    except:
        pass

    if isinstance(input, DF.DF):  # Single DF is given
        # noinspection PyTypeChecker
        OnePlot(input, _multiplot=False, *args, **kwargs)

    elif isinstance(input, DFset):  # Single DFset -> convert to list and plot
        MultPlot(
            input.DFs,
            coinciding=coinciding,
            atonce=atonce,
            show_sameasbond=show_sameasbond,
            *args,
            **kwargs,
        )

    elif isinstance(input, list):  # list of something -> check what is inside
        if all([isinstance(DFs, DF.DF) for DFs in input]):  # everything is a DF -> Plot
            input = [
                df_ for df_ in input if show_sameasbond or df_.SameAsBond is None
            ]  # filter linked bonds
            if atonce:  # plot all at once
                OnePlot(input, _multiplot=False, *args, **kwargs)
            else:  # plot one function at a plot
                for df in input:
                    OnePlot(df, _multiplot=True, *args, **kwargs)
                plt.show()
        elif all(
            [isinstance(df_, DF.DF) for df_list in input for df_ in df_list],
        ):  # everything is a list of DFs (implies DFset):
            if (
                all([isinstance(df_set, DFset) for df_set in input]) and coinciding
            ):  # everything is a DFset and we need to reduce the set
                template = input[0]
                for t in input:
                    template = template.Reduce(t)

                input_reduced = [df_set.Reduce(template) for df_set in input]
                MultPlot(
                    input_reduced,
                    coinciding=False,
                    atonce=atonce,
                    show_sameasbond=show_sameasbond,
                    *args,
                    **kwargs,
                )  # Plot the reduced input

            else:  # no need to reduce
                input.sort(
                    key=len,
                    reverse=True,
                )  # reorder list of DFset by length of each set
                if len(input[0]) != len(input[-1]):
                    print("Warning: the sets are of different length!")
                for df_first in input[
                    0
                ]:  # loop over all functions in the longest DFset
                    list_dfs_to_plot = [
                        df
                        for df_set in input
                        for df in df_set
                        if df.IsSimilar(df_first)
                    ]
                    list_dfs_to_plot = [
                        df_
                        for df_ in list_dfs_to_plot
                        if show_sameasbond or df_.SameAsBond is None
                    ]  # filter linked bonds
                    OnePlot(list_dfs_to_plot, _multiplot=True, *args, **kwargs)
                plt.show()
            # print("Do not know what to do with this kind of input")
    else:
        print("Do not know what to do with this kind of input")


def AnalyzeIMCOuput(
    filename,
    DFType="RDF",
    iters=None,
    test=False,
    mcmfile=None,
    PairNamesList=None,
    **kwargs,
):
    """Analyzes output file produced by MagiC and plot resulting functions of interest:

    Args:
        filename (str): File to read
        DFType ({'RDF', 'Pot', 'PotNew', 'PotCorr'}): Which function to read:

            - 'RDF': sampled RDFs,
            - 'RDFref': reference RDF,
            - 'Pot': potential used at the iteration,
            - 'PotNew': potential generated after each iteration,
            - 'PotCorr': potential correction applied after the iteration
        iters: Which iteration(s) to read. If nothing mentioned all iterations will be extracted.
            Example: ``iters=(1,2,3) or iters=(1)``
        test (bool): If True, read results of the intermediate convergence tests
        hardcopy: Do not show plots, save them to files instead.
        **kwargs: Arguments for MultPlot/OnePlot

    Example:
        ``AnalyzeIMCOutput('magic.out', DFType='Pot', iters=(1,2,3), test=False)``

    """
    DFs = ReadMagiC(
        filename,
        DFType=DFType,
        iters=iters,
        mcmfile=mcmfile,
        PairNamesList=PairNamesList,
        test=test,
    )
    if not isinstance(DFs, type([])):
        DFs = [DFs]
    if DFType.upper() == "RDF":
        DFsRef = ReadMagiC(
            filename,
            DFType="RDFRef",
            iters=iters,
            mcmfile=mcmfile,
            PairNamesList=PairNamesList,
            test=test,
        )
        if isinstance(DFsRef, list):
            DFsRef = DFsRef[0]
        DFs = DFs + [DFsRef]
    MultPlot(DFs, coinciding=True, atonce=False, **kwargs)


def HeatMap(refDFset, otherDFsets, hardcopy=False, outfile=None, force=False, **kwargs):
    """Visualize IMC convergence by drawing an interaction-specific RDF deviation HeatMap.

    Each line represents an interactions and columns represent the iterations.
    Reported numbers are distances between the reference RDF and corresponding sampled RDF for the particular interaction.

    Args:
        refDFset: Reference RDFs
        otherDFsets: list of RDFs sampled at different IMC iterations
        hardcopy: If to save the plot to png-file
        outfile: File to save the plot
        force: Produce the heatmap even if elements of otherDFset do not match refDFset
        **kwargs: Keyword arguments to pass to Seaborn.heatmap()

    Examples:
        rdfs = MT.ReadMagiC('01.magic.out', quiet=True) # Read the list of sampled DFsets
        rdf_ref = MT.ReadRDF('1DNA-K.full.rdf', quiet=True) # Read the reference DFset
        MT.HeatMap(rdf_ref, rdfs, annot=True, hardcopy=True, outfile="1DNA-K.full.rdf.eps")

    """
    import matplotlib

    if hardcopy:
        matplotlib.use("Agg")
    import matplotlib.pyplot as plt
    import pandas as pd
    import seaborn as sns

    if not force:
        assert all([otherDFset_.IsSimilar(refDFset) for otherDFset_ in otherDFsets]), (
            "All DFsets must be similar to the reference one"
        )

    dist_iterator = (
        refDF_.Distance(otherDF_, force=force)
        for otherDFset_ in otherDFsets
        for refDF_, otherDF_ in zip(refDFset, otherDFset_)
    )

    dist_array = np.fromiter(dist_iterator, dtype=float)
    dist_array = dist_array.reshape((len(otherDFsets), len(refDFset))).T

    dist_df = pd.DataFrame(
        dist_array,
        index=[refDF_.Name for refDF_ in refDFset],
        columns=[otherDFset_.Name for otherDFset_ in otherDFsets],
    )
    ax1 = sns.heatmap(
        dist_df,
        norm=matplotlib.colors.LogNorm(vmin=dist_array.min(), vmax=dist_array.max()),
        **kwargs,
    )
    ax1.set_xticklabels(ax1.get_xticklabels(), rotation=45, ha="right")
    ax1.set_yticklabels(ax1.get_yticklabels(), rotation="horizontal")
    plt.subplots_adjust(bottom=0.25)
    if hardcopy:
        plt.savefig(outfile if outfile is not None else refDFset.Name + ".png")
        plt.close("all")
    sns.reset_orig()
    return dist_df


def DumpDFs(DFs, filename):
    raise DeprecationWarning("Method DumpDFs is obsolete and no longer supported.")


def LoadDFs(filename):
    raise DeprecationWarning("Method LoadDFs is obsolete and no longer supported.")


def SaveDFsAsText(DFs):
    """Save function[s] from the given object, which may be single DF, DFset or list of DFs into a separate text-file.

    Usefull when plotting the fuctions with external software

    Args:
        DFs:  single DF, DFset or list of DF-objects

    """
    if isinstance(DFs, DFset) or isinstance(DFs, type([])):
        for i in DFs:
            SaveDFsAsText(i)
    else:
        DFs.Save()


def __LoadCharges(pots, mcmfile, **kwargs):
    for pot in pots:  # loop over all potentials
        if pot.Type == "NB" and pot.qq is None:
            print(f"\n{pot.Name}")
            print("The charges of AtomTypes involved in the potential are unknown.")
            if not mcmfile:
                print(
                    "Please specify according mcm files in mcmfile-parameter to read the charges",
                )
                return
            print("Reading charges from mcm-files")
            pot.GetCharges(mcmfile=mcmfile, **kwargs)
    return


def GetOptEpsilon(
    pots,
    eps_old,
    r1,
    eps_min=0,
    eps_max=0,
    npoints=100,
    mcmfile=None,
    **kwargs,
):
    """Calculate optimal value of dielectric permittivity, providing fastest decay of short-range intermolecular potentials.

    For more details check the User Guide

    Args:
        pots (DFset): The set of short-range potentials
        eps_old (float): original value of dielectric permittivity
        r1 (float): distance at which the tail starts
        eps_min (float): range of values for eps search, by default eps_min=0, eps_max=2*eps_old
        eps_max (float): range of values for eps search, by default eps_min=0, eps_max=2*eps_old
        npoints (int): how many points in the eps_mesh to have
        mcmfile ([str]): molecular topology files, required to read charges of atomic types, e.g. ``['Na.mcm', 'Cl.mcm']``

    Returns:
        Optimal dielectric permittivity value

    Example:
        ``eps_opt = MT.GetOptEpsilon(pots, eps_old=70.0, r1=15, eps_min=50, eps_max=100, mcmfile='dmpc_NM.CG.mcm')``

    """
    # Generate mesh of epsilon values:
    weight = 1e25
    eps_opt = 0
    if (eps_min == 0) and (eps_max == 0):
        eps_max = eps_old * 2
    eps = np.linspace(eps_min, eps_max, npoints)

    # Preload charges
    __LoadCharges(pots, mcmfile, **kwargs)

    for e in [e for e in eps if e != 0.0]:  # every particular value of the eps-mesh
        w = 0.0
        for pot in pots:  # loop over all potentials
            if pot.Type == "NB":
                if pot.qq is None:
                    if mcmfile is None:
                        print(
                            "The charges of AtomTypes involved in the potential are unknown.",
                        )
                        print(
                            "Please specify according mcm files in mcmfile-parameter to read the charges",
                        )
                        return None
                    print("Reading charges")
                    pot.GetCharges(mcmfile=mcmfile, **kwargs)
                w += pot.GetWeight(e, float(eps_old), r1)
        if w < weight:
            weight = w
            eps_opt = e
    return eps_opt


def PotsEpsCorrection(pots, eps_old, eps_new, mcmfile=None, **kwargs):
    """Create new set of short-range potentials with chaged value of dielectric permittivity for all intermolecular potentials in the given DFset "pots". Intramolecular potentials are kept untouched.

    Args:
        pots (DFset): Set of effective potentials without electrostatic contributions, as provided by MagiC.Core
        eps_old (float): Original value of the dielectric permittivity
        eps_new (float): New value of the dielectric permittivity
        mcmfile ([str]): molecular topology files, required to read charges of atomic types, e.g. ``['Na.mcm', 'Cl.mcm']``
        **kwargs:

    Returns:
        DFset - Set of short-range potentials corresponding to the new value of dielectric permittivity.

    Examples:
        MT.PotsEpsCorrection(pot_DNA_short, eps_old=70, eps_new=1.0, mcmfile="DNA.CG.mcm", quiet=True)

    """
    # Preload charge
    __LoadCharges(pots, mcmfile, **kwargs)
    newpots = copy.deepcopy(pots)
    for pot in newpots.DFs_NB:
        U_sr_new = pot.y + (
            (pot.qq * 1.602e-19 * 1.602e-19 * 6.022e23)
            / (4.0 * 3.1416 * 8.85e-12 * 1.0e-10 * 1.0e3)
        ) * (1.0 / eps_old - 1.0 / eps_new) * (1.0 / pot.x)
        pot.y = U_sr_new
        pot.Name = f"{pot.Name} eps_old:{eps_old:5.3f} eps_new: {eps_new:5.3f}"
    return newpots


def TotalPots(pots, eps, mcmfile, **kwargs):
    """Creates a set of total potentials by adding electrostatic contribution to short-range intermolecular potentials.

    Args:
        pots (DFset): original set of the short-range potentials
        eps (float): relative dielectric permittivity
        mcmfile ([str]): molecular topology files, required to read charges of atomic types, e.g. ``['Na.mcm', 'Cl.mcm']``

    Returns:
        DFset - Set of total potentials, including short-range and electrostatics part

    Examples:
        pot_DNA_short = MT.ReadPot('DNA.short.sample.pot', Ucut=100000)
        pot_DNA_total = MT.TotalPots(pot_DNA_short, 70.0, mcmfile=['DNA.CG.mcm'] )

    """
    if isinstance(pots[0], list):
        TotalPots(pots[0], eps, mcmfile, **kwargs)
    else:
        newpots = copy.deepcopy(pots)
        __LoadCharges(newpots, mcmfile, **kwargs)
        for pot in newpots:
            if pot.Type == "NB":
                U_sr_new = pot.y + (
                    (pot.qq * 1.602e-19 * 1.602e-19 * 6.022e23)
                    / (4.0 * 3.1416 * 8.85e-12 * 1.0e-10 * 1.0e3)
                ) * (1.0 / eps) * (1.0 / pot.x)
                pot.y = U_sr_new
                pot.Name = f"{pot.Name} Total with eps: {eps:5.3f}"
        return newpots


def PotsExtendTailRange(pots, RcutNB):
    """Extend the range of NB potentials in the DFset up to RcutNB (Inplace, i.e. no new set is returned).

    Args:
        pots (DFset): set of potentials
        RcutNB (float): The range to extend the potentials.

    Examples::
        pot_short = MT.ReadPot("DNA.short.sample.pot", Ucut=100000)
        MT.PotsExtendTailRange(pot_short, RcutNB=10)

    """
    if not isinstance(pots, DFset):
        print("Error: The provided object is not a set of potentials.")
    pots.ExtendTail(RcutNB)


def PotsPressCorr(pots, Ucorr0):
    r"""Create a new set of short-range potentials by adding a decaying linear term to each intermolecular
    potential in the set. Such correction suppose to improve reproduction of a correct pressure in the
    large scale CG simulation. Intramolecular potentials are kept untouched.

    Correction term is linear, having value of Ucorr0 at r=0, and vanishing to zero at r=rmax:

    .. math:: U_{corrected}(r) = U_{original}(r) - U_{corr 0} \cdot \frac{r}{r_{max}}

    Args:
        pots (DFset):  Original set of the potentials
        Ucorr0 (float): Intercept of the linear correction at r=0

    Returns:
        New DFset with updated NB-potentials

    Examples:
        pot = MT.ReadPot('DMPC.sample.pot', Ucut=1e5)
        pot_new = MT.PotsPressCorr(pot, Ucorr0=100)

    """
    newpots = copy.deepcopy(pots)
    print(f"Performing linear correction of the potentials: Ucorr(0)={Ucorr0}")
    for pot in newpots:
        pot.PotPressCorr(Ucorr0)
    return newpots


def PotsExport(
    pots,
    MDEngine,
    Rmaxtable=25.0,
    PHImaxtable=180.0,
    filename="",
    **kwargs,
):
    """Export the given set of potentials  (pots) to one of the availableMD packages formats:

    Parameters
    ----------
        pots (DFset) : Set of potentials to export
        MDEngine ({"GROMACS", "LAMMPS", "GALAMOST"}): Name of the MD package to export to: 'LAMMPS', 'GROMACS', 'GALAMOST'
        npoints (int): Number of points in the table
        Umax (float): Max value of energy (kJ/mol) at the repulsive wall region
        Rmaxtable (float): Maximum range of the table in A (for both non-bonded and pair-bonds). Deafault 25.0
        PHImaxtable (float): Maximum angle value (deg) in the table for angle-bendind bonds. Deafult 180.0
        filename (str): Prefix for the potential files name. Default empty sting.
        interpol (bool): Perform interpolation (True), or keep original resolution of the table (False). Default True.
        method ('gauss'|'sciint'): Which interpolation method to use ``gauss`` (default) or ``sciint``, which gives smoother forces,
            but may produce artifacts near Rcut, so use with care)
        zeroforce (bool): Do not write forces into GROMACS .xvg-file, but write zeros instead. In such case GROMACS
            should automatically calculate forces from potentials. Default: False
            NB: Even if zeroforce=True, actual force values are plotted.
        noplot (bool): Avoid suplementary plots. Default False
        hardcopy (bool):  Save supplementary plot to eps-files. Default False.
        figsize (int, int): Size of the supplementary plots
        dpi (int): Resolution of the supplementary plots

    Example::

        PotsExport(pot, MDEngine='GROMACS', Rmaxtable=25.0, PHImaxtable=180.0, npoints=2500, Umax=6000.0,
        interpol=True, method='gauss', sigma=0.5, noplot=False, hardcopy=True, figsize=(14,7.5), dpi=120
        filename='')

    """
    import matplotlib.pyplot as plt

    def_kwargs = {
        "Umax": 6000.0,
        "ofilename": filename,
        "method": "gauss",
        "zeroforce": False,
        "interpol": True,
    }
    def_kwargs.update(kwargs)
    kwargs = def_kwargs

    MDEngine = MDEngine.upper()
    if filename != "":
        filename += "."
    kwargs["ofilename"] = filename
    for pot in pots:
        Rmax = PHImaxtable if isinstance(pot, DF.Pot_AngleBond) else Rmaxtable
        if MDEngine == "GROMACS":
            kwargs["zeroforce"] = True
            pot.Export2Gromacs(Rmaxtable=Rmax, **kwargs)
        elif MDEngine == "GALAMOST":
            pot.Export2GALAMOST(Rmaxtable=Rmax, **kwargs)
        elif MDEngine == "LAMMPS":
            pot.Export2LAMMPS(Rmaxtable=Rmax, **kwargs)
        else:
            raise ValueError(
                "Wrong value of MDEngine provided: Shall be one of 'LAMMPS', 'GROMACS', 'GALAMOST'",
            )

    plt.show()

    if MDEngine == "GROMACS":
        print(
            "\nYou can use the following lines as a template to specify non-bonded interactions to your mdp-file",
        )
        print("\nBut DO NOT FORGET TO ADJUST THEM MANUALLY !!!")
        print(
            "\nenergygrps =" + " ".join(str(atom_type) for atom_type in pots.AtomTypes),
        )
        print(
            "energygrp_table ="
            + " ".join(
                [
                    f"{pot.AtomTypes[0]} {pot.AtomTypes[1]}"
                    for pot in pots
                    if pot.Type == "NB"
                ],
            ),
        )
    else:
        pass


# The functions below are kept for compatibility. It is recommended to use PotsExport instead


def PotsExport2Gromacs(pots, Rmaxtable=2.5, **kwargs):
    PotsExport(pots, MDEngine="GROMACS", Rmaxtable=Rmaxtable * 10.0, **kwargs)


def PotsExport2GALAMOST(pots, Rmaxtable=2.5, **kwargs):
    PotsExport(pots, MDEngine="GALAMOST", Rmaxtable=Rmaxtable * 10.0, **kwargs)


def PotsExport2LAMMPS(pots, **kwargs):
    PotsExport(pots, MDEngine="LAMMPS", **kwargs)


def _upd_docstring_potsexport_(str_, MDEngine, Rmaxtable_):
    str_ = str_.replace("one of the availableMD packages formats", MDEngine)
    str_ = str_.replace(
        "MDEngine - name of the package to export to: 'LAMMPS', 'GROMACS', 'GALAMOST'\n",
        "",
    )
    str_ = str_.replace(
        "Example: PotsExport(pot, MDEngine='GROMACS', Rmaxtable=25.0",
        f"Example: PotsExport2{MDEngine}(pot, Rmaxtable={Rmaxtable_}",
    )
    return str_


PotsExport2Gromacs.__doc__ = _upd_docstring_potsexport_(
    PotsExport.__doc__,
    "GROMACS",
    2.5,
)
PotsExport2GALAMOST.__doc__ = _upd_docstring_potsexport_(
    PotsExport.__doc__,
    "GALAMOST",
    2.5,
)
PotsExport2LAMMPS.__doc__ = _upd_docstring_potsexport_(
    PotsExport.__doc__,
    "LAMMPS",
    25.0,
)


def GromacsTopology(
    inpMagiC=None,
    system=None,
    topfile="topol.top",
    geometry=None,
    **kwargs,
):
    """Creates GROMACS's topology file for the system.

    The system can be directly provided as a parameter, read from magic.inp file, or initiated from
    list of molecular types and number of corresponding molecules. For two latter cases *.mcm-files shall be present
    in the same directory.

    Args:
           inpMagiC (str): Input file for MagiC.Core, used to define system's composition, i.e. list of molecular
           types and number of molecules of each type
           system (system): the system topology to export
           geometry (str): File with the starting geometry of the system in xmol format.
               If provided a corresponding .gro-file will be generated
           topfile (str): File to write the topology. Default 'topol.top'
           dfset (DFset): Set of potentials/RDFs having SameAsBond-records.
               If provided, the topology will take into account SameAsBond records from the DFset
           mcmfile ([str, str]): List of mcm-files defining molecular types. Default None, autodetected from inpMagic
           NMolMType ([int, int]):  List of number of molecules of each type. Default None, autodetected from inpMagic

    Example:
           ``MT.GromacsTopology('magic.inp', geometry='start.xmol')``
           ``MT.GromacsTopology(system=system, geometry='start.xmol')``
           ``MT.GromacsTopology(system=system, mcmfile=['DMPC.CG', 'Chol.CG'],  NMolMType=[30, 30]))``

    """
    if system is None:
        system = System(input=inpMagiC, geometry=geometry, **kwargs)
    system.WriteGromacsTopology(topfile=topfile)
    if geometry is not None:
        system.WriteGeometryGRO(
            geometry.replace(".xmol", ".gro"),
            AtomTypesInsteadOfAtoms=True,
        )
        print("Created starting geometry:" + geometry.replace(".xmol", ".gro"))


def LAMMPSTopology(
    inpMagiC=None,
    system=None,
    outfile="LAMMPS.data",
    hybrid=False,
    **kwargs,
):
    """Creates LAMMPS's topology file for the system.

    The system can be directly provided as a parameter, read from magic.inp file, or initiated from
     list of molecular types and number of corresponding molecules. For two latter cases *.mcm-files shall be present
     in the same directory.

    Args:
        inpMagiC (str): Input file for MagiC.Core, needed to define system's composition, i.e. list of molecular types and number of molecules of each type
        system (system): the system topology to export
        geometry (str): Starting geometry of the system in xmol.format
        outfile (str): file to write LAMMPS topology. Default: LAMMPS.data
        mcmfile ([str, str]): List of mcm-files defining molecular types. Default None, autodetected from inpMagic
        NMolMType ([int, int]):  List of number of molecules of each type. Default None, autodetected from inpMagic
        hybrid (bool): Add explicit bond-types to the topology file. Needed if few bond types are used, e.g. *table* and *zero*.
        dfset (DFset): Set of potentials/RDFs having SameAsBond-records. If provided, the topology will take into account SameAsBond records from the DFset

    Examples::

        MT.LAMMPSTopology("01.magic.inp", geometry="start.xmol")
        MT.LAMMPSTopology(
            geometry="start.xmol", outfile="LAMMPS.data", mcmfile=["DMPC.CG", "Chol.CG"], NMolMType=[30, 30]
        )

    """
    if system is None:
        system = System(input=inpMagiC, **kwargs)
    system.WriteLAMMPSData(outfile, hybrid=hybrid)
    return system


def GALAMOSTTopology(
    eps,
    inpMagiC=None,
    system=None,
    outfile="topology.xml",
    pyfile="tables.inc.py",
    **kwargs,
):
    """Creates GALAMOST topology files (.xml, and .py) for the system.

    The system can be directly provided as a parameter, read from magic.inp file, or initiated from
    list of molecular types and number of corresponding molecules. For two latter cases *.mcm-files shall be present
    in the same directory.

    The resulting topology is made of two files: XML-file, with system's geometry, atom types, atoms, bonds, angles.
    This file has same format as HOOMD-blue topology, so it can be directly opened by VMD.
    The second file is a python-script, which is assigning tabulated potential files to every particular interactions in the system.
    These files are shall be independently created using PotsExport (PotsExport2GALAMOST).

    Args:
        eps (float): Dielectric permittivity, required for charge conversion into GALAMOST internal units
        inpMagiC (str): Input file for MagiC.Core, needed to define system's composition, i.e. list of molecular types
            and number of molecules of each type
        system (system): the system topology to export
        geometry (str): Starting geometry of the system in xmol.format
        outfile (str): file to write the topology. Default: topology.xml
        mcmfile ([str, str]): List of mcm-files defining molecular types. Default None, autodetected from inpMagic
        NMolMType ([int, int]):  List of number of molecules of each type. Default None, autodetected from inpMagic
        dfset (DFset): Set of potentials/RDFs having SameAsBond-records. If provided, the topology will take into account SameAsBond records from the DFset
        pyfile (str): File for writing python records for tabulated potentials. Default 'tables.inc.py'

    Example:
        ``MT.GALAMOSTTopology(inpMagiC='01.magic.inp', geometry='start.xmol', eps=78.0)``

    """
    if system is None:
        system = System(input=inpMagiC, **kwargs)
    system.SetExclusions(inpMagiC=inpMagiC)
    system.WriteGALAMOSTxml(eps, outfile=outfile, pyfile=pyfile)
    system.WriteGALAMOSTExclusions()
    return system


def Deviation(
    filename,
    hardcopy=False,
    returnarrays=False,
    testpoints=False,
    outfile="deviation.eps",
):
    """Analyzes output file (or set of files) produced by MagiC and plots deviation between set of reference
    distribution functions and resulting distribution function obtained on every iteration of inverse procedure.

    Args:
        filename (str | [str, str]): Name (or list of names) of the magic output file(s)
        hardcopy (bool): Save the plot to an eps file. Default False
        returnarrays (bool): If the procedure shall return pandas dataframe with iteration number and deviation values. Default False
        testpoints (bool): If the points sampled in intermediate convergence tests shall be also plotted.
        outfile (str): File to save the plot, if hardcopy=True

    Example:
        ``Deviation(['01.magic.out', '02.magic.out'], testpoints=True)``

    """
    import matplotlib.pyplot as plt
    import pandas as pd

    def __parse_magic_out_files(filenames):
        Sdev = []
        RDFdev = []
        labels = []
        types = []
        testmarks = ["test", "Interm"]
        pattern = re.compile("Deviation")
        files = []

        for filename in filenames:
            with open(filename) as ifile:
                lines = ifile.readlines()
            iter_cnt = 0
            deviation_lines = [l.strip() for l in lines if pattern.search(l)]
            for line in deviation_lines:
                RDFdev.append(float(line.split("RDF:")[1]))
                Sdev.append(float(line.split("S:")[1].split("RDF:")[0]))
                files.append(filename)
                if any([testmark in line for testmark in testmarks]):
                    types.append("test")
                    labels.append("")
                else:
                    types.append("final")
                    iter_cnt += 1
                    labels.append(filename + ".iter" + str(iter_cnt))
        return pd.DataFrame(
            {
                "Sdev": np.array(Sdev),
                "RDFdev": np.array(RDFdev),
                "type": types,
                "label": labels,
                "file": files,
            },
        )

    if isinstance(filename, str):
        filename = [filename]

    df = __parse_magic_out_files(filename)

    if not testpoints:
        df = df[df.type == "final"]
        df = df.set_index(np.arange(1, len(df) + 1, 1))

    print(df[["Sdev", "RDFdev", "type", "label"]])
    # plot the results
    fig = plt.figure()
    ax1 = fig.add_subplot(211)
    plt.title("Deviation between sampled and reference RDFs")
    plt.setp(ax1.get_xticklabels(), visible=False)
    ax2 = fig.add_subplot(212, sharex=ax1)
    df["point_size"] = df["type"].map(
        {"test": 16, "final": 40},
    )  # set larger points for final values and smaller for intermediate test-values
    df["file"] = df["file"].astype("category")
    ax1.scatter(
        df.index,
        df.Sdev,
        s=df.point_size,
        c=df.file.cat.codes,
        cmap=plt.cm.Set3,
        label=r"$\sum_{r_j}[S_{ref}(r_j)-S_{(i)}(r_j)]^2$",
    )
    ax2.scatter(
        df.index,
        df.RDFdev,
        s=df.point_size,
        c=df.file.cat.codes,
        cmap=plt.cm.Set3,
        label=r"$\sum_{r_j}{[g_{ref}(r_j)-g_{(i)}(r_j)]^2}$",
    )

    ax2.set_xticks(df[df["type"] == "final"].index.values)
    ax2.set_xticklabels(df[df["type"] == "final"].label, rotation=90)
    ax1.set_ylabel(r"$\sum_{r_j}[S_{ref}(r_j)-S_{(i)}(r_j)]^2$")
    ax2.set_ylabel(r"$\sum_{r_j}{[g_{ref}(r_j)-g_{(i)}(r_j)]^2}$")
    ax2.set_ylim(bottom=0.0)
    ax1.set_ylim(bottom=0.0)
    if hardcopy:
        plt.savefig(outfile)
        plt.close()
    else:
        plt.show()
    if returnarrays:
        return df


def SplitDFset(ifile, ofile, Split=True):
    """Split the set of RDFs or potentials given in the file into a main header file and an additional set of included file.

    Args:
        ifile (str): File to read the DFset
        ofile (str): File to write the DFset
        Split ([bool]): Specify a logical list, specifying which DFs within the file shall be moved to the included files, while other will remain in the main file

    """
    raise DeprecationWarning(
        "Method SplitDFset is obsolete. Use method Write of class DFset instead",
    )


def ReadMagiC(
    ifile,
    iters=None,
    DFType="RDF",
    test=False,
    mcmfile=None,
    PairNamesList=None,
    quiet=False,
):
    """Reads sets of desired functions from MagiC.Core output.

    Main function for reading data from MagiC.Core log-files. It reads sets of functions specifyed by ``DFType`` from all files
    listed in ``ifile``  and returns a list of DFset.

    Args:
        ifile (str | [str, str]): The file or list of files to read.
        DFType ({'RDF', 'Pot', 'PotNew', 'PotCorr'}): Which function to read:

            - 'RDF': sampled RDFs,
            - 'RDFref': reference RDF,
            - 'Pot': potential used at the iteration,
            - 'PotNew': potential generated after the iteration,
            - 'PotCorr': potential correction applied after the iteration

        iters ((int, ...)): Which iterations to read.  Default None, read all iterations. Ex: ``iters=(1,2,3,4)``
        test (bool): If True, read results of the intermediate convergence tests
        quiet (bool): Suppress output, Default False

        These paramters are rarely used
        mcmfile: (optional, autodetected) List of molecular-topology files to read AtomTypes and bond definitions.
        PairNamesList: (optional, autodetected) List of pairs of atomic names to search in output file.
        It consists of three sublists: non-bonded pair interactions, bonded pair interactions, bending angle (1-3) bond interactions.

    Returns:
        List of DFset objects: [DFset1, DFset2, ...]

    Example:
        ``ReadMagiC(['01.magic.out', '02.magic.out', '03.magic.out'], DFType='RDF', quiet=True)``

    """

    def _detect_atomtypes_and_bonds(mcmfile, lines, PairNamesList):
        """Detect set of pairs/triplets of beads which are used in magic output file to mark
        according potential/distribution function. They are defined for every molecular type. Fist sub-list keeps
        intermolecular interactions, second - pairwise bonds, third - angle bending bonds.
         if a molecular type name is not provided in the subroutine's input, the PairNamesList is generated
         automatically, but the program assumes, that combinations of bead names are unique.
        """
        if mcmfile is None:
            # Detect molecular type names
            mlines = [
                l for l in lines for m in [re.search("MOLECULE", l)] if m
            ]  # lines with MT names
            mnames = [
                l.split("MOLECULE")[1].replace(" ", "").split(",")[0] + ".mcm"
                for l in mlines
            ]
            if not mnames:  # Have not got anything from the file. Try once more
                linentypes = [
                    l for l in lines for m in [re.search("Number of species:", l)] if m
                ]
                if linentypes:
                    ntypes = int(linentypes[0].split(":")[1].strip())
                    mlines = [
                        lines[i + 1 : i + 1 + ntypes]
                        for i in range(len(lines))
                        for m in [
                            re.search("Number of molecules of each species:", lines[i]),
                        ]
                        if m
                    ]
                    if mlines:
                        mnames = [l.strip().split()[2] + ".mcm" for l in mlines[0]]
            if not mnames:
                raise MTE.MagicToolsError(
                    "No Molecular Types detected! Please specify the mcmfiles manually!",
                )
            if not quiet:
                print(f"Detected Molecular Types:{mnames}")
            mcmfile = set(mnames)

        elif not isinstance(
            mcmfile,
            type([]),
        ):  # single file-name provided - convert to a list
            mcmfile = [mcmfile]
        if not quiet:
            print(f"Reading mcmfiles:{mcmfile}")
        system = System()
        MolTypes = [MolType(imcmfile, system, quiet=quiet) for imcmfile in mcmfile]
        bondname_dict = {}
        sameasbond_dict = {}
        if PairNamesList is None:
            if not quiet:
                print(
                    "Automatically defining list of interactions from input file. If this does not work well"
                    " for your input, manually provide PairNamesList to the procedure.\n",
                )
            pattern = re.compile("This pair|This triplet")
            l = [line.strip() for line in lines if pattern.search(line)]
            s = set(l)  # leave only one exemplar of every pair
            ll = []
            for line in l:  # order pairs as in the file
                if line in s:
                    ll.append(line)
                    s.remove(line)
            PairNamesList = [[], [], []]

            def unique(seq):
                seen = set()
                seen_add = seen.add
                return [x for x in seq if not (x in seen or seen_add(x))]

            patterns = [
                re.compile(pattern_)
                for pattern_ in [
                    "intermolecular",
                    "This pair.*intramolecular",
                    "This triplet:",
                ]
            ]

            def __parse_line__(line_, split1, split2):
                return line_.split(split1)[1].split(split2)[0].strip().replace(" ", "")

            for line in ll:
                if patterns[0].search(line):
                    if re.search(
                        "intermolecular pairs: *0$",
                        line,
                    ):  # make sure that there are non-zero RDFs
                        if not quiet:
                            print(
                                "No actual atom pairs detected for intermolecular pair: "
                                + __parse_line__(line, "This pair:", "intermolecular"),
                            )
                    else:
                        PairNamesList[0].append(
                            __parse_line__(line, "This pair:", "intermolecular"),
                        )
                if patterns[1].search(line):
                    record_ = __parse_line__(line, "This pair:", "intramolecular")
                    PairNamesList[1].append(record_)
                    if not quiet:
                        print(line)
                    if not quiet:
                        print("SameAs:" in line)
                    if "Bond" in line:
                        bondname_dict[record_] = line.split("Bond")[1].split(" ")[1]
                    if "SameAs:" in line:
                        sameasbond_dict[record_] = line.split("SameAs:")[1]
                if patterns[2].search(line):
                    record_ = __parse_line__(line, "This triplet:", "Bond")
                    PairNamesList[2].append(record_)
                    if "Bond" in line:
                        bondname_dict[record_] = line.split("Bond")[1].split(" ")[1]
                    if "SameAs:" in line:
                        sameasbond_dict[record_] = line.split("SameAs:")[1]

            PairNamesList = [unique(pn_list) for pn_list in PairNamesList]

            for List, msg_ in zip(
                PairNamesList,
                ["intermolecular pairs", "pairwise bonds", "angles"],
            ):
                if not quiet:
                    print(f"{len(List)} {msg_} detected {List}\n")
        return PairNamesList, MolTypes, bondname_dict, sameasbond_dict

    def _make_DF_from_lines(
        lines_,
        column,
        name,
        search_pattern=None,
        DF_subclass=None,
    ):
        """Parses set of lines <lines> for  regular expression <s> and returns object of a desired class."""
        assert isinstance(column, int) and (column > 0), (
            "Error: Column number must be positive integer!"
        )
        if not quiet:
            print("Pair " + str(pair))
        # search for resulting output (Final output, not a check one)
        re_pattern = re.compile(search_pattern)
        try:
            DF_g_list = [
                (float(l.split()[0]), float(l.split()[column - 1]))
                for l in lines_
                if re_pattern.search(l)
            ]
        except MTE.MagicToolsError:
            raise MTE.MagicToolsError(
                f"\nError while parsing the file.\n Parsing RegExpression: {search_pattern}\n",
            )
        if not DF_g_list:
            raise MTE.MagicToolsError(
                "\nError while parsing the file. Some tables were not found.\n"
                "Check if iterations are stated in accordance with the file: iters=(...)"
                f"Parsing RegExpression: {search_pattern}\n",
            )

        DF_g = np.array(DF_g_list)
        return DF_subclass(Name=name, g=DF_g)

    def AddProp2Bond(MolTypes, atoms, DFs):
        for MT in MolTypes:
            MTatoms = [a.Name for a in MT.Atoms]
            if all(x in MTatoms for x in atoms):
                # print('The bond type belongs to the molecular type: {0}'.format(MT.Name))
                IDatoms = [A for a in atoms for A in MT.Atoms if (a == A.Name)]
                if len(atoms) == 2:
                    bondtypes = [
                        BT for BT in MT.PairBondTypes if (IDatoms in BT.AtomGroups)
                    ]
                if len(atoms) == 3:
                    bondtypes = [
                        BT for BT in MT.AngleBondTypes if (IDatoms in BT.AtomGroups)
                    ]
                if len(bondtypes) > 1:
                    raise MTE.MagicToolsError(
                        "Error: this pair of atoms is involved in more than one bond! Check your mcm-files",
                    )
                DFs[-1].BondNumber = bondtypes[0].Number
                DFs[-1].MolTypeName = MT.Name
                DFs[-1].AtomGroups = [
                    [MT.Atoms.index(a) + 1 for a in AG]
                    for AG in bondtypes[0].AtomGroups
                ]

    if isinstance(ifile, list):
        dfset_list = []
        for ifile_ in ifile:
            dfset = ReadMagiC(
                ifile_,
                iters=iters,
                DFType=DFType,
                test=test,
                mcmfile=mcmfile,
                PairNamesList=PairNamesList,
                quiet=quiet,
            )
            if isinstance(dfset, DFset):
                dfset_list.append(dfset)
            else:
                dfset_list += dfset
        return dfset_list
    DFType_ = DFType.upper()
    assert DFType_ in ("RDF", "RDFREF", "POT", "NEWPOT", "POTNEW", "POTCORR"), (
        "ERROR: Unknown type of distribution function (DF)!"
    )
    try:
        df_file = open(ifile)
        lines = df_file.readlines()
        df_file.close()
    except:
        raise MTE.InputValueError("Can not read the input file!")

    PairNamesList, MolTypes, bondname_dict, sameasbond_dict = (
        _detect_atomtypes_and_bonds(mcmfile, lines, PairNamesList)
    )

    pattern = re.compile(
        " *(Final Corrected effective potential|^ *Potential correction convergence check)",
    )
    all_pot_lines = [l for l in lines if pattern.search(l)]
    if "Final" not in all_pot_lines[-1]:
        print("Warning! The file seems to be incomplete.")
        while "Final" not in all_pot_lines[-1]:
            all_pot_lines.pop()
    # Get total number of iterations completed:
    TotalNumIter = len(
        [
            l
            for l in all_pot_lines
            if re.compile("Final Corrected effective potential").search(l)
        ],
    )
    if not quiet:
        print(f"Total number of completed iterations:{TotalNumIter}")

    # Read exclusions:
    NPairBondsExclude = DFset._parse_exclusions(
        DFset._read_prop("NPAIRBONDSEXCLUDE", lines, must=False),
    )
    NAngleBondsExclude = DFset._parse_exclusions(
        DFset._read_prop("NANGLEBONDSEXCLUDE", lines, must=False),
    )

    #   build list of iteration numbers
    if not iters:
        iters = range(1, TotalNumIter + 1)
    elif isinstance(iters, int):  # eg. single iteration
        iters = [iters]

    # Get number of checks for every iteration
    TotalNumCheck = len(
        [l for l in all_pot_lines if "Potential correction convergence check" in l],
    )
    if not quiet:
        print(
            f"Total number of intermediate checks per iteration:{TotalNumCheck / TotalNumIter}",
        )
    if test:
        if not quiet:
            print("Intermediate checks are included:")
    newiters = []
    for irep in iters:
        if test:
            for i in range(TotalNumCheck // TotalNumIter):
                newiters.append(
                    (
                        f" *(Interm|Check) *{irep} *{i + 1}",
                        f"Check {i}",
                        irep,
                    ),
                )
        newiters.append((f" *Final *{irep}", "Final", irep))
    iters = newiters

    pattern = re.compile("pot: *")
    lines = [
        l for l in lines if pattern.search(l)
    ]  # Reduce the list of the lines to search

    column_by_DFType = {
        "RDFREF": 3,
        "RDF": 2,
        "POT": 5,
        "NEWPOT": 4,
        "POTNEW": 4,
        "POTCORR": 6,
    }
    if DFType_ == "RDFREF":
        iters = [iters[0]]  # only make one iteration if reading RDFref
    DFsList = []
    for iter_pattern, iter_type, iter_number in iters:  # loop over all iterations
        if not quiet:
            print(f"Iteration {iter_pattern}")
        DFs = []
        subclass_by_DFType = {
            "RDFREF": DF.RDFref_NB,
            "RDF": DF.RDF_NB,
            "POT": DF.Pot_NB,
            "NEWPOT": DF.Pot_NB,
            "POTNEW": DF.Pot_NB,
            "POTCORR": DF.Pot_NB,
        }
        for pair in PairNamesList[0]:  # Loop over intermolecular pairs
            s = (
                "pot: *"
                + pair.split("-")[0].strip()
                + " *"
                + pair.split("-")[1].strip()
                + iter_pattern
                + " *$"
            )
            name_ = f"{pair}"
            DFs.append(
                _make_DF_from_lines(
                    lines,
                    name=name_,
                    column=column_by_DFType[DFType_],
                    search_pattern=s,
                    DF_subclass=subclass_by_DFType[DFType_],
                ),
            )
            DFs[-1].AtomTypes = pair.split("-")

        subclass_by_DFType = {
            "RDFREF": DF.RDFref_PairBond,
            "RDF": DF.RDF_PairBond,
            "POT": DF.Pot_PairBond,
            "NEWPOT": DF.Pot_PairBond,
            "POTNEW": DF.Pot_PairBond,
            "POTCORR": DF.Pot_PairBond,
        }
        for pair in PairNamesList[
            1
        ]:  # Loop over intramolecular pairs with pairwise bonds
            name_ = f"{bondname_dict[pair] if pair in bondname_dict.keys() else pair}"
            s = (
                "pot: *"
                + " *".join([p.strip() for p in pair.split("-")[0:2]])
                + " *"
                + "-*[0-9]"
                + iter_pattern
                + " *$"
            )
            DFs.append(
                _make_DF_from_lines(
                    lines,
                    column=column_by_DFType[DFType_],
                    name=name_,
                    search_pattern=s,
                    DF_subclass=subclass_by_DFType[DFType_],
                ),
            )
            if pair in sameasbond_dict.keys():
                DFs[-1].SameAsBond = sameasbond_dict[pair]
            AddProp2Bond(MolTypes, pair.split("-"), DFs)

        subclass_by_DFType = {
            "RDFREF": DF.RDFref_AngleBond,
            "RDF": DF.RDF_AngleBond,
            "POT": DF.Pot_AngleBond,
            "NEWPOT": DF.Pot_AngleBond,
            "POTNEW": DF.Pot_AngleBond,
            "POTCORR": DF.Pot_AngleBond,
        }
        for pair in PairNamesList[2]:  # A
            name_ = f"{bondname_dict[pair] if pair in bondname_dict.keys() else pair}"

            s = (
                "pot: *"
                + " *".join([p.strip() for p in pair.split("-")[0:3]])
                + " *"
                + "-*[0-9]"
                + iter_pattern
                + " *$"
            )
            DFs.append(
                _make_DF_from_lines(
                    lines,
                    column=column_by_DFType[DFType_],
                    name=name_,
                    search_pattern=s,
                    DF_subclass=subclass_by_DFType[DFType_],
                ),
            )
            if pair in sameasbond_dict.keys():
                DFs[-1].SameAsBond = sameasbond_dict[pair]
            AddProp2Bond(MolTypes, pair.split("-"), DFs)
        DFsList.append(DFs)

    listDFset = []
    # Make DFsets out of inner list of DFs
    for i, DFs in enumerate(DFsList):  # DFs - single list of DFs
        min_ = 0.0
        max_ = np.max([df.Max for df in DFs if isinstance(df, DF.DF_NB)])
        npoints = int((max_ - min_) / DFs[0].Resol)
        # header_ = 'Reference' if DFType.upper() == 'RDFREF' else ('iter ' + str(iters[i][2]))
        header_ = (
            "Reference"
            if DFType.upper() == "RDFREF"
            else f"iter {iters[i][2]}.{iters[i][1]}"
        )
        name_ = f"{header_}.{ifile}"
        dfset_ = DFset(
            Name=name_,
            Min=min_,
            Max=max_,
            Npoints=npoints,
            DFs=DFs,
            NPairBondsExclude=NPairBondsExclude,
            NAngleBondsExclude=NAngleBondsExclude,
        )
        listDFset.append(dfset_)

    if len(listDFset) == 1:
        return listDFset[0]
    return listDFset


def ReadRDF(ifile, **kwargs):
    """Read set of RDFs from a rdf file.

    Args:
        ifile (str): Name of the file
        Name (str): Name of the DFset, used for annotations when plotted.
        quiet (bool): If to suppress output. Default False
        check (bool): If to check that bonded RDF are normalized to 1.0

    Example:
        ``rdf_ref = MT.ReadRDF('DMPC-Chol.rdf', Name='Reference RDF', quiet=True)``

    """
    dfset = DFset(File=ifile, check=False, **kwargs)

    return dfset


def ReadPot(ifile, Ucut=10000, **kwargs):
    """Read set of potentials from a .pot file

    Args:
        ifile (str): Name of the file
        Name (str): Name of the DFset, used for annotations when plotted
        quiet (bool): If to suppress output. Default False
        Ucut (float): Height of the hard repulsive core at r=0 in kJ/mol

    Example:
        ``pot = MT.ReadPot('03.Chol-DMPC.i010.pot', quiet=True)``
        ``pot2 = MT.ReadPot('01.MT1MT2.i010.pot', Ucut=5000.0)``

    """
    dfset = DFset(File=ifile, Ucut=Ucut, check=False, **kwargs)
    return dfset


def tpr2mmol(ifile):  # TODO: Rewrite as System.Init-method
    """Convert GROMACS's tpr file to a set of mmol-files, i.e. files lising atoms with their names, coordinates, masses and charges.

    Example:
        ``MT.tpr2mmol('03.dmpc30-chol30.tpr')``

    """
    if ifile.strip().endswith(".tpr"):
        tprfiledump = ifile + ".dmp"
        if os.system(f"gmxdump -s {ifile} > {tprfiledump}") != 0:
            if os.system(f"gmx dump -s {ifile} > {tprfiledump}") != 0:
                print(
                    "Error! Can not execute neither 'gmx dump' nor 'gmxdump'. Check presence of GROMACS in your PATH",
                )
    if ifile.strip().endswith(".dmp"):
        tprfiledump = ifile
    with open(tprfiledump) as ifile:
        lines = ifile.readlines()

    MTlines = [line.strip() for line in lines if re.search("moltype +=", line)]
    MTNames = [re.search('".*"', line).group().replace('"', "") for line in MTlines]

    NMollines = [line.strip() for line in lines if re.search("#molecules +=", line)]
    NMols = [int(line.split("=")[1]) for line in NMollines]

    #    NAtomlines = [line.strip() for line in lines if re.search('#atoms_mol +=', line)]
    NAtomlines = [line.strip() for line in lines if re.search(" atom ", line)]
    NAtomlines = NAtomlines[1::2]
    NAtoms = [int(re.findall(r"\d+", line)[0]) for line in NAtomlines]

    lBegMT = [
        i
        for iMT, MT in enumerate(MTNames)
        for i, l in enumerate(lines)
        if f"moltype ({iMT:<d})" in l
    ]
    lBegMT.append(len(lines) - 1)

    Rlines = [
        line.strip() for line in lines if re.search(r" +x\[ *[0-9]*\]=\{.*\}", line)
    ]
    R = [
        [float(rec) * 10.0 for rec in line.replace("}", "").split("]={")[1].split(",")]
        for line in Rlines
    ]
    rBeg = 0
    for iMT, MT in enumerate(MTNames):
        ll = lines[lBegMT[iMT] : lBegMT[iMT + 1]]
        ANamelines = [
            line.strip()
            for line in ll
            if re.search(r"atom\[[0-9]*\]=\{name=.*\}", line)
        ]
        ANames = [
            re.search('".*"', line).group().replace('"', "") for line in ANamelines
        ]
        AProplines = [
            line.strip()
            for line in ll
            if re.search(r"atom\[ *[0-9]*\]=\{type=.*\}", line)
        ]
        AProps = [
            [
                [rec.split("=")[1] for rec in line.split("]={")[1].split(",")][i]
                for i in [0, 3, 4]
            ]
            for line in AProplines
        ]
        Ri = R[rBeg : rBeg + NAtoms[iMT]]
        rBeg += NMols[iMT] * NAtoms[iMT]

        ofile = open(MT + ".mmol", "w")
        ofile.write(f"{NAtoms[iMT]}\n")
        ofile.write(
            "# {0} {1} {2} {3} {4} {5} \n".format(
                "Atom",
                "X",
                "Y",
                "Z",
                "Mass",
                "Charge",
            ),
        )
        ofile.writelines(
            [
                f"{ANames[i]} {round(Ri[i][0], 5)} {round(Ri[i][1], 5)} {round(Ri[i][2], 5)} {AProps[i][1]} {AProps[i][2]} \n"
                for i in range(NAtoms[iMT])
            ],
        )
        ofile.write("\n")
        ofile.close()


def gro2xmol(ifilename, ofilename="output.xmol"):
    """Convert .gro file into .xmol file

    Args:
        ifilename (str): input file (.gro)
        ofilename (str): output file (.xmol) optional

    Example:
        ``MT.gro2xmol('input.gro', 'output.xmol')``

    """
    with open(ifilename) as ifile:
        with open(ofilename, "w") as ofile:
            templine = ifile.readline()
            templine = ifile.readline()
            ifile = open(ifilename)
            natomsinp = int(templine.split("\n")[0])
            nlinestoread = int(templine.split("\n")[0]) + 3
            lines = [ifile.readline() for iline in range(nlinestoread)]
            while lines[nlinestoread - 1] != "":
                ll = []
                for i in range(len(lines)):
                    ll.append(lines[i].split("\n")[0])
                natoms = int(ll.pop(1).lstrip())
                if natoms != natomsinp:
                    raise MTE.MagicToolsError(
                        "Bad input: Total number of atoms in the system is different from sum(nmols*natimol)",
                    )

                box = [float(i) * 10.0 for i in ll[natoms + 1].split()]
                if "t=" in ll[0]:
                    t = float(ll.pop(0).split("t=")[1])
                else:
                    templine = ll.pop(0)
                    t = 0.0
                ofile.write(f"{natoms:10d}\n")
                ofile.write(
                    f" after {t * 1000.0:12.4f} fs, BOX: {box[0]:8.4f}    {box[1]:8.4f}    {box[2]:8.4f}\n",
                )

                atomname = [l.split()[1].lstrip() for l in ll[0:natoms]]
                X = [float(l.split()[3].lstrip()) * 10.0 for l in ll[0:natoms]]  # in nm
                Y = [float(l.split()[4].lstrip()) * 10.0 for l in ll[0:natoms]]  # nm
                Z = [float(l.split()[5].lstrip()) * 10.0 for l in ll[0:natoms]]  # nm
                i = 0

                for i in range(len(atomname)):
                    ofile.write(
                        f"{atomname[i]:4s} {X[i]:7.3f} {Y[i]:7.3f} {Z[i]:7.3f}\n",
                    )
                lines = [ifile.readline() for iline in range(nlinestoread)]


def xmol2gro(ifilename, ofilename, molnames, nmols, natimol, nconf=1):
    """Convert the xmol-file to gro-file.

    Args:
        ifilename (str): Input .xmol file
        ofilename (str): Output .gro file
        molnames ([str, str]):  List of molecular types names
        nmols ([int, int]): List of number of molecules of each type.
        natimol ([int, int]): List of number of atoms in molecule of each type.
        nconf (int): How many configurations to convert. Default 1.

    Example:
        Example for two component system of 98 molecules of DMPC (118 atoms) and 2700 molecules of water (3 atoms)

        ``xmol2gro('input.xmol', 'output.gro', ['DMPC','WAT'], [98,2700], [118,3], nconf=1)``

    """
    with open(ifilename) as ifile:
        with open(ofilename, "w") as ofile:
            if any([m.count(".") > 0 for m in molnames]):
                raise MTE.MagicToolsError(
                    "some of your molecule names contains dots. Please rename them",
                )
            for iconf in range(nconf):
                lines = []
                for i in range(
                    sum([nmols[i] * natimol[i] for i in range(len(nmols))]) + 2,
                ):
                    lines.append(ifile.readline().split("\n")[0])
                ll = lines
                if len(nmols) != len(natimol):
                    raise MTE.MagicToolsError("Bad input len(nmols)!=len(natimol)")
                natoms = int(ll.pop(0).lstrip())
                if natoms != sum([nmols[i] * natimol[i] for i in range(len(nmols))]):
                    raise MTE.MagicToolsError(
                        "Bad input: Total number of atoms in the system is different from sum(nmols*natimol)",
                    )
                box = [float(i) for i in ll[0].split("BOX:")[1].split()]
                ofile.write("gro-file converted from xmol using MagicTools.xmol2gro\n")
                ofile.write(str(natoms) + "\n")
                atomname = [l.split()[0].lstrip() for l in ll[1 : natoms + 1]]
                X = [
                    float(l.split()[1].lstrip()) * 0.1 for l in ll[1 : natoms + 1]
                ]  # in nm
                Y = [
                    float(l.split()[2].lstrip()) * 0.1 for l in ll[1 : natoms + 1]
                ]  # nm
                Z = [
                    float(l.split()[3].lstrip()) * 0.1 for l in ll[1 : natoms + 1]
                ]  # nm
                i = 0
                for inmol in range(len(nmols)):  # over types
                    for imol in range(nmols[inmol]):  # over molecules of type
                        for iat in range(
                            natimol[inmol],
                        ):  # over all atoms ov molecule of given type
                            first_res_number = 0
                            for restype in range(inmol):
                                first_res_number += nmols[restype]
                            ofile.write(
                                f"{first_res_number + imol + 1:>5d}{molnames[inmol]:<5.5s}{atomname[i]:>5.5s}{i + 1:>5d}{X[i]:>8.3f}{Y[i]:>8.3f}{Z[i]:>8.3f}{0.0:8.4f}{0.0:8.4f}{0.0:8.4f}\n",
                            )
                            i += 1
                ofile.write(
                    f"{box[0] * 0.1:10.5f}{box[1] * 0.1:10.5f}{box[2] * 0.1:10.5f}\n",
                )


def xtc2xmol(filename, system, first=False, ofilename=None):
    """Convert .xtc file to .xmol file. (.trr files are also accepted).

    Args:
        filename (str): .xtc file
        system (System): System-object reuired to get names of the atoms
        first (bool): If only the first frame of the xtc file shall be used. Default False
        ofilename (str): Output .xmol file, if not given the input file name will be used.

    """
    try:
        import mdtraj
    except ImportError:
        print(
            "mdtraj library required. Please install it as described here http://mdtraj.org",
        )
        return
    trj = mdtraj.open(filename)
    names = [atom_.Name for atom_ in system.Atoms]
    if ofilename is None:
        ofilename = filename.replace("xtc", "xmol").replace("trr", "xmol")
    with open(ofilename, "w") as ofile:
        r, time, step, box_ = trj.read(1)
        cnt = 0
        while not ((0 in r.shape) or (len(r.shape) != 3)):
            cnt += 1
            x = r[0] * 10.0
            t = float(time[0])
            box = np.array(np.diag(box_[0]) * 10.0)
            assert len(x) == len(names)
            ofile.write(f"{len(x):10d}\n")
            ofile.write(
                f" after {t * 1000.0:12.4f} fs, BOX: {box[0]:8.4f}    {box[1]:8.4f}    {box[2]:8.4f}\n",
            )
            for name, r in zip(names, x):
                ofile.write(f"{name}  {r[0]:7.3f}  {r[1]:7.3f}  {r[2]:7.3f}\n")
            if first:
                return
            r, time, step, box_ = trj.read(1)
    return


def GetStartConfs(
    ifilename,
    Nconfs,
    ofilename="start.xmol",
    Begin=0,
    End=0,
    Random=False,
):
    """Creates a set of starting configurations to be used in MagiC.Core.
    I.e. it reduces the full bead-mapped trajectory file to a set of uniformly distributed configurations.

    Args:
        ifilename (str): Input trajectory in xmol-format
        Nconfs (int): Number of configurations to generate
        ofilename (str): Output trajectory filename
        Begin (int): Specify range of configurations to pick from
        End (int): Specify range of configurations to pick from
        Random (bool): Pick trajectories randomly (with uniform distribution), otherwise use constant step

    Example:
        ``MT.GetStartConfs('traj.xmol', Nconfs=100, Begin=0, End=10000, Random=False)``

        Uniformly pick 100 configurations from file traj.xmol, starting with configuration 0 and up to configuration 10000.
         Every 100th configuration will be picked.

    """
    try:
        NconfsTotal = int(
            subprocess.check_output("grep -c after " + ifilename, shell=True),
        )
    except:
        raise MTE.MagicToolsError(
            "Can not get total number of the configurations in the trajectory",
        )

    with open(ifilename) as ifile:
        Natoms = int(ifile.readline().strip())

    with open(ofilename, "w") as ofile:
        with open(ifilename) as ifile:
            print(f"{Natoms} atoms in the file")
            print(f"{NconfsTotal} frames in the file")
            if End == 0:
                End = NconfsTotal

            if Random:
                random.seed()
                confs = [random.randint(Begin, End) for i in range(Nconfs)]
                confs.sort()
            else:
                confs = range(Begin, End, (End - Begin) // Nconfs)
                print(
                    f"Begin={Begin}, End={End}, Nconfs={Nconfs}, Step={(End - Begin) / Nconfs}",
                )

                # read the trajectory:
            old = 0
            cnt = 0
            for conf in confs:
                for i in range((Natoms + 2) * (conf - old - 1)):
                    l = ifile.readline()
                    if l == "":
                        break
                ll = [ifile.readline() for i in range(Natoms + 2)]
                if ll[-1] == "":  # if EOF reached
                    break
                ofile.writelines(ll)
                cnt = cnt + 1
                old = conf
            print(f"{cnt} configurations written")


def Average(list_of_DFset, **kwargs):
    """Averages given list of DFset objects into a single DFset.

    Args:
        list_of_DFset: list of DFset-objects
        force (bool): Force the averaging of DFs even if they are not alike (False)
        weights ([float, float]): List of the weights for the averaging. Must have length of the corresponding DFset

    Returns:
        DFset each function of which is an average of corresponding funcions from all DFsets of the given list

    Example: ::

        rdf1 = MT.ReadRDF("file1.rdf")
        rdf2 = MT.ReadRDF("file2.rdf")

        rdf_average = MT.Average([rdf1, rdf2], weights=[1.0, 1.0])

    """
    return DFset.Average(list_of_DFset, **kwargs)


def _read_and_clean_lines(filename):
    with open(filename) as ifile:
        lines = ifile.readlines()
    # cut away all lines starting with # or !
    lines = [s.strip() for s in lines]
    lines = [s.lstrip() for s in lines]
    lines = [s.rstrip(",") for s in lines]
    lines = [s for s in lines if s and (not s.startswith(("#", "!")))]
    # read number of atoms in the molecular type
    return lines


def dcd2xtc(trj, top):
    """Convert GALAMOST .dcd file to .xtc.

    It is assumed that GALAMOST files have length unit of nm.
    Note that timestep is not preserved, as it is not stored in dcd-format

    Args:
        trj (str): GALAMOST trajectory file in dcd format
        top (str): GALAMOST topology file in xml-format


    Example:
        ``MT.dcd2xtc("trj.dcd", "topology.xml")``

    """
    import mdtraj

    topology_ = mdtraj.load_hoomdxml(top).topology
    trj_dcd = mdtraj.load_dcd(trj, top=topology_)
    trj_dcd.xyz = trj_dcd.xyz * 10.0
    trj_dcd.unitcell_vectors *= 10.0
    trj_dcd.save_xtc(trj.replace(".dcd", ".xtc"))
