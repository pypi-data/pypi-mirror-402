# Alpha DSL

Domain-specific language for composing alpha expressions with operator overloading.

## Overview

The Alpha DSL provides two ways to build alpha expressions:

1. **Alpha class** - Python operator overloading (`+`, `-`, `*`, `/`, `<`, `>`, etc.)
2. **alpha_eval()** - String-based DSL for dynamic expressions (GP/RL compatible)

All work on **wide DataFrames**: first column is date, remaining columns are symbols.

```
timestamp   | AAPL  | MSFT  | GOOGL
2024-01-01  | 100.0 | 200.0 | 150.0
2024-01-02  | 101.0 | 198.0 | 152.0
```

## Installation

```python
from quantdl.alpha import Alpha, alpha_eval
import quantdl.operators as ops
```

---

## Alpha Class

**Location**: `src/quantdl/alpha/core.py`

Wrap a DataFrame to enable operator overloading:

```python
close = Alpha(close_df)
volume = Alpha(volume_df)
```

### Arithmetic

```python
returns = close / Alpha(ops.ts_delay(close.data, 1)) - 1  # daily returns
weighted = returns * volume                                # volume-weighted
scaled = returns * 100                                     # scalar multiply
```

### Comparisons

Returns `1.0` for True, `0.0` for False:

```python
mask = close > 100          # Alpha with 1.0 where close > 100
mask = close >= volume      # element-wise comparison
```

### Logical Operations

```python
both = (close > 100) & (volume > 1000)    # AND
either = (close > 100) | (volume > 1000)  # OR
inverted = ~(close > 100)                  # NOT (1.0 where False)
```

### Unary Operations

```python
neg = -close          # negation
absolute = abs(close) # absolute value (Python builtin works)
```

### Access Underlying Data

```python
alpha = close * 2
result_df = alpha.data  # get pl.DataFrame
```

### Supported Operators

| Operator | Description |
|----------|-------------|
| `+`, `-`, `*`, `/`, `**` | Arithmetic |
| `<`, `<=`, `>`, `>=`, `==`, `!=` | Comparison |
| `&`, `\|` | Logical |
| `-x` | Negation |

---

## Operators Integration

Operators work on raw DataFrames. Use `.data` to extract from Alpha:

```python
close = Alpha(close_df)

# Apply operator to underlying DataFrame
ma = ops.ts_mean(close.data, 20)

# Wrap result back in Alpha for further operations
ma_alpha = Alpha(ma)
signal = ma_alpha - close
```

### Common Pattern

```python
# Compute momentum, rank cross-sectionally
momentum = ops.ts_delta(close_df, 5)
ranked = ops.rank(momentum)
signal = Alpha(ranked)
```

### Chaining Operators

```python
# Rank of z-scored 20-day returns
returns = close_df.select(
    pl.col("timestamp"),
    *[(pl.col(c) / pl.col(c).shift(20) - 1) for c in symbols]
)
alpha = ops.rank(ops.zscore(returns))
```

---

## String DSL (alpha_eval)

**Location**: `src/quantdl/alpha/parser.py`

Parse and evaluate string expressions safely using AST:

```python
result = alpha_eval(
    "close * 2 + 1",
    {"close": close_df}
)
```

### Signature

```python
def alpha_eval(
    expr: str,
    variables: dict[str, AlphaLike],
    ops: Any | None = None,
) -> Alpha:
```

### With Operators

Two syntax styles supported:

```python
# Clean syntax (recommended for GP/RL)
result = alpha_eval(
    "rank(-ts_delta(close, 5))",
    {"close": close_df},
    ops=ops,
)

# Legacy syntax (still supported)
result = alpha_eval(
    "ops.rank(-ops.ts_delta(close, 5))",
    {"close": close_df},
    ops=ops,
)
```

### Builtin Functions

Available without `ops` parameter:

| Function | Description |
|----------|-------------|
| `abs(x)` | Absolute value |
| `min(x, y, ...)` | Element-wise minimum |
| `max(x, y, ...)` | Element-wise maximum |
| `log(x)` | Natural logarithm |
| `sqrt(x)` | Square root |
| `sign(x)` | Sign function |

```python
result = alpha_eval("min(close, vwap)", {"close": close_df, "vwap": vwap_df})
result = alpha_eval("abs(close - 100)", {"close": close_df})
```

### Ternary Expressions

```python
result = alpha_eval(
    "close if close > 100 else 0",
    {"close": close_df}
)
```

### Complex Expressions

```python
result = alpha_eval(
    "rank(ts_mean(close, 5)) * (volume > ts_mean(volume, 20))",
    {"close": close_df, "volume": volume_df},
    ops=ops
)
```

### Supported Syntax

| Category | Examples |
|----------|----------|
| Variables | Any name in `variables` dict |
| Literals | `2`, `1.5`, `-3.14` |
| Binary ops | `+`, `-`, `*`, `/`, `**`, `<`, `<=`, `>`, `>=`, `==`, `!=`, `&`, `\|` |
| Unary ops | `-`, `+`, `~` |
| Ternary | `x if cond else y` |

---

## GP/RL Integration

The DSL is designed for genetic programming and reinforcement learning alpha mining:

```python
import quantdl.operators as ops
from quantdl.alpha import alpha_eval

# Expression generated by GP/RL agent
expr = "rank(ts_zscore(ts_delta(close, 5), 20))"

# Evaluate
alpha = alpha_eval(expr, {"close": close_df}, ops=ops)

# Get underlying DataFrame
result_df = alpha.data
```

**Why clean syntax matters**: GP/RL systems generate expression trees. The clean syntax (`rank(...)` vs `ops.rank(...)`) produces shorter, more readable expressions.

---

## Validation

Alpha operations validate alignment automatically:

```python
from quantdl.alpha import ColumnMismatchError, DateMismatchError

try:
    result = Alpha(df1) + Alpha(df2)  # different columns
except ColumnMismatchError as e:
    print(e.left_cols, e.right_cols)

try:
    result = Alpha(df1) + Alpha(df3)  # different row counts
except DateMismatchError as e:
    print(e.left_dates, e.right_dates)
```

Scalar operations don't require alignment:

```python
result = Alpha(close_df) * 2  # always works
```

---

## Type Reference

| Type | Description |
|------|-------------|
| `Alpha` | Wrapped DataFrame with operator overloading |
| `AlphaLike` | `Alpha`, `pl.DataFrame`, `int`, or `float` |
| `Scalar` | `int` or `float` |

## Exception Reference

| Exception | Description |
|-----------|-------------|
| `AlphaError` | Base exception for alpha operations |
| `AlphaParseError` | Invalid syntax, unknown variable, unsupported operation |
| `ColumnMismatchError` | DataFrames have different columns |
| `DateMismatchError` | DataFrames have different row counts |

---

## Operator Categories

| Category | Examples | Input |
|----------|----------|-------|
| Time-series | `ts_mean`, `ts_delta`, `ts_rank` | column-wise |
| Cross-sectional | `rank`, `zscore`, `scale` | row-wise |
| Arithmetic | `abs`, `add`, `multiply`, `log` | element-wise |
| Logical | `and_`, `or_`, `if_else` | element-wise |
| Group | `group_rank`, `group_zscore` | grouped rows |

---

## Example: Momentum Alpha

```python
from quantdl import QuantDLClient
from quantdl.alpha import Alpha
import quantdl.operators as ops

client = QuantDLClient()

# Load data
close = client.ticks(["AAPL", "MSFT", "GOOGL"], "close", "2024-01-01", "2024-12-31")
volume = client.ticks(["AAPL", "MSFT", "GOOGL"], "volume", "2024-01-01", "2024-12-31")

# 5-day momentum, ranked
momentum = ops.ts_delta(close, 5)
ranked = ops.rank(momentum)

# Filter by volume
avg_volume = ops.ts_mean(volume, 20)
mask = Alpha(volume) > Alpha(avg_volume)

# Final alpha
alpha = Alpha(ranked) * mask
result = alpha.data
```

## Example: Mean Reversion Alpha

```python
# Z-score of price vs 20-day MA
ma = ops.ts_mean(close, 20)
std = ops.ts_std(close, 20)
zscore = ops.divide(ops.subtract(close, ma), std)

# Negative zscore = buy signal (mean reversion)
alpha = ops.rank(-zscore)
```

## Example: String DSL

```python
from quantdl.alpha import alpha_eval
import quantdl.operators as ops

# Using string DSL for GP/RL compatibility
signal = alpha_eval(
    "rank(-ts_delta(close, 5))",
    {"close": close},
    ops=ops,
)

print(signal.data)
```

---

## Test Coverage

**Location**: `tests/test_alpha.py`

| Test | Coverage |
|------|----------|
| `test_alpha_arithmetic` | Alpha +, -, *, / |
| `test_alpha_comparison` | Alpha <, >, ==, etc. |
| `test_alpha_eval_basic` | Basic expression parsing |
| `test_alpha_eval_operators` | Operator function calls |
| `test_alpha_eval_clean_syntax` | GP/RL-friendly syntax |
| `test_alpha_parse_error` | Error handling |

Run tests:
```bash
uv run pytest tests/test_alpha.py -v
```
