# coding: utf-8

"""
    VRt.Packer [PC]

    Veeroute Packer API.  # Description  The service is designed to calculate the placement of goods inside given packages.  ## Types of packages  ### Pallet  ![pallet](../images/packer_pallet.svg)  *Mono-pallet*  If the pallet is fully equipped with the same product, then such a pallet is called **mono-pallet**, such a pallet has the following loading rules:  1. The maximum allowable height of the pallet with the goods laid on it is taken into account. 1. The maximum allowable weight of the loaded pallet is taken into account. 1. Goods packages can only be stacked parallel to the walls of the pallet. 1. It is allowed to rotate packages around the vertical Z-axis and only at a right angle. 1. In order to equalize the height between the positions (to place another pallet on top), empty spaces can be added to the stacking by layers.  *Zone tray*  After the formation of mono-pallets, the remaining part of the goods of the same article is placed on the next pallet, which is divided into zones by means of a cardboard partition in such a way that only one item of goods is placed in each zone, while the zones have the following restrictions:  1. The zones are rectangular. 1. The ratio between the sides of the zones can be any. 1. One of the sides of any zone is always in contact with the edge of the pallet. 1. Permissible number of zones on a pallet: from 2 to 6. 1. Each zone is filled according to the rules for filling a mono-pallet. 1. The stacking height of all goods does not exceed 50 mm, so that another pallet can be placed on top of such a pallet. 1. It is allowed to form pallets with different stacking heights for different positions (height difference is more than 50 mm), if these are the top pallets in the stack.  ### Mixbox  ![mixbox](../images/packer_mixbox.svg)  If the above steps fail to place the item in this way, so that the pallet is of the required height or weight, mixboxes are used:  1. Mixbox can only be placed in one layer. 1. Different goods can be placed in one mixbox, in this case it is divided by partitions similarly to a pallet (the only difference is that the height of the packed goods is not aligned). 1. Mixboxes can be mixed with items on the same pallet. 1. One product can be packed in different mixboxes.  ### Slot  ![slot](../images/packer_slot.svg)  The loaded pallets are stacked on top of each other, the slot is where the stack of pallets is placed. The slot has no physical body - so the dimensions of the `body` of the slot are zero.  ## Coordinate system  ![coordinates](../images/packer_coordinates.svg)  To indicate the location of packages and goods, a local coordinate system is used, in which the coordinates of a particular object are indicated relative to the near left lower corner of the parent object, while:  * Horizontal plane - axes **X**, **Y** * Vertical - **Z** axis  The ratio of the axes of goods and packages:  * Width - **X** * Length - **Y** * Height - **Z**  ## Entity diagram  ![erd](../uml/packer.svg)

    The version of the OpenAPI document: 7.29.3120
    Contact: servicedesk@veeroute.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field
from typing import Any, ClassVar, Dict, List, Optional
from typing_extensions import Annotated
from vrt_lss_packer.models.entity_error import EntityError
from vrt_lss_packer.models.entity_warning import EntityWarning
from vrt_lss_packer.models.schema_error import SchemaError
from vrt_lss_packer.models.tracedata import Tracedata
from typing import Optional, Set
from typing_extensions import Self

class Custom400WithErrorsAndWarnings(BaseModel):
    """
    Error details.
    """ # noqa: E501
    tracedata: Tracedata
    message: Optional[Annotated[str, Field(min_length=1, strict=True, max_length=2048)]] = Field(default=None, description="Error message.")
    schema_errors: Optional[Annotated[List[SchemaError], Field(min_length=0, max_length=15001)]] = Field(default=None, description="List of syntax errors - data does not match the schema.")
    logical_errors: Optional[Annotated[List[EntityError], Field(min_length=0, max_length=70001)]] = Field(default=None, description="A list of errors in the source data that make it impossible to start the calculation. ")
    warnings: Optional[Annotated[List[EntityWarning], Field(min_length=0, max_length=70001)]] = Field(default=None, description="List of warnings. Depending on the flag `calculation_settings.treat_warnings_as_errors` - triggered checks are interpreted as errors or result in the removal of incorrect data from the calculation. ")
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["tracedata", "message", "schema_errors", "logical_errors", "warnings"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Custom400WithErrorsAndWarnings from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of tracedata
        if self.tracedata:
            _dict['tracedata'] = self.tracedata.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in schema_errors (list)
        _items = []
        if self.schema_errors:
            for _item_schema_errors in self.schema_errors:
                if _item_schema_errors:
                    _items.append(_item_schema_errors.to_dict())
            _dict['schema_errors'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in logical_errors (list)
        _items = []
        if self.logical_errors:
            for _item_logical_errors in self.logical_errors:
                if _item_logical_errors:
                    _items.append(_item_logical_errors.to_dict())
            _dict['logical_errors'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in warnings (list)
        _items = []
        if self.warnings:
            for _item_warnings in self.warnings:
                if _item_warnings:
                    _items.append(_item_warnings.to_dict())
            _dict['warnings'] = _items
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        # set to None if message (nullable) is None
        # and model_fields_set contains the field
        if self.message is None and "message" in self.model_fields_set:
            _dict['message'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Custom400WithErrorsAndWarnings from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "tracedata": Tracedata.from_dict(obj["tracedata"]) if obj.get("tracedata") is not None else None,
            "message": obj.get("message"),
            "schema_errors": [SchemaError.from_dict(_item) for _item in obj["schema_errors"]] if obj.get("schema_errors") is not None else None,
            "logical_errors": [EntityError.from_dict(_item) for _item in obj["logical_errors"]] if obj.get("logical_errors") is not None else None,
            "warnings": [EntityWarning.from_dict(_item) for _item in obj["warnings"]] if obj.get("warnings") is not None else None
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj


