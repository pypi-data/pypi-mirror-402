"""Dataset client for accessing Flo datasets from workflows."""

import os
import requests
from typing import Any, Optional, List, Dict
from tenacity import retry, stop_after_attempt, wait_exponential

from flo.datasets.models import DatasetRow
from flo.datasets.exceptions import (
    DatasetNotFoundError,
    DatasetAPIError,
)


class DatasetClient:
    """Client for interacting with a single dataset."""
    
    def __init__(
        self,
        dataset_id: str,
        dataset_name: str,
        http_client: "FloDatasetClient",
    ):
        self._id = dataset_id
        self._name = dataset_name
        self._http = http_client
        self._pinned_version: Optional[int] = None
    
    def find(
        self,
        filter: Optional[Dict[str, Any]] = None,
        limit: int = 100,
    ) -> List[Dict[str, Any]]:
        """Query rows from the dataset."""
        query_request = {
            "workflowRunId": self._http._run_id,
            "filter": filter or {},
            "limit": limit,
        }
        # For dev runs, include tenantId
        if self._http._run_id.startswith("dev_"):
            query_request["tenantId"] = self._http._tenant_id
        
        response = self._http._request(
            "POST",
            f"/workflow/datasets/{self._id}/query",
            json=query_request,
        )
        
        # Record access and update pinned version
        self._pinned_version = response.get("version")
        self._http._record_access(
            self._id,
            self._name,
            "read",
            self._pinned_version,
        )
        
        return response.get("rows", [])
    
    def find_one(self, filter: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """Find a single row matching the filter."""
        rows = self.find(filter, limit=1)
        return rows[0] if rows else None
    
    def insert(self, data: Dict[str, Any]) -> DatasetRow:
        """Insert a new row. Row ID is auto-generated by server."""
        insert_request = {
            "workflowRunId": self._http._run_id,
            "data": data,
        }
        # For dev runs, include tenantId
        if self._http._run_id.startswith("dev_"):
            insert_request["tenantId"] = self._http._tenant_id
        
        response = self._http._request(
            "POST",
            f"/workflow/datasets/{self._id}/rows",
            json=insert_request,
        )
        
        version_written = response.get("version")
        self._http._record_access(
            self._id,
            self._name,
            "write",
            self._pinned_version,
            version_written,
        )
        
        return DatasetRow(
            row_id=response["rowId"],
            data=data,
            version=version_written,
        )
    
    def update(self, row_id: str, data: Dict[str, Any]) -> DatasetRow:
        """Update an existing row by its server-generated row ID."""
        update_request = {
            "workflowRunId": self._http._run_id,
            "data": data,
        }
        # For dev runs, include tenantId
        if self._http._run_id.startswith("dev_"):
            update_request["tenantId"] = self._http._tenant_id
        
        response = self._http._request(
            "PUT",
            f"/workflow/datasets/{self._id}/rows/{row_id}",
            json=update_request,
        )
        
        version_written = response.get("version")
        self._http._record_access(
            self._id,
            self._name,
            "write",
            self._pinned_version,
            version_written,
        )
        
        return DatasetRow(
            row_id=response["rowId"],
            data=data,
            version=version_written,
        )
    
    def delete(self, row_id: str) -> int:
        """Delete a row by its server-generated row ID. Returns new version number."""
        delete_request = {"workflowRunId": self._http._run_id}
        # For dev runs, include tenantId
        if self._http._run_id.startswith("dev_"):
            delete_request["tenantId"] = self._http._tenant_id
        
        response = self._http._request(
            "DELETE",
            f"/workflow/datasets/{self._id}/rows/{row_id}",
            json=delete_request,
        )
        
        version_written = response.get("version")
        self._http._record_access(
            self._id,
            self._name,
            "write",
            self._pinned_version,
            version_written,
        )
        
        return version_written


class FloDatasetClient:
    """Main Flo SDK client for datasets. Authentication handled automatically by Flo runtime."""
    
    def __init__(
        self,
        base_url: str,
        api_key: str,
        run_id: str,
        tenant_id: str,
    ):
        self._base_url = base_url.rstrip("/")
        self._api_key = api_key
        self._run_id = run_id
        self._tenant_id = tenant_id
        self._dataset_cache: Dict[str, DatasetClient] = {}
        self._session = requests.Session()
        self._session.headers.update({
            "Authorization": f"Bearer {api_key}",
            "Content-Type": "application/json",
        })
    
    @classmethod
    def from_env(cls) -> "FloDatasetClient":
        """Create client from workflow environment. This is the standard entry point."""
        base_url = os.getenv("FLO_API_URL")
        api_key = os.getenv("FLO_API_KEY")
        run_id = os.getenv("FLO_RUN_ID")
        tenant_id = os.getenv("FLO_TENANT_ID")
        
        if not all([base_url, api_key, run_id, tenant_id]):
            raise ValueError(
                "Missing required environment variables. "
                "Ensure FLO_API_URL, FLO_API_KEY, FLO_RUN_ID, and FLO_TENANT_ID are set."
            )
        
        return cls(
            base_url=base_url,
            api_key=api_key,
            run_id=run_id,
            tenant_id=tenant_id,
        )
    
    def dataset(self, name: str) -> DatasetClient:
        """Get a dataset client by name. Version is pinned automatically on first access."""
        if name not in self._dataset_cache:
            # Resolve name to ID and pin version
            # For dev runs (IDs starting with "dev_"), include tenantId in request body
            pin_request = {
                "workflowRunId": self._run_id,
                "datasets": [name],
            }
            if self._run_id.startswith("dev_"):
                pin_request["tenantId"] = self._tenant_id
            
            pins = self._request(
                "POST",
                "/workflow/datasets/pin",
                json=pin_request,
            )
            
            pin = pins["pins"][0]
            
            client = DatasetClient(
                dataset_id=pin["datasetId"],
                dataset_name=pin["datasetName"],
                http_client=self,
            )
            client._pinned_version = pin["versionPinned"]
            self._dataset_cache[name] = client
        
        return self._dataset_cache[name]
    
    def list_datasets(
        self,
        page: int = 1,
        page_size: int = 20,
        search: Optional[str] = None,
    ) -> Dict[str, Any]:
        """
        List all datasets available to this workflow.
        
        Args:
            page: Page number (1-indexed)
            page_size: Number of datasets per page (max 100)
            search: Optional search query to filter datasets by name
        
        Returns:
            Dictionary with:
            - datasets: List of dataset dictionaries with id, name, description, etc.
            - total: Total number of datasets
            - page: Current page number
            - pageSize: Number of datasets per page
            - totalPages: Total number of pages
        
        Example:
            client = FloDatasetClient.from_env()
            result = client.list_datasets(page=1, page_size=10, search="invoices")
            for dataset in result['datasets']:
                print(f"{dataset['name']}: {dataset['rowCount']} rows")
        """
        params: Dict[str, Any] = {
            "page": page,
            "pageSize": page_size,
            "tenantId": self._tenant_id,  # Always include tenantId
        }
        if search:
            params["search"] = search
        
        response = self._request(
            "GET",
            "/workflow/datasets",
            json=None,
            params=params,
        )
        
        return response
    
    def _request(
        self,
        method: str,
        endpoint: str,
        json: Optional[Dict[str, Any]] = None,
        params: Optional[Dict[str, Any]] = None,
    ) -> Dict[str, Any]:
        """Make a request to the Flo API."""
        url = f"{self._base_url}{endpoint}"
        
        try:
            response = self._session.request(
                method=method,
                url=url,
                json=json,
                params=params,
                timeout=30,
            )
            
            # Handle errors
            if response.status_code == 401:
                raise DatasetAPIError(
                    "Authentication failed. Check FLO_API_KEY.",
                    status_code=response.status_code,
                )
            
            if response.status_code == 404:
                error_data = response.json() if response.content else {}
                if "Dataset not found" in error_data.get("message", ""):
                    raise DatasetNotFoundError(
                        error_data.get("message", "Dataset not found")
                    )
                raise DatasetAPIError(
                    error_data.get("message", "Resource not found"),
                    status_code=response.status_code,
                    response=error_data,
                )
            
            if not response.ok:
                error_data = response.json() if response.content else {}
                raise DatasetAPIError(
                    error_data.get("message", f"API request failed: {response.text}"),
                    status_code=response.status_code,
                    response=error_data,
                )
            
            return response.json()
            
        except requests.exceptions.RequestException as e:
            raise DatasetAPIError(f"Request failed: {str(e)}")
    
    def _record_access(
        self,
        dataset_id: str,
        dataset_name: str,
        access_type: str,
        version_pinned: Optional[int],
        version_written: Optional[int] = None,
    ) -> None:
        """Record dataset access (no-op for now, access is tracked server-side)."""
        # Access tracking is handled server-side via the API endpoints
        # This method exists for potential future client-side tracking
        pass
    
    def __enter__(self):
        """Context manager entry."""
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        """Context manager exit - close session."""
        self._session.close()

