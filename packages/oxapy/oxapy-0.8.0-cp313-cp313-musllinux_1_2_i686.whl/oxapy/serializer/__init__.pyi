# This file is automatically generated by pyo3_stub_gen
# ruff: noqa: E501, F401

import builtins
import typing
from oxapy.exceptions import ClientError

class BooleanField(Field):
    r"""
    Represents a boolean field.
    """
    def __new__(cls, required: builtins.bool = True, nullable: builtins.bool = False, format: typing.Optional[builtins.str] = None, many: builtins.bool = False, length: typing.Optional[builtins.int] = None, min_length: typing.Optional[builtins.int] = None, max_length: typing.Optional[builtins.int] = None, pattern: typing.Optional[builtins.str] = None, enum_values: typing.Optional[typing.Sequence[builtins.str]] = None, read_only: builtins.bool = False, write_only: builtins.bool = False) -> BooleanField:
        r"""
        Create a new field of this type.
        
        Args:
            required (bool, optional): Whether this field is required. Defaults to `True`.
            nullable (bool, optional): Whether this field allows `null`. Defaults to `False`.
            format (str, optional): Optional format override.
            many (bool, optional): Whether this field is a list of values.
            min_length (int, optional): Minimum length (for string types).
            max_length (int, optional): Maximum length (for string types).
            pattern (str, optional): Regular expression pattern.
            enum_values (list[str], optional): List of allowed values.
            read_only (bool, optional): If `True`, the field will be excluded when deserializing.
            write_only (bool, optional): If `True`, the field will be excluded when serializing.
        """

class CharField(Field):
    r"""
    Represents a string field.
    """
    def __new__(cls, required: builtins.bool = True, nullable: builtins.bool = False, format: typing.Optional[builtins.str] = None, many: builtins.bool = False, length: typing.Optional[builtins.int] = None, min_length: typing.Optional[builtins.int] = None, max_length: typing.Optional[builtins.int] = None, pattern: typing.Optional[builtins.str] = None, enum_values: typing.Optional[typing.Sequence[builtins.str]] = None, read_only: builtins.bool = False, write_only: builtins.bool = False) -> CharField:
        r"""
        Create a new field of this type.
        
        Args:
            required (bool, optional): Whether this field is required. Defaults to `True`.
            nullable (bool, optional): Whether this field allows `null`. Defaults to `False`.
            format (str, optional): Optional format override.
            many (bool, optional): Whether this field is a list of values.
            min_length (int, optional): Minimum length (for string types).
            max_length (int, optional): Maximum length (for string types).
            pattern (str, optional): Regular expression pattern.
            enum_values (list[str], optional): List of allowed values.
            read_only (bool, optional): If `True`, the field will be excluded when deserializing.
            write_only (bool, optional): If `True`, the field will be excluded when serializing.
        """

class DateField(Field):
    r"""
    Represents a date field (YYYY-MM-DD).
    """
    def __new__(cls, required: builtins.bool = True, nullable: builtins.bool = False, format: typing.Optional[builtins.str] = 'date', many: builtins.bool = False, length: typing.Optional[builtins.int] = None, min_length: typing.Optional[builtins.int] = None, max_length: typing.Optional[builtins.int] = None, pattern: typing.Optional[builtins.str] = None, enum_values: typing.Optional[typing.Sequence[builtins.str]] = None, read_only: builtins.bool = False, write_only: builtins.bool = False) -> DateField:
        r"""
        Create a new field of this type.
        
        Args:
            required (bool, optional): Whether this field is required. Defaults to `True`.
            nullable (bool, optional): Whether this field allows `null`. Defaults to `False`.
            format (str, optional): Optional format override.
            many (bool, optional): Whether this field is a list of values.
            min_length (int, optional): Minimum length (for string types).
            max_length (int, optional): Maximum length (for string types).
            pattern (str, optional): Regular expression pattern.
            enum_values (list[str], optional): List of allowed values.
            read_only (bool, optional): If `True`, the field will be excluded when deserializing.
            write_only (bool, optional): If `True`, the field will be excluded when serializing.
        """

class DateTimeField(Field):
    r"""
    Represents a date-time field (RFC 3339).
    """
    def __new__(cls, required: builtins.bool = True, nullable: builtins.bool = False, format: typing.Optional[builtins.str] = 'date-time', many: builtins.bool = False, length: typing.Optional[builtins.int] = None, min_length: typing.Optional[builtins.int] = None, max_length: typing.Optional[builtins.int] = None, pattern: typing.Optional[builtins.str] = None, enum_values: typing.Optional[typing.Sequence[builtins.str]] = None, read_only: builtins.bool = False, write_only: builtins.bool = False) -> DateTimeField:
        r"""
        Create a new field of this type.
        
        Args:
            required (bool, optional): Whether this field is required. Defaults to `True`.
            nullable (bool, optional): Whether this field allows `null`. Defaults to `False`.
            format (str, optional): Optional format override.
            many (bool, optional): Whether this field is a list of values.
            min_length (int, optional): Minimum length (for string types).
            max_length (int, optional): Maximum length (for string types).
            pattern (str, optional): Regular expression pattern.
            enum_values (list[str], optional): List of allowed values.
            read_only (bool, optional): If `True`, the field will be excluded when deserializing.
            write_only (bool, optional): If `True`, the field will be excluded when serializing.
        """

class EmailField(Field):
    r"""
    Represents an email field, validated by format.
    """
    def __new__(cls, required: builtins.bool = True, nullable: builtins.bool = False, format: typing.Optional[builtins.str] = 'email', many: builtins.bool = False, length: typing.Optional[builtins.int] = None, min_length: typing.Optional[builtins.int] = None, max_length: typing.Optional[builtins.int] = None, pattern: typing.Optional[builtins.str] = None, enum_values: typing.Optional[typing.Sequence[builtins.str]] = None, read_only: builtins.bool = False, write_only: builtins.bool = False) -> EmailField:
        r"""
        Create a new field of this type.
        
        Args:
            required (bool, optional): Whether this field is required. Defaults to `True`.
            nullable (bool, optional): Whether this field allows `null`. Defaults to `False`.
            format (str, optional): Optional format override.
            many (bool, optional): Whether this field is a list of values.
            min_length (int, optional): Minimum length (for string types).
            max_length (int, optional): Maximum length (for string types).
            pattern (str, optional): Regular expression pattern.
            enum_values (list[str], optional): List of allowed values.
            read_only (bool, optional): If `True`, the field will be excluded when deserializing.
            write_only (bool, optional): If `True`, the field will be excluded when serializing.
        """

class EnumField(Field):
    r"""
    Represents an enumerated string field.
    """
    def __new__(cls, required: builtins.bool = True, nullable: builtins.bool = False, format: typing.Optional[builtins.str] = None, many: builtins.bool = False, length: typing.Optional[builtins.int] = None, min_length: typing.Optional[builtins.int] = None, max_length: typing.Optional[builtins.int] = None, pattern: typing.Optional[builtins.str] = None, enum_values: typing.Optional[typing.Sequence[builtins.str]] = None, read_only: builtins.bool = False, write_only: builtins.bool = False) -> EnumField:
        r"""
        Create a new field of this type.
        
        Args:
            required (bool, optional): Whether this field is required. Defaults to `True`.
            nullable (bool, optional): Whether this field allows `null`. Defaults to `False`.
            format (str, optional): Optional format override.
            many (bool, optional): Whether this field is a list of values.
            min_length (int, optional): Minimum length (for string types).
            max_length (int, optional): Maximum length (for string types).
            pattern (str, optional): Regular expression pattern.
            enum_values (list[str], optional): List of allowed values.
            read_only (bool, optional): If `True`, the field will be excluded when deserializing.
            write_only (bool, optional): If `True`, the field will be excluded when serializing.
        """

class Field:
    r"""
    Base class representing a JSON schema field.
    """
    @property
    def required(self) -> builtins.bool: ...
    @required.setter
    def required(self, value: builtins.bool) -> None: ...
    @property
    def ty(self) -> builtins.str: ...
    @ty.setter
    def ty(self, value: builtins.str) -> None: ...
    @property
    def nullable(self) -> builtins.bool: ...
    @nullable.setter
    def nullable(self, value: builtins.bool) -> None: ...
    @property
    def format(self) -> typing.Optional[builtins.str]: ...
    @format.setter
    def format(self, value: typing.Optional[builtins.str]) -> None: ...
    @property
    def many(self) -> builtins.bool: ...
    @many.setter
    def many(self, value: builtins.bool) -> None: ...
    @property
    def length(self) -> typing.Optional[builtins.int]: ...
    @length.setter
    def length(self, value: typing.Optional[builtins.int]) -> None: ...
    @property
    def min_length(self) -> typing.Optional[builtins.int]: ...
    @min_length.setter
    def min_length(self, value: typing.Optional[builtins.int]) -> None: ...
    @property
    def max_length(self) -> typing.Optional[builtins.int]: ...
    @max_length.setter
    def max_length(self, value: typing.Optional[builtins.int]) -> None: ...
    @property
    def pattern(self) -> typing.Optional[builtins.str]: ...
    @pattern.setter
    def pattern(self, value: typing.Optional[builtins.str]) -> None: ...
    @property
    def enum_values(self) -> typing.Optional[builtins.list[builtins.str]]: ...
    @enum_values.setter
    def enum_values(self, value: typing.Optional[builtins.list[builtins.str]]) -> None: ...
    @property
    def read_only(self) -> builtins.bool: ...
    @read_only.setter
    def read_only(self, value: builtins.bool) -> None: ...
    @property
    def write_only(self) -> builtins.bool: ...
    @write_only.setter
    def write_only(self, value: builtins.bool) -> None: ...
    def __new__(cls, ty: builtins.str, required: builtins.bool = True, nullable: builtins.bool = False, format: typing.Optional[builtins.str] = None, many: builtins.bool = False, length: typing.Optional[builtins.int] = None, min_length: typing.Optional[builtins.int] = None, max_length: typing.Optional[builtins.int] = None, pattern: typing.Optional[builtins.str] = None, enum_values: typing.Optional[typing.Sequence[builtins.str]] = None, read_only: builtins.bool = False, write_only: builtins.bool = False) -> Field:
        r"""
        Create a new field definition.
        
        This is the base field class. You usually use one of the subclasses
        (`CharField`, `EmailField`, `IntegerField`, etc.) rather than instantiating
        this directly.
        
        Args:
            ty (str): Field type, e.g., `"string"`, `"integer"`, etc.
            required (bool, optional): Whether this field is required. Defaults to `True`.
            nullable (bool, optional): Whether this field allows `null`. Defaults to `False`.
            format (str, optional): Optional format (e.g., `"email"`, `"uuid"`).
            many (bool, optional): Whether this field is a list of values. Defaults to `False`.
            length (int, optional): Length for string fields.
            min_length (int, optional): Minimum length for string fields.
            max_length (int, optional): Maximum length for string fields.
            pattern (str, optional): Regular expression pattern for validation.
            enum_values (list[str], optional): List of allowed values.
            read_only (bool, optional): If `True`, the field will be excluded when deserializing. Defaults to `None`.
            write_only (bool, optional): If `True`, the field will be excluded when serializing. Defaults to `None`.
        
        Example:
        ```python
        field = Field("string", min_length=3, max_length=255)
        ```
        """

class IntegerField(Field):
    r"""
    Represents an integer field in JSON schema.
    """
    def __new__(cls, required: builtins.bool = True, nullable: builtins.bool = False, format: typing.Optional[builtins.str] = None, many: builtins.bool = False, length: typing.Optional[builtins.int] = None, min_length: typing.Optional[builtins.int] = None, max_length: typing.Optional[builtins.int] = None, pattern: typing.Optional[builtins.str] = None, enum_values: typing.Optional[typing.Sequence[builtins.str]] = None, read_only: builtins.bool = False, write_only: builtins.bool = False) -> IntegerField:
        r"""
        Create a new field of this type.
        
        Args:
            required (bool, optional): Whether this field is required. Defaults to `True`.
            nullable (bool, optional): Whether this field allows `null`. Defaults to `False`.
            format (str, optional): Optional format override.
            many (bool, optional): Whether this field is a list of values.
            min_length (int, optional): Minimum length (for string types).
            max_length (int, optional): Maximum length (for string types).
            pattern (str, optional): Regular expression pattern.
            enum_values (list[str], optional): List of allowed values.
            read_only (bool, optional): If `True`, the field will be excluded when deserializing.
            write_only (bool, optional): If `True`, the field will be excluded when serializing.
        """

class NumberField(Field):
    r"""
    Represents a numeric (float) field.
    """
    def __new__(cls, required: builtins.bool = True, nullable: builtins.bool = False, format: typing.Optional[builtins.str] = None, many: builtins.bool = False, length: typing.Optional[builtins.int] = None, min_length: typing.Optional[builtins.int] = None, max_length: typing.Optional[builtins.int] = None, pattern: typing.Optional[builtins.str] = None, enum_values: typing.Optional[typing.Sequence[builtins.str]] = None, read_only: builtins.bool = False, write_only: builtins.bool = False) -> NumberField:
        r"""
        Create a new field of this type.
        
        Args:
            required (bool, optional): Whether this field is required. Defaults to `True`.
            nullable (bool, optional): Whether this field allows `null`. Defaults to `False`.
            format (str, optional): Optional format override.
            many (bool, optional): Whether this field is a list of values.
            min_length (int, optional): Minimum length (for string types).
            max_length (int, optional): Maximum length (for string types).
            pattern (str, optional): Regular expression pattern.
            enum_values (list[str], optional): List of allowed values.
            read_only (bool, optional): If `True`, the field will be excluded when deserializing.
            write_only (bool, optional): If `True`, the field will be excluded when serializing.
        """

class Serializer(Field):
    @property
    def instance(self) -> typing.Optional[typing.Any]: ...
    @instance.setter
    def instance(self, value: typing.Optional[typing.Any]) -> None: ...
    @property
    def validated_data(self) -> dict: ...
    @validated_data.setter
    def validated_data(self, value: dict) -> None: ...
    @property
    def raw_data(self) -> typing.Optional[builtins.str]: ...
    @raw_data.setter
    def raw_data(self, value: typing.Optional[builtins.str]) -> None: ...
    @property
    def context(self) -> dict: ...
    @context.setter
    def context(self, value: dict) -> None: ...
    @property
    def data(self) -> typing.Any:
        r"""
        Return the serialized representation of the instance(s).
        
        If `many=True`, returns a list of serialized dicts.
        Otherwise, returns a single dict, or None if no instance.
        Fields marked as `write_only=True` will be excluded from the serialized output.
        
        Returns:
            dict or list[dict] or None: Serialized representation(s).
        
        Example:
        ```python
        from oxapy import serializer
        
        class MySerializer(serializer.Serializer):
            email = serializer.EmailField()
        
        class User:
            def __init__(self, email):
                self.email = email
        
        user = User("user@example.com")
        serializer = MySerializer(instance=user)
        print(serializer.data)
        ```
        """
    def __new__(cls, data: typing.Optional[builtins.str] = None, instance: typing.Optional[typing.Any] = None, required: builtins.bool = True, nullable: builtins.bool = False, many: builtins.bool = False, context: typing.Optional[dict] = None, read_only: builtins.bool = False, write_only: builtins.bool = False) -> Serializer:
        r"""
        Create a new `Serializer` instance.
        
        This constructor initializes the serializer with optional raw JSON data, an instance to serialize,
        and optional context.
        
        Args:
            data (str, optional): Raw JSON string to be validated or deserialized.
            instance (Any, optional): Python object instance to be serialized.
            required (bool, optional): Whether the field is required (default: True).
            nullable (bool, optional): Whether the field allows null values (default: False).
            many (bool, optional): Whether the serializer handles multiple objects (default: False).
            context (dict, optional): Additional context information.
            read_only (bool, optional): If `True`, the serializer will be excluded when deserializing (default: False).
            write_only (bool, optional): If `True`, the serializer will be excluded when serializing (default: False).
        
        Returns:
            Serializer: The new serializer instance.
        
        Example:
        ```python
        from oxapy import serializer
        
        class MySerializer(serializer.Serializer):
            email = serializer.EmailField()
            password = serializer.CharField(write_only=True)
        
        serializer = MySerializer(
            data='{"email": "user@example.com", "password": "secret123"}'
        )
        ```
        """
    def schema(self) -> dict:
        r"""
        Generate and return the JSON Schema for this serializer.
        
        The schema is built dynamically based on the serializer class definition and its fields.
        
        Returns:
            dict: The JSON Schema as a Python dictionary.
        
        Example:
        ```python
        from oxapy import serializer
        
        class MySerializer(serializer.Serializer):
            email = serializer.EmailField()
        
        serializer = MySerializer()
        schema = serializer.schema()
        print(schema)
        ```
        """
    def is_valid(self) -> None:
        r"""
        Validate the raw JSON data and store the result in `validated_data`.
        
        Parses the `raw_data` JSON string, validates it, and saves the result as `validated_data`.
        
        Raises:
            ValidationException: If `raw_data` is missing or invalid.
        
        Example:
        ```python
        from oxapy import serializer
        
        class MySerializer(serializer.Serializer):
            email = serializer.EmailField()
        
        serializer = MySerializer(data='{"email": "user@example.com"}')
        serializer.is_valid()
        print(serializer.validated_data["email"])
        ```
        """
    def validate(self, attr: dict) -> dict:
        r"""
        Validate a Python dictionary against the serializer's schema.
        
        Args:
            attr (dict): The data to validate.
        
        Returns:
            dict: The validated data, with any `read_only` fields removed.
        
        Raises:
            ValidationException: If validation fails.
        
        Example:
        ```python
        from oxapy import serializer
        
        class MySerializer(serializer.Serializer):
            email = serializer.EmailField()
        
        serializer = MySerializer()
        serializer.validate({"email": "user@example.com"})
        ```
        """
    def create(self, session: typing.Any, validated_data: dict) -> typing.Any:
        r"""
        Create and persist a new model instance with validated data.
        
        Args:
            session (Any): The database session.
            validated_data (dict): The validated data.
        
        Returns:
            Any: The created instance.
        
        Example:
        ```python
        from oxapy import serializer
        
        class MySerializer(serializer.Serializer):
            email = serializer.EmailField()
        
        serializer = MySerializer(data='{"email": "user@example.com"}')
        serializer.is_valid()
        # Assuming `session` is a database session
        instance = serializer.create(session, serializer.validated_data)
        ```
        """
    def save(self, session: typing.Any) -> typing.Any:
        r"""
        Save validated data by creating a new instance and persisting it.
        
        Calls `is_valid()` first to populate `validated_data` before calling `create()`.
        
        Args:
            session (Any): The database session.
        
        Returns:
            Any: The created instance.
        
        Raises:
            Exception: If `is_valid()` was not called first.
        
        Example:
        ```python
        from oxapy import serializer
        
        class MySerializer(serializer.Serializer):
            email = serializer.EmailField()
        
        serializer = MySerializer(data='{"email": "user@example.com"}')
        serializer.is_valid()
        # Assuming `session` is a database session
        instance = serializer.save(session)
        ```
        """
    def update(self, session: typing.Any, instance: typing.Any, validated_data: typing.Mapping[builtins.str, typing.Any]) -> typing.Any:
        r"""
        Update an existing instance with validated data.
        
        Args:
            session (Any): The database session.
            instance (Any): The instance to update.
            validated_data (dict): Field names and new values.
        
        Returns:
            Any: The updated instance.
        
        Example:
        ```python
        from oxapy import serializer
        
        class MySerializer(serializer.Serializer):
            email = serializer.EmailField()
        
        # Assuming `session` and `instance` are available
        serializer = MySerializer()
        updated = serializer.update(session, instance, {"email": "new@email.com"})
        ```
        """
    def to_representation(self, instance: typing.Any) -> dict:
        r"""
        Convert a model instance to a Python dictionary.
        
        Processes each field in the model, excluding those marked as `write_only=True`.
        
        Args:
            instance: The model instance to serialize.
        
        Returns:
            dict: Dictionary representation of the instance.
        """

class UUIDField(Field):
    r"""
    Represents a UUID field.
    """
    def __new__(cls, required: builtins.bool = True, nullable: builtins.bool = False, format: typing.Optional[builtins.str] = 'uuid', many: builtins.bool = False, length: typing.Optional[builtins.int] = None, min_length: typing.Optional[builtins.int] = None, max_length: typing.Optional[builtins.int] = None, pattern: typing.Optional[builtins.str] = None, enum_values: typing.Optional[typing.Sequence[builtins.str]] = None, read_only: builtins.bool = False, write_only: builtins.bool = False) -> UUIDField:
        r"""
        Create a new field of this type.
        
        Args:
            required (bool, optional): Whether this field is required. Defaults to `True`.
            nullable (bool, optional): Whether this field allows `null`. Defaults to `False`.
            format (str, optional): Optional format override.
            many (bool, optional): Whether this field is a list of values.
            min_length (int, optional): Minimum length (for string types).
            max_length (int, optional): Maximum length (for string types).
            pattern (str, optional): Regular expression pattern.
            enum_values (list[str], optional): List of allowed values.
            read_only (bool, optional): If `True`, the field will be excluded when deserializing.
            write_only (bool, optional): If `True`, the field will be excluded when serializing.
        """

@typing.final
class ValidationException(ClientError):
    r"""
    Serializer validation exception.
    
    Raised when data validation fails during serialization or deserialization.
    This includes missing required fields, invalid field values, type mismatches,
    and schema constraint violations.
    """
    def __new__(cls, e: typing.Any) -> ValidationException: ...

