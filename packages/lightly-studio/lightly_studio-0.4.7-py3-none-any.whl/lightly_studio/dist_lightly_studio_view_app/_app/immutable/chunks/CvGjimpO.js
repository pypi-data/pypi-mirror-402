var _=Object.defineProperty;var E=(s,t,e)=>t in s?_(s,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):s[t]=e;var w=(s,t,e)=>E(s,typeof t!="symbol"?t+"":t,e);const T={bodySerializer:s=>JSON.stringify(s,(t,e)=>typeof e=="bigint"?e.toString():e)},U=async(s,t)=>{const e=typeof t=="function"?await t(s):t;if(e)return s.scheme==="bearer"?`Bearer ${e}`:s.scheme==="basic"?`Basic ${btoa(e)}`:e},P=s=>{switch(s){case"label":return".";case"matrix":return";";case"simple":return",";default:return"&"}},W=s=>{switch(s){case"form":return",";case"pipeDelimited":return"|";case"spaceDelimited":return"%20";default:return","}},k=s=>{switch(s){case"label":return".";case"matrix":return";";case"simple":return",";default:return"&"}},z=({allowReserved:s,explode:t,name:e,style:a,value:o})=>{if(!t){const r=(s?o:o.map(c=>encodeURIComponent(c))).join(W(a));switch(a){case"label":return`.${r}`;case"matrix":return`;${e}=${r}`;case"simple":return r;default:return`${e}=${r}`}}const i=P(a),n=o.map(r=>a==="label"||a==="simple"?s?r:encodeURIComponent(r):y({allowReserved:s,name:e,value:r})).join(i);return a==="label"||a==="matrix"?i+n:n},y=({allowReserved:s,name:t,value:e})=>{if(e==null)return"";if(typeof e=="object")throw new Error("Deeply-nested arrays/objects arenâ€™t supported. Provide your own `querySerializer()` to handle these.");return`${t}=${s?e:encodeURIComponent(e)}`},O=({allowReserved:s,explode:t,name:e,style:a,value:o,valueOnly:i})=>{if(o instanceof Date)return i?o.toISOString():`${e}=${o.toISOString()}`;if(a!=="deepObject"&&!t){let c=[];Object.entries(o).forEach(([d,b])=>{c=[...c,d,s?b:encodeURIComponent(b)]});const l=c.join(",");switch(a){case"form":return`${e}=${l}`;case"label":return`.${l}`;case"matrix":return`;${e}=${l}`;default:return l}}const n=k(a),r=Object.entries(o).map(([c,l])=>y({allowReserved:s,name:a==="deepObject"?`${e}[${c}]`:c,value:l})).join(n);return a==="label"||a==="matrix"?n+r:r},V=/\{[^{}]+\}/g,D=({path:s,url:t})=>{let e=t;const a=t.match(V);if(a)for(const o of a){let i=!1,n=o.substring(1,o.length-1),r="simple";n.endsWith("*")&&(i=!0,n=n.substring(0,n.length-1)),n.startsWith(".")?(n=n.substring(1),r="label"):n.startsWith(";")&&(n=n.substring(1),r="matrix");const c=s[n];if(c==null)continue;if(Array.isArray(c)){e=e.replace(o,z({explode:i,name:n,style:r,value:c}));continue}if(typeof c=="object"){e=e.replace(o,O({explode:i,name:n,style:r,value:c,valueOnly:!0}));continue}if(r==="matrix"){e=e.replace(o,`;${y({name:n,value:c})}`);continue}const l=encodeURIComponent(r==="label"?`.${c}`:c);e=e.replace(o,l)}return e},C=({allowReserved:s,array:t,object:e}={})=>o=>{const i=[];if(o&&typeof o=="object")for(const n in o){const r=o[n];if(r!=null)if(Array.isArray(r)){const c=z({allowReserved:s,explode:!0,name:n,style:"form",value:r,...t});c&&i.push(c)}else if(typeof r=="object"){const c=O({allowReserved:s,explode:!0,name:n,style:"deepObject",value:r,...e});c&&i.push(c)}else{const c=y({allowReserved:s,name:n,value:r});c&&i.push(c)}}return i.join("&")},H=s=>{var e;if(!s)return"stream";const t=(e=s.split(";")[0])==null?void 0:e.trim();if(t){if(t.startsWith("application/json")||t.endsWith("+json"))return"json";if(t==="multipart/form-data")return"formData";if(["application/","audio/","image/","video/"].some(a=>t.startsWith(a)))return"blob";if(t.startsWith("text/"))return"text"}},N=async({security:s,...t})=>{for(const e of s){const a=await U(e,t.auth);if(!a)continue;const o=e.name??"Authorization";switch(e.in){case"query":t.query||(t.query={}),t.query[o]=a;break;case"cookie":t.headers.append("Cookie",`${o}=${a}`);break;case"header":default:t.headers.set(o,a);break}return}},A=s=>R({baseUrl:s.baseUrl,path:s.path,query:s.query,querySerializer:typeof s.querySerializer=="function"?s.querySerializer:C(s.querySerializer),url:s.url}),R=({baseUrl:s,path:t,query:e,querySerializer:a,url:o})=>{const i=o.startsWith("/")?o:`/${o}`;let n=(s??"")+i;t&&(n=D({path:t,url:n}));let r=e?a(e):"";return r.startsWith("?")&&(r=r.substring(1)),r&&(n+=`?${r}`),n},$=(s,t)=>{var a;const e={...s,...t};return(a=e.baseUrl)!=null&&a.endsWith("/")&&(e.baseUrl=e.baseUrl.substring(0,e.baseUrl.length-1)),e.headers=q(s.headers,t.headers),e},q=(...s)=>{const t=new Headers;for(const e of s){if(!e||typeof e!="object")continue;const a=e instanceof Headers?e.entries():Object.entries(e);for(const[o,i]of a)if(i===null)t.delete(o);else if(Array.isArray(i))for(const n of i)t.append(o,n);else i!==void 0&&t.set(o,typeof i=="object"?JSON.stringify(i):i)}return t};class g{constructor(){w(this,"_fns");this._fns=[]}clear(){this._fns=[]}getInterceptorIndex(t){return typeof t=="number"?this._fns[t]?t:-1:this._fns.indexOf(t)}exists(t){const e=this.getInterceptorIndex(t);return!!this._fns[e]}eject(t){const e=this.getInterceptorIndex(t);this._fns[e]&&(this._fns[e]=null)}update(t,e){const a=this.getInterceptorIndex(t);return this._fns[a]?(this._fns[a]=e,t):!1}use(t){return this._fns=[...this._fns,t],this._fns.length-1}}const B=()=>({error:new g,request:new g,response:new g}),J=C({allowReserved:!1,array:{explode:!0,style:"form"},object:{explode:!0,style:"deepObject"}}),L={"Content-Type":"application/json"},I=(s={})=>({...T,headers:L,parseAs:"auto",querySerializer:J,...s}),Q=(s={})=>{let t=$(I(),s);const e=()=>({...t}),a=n=>(t=$(t,n),e()),o=B(),i=async n=>{const r={...t,...n,fetch:n.fetch??t.fetch??globalThis.fetch,headers:q(t.headers,n.headers)};r.security&&await N({...r,security:r.security}),r.requestValidator&&await r.requestValidator(r),r.body&&r.bodySerializer&&(r.body=r.bodySerializer(r.body)),(r.body===void 0||r.body==="")&&r.headers.delete("Content-Type");const c=A(r),l={redirect:"follow",...r};let d=new Request(c,l);for(const u of o.request._fns)u&&(d=await u(d,r));const b=r.fetch;let f=await b(d);for(const u of o.response._fns)u&&(f=await u(f,d,r));const m={request:d,response:f};if(f.ok){if(f.status===204||f.headers.get("Content-Length")==="0")return r.responseStyle==="data"?{}:{data:{},...m};const u=(r.parseAs==="auto"?H(f.headers.get("Content-Type")):r.parseAs)??"json";let h;switch(u){case"arrayBuffer":case"blob":case"formData":case"json":case"text":h=await f[u]();break;case"stream":return r.responseStyle==="data"?f.body:{data:f.body,...m}}return u==="json"&&(r.responseValidator&&await r.responseValidator(h),r.responseTransformer&&(h=await r.responseTransformer(h))),r.responseStyle==="data"?h:{data:h,...m}}const j=await f.text();let x;try{x=JSON.parse(j)}catch{}const S=x??j;let p=S;for(const u of o.error._fns)u&&(p=await u(S,f,d,r));if(p=p||{},r.throwOnError)throw p;return r.responseStyle==="data"?void 0:{error:p,...m}};return{buildUrl:A,connect:n=>i({...n,method:"CONNECT"}),delete:n=>i({...n,method:"DELETE"}),get:n=>i({...n,method:"GET"}),getConfig:e,head:n=>i({...n,method:"HEAD"}),interceptors:o,options:n=>i({...n,method:"OPTIONS"}),patch:n=>i({...n,method:"PATCH"}),post:n=>i({...n,method:"POST"}),put:n=>i({...n,method:"PUT"}),request:i,setConfig:a,trace:n=>i({...n,method:"TRACE"})}},M=Q(I());export{M as c};
