# This file was auto-generated by Fern from our API Definition.

import typing

from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.request_options import RequestOptions
from .raw_client import AsyncRawConstrueClient, RawConstrueClient
from .types.construe_upload_code_system_response import ConstrueUploadCodeSystemResponse
from .types.extract_codes_result import ExtractCodesResult
from .types.extract_request_config import ExtractRequestConfig
from .types.extract_request_system import ExtractRequestSystem
from .types.get_code_response import GetCodeResponse
from .types.list_code_systems_response import ListCodeSystemsResponse
from .types.list_codes_response import ListCodesResponse
from .types.semantic_search_response import SemanticSearchResponse
from .types.text_search_response import TextSearchResponse
from .types.upload_request_format import UploadRequestFormat

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class ConstrueClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._raw_client = RawConstrueClient(client_wrapper=client_wrapper)

    @property
    def with_raw_response(self) -> RawConstrueClient:
        """
        Retrieves a raw implementation of this client that returns raw responses.

        Returns
        -------
        RawConstrueClient
        """
        return self._raw_client

    def upload_code_system(
        self,
        *,
        name: str,
        version: str,
        format: UploadRequestFormat,
        file: str,
        revision: typing.Optional[float] = OMIT,
        code_col: typing.Optional[str] = OMIT,
        desc_col: typing.Optional[str] = OMIT,
        defn_col: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ConstrueUploadCodeSystemResponse:
        """
        Upload a custom medical code system with codes and descriptions for use in code extraction.
        Upon upload, construe generates embeddings for all of the codes in the code system and stores them in the vector database so you can
        subsequently use the code system for construe/extract and lang2fhir/create (coming soon!)

        Parameters
        ----------
        name : str
            Name of the code system

        version : str
            Version of the code system

        format : UploadRequestFormat
            Format of the uploaded file

        file : str
            The file contents as a base64-encoded string

        revision : typing.Optional[float]
            Optional revision number

        code_col : typing.Optional[str]
            Column name containing codes (required for CSV format)

        desc_col : typing.Optional[str]
            Column name containing descriptions (required for CSV format)

        defn_col : typing.Optional[str]
            Optional column name containing long definitions (for CSV format)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ConstrueUploadCodeSystemResponse
            Successfully uploaded code system

        Examples
        --------
        from phenoml import phenoml

        client = phenoml(
            token="YOUR_TOKEN",
        )
        client.construe.upload_code_system(
            name="CUSTOM_CODES",
            version="1.0",
            format="json",
            file="file",
        )
        """
        _response = self._raw_client.upload_code_system(
            name=name,
            version=version,
            format=format,
            file=file,
            revision=revision,
            code_col=code_col,
            desc_col=desc_col,
            defn_col=defn_col,
            request_options=request_options,
        )
        return _response.data

    def extract_codes(
        self,
        *,
        text: str,
        system: typing.Optional[ExtractRequestSystem] = OMIT,
        config: typing.Optional[ExtractRequestConfig] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ExtractCodesResult:
        """
        Converts natural language text into structured medical codes

        Parameters
        ----------
        text : str
            Natural language text to extract codes from

        system : typing.Optional[ExtractRequestSystem]

        config : typing.Optional[ExtractRequestConfig]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ExtractCodesResult
            Successfully extracted codes

        Examples
        --------
        from phenoml import phenoml

        client = phenoml(
            token="YOUR_TOKEN",
        )
        client.construe.extract_codes(
            text="Patient is a 14-year-old female, previously healthy, who is here for evaluation of abnormal renal ultrasound with atrophic right kidney",
        )
        """
        _response = self._raw_client.extract_codes(
            text=text, system=system, config=config, request_options=request_options
        )
        return _response.data

    def list_available_code_systems(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> ListCodeSystemsResponse:
        """
        Returns metadata about all available code systems including built-in and custom systems.

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ListCodeSystemsResponse
            List of available code systems

        Examples
        --------
        from phenoml import phenoml

        client = phenoml(
            token="YOUR_TOKEN",
        )
        client.construe.list_available_code_systems()
        """
        _response = self._raw_client.list_available_code_systems(request_options=request_options)
        return _response.data

    def list_codes_in_a_code_system(
        self,
        codesystem: str,
        *,
        version: typing.Optional[str] = None,
        cursor: typing.Optional[str] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ListCodesResponse:
        """
        Returns a paginated list of all codes in the specified code system.

        Parameters
        ----------
        codesystem : str
            Code system name (e.g., "ICD-10-CM", "SNOMED_CT_US_LITE")

        version : typing.Optional[str]
            Specific version of the code system. Required if multiple versions exist.

        cursor : typing.Optional[str]
            Pagination cursor from previous response

        limit : typing.Optional[int]
            Maximum number of codes to return (default 20)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ListCodesResponse
            Paginated list of codes

        Examples
        --------
        from phenoml import phenoml

        client = phenoml(
            token="YOUR_TOKEN",
        )
        client.construe.list_codes_in_a_code_system(
            codesystem="ICD-10-CM",
            version="2025",
            cursor="cursor",
            limit=1,
        )
        """
        _response = self._raw_client.list_codes_in_a_code_system(
            codesystem, version=version, cursor=cursor, limit=limit, request_options=request_options
        )
        return _response.data

    def get_a_specific_code(
        self,
        codesystem: str,
        code_id: str,
        *,
        version: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GetCodeResponse:
        """
        Returns details for a specific code within a code system.

        Parameters
        ----------
        codesystem : str
            Code system name

        code_id : str
            The code identifier

        version : typing.Optional[str]
            Specific version of the code system

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GetCodeResponse
            Code details

        Examples
        --------
        from phenoml import phenoml

        client = phenoml(
            token="YOUR_TOKEN",
        )
        client.construe.get_a_specific_code(
            codesystem="ICD-10-CM",
            code_id="E11.65",
            version="version",
        )
        """
        _response = self._raw_client.get_a_specific_code(
            codesystem, code_id, version=version, request_options=request_options
        )
        return _response.data

    def semantic_search_embedding_based(
        self,
        codesystem: str,
        *,
        text: str,
        version: typing.Optional[str] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SemanticSearchResponse:
        """
        Performs semantic similarity search using vector embeddings.

        **When to use**: Best for natural language queries where you want to find conceptually
        related codes, even when different terminology is used. The search understands meaning,
        not just keywords.

        **Examples**:
        - Query "trouble breathing at night" finds codes like "Sleep apnea", "Orthopnea",
          "Nocturnal dyspnea" — semantically related but no exact keyword matches
        - Query "heart problems" finds "Myocardial infarction", "Cardiac arrest", "Arrhythmia"

        **Trade-offs**: Slower than text search (requires embedding generation), but finds
        conceptually similar results that keyword search would miss.

        See also: `/search/text` for faster keyword-based lookup with typo tolerance.

        Parameters
        ----------
        codesystem : str
            Code system name

        text : str
            Natural language text to find semantically similar codes for

        version : typing.Optional[str]
            Specific version of the code system

        limit : typing.Optional[int]
            Maximum number of results (default 10, max 50)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SemanticSearchResponse
            Semantic search results ordered by similarity

        Examples
        --------
        from phenoml import phenoml

        client = phenoml(
            token="YOUR_TOKEN",
        )
        client.construe.semantic_search_embedding_based(
            codesystem="ICD-10-CM",
            text="patient has trouble breathing at night and wakes up gasping",
            version="version",
            limit=1,
        )
        """
        _response = self._raw_client.semantic_search_embedding_based(
            codesystem, text=text, version=version, limit=limit, request_options=request_options
        )
        return _response.data

    def text_search_keyword_based(
        self,
        codesystem: str,
        *,
        q: str,
        version: typing.Optional[str] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> TextSearchResponse:
        """
        Performs fast full-text search over code IDs and descriptions.

        **When to use**: Best for autocomplete UIs, code lookup, or when users know part of
        the code ID or specific keywords. Fast response times suitable for typeahead interfaces.

        **Features**:
        - Substring matching on code IDs (e.g., "11.65" finds "E11.65")
        - Typo tolerance on descriptions (not on code IDs)
        - Fast response times (~10-50ms)

        **Examples**:
        - Query "E11" finds all codes starting with E11 (diabetes codes)
        - Query "diabtes" (typo) still finds "diabetes" codes

        **Trade-offs**: Faster than semantic search, but only matches keywords/substrings.
        Won't find conceptually related codes with different terminology.

        See also: `/search/semantic` for finding conceptually similar codes.

        Parameters
        ----------
        codesystem : str
            Code system name

        q : str
            Search query (searches code IDs and descriptions)

        version : typing.Optional[str]
            Specific version of the code system

        limit : typing.Optional[int]
            Maximum number of results (default 20, max 100)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        TextSearchResponse
            Text search results

        Examples
        --------
        from phenoml import phenoml

        client = phenoml(
            token="YOUR_TOKEN",
        )
        client.construe.text_search_keyword_based(
            codesystem="ICD-10-CM",
            q="E11.65",
            version="version",
            limit=1,
        )
        """
        _response = self._raw_client.text_search_keyword_based(
            codesystem, q=q, version=version, limit=limit, request_options=request_options
        )
        return _response.data


class AsyncConstrueClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._raw_client = AsyncRawConstrueClient(client_wrapper=client_wrapper)

    @property
    def with_raw_response(self) -> AsyncRawConstrueClient:
        """
        Retrieves a raw implementation of this client that returns raw responses.

        Returns
        -------
        AsyncRawConstrueClient
        """
        return self._raw_client

    async def upload_code_system(
        self,
        *,
        name: str,
        version: str,
        format: UploadRequestFormat,
        file: str,
        revision: typing.Optional[float] = OMIT,
        code_col: typing.Optional[str] = OMIT,
        desc_col: typing.Optional[str] = OMIT,
        defn_col: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ConstrueUploadCodeSystemResponse:
        """
        Upload a custom medical code system with codes and descriptions for use in code extraction.
        Upon upload, construe generates embeddings for all of the codes in the code system and stores them in the vector database so you can
        subsequently use the code system for construe/extract and lang2fhir/create (coming soon!)

        Parameters
        ----------
        name : str
            Name of the code system

        version : str
            Version of the code system

        format : UploadRequestFormat
            Format of the uploaded file

        file : str
            The file contents as a base64-encoded string

        revision : typing.Optional[float]
            Optional revision number

        code_col : typing.Optional[str]
            Column name containing codes (required for CSV format)

        desc_col : typing.Optional[str]
            Column name containing descriptions (required for CSV format)

        defn_col : typing.Optional[str]
            Optional column name containing long definitions (for CSV format)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ConstrueUploadCodeSystemResponse
            Successfully uploaded code system

        Examples
        --------
        import asyncio

        from phenoml import Asyncphenoml

        client = Asyncphenoml(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.construe.upload_code_system(
                name="CUSTOM_CODES",
                version="1.0",
                format="json",
                file="file",
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.upload_code_system(
            name=name,
            version=version,
            format=format,
            file=file,
            revision=revision,
            code_col=code_col,
            desc_col=desc_col,
            defn_col=defn_col,
            request_options=request_options,
        )
        return _response.data

    async def extract_codes(
        self,
        *,
        text: str,
        system: typing.Optional[ExtractRequestSystem] = OMIT,
        config: typing.Optional[ExtractRequestConfig] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ExtractCodesResult:
        """
        Converts natural language text into structured medical codes

        Parameters
        ----------
        text : str
            Natural language text to extract codes from

        system : typing.Optional[ExtractRequestSystem]

        config : typing.Optional[ExtractRequestConfig]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ExtractCodesResult
            Successfully extracted codes

        Examples
        --------
        import asyncio

        from phenoml import Asyncphenoml

        client = Asyncphenoml(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.construe.extract_codes(
                text="Patient is a 14-year-old female, previously healthy, who is here for evaluation of abnormal renal ultrasound with atrophic right kidney",
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.extract_codes(
            text=text, system=system, config=config, request_options=request_options
        )
        return _response.data

    async def list_available_code_systems(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> ListCodeSystemsResponse:
        """
        Returns metadata about all available code systems including built-in and custom systems.

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ListCodeSystemsResponse
            List of available code systems

        Examples
        --------
        import asyncio

        from phenoml import Asyncphenoml

        client = Asyncphenoml(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.construe.list_available_code_systems()


        asyncio.run(main())
        """
        _response = await self._raw_client.list_available_code_systems(request_options=request_options)
        return _response.data

    async def list_codes_in_a_code_system(
        self,
        codesystem: str,
        *,
        version: typing.Optional[str] = None,
        cursor: typing.Optional[str] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ListCodesResponse:
        """
        Returns a paginated list of all codes in the specified code system.

        Parameters
        ----------
        codesystem : str
            Code system name (e.g., "ICD-10-CM", "SNOMED_CT_US_LITE")

        version : typing.Optional[str]
            Specific version of the code system. Required if multiple versions exist.

        cursor : typing.Optional[str]
            Pagination cursor from previous response

        limit : typing.Optional[int]
            Maximum number of codes to return (default 20)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ListCodesResponse
            Paginated list of codes

        Examples
        --------
        import asyncio

        from phenoml import Asyncphenoml

        client = Asyncphenoml(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.construe.list_codes_in_a_code_system(
                codesystem="ICD-10-CM",
                version="2025",
                cursor="cursor",
                limit=1,
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.list_codes_in_a_code_system(
            codesystem, version=version, cursor=cursor, limit=limit, request_options=request_options
        )
        return _response.data

    async def get_a_specific_code(
        self,
        codesystem: str,
        code_id: str,
        *,
        version: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GetCodeResponse:
        """
        Returns details for a specific code within a code system.

        Parameters
        ----------
        codesystem : str
            Code system name

        code_id : str
            The code identifier

        version : typing.Optional[str]
            Specific version of the code system

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GetCodeResponse
            Code details

        Examples
        --------
        import asyncio

        from phenoml import Asyncphenoml

        client = Asyncphenoml(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.construe.get_a_specific_code(
                codesystem="ICD-10-CM",
                code_id="E11.65",
                version="version",
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.get_a_specific_code(
            codesystem, code_id, version=version, request_options=request_options
        )
        return _response.data

    async def semantic_search_embedding_based(
        self,
        codesystem: str,
        *,
        text: str,
        version: typing.Optional[str] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SemanticSearchResponse:
        """
        Performs semantic similarity search using vector embeddings.

        **When to use**: Best for natural language queries where you want to find conceptually
        related codes, even when different terminology is used. The search understands meaning,
        not just keywords.

        **Examples**:
        - Query "trouble breathing at night" finds codes like "Sleep apnea", "Orthopnea",
          "Nocturnal dyspnea" — semantically related but no exact keyword matches
        - Query "heart problems" finds "Myocardial infarction", "Cardiac arrest", "Arrhythmia"

        **Trade-offs**: Slower than text search (requires embedding generation), but finds
        conceptually similar results that keyword search would miss.

        See also: `/search/text` for faster keyword-based lookup with typo tolerance.

        Parameters
        ----------
        codesystem : str
            Code system name

        text : str
            Natural language text to find semantically similar codes for

        version : typing.Optional[str]
            Specific version of the code system

        limit : typing.Optional[int]
            Maximum number of results (default 10, max 50)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SemanticSearchResponse
            Semantic search results ordered by similarity

        Examples
        --------
        import asyncio

        from phenoml import Asyncphenoml

        client = Asyncphenoml(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.construe.semantic_search_embedding_based(
                codesystem="ICD-10-CM",
                text="patient has trouble breathing at night and wakes up gasping",
                version="version",
                limit=1,
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.semantic_search_embedding_based(
            codesystem, text=text, version=version, limit=limit, request_options=request_options
        )
        return _response.data

    async def text_search_keyword_based(
        self,
        codesystem: str,
        *,
        q: str,
        version: typing.Optional[str] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> TextSearchResponse:
        """
        Performs fast full-text search over code IDs and descriptions.

        **When to use**: Best for autocomplete UIs, code lookup, or when users know part of
        the code ID or specific keywords. Fast response times suitable for typeahead interfaces.

        **Features**:
        - Substring matching on code IDs (e.g., "11.65" finds "E11.65")
        - Typo tolerance on descriptions (not on code IDs)
        - Fast response times (~10-50ms)

        **Examples**:
        - Query "E11" finds all codes starting with E11 (diabetes codes)
        - Query "diabtes" (typo) still finds "diabetes" codes

        **Trade-offs**: Faster than semantic search, but only matches keywords/substrings.
        Won't find conceptually related codes with different terminology.

        See also: `/search/semantic` for finding conceptually similar codes.

        Parameters
        ----------
        codesystem : str
            Code system name

        q : str
            Search query (searches code IDs and descriptions)

        version : typing.Optional[str]
            Specific version of the code system

        limit : typing.Optional[int]
            Maximum number of results (default 20, max 100)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        TextSearchResponse
            Text search results

        Examples
        --------
        import asyncio

        from phenoml import Asyncphenoml

        client = Asyncphenoml(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.construe.text_search_keyword_based(
                codesystem="ICD-10-CM",
                q="E11.65",
                version="version",
                limit=1,
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.text_search_keyword_based(
            codesystem, q=q, version=version, limit=limit, request_options=request_options
        )
        return _response.data
