"""
Schema definitions for dbt project files and artifacts.
"""
import typing as t
from dataclasses import dataclass


@dataclass
class DbtProjectConfig:
    """
    Represents the relevant fields from dbt_project.yml.
    """
    name: str
    model_paths: list[str]
    target_path: str = "target"

    @classmethod
    def from_dict(cls, data: dict) -> "DbtProjectConfig":
        """Parse dbt_project.yml dictionary into DbtProjectConfig."""
        return cls(
            name=data["name"],
            model_paths=data.get("model-paths", ["models"]),
            target_path=data.get("target-path", "target"),
        )


@dataclass
class DbtColumn:
    """Represents a column in a dbt model or source."""
    name: str
    data_type: t.Optional[str] = None
    description: t.Optional[str] = None


@dataclass
class DbtNode:
    """
    Represents a node from manifest.json (model, source, etc.).

    We only include the fields we need for unit testing.
    """
    name: str
    unique_id: str
    resource_type: str  # "model", "source", "seed", etc.
    database: t.Optional[str] = None
    schema_: t.Optional[str] = None  # schema is a reserved word
    columns: dict[str, DbtColumn] = None
    compiled_sql: t.Optional[str] = None
    depends_on: list[str] = None

    @classmethod
    def from_dict(cls, unique_id: str, data: dict) -> "DbtNode":
        """Parse a node from manifest.json."""
        columns = {}
        if "columns" in data:
            for col_name, col_data in data["columns"].items():
                columns[col_name] = DbtColumn(
                    name=col_name,
                    data_type=col_data.get("data_type"),
                    description=col_data.get("description"),
                )

        return cls(
            name=data.get("name", ""),
            unique_id=unique_id,
            resource_type=data.get("resource_type", ""),
            database=data.get("database"),
            schema_=data.get("schema"),
            columns=columns or {},
            compiled_sql=data.get("compiled_sql") or data.get("compiled_code"),
            depends_on=data.get("depends_on", {}).get("nodes", []),
        )


@dataclass
class DbtManifest:
    """
    Represents the manifest.json file generated by dbt.

    Contains metadata about all nodes in the dbt project.
    """
    nodes: dict[str, DbtNode]

    @classmethod
    def from_dict(cls, data: dict) -> "DbtManifest":
        """Parse manifest.json dictionary into DbtManifest."""
        nodes = {}
        for unique_id, node_data in data.get("nodes", {}).items():
            nodes[unique_id] = DbtNode.from_dict(unique_id, node_data)

        # Also include sources from the sources section
        for unique_id, source_data in data.get("sources", {}).items():
            nodes[unique_id] = DbtNode.from_dict(unique_id, source_data)

        return cls(nodes=nodes)

    def get_node_by_name(self, name: str) -> t.Optional[DbtNode]:
        """Find a node by its name (not unique_id)."""
        for node in self.nodes.values():
            if node.name == name:
                return node
        return None
