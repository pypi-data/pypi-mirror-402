# Implementation Plan: Chrony Tracking Binding

**Branch**: `002-tracking-binding` | **Date**: 2026-01-15 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/002-tracking-binding/spec.md`

**Note**: This template is filled in by the `/speckit.plan` command. See `.specify/templates/commands/plan.md` for the execution workflow.

## Summary

Enable Python applications to monitor chrony time synchronization status by implementing CFFI bindings to libchrony's high-level introspection API. The binding uses `chrony_get_field_*` functions to retrieve tracking data as native C types, avoiding manual wire-format conversions. Data is exposed as a typed Python dataclass with read-only access to chronyd tracking metrics including offset, frequency, stratum, and reference source information.

## Technical Context

**Language/Version**: Python 3.10+ (supports 3.10, 3.11, 3.12, 3.13, 3.14)
**Primary Dependencies**: CFFI (for libchrony binding via API mode), libchrony (system library), libchrony-devel (build-time headers)
**Storage**: N/A (read-only monitoring, no persistence)
**Testing**: pytest with pytest-cov; unit tests run anywhere; integration tests via Docker (Linux container with libchrony + chronyd)
**Target Platform**: Linux (primary), other platforms where libchrony available
**Project Type**: Single library package
**Performance Goals**: Instant retrieval when chronyd running (sub-millisecond local socket call)
**Constraints**: Read-only access only; no control capabilities; requires libchrony installed
**Scale/Scope**: Single-user library; monitoring use case (dashboards, observability)

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

### pychrony Constitution Gates

**MUST PASS:**
- ✅ API scope limited to libchrony read-only capabilities (tracking data only, no control)
- ✅ Implementation uses CFFI binding to system libchrony (no vendoring)
- ✅ Uses libchrony's high-level introspection API (chrony_get_field_* functions)
- ✅ Full type hints and Pythonic interfaces (dataclass with typed fields)
- ✅ Linux-first design with Linux CI (primary target platform)
- ✅ Test coverage for all new features (pytest required)
- ✅ No vendoring or reimplementation of libchrony (dynamic linking only)

**Constitution Compliance**: All gates pass. Feature aligns with:
- "libchrony is the source of truth" - uses high-level API, not direct struct access
- "Pythonic, typed API" - dataclass with full type hints
- "Monitoring only" - read-only tracking data access
- "Linux-first" - primary Linux target
- "Tests required" - pytest coverage mandatory
- "Bind via CFFI API mode" - uses ffi.set_source() for compiled bindings
- "Requires libchrony-devel headers" - build-time dependency for API mode

## Project Structure

### Documentation (this feature)

```text
specs/002-tracking-binding/
├── plan.md              # This file (/speckit.plan command output)
├── research.md          # Phase 0 output (/speckit.plan command)
├── data-model.md        # Phase 1 output (/speckit.plan command)
├── quickstart.md        # Phase 1 output (/speckit.plan command)
├── contracts/           # Phase 1 output (/speckit.plan command)
└── tasks.md             # Phase 2 output (/speckit.tasks command - NOT created by /speckit.plan)
```

### Source Code (repository root)

```text
src/pychrony/
├── __init__.py              # Package exports (TrackingStatus, get_tracking, exceptions)
├── _core/
│   ├── __init__.py
│   ├── _build_bindings.py   # CFFI API mode build script (ffi.set_source)
│   └── _bindings.py         # Generated by CFFI at build time (compiled C extension)
├── models.py                # TrackingStatus dataclass
└── exceptions.py            # ChronyError hierarchy

tests/
├── conftest.py          # pytest fixtures
├── unit/                # Pure Python logic (runs anywhere)
│   ├── test_models.py
│   ├── test_exceptions.py
│   └── test_validation.py
├── integration/         # Real CFFI (Docker only)
│   ├── test_tracking.py
│   └── test_connection.py
└── contract/            # API stability (runs anywhere)
    └── test_api.py

docker/
├── Dockerfile.test          # Test environment (Fedora + libchrony + libchrony-devel + chronyd)
└── docker-compose.test.yml  # Test orchestration
```

**Structure Decision**: Single library package following existing `src/pychrony/` layout. Tests organized by type (unit/integration/contract) as per constitution testing requirements.

**Testing Strategy** (docker-compose with tests-in-container):
- **Unit tests** (`tests/unit/`): Pure Python logic (dataclass, validation, exceptions) - runs anywhere
- **Integration tests** (`tests/integration/`): Real CFFI + libchrony + chronyd - **runs inside Docker container**
- **Contract tests** (`tests/contract/`): Public API stability - runs anywhere
- **Why tests-in-container**: libchrony is Linux-only; tests must run where libchrony exists (not on macOS host)

**Developer Commands**:
```bash
# Fast local iteration (no Docker needed)
uv run pytest tests/unit tests/contract

# Integration tests (requires Docker)
docker compose -f docker/docker-compose.test.yml run test-integration

# Full test suite
docker compose -f docker/docker-compose.test.yml run test-all
```

## Complexity Tracking

> **No violations to justify** - All constitution gates pass.

| Violation | Why Needed | Simpler Alternative Rejected Because |
|-----------|------------|-------------------------------------|
| None | N/A | N/A |

## Post-Design Constitution Check

*Re-evaluated after Phase 1 design completion (2026-01-15)*

### Verification Against Design Artifacts

| Principle | Design Compliance | Evidence |
|-----------|------------------|----------|
| libchrony is source of truth | ✅ PASS | Uses high-level introspection API (chrony_get_field_*), not direct struct access |
| High-level API requirement | ✅ PASS | CFFI cdef declares functions only, no RPY_Tracking struct; libchrony handles conversions |
| Pythonic, typed API | ✅ PASS | `TrackingStatus` is frozen dataclass with full type hints (data-model.md) |
| Monitoring only | ✅ PASS | Only read operations defined; no write/control methods in API contract |
| Linux-first | ✅ PASS | Default socket paths are Linux-specific; other platforms require user-provided path |
| Tests required | ✅ PASS | Test structure defined: unit/, integration/, contract/ with pytest |
| CFFI API mode binding | ✅ PASS | `_build_bindings.py` uses ffi.set_source() for compiled bindings (per CFFI recommendations) |
| No vendoring | ✅ PASS | System libchrony linked dynamically at runtime; libchrony-devel provides headers at build time |
| UV package manager | ✅ PASS | CFFI in build-requires and dependencies in pyproject.toml for UV |

### Design Artifacts Produced

- [x] research.md - High-level API approach documented
- [x] data-model.md - TrackingStatus and exceptions defined (no custom type conversions)
- [x] contracts/python-api.md - Public API contract documented
- [x] quickstart.md - Usage examples and troubleshooting guide

### Ready for Task Generation

All Phase 1 deliverables complete. Constitution compliance verified. Proceed to `/speckit.tasks` when ready.
