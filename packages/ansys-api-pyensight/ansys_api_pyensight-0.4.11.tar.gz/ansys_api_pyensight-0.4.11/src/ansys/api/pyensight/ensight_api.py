"""Module ensight_api
Autogenerated from: ensight_api.xml at 2026-01-22T10:08:33.528341
"""
from ansys.pyensight.core import Session
from ansys.pyensight.core.ensobj import ENSOBJ
from ansys.pyensight.core import ensobjlist
from ansys.api.pyensight.ens_annot import ENS_ANNOT
from ansys.api.pyensight.ens_annot_text import ENS_ANNOT_TEXT
from ansys.api.pyensight.ens_annot_line import ENS_ANNOT_LINE
from ansys.api.pyensight.ens_annot_logo import ENS_ANNOT_LOGO
from ansys.api.pyensight.ens_annot_lgnd import ENS_ANNOT_LGND
from ansys.api.pyensight.ens_annot_marker import ENS_ANNOT_MARKER
from ansys.api.pyensight.ens_annot_arrow import ENS_ANNOT_ARROW
from ansys.api.pyensight.ens_annot_dial import ENS_ANNOT_DIAL
from ansys.api.pyensight.ens_annot_gauge import ENS_ANNOT_GAUGE
from ansys.api.pyensight.ens_annot_shape import ENS_ANNOT_SHAPE
from ansys.api.pyensight.ens_camera import ENS_CAMERA
from ansys.api.pyensight.ens_case import ENS_CASE
from ansys.api.pyensight.ens_flipbook import ENS_FLIPBOOK
from ansys.api.pyensight.ens_frame import ENS_FRAME
from ansys.api.pyensight.ens_geom import ENS_GEOM
from ansys.api.pyensight.ens_globals import ENS_GLOBALS
from ansys.api.pyensight.ens_group import ENS_GROUP
from ansys.api.pyensight.ens_lightsource import ENS_LIGHTSOURCE
from ansys.api.pyensight.ens_lpart import ENS_LPART
from ansys.api.pyensight.ens_mat import ENS_MAT
from ansys.api.pyensight.ens_palette import ENS_PALETTE
from ansys.api.pyensight.ens_part import ENS_PART
from ansys.api.pyensight.ens_part_model import ENS_PART_MODEL
from ansys.api.pyensight.ens_part_clip import ENS_PART_CLIP
from ansys.api.pyensight.ens_part_contour import ENS_PART_CONTOUR
from ansys.api.pyensight.ens_part_discrete_particle import ENS_PART_DISCRETE_PARTICLE
from ansys.api.pyensight.ens_part_frame import ENS_PART_FRAME
from ansys.api.pyensight.ens_part_isosurface import ENS_PART_ISOSURFACE
from ansys.api.pyensight.ens_part_particle_trace import ENS_PART_PARTICLE_TRACE
from ansys.api.pyensight.ens_part_profile import ENS_PART_PROFILE
from ansys.api.pyensight.ens_part_vector_arrow import ENS_PART_VECTOR_ARROW
from ansys.api.pyensight.ens_part_elevated_surface import ENS_PART_ELEVATED_SURFACE
from ansys.api.pyensight.ens_part_developed_surface import ENS_PART_DEVELOPED_SURFACE
from ansys.api.pyensight.ens_part_built_up import ENS_PART_BUILT_UP
from ansys.api.pyensight.ens_part_tensor_glyph import ENS_PART_TENSOR_GLYPH
from ansys.api.pyensight.ens_part_fx_vortex_core import ENS_PART_FX_VORTEX_CORE
from ansys.api.pyensight.ens_part_fx_shock import ENS_PART_FX_SHOCK
from ansys.api.pyensight.ens_part_fx_sep_att import ENS_PART_FX_SEP_ATT
from ansys.api.pyensight.ens_part_mat_interface import ENS_PART_MAT_INTERFACE
from ansys.api.pyensight.ens_part_point import ENS_PART_POINT
from ansys.api.pyensight.ens_part_axisymmetric import ENS_PART_AXISYMMETRIC
from ansys.api.pyensight.ens_part_vof import ENS_PART_VOF
from ansys.api.pyensight.ens_part_aux_geom import ENS_PART_AUX_GEOM
from ansys.api.pyensight.ens_part_filter import ENS_PART_FILTER
from ansys.api.pyensight.ens_plotter import ENS_PLOTTER
from ansys.api.pyensight.ens_polyline import ENS_POLYLINE
from ansys.api.pyensight.ens_probe import ENS_PROBE
from ansys.api.pyensight.ens_query import ENS_QUERY
from ansys.api.pyensight.ens_scene import ENS_SCENE
from ansys.api.pyensight.ens_source import ENS_SOURCE
from ansys.api.pyensight.ens_spec import ENS_SPEC
from ansys.api.pyensight.ens_state import ENS_STATE
from ansys.api.pyensight.ens_texture import ENS_TEXTURE
from ansys.api.pyensight.ens_tool import ENS_TOOL
from ansys.api.pyensight.ens_tool_cursor import ENS_TOOL_CURSOR
from ansys.api.pyensight.ens_tool_line import ENS_TOOL_LINE
from ansys.api.pyensight.ens_tool_plane import ENS_TOOL_PLANE
from ansys.api.pyensight.ens_tool_box import ENS_TOOL_BOX
from ansys.api.pyensight.ens_tool_cylinder import ENS_TOOL_CYLINDER
from ansys.api.pyensight.ens_tool_cone import ENS_TOOL_CONE
from ansys.api.pyensight.ens_tool_sphere import ENS_TOOL_SPHERE
from ansys.api.pyensight.ens_tool_revolution import ENS_TOOL_REVOLUTION
from ansys.api.pyensight.ens_var import ENS_VAR
from ansys.api.pyensight.ens_vport import ENS_VPORT
from ansys.api.pyensight.ens_animobj import ens_animobj
from ansys.api.pyensight.ens_emitterobj import ens_emitterobj
from typing import Any, List, Type, Union, Optional, Tuple, TYPE_CHECKING
import types

if TYPE_CHECKING:
    from ansys.pyensight.core.utils.views import Views
    from ansys.pyensight.core.utils.query import Query
    from ansys.pyensight.core.utils.export import Export
    from ansys.pyensight.core.utils.parts import Parts
    from ansys.pyensight.core.utils.support import Support
    from ansys.pyensight.core.utils.adr import Adr
    from ansys.pyensight.core.utils.variables import Variables
    from ansys.pyensight.core.utils.omniverse import Omniverse
    from ansys.pyensight.core.utils.readers import Readers


class UtilsNameSpace(types.SimpleNamespace):
    def __init__(self, *args, **kwargs):
        super(*args, **kwargs)
        self.views: 'Views'
        self.query: 'Query'
        self.export: 'Export'
        self.parts: 'Parts'
        self.support: 'Support'
        self.adr: 'Adr'
        self.variables: 'Variables'
        self.omniverse: 'Omniverse'
        self.readers: 'Readers'


class vortexcore:
    """Class wrapper for EnSight vortexcore module

    This class acts as a proxy for the EnSight Python module ensight.vortexcore
    """
    def __init__(self, session: Session):
        self._session = session

    def begin(self) -> int:
        """Delimit the modifications for vortexcore attributes.
        
        | These commands are used to set the attributes for a vortex core creation.
        
        Examples:
            ::
        
                #
                # Specify the 3D parent part(s) 
                # from which to create the vortex cores
                #
                ensight.part.select_begin(1)
                #
                # Compute the vortex cores part
                #
                ensight.vortexcore.begin()
                ensight.vortexcore.end()
                ensight.vortexcore.create()
                #
                # Now select the newly created vortex part 
                # for subsequent operations
                #
                ensight.part.select_begin(5)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.vortexcore.begin()'''
        return self._session.cmd(cmd)

    def create(self) -> int:
        """Create a vortex core part with the currently defined attributes and the selected 3D parent parts.
        
        Examples:
            ::
        
                #
                # Specify the 3D parent part(s) 
                # from which to create the vortex cores
                #
                ensight.part.select_begin(1)
                #
                # Compute the vortex cores part
                #
                ensight.vortexcore.begin()
                ensight.vortexcore.end()
                ensight.vortexcore.create()
                #
                # Now select the newly created vortex part 
                # for subsequent operations
                #
                ensight.part.select_begin(5)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.vortexcore.create()'''
        return self._session.cmd(cmd)

    def density(self, p0: Any) -> int:
        """Specify the density variable to use in creating/updating a vortex core part or the default attributes.
        
        | This variable is assigned automatically if the variable name <Density> exists. 
        | Since the computation of separation and attachment lines depend on velocity, either the velocity variable must be defined or both the density and momentum variables must be defined to obtain the velocity variable.
        
        Args:
            p0:
                'variable_name' the name of the density variable (the default <none> means to use nothing)
        
        Examples:
            ::
        
                ensight.variables.activate("Density")
                ensight.vortexcore.select_default()
                ensight.part.modify_begin()
                ensight.vortexcore.density("Density")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.vortexcore.density({repr(p0)})'''
        return self._session.cmd(cmd)

    def end(self) -> int:
        """Delimit the modifications for vortexcore attributes.
        
        | These commands are used to set the attributes for a vortex core creation.
        
        Examples:
            ::
        
                #
                # Specify the 3D parent part(s) 
                # from which to create the vortex cores
                #
                ensight.part.select_begin(1)
                #
                # Compute the vortex cores part
                #
                ensight.vortexcore.begin()
                ensight.vortexcore.end()
                ensight.vortexcore.create()
                #
                # Now select the newly created vortex part 
                # for subsequent operations
                #
                ensight.part.select_begin(5)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.vortexcore.end()'''
        return self._session.cmd(cmd)

    def method(self, p0: str) -> int:
        """Specify the algorithm to use to compute the vortex core parts.
        
        Args:
            p0:
                'algorithm'
        
                * vorticity
                * eigen_analysis
        
        Examples:
            ::
        
                ensight.part.select_begin(5)
                ensight.part.modify_begin()
                ensight.vortexcore.method("vorticity")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.vortexcore.method({repr(p0)})'''
        return self._session.cmd(cmd)

    def momentum(self, p0: Any) -> int:
        """Specify the momentum variable to use in creating/updating a vortex core part or the default attributes.
        
        | This variable is assigned automatically if the variable name <Momentum> exists.
        | Since the computation of separation and attachment lines depend on velocity, either the velocity variable must be defined or both the density and momentum variables must be defined to obtain the velocity variable.
        
        Args:
            p0:
                'variable_name' name of the momentum variable (the default name <none> means to use nothing)
        
        Examples:
            ::
        
                ensight.variables.activate("Momentum")
                ensight.vortexcore.select_default()
                ensight.part.modify_begin()
                ensight.vortexcore.momentum("Momentum")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.vortexcore.momentum({repr(p0)})'''
        return self._session.cmd(cmd)

    def ratio_of_spec_heat(self, args: Any) -> int:
        """Specify the ratio of specific heat constant value or  variable name to use in creating/updating a vortex core part or the default attributes.
        
        Args:
            p0:
                'name' scalar field variable name for the ratio of specific heats
            p1:
                'value' constant value (default = 1.4) for the ratio of specific heats
        
        Examples:
            ::
        
                ensight.vortexcore.select_default()
                ensight.part.modify_begin()
                ensight.vortexcore.ratio_of_spec_heat(1.4)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.vortexcore.ratio_of_spec_heat({repr(args)})'''
        return self._session.cmd(cmd)

    def select_default(self) -> int:
        """Specify that the default attributes of the vortex core part are to be set for all subsequent vortex core creates and updates.
        
        Examples:
            ::
        
                ensight.vortexcore.select_default()
                ensight.part.modify_begin()
                ensight.vortexcore.momentum("none")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.vortexcore.select_default()'''
        return self._session.cmd(cmd)

    def threshold(self, p0: Any) -> int:
        """Specify the threshold variable description by which to filter the segments of the selected vortex cores part.
        
        | The default threshold variable for vortex cores is "fx_vortcore_streng".
        
        Args:
            p0:
                'variable_name' name of the scalar variable by which to filter the vortex core segments
        
        Examples:
            ::
        
                ensight.part.select_begin(5)
                ensight.part.modify_begin()
                ensight.vortexcore.threshold("Density")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.vortexcore.threshold({repr(p0)})'''
        return self._session.cmd(cmd)

    def threshold_filter(self, p0: str) -> int:
        """Specify how to filter out segments of the specified vortex cores part, according to the specified threshold variable and value.
        
        Args:
            p0:
                'option'
        
                * <=
                * >=
        
        Examples:
            ::
        
                ensight.part.select_begin(5)
                ensight.part.modify_begin()
                ensight.vortexcore.threshold_filter(">=")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.vortexcore.threshold_filter({repr(p0)})'''
        return self._session.cmd(cmd)

    def threshold_max(self, p0: float) -> int:
        """Specify the maximum threshold limit under which to filter the threshold value of the selected vortex cores part(s).
        
        | This value must be greater than the threshold_min value, and be a valid threshold variable value. This value is initially automatically adjusted usually to an order of magnitude above the threshold value.
        
        Args:
            p0:
                'threshold_value' maximum threshold variable range limit below which to threshold the vortex cores part
        
        Examples:
            ::
        
                ensight.part.select_begin(5)
                ensight.part.modify_begin()
                ensight.vortexcore.threshold_max(1.0000e+01)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.vortexcore.threshold_max({repr(p0)})'''
        return self._session.cmd(cmd)

    def threshold_min(self, p0: float) -> int:
        """Specify the minimum threshold limit above which to filter the threshold value of the selected vortex cores part(s).
        
        | This value must be less than the threshold_max value, and be a valid threshold variable value. This value is initially adjusted to the threshold value.
        
        Args:
            p0:
                'threshold_value' minimum threshold variable range limit above which to threshold the vortex cores part
        
        Examples:
            ::
        
                ensight.part.select_begin(5)
                ensight.part.modify_begin()
                ensight.vortexcore.threshold_min(1.0000e-01)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.vortexcore.threshold_min({repr(p0)})'''
        return self._session.cmd(cmd)

    def threshold_value(self, p0: float) -> int:
        """Specify the threshold value by which to filter the segments from the selected vortex cores part(s). 
        
        | This value is automatically set to the minimum vortex core strength variable value of the vortex cores part.  This value must lie within the threshold variable interval [threshold_min,theshold_max].
        
        Args:
            p0:
                'threshold_value' variable value by which to apply the threshold filter to the vortex core segments
        
        Examples:
            ::
        
                ensight.part.select_begin(5)
                ensight.part.modify_begin()
                ensight.vortexcore.threshold_value(5.0000e-01)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.vortexcore.threshold_value({repr(p0)})'''
        return self._session.cmd(cmd)

    def velocity(self, p0: Any) -> int:
        """Specify the velocity variable to use in creating/updating a vortex core part or the default attributes.
        
        | This variable is automatically assigned if the variable name <velocity> exists. 
        | Since the computation of separation and attachment lines depend on velocity, either the velocity variable must be defined or both the density and momentum variables must be defined to obtain the velocity variable.
        
        Args:
            p0:
                'variable_name' name of the velocity variable (the default <none> means to use nothing)
        
        Examples:
            ::
        
                ensight.variables.activate("Velocity")
                ensight.vortexcore.select_default()
                ensight.part.modify_begin()
                ensight.vortexcore.velocity("Velocity")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.vortexcore.velocity({repr(p0)})'''
        return self._session.cmd(cmd)


class vof:
    """Class wrapper for EnSight vof module

    This class acts as a proxy for the EnSight Python module ensight.vof
    """
    def __init__(self, session: Session):
        self._session = session

    def begin(self) -> int:
        """Vof: begin

        """
        cmd = f'''ensight.vof.begin()'''
        return self._session.cmd(cmd)

    def blanking_algorithm(self, p0: str) -> int:
        """Vof: blanking_algorithm

        """
        cmd = f'''ensight.vof.blanking_algorithm({repr(p0)})'''
        return self._session.cmd(cmd)

    def blanking_clip_alg(self, p0: float) -> int:
        """Vof: blanking_clip_alg

        """
        cmd = f'''ensight.vof.blanking_clip_alg({repr(p0)})'''
        return self._session.cmd(cmd)

    def blanking_threshold(self, p0: float) -> int:
        """Vof: blanking_threshold

        """
        cmd = f'''ensight.vof.blanking_threshold({repr(p0)})'''
        return self._session.cmd(cmd)

    def blanking_variable1(self, p0: Any) -> int:
        """Vof: blanking_variable1

        """
        cmd = f'''ensight.vof.blanking_variable1({repr(p0)})'''
        return self._session.cmd(cmd)

    def blanking_variable2(self, p0: Any) -> int:
        """Vof: blanking_variable2

        """
        cmd = f'''ensight.vof.blanking_variable2({repr(p0)})'''
        return self._session.cmd(cmd)

    def boundary_flag_xmax(self, p0: str) -> int:
        """Vof: boundary_flag_xmax

        """
        cmd = f'''ensight.vof.boundary_flag_xmax({repr(p0)})'''
        return self._session.cmd(cmd)

    def boundary_flag_xmin(self, p0: str) -> int:
        """Vof: boundary_flag_xmin

        """
        cmd = f'''ensight.vof.boundary_flag_xmin({repr(p0)})'''
        return self._session.cmd(cmd)

    def boundary_flag_ymax(self, p0: str) -> int:
        """Vof: boundary_flag_ymax

        """
        cmd = f'''ensight.vof.boundary_flag_ymax({repr(p0)})'''
        return self._session.cmd(cmd)

    def boundary_flag_ymin(self, p0: str) -> int:
        """Vof: boundary_flag_ymin

        """
        cmd = f'''ensight.vof.boundary_flag_ymin({repr(p0)})'''
        return self._session.cmd(cmd)

    def boundary_flag_zmax(self, p0: str) -> int:
        """Vof: boundary_flag_zmax

        """
        cmd = f'''ensight.vof.boundary_flag_zmax({repr(p0)})'''
        return self._session.cmd(cmd)

    def boundary_flag_zmin(self, p0: str) -> int:
        """Vof: boundary_flag_zmin

        """
        cmd = f'''ensight.vof.boundary_flag_zmin({repr(p0)})'''
        return self._session.cmd(cmd)

    def cell_comp_num(self, p0: int) -> int:
        """Vof: cell_comp_num

        """
        cmd = f'''ensight.vof.cell_comp_num({repr(p0)})'''
        return self._session.cmd(cmd)

    def cell_type(self, p0: Any) -> int:
        """Vof: cell_type

        """
        cmd = f'''ensight.vof.cell_type({repr(p0)})'''
        return self._session.cmd(cmd)

    def cell_volume_fraction(self, p0: Any) -> int:
        """Vof: cell_volume_fraction

        """
        cmd = f'''ensight.vof.cell_volume_fraction({repr(p0)})'''
        return self._session.cmd(cmd)

    def clip_blanking_variable(self, p0: Any) -> int:
        """Vof: clip_blanking_variable

        """
        cmd = f'''ensight.vof.clip_blanking_variable({repr(p0)})'''
        return self._session.cmd(cmd)

    def clip_lctw(self, p0: str) -> int:
        """Vof: clip_lctw

        """
        cmd = f'''ensight.vof.clip_lctw({repr(p0)})'''
        return self._session.cmd(cmd)

    def clip_periodic_flagx(self, p0: str) -> int:
        """Vof: clip_periodic_flagx

        """
        cmd = f'''ensight.vof.clip_periodic_flagx({repr(p0)})'''
        return self._session.cmd(cmd)

    def clip_periodic_flagy(self, p0: str) -> int:
        """Vof: clip_periodic_flagy

        """
        cmd = f'''ensight.vof.clip_periodic_flagy({repr(p0)})'''
        return self._session.cmd(cmd)

    def clip_type(self, p0: str) -> int:
        """Vof: clip_type

        """
        cmd = f'''ensight.vof.clip_type({repr(p0)})'''
        return self._session.cmd(cmd)

    def component(self, p0: float, p1: float, p2: float) -> int:
        """Vof: component

        """
        cmd = f'''ensight.vof.component({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def component_num_in_cell(self, p0: Any) -> int:
        """Vof: component_num_in_cell

        """
        cmd = f'''ensight.vof.component_num_in_cell({repr(p0)})'''
        return self._session.cmd(cmd)

    def cooling_channel_comp(self, p0: Any) -> int:
        """Vof: cooling_channel_comp

        """
        cmd = f'''ensight.vof.cooling_channel_comp({repr(p0)})'''
        return self._session.cmd(cmd)

    def create(self) -> int:
        """Vof: create

        """
        cmd = f'''ensight.vof.create()'''
        return self._session.cmd(cmd)

    def end(self) -> int:
        """Vof: end

        """
        cmd = f'''ensight.vof.end()'''
        return self._session.cmd(cmd)

    def epsilon(self, p0: float) -> int:
        """Vof: epsilon

        """
        cmd = f'''ensight.vof.epsilon({repr(p0)})'''
        return self._session.cmd(cmd)

    def face_area_fraction(self, p0: Any) -> int:
        """Vof: face_area_fraction

        """
        cmd = f'''ensight.vof.face_area_fraction({repr(p0)})'''
        return self._session.cmd(cmd)

    def geometric_type(self, p0: str) -> int:
        """Vof: geometric_type

        """
        cmd = f'''ensight.vof.geometric_type({repr(p0)})'''
        return self._session.cmd(cmd)

    def interactive_rangemax(self, p0: float) -> int:
        """Vof: interactive_rangemax

        """
        cmd = f'''ensight.vof.interactive_rangemax({repr(p0)})'''
        return self._session.cmd(cmd)

    def interactive_rangemin(self, p0: float) -> int:
        """Vof: interactive_rangemin

        """
        cmd = f'''ensight.vof.interactive_rangemin({repr(p0)})'''
        return self._session.cmd(cmd)

    def interactive_step(self, p0: float) -> int:
        """Vof: interactive_step

        """
        cmd = f'''ensight.vof.interactive_step({repr(p0)})'''
        return self._session.cmd(cmd)

    def interactive_xmax(self, p0: float) -> int:
        """Vof: interactive_xmax

        """
        cmd = f'''ensight.vof.interactive_xmax({repr(p0)})'''
        return self._session.cmd(cmd)

    def interactive_xmin(self, p0: float) -> int:
        """Vof: interactive_xmin

        """
        cmd = f'''ensight.vof.interactive_xmin({repr(p0)})'''
        return self._session.cmd(cmd)

    def interactive_ymax(self, p0: float) -> int:
        """Vof: interactive_ymax

        """
        cmd = f'''ensight.vof.interactive_ymax({repr(p0)})'''
        return self._session.cmd(cmd)

    def interactive_ymin(self, p0: float) -> int:
        """Vof: interactive_ymin

        """
        cmd = f'''ensight.vof.interactive_ymin({repr(p0)})'''
        return self._session.cmd(cmd)

    def interactive_zmax(self, p0: float) -> int:
        """Vof: interactive_zmax

        """
        cmd = f'''ensight.vof.interactive_zmax({repr(p0)})'''
        return self._session.cmd(cmd)

    def interactive_zmin(self, p0: float) -> int:
        """Vof: interactive_zmin

        """
        cmd = f'''ensight.vof.interactive_zmin({repr(p0)})'''
        return self._session.cmd(cmd)

    def mesh_planeloc(self, p0: str) -> int:
        """Vof: mesh_planeloc

        """
        cmd = f'''ensight.vof.mesh_planeloc({repr(p0)})'''
        return self._session.cmd(cmd)

    def select_default(self) -> int:
        """Vof: select_default

        """
        cmd = f'''ensight.vof.select_default()'''
        return self._session.cmd(cmd)

    def specify_cell_comp_num(self, p0: str) -> int:
        """Vof: specify_cell_comp_num

        """
        cmd = f'''ensight.vof.specify_cell_comp_num({repr(p0)})'''
        return self._session.cmd(cmd)

    def symmetry(self, p0: str) -> int:
        """Vof: symmetry

        """
        cmd = f'''ensight.vof.symmetry({repr(p0)})'''
        return self._session.cmd(cmd)

    def type(self, p0: str) -> int:
        """Vof: type

        """
        cmd = f'''ensight.vof.type({repr(p0)})'''
        return self._session.cmd(cmd)

    def value(self, p0: float) -> int:
        """Vof: value

        """
        cmd = f'''ensight.vof.value({repr(p0)})'''
        return self._session.cmd(cmd)

    def variable(self, p0: Any) -> int:
        """Vof: variable

        """
        cmd = f'''ensight.vof.variable({repr(p0)})'''
        return self._session.cmd(cmd)

    def ztest(self, p0: float) -> int:
        """Vof: ztest

        """
        cmd = f'''ensight.vof.ztest({repr(p0)})'''
        return self._session.cmd(cmd)


class views:
    """Class wrapper for EnSight views module

    This class acts as a proxy for the EnSight Python module ensight.views
    """
    def __init__(self, session: Session):
        self._session = session

    def apply(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.views.apply()'''
        return self._session.cmd(cmd)

    def load(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.views.load({repr(p0)})'''
        return self._session.cmd(cmd)

    def load_dir(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.views.load_dir({repr(p0)})'''
        return self._session.cmd(cmd)

    def new(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.views.new()'''
        return self._session.cmd(cmd)

    def remove(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.views.remove()'''
        return self._session.cmd(cmd)

    def remove_all(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.views.remove_all()'''
        return self._session.cmd(cmd)

    def rename(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.views.rename({repr(p0)})'''
        return self._session.cmd(cmd)

    def rename_all(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.views.rename_all({repr(p0)})'''
        return self._session.cmd(cmd)

    def replace(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.views.replace()'''
        return self._session.cmd(cmd)

    def rescale_views(self, p0: str) -> int:
        """Views: rescale_views

        """
        cmd = f'''ensight.views.rescale_views({repr(p0)})'''
        return self._session.cmd(cmd)

    def save(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.views.save()'''
        return self._session.cmd(cmd)

    def save_as(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.views.save_as({repr(p0)})'''
        return self._session.cmd(cmd)

    def select(self, p0: int) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.views.select({repr(p0)})'''
        return self._session.cmd(cmd)

    def update(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.views.update()'''
        return self._session.cmd(cmd)

    def use_stored_image(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.views.use_stored_image({repr(p0)})'''
        return self._session.cmd(cmd)


class viewport_bounds:
    """Class wrapper for EnSight viewport_bounds module

    This class acts as a proxy for the EnSight Python module ensight.viewport_bounds
    """
    def __init__(self, session: Session):
        self._session = session

    def auto_size(self, p0: str) -> int:
        """When geometry changes the bounds display will resize if this toggle is set
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.view.bounds("ON")
                ensight.viewport.select_begin(0)
                ensight.viewport_bounds.auto_size("OFF")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.viewport_bounds.auto_size({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_height(self, p0: float) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.viewport_bounds.axis_height({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_linewidth(self, p0: int) -> int:
        """Set the line width for the bounds axis
        
        Args:
            p0:
                'line_width' the pixel width for the axis
        
        Examples:
            ::
        
                ensight.view.bounds("ON")
                ensight.viewport.select_begin(0)
                ensight.viewport_bounds.visible("ON")
                ensight.viewport_bounds.axis_linewidth(2)
                ensight.viewport_bounds.axis_rgb(1.0000e+00,0.0000e+00,1.0000e+00)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.viewport_bounds.axis_linewidth({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_rgb(self, p0: float, p1: float, p2: float) -> int:
        """Set the color for the bounds axis
        
        Args:
            p0:
                'red_val' red, green, blue color components (must be between 0.0 and 1.0)
            p1:
                'grn_val' red, green, blue color components (must be between 0.0 and 1.0)
            p2:
                'blu_val' red, green, blue color components (must be between 0.0 and 1.0)
        
        Examples:
            ::
        
                ensight.view.bounds("ON")
                ensight.viewport.select_begin(0)
                ensight.viewport_bounds.visible("ON")
                ensight.viewport_bounds.axis_linewidth(1)
                ensight.viewport_bounds.axis_rgb(1.0000e+00,0.0000e+00,1.0000e+00)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.viewport_bounds.axis_rgb({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def axis_width(self, p0: float) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.viewport_bounds.axis_width({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_x_displayonedge(self, p0: str) -> int:
        """Viewport_bounds: axis_x_displayonedge

        """
        cmd = f'''ensight.viewport_bounds.axis_x_displayonedge({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_x_format(self, p0: str) -> int:
        """Specifies the format to be used for labels along the x/y/z axis
        
        Args:
            p0:
                'format' may be any valid C language format string
        
        Examples:
            ::
        
                ensight.view.bounds("ON")
                ensight.viewport.select_begin(0)
                ensight.viewport_bounds.axis_x_format("%.2f")
                ensight.viewport_bounds.axis_y_format("%g")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.viewport_bounds.axis_x_format({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_x_gridextentloc(self, p0: str) -> int:
        """Specifies which bounds will receive grids and subgrid lines
        
        Args:
            p0:
                'extent'
        
                * Can be any of the following:
                * min
                * max
                * both
        
        Examples:
            ::
        
                ensight.view.bounds("ON")
                ensight.viewport.select_begin(0)
                ensight.viewport_bounds.axis_x_gridextentloc("both")
                ensight.viewport_bounds.axis_y_gridextentloc("min")
                ensight.viewport_bounds.axis_z_gridextentloc("max")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.viewport_bounds.axis_x_gridextentloc({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_x_gridtype(self, p0: str) -> int:
        """Set the line type for the x/y/z grid bounds
        
        | If grid, the line type is specified via the viewport_bounds: grid_linetype command
        
        Args:
            p0:
                'grid_type'
        
                * Can be any of the following:
                * none
                * grid
                * tick
        
        Examples:
            ::
        
                ensight.view.bounds("ON")
                ensight.viewport.select_begin(0)
                ensight.viewport_bounds.axis_x_gridtype("solid")
                ensight.viewport_bounds.axis_y_gridtype("none")
                ensight.viewport_bounds.axis_z_gridtype("tick")
                ensight.viewport_bounds.grid_linetype("solid")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.viewport_bounds.axis_x_gridtype({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_x_labelaxisloc(self, p0: str) -> int:
        """Specifies the location for the x/y/z axis labels for bounds display
        
        | When label_location is "all", the number of labels is controlled by the viewport_bounds: axis_x/y/z_numgrid command
        
        Args:
            p0:
                'label_location'
        
                * Can be any of the following:
                * none
                * all
                * beg_end
        
        Examples:
            ::
        
                ensight.view.bounds("ON")
                ensight.viewport.select_begin(0)
                ensight.viewport_bounds.length("as_specified")
                ensight.viewport_bounds.axis_x_min(0.)
                ensight.viewport_bounds.axis_x_max(1.)
                ensight.viewport_bounds.axis_x_numgrid(5)
                ensight.viewport_bounds.axis_x_labelaxisloc("beg_end")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.viewport_bounds.axis_x_labelaxisloc({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_x_labelextentloc(self, p0: str) -> int:
        """Specifies which bounds axis will receive labels
        
        Args:
            p0:
                'extent'
        
                * Can be any of the following:
                * min
                * max
                * both
        
        Examples:
            ::
        
                ensight.view.bounds("ON")
                ensight.viewport.select_begin(0)
                ensight.viewport_bounds.axis_x_labelextentloc("both")
                ensight.viewport_bounds.axis_y_labelextentloc("min")
                ensight.viewport_bounds.axis_z_labelextentloc("max")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.viewport_bounds.axis_x_labelextentloc({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_x_labelfilter(self, p0: str) -> int:
        """Viewport_bounds: axis_x_labelfilter

        """
        cmd = f'''ensight.viewport_bounds.axis_x_labelfilter({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_x_labelrgb(self, p0: float, p1: float, p2: float) -> int:
        """Set the color for the x/y/z axis labels
        
        Args:
            p0:
                'red_val' red, green, blue color components (must be between 0.0 and 1.0)
            p1:
                'grn_val' red, green, blue color components (must be between 0.0 and 1.0)
            p2:
                'blu_val' red, green, blue color components (must be between 0.0 and 1.0)
        
        Examples:
            ::
        
                ensight.view.bounds("ON")
                ensight.viewport.select_begin(0)
                ensight.viewport_bounds.axis_x_labelrgb(4.0000e-01,0.0000e+00,1.0000e+00)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.viewport_bounds.axis_x_labelrgb({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def axis_x_max(self, p0: float) -> int:
        """Sets the minimum value for the x/y/z axis
        
        | If the length attribute is set to rounded the resulting min/max x/y/z value will be modified from the specified value
        
        Args:
            p0:
                'min' the minimum axis value
            p1:
                'max' the maximum axis value
        
        Examples:
            ::
        
                ensight.view.bounds("ON")
                ensight.viewport.select_begin(0)
                ensight.viewport_bounds.axis_linewidth(1)
                ensight.viewport_bounds.axis_rgb(1.0000e+00,0.0000e+00,1.0000e+00)
                ensight.viewport_bounds.length("as_specified")
                ensight.viewport_bounds.axis_x_min(0.2)
                ensight.viewport_bounds.axis_x_max(0.6)
                ensight.viewport_bounds.axis_y_min(0.0)
                ensight.viewport_bounds.axis_y_max(1.0)
                ensight.viewport_bounds.axis_z_min(-1.)
                ensight.viewport_bounds.axis_z_max(1.)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.viewport_bounds.axis_x_max({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_x_min(self, p0: float) -> int:
        """Sets the minimum value for the x/y/z axis
        
        | If the length attribute is set to rounded the resulting min/max x/y/z value will be modified from the specified value
        
        Args:
            p0:
                'min' the minimum axis value
            p1:
                'max' the maximum axis value
        
        Examples:
            ::
        
                ensight.view.bounds("ON")
                ensight.viewport.select_begin(0)
                ensight.viewport_bounds.axis_linewidth(1)
                ensight.viewport_bounds.axis_rgb(1.0000e+00,0.0000e+00,1.0000e+00)
                ensight.viewport_bounds.length("as_specified")
                ensight.viewport_bounds.axis_x_min(0.2)
                ensight.viewport_bounds.axis_x_max(0.6)
                ensight.viewport_bounds.axis_y_min(0.0)
                ensight.viewport_bounds.axis_y_max(1.0)
                ensight.viewport_bounds.axis_z_min(-1.)
                ensight.viewport_bounds.axis_z_max(1.)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.viewport_bounds.axis_x_min({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_x_numgrid(self, p0: float) -> int:
        """Set the number of grid marks along the x/y/z axis
        
        | If the length attribute is set to rounded the resulting number of grid marks will be modified from the specified value.
        
        Args:
            p0:
                'num' the number of grid marks to be used
        
        Examples:
            ::
        
                ensight.view.bounds("ON")
                ensight.viewport.select_begin(0)
                ensight.viewport_bounds.axis_linewidth(1)
                ensight.viewport_bounds.axis_rgb(1.0000e+00,0.0000e+00,1.0000e+00)
                ensight.viewport_bounds.length("as_specified")
                ensight.viewport_bounds.axis_x_numgrid(5)
                ensight.viewport_bounds.axis_y_numgrid(3)
                ensight.viewport_bounds.axis_z_numgrid(7)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.viewport_bounds.axis_x_numgrid({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_x_numsubgrid(self, p0: float) -> int:
        """Set the number of subgrid marks along the x/y/z axis
        
        | If the length attribute is set to rounded the resulting number of subgrid marks will be modified from the specified value.
        
        Args:
            p0:
                'num' the number of subgrid marks to be used
        
        Examples:
            ::
        
                ensight.view.bounds("ON")
                ensight.viewport.select_begin(0)
                ensight.viewport_bounds.length("as_specified")
                ensight.viewport_bounds.axis_x_numsubgrid(2)
                ensight.viewport_bounds.axis_y_numsubgrid(2)
                ensight.viewport_bounds.axis_z_numsubgrid(3)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.viewport_bounds.axis_x_numsubgrid({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_x_orig(self, p0: float) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.viewport_bounds.axis_x_orig({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_x_sgridtype(self, p0: str) -> int:
        """Set the line type for the x/y/z subgrid bounds
        
        | If "grid", the line type is specified via the viewport_bounds: subgrid_linetype command
        
        Args:
            p0:
                'grid_type'
        
                * Can be any of the following:
                * none
                * grid
                * tick
        
        Examples:
            ::
        
                ensight.view.bounds("ON")
                ensight.viewport.select_begin(0)
                ensight.viewport_bounds.axis_x_sgridtype("solid")
                ensight.viewport_bounds.axis_y_sgridtype("none")
                ensight.viewport_bounds.axis_z_sgridtype("tick")
                ensight.viewport_bounds.subgrid_linetype("solid")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.viewport_bounds.axis_x_sgridtype({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_x_subtick(self, p0: str) -> int:
        """Viewport_bounds: axis_x_subtick

        """
        cmd = f'''ensight.viewport_bounds.axis_x_subtick({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_x_tick(self, p0: str) -> int:
        """Viewport_bounds: axis_x_tick

        """
        cmd = f'''ensight.viewport_bounds.axis_x_tick({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_x_title(self, p0: str) -> int:
        """Viewport_bounds: axis_x_title

        """
        cmd = f'''ensight.viewport_bounds.axis_x_title({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_x_titlesize(self, p0: int) -> int:
        """Viewport_bounds: axis_x_titlesize

        """
        cmd = f'''ensight.viewport_bounds.axis_x_titlesize({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_x_ymaxzmax(self, p0: str) -> int:
        """Viewport_bounds: axis_x_ymaxzmax

        """
        cmd = f'''ensight.viewport_bounds.axis_x_ymaxzmax({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_x_ymaxzmin(self, p0: str) -> int:
        """Viewport_bounds: axis_x_ymaxzmin

        """
        cmd = f'''ensight.viewport_bounds.axis_x_ymaxzmin({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_x_yminzmax(self, p0: str) -> int:
        """Viewport_bounds: axis_x_yminzmax

        """
        cmd = f'''ensight.viewport_bounds.axis_x_yminzmax({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_x_yminzmin(self, p0: str) -> int:
        """Viewport_bounds: axis_x_yminzmin

        """
        cmd = f'''ensight.viewport_bounds.axis_x_yminzmin({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_y_displayonedge(self, p0: str) -> int:
        """Viewport_bounds: axis_y_displayonedge

        """
        cmd = f'''ensight.viewport_bounds.axis_y_displayonedge({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_y_format(self, p0: str) -> int:
        """Specifies the format to be used for labels along the x/y/z axis
        
        Args:
            p0:
                'format' may be any valid C language format string
        
        Examples:
            ::
        
                ensight.view.bounds("ON")
                ensight.viewport.select_begin(0)
                ensight.viewport_bounds.axis_x_format("%.2f")
                ensight.viewport_bounds.axis_y_format("%g")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.viewport_bounds.axis_y_format({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_y_gridextentloc(self, p0: str) -> int:
        """Specifies which bounds will receive grids and subgrid lines
        
        Args:
            p0:
                'extent'
        
                * Can be any of the following:
                * min
                * max
                * both
        
        Examples:
            ::
        
                ensight.view.bounds("ON")
                ensight.viewport.select_begin(0)
                ensight.viewport_bounds.axis_x_gridextentloc("both")
                ensight.viewport_bounds.axis_y_gridextentloc("min")
                ensight.viewport_bounds.axis_z_gridextentloc("max")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.viewport_bounds.axis_y_gridextentloc({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_y_gridtype(self, p0: str) -> int:
        """Set the line type for the x/y/z grid bounds
        
        | If grid, the line type is specified via the viewport_bounds: grid_linetype command
        
        Args:
            p0:
                'grid_type'
        
                * Can be any of the following:
                * none
                * grid
                * tick
        
        Examples:
            ::
        
                ensight.view.bounds("ON")
                ensight.viewport.select_begin(0)
                ensight.viewport_bounds.axis_x_gridtype("solid")
                ensight.viewport_bounds.axis_y_gridtype("none")
                ensight.viewport_bounds.axis_z_gridtype("tick")
                ensight.viewport_bounds.grid_linetype("solid")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.viewport_bounds.axis_y_gridtype({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_y_labelaxisloc(self, p0: str) -> int:
        """Specifies the location for the x/y/z axis labels for bounds display
        
        | When label_location is "all", the number of labels is controlled by the viewport_bounds: axis_x/y/z_numgrid command
        
        Args:
            p0:
                'label_location'
        
                * Can be any of the following:
                * none
                * all
                * beg_end
        
        Examples:
            ::
        
                ensight.view.bounds("ON")
                ensight.viewport.select_begin(0)
                ensight.viewport_bounds.length("as_specified")
                ensight.viewport_bounds.axis_x_min(0.)
                ensight.viewport_bounds.axis_x_max(1.)
                ensight.viewport_bounds.axis_x_numgrid(5)
                ensight.viewport_bounds.axis_x_labelaxisloc("beg_end")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.viewport_bounds.axis_y_labelaxisloc({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_y_labelextentloc(self, p0: str) -> int:
        """Specifies which bounds axis will receive labels
        
        Args:
            p0:
                'extent'
        
                * Can be any of the following:
                * min
                * max
                * both
        
        Examples:
            ::
        
                ensight.view.bounds("ON")
                ensight.viewport.select_begin(0)
                ensight.viewport_bounds.axis_x_labelextentloc("both")
                ensight.viewport_bounds.axis_y_labelextentloc("min")
                ensight.viewport_bounds.axis_z_labelextentloc("max")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.viewport_bounds.axis_y_labelextentloc({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_y_labelfilter(self, p0: str) -> int:
        """Viewport_bounds: axis_y_labelfilter

        """
        cmd = f'''ensight.viewport_bounds.axis_y_labelfilter({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_y_labelrgb(self, p0: float, p1: float, p2: float) -> int:
        """Set the color for the x/y/z axis labels
        
        Args:
            p0:
                'red_val' red, green, blue color components (must be between 0.0 and 1.0)
            p1:
                'grn_val' red, green, blue color components (must be between 0.0 and 1.0)
            p2:
                'blu_val' red, green, blue color components (must be between 0.0 and 1.0)
        
        Examples:
            ::
        
                ensight.view.bounds("ON")
                ensight.viewport.select_begin(0)
                ensight.viewport_bounds.axis_x_labelrgb(4.0000e-01,0.0000e+00,1.0000e+00)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.viewport_bounds.axis_y_labelrgb({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def axis_y_max(self, p0: float) -> int:
        """Sets the minimum value for the x/y/z axis
        
        | If the length attribute is set to rounded the resulting min/max x/y/z value will be modified from the specified value
        
        Args:
            p0:
                'min' the minimum axis value
            p1:
                'max' the maximum axis value
        
        Examples:
            ::
        
                ensight.view.bounds("ON")
                ensight.viewport.select_begin(0)
                ensight.viewport_bounds.axis_linewidth(1)
                ensight.viewport_bounds.axis_rgb(1.0000e+00,0.0000e+00,1.0000e+00)
                ensight.viewport_bounds.length("as_specified")
                ensight.viewport_bounds.axis_x_min(0.2)
                ensight.viewport_bounds.axis_x_max(0.6)
                ensight.viewport_bounds.axis_y_min(0.0)
                ensight.viewport_bounds.axis_y_max(1.0)
                ensight.viewport_bounds.axis_z_min(-1.)
                ensight.viewport_bounds.axis_z_max(1.)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.viewport_bounds.axis_y_max({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_y_min(self, p0: float) -> int:
        """Sets the minimum value for the x/y/z axis
        
        | If the length attribute is set to rounded the resulting min/max x/y/z value will be modified from the specified value
        
        Args:
            p0:
                'min' the minimum axis value
            p1:
                'max' the maximum axis value
        
        Examples:
            ::
        
                ensight.view.bounds("ON")
                ensight.viewport.select_begin(0)
                ensight.viewport_bounds.axis_linewidth(1)
                ensight.viewport_bounds.axis_rgb(1.0000e+00,0.0000e+00,1.0000e+00)
                ensight.viewport_bounds.length("as_specified")
                ensight.viewport_bounds.axis_x_min(0.2)
                ensight.viewport_bounds.axis_x_max(0.6)
                ensight.viewport_bounds.axis_y_min(0.0)
                ensight.viewport_bounds.axis_y_max(1.0)
                ensight.viewport_bounds.axis_z_min(-1.)
                ensight.viewport_bounds.axis_z_max(1.)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.viewport_bounds.axis_y_min({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_y_numgrid(self, p0: float) -> int:
        """Set the number of grid marks along the x/y/z axis
        
        | If the length attribute is set to rounded the resulting number of grid marks will be modified from the specified value.
        
        Args:
            p0:
                'num' the number of grid marks to be used
        
        Examples:
            ::
        
                ensight.view.bounds("ON")
                ensight.viewport.select_begin(0)
                ensight.viewport_bounds.axis_linewidth(1)
                ensight.viewport_bounds.axis_rgb(1.0000e+00,0.0000e+00,1.0000e+00)
                ensight.viewport_bounds.length("as_specified")
                ensight.viewport_bounds.axis_x_numgrid(5)
                ensight.viewport_bounds.axis_y_numgrid(3)
                ensight.viewport_bounds.axis_z_numgrid(7)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.viewport_bounds.axis_y_numgrid({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_y_numsubgrid(self, p0: float) -> int:
        """Set the number of subgrid marks along the x/y/z axis
        
        | If the length attribute is set to rounded the resulting number of subgrid marks will be modified from the specified value.
        
        Args:
            p0:
                'num' the number of subgrid marks to be used
        
        Examples:
            ::
        
                ensight.view.bounds("ON")
                ensight.viewport.select_begin(0)
                ensight.viewport_bounds.length("as_specified")
                ensight.viewport_bounds.axis_x_numsubgrid(2)
                ensight.viewport_bounds.axis_y_numsubgrid(2)
                ensight.viewport_bounds.axis_z_numsubgrid(3)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.viewport_bounds.axis_y_numsubgrid({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_y_orig(self, p0: float) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.viewport_bounds.axis_y_orig({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_y_sgridtype(self, p0: str) -> int:
        """Set the line type for the x/y/z subgrid bounds
        
        | If "grid", the line type is specified via the viewport_bounds: subgrid_linetype command
        
        Args:
            p0:
                'grid_type'
        
                * Can be any of the following:
                * none
                * grid
                * tick
        
        Examples:
            ::
        
                ensight.view.bounds("ON")
                ensight.viewport.select_begin(0)
                ensight.viewport_bounds.axis_x_sgridtype("solid")
                ensight.viewport_bounds.axis_y_sgridtype("none")
                ensight.viewport_bounds.axis_z_sgridtype("tick")
                ensight.viewport_bounds.subgrid_linetype("solid")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.viewport_bounds.axis_y_sgridtype({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_y_subtick(self, p0: str) -> int:
        """Viewport_bounds: axis_y_subtick

        """
        cmd = f'''ensight.viewport_bounds.axis_y_subtick({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_y_tick(self, p0: str) -> int:
        """Viewport_bounds: axis_y_tick

        """
        cmd = f'''ensight.viewport_bounds.axis_y_tick({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_y_title(self, p0: str) -> int:
        """Viewport_bounds: axis_y_title

        """
        cmd = f'''ensight.viewport_bounds.axis_y_title({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_y_titlesize(self, p0: int) -> int:
        """Viewport_bounds: axis_y_titlesize

        """
        cmd = f'''ensight.viewport_bounds.axis_y_titlesize({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_y_ymaxzmax(self, p0: str) -> int:
        """Viewport_bounds: axis_y_ymaxzmax

        """
        cmd = f'''ensight.viewport_bounds.axis_y_ymaxzmax({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_y_ymaxzmin(self, p0: str) -> int:
        """Viewport_bounds: axis_y_ymaxzmin

        """
        cmd = f'''ensight.viewport_bounds.axis_y_ymaxzmin({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_y_yminzmax(self, p0: str) -> int:
        """Viewport_bounds: axis_y_yminzmax

        """
        cmd = f'''ensight.viewport_bounds.axis_y_yminzmax({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_y_yminzmin(self, p0: str) -> int:
        """Viewport_bounds: axis_y_yminzmin

        """
        cmd = f'''ensight.viewport_bounds.axis_y_yminzmin({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_z_displayonedge(self, p0: str) -> int:
        """Viewport_bounds: axis_z_displayonedge

        """
        cmd = f'''ensight.viewport_bounds.axis_z_displayonedge({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_z_format(self, p0: str) -> int:
        """Specifies the format to be used for labels along the x/y/z axis
        
        Args:
            p0:
                'format' may be any valid C language format string
        
        Examples:
            ::
        
                ensight.view.bounds("ON")
                ensight.viewport.select_begin(0)
                ensight.viewport_bounds.axis_x_format("%.2f")
                ensight.viewport_bounds.axis_y_format("%g")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.viewport_bounds.axis_z_format({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_z_gridextentloc(self, p0: str) -> int:
        """Specifies which bounds will receive grids and subgrid lines
        
        Args:
            p0:
                'extent'
        
                * Can be any of the following:
                * min
                * max
                * both
        
        Examples:
            ::
        
                ensight.view.bounds("ON")
                ensight.viewport.select_begin(0)
                ensight.viewport_bounds.axis_x_gridextentloc("both")
                ensight.viewport_bounds.axis_y_gridextentloc("min")
                ensight.viewport_bounds.axis_z_gridextentloc("max")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.viewport_bounds.axis_z_gridextentloc({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_z_gridtype(self, p0: str) -> int:
        """Set the line type for the x/y/z grid bounds
        
        | If grid, the line type is specified via the viewport_bounds: grid_linetype command
        
        Args:
            p0:
                'grid_type'
        
                * Can be any of the following:
                * none
                * grid
                * tick
        
        Examples:
            ::
        
                ensight.view.bounds("ON")
                ensight.viewport.select_begin(0)
                ensight.viewport_bounds.axis_x_gridtype("solid")
                ensight.viewport_bounds.axis_y_gridtype("none")
                ensight.viewport_bounds.axis_z_gridtype("tick")
                ensight.viewport_bounds.grid_linetype("solid")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.viewport_bounds.axis_z_gridtype({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_z_labelaxisloc(self, p0: str) -> int:
        """Specifies the location for the x/y/z axis labels for bounds display
        
        | When label_location is "all", the number of labels is controlled by the viewport_bounds: axis_x/y/z_numgrid command
        
        Args:
            p0:
                'label_location'
        
                * Can be any of the following:
                * none
                * all
                * beg_end
        
        Examples:
            ::
        
                ensight.view.bounds("ON")
                ensight.viewport.select_begin(0)
                ensight.viewport_bounds.length("as_specified")
                ensight.viewport_bounds.axis_x_min(0.)
                ensight.viewport_bounds.axis_x_max(1.)
                ensight.viewport_bounds.axis_x_numgrid(5)
                ensight.viewport_bounds.axis_x_labelaxisloc("beg_end")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.viewport_bounds.axis_z_labelaxisloc({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_z_labelextentloc(self, p0: str) -> int:
        """Specifies which bounds axis will receive labels
        
        Args:
            p0:
                'extent'
        
                * Can be any of the following:
                * min
                * max
                * both
        
        Examples:
            ::
        
                ensight.view.bounds("ON")
                ensight.viewport.select_begin(0)
                ensight.viewport_bounds.axis_x_labelextentloc("both")
                ensight.viewport_bounds.axis_y_labelextentloc("min")
                ensight.viewport_bounds.axis_z_labelextentloc("max")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.viewport_bounds.axis_z_labelextentloc({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_z_labelfilter(self, p0: str) -> int:
        """Viewport_bounds: axis_z_labelfilter

        """
        cmd = f'''ensight.viewport_bounds.axis_z_labelfilter({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_z_labelrgb(self, p0: float, p1: float, p2: float) -> int:
        """Set the color for the x/y/z axis labels
        
        Args:
            p0:
                'red_val' red, green, blue color components (must be between 0.0 and 1.0)
            p1:
                'grn_val' red, green, blue color components (must be between 0.0 and 1.0)
            p2:
                'blu_val' red, green, blue color components (must be between 0.0 and 1.0)
        
        Examples:
            ::
        
                ensight.view.bounds("ON")
                ensight.viewport.select_begin(0)
                ensight.viewport_bounds.axis_x_labelrgb(4.0000e-01,0.0000e+00,1.0000e+00)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.viewport_bounds.axis_z_labelrgb({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def axis_z_max(self, p0: float) -> int:
        """Sets the minimum value for the x/y/z axis
        
        | If the length attribute is set to rounded the resulting min/max x/y/z value will be modified from the specified value
        
        Args:
            p0:
                'min' the minimum axis value
            p1:
                'max' the maximum axis value
        
        Examples:
            ::
        
                ensight.view.bounds("ON")
                ensight.viewport.select_begin(0)
                ensight.viewport_bounds.axis_linewidth(1)
                ensight.viewport_bounds.axis_rgb(1.0000e+00,0.0000e+00,1.0000e+00)
                ensight.viewport_bounds.length("as_specified")
                ensight.viewport_bounds.axis_x_min(0.2)
                ensight.viewport_bounds.axis_x_max(0.6)
                ensight.viewport_bounds.axis_y_min(0.0)
                ensight.viewport_bounds.axis_y_max(1.0)
                ensight.viewport_bounds.axis_z_min(-1.)
                ensight.viewport_bounds.axis_z_max(1.)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.viewport_bounds.axis_z_max({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_z_min(self, p0: float) -> int:
        """Sets the minimum value for the x/y/z axis
        
        | If the length attribute is set to rounded the resulting min/max x/y/z value will be modified from the specified value
        
        Args:
            p0:
                'min' the minimum axis value
            p1:
                'max' the maximum axis value
        
        Examples:
            ::
        
                ensight.view.bounds("ON")
                ensight.viewport.select_begin(0)
                ensight.viewport_bounds.axis_linewidth(1)
                ensight.viewport_bounds.axis_rgb(1.0000e+00,0.0000e+00,1.0000e+00)
                ensight.viewport_bounds.length("as_specified")
                ensight.viewport_bounds.axis_x_min(0.2)
                ensight.viewport_bounds.axis_x_max(0.6)
                ensight.viewport_bounds.axis_y_min(0.0)
                ensight.viewport_bounds.axis_y_max(1.0)
                ensight.viewport_bounds.axis_z_min(-1.)
                ensight.viewport_bounds.axis_z_max(1.)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.viewport_bounds.axis_z_min({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_z_numgrid(self, p0: float) -> int:
        """Set the number of grid marks along the x/y/z axis
        
        | If the length attribute is set to rounded the resulting number of grid marks will be modified from the specified value.
        
        Args:
            p0:
                'num' the number of grid marks to be used
        
        Examples:
            ::
        
                ensight.view.bounds("ON")
                ensight.viewport.select_begin(0)
                ensight.viewport_bounds.axis_linewidth(1)
                ensight.viewport_bounds.axis_rgb(1.0000e+00,0.0000e+00,1.0000e+00)
                ensight.viewport_bounds.length("as_specified")
                ensight.viewport_bounds.axis_x_numgrid(5)
                ensight.viewport_bounds.axis_y_numgrid(3)
                ensight.viewport_bounds.axis_z_numgrid(7)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.viewport_bounds.axis_z_numgrid({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_z_numsubgrid(self, p0: float) -> int:
        """Set the number of subgrid marks along the x/y/z axis
        
        | If the length attribute is set to rounded the resulting number of subgrid marks will be modified from the specified value.
        
        Args:
            p0:
                'num' the number of subgrid marks to be used
        
        Examples:
            ::
        
                ensight.view.bounds("ON")
                ensight.viewport.select_begin(0)
                ensight.viewport_bounds.length("as_specified")
                ensight.viewport_bounds.axis_x_numsubgrid(2)
                ensight.viewport_bounds.axis_y_numsubgrid(2)
                ensight.viewport_bounds.axis_z_numsubgrid(3)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.viewport_bounds.axis_z_numsubgrid({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_z_sgridtype(self, p0: str) -> int:
        """Set the line type for the x/y/z subgrid bounds
        
        | If "grid", the line type is specified via the viewport_bounds: subgrid_linetype command
        
        Args:
            p0:
                'grid_type'
        
                * Can be any of the following:
                * none
                * grid
                * tick
        
        Examples:
            ::
        
                ensight.view.bounds("ON")
                ensight.viewport.select_begin(0)
                ensight.viewport_bounds.axis_x_sgridtype("solid")
                ensight.viewport_bounds.axis_y_sgridtype("none")
                ensight.viewport_bounds.axis_z_sgridtype("tick")
                ensight.viewport_bounds.subgrid_linetype("solid")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.viewport_bounds.axis_z_sgridtype({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_z_subtick(self, p0: str) -> int:
        """Viewport_bounds: axis_z_subtick

        """
        cmd = f'''ensight.viewport_bounds.axis_z_subtick({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_z_tick(self, p0: str) -> int:
        """Viewport_bounds: axis_z_tick

        """
        cmd = f'''ensight.viewport_bounds.axis_z_tick({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_z_title(self, p0: str) -> int:
        """Viewport_bounds: axis_z_title

        """
        cmd = f'''ensight.viewport_bounds.axis_z_title({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_z_titlesize(self, p0: int) -> int:
        """Viewport_bounds: axis_z_titlesize

        """
        cmd = f'''ensight.viewport_bounds.axis_z_titlesize({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_z_ymaxzmax(self, p0: str) -> int:
        """Viewport_bounds: axis_z_ymaxzmax

        """
        cmd = f'''ensight.viewport_bounds.axis_z_ymaxzmax({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_z_ymaxzmin(self, p0: str) -> int:
        """Viewport_bounds: axis_z_ymaxzmin

        """
        cmd = f'''ensight.viewport_bounds.axis_z_ymaxzmin({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_z_yminzmax(self, p0: str) -> int:
        """Viewport_bounds: axis_z_yminzmax

        """
        cmd = f'''ensight.viewport_bounds.axis_z_yminzmax({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_z_yminzmin(self, p0: str) -> int:
        """Viewport_bounds: axis_z_yminzmin

        """
        cmd = f'''ensight.viewport_bounds.axis_z_yminzmin({repr(p0)})'''
        return self._session.cmd(cmd)

    def dimension(self, p0: str) -> int:
        """Set the bounds display to 2D or 3D.
        
        | The 2D option is only available for 2D viewports and 3D viewports display in orthographic mode.
        
        Args:
            p0:
                'dimension'
        
                * 2D
                * 3D
        
        Examples:
            ::
        
                # 
                # turn on bounds display and make the bounds for
                # viewport 0 2D
                #
                ensight.view.bounds("ON")
                ensight.viewport.select_begin(0)
                ensight.viewport_bounds.dimension("2D")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.viewport_bounds.dimension({repr(p0)})'''
        return self._session.cmd(cmd)

    def face_xmax_grid(self, p0: str) -> int:
        """Viewport_bounds: face_xmax_grid

        """
        cmd = f'''ensight.viewport_bounds.face_xmax_grid({repr(p0)})'''
        return self._session.cmd(cmd)

    def face_xmax_gridfilter(self, p0: str) -> int:
        """Viewport_bounds: face_xmax_gridfilter

        """
        cmd = f'''ensight.viewport_bounds.face_xmax_gridfilter({repr(p0)})'''
        return self._session.cmd(cmd)

    def face_xmax_subgrid(self, p0: str) -> int:
        """Viewport_bounds: face_xmax_subgrid

        """
        cmd = f'''ensight.viewport_bounds.face_xmax_subgrid({repr(p0)})'''
        return self._session.cmd(cmd)

    def face_xmin_grid(self, p0: str) -> int:
        """Viewport_bounds: face_xmin_grid

        """
        cmd = f'''ensight.viewport_bounds.face_xmin_grid({repr(p0)})'''
        return self._session.cmd(cmd)

    def face_xmin_gridfilter(self, p0: str) -> int:
        """Viewport_bounds: face_xmin_gridfilter

        """
        cmd = f'''ensight.viewport_bounds.face_xmin_gridfilter({repr(p0)})'''
        return self._session.cmd(cmd)

    def face_xmin_subgrid(self, p0: str) -> int:
        """Viewport_bounds: face_xmin_subgrid

        """
        cmd = f'''ensight.viewport_bounds.face_xmin_subgrid({repr(p0)})'''
        return self._session.cmd(cmd)

    def face_ymax_grid(self, p0: str) -> int:
        """Viewport_bounds: face_ymax_grid

        """
        cmd = f'''ensight.viewport_bounds.face_ymax_grid({repr(p0)})'''
        return self._session.cmd(cmd)

    def face_ymax_gridfilter(self, p0: str) -> int:
        """Viewport_bounds: face_ymax_gridfilter

        """
        cmd = f'''ensight.viewport_bounds.face_ymax_gridfilter({repr(p0)})'''
        return self._session.cmd(cmd)

    def face_ymax_subgrid(self, p0: str) -> int:
        """Viewport_bounds: face_ymax_subgrid

        """
        cmd = f'''ensight.viewport_bounds.face_ymax_subgrid({repr(p0)})'''
        return self._session.cmd(cmd)

    def face_ymin_grid(self, p0: str) -> int:
        """Viewport_bounds: face_ymin_grid

        """
        cmd = f'''ensight.viewport_bounds.face_ymin_grid({repr(p0)})'''
        return self._session.cmd(cmd)

    def face_ymin_gridfilter(self, p0: str) -> int:
        """Viewport_bounds: face_ymin_gridfilter

        """
        cmd = f'''ensight.viewport_bounds.face_ymin_gridfilter({repr(p0)})'''
        return self._session.cmd(cmd)

    def face_ymin_subgrid(self, p0: str) -> int:
        """Viewport_bounds: face_ymin_subgrid

        """
        cmd = f'''ensight.viewport_bounds.face_ymin_subgrid({repr(p0)})'''
        return self._session.cmd(cmd)

    def face_zmax_grid(self, p0: str) -> int:
        """Viewport_bounds: face_zmax_grid

        """
        cmd = f'''ensight.viewport_bounds.face_zmax_grid({repr(p0)})'''
        return self._session.cmd(cmd)

    def face_zmax_gridfilter(self, p0: str) -> int:
        """Viewport_bounds: face_zmax_gridfilter

        """
        cmd = f'''ensight.viewport_bounds.face_zmax_gridfilter({repr(p0)})'''
        return self._session.cmd(cmd)

    def face_zmax_subgrid(self, p0: str) -> int:
        """Viewport_bounds: face_zmax_subgrid

        """
        cmd = f'''ensight.viewport_bounds.face_zmax_subgrid({repr(p0)})'''
        return self._session.cmd(cmd)

    def face_zmin_grid(self, p0: str) -> int:
        """Viewport_bounds: face_zmin_grid

        """
        cmd = f'''ensight.viewport_bounds.face_zmin_grid({repr(p0)})'''
        return self._session.cmd(cmd)

    def face_zmin_gridfilter(self, p0: str) -> int:
        """Viewport_bounds: face_zmin_gridfilter

        """
        cmd = f'''ensight.viewport_bounds.face_zmin_gridfilter({repr(p0)})'''
        return self._session.cmd(cmd)

    def face_zmin_subgrid(self, p0: str) -> int:
        """Viewport_bounds: face_zmin_subgrid

        """
        cmd = f'''ensight.viewport_bounds.face_zmin_subgrid({repr(p0)})'''
        return self._session.cmd(cmd)

    def grid_linetype(self, p0: str) -> int:
        """Specifies the type of grid lines that will be drawn for bounds display.
        
        Args:
            p0:
                'line_type'
        
                * Can be any of the following:
                * solid
                * dotted
                * dash
        
        Examples:
            ::
        
                ensight.view.bounds("ON")
                ensight.viewport.select_begin(0)
                ensight.viewport_bounds.visible("ON")
                ensight.viewport_bounds.grid_linewidth(2)
                ensight.viewport_bounds.grid_linetype("dotted")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.viewport_bounds.grid_linetype({repr(p0)})'''
        return self._session.cmd(cmd)

    def grid_linewidth(self, p0: int) -> int:
        """Set the bounds axis grid line width
        
        Args:
            p0:
                'width' specifies the width in pixels
        
        Examples:
            ::
        
                ensight.view.bounds("ON")
                ensight.viewport.select_begin(0)
                ensight.viewport_bounds.visible("ON")
                ensight.viewport_bounds.grid_linewidth(2)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.viewport_bounds.grid_linewidth({repr(p0)})'''
        return self._session.cmd(cmd)

    def grid_rgb(self, p0: float, p1: float, p2: float) -> int:
        """Set the color for the bounds grid lines
        
        Args:
            p0:
                'red_val' red, green, blue color components (must be between 0.0 and 1.0)
            p1:
                'grn_val' red, green, blue color components (must be between 0.0 and 1.0)
            p2:
                'blu_val' red, green, blue color components (must be between 0.0 and 1.0)
        
        Examples:
            ::
        
                ensight.view.bounds("ON")
                ensight.viewport.select_begin(0)
                ensight.viewport_bounds.visible("ON")
                ensight.viewport_bounds.grid_linewidth(2)
                ensight.viewport_bounds.grid_rgb(0.5,1,0)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.viewport_bounds.grid_rgb({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def label_size(self, p0: float) -> int:
        """Viewport_bounds: label_size

        """
        cmd = f'''ensight.viewport_bounds.label_size({repr(p0)})'''
        return self._session.cmd(cmd)

    def label_size_2d(self, p0: int) -> int:
        """Viewport_bounds: label_size_2d

        """
        cmd = f'''ensight.viewport_bounds.label_size_2d({repr(p0)})'''
        return self._session.cmd(cmd)

    def label_size_3d(self, p0: int) -> int:
        """Viewport_bounds: label_size_3d

        """
        cmd = f'''ensight.viewport_bounds.label_size_3d({repr(p0)})'''
        return self._session.cmd(cmd)

    def length(self, p0: str) -> int:
        """Use min/max information as specified or use round numbers
        
        Args:
            p0:
                'size_option'
        
                * as_specified
                * rounded
        
        Examples:
            ::
        
                ensight.view.bounds("ON")
                ensight.viewport.select_begin(0)
                ensight.viewport_bounds.visible("ON")
                ensight.viewport_bounds.axis_linewidth(1)
                ensight.viewport_bounds.length("as_specified")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.viewport_bounds.length({repr(p0)})'''
        return self._session.cmd(cmd)

    def subgrid_linetype(self, p0: str) -> int:
        """Specifies the type of subgrid lines that will be drawn for bounds display.
        
        Args:
            p0:
                'line_type'
        
                * Can be any of the following:
                * solid
                * dotted
                * dash
        
        Examples:
            ::
        
                ensight.view.bounds("ON")
                ensight.viewport.select_begin(0)
                ensight.viewport_bounds.visible("ON")
                ensight.viewport_bounds.subgrid_linewidth(2)
                ensight.viewport_bounds.subgrid_linetype("dotted")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.viewport_bounds.subgrid_linetype({repr(p0)})'''
        return self._session.cmd(cmd)

    def subgrid_linewidth(self, p0: int) -> int:
        """Set the bounds axis subgrid line width
        
        Args:
            p0:
                'width' specifies the width in pixels
        
        Examples:
            ::
        
                ensight.view.bounds("ON")
                ensight.viewport.select_begin(0)
                ensight.viewport_bounds.visible("ON")
                ensight.viewport_bounds.subgrid_linewidth(2)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.viewport_bounds.subgrid_linewidth({repr(p0)})'''
        return self._session.cmd(cmd)

    def subgrid_rgb(self, p0: float, p1: float, p2: float) -> int:
        """Set the color for the bounds subgrid lines
        
        Args:
            p0:
                'red_val' red, green, blue color components (must be between 0.0 and 1.0)
            p1:
                'grn_val' red, green, blue color components (must be between 0.0 and 1.0)
            p2:
                'blu_val' red, green, blue color components (must be between 0.0 and 1.0)
        
        Examples:
            ::
        
                ensight.view.bounds("ON")
                ensight.viewport.select_begin(0)
                ensight.viewport_bounds.visible("ON")
                ensight.viewport_bounds.subgrid_linewidth(2)
                ensight.viewport_bounds.subgrid_rgb(0.5,0.5,0.5)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.viewport_bounds.subgrid_rgb({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def subtick_scale_factor(self, p0: float) -> int:
        """Viewport_bounds: subtick_scale_factor

        """
        cmd = f'''ensight.viewport_bounds.subtick_scale_factor({repr(p0)})'''
        return self._session.cmd(cmd)

    def tick_scale_factor(self, p0: float) -> int:
        """Viewport_bounds: tick_scale_factor

        """
        cmd = f'''ensight.viewport_bounds.tick_scale_factor({repr(p0)})'''
        return self._session.cmd(cmd)

    def transparency(self, p0: float) -> int:
        """Sets the opaqueness for the bounds display
        
        Args:
            p0:
                'value' opaqueness value
            p1:
                'value' opaqueness value
        
        Examples:
            ::
        
                ensight.view.bounds("ON")
                ensight.viewport.select_begin(0)
                ensight.viewport_bounds.transparency(0.5)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.viewport_bounds.transparency({repr(p0)})'''
        return self._session.cmd(cmd)

    def visible(self, p0: str) -> int:
        """Turn on bounds display for a viewport
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                #
                # turn on bounds display but turn the bounds off for viewport 1
                #
                ensight.view.bounds("ON")
                ensight.viewport.select_begin(1)
                ensight.viewport_bounds.visible("OFF")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.viewport_bounds.visible({repr(p0)})'''
        return self._session.cmd(cmd)


class viewport_axis:
    """Class wrapper for EnSight viewport_axis module

    This class acts as a proxy for the EnSight Python module ensight.viewport_axis
    """
    def __init__(self, session: Session):
        self._session = session

    def auto_size(self, p0: str) -> int:
        """Viewport_axis: auto_size

        """
        cmd = f'''ensight.viewport_axis.auto_size({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_height(self, p0: float) -> int:
        """Viewport_axis: axis_height

        """
        cmd = f'''ensight.viewport_axis.axis_height({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_linewidth(self, p0: int) -> int:
        """Viewport_axis: axis_linewidth

        """
        cmd = f'''ensight.viewport_axis.axis_linewidth({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_rgb(self, p0: float, p1: float, p2: float) -> int:
        """Viewport_axis: axis_rgb

        """
        cmd = f'''ensight.viewport_axis.axis_rgb({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def axis_width(self, p0: float) -> int:
        """Viewport_axis: axis_width

        """
        cmd = f'''ensight.viewport_axis.axis_width({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_x_displayonedge(self, p0: str) -> int:
        """Viewport_axis: axis_x_displayonedge

        """
        cmd = f'''ensight.viewport_axis.axis_x_displayonedge({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_x_format(self, p0: str) -> int:
        """Viewport_axis: axis_x_format

        """
        cmd = f'''ensight.viewport_axis.axis_x_format({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_x_gridextentloc(self, p0: str) -> int:
        """Viewport_axis: axis_x_gridextentloc

        """
        cmd = f'''ensight.viewport_axis.axis_x_gridextentloc({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_x_gridtype(self, p0: str) -> int:
        """Viewport_axis: axis_x_gridtype

        """
        cmd = f'''ensight.viewport_axis.axis_x_gridtype({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_x_labelaxisloc(self, p0: str) -> int:
        """Viewport_axis: axis_x_labelaxisloc

        """
        cmd = f'''ensight.viewport_axis.axis_x_labelaxisloc({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_x_labelextentloc(self, p0: str) -> int:
        """Viewport_axis: axis_x_labelextentloc

        """
        cmd = f'''ensight.viewport_axis.axis_x_labelextentloc({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_x_labelfilter(self, p0: str) -> int:
        """Viewport_axis: axis_x_labelfilter

        """
        cmd = f'''ensight.viewport_axis.axis_x_labelfilter({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_x_labelrgb(self, p0: float, p1: float, p2: float) -> int:
        """Viewport_axis: axis_x_labelrgb

        """
        cmd = f'''ensight.viewport_axis.axis_x_labelrgb({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def axis_x_max(self, p0: float) -> int:
        """Viewport_axis: axis_x_max

        """
        cmd = f'''ensight.viewport_axis.axis_x_max({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_x_min(self, p0: float) -> int:
        """Viewport_axis: axis_x_min

        """
        cmd = f'''ensight.viewport_axis.axis_x_min({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_x_numgrid(self, p0: float) -> int:
        """Viewport_axis: axis_x_numgrid

        """
        cmd = f'''ensight.viewport_axis.axis_x_numgrid({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_x_numsubgrid(self, p0: float) -> int:
        """Viewport_axis: axis_x_numsubgrid

        """
        cmd = f'''ensight.viewport_axis.axis_x_numsubgrid({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_x_orig(self, p0: float) -> int:
        """Viewport_axis: axis_x_orig

        """
        cmd = f'''ensight.viewport_axis.axis_x_orig({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_x_sgridtype(self, p0: str) -> int:
        """Viewport_axis: axis_x_sgridtype

        """
        cmd = f'''ensight.viewport_axis.axis_x_sgridtype({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_x_subtick(self, p0: str) -> int:
        """Viewport_axis: axis_x_subtick

        """
        cmd = f'''ensight.viewport_axis.axis_x_subtick({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_x_tick(self, p0: str) -> int:
        """Viewport_axis: axis_x_tick

        """
        cmd = f'''ensight.viewport_axis.axis_x_tick({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_x_title(self, p0: str) -> int:
        """Viewport_axis: axis_x_title

        """
        cmd = f'''ensight.viewport_axis.axis_x_title({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_x_titlesize(self, p0: int) -> int:
        """Viewport_axis: axis_x_titlesize

        """
        cmd = f'''ensight.viewport_axis.axis_x_titlesize({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_x_ymaxzmax(self, p0: str) -> int:
        """Viewport_axis: axis_x_ymaxzmax

        """
        cmd = f'''ensight.viewport_axis.axis_x_ymaxzmax({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_x_ymaxzmin(self, p0: str) -> int:
        """Viewport_axis: axis_x_ymaxzmin

        """
        cmd = f'''ensight.viewport_axis.axis_x_ymaxzmin({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_x_yminzmax(self, p0: str) -> int:
        """Viewport_axis: axis_x_yminzmax

        """
        cmd = f'''ensight.viewport_axis.axis_x_yminzmax({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_x_yminzmin(self, p0: str) -> int:
        """Viewport_axis: axis_x_yminzmin

        """
        cmd = f'''ensight.viewport_axis.axis_x_yminzmin({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_y_displayonedge(self, p0: str) -> int:
        """Viewport_axis: axis_y_displayonedge

        """
        cmd = f'''ensight.viewport_axis.axis_y_displayonedge({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_y_format(self, p0: str) -> int:
        """Viewport_axis: axis_y_format

        """
        cmd = f'''ensight.viewport_axis.axis_y_format({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_y_gridextentloc(self, p0: str) -> int:
        """Viewport_axis: axis_y_gridextentloc

        """
        cmd = f'''ensight.viewport_axis.axis_y_gridextentloc({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_y_gridtype(self, p0: str) -> int:
        """Viewport_axis: axis_y_gridtype

        """
        cmd = f'''ensight.viewport_axis.axis_y_gridtype({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_y_labelaxisloc(self, p0: str) -> int:
        """Viewport_axis: axis_y_labelaxisloc

        """
        cmd = f'''ensight.viewport_axis.axis_y_labelaxisloc({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_y_labelextentloc(self, p0: str) -> int:
        """Viewport_axis: axis_y_labelextentloc

        """
        cmd = f'''ensight.viewport_axis.axis_y_labelextentloc({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_y_labelfilter(self, p0: str) -> int:
        """Viewport_axis: axis_y_labelfilter

        """
        cmd = f'''ensight.viewport_axis.axis_y_labelfilter({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_y_labelrgb(self, p0: float, p1: float, p2: float) -> int:
        """Viewport_axis: axis_y_labelrgb

        """
        cmd = f'''ensight.viewport_axis.axis_y_labelrgb({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def axis_y_max(self, p0: float) -> int:
        """Viewport_axis: axis_y_max

        """
        cmd = f'''ensight.viewport_axis.axis_y_max({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_y_min(self, p0: float) -> int:
        """Viewport_axis: axis_y_min

        """
        cmd = f'''ensight.viewport_axis.axis_y_min({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_y_numgrid(self, p0: float) -> int:
        """Viewport_axis: axis_y_numgrid

        """
        cmd = f'''ensight.viewport_axis.axis_y_numgrid({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_y_numsubgrid(self, p0: float) -> int:
        """Viewport_axis: axis_y_numsubgrid

        """
        cmd = f'''ensight.viewport_axis.axis_y_numsubgrid({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_y_orig(self, p0: float) -> int:
        """Viewport_axis: axis_y_orig

        """
        cmd = f'''ensight.viewport_axis.axis_y_orig({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_y_sgridtype(self, p0: str) -> int:
        """Viewport_axis: axis_y_sgridtype

        """
        cmd = f'''ensight.viewport_axis.axis_y_sgridtype({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_y_subtick(self, p0: str) -> int:
        """Viewport_axis: axis_y_subtick

        """
        cmd = f'''ensight.viewport_axis.axis_y_subtick({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_y_tick(self, p0: str) -> int:
        """Viewport_axis: axis_y_tick

        """
        cmd = f'''ensight.viewport_axis.axis_y_tick({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_y_title(self, p0: str) -> int:
        """Viewport_axis: axis_y_title

        """
        cmd = f'''ensight.viewport_axis.axis_y_title({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_y_titlesize(self, p0: int) -> int:
        """Viewport_axis: axis_y_titlesize

        """
        cmd = f'''ensight.viewport_axis.axis_y_titlesize({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_y_ymaxzmax(self, p0: str) -> int:
        """Viewport_axis: axis_y_ymaxzmax

        """
        cmd = f'''ensight.viewport_axis.axis_y_ymaxzmax({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_y_ymaxzmin(self, p0: str) -> int:
        """Viewport_axis: axis_y_ymaxzmin

        """
        cmd = f'''ensight.viewport_axis.axis_y_ymaxzmin({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_y_yminzmax(self, p0: str) -> int:
        """Viewport_axis: axis_y_yminzmax

        """
        cmd = f'''ensight.viewport_axis.axis_y_yminzmax({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_y_yminzmin(self, p0: str) -> int:
        """Viewport_axis: axis_y_yminzmin

        """
        cmd = f'''ensight.viewport_axis.axis_y_yminzmin({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_z_displayonedge(self, p0: str) -> int:
        """Viewport_axis: axis_z_displayonedge

        """
        cmd = f'''ensight.viewport_axis.axis_z_displayonedge({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_z_format(self, p0: str) -> int:
        """Viewport_axis: axis_z_format

        """
        cmd = f'''ensight.viewport_axis.axis_z_format({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_z_gridextentloc(self, p0: str) -> int:
        """Viewport_axis: axis_z_gridextentloc

        """
        cmd = f'''ensight.viewport_axis.axis_z_gridextentloc({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_z_gridtype(self, p0: str) -> int:
        """Viewport_axis: axis_z_gridtype

        """
        cmd = f'''ensight.viewport_axis.axis_z_gridtype({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_z_labelaxisloc(self, p0: str) -> int:
        """Viewport_axis: axis_z_labelaxisloc

        """
        cmd = f'''ensight.viewport_axis.axis_z_labelaxisloc({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_z_labelextentloc(self, p0: str) -> int:
        """Viewport_axis: axis_z_labelextentloc

        """
        cmd = f'''ensight.viewport_axis.axis_z_labelextentloc({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_z_labelfilter(self, p0: str) -> int:
        """Viewport_axis: axis_z_labelfilter

        """
        cmd = f'''ensight.viewport_axis.axis_z_labelfilter({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_z_labelrgb(self, p0: float, p1: float, p2: float) -> int:
        """Viewport_axis: axis_z_labelrgb

        """
        cmd = f'''ensight.viewport_axis.axis_z_labelrgb({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def axis_z_max(self, p0: float) -> int:
        """Viewport_axis: axis_z_max

        """
        cmd = f'''ensight.viewport_axis.axis_z_max({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_z_min(self, p0: float) -> int:
        """Viewport_axis: axis_z_min

        """
        cmd = f'''ensight.viewport_axis.axis_z_min({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_z_numgrid(self, p0: float) -> int:
        """Viewport_axis: axis_z_numgrid

        """
        cmd = f'''ensight.viewport_axis.axis_z_numgrid({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_z_numsubgrid(self, p0: float) -> int:
        """Viewport_axis: axis_z_numsubgrid

        """
        cmd = f'''ensight.viewport_axis.axis_z_numsubgrid({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_z_sgridtype(self, p0: str) -> int:
        """Viewport_axis: axis_z_sgridtype

        """
        cmd = f'''ensight.viewport_axis.axis_z_sgridtype({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_z_subtick(self, p0: str) -> int:
        """Viewport_axis: axis_z_subtick

        """
        cmd = f'''ensight.viewport_axis.axis_z_subtick({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_z_tick(self, p0: str) -> int:
        """Viewport_axis: axis_z_tick

        """
        cmd = f'''ensight.viewport_axis.axis_z_tick({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_z_title(self, p0: str) -> int:
        """Viewport_axis: axis_z_title

        """
        cmd = f'''ensight.viewport_axis.axis_z_title({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_z_titlesize(self, p0: int) -> int:
        """Viewport_axis: axis_z_titlesize

        """
        cmd = f'''ensight.viewport_axis.axis_z_titlesize({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_z_ymaxzmax(self, p0: str) -> int:
        """Viewport_axis: axis_z_ymaxzmax

        """
        cmd = f'''ensight.viewport_axis.axis_z_ymaxzmax({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_z_ymaxzmin(self, p0: str) -> int:
        """Viewport_axis: axis_z_ymaxzmin

        """
        cmd = f'''ensight.viewport_axis.axis_z_ymaxzmin({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_z_yminzmax(self, p0: str) -> int:
        """Viewport_axis: axis_z_yminzmax

        """
        cmd = f'''ensight.viewport_axis.axis_z_yminzmax({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_z_yminzmin(self, p0: str) -> int:
        """Viewport_axis: axis_z_yminzmin

        """
        cmd = f'''ensight.viewport_axis.axis_z_yminzmin({repr(p0)})'''
        return self._session.cmd(cmd)

    def dimension(self, p0: str) -> int:
        """Viewport_axis: dimension

        """
        cmd = f'''ensight.viewport_axis.dimension({repr(p0)})'''
        return self._session.cmd(cmd)

    def face_xmax_grid(self, p0: str) -> int:
        """Viewport_axis: face_xmax_grid

        """
        cmd = f'''ensight.viewport_axis.face_xmax_grid({repr(p0)})'''
        return self._session.cmd(cmd)

    def face_xmax_gridfilter(self, p0: str) -> int:
        """Viewport_axis: face_xmax_gridfilter

        """
        cmd = f'''ensight.viewport_axis.face_xmax_gridfilter({repr(p0)})'''
        return self._session.cmd(cmd)

    def face_xmax_subgrid(self, p0: str) -> int:
        """Viewport_axis: face_xmax_subgrid

        """
        cmd = f'''ensight.viewport_axis.face_xmax_subgrid({repr(p0)})'''
        return self._session.cmd(cmd)

    def face_xmin_grid(self, p0: str) -> int:
        """Viewport_axis: face_xmin_grid

        """
        cmd = f'''ensight.viewport_axis.face_xmin_grid({repr(p0)})'''
        return self._session.cmd(cmd)

    def face_xmin_gridfilter(self, p0: str) -> int:
        """Viewport_axis: face_xmin_gridfilter

        """
        cmd = f'''ensight.viewport_axis.face_xmin_gridfilter({repr(p0)})'''
        return self._session.cmd(cmd)

    def face_xmin_subgrid(self, p0: str) -> int:
        """Viewport_axis: face_xmin_subgrid

        """
        cmd = f'''ensight.viewport_axis.face_xmin_subgrid({repr(p0)})'''
        return self._session.cmd(cmd)

    def face_ymax_grid(self, p0: str) -> int:
        """Viewport_axis: face_ymax_grid

        """
        cmd = f'''ensight.viewport_axis.face_ymax_grid({repr(p0)})'''
        return self._session.cmd(cmd)

    def face_ymax_gridfilter(self, p0: str) -> int:
        """Viewport_axis: face_ymax_gridfilter

        """
        cmd = f'''ensight.viewport_axis.face_ymax_gridfilter({repr(p0)})'''
        return self._session.cmd(cmd)

    def face_ymax_subgrid(self, p0: str) -> int:
        """Viewport_axis: face_ymax_subgrid

        """
        cmd = f'''ensight.viewport_axis.face_ymax_subgrid({repr(p0)})'''
        return self._session.cmd(cmd)

    def face_ymin_grid(self, p0: str) -> int:
        """Viewport_axis: face_ymin_grid

        """
        cmd = f'''ensight.viewport_axis.face_ymin_grid({repr(p0)})'''
        return self._session.cmd(cmd)

    def face_ymin_gridfilter(self, p0: str) -> int:
        """Viewport_axis: face_ymin_gridfilter

        """
        cmd = f'''ensight.viewport_axis.face_ymin_gridfilter({repr(p0)})'''
        return self._session.cmd(cmd)

    def face_ymin_subgrid(self, p0: str) -> int:
        """Viewport_axis: face_ymin_subgrid

        """
        cmd = f'''ensight.viewport_axis.face_ymin_subgrid({repr(p0)})'''
        return self._session.cmd(cmd)

    def face_zmax_grid(self, p0: str) -> int:
        """Viewport_axis: face_zmax_grid

        """
        cmd = f'''ensight.viewport_axis.face_zmax_grid({repr(p0)})'''
        return self._session.cmd(cmd)

    def face_zmax_gridfilter(self, p0: str) -> int:
        """Viewport_axis: face_zmax_gridfilter

        """
        cmd = f'''ensight.viewport_axis.face_zmax_gridfilter({repr(p0)})'''
        return self._session.cmd(cmd)

    def face_zmax_subgrid(self, p0: str) -> int:
        """Viewport_axis: face_zmax_subgrid

        """
        cmd = f'''ensight.viewport_axis.face_zmax_subgrid({repr(p0)})'''
        return self._session.cmd(cmd)

    def face_zmin_grid(self, p0: str) -> int:
        """Viewport_axis: face_zmin_grid

        """
        cmd = f'''ensight.viewport_axis.face_zmin_grid({repr(p0)})'''
        return self._session.cmd(cmd)

    def face_zmin_gridfilter(self, p0: str) -> int:
        """Viewport_axis: face_zmin_gridfilter

        """
        cmd = f'''ensight.viewport_axis.face_zmin_gridfilter({repr(p0)})'''
        return self._session.cmd(cmd)

    def face_zmin_subgrid(self, p0: str) -> int:
        """Viewport_axis: face_zmin_subgrid

        """
        cmd = f'''ensight.viewport_axis.face_zmin_subgrid({repr(p0)})'''
        return self._session.cmd(cmd)

    def grid_linetype(self, p0: str) -> int:
        """Viewport_axis: grid_linetype

        """
        cmd = f'''ensight.viewport_axis.grid_linetype({repr(p0)})'''
        return self._session.cmd(cmd)

    def grid_linewidth(self, p0: int) -> int:
        """Viewport_axis: grid_linewidth

        """
        cmd = f'''ensight.viewport_axis.grid_linewidth({repr(p0)})'''
        return self._session.cmd(cmd)

    def grid_rgb(self, p0: float, p1: float, p2: float) -> int:
        """Viewport_axis: grid_rgb

        """
        cmd = f'''ensight.viewport_axis.grid_rgb({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def label_size(self, p0: float) -> int:
        """Viewport_axis: label_size

        """
        cmd = f'''ensight.viewport_axis.label_size({repr(p0)})'''
        return self._session.cmd(cmd)

    def label_size_2d(self, p0: int) -> int:
        """Viewport_axis: label_size_2d

        """
        cmd = f'''ensight.viewport_axis.label_size_2d({repr(p0)})'''
        return self._session.cmd(cmd)

    def label_size_3d(self, p0: int) -> int:
        """Viewport_axis: label_size_3d

        """
        cmd = f'''ensight.viewport_axis.label_size_3d({repr(p0)})'''
        return self._session.cmd(cmd)

    def length(self, p0: str) -> int:
        """Viewport_axis: length

        """
        cmd = f'''ensight.viewport_axis.length({repr(p0)})'''
        return self._session.cmd(cmd)

    def subgrid_linetype(self, p0: str) -> int:
        """Viewport_axis: subgrid_linetype

        """
        cmd = f'''ensight.viewport_axis.subgrid_linetype({repr(p0)})'''
        return self._session.cmd(cmd)

    def subgrid_linewidth(self, p0: int) -> int:
        """Viewport_axis: subgrid_linewidth

        """
        cmd = f'''ensight.viewport_axis.subgrid_linewidth({repr(p0)})'''
        return self._session.cmd(cmd)

    def subgrid_rgb(self, p0: float, p1: float, p2: float) -> int:
        """Viewport_axis: subgrid_rgb

        """
        cmd = f'''ensight.viewport_axis.subgrid_rgb({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def subtick_scale_factor(self, p0: float) -> int:
        """Viewport_axis: subtick_scale_factor

        """
        cmd = f'''ensight.viewport_axis.subtick_scale_factor({repr(p0)})'''
        return self._session.cmd(cmd)

    def tick_scale_factor(self, p0: float) -> int:
        """Viewport_axis: tick_scale_factor

        """
        cmd = f'''ensight.viewport_axis.tick_scale_factor({repr(p0)})'''
        return self._session.cmd(cmd)

    def transparency(self, p0: float) -> int:
        """Viewport_axis: transparency

        """
        cmd = f'''ensight.viewport_axis.transparency({repr(p0)})'''
        return self._session.cmd(cmd)

    def visible(self, p0: str) -> int:
        """Viewport_axis: visible

        """
        cmd = f'''ensight.viewport_axis.visible({repr(p0)})'''
        return self._session.cmd(cmd)


class viewport:
    """Class wrapper for EnSight viewport module

    This class acts as a proxy for the EnSight Python module ensight.viewport
    """
    def __init__(self, session: Session):
        self._session = session

    def _raise(self) -> int:
        """Viewport: raise

        """
        cmd = f'''ensight.viewport._raise()'''
        return self._session.cmd(cmd)

    def auto_centering(self, p0: str) -> int:
        """Viewport: auto_centering

        """
        cmd = f'''ensight.viewport.auto_centering({repr(p0)})'''
        return self._session.cmd(cmd)

    def background_image(self, p0: str) -> int:
        """Specify the image file to be used as the background for the selected viewport(s).
        
        | Image file types supported are:  xpm and bmp
        
        Args:
            p0:
                'filename' the image file to use as the background
        
        Examples:
            ::
        
                ensight.viewport.select_begin(0)
                ensight.viewport.background_type("image")
                ensight.viewport.background_image("/tmp/mybackground.xpm")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.viewport.background_image({repr(p0)})'''
        return self._session.cmd(cmd)

    def background_type(self, p0: str) -> int:
        """Specify the type of background to be displayed for the selected viewport(s).
        
        Args:
            p0:
                'type'
        
                * the following types are applied to the selected viewports
                * blended
                * constant
                * inherit
                * image
                * transparent
        
        Examples:
            ::
        
                ensight.viewport.select_begin(0)
                ensight.viewport.background_type("blended")
                ensight.viewport.blend_levels(3)
                ensight.viewport.blend_editlevel(1)
                ensight.viewport.blend_rgb(1.0000e+00,1.0000e+00,1.0000e+00)
                ensight.viewport.blend_editlevel(2)
                ensight.viewport.blend_rgb(0.0000e+00,0.0000e+00,1.0000e+00)
                ensight.viewport.blend_editlevel(3)
                ensight.viewport.blend_position(3.2000e-01)
                ensight.viewport.blend_rgb(0.0000e+00,0.0000e+00,0.0000e+00)
                ensight.viewport.select_begin(1)
                ensight.viewport.background_type("inherit")
                ensight.viewport.select_begin(2)
                ensight.viewport.background_type("constant")
                ensight.viewport.constant_rgb(0.0000e+00,0.0000e+00,0.0000e+00)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.viewport.background_type({repr(p0)})'''
        return self._session.cmd(cmd)

    def blend_editlevel(self, p0: int) -> int:
        """Specify the level to edit of the corresponding blended background type for the selected viewport(s), i.e. used to edit either the position or color of the level.
        
        Args:
            p0:
                'level_num' specified level number for the blended background type
        
        Examples:
            ::
        
                ensight.viewport.select_begin(0)
                ensight.viewport.background_type("blended")
                ensight.viewport.blend_levels(3)
                ensight.viewport.blend_editlevel(1)
                ensight.viewport.blend_rgb(1.0000e+00,1.0000e+00,1.0000e+00)
                ensight.viewport.blend_editlevel(2)
                ensight.viewport.blend_rgb(0.0000e+00,0.0000e+00,1.0000e+00)
                ensight.viewport.blend_editlevel(3)
                ensight.viewport.blend_position(3.2000e-01)
                ensight.viewport.blend_rgb(0.0000e+00,0.0000e+00,0.0000e+00)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.viewport.blend_editlevel({repr(p0)})'''
        return self._session.cmd(cmd)

    def blend_levels(self, p0: int) -> int:
        """Specify the number of (vertical) levels of the corresponding blended background type for the selected viewport(s).
        
        Args:
            p0:
                'num' number of levels in I[1,n] for the blended background type
        
        Examples:
            ::
        
                ensight.viewport.select_begin(0)
                ensight.viewport.blend_levels(3)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.viewport.blend_levels({repr(p0)})'''
        return self._session.cmd(cmd)

    def blend_position(self, p0: float) -> int:
        """Specify the position of the specified blend level of the corresponding blended background type for the selected viewport(s).
        
        | Blend level 0 must be located at 0.
        | Blend level N must be locted at 1.
        | Blend level N must be > N-1.
        
        Args:
            p0:
                'position' normalized position in I[0.,1.] for the blended background level
        
        Examples:
            ::
        
                ensight.viewport.select_begin(0)
                ensight.viewport.background_type("blended")
                ensight.viewport.blend_levels(3)
                ensight.viewport.blend_editlevel(2)
                ensight.viewport.blend_position(3.2000e-01)
                ensight.viewport.blend_rgb(0.0000e+00,0.0000e+00,1.0000e+00)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.viewport.blend_position({repr(p0)})'''
        return self._session.cmd(cmd)

    def blend_rgb(self, p0: float, p1: float, p2: float) -> int:
        """Specify the red, green and blue components of the blended background color for the specified level of the selected viewport(s).
        
        Args:
            p0:
                'red_val' red, green, blue color component values given in I[0.,1.]
            p1:
                'grn_val' red, green, blue color component values given in I[0.,1.]
            p2:
                'blu_val' red, green, blue color component values given in I[0.,1.]
        
        Examples:
            ::
        
                ensight.viewport.select_begin(0)
                ensight.viewport.background_type("blended")
                ensight.viewport.blend_levels(3)
                ensight.viewport.blend_editlevel(2)
                ensight.viewport.blend_position(3.2000e-01)
                ensight.viewport.blend_rgb(0.0000e+00,0.0000e+00,1.0000e+00)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.viewport.blend_rgb({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def border_rgb(self, p0: float, p1: float, p2: float) -> int:
        """Set the color for the viewport border.
        
        | By default the border color is white.
        | Used only if viewport: border_visible is ON.
        
        Args:
            p0:
                'red_val' red, green, blue color component values given in I[0.,1.]
            p1:
                'grn_val' red, green, blue color component values given in I[0.,1.]
            p2:
                'blu_val' red, green, blue color component values given in I[0.,1.]
        
        Examples:
            ::
        
                ensight.viewport.select_begin(1)
                ensight.viewport.border_rgb(1.,0.,1.)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.viewport.border_rgb({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def border_visible(self, p0: str) -> int:
        """Set visibility of viewport border.
        
        | Viewport borders are on by default.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF 
        
        Examples:
            ::
        
                ensight.viewport.select_begin(1)
                ensight.viewport.border_visible("OFF")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.viewport.border_visible({repr(p0)})'''
        return self._session.cmd(cmd)

    def constant_rgb(self, p0: float, p1: float, p2: float) -> int:
        """Specify the red, green and blue components of the constant background color for the selected viewport(s)
        
        Args:
            p0:
                'red_val' red, green, blue color component values given in I[0.,1.]
            p1:
                'grn_val' red, green, blue color component values given in I[0.,1.]
            p2:
                'blu_val' red, green, blue color component values given in I[0.,1.]
        
        Examples:
            ::
        
                ensight.viewport.select_begin(2)
                ensight.viewport.background_type("constant")
                ensight.viewport.constant_rgb(0.0000e+00,0.0000e+00,0.0000e+00)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.viewport.constant_rgb({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def delete(self) -> int:
        """Delete all selected viewports.
        
        | After selected viewports have been deleted, the main viewport (0) will be selected.
        | The main viewport (0) cannot be deleted.
        
        Examples:
            ::
        
                ensight.viewport.select_begin(2,5)
                ensight.viewport.delete()
                ensight.viewport.select_begin(0)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.viewport.delete()'''
        return self._session.cmd(cmd)

    def exchange_with_largest(self, p0: int) -> int:
        """Viewport: exchange_with_largest

        """
        cmd = f'''ensight.viewport.exchange_with_largest({repr(p0)})'''
        return self._session.cmd(cmd)

    def global_axis_location(self, p0: float, p1: float) -> int:
        """Viewport: global_axis_location

        """
        cmd = f'''ensight.viewport.global_axis_location({repr(p0)},{repr(p1)})'''
        return self._session.cmd(cmd)

    def global_axis_visible(self, p0: str) -> int:
        """Viewport: global_axis_visible

        """
        cmd = f'''ensight.viewport.global_axis_visible({repr(p0)})'''
        return self._session.cmd(cmd)

    def global_axis_xlabel(self, p0: str) -> int:
        """Viewport: global_axis_xlabel

        """
        cmd = f'''ensight.viewport.global_axis_xlabel({repr(p0)})'''
        return self._session.cmd(cmd)

    def global_axis_ylabel(self, p0: str) -> int:
        """Viewport: global_axis_ylabel

        """
        cmd = f'''ensight.viewport.global_axis_ylabel({repr(p0)})'''
        return self._session.cmd(cmd)

    def global_axis_zlabel(self, p0: str) -> int:
        """Viewport: global_axis_zlabel

        """
        cmd = f'''ensight.viewport.global_axis_zlabel({repr(p0)})'''
        return self._session.cmd(cmd)

    def height(self, p0: float) -> int:
        """Specify the normalized height for the selected viewport(s).
        
        Args:
            p0:
                'height' normalized height I[0.,1.]
        
        Examples:
            ::
        
                ensight.viewport.select_begin(0)
                ensight.viewport.origin_x(3.3333e-01)
                ensight.viewport.origin_y(0.0000e+00)
                ensight.viewport.width(5.1712e-01)
                ensight.viewport.height(1.0000e+00)
                ensight.viewport.select_begin(1,2)
                ensight.viewport.height(2.5000e-01)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.viewport.height({repr(p0)})'''
        return self._session.cmd(cmd)

    def hidden_line(self, p0: str) -> int:
        """Toggle whether hidden line meshes are to be overlaid onto parts in active viewport(s).
        
        | A part will be displayed with hidden lines if:
        | (a) view: hidden-line  ON
        | (b) viewport: hidden_line  ON
        | (c) part: hidden_line  ON
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.viewport.select_begin(0)
                ensight.viewport.hidden_line("OFF")
                ensight.viewport.select_begin(1)
                ensight.viewport.hidden_line("ON")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.viewport.hidden_line({repr(p0)})'''
        return self._session.cmd(cmd)

    def hidden_surface(self, p0: str) -> int:
        """Toggle whether hidden surfaces are to be removed from parts in active viewport(s).
        
        | A part will be displayed with shading if:
        | (a) view: hidden-surface  ON
        | (b) viewport: hidden_surface  ON
        | (c) part: hidden_surface  ON
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.viewport.select_begin(0)
                ensight.viewport.hidden_surface("OFF")
                ensight.viewport.select_begin(1)
                ensight.viewport.hidden_surface("ON")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.viewport.hidden_surface({repr(p0)})'''
        return self._session.cmd(cmd)

    def light1_azimuth(self, p0: float) -> int:
        """Defines the azimuth angle of light source 1.
        
        | This command needs to be used in conjunction with the viewport: light1_elevation <angle>  and viewport: light1_position <option> commands.
        
        Args:
            p0:
                'angle' azimuth angle for light source 1
        
        Examples:
            ::
        
                ensight.viewport.select_begin(3)
                ensight.viewport.light1_position("Relative")
                ensight.viewport.light1_azimuth(-9.702e+01)
                ensight.viewport.light1_elevation(3.750e+01)
                ensight.viewport.light_converttoabs()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.viewport.light1_azimuth({repr(p0)})'''
        return self._session.cmd(cmd)

    def light1_elevation(self, p0: float) -> int:
        """Defines the elevation angle of light source 1.
        
        | This command needs to be used in conjunction with the viewport: light1_azimuth <angle> and viewport: light1_position <option> commands.
        
        Args:
            p0:
                'angle' elevation angle for light source 1
        
        Examples:
            ::
        
                ensight.viewport.select_begin(3)
                ensight.viewport.light1_position("Relative")
                ensight.viewport.light1_azimuth(-9.702e+01)
                ensight.viewport.light1_elevation(3.750e+01)
                ensight.viewport.light_converttoabs()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.viewport.light1_elevation({repr(p0)})'''
        return self._session.cmd(cmd)

    def light1_position(self, p0: str) -> int:
        """Defines whether light source 1 is defined in the model coordinate system (absolute) or in reference to the viewer.
        
        | This command needs to be used in conjunction with the viewport: light1_azimuth <angle>  and viewport: light1_elevation <angle> commands.
        
        Args:
            p0:
                'option'
        
                * Absolute
                * Relative
        
        Examples:
            ::
        
                ensight.viewport.select_begin(3)
                ensight.viewport.light1_position("Relative")
                ensight.viewport.light1_azimuth(-9.702e+01)
                ensight.viewport.light1_elevation(3.750e+01)
                ensight.viewport.light_converttoabs()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.viewport.light1_position({repr(p0)})'''
        return self._session.cmd(cmd)

    def light2_intensity(self, p0: float) -> int:
        """Defines the intensity of light source 2, which is always at the location of the viewer (camera).
        
        | None 
        
        Args:
            p0:
                'amount' intensity of light source 2 (between 0.0 and 1.0)
        
        Examples:
            ::
        
                ensight.viewport.select_begin(3)
                ensight.viewport.light1_position("Relative")
                ensight.viewport.light1_azimuth(-9.702e+01)
                ensight.viewport.light1_elevation(3.750e+01)
                ensight.viewport.light_converttoabs()
                ensight.viewport.light2_intensity(3.100e-01)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.viewport.light2_intensity({repr(p0)})'''
        return self._session.cmd(cmd)

    def light_converttoabs(self) -> int:
        """Converts light coordinates which are relative to the viewport to be absolute (relative to the model coordinate system) and thus have a static lighting effect.
        
        | none
        
        Examples:
            ::
        
                ensight.viewport.select_begin(3)
                ensight.viewport.light1_position("Relative")
                ensight.viewport.light1_azimuth(-9.702e+01)
                ensight.viewport.light1_elevation(3.750e+01)
                ensight.viewport.light_converttoabs()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.viewport.light_converttoabs()'''
        return self._session.cmd(cmd)

    def lower(self) -> int:
        """Lower the selected viewport(s) to be located beneath all the other viewports - except the main viewport.
        
        | The main viewport (0) always remains beneath all viewports; and thus, is neither raised or lowered.
        
        Examples:
            ::
        
                ensight.viewport.select_begin(3,4)
                ensight.viewport.lower()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.viewport.lower()'''
        return self._session.cmd(cmd)

    def new(self) -> int:
        """Specify a new viewport to be created.
        
        | New viewport indexing sequentially increments in the range I[1,16].
        
        Examples:
            ::
        
                ensight.viewport.new()
                ensight.viewport.select_begin(1)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.viewport.new()'''
        return self._session.cmd(cmd)

    def new_or_mod(self, p0: int) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.viewport.new_or_mod({repr(p0)})'''
        return self._session.cmd(cmd)

    def not_used(self, p0: str) -> int:
        """Viewport: not_used

        """
        cmd = f'''ensight.viewport.not_used({repr(p0)})'''
        return self._session.cmd(cmd)

    def origin_x(self, p0: float) -> int:
        """Specify the normalized x/y-coordinate value of the origin for the selected viewport(s).
        
        Args:
            p0:
                'coord' lower left/bottom of viewport with range I[0.,1.]
        
        Examples:
            ::
        
                ensight.viewport.select_begin(0)
                ensight.viewport.origin_x(3.3333e-01)
                ensight.viewport.origin_y(0.0000e+00)
                ensight.viewport.width(5.1712e-01)
                ensight.viewport.height(1.0000e+00)
                ensight.viewport.select_begin(1,2)
                ensight.viewport.origin_x(1.0000e-01)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.viewport.origin_x({repr(p0)})'''
        return self._session.cmd(cmd)

    def origin_y(self, p0: float) -> int:
        """Specify the normalized x/y-coordinate value of the origin for the selected viewport(s).
        
        Args:
            p0:
                'coord' lower left/bottom of viewport with range I[0.,1.]
        
        Examples:
            ::
        
                ensight.viewport.select_begin(0)
                ensight.viewport.origin_x(3.3333e-01)
                ensight.viewport.origin_y(0.0000e+00)
                ensight.viewport.width(5.1712e-01)
                ensight.viewport.height(1.0000e+00)
                ensight.viewport.select_begin(1,2)
                ensight.viewport.origin_x(1.0000e-01)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.viewport.origin_y({repr(p0)})'''
        return self._session.cmd(cmd)

    def perspective(self, p0: str) -> int:
        """Toggle whether viewing frustrum is to be perspective or orthographic in selected viewport(s).
        
        | Geometry will be shown with perspective if:
        | (a) view: perspective  ON
        | (b) viewport: perspective  ON
        
        Args:
            p0:
                'toggle'
        
                * one of following toggle values:
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.viewport.select_begin(0)
                ensight.viewport.perspective("OFF")
                ensight.viewport.select_begin(1)
                ensight.viewport.perspective("ON")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.viewport.perspective({repr(p0)})'''
        return self._session.cmd(cmd)

    def query_count(self, args: Any) -> int:
        """Viewport: query_count

        """
        cmd = f'''ensight.viewport.query_count({repr(args)})'''
        return self._session.cmd(cmd)

    def query_display_attributes(self, args: Any) -> int:
        """Viewport: query_display_attributes

        """
        cmd = f'''ensight.viewport.query_display_attributes({repr(args)})'''
        return self._session.cmd(cmd)

    def query_location(self, args: Any) -> int:
        """Viewport: query_location

        """
        cmd = f'''ensight.viewport.query_location({repr(args)})'''
        return self._session.cmd(cmd)

    def query_mouse_info(self, args: Any) -> int:
        """Viewport: query_mouse_info

        """
        cmd = f'''ensight.viewport.query_mouse_info({repr(args)})'''
        return self._session.cmd(cmd)

    def query_object_atwindowxy(self, args: Any) -> int:
        """Viewport: query_object_atwindowxy

        """
        cmd = f'''ensight.viewport.query_object_atwindowxy({repr(args)})'''
        return self._session.cmd(cmd)

    def query_size(self, args: Any) -> int:
        """Viewport: query_size

        """
        cmd = f'''ensight.viewport.query_size({repr(args)})'''
        return self._session.cmd(cmd)

    def query_window_depth(self, args: Any) -> int:
        """Viewport: query_window_depth

        """
        cmd = f'''ensight.viewport.query_window_depth({repr(args)})'''
        return self._session.cmd(cmd)

    def query_window_mousepress(self, args: Any) -> int:
        """Viewport: query_window_mousepress

        """
        cmd = f'''ensight.viewport.query_window_mousepress({repr(args)})'''
        return self._session.cmd(cmd)

    def query_window_rgba(self, args: Any) -> int:
        """Viewport: query_window_rgba

        """
        cmd = f'''ensight.viewport.query_window_rgba({repr(args)})'''
        return self._session.cmd(cmd)

    def query_window_size(self, args: Any) -> int:
        """Viewport: query_window_size

        """
        cmd = f'''ensight.viewport.query_window_size({repr(args)})'''
        return self._session.cmd(cmd)

    def select_all(self) -> int:
        """Select all created viewports for editing.
        
        Examples:
            ::
        
                ensight.viewport.select_all()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.viewport.select_all()'''
        return self._session.cmd(cmd)

    def select_begin(self, *args, **kwargs) -> Any:
        """Set active viewport(s) selection construct for subsequent viewport modification.
        
        | All other "viewport:" commands operate off this setting.
        
        Args:
            p0:
                'idn' list of viewport number(s) to be active for editing. 
        
        Examples:
            ::
        
                ensight.viewport.select_begin(0)
                ensight.view_transf.function("global")
                ensight.viewport.viewport_layout("two_vertical")
                ensight.viewport.select_begin(1,2)
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.viewport.select_begin({arg_string})"
        return self._session.cmd(cmd)

    def select_default(self) -> int:
        """Allows the setting of default viewport attributes prior to creating the next viewport.
        
        Examples:
            ::
        
                ensight.viewport.select_default()
                ensight.viewport.perspective("OFF")
                ensight.viewport.background_type("constant")
                ensight.viewport.constant_rgb(0.0000e+00,0.0000e+00,0.0000e+00)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.viewport.select_default()'''
        return self._session.cmd(cmd)

    def track(self, p0: str) -> int:
        """Specify the location of the position to track (if any tracking is to be used).  Tracking causes the viewer (camera) to stay tuned on the position chosen as the model moves.
        
        | None
        
        Args:
            p0:
                'location'
        
                * Off
                * part_centroid
                * part_xmin
                * part_xmax
                * part_ymin
                * part_ymax
                * part_zmin 
                * part_zmax
                * node_number
        
        Examples:
            ::
        
                ensight.viewport.select_begin(0)
                ensight.viewport.track("part_centroid")
                ensight.viewport.tracking_part_id(9)
                ensight.viewport.select_begin(2)
                ensight.viewport.track("node_number")
                ensight.viewport.tracking_part_id(21)
                ensight.viewport.tracking_node_id(983)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.viewport.track({repr(p0)})'''
        return self._session.cmd(cmd)

    def tracking_node_id(self, p0: int) -> int:
        """Specify the node id to track.  Tracking causes the viewer (camera) to stay tuned on the position chosen as the model moves.
        
        | One should also specify the part that contains this node id, because node ids are only unique within parts in EnSight.
        
        Args:
            p0:
                'nid' The id of the node that will be tracked
        
        Examples:
            ::
        
                ensight.viewport.select_begin(0)
                ensight.viewport.track("part_centroid")
                ensight.viewport.tracking_part_id(9)
                ensight.viewport.select_begin(2)
                ensight.viewport.track("node_number")
                ensight.viewport.tracking_part_id(21)
                ensight.viewport.tracking_node_id(983)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.viewport.tracking_node_id({repr(p0)})'''
        return self._session.cmd(cmd)

    def tracking_part_id(self, args: Any) -> int:
        """Specify the part id to use for the other location options for tracking.  Tracking causes the viewer (camera) to stay tuned on the position chosen as the model moves.
        
        | One must specify the part that will be used for the part centroid, min/max, or node number tracking option chosen in viewport: track <location> command
        
        Args:
            p0:
                'pid' The id of the part that will be tracked by one of the options
        
        Examples:
            ::
        
                ensight.viewport.select_begin(0)
                ensight.viewport.track("part_centroid")
                ensight.viewport.tracking_part_id(9)
                ensight.viewport.select_begin(2)
                ensight.viewport.track("node_number")
                ensight.viewport.tracking_part_id(21)
                ensight.viewport.tracking_node_id(983)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.viewport.tracking_part_id({repr(args)})'''
        return self._session.cmd(cmd)

    def tracking_partbyname(self, args: Any) -> int:
        """Specify the part name to use for the other location options for tracking.  Tracking causes the viewer (camera) to stay tuned on the position chosen as the model moves.
        
        | One must specify the part that will be used for the part centroid, min/max, or node number tracking option chosen in viewport: track <location> command
        
        Args:
            p0:
                'partname' The name of the part that will be tracked by one of the options
        
        Examples:
            ::
        
                ensight.viewport.select_begin(0)
                ensight.viewport.track("part_centroid")
                ensight.viewport.tracking_partbyname("flowfield")
                ensight.viewport.select_begin(2)
                ensight.viewport.track("node_number")
                ensight.viewport.tracking_partbyname("outflow")
                ensight.viewport.tracking_node_id(983)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.viewport.tracking_partbyname({repr(args)})'''
        return self._session.cmd(cmd)

    def view_dimension(self, p0: str) -> int:
        """Set the dimension of the viewport.
        
        | Dimension 2D is handy for displaying 2D clips and/or developed surfaces.
        | A 2D viewport can only be transformed in 2D.
        
        Args:
            p0:
                'option'
        
                * includes the following viewport dimensions:
                * 3D (default)
                * 2D
        
        Examples:
            ::
        
                ensight.viewport.select_begin(0,1)
                ensight.viewport.view_dimension("3D")
                ensight.viewport.select_begin(2)
                ensight.viewport.view_dimension("2D")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.viewport.view_dimension({repr(p0)})'''
        return self._session.cmd(cmd)

    def viewport_layout(self, p0: str) -> int:
        """Specify the type of layout to be used in dividing the graphics window into viewports.
        
        | When creating a layout of viewports, the active viewport defaults to the last viewport created, i.e. if creating four_equal viewports, the active viewport is the last of the four created.
        
        Args:
            p0:
                'option'
        
                * includes the following types of viewport layouts:
                * one
                * two_vertical
                * two_horizontal
                * four_equal
                * four_withthreeleft
                * four_withthreebottom 
        
        Examples:
            ::
        
                ensight.viewport.select_begin(0)
                ensight.view_transf.function("global")
                ensight.viewport.viewport_layout("two_vertical")
                ensight.viewport.select_begin(1)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.viewport.viewport_layout({repr(p0)})'''
        return self._session.cmd(cmd)

    def visible(self, p0: str) -> int:
        """Toggle whether selected viewports are visible.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.viewport.select_begin(0)
                ensight.viewport.visible("OFF")
                ensight.viewport.select_begin(1)
                ensight.viewport.visible("ON")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.viewport.visible({repr(p0)})'''
        return self._session.cmd(cmd)

    def width(self, p0: float) -> int:
        """Specify the normalized width for the selected viewport(s).
        
        Args:
            p0:
                'width' normalized width I[0.,1.]
        
        Examples:
            ::
        
                ensight.viewport.select_begin(0)
                ensight.viewport.origin_x(3.3333e-01)
                ensight.viewport.origin_y(0.0000e+00)
                ensight.viewport.width(5.1712e-01)
                ensight.viewport.height(1.0000e+00)
                ensight.viewport.select_begin(1,2)
                ensight.viewport.width(2.5000e-01)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.viewport.width({repr(p0)})'''
        return self._session.cmd(cmd)


class view_transf:
    """Class wrapper for EnSight view_transf module

    This class acts as a proxy for the EnSight Python module ensight.view_transf
    """
    def __init__(self, session: Session):
        self._session = session

    def action(self, p0: str) -> int:
        """Sets the transformation method for interaction in the user interface.
        
        | This is not a necessary command.  It is used to change the user interface to reflect the transformation currently attached to the mouse button tied to the transformation action (by default the left mouse button).
        
        Args:
            p0:
                'method'
        
                * rotate
                * translate
                * scale
                * zoom
                * band_zoom
                * select_tool_pos
        
        Examples:
            ::
        
                ensight.view_transf.action("translate")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.action({repr(p0)})'''
        return self._session.cmd(cmd)

    def align2D(self, p0: int, p1: int, p2: int, p3: int) -> int:
        """View_transf: align2D

        """
        cmd = f'''ensight.view_transf.align2D({repr(p0)},{repr(p1)},{repr(p2)},{repr(p3)})'''
        return self._session.cmd(cmd)

    def axis(self, p0: str) -> int:
        """Sets the axis to use for rotate, translate, and scale transformations.
        
        | Used in the transformation dialog to control the axis about which transformational values are applied.
        | The axis is either the global system or, if in Frame mode, the selected frame's axis system.
        
        Args:
            p0:
                'which'
        
                * x
                * y
                * z
                * all
        
        Examples:
            ::
        
                # 
                # Set the axis to x 
                # and rotate about the x axis 15 degrees 
                # 
                ensight.view_transf.axis("x")
                ensight.view_transf.rotate(15.000000,0.000000,0.000000)
                # 
                # Set the axis to be y 
                # and translate one unit in the -negative y direction 
                # 
                ensight.view_transf.axis("y")
                ensight.view_transf.translate(0.0000e+00,-1.0000e+00,0.0000e+00)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.axis({repr(p0)})'''
        return self._session.cmd(cmd)

    def band_zoom_expand_from(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.band_zoom_expand_from({repr(p0)})'''
        return self._session.cmd(cmd)

    def box_axis(self, p0: float, p1: float, p2: float, p3: float) -> int:
        """Specify the direction vectors for a box tool. 
        
        | The direction vectors are in reference to the selected coordinate frame.
        
        Args:
            p0:
                'axis'
        
                * x
                * y
                * z
            p1:
                'x_comp' The x component of the direction vector
            p2:
                'y_comp' The y component of the direction vector
            p3:
                'z_comp' The z component of the direction vector
        
        Examples:
            ::
        
                ensight.tools.box("ON")
                ensight.view_transf.function("box")
                ensight.view_transf.box_length(3.000000e+00,4.000000e+00,5.000000e+00)
                ensight.view_transf.box_origin(0.000000e+00,1.000000e+00,0.000000e+00)
                ensight.view_transf.box_axis("x",1.000000e+00,0.000000e+00,0.000000e+00)
                ensight.view_transf.box_axis("y",0.000000e+00,1.000000e+00,0.000000e+00)
                ensight.view_transf.box_axis("z",0.000000e+00,0.000000e+00,1.000000e+00)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.box_axis({repr(p0)},{repr(p1)},{repr(p2)},{repr(p3)})'''
        return self._session.cmd(cmd)

    def box_length(self, p0: float, p1: float, p2: float) -> int:
        """Specify the size of the box tool in the x, y, and z directions.
        
        | The lengths are in relation to the box axis directions.
        
        Args:
            p0:
                'x_len' The length of box tool in the x, y, z direction
            p1:
                'y_len' The length of box tool in the x, y, z direction
            p2:
                'z_len' The length of box tool in the x, y, z direction
        
        Examples:
            ::
        
                ensight.tools.box("ON")
                ensight.view_transf.function("box")
                ensight.view_transf.box_length(3.000000e+00,4.000000e+00,5.000000e+00)
                ensight.view_transf.box_origin(0.000000e+00,1.000000e+00,0.000000e+00)
                ensight.view_transf.box_axis("x",1.000000e+00,0.000000e+00,0.000000e+00)
                ensight.view_transf.box_axis("y",0.000000e+00,1.000000e+00,0.000000e+00)
                ensight.view_transf.box_axis("z",0.000000e+00,0.000000e+00,1.000000e+00)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.box_length({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def box_origin(self, p0: float, p1: float, p2: float) -> int:
        """Specify the origin of the box tool in reference to the selected coordinate frame.
        
        Args:
            p0:
                'x_ori' The x, y, z origin of the box tool
            p1:
                'y_ori' The x, y, z origin of the box tool
            p2:
                'z_ori' The x, y, z origin of the box tool
        
        Examples:
            ::
        
                ensight.tools.box("ON")
                ensight.view_transf.function("box")
                ensight.view_transf.box_length(3.000000e+00,4.000000e+00,5.000000e+00)
                ensight.view_transf.box_origin(0.000000e+00,1.000000e+00,0.000000e+00)
                ensight.view_transf.box_axis("x",1.000000e+00,0.000000e+00,0.000000e+00)
                ensight.view_transf.box_axis("y",0.000000e+00,1.000000e+00,0.000000e+00)
                ensight.view_transf.box_axis("z",0.000000e+00,0.000000e+00,1.000000e+00)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.box_origin({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def camera_desc(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.camera_desc({repr(p0)})'''
        return self._session.cmd(cmd)

    def camera_direction_xyz(self, p0: float, p1: float, p2: float) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.camera_direction_xyz({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def camera_focus(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.camera_focus({repr(p0)})'''
        return self._session.cmd(cmd)

    def camera_focus_distprojpln(self, p0: float) -> int:
        """View_transf: camera_focus_distprojpln

        """
        cmd = f'''ensight.view_transf.camera_focus_distprojpln({repr(p0)})'''
        return self._session.cmd(cmd)

    def camera_focus_forwardxyz(self, p0: float, p1: float, p2: float) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.camera_focus_forwardxyz({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def camera_focus_partnode(self, p0: int, p1: int) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.camera_focus_partnode({repr(p0)},{repr(p1)})'''
        return self._session.cmd(cmd)

    def camera_lens(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.camera_lens({repr(p0)})'''
        return self._session.cmd(cmd)

    def camera_location_fromfile(self, p0: str) -> int:
        """View_transf: camera_location_fromfile

        """
        cmd = f'''ensight.view_transf.camera_location_fromfile({repr(p0)})'''
        return self._session.cmd(cmd)

    def camera_origin(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.camera_origin({repr(p0)})'''
        return self._session.cmd(cmd)

    def camera_origin_offset(self, p0: float, p1: float, p2: float) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.camera_origin_offset({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def camera_origin_partnode(self, p0: int, p1: int) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.camera_origin_partnode({repr(p0)},{repr(p1)})'''
        return self._session.cmd(cmd)

    def camera_origin_scalefactor(self, p0: float) -> int:
        """View_transf: camera_origin_scalefactor

        """
        cmd = f'''ensight.view_transf.camera_origin_scalefactor({repr(p0)})'''
        return self._session.cmd(cmd)

    def camera_origin_spline(self, args: Any) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.camera_origin_spline({repr(args)})'''
        return self._session.cmd(cmd)

    def camera_origin_splinevalue(self, p0: float) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.camera_origin_splinevalue({repr(p0)})'''
        return self._session.cmd(cmd)

    def camera_origin_xyz(self, p0: float, p1: float, p2: float) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.camera_origin_xyz({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def camera_size(self, p0: float) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.camera_size({repr(p0)})'''
        return self._session.cmd(cmd)

    def camera_up_xyz(self, p0: float, p1: float, p2: float) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.camera_up_xyz({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def camera_view_angle(self, p0: float) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.camera_view_angle({repr(p0)})'''
        return self._session.cmd(cmd)

    def camera_visible(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.camera_visible({repr(p0)})'''
        return self._session.cmd(cmd)

    def cameraselect_byname_begin(self, *args, **kwargs) -> Any:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.view_transf.cameraselect_byname_begin({arg_string})"
        return self._session.cmd(cmd)

    def cameraselect_byname_end(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.cameraselect_byname_end()'''
        return self._session.cmd(cmd)

    def cameratoview_compute(self) -> int:
        """View_transf: cameratoview_compute

        """
        cmd = f'''ensight.view_transf.cameratoview_compute()'''
        return self._session.cmd(cmd)

    def cameratoview_direction(self, p0: float, p1: float, p2: float) -> int:
        """View_transf: cameratoview_direction

        """
        cmd = f'''ensight.view_transf.cameratoview_direction({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def cameratoview_focaldist(self, p0: float) -> int:
        """View_transf: cameratoview_focaldist

        """
        cmd = f'''ensight.view_transf.cameratoview_focaldist({repr(p0)})'''
        return self._session.cmd(cmd)

    def cameratoview_focalpoint(self, p0: float, p1: float, p2: float) -> int:
        """View_transf: cameratoview_focalpoint

        """
        cmd = f'''ensight.view_transf.cameratoview_focalpoint({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def cameratoview_readfile(self, p0: str) -> int:
        """View_transf: cameratoview_readfile

        """
        cmd = f'''ensight.view_transf.cameratoview_readfile({repr(p0)})'''
        return self._session.cmd(cmd)

    def cameratoview_rotation(self, p0: float) -> int:
        """View_transf: cameratoview_rotation

        """
        cmd = f'''ensight.view_transf.cameratoview_rotation({repr(p0)})'''
        return self._session.cmd(cmd)

    def center_of_transform(self, p0: float, p1: float, p2: float) -> int:
        """Set the point in space that will be the origin for transformations. 
        
        | Since transformations can be different per viewport, this can be set for each viewport, thus a viewport selection is needed if more than one viewport is being used.
        | Cannot be set during keyframe animation.
        
        Args:
            p0:
                'x_coord' model x coordinate of the desired transformation origin
            p1:
                'y_coord' model y coordinate of the desired transformation origin
            p2:
                'z_coord' model z coordinate of the desired transformation origin
        
        Examples:
            ::
        
                # 
                # Selecting two viewports 
                # 
                ensight.viewport.select_begin(2,3)
                # 
                # Setting the center of transformations to be 
                # at (.5 .6 1) for each of these viewports 
                # 
                ensight.view_transf.center_of_transform(5.0000e-01,6.0000e-01,1.0000e+00)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.center_of_transform({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def clipping(self, p0: str) -> int:
        """View_transf: clipping

        """
        cmd = f'''ensight.view_transf.clipping({repr(p0)})'''
        return self._session.cmd(cmd)

    def cone(self, p0: float, p1: float, p2: float, p3: float) -> int:
        """View_transf: cone

        """
        cmd = f'''ensight.view_transf.cone({repr(p0)},{repr(p1)},{repr(p2)},{repr(p3)})'''
        return self._session.cmd(cmd)

    def cone_angle(self, p0: float) -> int:
        """Set the angle for the cone tool.
        
        | Use with view_transf: cone_axis and view_transf: cone_origin to specify the cone tool location and orientation
        
        Args:
            p0:
                'angle' the cone angle (in degrees)
        
        Examples:
            ::
        
                # 
                # Turns the display of the quadric cone on 
                # (only one quadric tool at a time can be on) 
                # 
                ensight.tools.quadric("cone")
                # 
                # Sets the angle and other attributes of the cone tool 
                # 
                ensight.view_transf.cone_angle(25.000000)
                ensight.view_transf.cone_axis(1.000000,0.100000,0.000000)
                ensight.view_transf.cone_origin(-0.750000,0.700000,1.000000)
                # 
                # Turns off the display of the quadric tool 
                # 
                ensight.tools.quadric("none")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.cone_angle({repr(p0)})'''
        return self._session.cmd(cmd)

    def cone_axis(self, p0: float, p1: float, p2: float) -> int:
        """Sets the axis for the cone tool.
        
        | Use with view_transf: cone_angle and view_transf: cone_origin to specify the cone tool location and orientation.
        | The components are in reference to the selected frame.
        
        Args:
            p0:
                'x_comp' x, y, z directional components for the cone tool axis
            p1:
                'y_comp' x, y, z directional components for the cone tool axis
            p2:
                'z_comp' x, y, z directional components for the cone tool axis
        
        Examples:
            ::
        
                # 
                # Turns display of the quadric cone on 
                # (only one quadric tool at a time can be on) 
                # 
                ensight.tools.quadric("cone")
                # 
                # Sets the axis and other attributes of the cone tool 
                # 
                ensight.view_transf.cone_angle(25.000000)
                ensight.view_transf.cone_axis(1.000000,0.100000,0.000000)
                ensight.view_transf.cone_origin(-0.750000,0.700000,1.000000)
                # 
                # Turns off the display of the quadric tool 
                # 
                ensight.tools.quadric("none")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.cone_axis({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def cone_origin(self, p0: float, p1: float, p2: float) -> int:
        """Sets the origin point for the tip of the cone tool.
        
        | Use with view_transf: cone_angle and view_transf: cone_axis to specify the cone tool location and orientation
        | The components are in reference to the selected frame.
        
        Args:
            p0:
                'x_coord' x, y, z coordinates of the cone tool origin
            p1:
                'y_coord' x, y, z coordinates of the cone tool origin
            p2:
                'z_coord' x, y, z coordinates of the cone tool origin
        
        Examples:
            ::
        
                # 
                # Turns display of the quadric cone on 
                # (only one quadric tool at a time can be on) 
                # 
                ensight.tools.quadric("cone")
                # 
                # Sets the origin and other attributes of the cone tool 
                # 
                ensight.view_transf.cone_angle(25.000000)
                ensight.view_transf.cone_axis(1.000000,0.100000,0.000000)
                ensight.view_transf.cone_origin(-0.750000,0.700000,1.000000)
                # 
                # Turns off the display of the quadric tool 
                # 
                ensight.tools.quadric("none")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.cone_origin({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def cursor(self, p0: float, p1: float, p2: float) -> int:
        """Sets the location of the cursor tool.
        
        | The components are in reference to the selected frame.
        
        Args:
            p0:
                'x_coord ' x, y, z coordinates of the cursor
            p1:
                'y_coord ' x, y, z coordinates of the cursor
            p2:
                'z_coord ' x, y, z coordinates of the cursor
        
        Examples:
            ::
        
                # 
                # Sets the cursor to the point (.79563 1 .8554) 
                # 
                ensight.view_transf.cursor(0.795630,1.000000,0.855400)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.cursor({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def cursor_by_partijk(self, p0: int, p1: int, p2: int, p3: int) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.cursor_by_partijk({repr(p0)},{repr(p1)},{repr(p2)},{repr(p3)})'''
        return self._session.cmd(cmd)

    def cursor_by_partnameijk(self, p0: str, p1: str, p2: str, p3: str) -> int:
        """View_transf: cursor_by_partnameijk

        """
        cmd = f'''ensight.view_transf.cursor_by_partnameijk({repr(p0)},{repr(p1)},{repr(p2)},{repr(p3)})'''
        return self._session.cmd(cmd)

    def cylinder(self, p0: float, p1: float, p2: float, p3: float) -> int:
        """View_transf: cylinder

        """
        cmd = f'''ensight.view_transf.cylinder({repr(p0)},{repr(p1)},{repr(p2)},{repr(p3)})'''
        return self._session.cmd(cmd)

    def cylinder_axis(self, p0: float, p1: float, p2: float) -> int:
        """Sets the axis for the cylinder tool.
        
        | Use with view_transf: cylinder_origin and view_transf: cylinder_radius to fully define the cylinder tool
        | The components are in reference to the selected frame.
        
        Args:
            p0:
                'x_comp' x, y, z directional components for the cylinder tool axis
            p1:
                'y_comp' x, y, z directional components for the cylinder tool axis
            p2:
                'z_comp' x, y, z directional components for the cylinder tool axis
        
        Examples:
            ::
        
                # 
                # Turns display of the quadric cylinder on 
                # (only one quadric tool at a time can be on) 
                # 
                ensight.tools.quadric("cylinder")
                # 
                # Sets the axis and other attributes of the cylinder tool 
                # 
                ensight.view_transf.cylinder_axis(1.000000,0.100000,0.000000)
                ensight.view_transf.cylinder_origin(-0.750000,0.700000,1.000000)
                ensight.view_transf.cylinder_radius(1.500000)
                # 
                # Turns off the display of the quadric tool 
                # 
                ensight.tools.quadric("none")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.cylinder_axis({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def cylinder_length(self, p0: float) -> int:
        """View_transf: cylinder_length

        """
        cmd = f'''ensight.view_transf.cylinder_length({repr(p0)})'''
        return self._session.cmd(cmd)

    def cylinder_origin(self, p0: float, p1: float, p2: float) -> int:
        """Sets the origin point for one end of the cylinder tool.
        
        | Use with view_transf: cylinder_axis and view_transf: cylinder_radius to fully define the cylinder tool.
        | The components are in reference to the selected frame.
        
        Args:
            p0:
                'x_coord' x, y, z coordinates of the cylinder tool origin 
            p1:
                'y_coord' x, y, z coordinates of the cylinder tool origin 
            p2:
                'z_coord' x, y, z coordinates of the cylinder tool origin 
        
        Examples:
            ::
        
                # 
                # Turns display of the quadric cylinder on 
                # (only one quadric tool at a time can be on) 
                # 
                ensight.tools.quadric("cylinder")
                # 
                # Sets the origin and other attributes of the cylinder tool 
                # 
                ensight.view_transf.cylinder_axis(1.000000,0.100000,0.000000)
                ensight.view_transf.cylinder_origin(-0.750000,0.700000,1.000000)
                ensight.view_transf.cylinder_radius(1.500000)
                # 
                # Turns off the display of the quadric tool 
                # 
                ensight.tools.quadric("none")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.cylinder_origin({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def cylinder_radius(self, p0: float) -> int:
        """Set the radius value for the cylinder tool.
        
        | Use with view_transf: cylinder_origin and view_transf: cylinder_axis to fully define the cylinder tool.
        
        Args:
            p0:
                'rad' cylinder radius value (in model coordinates)
        
        Examples:
            ::
        
                # 
                # Turns the display of the quadric cylinder on 
                # (only one quadric tool at a time can be on) 
                # 
                ensight.tools.quadric("cylinder")
                # 
                # Sets the radius and other attributes of the cylinder tool 
                # 
                ensight.view_transf.cylinder_axis(1.000000,0.100000,0.000000)
                ensight.view_transf.cylinder_origin(-0.750000,0.700000,1.000000)
                ensight.view_transf.cylinder_radius(1.500000)
                # 
                # Turns off the display of the quadric tool 
                # 
                ensight.tools.quadric("none")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.cylinder_radius({repr(p0)})'''
        return self._session.cmd(cmd)

    def dialog_visible(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.dialog_visible({repr(p0)})'''
        return self._session.cmd(cmd)

    def distance(self, p0: float) -> int:
        """Sets the distance from the look_from to the look_at point.
        
        | Since transformations can be different per viewport, this can be set for each viewport, thus a viewport selection is needed if more than one viewport is being used. 
        | This command causes the look_from point to move along the line between the look_from and the look_at point to the desired distance. The look_at point does not move.
        
        Args:
            p0:
                'dist' distance between the look_from and the look_at point (in model system)
        
        Examples:
            ::
        
                # 
                # Selecting two viewports 
                # 
                ensight.viewport.select_begin(1,3)
                # 
                # Setting the look_at and look_from points 
                # for each of these viewports 
                # 
                ensight.view_transf.look_at(1.0000e+00,5.0000e-01,1.0000e+00)
                ensight.view_transf.look_from(5.0000e-01,5.0000e-01,2.0000e+01)
                # 
                # Changing the distance between the look_at and the look_from 
                # points. The look_at point will not change, but the 
                # look_from point will be moved appropriately 
                # 
                ensight.view_transf.distance(2.5000e+01)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.distance({repr(p0)})'''
        return self._session.cmd(cmd)

    def fit(self, p0: int) -> int:
        """Appropriate scaling and translations are done so that the visible parts fit in the selected viewport.
        
        Args:
            p0:
                'viewport' viewport number in which the model will be fit.  (0, 1, ...)
        
        Examples:
            ::
        
                #
                # too fit the model in viewport 0
                #
                ensight.view_transf.fit(0)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.fit({repr(p0)})'''
        return self._session.cmd(cmd)

    def fit_current_viewport(self) -> int:
        """View_transf: fit_current_viewport

        """
        cmd = f'''ensight.view_transf.fit_current_viewport()'''
        return self._session.cmd(cmd)

    def function(self, p0: str) -> int:
        """Sets the transformation mode.
        
        Args:
            p0:
                'mode'
        
                * box
                * cone
                * cursor
                * cylinder
                * frame
                * global
                * line
                * local
                * plane
                * revolution
                * select_tool
                * sphere
                * spline
                * camera
        
        Examples:
            ::
        
                # 
                # Sets the function to cursor mode 
                # and translates the cursor 
                # 
                ensight.view_transf.function("cursor")
                ensight.view_transf.translate(0.295634,-0.014792,-0.144601)
                # 
                # Return to global transformation mode 
                # 
                ensight.view_transf.function("global")
                # 
                # Does some global transformations 
                # 
                ensight.view_transf.zoom(1.431051)
                ensight.view_transf.rotate(-1.071430,21.547768,0.000000)
                ensight.view_transf.translate(0.620558,0.000000,0.000000)
                # 
                # Sets Frame transform mode (local) 
                # 
                ensight.view_transf.function("local")
                # 
                # Selects the viewport and frame to use 
                # 
                ensight.viewport.select_begin(3)
                ensight.frame.select_begin(1)
                # 
                # And translate the parts attached to frame 1 
                # 
                ensight.view_transf.translate(0.0000E+00,-4.0000e+00,0.0000e+00)
                # 
                # Return to global transformation mode 
                # 
                ensight.view_transf.function("global")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.function({repr(p0)})'''
        return self._session.cmd(cmd)

    def initialize_viewports(self) -> int:
        """Resets transformations, look_at viewing parameters, and z clipping to the original values applied when model was first displayed.
        
        | Since transformations can be different per viewport, this can be applied to each viewport. Thus, a viewport selection is needed if more than one viewport is being used.
        
        Examples:
            ::
        
                # 
                # Selecting two viewports 
                # 
                ensight.viewport.select_begin(1,3)
                # 
                # Reinitializing these 2 viewports 
                # 
                ensight.view_transf.initialize_viewports()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.initialize_viewports()'''
        return self._session.cmd(cmd)

    def limit(self, p0: float) -> int:
        """Sets value represented by the extreme ends of the transformation slider in the transformation dialog.
        
        | This is a control for the user interface. Moving the slider all the way to the right will apply this value once positively. Moving it all the way to the left will apply this value once negatively. The slider is self centering, so one can continue to apply these amounts to the selected transformations. 
        | Associated with this is the Increment, which is the value that is applied (positively or negatively) by clicking the stepper button once.
        
        Args:
            p0:
                'value' the value to set as the limit for a complete movement of the cursor in the positive or negative directions
        
        Examples:
            ::
        
                ensight.view_transf.limit(5.000000)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.limit({repr(p0)})'''
        return self._session.cmd(cmd)

    def line(self, p0: float, p1: float, p2: float, p3: float) -> int:
        """Sets the location of the line tool by setting two endpoints.
        
        | Coordinates are in reference to the selected coordinate frame.
        
        Args:
            p0:
                'end_pt'
        
                * 1 - for the first end of the line
                * 2 - for the second end of the line
            p1:
                'x_coord' the x coordinate of the end point
            p2:
                'y_coord' the y coordinate of the end point
            p3:
                'z_coord' the z coordinate of the end point
        
        Examples:
            ::
        
                # 
                # Set the line tool endpoints 
                # 
                ensight.view_transf.line(1,-0.723300,0.700000,1.000000)
                ensight.view_transf.line(2,1.723300,0.500000,1.000000)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.line({repr(p0)},{repr(p1)},{repr(p2)},{repr(p3)})'''
        return self._session.cmd(cmd)

    def line_by_nodeids(self, p0: int, p1: int) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.line_by_nodeids({repr(p0)},{repr(p1)})'''
        return self._session.cmd(cmd)

    def line_length(self, p0: float) -> int:
        """Changes the line tool length.
        
        | When this is applied, the location of endpoint 1 will not change, but endpoint 2 will be moved along the line through endpoint 1 and endpoint 2, until the points are separated by the length desired.
        
        Args:
            p0:
                'length' desired length of the line tool
        
        Examples:
            ::
        
                # 
                # Set the line tool endpoints 
                # 
                ensight.view_transf.line(1,-0.723300,0.700000,1.000000)
                ensight.view_transf.line(2,1.723300,0.500000,1.000000)
                # 
                # Now make the tool 10 units long 
                # (endpoint 2 will be moved) 
                # 
                ensight.view_transf.line_length(10.000000)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.line_length({repr(p0)})'''
        return self._session.cmd(cmd)

    def look_at(self, p0: float, p1: float, p2: float) -> int:
        """Sets the look_at point for the selected viewport(s).
        
        | Since transformations can be different per viewport, this can be set for each viewport, thus a viewport selection is needed if more than one viewport is being used.
        | Coordinates are in reference to the model coordinate system.
        
        Args:
            p0:
                'x_coord' model x, y, z coordinates of the look_at point
            p1:
                'y_coord' model x, y, z coordinates of the look_at point
            p2:
                'z_coord' model x, y, z coordinates of the look_at point
        
        Examples:
            ::
        
                # 
                # Selecting two viewports 
                # 
                ensight.viewport.select_begin(1,3)
                # 
                # Setting the look_at and look_from points 
                # for each of these viewports 
                # 
                ensight.view_transf.look_at(1.0000e+00,5.0000e-01,1.0000e+00)
                ensight.view_transf.look_from(5.0000e-01,5.0000e-01,2.0000e+01)
                # 
                # Changing the distance between the look_at and the look_from 
                # points. The look_at point will not change, but the 
                # look_from point will be moved appropriately 
                # 
                ensight.view_transf.distance(2.5000e+01)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.look_at({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def look_from(self, p0: float, p1: float, p2: float) -> int:
        """Sets the look_from point for the selected viewport(s).
        
        | Since transformations can be different per viewport, this can be set for each viewport, thus a viewport selection is needed if more than one viewport is being used.
        | Coordinates are in reference to the model coordinate system.
        
        Args:
            p0:
                'x_coord' model x, y, z coordinates of the look_from point
            p1:
                'y_coord' model x, y, z coordinates of the look_from point
            p2:
                'z_coord' model x, y, z coordinates of the look_from point
        
        Examples:
            ::
        
                # 
                # Selecting two viewports 
                # 
                ensight.viewport.select_begin(1,3)
                # 
                # Setting the look_at and look_from points 
                # for each of these viewports 
                # 
                ensight.view_transf.look_at(1.0000e+00,5.0000e-01,1.0000e+00)
                ensight.view_transf.look_from(5.0000e-01,5.0000e-01,2.0000e+01)
                # 
                # Changing the distance between the look_at and the look_from 
                # points. The look_at point will not change, but the 
                # look_from point will be moved appropriately 
                # 
                ensight.view_transf.distance(2.5000e+01)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.look_from({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def mode(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.mode({repr(p0)})'''
        return self._session.cmd(cmd)

    def plane(self, p0: float, p1: float, p2: float, p3: float) -> int:
        """Sets the location of the plane tool by setting three corner points.
        
        | These points are best thought of as 1 being the lower left corner, 2 being the lower right corner, and 3 being the upper right corner.
        | Coordinates are in reference to the selected coordinate frame.
        
        Args:
            p0:
                'corner_pt'
        
                * 1 - for the first corner of the plane tool
                * 2 - for the second corner of the plane tool 
                * 3 - for the third corner of the plane tool
            p1:
                'x_coord '
        
                * x coordinate of the corner point
            p2:
                'y_coord '
        
                * y coordinate of the corner point
            p3:
                'z_coord '
        
                * z coordinate of the corner point
        
        Examples:
            ::
        
                # 
                # Set the plane tool corner points 
                # 
                ensight.view_transf.plane(1,-0.750000,-0.750000,0.900000)
                ensight.view_transf.plane(2,1.750000,-0.750000,1.100000)
                ensight.view_transf.plane(3,1.750000,2.000000,1.000000)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.plane({repr(p0)},{repr(p1)},{repr(p2)},{repr(p3)})'''
        return self._session.cmd(cmd)

    def plane_by_nodeids(self, p0: int, p1: int, p2: int) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.plane_by_nodeids({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def plane_equation(self, p0: float, p1: float, p2: float, p3: float) -> int:
        """Sets the location of the plane tool by specifying the coefficients of the plane equation (Ax + By + Cz = D).
        
        | Coefficients are in reference to the selected coordinate frame.
        
        Args:
            p0:
                'A' the x coefficient
            p1:
                'B' the y coefficient
            p2:
                'C' the z coefficient
            p3:
                'D' the constant term
        
        Examples:
            ::
        
                # 
                # Set the plane tool by the plane equation 
                # 
                ensight.view_transf.plane_equation(-1.000000,0.500000,12.499997,11.659089)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.plane_equation({repr(p0)},{repr(p1)},{repr(p2)},{repr(p3)})'''
        return self._session.cmd(cmd)

    def plane_normal(self, p0: float, p1: float, p2: float) -> int:
        """Specify the plane tool orientation.
        
        | The normal is in reference to the selected coordinate frame.
        
        Args:
            p0:
                'x_dir' x, y, z component of the plane tool normal
            p1:
                'y_dir' x, y, z component of the plane tool normal
            p2:
                'z_dir' x, y, z component of the plane tool normal
        
        Examples:
            ::
        
                ensight.tools.plane("ON")
                ensight.view_transf.function("plane")
                #
                # define the plane to be located at 0,1,0 with the z-axis (plane normal)
                # pointing in the x direction.  The plane is 3 units in X and 4 units in Y
                # (x and y according to the plane definition)
                #
                ensight.view_transf.plane_origin(0.000000e+00,1.000000e+00,0.000000e+00)
                ensight.view_transf.plane_normal(1.000000e+00,0.000000e+00,0.000000e+00)
                ensight.view_transf.plane_size(3.000000e+00,4.000000e+00)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.plane_normal({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def plane_origin(self, p0: float, p1: float, p2: float) -> int:
        """Specify the plane tool origin.
        
        | The origin is in reference to the selected coordinate frame.
        
        Args:
            p0:
                'x_ori' The x, y, z origin of the plane tool
            p1:
                'y_ori' The x, y, z origin of the plane tool
            p2:
                'z_ori' The x, y, z origin of the plane tool
        
        Examples:
            ::
        
                ensight.tools.plane("ON")
                ensight.view_transf.function("plane")
                #
                # define the plane to be located at 0,1,0 with the z-axis (plane normal)
                # pointing in the x direction.  The plane is 3 units in X and 4 units in Y
                # (x and y according to the plane definition)
                #
                ensight.view_transf.plane_origin(0.000000e+00,1.000000e+00,0.000000e+00)
                ensight.view_transf.plane_normal(1.000000e+00,0.000000e+00,0.000000e+00)
                ensight.view_transf.plane_size(3.000000e+00,4.000000e+00)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.plane_origin({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def plane_size(self, p0: float, p1: float) -> int:
        """Specify the plane tool size.
        
        | X and Y directions are according to the plane tool definition.
        
        Args:
            p0:
                'x_size' Size of the plane tool in the x, y direction
            p1:
                'y_size' Size of the plane tool in the x, y direction
        
        Examples:
            ::
        
                ensight.tools.plane("ON")
                ensight.view_transf.function("plane")
                #
                # define the plane to be located at 0,1,0 with the z-axis (plane normal)
                # pointing in the x direction.  The plane is 3 units in X and 4 units in Y
                # (x and y according to the plane definition)
                #
                ensight.view_transf.plane_origin(0.000000e+00,1.000000e+00,0.000000e+00)
                ensight.view_transf.plane_normal(1.000000e+00,0.000000e+00,0.000000e+00)
                ensight.view_transf.plane_size(3.000000e+00,4.000000e+00)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.plane_size({repr(p0)},{repr(p1)})'''
        return self._session.cmd(cmd)

    def query_composite_matrix(self, args: Any) -> int:
        """View_transf: query_composite_matrix

        """
        cmd = f'''ensight.view_transf.query_composite_matrix({repr(args)})'''
        return self._session.cmd(cmd)

    def query_lookat_position(self, args: Any) -> int:
        """View_transf: query_lookat_position

        """
        cmd = f'''ensight.view_transf.query_lookat_position({repr(args)})'''
        return self._session.cmd(cmd)

    def query_lookfrom_position(self, args: Any) -> int:
        """View_transf: query_lookfrom_position

        """
        cmd = f'''ensight.view_transf.query_lookfrom_position({repr(args)})'''
        return self._session.cmd(cmd)

    def query_perang(self, args: Any) -> int:
        """View_transf: query_perang

        """
        cmd = f'''ensight.view_transf.query_perang({repr(args)})'''
        return self._session.cmd(cmd)

    def query_proj_matrix(self, args: Any) -> int:
        """View_transf: query_proj_matrix

        """
        cmd = f'''ensight.view_transf.query_proj_matrix({repr(args)})'''
        return self._session.cmd(cmd)

    def query_rotate_matrix(self, args: Any) -> int:
        """View_transf: query_rotate_matrix

        """
        cmd = f'''ensight.view_transf.query_rotate_matrix({repr(args)})'''
        return self._session.cmd(cmd)

    def query_scale_matrix(self, args: Any) -> int:
        """View_transf: query_scale_matrix

        """
        cmd = f'''ensight.view_transf.query_scale_matrix({repr(args)})'''
        return self._session.cmd(cmd)

    def query_transform_center(self, args: Any) -> int:
        """View_transf: query_transform_center

        """
        cmd = f'''ensight.view_transf.query_transform_center({repr(args)})'''
        return self._session.cmd(cmd)

    def query_translate_matrix(self, args: Any) -> int:
        """View_transf: query_translate_matrix

        """
        cmd = f'''ensight.view_transf.query_translate_matrix({repr(args)})'''
        return self._session.cmd(cmd)

    def query_zclip(self, args: Any) -> int:
        """View_transf: query_zclip

        """
        cmd = f'''ensight.view_transf.query_zclip({repr(args)})'''
        return self._session.cmd(cmd)

    def redo(self) -> int:
        """Redo the undo.
        
        Examples:
            ::
        
                ensight.view_transf.function("global")
                ensight.view_transf.rotate(2.510301e+01,7.117291e+01,0.000000e+00)
                ensight.view_transf.undo()
                ensight.view_transf.redo()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.redo()'''
        return self._session.cmd(cmd)

    def redraw_idle(self, args: Any) -> int:
        """View_transf: redraw_idle

        """
        cmd = f'''ensight.view_transf.redraw_idle({repr(args)})'''
        return self._session.cmd(cmd)

    def region_tool_close(self) -> int:
        """View_transf: region_tool_close

        """
        cmd = f'''ensight.view_transf.region_tool_close()'''
        return self._session.cmd(cmd)

    def region_tool_deletepoint(self, p0: int) -> int:
        """View_transf: region_tool_deletepoint

        """
        cmd = f'''ensight.view_transf.region_tool_deletepoint({repr(p0)})'''
        return self._session.cmd(cmd)

    def region_tool_point(self, p0: float, p1: float, p2: float, p3: float) -> int:
        """View_transf: region_tool_point

        """
        cmd = f'''ensight.view_transf.region_tool_point({repr(p0)},{repr(p1)},{repr(p2)},{repr(p3)})'''
        return self._session.cmd(cmd)

    def reset_by_action(self) -> int:
        """Initializes the current action transformation, thus removing the effect of that transformation.
        
        | Since transformations can be different per viewport, this command can be used for each viewport, thus a viewport selection is needed if more than one viewport is being used.
        
        Examples:
            ::
        
                # 
                # Set the action to rotate 
                # and the axis to be x 
                # 
                ensight.view_transf.action("rotate")
                ensight.view_transf.axis("x")
                # 
                # Select the viewport(s) desired 
                # 
                ensight.viewport.select_begin(0,2)
                # 
                # perform a couple of rotates 
                # 
                ensight.view_transf.rotate(0.500000,0.000000,0.00000)
                ensight.view_transf.rotate(-30.00000,0.000000,0.00000)
                # 
                # Now remove both rotates using this command 
                # because the action is rotate. 
                # 
                ensight.view_transf.reset_by_action()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.reset_by_action()'''
        return self._session.cmd(cmd)

    def reset_rot_trn_scl(self) -> int:
        """Removes the rotation, translation, and scale transformations in the selected viewports.
        
        | Since transformations can be different per viewport, this command can be used for each viewport, thus a viewport selection is needed if more than one viewport is being used.
        | In Frame mode initializes the selected frames.
        
        Examples:
            ::
        
                # 
                # Select the viewport(s) desired 
                # 
                ensight.viewport.select_begin(0,2)
                # 
                # perform some rotations, translations and/or scales 
                # 
                ensight.view_transf.rotate(15.535719,-27.859741,0.000000)
                ensight.view_transf.translate(0.620558,0.000000,0.000000)
                ensight.view_transf.scale(1.2000e+00,1.2000e+00,1.2000e+00)
                # 
                # Now remove these transformations using this command 
                # 
                ensight.view_transf.reset_rot_trn_scl()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.reset_rot_trn_scl()'''
        return self._session.cmd(cmd)

    def reset_tool_constrain(self, p0: str) -> int:
        """Sets scope for the resetting of tool locations. The reset can cause the tool to be placed at its initial default location or at the center of the parts in the current viewport. 
        
        | The state set here applies to all future tool resets.
        
        Args:
            p0:
                'option'
        
                * by_global 
                * by_viewport 
        
        Examples:
            ::
        
                # 
                # Set the tool reset state to be "by viewport" 
                # 
                ensight.view_transf.reset_tool_constrain("by_viewport")
                # 
                # Select the viewport(s) desired 
                # 
                ensight.viewport.select_begin(0)
                # 
                # Reset the plane tool to the center of parts 
                # parts in viewport 0 
                # 
                ensight.view_transf.function("plane")
                ensight.view_transf.reset_rot_trn_scl()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.reset_tool_constrain({repr(p0)})'''
        return self._session.cmd(cmd)

    def reset_viewer(self) -> int:
        """View_transf: reset_viewer

        """
        cmd = f'''ensight.view_transf.reset_viewer()'''
        return self._session.cmd(cmd)

    def restore_view(self, p0: str) -> int:
        """Restores a previously saved view state file.
        
        | Since transformations are viewport independent, you need to select the desired viewport before restoring a view state (if you are using multiple viewports).
        
        Args:
            p0:
                'filename' name of the file containing the saved view
        
        Examples:
            ::
        
                # 
                # Select the viewport(s) desired 
                # 
                ensight.viewport.select_begin(0)
                # 
                # Save the current view state into the file 
                # /usr/tmp/view1 
                # 
                ensight.view_transf.save_view("/usr/tmp/view1")
                # 
                # You could now do other transformations etc... 
                # 
                # And then when you want to restore to the view state 
                # we saved, do the following 
                # 
                ensight.view_transf.restore_view("/usr/tmp/view1")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.restore_view({repr(p0)})'''
        return self._session.cmd(cmd)

    def revolution_axis(self, p0: float, p1: float, p2: float) -> int:
        """Sets the axis for the revolution tool.
        
        | Coordinates are in reference to the selected coordinate frame.
        
        Args:
            p0:
                'x_comp' x, y, z directional components of the revolution tool axis
            p1:
                'y_comp' x, y, z directional components of the revolution tool axis
            p2:
                'z_comp' x, y, z directional components of the revolution tool axis
        
        Examples:
            ::
        
                # 
                # Turns display of the quadric surface of revolution on 
                # (only one quadric tool at a time can be on) 
                # 
                ensight.tools.quadric("revolution")
                # 
                # Sets the axis and other attributes of the revolution tool 
                # 
                ensight.view_transf.revolution_origin(0.500000,0.700000,1.000000)
                ensight.view_transf.revolution_axis(0.995040,0.099504,0.000000)
                ensight.view_transf.revolution_number_of_points(7)
                ensight.view_transf.revolution_point(1,-1.250000,0.500000)
                ensight.view_transf.revolution_point(2,-0.625000,0.500000)
                ensight.view_transf.revolution_point(3,0.000000,1.000000)
                ensight.view_transf.revolution_point(4,0.301802,0.720000)
                ensight.view_transf.revolution_point(5,0.319820,0.710000)
                ensight.view_transf.revolution_point(6,0.625000,0.500000)
                ensight.view_transf.revolution_point(7,1.250000,0.500000)
                # 
                # Turns off the display of the revolution tool 
                # 
                ensight.tools.quadric("none")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.revolution_axis({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def revolution_number_of_points(self, p0: int) -> int:
        """View_transf: revolution_#_of_points

        """
        cmd = f'''ensight.view_transf.revolution_number_of_points({repr(p0)})'''
        return self._session.cmd(cmd)

    def revolution_origin(self, p0: float, p1: float, p2: float) -> int:
        """Sets the origin point for the first end of the revolution tool.
        
        | Coordinates are in reference to the selected coordinate frame.
        
        Args:
            p0:
                'x_coord' x, y, z coordinates of 1st end of the revolution tool
            p1:
                'y_coord' x, y, z coordinates of 1st end of the revolution tool
            p2:
                'z_coord' x, y, z coordinates of 1st end of the revolution tool
        
        Examples:
            ::
        
                # 
                # Turns display of the quadric surface of revolution on 
                # (only one quadric tool at a time can be on) 
                # 
                ensight.tools.quadric("revolution")
                # 
                # Sets the axis and other attributes of the revolution tool 
                # 
                ensight.view_transf.revolution_origin(0.500000,0.700000,1.000000)
                ensight.view_transf.revolution_axis(0.995040,0.099504,0.000000)
                ensight.view_transf.revolution_number_of_points(7)
                ensight.view_transf.revolution_point(1,-1.250000,0.500000)
                ensight.view_transf.revolution_point(2,-0.625000,0.500000)
                ensight.view_transf.revolution_point(3,0.000000,1.000000)
                ensight.view_transf.revolution_point(4,0.301802,0.720000)
                ensight.view_transf.revolution_point(5,0.319820,0.710000)
                ensight.view_transf.revolution_point(6,0.625000,0.500000)
                ensight.view_transf.revolution_point(7,1.250000,0.500000)
                # 
                # Turns off the display of the revolution tool 
                # 
                ensight.tools.quadric("none")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.revolution_origin({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def revolution_point(self, p0: float, p1: float, p2: float) -> int:
        """Defines the location of the given point in relation to the revolution axis.
        
        Args:
            p0:
                'pt_number' revolution tool point number for which the coordinates are being given
            p1:
                'x_coord' x coordinate of the point on the revolution tool. Namely, the distance parallel to the revolution axis from the origin of the tool
            p2:
                'y_coord' y coordinate of the point on the revolution tool. Namely, the distance perpendicular to the revolution axis from the origin of the tool
        
        Examples:
            ::
        
                # 
                # Turns display of the quadric surface of revolution on 
                # (only one quadric tool at a time can be on) 
                # 
                ensight.tools.quadric("revolution")
                # 
                # Sets the axis and other attributes of the revolution tool 
                # 
                ensight.view_transf.revolution_origin(0.500000,0.700000,1.000000)
                ensight.view_transf.revolution_axis(0.995040,0.099504,0.000000)
                ensight.view_transf.revolution_number_of_points(7)
                ensight.view_transf.revolution_point(1,-1.250000,0.500000)
                ensight.view_transf.revolution_point(2,-0.625000,0.500000)
                ensight.view_transf.revolution_point(3,0.000000,1.000000)
                ensight.view_transf.revolution_point(4,0.301802,0.720000)
                ensight.view_transf.revolution_point(5,0.319820,0.710000)
                ensight.view_transf.revolution_point(6,0.625000,0.500000)
                ensight.view_transf.revolution_point(7,1.250000,0.500000)
                # 
                # Turns off the display of the revolution tool 
                # 
                ensight.tools.quadric("none")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.revolution_point({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def rotate(self, p0: float, p1: float, p2: float) -> int:
        """Specifies a rotation (in degrees about each of the axes). Used for global, frame, and tool transformations.
        
        | Since transformations can be different per viewport, this can be set for each viewport, thus a viewport selection is needed if more than one viewport is being used.
        
        Args:
            p0:
                'x_ang' number of degrees to rotate about the x,y,z axes. (sign is according to the right-hand rule)
            p1:
                'y_ang' number of degrees to rotate about the x,y,z axes. (sign is according to the right-hand rule)
            p2:
                'z_ang' number of degrees to rotate about the x,y,z axes. (sign is according to the right-hand rule)
        
        Examples:
            ::
        
                # 
                # Selecting viewport(s) 
                # 
                ensight.viewport.select_begin(2)
                # 
                # Set the axis to x 
                # and rotate about the x axis 15 degrees 
                # 
                ensight.view_transf.axis("x")
                ensight.view_transf.rotate(15.000000,0.000000,0.000000)
                # 
                # Set the axis to be y 
                # and translate one unit in the -negative y direction 
                # 
                ensight.view_transf.axis("y")
                ensight.view_transf.translate(0.0000e+00,-1.0000e+00,0.0000e+00)
                # 
                # Now showing it with a plane tool rotation 
                # 
                ensight.tools.plane("ON")
                ensight.view_transf.function("plane")
                ensight.view_transf.rotate(0.000000,-39.575481,0.000000)
                ensight.view_transf.function("global")
                # 
                # And now with a local transformation 
                # 
                ensight.part.select_default()
                ensight.frame.create()
                ensight.frame.select_begin(1)
                ensight.part.select_begin(1)
                ensight.frame.assign(1)
                ensight.view_transf.function("local")
                ensight.view_transf.axis("y")
                ensight.view_transf.rotate(0.000000,27.000000,0.000000)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.rotate({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def save_view(self, p0: str) -> int:
        """Save the current view state into a file.
        
        Args:
            p0:
                'filename' the name (including the path) of the file in which to save the view state
        
        Examples:
            ::
        
                # 
                # Select the viewport(s) desired 
                # 
                ensight.viewport.select_begin(0)
                # 
                # Save the current view state into the file 
                # /usr/tmp/view1 
                # 
                ensight.view_transf.save_view("/usr/tmp/view1")
                # 
                # You could now do other transformations etc... 
                # 
                # And then when you want to restore to the view state 
                # we saved, do the following 
                # 
                ensight.view_transf.restore_view("/usr/tmp/view1")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.save_view({repr(p0)})'''
        return self._session.cmd(cmd)

    def scale(self, p0: float, p1: float, p2: float) -> int:
        """Defines a scaling in each of the axis directions. Used for global, frame, and tool transformation.
        
        | Since transformations can be different per viewport, this can be set for each viewport, thus a viewport selection is needed if more than one viewport is being used.
        
        Args:
            p0:
                'x_scale' scale factor to apply to x, y, z coordinates
            p1:
                'y_scale' scale factor to apply to x, y, z coordinates
            p2:
                'z_scale' scale factor to apply to x, y, z coordinates
        
        Examples:
            ::
        
                # 
                # Selecting viewport(s) 
                # 
                ensight.viewport.select_begin(2)
                # 
                # Applying a global scaling 
                # (evenly in all directions) 
                # 
                ensight.view_transf.scale(1.2000e+00,1.2000e+00,1.2000e+00)
                # 
                # Now with a local transformation 
                # (Scaling only in the z direction) 
                # 
                ensight.frame.select_begin(1)
                ensight.view_transf.function("local")
                ensight.view_transf.scale(0.0000e+00,0.0000e+00,5.0000e+00)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.scale({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def select_tool(self, p0: float, p1: float, p2: float, p3: float) -> int:
        """Sets the location of the selection tool by setting normalized screen min and max values.
        
        | The screen is considered normalized as 0 to 1 in both x and y directions, with the origin in the bottom left.
        
        Args:
            p0:
                'xmin'
        
                * minimum x screen coordinate  (0 to 1)
            p1:
                'xmax'
        
                * maximum x screen coordinate  (0 to 1)
            p2:
                'ymin'
        
                * minimum y screen coordinate  (0 to 1)
            p3:
                'ymax'
        
                * maximum y screen coordinate  (0 to 1)
        
        Examples:
            ::
        
                # 
                # Set select tool location
                # 
                ensight.tools.select_tool("ON")
                ensight.view_transf.select_tool(0.25,0.25,0.75,0.75)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.select_tool({repr(p0)},{repr(p1)},{repr(p2)},{repr(p3)})'''
        return self._session.cmd(cmd)

    def sensitivity(self, p0: float) -> int:
        """View_transf: sensitivity

        """
        cmd = f'''ensight.view_transf.sensitivity({repr(p0)})'''
        return self._session.cmd(cmd)

    def sphere_axis(self, p0: float, p1: float, p2: float) -> int:
        """Sets the axis components for the sphere tool.
        
        | Coordinates are in reference to the selected coordinate frame.
        
        Args:
            p0:
                'x_comp' x, y, z components of the sphere tool axis
            p1:
                'y_comp' x, y, z components of the sphere tool axis
            p2:
                'z_comp' x, y, z components of the sphere tool axis
        
        Examples:
            ::
        
                # 
                # Turns display of the quadric sphere tool on 
                # (only one quadric tool at a time can be on) 
                # 
                ensight.tools.quadric("sphere")
                # 
                # Sets the axis and other attributes of the sphere tool 
                # 
                ensight.view_transf.sphere_radius(1.500000)
                ensight.view_transf.sphere_axis(1.000000,0.100000,0.000000)
                ensight.view_transf.sphere_origin(0.500000,0.700000,1.000000)
                # 
                # Turns off the display of the sphere tool 
                # 
                ensight.tools.quadric("none")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.sphere_axis({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def sphere_origin(self, p0: float, p1: float, p2: float) -> int:
        """Sets the origin point for the first end of the sphere tool.
        
        | Coordinates are in reference to the selected coordinate frame.
        
        Args:
            p0:
                'x_coord' x, y, z coordinates of 1st end of the sphere tool
            p1:
                'y_coord' x, y, z coordinates of 1st end of the sphere tool
            p2:
                'z_coord' x, y, z coordinates of 1st end of the sphere tool
        
        Examples:
            ::
        
                # 
                # Turns display of the quadric sphere tool on 
                # (only one quadric tool at a time can be on) 
                # 
                ensight.tools.quadric("sphere")
                # 
                # Sets the origin and other attributes of the sphere tool 
                # 
                ensight.view_transf.sphere_radius(1.500000)
                ensight.view_transf.sphere_axis(1.000000,0.100000,0.000000)
                ensight.view_transf.sphere_origin(0.500000,0.700000,1.000000)
                # 
                # Turns off the display of the sphere tool 
                # 
                ensight.tools.quadric("none")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.sphere_origin({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def sphere_radius(self, p0: float) -> int:
        """Defines the radius of the sphere tool.
        
        Args:
            p0:
                'value' radius of the sphere tool
        
        Examples:
            ::
        
                # 
                # Turns display of the quadric sphere tool on 
                # (only one quadric tool at a time can be on) 
                # 
                ensight.tools.quadric("sphere")
                # 
                # Sets the axis and other attributes of the sphere tool 
                # 
                ensight.view_transf.sphere_radius(1.500000)
                ensight.view_transf.sphere_axis(1.000000,0.100000,0.000000)
                ensight.view_transf.sphere_origin(0.500000,0.700000,1.000000)
                # 
                # Turns off the display of the sphere tool 
                # 
                ensight.tools.quadric("none")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.sphere_radius({repr(p0)})'''
        return self._session.cmd(cmd)

    def spin(self, p0: float, p1: float, p2: float, p3: float) -> int:
        """Applies a global rotation multiple times.
        
        | Interactively, the model will continue to spin until the user stops it. Once stopped, the command language contains the number of times the rotation was applied.
        
        Args:
            p0:
                'num' number of times that the rotation is to be applied
            p1:
                'x_ang' number of degrees to rotate about the x, y, z axes. (sign is according to the right-hand rule)
            p2:
                'y_ang' number of degrees to rotate about the x, y, z axes. (sign is according to the right-hand rule)
            p3:
                'z_ang' number of degrees to rotate about the x, y, z axes. (sign is according to the right-hand rule)
        
        Examples:
            ::
        
                # 
                # Selecting viewport(s) 
                # 
                ensight.viewport.select_begin(2)
                # 
                # Spin only works with global rotations 
                # 
                ensight.view_transf.function("global")
                # 
                # Apply the rotation specified 
                # (In this case, 105 times)
                # 
                ensight.view_transf.spin(105,0.602679,-10.175333,0.000000)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.spin({repr(p0)},{repr(p1)},{repr(p2)},{repr(p3)})'''
        return self._session.cmd(cmd)

    def spline_color(self, p0: float, p1: float, p2: float) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.spline_color({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def spline_copy(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.spline_copy()'''
        return self._session.cmd(cmd)

    def spline_delete(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.spline_delete()'''
        return self._session.cmd(cmd)

    def spline_description(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.spline_description({repr(p0)})'''
        return self._session.cmd(cmd)

    def spline_id(self, p0: int, p1: int) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.spline_id({repr(p0)},{repr(p1)})'''
        return self._session.cmd(cmd)

    def spline_invert(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.spline_invert()'''
        return self._session.cmd(cmd)

    def spline_line_style(self, p0: str) -> int:
        """View_transf: spline_line_style

        """
        cmd = f'''ensight.view_transf.spline_line_style({repr(p0)})'''
        return self._session.cmd(cmd)

    def spline_load_fromfile(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.spline_load_fromfile({repr(p0)})'''
        return self._session.cmd(cmd)

    def spline_load_frompart(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.spline_load_frompart({repr(p0)})'''
        return self._session.cmd(cmd)

    def spline_new(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.spline_new()'''
        return self._session.cmd(cmd)

    def spline_offset(self, p0: float, p1: float, p2: float) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.spline_offset({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def spline_point_size(self, p0: float) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.spline_point_size({repr(p0)})'''
        return self._session.cmd(cmd)

    def spline_point_visibility(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.spline_point_visibility({repr(p0)})'''
        return self._session.cmd(cmd)

    def spline_save(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.spline_save({repr(p0)})'''
        return self._session.cmd(cmd)

    def spline_select(self, p0: int) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.spline_select({repr(p0)})'''
        return self._session.cmd(cmd)

    def spline_select_begin(self, *args, **kwargs) -> Any:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.view_transf.spline_select_begin({arg_string})"
        return self._session.cmd(cmd)

    def spline_visibility(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.spline_visibility({repr(p0)})'''
        return self._session.cmd(cmd)

    def spline_width(self, p0: int) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.spline_width({repr(p0)})'''
        return self._session.cmd(cmd)

    def splinepoint_copy(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.splinepoint_copy()'''
        return self._session.cmd(cmd)

    def splinepoint_create(self, p0: float, p1: float, p2: float) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.splinepoint_create({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def splinepoint_delete(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.splinepoint_delete()'''
        return self._session.cmd(cmd)

    def splinepoint_edit(self, p0: float, p1: float, p2: float) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.splinepoint_edit({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def splinepoint_offset(self, p0: float, p1: float, p2: float) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.splinepoint_offset({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def splinepoint_paste(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.splinepoint_paste()'''
        return self._session.cmd(cmd)

    def splinepoint_select_all(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.splinepoint_select_all()'''
        return self._session.cmd(cmd)

    def splinepoint_select_begin(self, *args, **kwargs) -> Any:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.view_transf.splinepoint_select_begin({arg_string})"
        return self._session.cmd(cmd)

    def translate(self, p0: float, p1: float, p2: float) -> int:
        """Specifies a translation in each of the coordinate directions. Used for global, frame, and tool transformations.
        
        | Since transformations can be different per viewport, this can be set for each viewport, thus a viewport selection is needed if more than one viewport is being used.
        
        Args:
            p0:
                'x_dist' distance to translate in the x, y, z directions
            p1:
                'y_dist' distance to translate in the x, y, z directions
            p2:
                'z_dist' distance to translate in the x, y, z directions
        
        Examples:
            ::
        
                # 
                # Sets the function to cursor mode 
                # and translates the cursor 
                # 
                ensight.view_transf.function("cursor")
                ensight.view_transf.translate(0.295634,-0.014792,-0.144601)
                # 
                # Return to global transformation mode 
                # 
                ensight.view_transf.function("global")
                # 
                # Does some global transformations 
                # (one of which is a translate) 
                # 
                ensight.view_transf.zoom(1.431051)
                ensight.view_transf.rotate(-1.071430,21.547768,0.000000)
                ensight.view_transf.translate(0.620558,0.000000,0.000000)
                # 
                # Sets Frame transform mode (local) 
                # 
                ensight.view_transf.function("local")
                # 
                # Selects the viewport and frame to use 
                # 
                ensight.viewport.select_begin(3)
                ensight.frame.select_begin(1)
                # 
                # And translate the parts attached to frame 1 
                # 
                ensight.view_transf.translate(0.0000E+00,-4.0000e+00,0.0000e+00)
                # 
                # Return to global transformation mode 
                # 
                ensight.view_transf.function("global")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.translate({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def undo(self) -> int:
        """Undo the last transformation or tool definition.
        
        Examples:
            ::
        
                ensight.view_transf.function("global")
                ensight.view_transf.rotate(2.510301e+01,7.117291e+01,0.000000e+00)
                ensight.view_transf.undo()
                ensight.view_transf.redo()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.undo()'''
        return self._session.cmd(cmd)

    def view_center(self, p0: float, p1: float, p2: float) -> int:
        """View_transf: view_center

        """
        cmd = f'''ensight.view_transf.view_center({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def view_center_and_direction(self, p0: float, p1: float, p2: float, p3: float, p4: float, p5: float) -> int:
        """View_transf: view_center_and_direction

        """
        cmd = f'''ensight.view_transf.view_center_and_direction({repr(p0)},{repr(p1)},{repr(p2)},{repr(p3)},{repr(p4)},{repr(p5)})'''
        return self._session.cmd(cmd)

    def view_center_var_max(self, p0: Any) -> int:
        """View_transf: view_center_var_max

        """
        cmd = f'''ensight.view_transf.view_center_var_max({repr(p0)})'''
        return self._session.cmd(cmd)

    def view_center_var_min(self, p0: Any) -> int:
        """View_transf: view_center_var_min

        """
        cmd = f'''ensight.view_transf.view_center_var_min({repr(p0)})'''
        return self._session.cmd(cmd)

    def view_from_triad_axis(self, p0: str) -> int:
        """View_transf: view_from_triad_axis

        """
        cmd = f'''ensight.view_transf.view_from_triad_axis({repr(p0)})'''
        return self._session.cmd(cmd)

    def view_recall(self, p0: str) -> int:
        """View the model from a standard (or customized) view position.
        
        | The F5, F6, F7 views have standard right, top, and front views for a default. These can be altered by the user using the "view_transf: view_store" command. Since transformations can be different per viewport, this can be set for each viewport, thus a viewport selection is needed if more than one viewport is being used.
        
        Args:
            p0:
                'option'
        
                * F5
                * F6
                * F7
                * F8
                * +X
                * +Y
                * +Z
                * -X
                * -Y
                * -Z
        
        Examples:
            ::
        
                # 
                # Select viewport for which you wish 
                # to modify the view 
                # 
                ensight.viewport.select_begin(1)
                ensight.view_transf.view_recall("F5")
                # 
                # Selecting a different viewport 
                # to show another example 
                # 
                ensight.viewport.select_begin(2)
                ensight.view_transf.view_recall("+Y")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.view_recall({repr(p0)})'''
        return self._session.cmd(cmd)

    def view_store(self, p0: str) -> int:
        """Stores a current View state as a state attached to one of the four customizable function keys.
        
        | The F5, F6, F7 views have standard right, top, and front views for a default. These can be altered by the user using this command. The views stored here can be recalled using the "view_transf: view_recall" command. 
        | Since transformations can be different per viewport, this can be set for each viewport, thus a viewport selection is needed if more than one viewport is being used.
        
        Args:
            p0:
                'option'
        
                * F5
                * F6
                * F7
                * F8
        
        Examples:
            ::
        
                # 
                # Select viewport that contains the 
                # view that you wish to store. 
                # 
                ensight.viewport.select_begin(1)
                # 
                # Store it into the desired F key 
                # 
                ensight.view_transf.view_store("F5")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.view_store({repr(p0)})'''
        return self._session.cmd(cmd)

    def viewport_camera(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.viewport_camera({repr(p0)})'''
        return self._session.cmd(cmd)

    def viewport_link(self, p0: str) -> int:
        """Link the interactive global transformations of multiple viewports. This causes any transformations applied to one of the viewports to be applied to all the other linked viewports as well.
        
        | Only interactive transforms are linked.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                # 
                # Selecting three viewports, and linking them 
                # 
                ensight.viewport.select_begin(0,1,2)
                ensight.view_transf.viewport_link("ON")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.viewport_link({repr(p0)})'''
        return self._session.cmd(cmd)

    def viewport_state_copy(self) -> int:
        """Save the transformation state of the currently selected viewport (for the purpose of applying it to a different viewport with the "view_transf: viewport_state_paste" command.
        
        Examples:
            ::
        
                # 
                # Select viewport for which you wish 
                # to save the transformation state 
                # 
                ensight.viewport.select_begin(1)
                ensight.view_transf.viewport_state_copy()
                # 
                # Select the viewport you wish to 
                # apply this state to 
                # 
                ensight.viewport.select_begin(2)
                ensight.view_transf.viewport_state_paste()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.viewport_state_copy()'''
        return self._session.cmd(cmd)

    def viewport_state_paste(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.viewport_state_paste()'''
        return self._session.cmd(cmd)

    def viewports(self, p0: int) -> int:
        """View_transf: viewports

        """
        cmd = f'''ensight.view_transf.viewports({repr(p0)})'''
        return self._session.cmd(cmd)

    def vr_scale(self, p0: float) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.vr_scale({repr(p0)})'''
        return self._session.cmd(cmd)

    def vr_worldcenter(self, p0: float, p1: float, p2: float) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.vr_worldcenter({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def vr_worlddiagonal(self, p0: float) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.vr_worlddiagonal({repr(p0)})'''
        return self._session.cmd(cmd)

    def zclip_back(self, p0: float) -> int:
        """Sets the position of the back/front z-clip plane
        
        | This value is used only when "view_transf: zclip_float" is OFF.  Since transformations can be different per viewport, this can be set for each viewport, thus a viewport selection is needed if more than one viewport is being used.
        
        Args:
            p0:
                'z_loc' z coordinate of the back/front z-clipping plane
        
        Examples:
            ::
        
                # 
                # Select viewport 
                # 
                ensight.viewport.select_begin(1)
                # 
                # Set z-clip float OFF and set the location 
                # the front and back clipping planes 
                # 
                ensight.view_transf.zclip_float("OFF")
                ensight.view_transf.zclip_front(7.2296e+00)
                ensight.view_transf.zclip_back(3.5459e+01)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.zclip_back({repr(p0)})'''
        return self._session.cmd(cmd)

    def zclip_float(self, p0: str) -> int:
        """Sets the z-clipping state. The front and back z-clipping planes can "float" so that they are always outside the model - causing no z-clipping to occur, or they can be set once initially and are then subject to manual modification. 
        
        | Since the z-buffer uses the resolution between the front and back clipping planes, it is desirable to have these planes "near" the model. However, unless you specifically want to perform z-clipping, these by default "float" as needed to avoid any z-clipping. If you want z-clipping control, you can turn this "floating" behavior off and set the front and back plane locations yourself.  During the float mode, near clipping will occur if it must be at the specified minimum z-clip location. A minimum is needed to avoid z reflection.Since transformations can be different per viewport, this can be set for each viewport, thus a viewport selection is needed if more than one viewport is being used.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                # 
                # Select viewport 
                # 
                ensight.viewport.select_begin(1)
                # 
                # Set z-clip float OFF and set the location 
                # of the front and back clipping planes 
                # 
                ensight.view_transf.zclip_float("OFF")
                ensight.view_transf.zclip_front(7.2296e+00)
                ensight.view_transf.zclip_back(3.5459e+01)
                # 
                # To have them float instead 
                # 
                ensight.view_transf.zclip_float("ON")
                ensight.view_transf.zclip_min(4.00000e-04)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.zclip_float({repr(p0)})'''
        return self._session.cmd(cmd)

    def zclip_front(self, p0: float) -> int:
        """Sets the position of the back/front z-clip plane
        
        | This value is used only when "view_transf: zclip_float" is OFF.  Since transformations can be different per viewport, this can be set for each viewport, thus a viewport selection is needed if more than one viewport is being used.
        
        Args:
            p0:
                'z_loc' z coordinate of the back/front z-clipping plane
        
        Examples:
            ::
        
                # 
                # Select viewport 
                # 
                ensight.viewport.select_begin(1)
                # 
                # Set z-clip float OFF and set the location 
                # the front and back clipping planes 
                # 
                ensight.view_transf.zclip_float("OFF")
                ensight.view_transf.zclip_front(7.2296e+00)
                ensight.view_transf.zclip_back(3.5459e+01)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.zclip_front({repr(p0)})'''
        return self._session.cmd(cmd)

    def zclip_min(self, p0: float) -> int:
        """Sets the minimum to which the front z-clipping plane is allowed to "float".
        
        | Since the z-buffer uses the resolution between the front and back clipping planes, it is desirable to have these planes "near" the model. However, unless you specifically want to perform z-clipping, these by default "float" as needed to avoid any z-clipping. If you want z-clipping control, you can turn this "floating" behavior off and set the front and back plane locations yourself.  During the float mode, near clipping will occur if it must be at the specified minimum z-clip location. A minimum is needed to avoid z reflection. Since transformations can be different per viewport, this can be set for each viewport, thus a viewport selection is needed if more than one viewport is being used.
        
        Args:
            p0:
                'z_min' minimum allowable z location for the front z-clipping plane
        
        Examples:
            ::
        
                # 
                # Select viewport 
                # 
                ensight.viewport.select_begin(1)
                # 
                # Set z-clip float OFF and set the location 
                # of the front and back clipping planes 
                # 
                ensight.view_transf.zclip_float("OFF")
                ensight.view_transf.zclip_front(7.2296e+00)
                ensight.view_transf.zclip_back(3.5459e+01)
                # 
                # To have them float instead 
                # (note the minimum being set) 
                # 
                ensight.view_transf.zclip_float("ON")
                ensight.view_transf.zclip_min(4.00000e-04)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.zclip_min({repr(p0)})'''
        return self._session.cmd(cmd)

    def zoom(self, p0: float) -> int:
        """Move the viewer closer or farther away.
        
        | Since transformations can be different per viewport, this can be set for each viewport, thus a viewport selection is needed if more than one viewport is being used.
        
        Args:
            p0:
                'factor' amount of zoom scaling
        
        Examples:
            ::
        
                # 
                # Selecting viewport(s) 
                # 
                ensight.viewport.select_begin(2)
                # 
                # Applying a zoom factor 
                # 
                ensight.view_transf.zoom(1.431051)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.zoom({repr(p0)})'''
        return self._session.cmd(cmd)

    def zoom_style(self, p0: str) -> int:
        """Select the zoom user interaction style.
        
        Args:
            p0:
                'style'
        
                * automatic_slide
                * manual_drag
        
        Examples:
            ::
        
                ensight.view_transf.zoom_style("automatic_slide")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.zoom_style({repr(p0)})'''
        return self._session.cmd(cmd)

    def zoom_to_selectregion(self) -> int:
        """Perform the zoom according to the current location of the selection tool.
        
        Examples:
            ::
        
                ensight.tools.select_tool("ON")
                ensight.view_transf.function("global")
                ensight.view_transf.select_tool(.25,.25,.75,.75)
                ensight.view_transf.zoom_to_selectregion()
                ensight.view_transf.undo()
                ensight.view_transf.redo()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view_transf.zoom_to_selectregion()'''
        return self._session.cmd(cmd)


class view:
    """Class wrapper for EnSight view module

    This class acts as a proxy for the EnSight Python module ensight.view
    """
    def __init__(self, session: Session):
        self._session = session

    def _2d3d_grid(self, p0: str) -> int:
        """View: 2d3d_grid

        """
        cmd = f'''ensight.view._2d3d_grid({repr(p0)})'''
        return self._session.cmd(cmd)

    def bounding_box(self, p0: str) -> int:
        """View: bounding_box

        """
        cmd = f'''ensight.view.bounding_box({repr(p0)})'''
        return self._session.cmd(cmd)

    def bounding_mode(self, p0: str) -> int:
        """View: bounding_mode

        """
        cmd = f'''ensight.view.bounding_mode({repr(p0)})'''
        return self._session.cmd(cmd)

    def bounds(self, p0: str) -> int:
        """Toggles on or off the global bounds display
        
        | Bounds display will be visible in a viewport if this toggle is ON and the "viewport_bounds: visible ON" is also set.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                #
                # turn on bounds display but turn the bounds off for viewport 1
                #
                ensight.view.bounds("ON")
                ensight.viewport.select_begin(1)
                ensight.viewport_bounds.visible("OFF")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view.bounds({repr(p0)})'''
        return self._session.cmd(cmd)

    def camera(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view.camera({repr(p0)})'''
        return self._session.cmd(cmd)

    def clipping(self, p0: str) -> int:
        """Toggles on or off the auxiliary clipping plane
        
        | When auxiliary clipping is on, objects on the negative side of the plane tool are not drawn. By toggling on or off parts individual auxiliary clipping attribute (part: clip), some parts can be clipped while others are not.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.tools.plane("ON")
                ensight.view.clipping("ON")
                # WARNING: following line includes OBSOLETE call (ensight.part.select_partname_begin).
                ensight.part.select_partname_begin("(CASE:Case 1)ami-x hypersonic body")
                ensight.part.modify_begin()
                ensight.part.clip("OFF")
                ensight.part.modify_end()
                ensight.view_transf.function("plane")
                ensight.view_transf.rotate(106.516396,0.000000,0.000000)
                ensight.view_transf.function("global")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view.clipping({repr(p0)})'''
        return self._session.cmd(cmd)

    def default_orientation(self, p0: str) -> int:
        """Sets the default view orientation.
        
        | Must be executed before data is read.
        | The default is +z
        
        Args:
            p0:
                'direction'
        
                * +x
                * -x
                * +y
                * -y
                * +z
                * -z
        
        Examples:
            ::
        
                ensight.view.default_orientation("+x")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view.default_orientation({repr(p0)})'''
        return self._session.cmd(cmd)

    def detail_mode(self, p0: str) -> int:
        """View: detail_mode

        """
        cmd = f'''ensight.view.detail_mode({repr(p0)})'''
        return self._session.cmd(cmd)

    def display_mode(self, p0: str) -> int:
        """View: display_mode

        """
        cmd = f'''ensight.view.display_mode({repr(p0)})'''
        return self._session.cmd(cmd)

    def fast_display(self, p0: str) -> int:
        """Toggles the fast display setting. When on, parts can be rendered using an alternative representation while being interactively moved.
        
        | Each part has an attribute that indicates how it will be drawn when fast display is on. See 'part: bounding_rep'.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.view.fast_display("ON")
                # WARNING: following line includes OBSOLETE call (ensight.part.select_partname_begin).
                ensight.part.select_partname_begin("(CASE:Case 1)external flow field")
                ensight.part.modify_begin()
                ensight.part.bounding_rep("points")
                ensight.part.modify_end()
                ensight.view_transf.rotate(-3.021584,51.034481,0.000000)
                ensight.view_transf.function("global")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view.fast_display({repr(p0)})'''
        return self._session.cmd(cmd)

    def feature_qia(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view.feature_qia({repr(p0)})'''
        return self._session.cmd(cmd)

    def full_color(self, p0: str) -> int:
        """View: full_color

        """
        cmd = f'''ensight.view.full_color({repr(p0)})'''
        return self._session.cmd(cmd)

    def full_screen(self, p0: str) -> int:
        """Toggles full screen rendering
        
        | During full screen rendering, the graphics window fills the screen hiding the rest of the user interface and other windows.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.view.full_screen("ON")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view.full_screen({repr(p0)})'''
        return self._session.cmd(cmd)

    def hardware_line_offset(self, p0: str) -> int:
        """Toggles on or off the use of hardware line offset
        
        | This command is only used for view preferences.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.view.hardware_line_offset("ON")
                ensight.view.default_orientation("+Z")
                ensight.view.hidden_surface("OFF")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view.hardware_line_offset({repr(p0)})'''
        return self._session.cmd(cmd)

    def hidden_line(self, *args, **kwargs) -> Any:
        """Toggles global hidden line drawing.
        
        | Each part has a part attribute that determines whether or not it will be drawn with hidden lines if the global setting is on (See part: hidden_line).  
        | If the optional RGB values are specified, they must be values between 0.0 and 1.0. If none are specified, then 0.0, 0.0, 0.0 are used.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
            p1:
                'red_val' optional red, green, blue color values (range 0.0 to 1.0) for the hidden lines when hidden surface (See view: hidden_surface) is also ON
            p2:
                'grn_val' optional red, green, blue color values (range 0.0 to 1.0) for the hidden lines when hidden surface (See view: hidden_surface) is also ON
            p3:
                'blu_val' optional red, green, blue color values (range 0.0 to 1.0) for the hidden lines when hidden surface (See view: hidden_surface) is also ON
        
        Examples:
            ::
        
                ensight.sendmesgoptions(version="8.20 ")
                ensight.view.hidden_line("ON",1.0000e+00,0.0000e+00,0.0000e+00)
                ensight.part.modify_begin()
                ensight.part.hidden_line("OFF")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.view.hidden_line({arg_string})"
        return self._session.cmd(cmd)

    def hidden_surface(self, p0: str) -> int:
        """Toggles display of shaded surfaces.
        
        | Each part has an attribute that determines whether it will be drawn in shaded or in line mode (part: hidden_surface).
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.view.hidden_surface("ON")
                # WARNING: following line includes OBSOLETE call (ensight.part.select_partname_begin).
                ensight.part.select_partname_begin("(CASE:Case 1)ami-x hypersonic body")
                ensight.part.modify_begin()
                ensight.part.hidden_surface("OFF")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view.hidden_surface({repr(p0)})'''
        return self._session.cmd(cmd)

    def highlight_parts(self, p0: str) -> int:
        """Toggles display of highlighted parts.
        
        | This is a global toggle for all parts.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.view.highlight_parts("OFF")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view.highlight_parts({repr(p0)})'''
        return self._session.cmd(cmd)

    def perspective(self, p0: str) -> int:
        """Toggles global perspective rendering.
        
        | Perspective rendering causes things further in distance to appear smaller than closer objects. If this setting is off then objects will be rendered in orthographic mode which does not use perspective foreshortening.
        | Each viewport has a local setting.  See viewport: perspective
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.view.perspective("ON")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view.perspective({repr(p0)})'''
        return self._session.cmd(cmd)

    def pick_method(self, p0: str) -> int:
        """Chooses whether picking occurs in software or on the graphics hardware card.
        
        Args:
            p0:
                'value'
        
                * hardware
                * software
        
        Examples:
            ::
        
                ensight.view.pick_method("hardware")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view.pick_method({repr(p0)})'''
        return self._session.cmd(cmd)

    def pick_mode(self, p0: str) -> int:
        """Sets what type of pick will be performed when the 'p' key is pressed.
        
        | See the EnSight User's Manual for instructions on how to operate each of these picks. 
        
        Args:
            p0:
                'value'
        
                * center_of_transform
                * cursor
                * line
                * look_at 
                * part
                * plane
                * plane_2pt
                * plane_normal
                * plane_origin
                * elements_to_blank
                * plane_by_3nodeids
                * line_by_2nodeids
                * line_by_surface+normal
                * color_palette_band
                * spline_point
                * camera_origin_xyz
                * camera_origin_node
                * camera_direction_xyz
                * camera_direction_node
                * frame_origin
        
        Examples:
            ::
        
                ensight.view.pick_mode("part")
                ensight.view.pick_mode("cursor")
                ensight.view_transf.cursor(-9.941673,-39.746929,3.714395)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view.pick_mode({repr(p0)})'''
        return self._session.cmd(cmd)

    def query_mode(self, args: Any) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view.query_mode({repr(args)})'''
        return self._session.cmd(cmd)

    def raytrace_logo_visible(self, p0: str) -> int:
        """View: raytrace_logo_visible

        """
        cmd = f'''ensight.view.raytrace_logo_visible({repr(p0)})'''
        return self._session.cmd(cmd)

    def scale(self, p0: str) -> int:
        """View: scale

        """
        cmd = f'''ensight.view.scale({repr(p0)})'''
        return self._session.cmd(cmd)

    def static_lighting(self, p0: str) -> int:
        """View: static_lighting

        """
        cmd = f'''ensight.view.static_lighting({repr(p0)})'''
        return self._session.cmd(cmd)

    def stereo(self, p0: str) -> int:
        """Toggles stereo rendering.
        
        | Stereo rendering will only occur if the graphics hardware supports it.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.view.stereo("ON")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.view.stereo({repr(p0)})'''
        return self._session.cmd(cmd)

    def use_gamma_correction(self, p0: str) -> int:
        """View: use_gamma_correction

        """
        cmd = f'''ensight.view.use_gamma_correction({repr(p0)})'''
        return self._session.cmd(cmd)

    def varsize(self, p0: int, p1: int) -> int:
        """View: varsize

        """
        cmd = f'''ensight.view.varsize({repr(p0)},{repr(p1)})'''
        return self._session.cmd(cmd)

    def varsize_toggle(self) -> int:
        """View: varsize_toggle

        """
        cmd = f'''ensight.view.varsize_toggle()'''
        return self._session.cmd(cmd)

    def watermark(self, p0: str) -> int:
        """View: watermark

        """
        cmd = f'''ensight.view.watermark({repr(p0)})'''
        return self._session.cmd(cmd)


class vctarrow:
    """Class wrapper for EnSight vctarrow module

    This class acts as a proxy for the EnSight Python module ensight.vctarrow
    """
    def __init__(self, session: Session):
        self._session = session

    def arrow_attach(self, p0: str) -> int:
        """Vctarrow: arrow_attach

        """
        cmd = f'''ensight.vctarrow.arrow_attach({repr(p0)})'''
        return self._session.cmd(cmd)

    def arrow_location(self, p0: str) -> int:
        """Control the location of the arrows
        
        | Discrete particles can only use the 'node' vector location. 
        | For linear elements 'node' and 'vertices' give the same result. 
        
        Args:
            p0:
                'location'
        
                * vertices
                * node
                * element_center
        
        Examples:
            ::
        
                # WARNING: following line includes OBSOLETE call (ensight.variables.select_varname_begin).
                ensight.variables.select_varname_begin("Area ","Area2 ","variables: select_varname_end ","# ","# Saving the areas to a file ","# ","variables: save_constants /usr/tmp/my_constants","part: select_begin ","2 ")
                ensight.part.modify_begin()
                ensight.vctarrow.arrow_location("element_center")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.vctarrow.arrow_location({repr(p0)})'''
        return self._session.cmd(cmd)

    def arrow_type(self, p0: str) -> int:
        """Change the visual representation of the arrow shafts
        
        Args:
            p0:
                'type'
        
                * rectilinear
                * rect_fixed
                * curved
        
        Examples:
            ::
        
                ensight.part.select_begin(2)
                ensight.part.modify_begin()
                ensight.vctarrow.arrow_type("curved")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.vctarrow.arrow_type({repr(p0)})'''
        return self._session.cmd(cmd)

    def begin(self) -> int:
        """Delimit the modifications for vector arrow attributes
        
        | These commands are used to set the attributes for a vector arrow part creation. 
        
        Examples:
            ::
        
                ensight.vctarrow.begin()
                ensight.vctarrow.variable("VITESSE")
                ensight.vctarrow.end()
                ensight.vctarrow.create()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.vctarrow.begin()'''
        return self._session.cmd(cmd)

    def color_by_projection(self, p0: str) -> int:
        """Vctarrow: color_by_projection

        """
        cmd = f'''ensight.vctarrow.color_by_projection({repr(p0)})'''
        return self._session.cmd(cmd)

    def component(self, p0: float, p1: float, p2: float) -> int:
        """Specify a scaling factor for each component of the vector variable,  to be used in calculating both the magnitude and direction of the vector  arrow.
        
        | Specify 1 to use the full value of a component. Specify 0 to ignore the corresponding vector components (and thus confine all vector arrows to planes  perpendicular to that axis). 
        | Values may be negative to reverse the direction of the component.  
        
        Args:
            p0:
                'x_scale' scaling for the x-component 
            p1:
                'y_scale' scaling for the y-component 
            p2:
                'z_scale' scaling for the z-component 
        
        Examples:
            ::
        
                ensight.vctarrow.begin()
                ensight.vctarrow.variable("VITESSE")
                ensight.vctarrow.end()
                ensight.vctarrow.create()
                ensight.part.select_begin(2)
                ensight.part.modify_begin()
                ensight.vctarrow.component(2.0000e+00,1.0000e+00,1.0000e+00)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.vctarrow.component({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def create(self) -> int:
        """Create a new vector arrow part using the currently defined attributes and selected parent parts.
        
        | The vector variable must be set via the vctarrow: variable command before the part can be created. 
        
        Examples:
            ::
        
                ensight.variables.activate("VITESSE")
                ensight.part.select_all()
                ensight.vctarrow.begin()
                ensight.vctarrow.variable("VITESSE")
                ensight.vctarrow.end()
                ensight.vctarrow.create()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.vctarrow.create()'''
        return self._session.cmd(cmd)

    def density(self, p0: float) -> int:
        """Control the fraction of the parent's nodes which will display a vector.
        
        | A value of 0.0 results in no arrows, while a value of 1.0 results in an arrow at every node. Between these two values the arrows are randomly distributed at the specified density. 
        
        Args:
            p0:
                'value' density value between 0 and 1
        
        Examples:
            ::
        
                ensight.vctarrow.begin()
                ensight.vctarrow.variable("VITESSE")
                ensight.vctarrow.end()
                ensight.vctarrow.create()
                ensight.part.select_begin(2)
                ensight.part.modify_begin()
                ensight.vctarrow.density(5.0000e-01)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.vctarrow.density({repr(p0)})'''
        return self._session.cmd(cmd)

    def display_offset(self, p0: float) -> int:
        """Specify a visual offset for the vectors from the surface.
        
        | A positive offset moves the vector away from the surface in the direction of the normal. 
        
        Args:
            p0:
                'offset' offset in world coordinates
        
        Examples:
            ::
        
                ensight.vctarrow.begin()
                ensight.vctarrow.variable("VITESSE")
                ensight.vctarrow.end()
                ensight.vctarrow.create()
                ensight.part.select_begin(2)
                ensight.part.modify_begin()
                ensight.vctarrow.display_offset(1.0000e-01)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.vctarrow.display_offset({repr(p0)})'''
        return self._session.cmd(cmd)

    def end(self) -> int:
        """Delimit the modifications for vector arrow attributes
        
        | These commands are used to set the attributes for a vector arrow part creation. 
        
        Examples:
            ::
        
                ensight.vctarrow.begin()
                ensight.vctarrow.variable("VITESSE")
                ensight.vctarrow.end()
                ensight.vctarrow.create()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.vctarrow.end()'''
        return self._session.cmd(cmd)

    def instant(self, p0: float) -> int:
        """Vctarrow: instant

        """
        cmd = f'''ensight.vctarrow.instant({repr(p0)})'''
        return self._session.cmd(cmd)

    def projection(self, p0: str) -> int:
        """Apply a projection to the vectors prior to display
        
        | Vector components are scaled prior to computing the projections.  
        
        Args:
            p0:
                'proj'
        
                * all
                * normal
                * tangential
                * component
        
        Examples:
            ::
        
                ensight.variables.activate("velocity")
                ensight.vctarrow.begin()
                ensight.vctarrow.variable("velocity")
                ensight.vctarrow.end()
                ensight.vctarrow.create()
                ensight.part.select_begin(4)
                ensight.part.modify_begin()
                ensight.vctarrow.projection("component")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.vctarrow.projection({repr(p0)})'''
        return self._session.cmd(cmd)

    def scale_factor(self, p0: float) -> int:
        """Control the length of the vector arrows
        
        | If the arrow type is "Rectilinear" this parameter is a scaling multiple to change the magnitude of the vectors. If the type is "Rect_fixed" the parameter specifies the absolute magnitude for each vector. If the type is "Curved" this parameter controls the integration time for the streamlines which make up the curved part of the arrow. 
        
        Args:
            p0:
                'scale/time' scale factor or time
        
        Examples:
            ::
        
                ensight.vctarrow.begin()
                ensight.vctarrow.variable("VITESSE")
                ensight.vctarrow.end()
                ensight.vctarrow.create()
                ensight.part.select_begin(2)
                ensight.part.modify_begin()
                ensight.vctarrow.scale_factor(7.0000e-01)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.vctarrow.scale_factor({repr(p0)})'''
        return self._session.cmd(cmd)

    def select_default(self) -> int:
        """Sets the target to the default settings for subsequent attribute modifications.
        
        Examples:
            ::
        
                ensight.vctarrow.select_default()
                ensight.part.modify_begin()
                ensight.vctarrow.variable("VITESSE")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.vctarrow.select_default()'''
        return self._session.cmd(cmd)

    def threshold_high(self, p0: float) -> int:
        """Set the low or high threshold value
        
        | Used with vctarrow: thresholds
        
        Args:
            p0:
                'low' low filter threshold
            p1:
                'high' high filter threshold
        
        Examples:
            ::
        
                ensight.vctarrow.begin()
                ensight.vctarrow.variable("VITESSE")
                ensight.vctarrow.end()
                ensight.vctarrow.create()
                ensight.part.select_begin(2)
                ensight.part.modify_begin()
                ensight.vctarrow.thresholds("band")
                ensight.part.modify_end()
                ensight.part.modify_begin()
                ensight.vctarrow.threshold_low(5.0000e-1)
                ensight.part.modify_end()
                ensight.part.modify_begin()
                ensight.vctarrow.threshold_high(7.5000e-1)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.vctarrow.threshold_high({repr(p0)})'''
        return self._session.cmd(cmd)

    def threshold_low(self, p0: float) -> int:
        """Set the low or high threshold value
        
        | Used with vctarrow: thresholds
        
        Args:
            p0:
                'low' low filter threshold
            p1:
                'high' high filter threshold
        
        Examples:
            ::
        
                ensight.vctarrow.begin()
                ensight.vctarrow.variable("VITESSE")
                ensight.vctarrow.end()
                ensight.vctarrow.create()
                ensight.part.select_begin(2)
                ensight.part.modify_begin()
                ensight.vctarrow.thresholds("band")
                ensight.part.modify_end()
                ensight.part.modify_begin()
                ensight.vctarrow.threshold_low(5.0000e-1)
                ensight.part.modify_end()
                ensight.part.modify_begin()
                ensight.vctarrow.threshold_high(7.5000e-1)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.vctarrow.threshold_low({repr(p0)})'''
        return self._session.cmd(cmd)

    def thresholds(self, p0: str) -> int:
        """Apply a threshold filter to the selection of vectors for display.
        
        | Threshold filtering occurs after density filtering. When using both forms of filtering in combination the actual vector density may not be exactly as specified. 
        
        Args:
            p0:
                'type'
        
                * none
                * low
                * band
                * high
                * low_high
        
        Examples:
            ::
        
                ensight.vctarrow.begin()
                ensight.vctarrow.variable("VITESSE")
                ensight.vctarrow.end()
                ensight.vctarrow.create()
                ensight.part.select_begin(2)
                ensight.part.modify_begin()
                ensight.vctarrow.thresholds("band")
                ensight.part.modify_end()
                ensight.part.modify_begin()
                ensight.vctarrow.threshold_low(5.0000e-1)
                ensight.part.modify_end()
                ensight.part.modify_begin()
                ensight.vctarrow.threshold_high(7.5000e-1)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.vctarrow.thresholds({repr(p0)})'''
        return self._session.cmd(cmd)

    def tip_rgb(self, p0: float, p1: float, p2: float) -> int:
        """Change the color of the arrow tips
        
        | The color of the tip is only used when the tip shape is 'tipped' 
        
        Args:
            p0:
                'red_val' red, green, blue components of the color tip (range 0.0 to 1.0)
            p1:
                'grn_val' red, green, blue components of the color tip (range 0.0 to 1.0)
            p2:
                'blu_val' red, green, blue components of the color tip (range 0.0 to 1.0)
        
        Examples:
            ::
        
                ensight.vctarrow.begin()
                ensight.vctarrow.variable("VITESSE")
                ensight.vctarrow.end()
                ensight.vctarrow.create()
                ensight.part.select_begin(2)
                ensight.part.modify_begin()
                ensight.vctarrow.tip_shape("tipped")
                ensight.part.modify_end()
                ensight.part.modify_begin()
                ensight.vctarrow.tip_rgb(0.0000e00,1.0000e00,0.0000e00)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.vctarrow.tip_rgb({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def tip_shaft(self, p0: str) -> int:
        """Vctarrow: tip_shaft

        """
        cmd = f'''ensight.vctarrow.tip_shaft({repr(p0)})'''
        return self._session.cmd(cmd)

    def tip_shape(self, p0: str) -> int:
        """Change the visual representation of the arrow tips
        
        Args:
            p0:
                'type'
        
                * none
                * cone
                * normal
                * triangles
                * tipped
        
        Examples:
            ::
        
                ensight.vctarrow.begin()
                ensight.vctarrow.variable("VITESSE")
                ensight.vctarrow.end()
                ensight.vctarrow.create()
                ensight.part.select_begin(2)
                ensight.part.modify_begin()
                ensight.vctarrow.tip_shape("cone")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.vctarrow.tip_shape({repr(p0)})'''
        return self._session.cmd(cmd)

    def tip_size(self, p0: float) -> int:
        """Vctarrow: tip_size

        """
        cmd = f'''ensight.vctarrow.tip_size({repr(p0)})'''
        return self._session.cmd(cmd)

    def tip_size_fixed(self, p0: float) -> int:
        """This command has not yet been documented
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.vctarrow.tip_size_fixed({repr(p0)})'''
        return self._session.cmd(cmd)

    def tip_size_proportional(self, p0: float) -> int:
        """This command has not yet been documented
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.vctarrow.tip_size_proportional({repr(p0)})'''
        return self._session.cmd(cmd)

    def tip_size_rep(self, p0: str) -> int:
        """Set the method for determining tip size
        
        | This parameter is only used for 'triangle' or 'normal' arrow tips. 
        
        Args:
            p0:
                'rep'
        
                * fixed
                * proportional
        
        Examples:
            ::
        
                ensight.vctarrow.begin()
                ensight.vctarrow.variable("VITESSE")
                ensight.vctarrow.end()
                ensight.vctarrow.create()
                ensight.part.select_begin(2)
                ensight.part.modify_begin()
                ensight.vctarrow.tip_shape("triangle")
                ensight.part.modify_end()
                ensight.part.modify_begin()
                ensight.vctarrow.tip_size_rep("fixed")
                ensight.part.modify_end()
                ensight.part.modify_begin()
                ensight.vctarrow.tip_size(2.0000e-1)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.vctarrow.tip_size_rep({repr(p0)})'''
        return self._session.cmd(cmd)

    def variable(self, p0: Any) -> int:
        """Specify the vector variable to be used for vector arrow creation.
        
        | The variable must be activated before it can be used in a vector arrow plot. 
        
        Args:
            p0:
                'var_name' name of an active vector variable
        
        Examples:
            ::
        
                ensight.variables.activate("VITESSE")
                ensight.part.select_all()
                ensight.vctarrow.begin()
                ensight.vctarrow.variable("VITESSE")
                ensight.vctarrow.end()
                ensight.vctarrow.create()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.vctarrow.variable({repr(p0)})'''
        return self._session.cmd(cmd)


class variables:
    """Class wrapper for EnSight variables module

    This class acts as a proxy for the EnSight Python module ensight.variables
    """
    def __init__(self, session: Session):
        self._session = session

    def activate(self, p0: str) -> int:
        """Activates a variable.
        
        | A variable must be activated before it can be used for any purpose.
        
        Args:
            p0:
                'name' name of the variable to activate
        
        Examples:
            ::
        
                #
                # Activate a variable and use it
                # to color a part
                #
                ensight.variables.activate("temperature")
                ensight.part.select_begin(1)
                ensight.part.colorby_palette("temperature")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.variables.activate({repr(p0)})'''
        return self._session.cmd(cmd)

    def activate_all(self) -> int:
        """Activates all variables.
        
        Examples:
            ::
        
                # 
                # Activating all variables 
                # 
                ensight.variables.activate_all()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.variables.activate_all()'''
        return self._session.cmd(cmd)

    def deactivate(self, p0: str) -> int:
        """Deactivates a variable.
        
        | A deactivated variable is not available for use, but can be activated again if needed.
        | If a computed variable is deactivated it is deleted and must be re-specified if needed at a later time.
        
        Args:
            p0:
                'name' name of the variable to deactivate
        
        Examples:
            ::
        
                ensight.variables.deactivate("temperature")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.variables.deactivate({repr(p0)})'''
        return self._session.cmd(cmd)

    def evaluate(self, p0: str) -> int:
        """Creates a computed variable.
        
        | The expression must conform to one of the many supplied general functions or  proper math or calculator operations within EnSight. It is subject to all the  limitations of such, so please familiarize yourself with these.
        
        Args:
            p0:
                'expression' expression needed to create a computed variable
        
        Examples:
            ::
        
                ensight.part.select_all()
                ensight.variables.activate_all()
                ensight.variables.evaluate("Area = Area(plist)")
                ensight.variables.evaluate("Grad = Grad(plist,temperature)")
                ensight.variables.evaluate("CmplxTransResp = CmplxTransResp(plist,c_scalar,90.0)")
        
        Returns:
            zero on success, non-zero on error
        	
        See also:
            :doc:`Calculator Functions <../calc_functions>`

        """
        cmd = f'''ensight.variables.evaluate({repr(p0)})'''
        return self._session.cmd(cmd)

    def get_mainvarlist_select(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.variables.get_mainvarlist_select()'''
        return self._session.cmd(cmd)

    def load_constants(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.variables.load_constants({repr(p0)})'''
        return self._session.cmd(cmd)

    def modify_parameter(self, p0: str) -> int:
        """Modifies a parameter of a general function computed variable.
        
        | Currently only used for modifying the phase angle of a complex transient response variable.
        
        Args:
            p0:
                'varname' computed variable's name
            p1:
                'num' parameter number for the computed variable
            p2:
                'string or value' proper modified string, or number for the parameter specified
        
        Examples:
            ::
        
                ensight.variables.activate_all()
                ensight.part.select_all()
                ensight.variables.evaluate("CmplxTransResp = CmplxTransResp(plist,c_scalar,90.0)")
                ensight.function.palette("CmplxTransResp")
                ensight.variables.modify_parameter("CmplxTransResp param 3=1.1700e+02")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.variables.modify_parameter({repr(p0)})'''
        return self._session.cmd(cmd)

    def next_constant_isperpart(self, p0: str) -> int:
        """Variables: next_constant_isperpart

        """
        cmd = f'''ensight.variables.next_constant_isperpart({repr(p0)})'''
        return self._session.cmd(cmd)

    def notify_before_activate(self, p0: str) -> int:
        """A preference that can be set concerning notification when a variable will activated. Since EnSight by default activates variables automatically if needed, this command can cause a confirmation to be requested before a variable is activated. 
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.variables.notify_before_activate("ON")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.variables.notify_before_activate({repr(p0)})'''
        return self._session.cmd(cmd)

    def override_dialog_show(self) -> int:
        """Variables: override_dialog_show

        """
        cmd = f'''ensight.variables.override_dialog_show()'''
        return self._session.cmd(cmd)

    def override_gt_active(self, p0: str) -> int:
        """Variables: override_gt_active

        """
        cmd = f'''ensight.variables.override_gt_active({repr(p0)})'''
        return self._session.cmd(cmd)

    def override_gt_min(self, p0: float) -> int:
        """Variables: override_gt_min

        """
        cmd = f'''ensight.variables.override_gt_min({repr(p0)})'''
        return self._session.cmd(cmd)

    def override_gt_rgb(self, p0: float, p1: float, p2: float) -> int:
        """Variables: override_gt_rgb

        """
        cmd = f'''ensight.variables.override_gt_rgb({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def override_gt_useabs(self, p0: str) -> int:
        """Variables: override_gt_useabs

        """
        cmd = f'''ensight.variables.override_gt_useabs({repr(p0)})'''
        return self._session.cmd(cmd)

    def override_lt_active(self, p0: str) -> int:
        """Variables: override_lt_active

        """
        cmd = f'''ensight.variables.override_lt_active({repr(p0)})'''
        return self._session.cmd(cmd)

    def override_lt_min(self, p0: float) -> int:
        """Variables: override_lt_min

        """
        cmd = f'''ensight.variables.override_lt_min({repr(p0)})'''
        return self._session.cmd(cmd)

    def override_lt_rgb(self, p0: float, p1: float, p2: float) -> int:
        """Variables: override_lt_rgb

        """
        cmd = f'''ensight.variables.override_lt_rgb({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def override_lt_useabs(self, p0: str) -> int:
        """Variables: override_lt_useabs

        """
        cmd = f'''ensight.variables.override_lt_useabs({repr(p0)})'''
        return self._session.cmd(cmd)

    def override_modify_begin(self) -> int:
        """Variables: override_modify_begin

        """
        cmd = f'''ensight.variables.override_modify_begin()'''
        return self._session.cmd(cmd)

    def override_modify_end(self) -> int:
        """Variables: override_modify_end

        """
        cmd = f'''ensight.variables.override_modify_end()'''
        return self._session.cmd(cmd)

    def override_range_active(self, p0: str) -> int:
        """Variables: override_range_active

        """
        cmd = f'''ensight.variables.override_range_active({repr(p0)})'''
        return self._session.cmd(cmd)

    def override_range_max(self, p0: float) -> int:
        """Variables: override_range_max

        """
        cmd = f'''ensight.variables.override_range_max({repr(p0)})'''
        return self._session.cmd(cmd)

    def override_range_min(self, p0: float) -> int:
        """Variables: override_range_min

        """
        cmd = f'''ensight.variables.override_range_min({repr(p0)})'''
        return self._session.cmd(cmd)

    def override_range_rgb(self, p0: float, p1: float, p2: float) -> int:
        """Variables: override_range_rgb

        """
        cmd = f'''ensight.variables.override_range_rgb({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def override_range_useabs(self, p0: str) -> int:
        """Variables: override_range_useabs

        """
        cmd = f'''ensight.variables.override_range_useabs({repr(p0)})'''
        return self._session.cmd(cmd)

    def query_information(self, args: Any) -> int:
        """Variables: query_information

        """
        cmd = f'''ensight.variables.query_information({repr(args)})'''
        return self._session.cmd(cmd)

    def query_objects(self, args: Any) -> int:
        """Variables: query_objects

        """
        cmd = f'''ensight.variables.query_objects({repr(args)})'''
        return self._session.cmd(cmd)

    def save_all_constants(self, p0: str, p1: str, p2: str, p3: str) -> int:
        """Saves all active constant variable values to a file.
        
        Args:
            p0:
                'filename' name of the file in which to save the constants
        
        Examples:
            ::
        
                # 
                # Activating all variables 
                # 
                ensight.variables.activate_all()
                # 
                # Computing area of one part 
                # 
                ensight.part.select_begin(1)
                ensight.variables.evaluate("Area = Area(plist)")
                # 
                # Computing area of another part 
                # 
                ensight.part.select_begin(2)
                ensight.variables.evaluate("Area2 = Area(plist)")
                ensight.variables.save_all_constants("/usr/tmp/all_constants")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.variables.save_all_constants({repr(p0)},{repr(p1)},{repr(p2)},{repr(p3)})'''
        return self._session.cmd(cmd)

    def save_constants(self, p0: str, p1: str, p2: str, p3: str) -> int:
        """Saves selected constant variable values to a file.
        
        Args:
            p0:
                'filename' name of the file in which to save the constants
        
        Examples:
            ::
        
                # 
                # Activating all variables 
                # 
                ensight.variables.activate_all()
                # 
                # Computing area of one part 
                # 
                ensight.part.select_begin(1)
                ensight.variables.evaluate("Area = Area(plist)")
                # 
                # Computing area of another part 
                # 
                ensight.part.select_begin(2)
                ensight.variables.evaluate("Area2 = Area(plist)")
                # 
                # Selecting the computed area constant to write them out 
                # 
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.variables.save_constants({repr(p0)},{repr(p1)},{repr(p2)},{repr(p3)})'''
        return self._session.cmd(cmd)

    def select_begin(self, *args, **kwargs) -> Any:
        """Variables: select_begin

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.variables.select_begin({arg_string})"
        return self._session.cmd(cmd)

    def select_byname_begin(self, *args, **kwargs) -> Any:
        """Selects variables for future use.
        
        Args:
            p0:
                'varname' valid name of a variable
        
        Examples:
            ::
        
                # WARNING: following line includes OBSOLETE call (ensight.variables.select_varname_begin).
                ensight.variables.select_varname_begin("Area ","Area2 ","variables: select_varname_end ","# ","# Saving the areas to a file ","# ","variables: save_constants /usr/tmp/my_constants","# ","# Activating all variables ","# ","variables: activate_all ","# ","# Computing area of one part ","# ","part: select_begin ","1 ")
                ensight.variables.evaluate("Area = Area(plist)")
                # 
                # Computing area of another part 
                # 
                ensight.part.select_begin(2)
                ensight.variables.evaluate("Area2 = Area(plist)")
                # 
                # Selecting the computed area constant to write them out 
                # 
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.variables.select_byname_begin({arg_string})"
        return self._session.cmd(cmd)

    def select_byname_end(self) -> int:
        """Selects variables for future use.
        
        Args:
            p0:
                'varname' valid name of a variable
        
        Examples:
            ::
        
                # WARNING: following line includes OBSOLETE call (ensight.variables.select_varname_begin).
                ensight.variables.select_varname_begin("Area ","Area2 ","variables: select_varname_end ","# ","# Saving the areas to a file ","# ","variables: save_constants /usr/tmp/my_constants","# ","# Activating all variables ","# ","variables: activate_all ","# ","# Computing area of one part ","# ","part: select_begin ","1 ")
                ensight.variables.evaluate("Area = Area(plist)")
                # 
                # Computing area of another part 
                # 
                ensight.part.select_begin(2)
                ensight.variables.evaluate("Area2 = Area(plist)")
                # 
                # Selecting the computed area constant to write them out 
                # 
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.variables.select_byname_end()'''
        return self._session.cmd(cmd)

    def select_varname_begin(self, args: Any) -> int:
        """Variables: select_varname_begin

        """
        cmd = f'''ensight.variables.select_varname_begin({repr(args)})'''
        return self._session.cmd(cmd)

    def select_varname_end(self) -> int:
        """Variables: select_varname_end

        """
        cmd = f'''ensight.variables.select_varname_end()'''
        return self._session.cmd(cmd)

    def set_working(self, p0: str, p1: str) -> int:
        """Variables: set_working

        """
        cmd = f'''ensight.variables.set_working({repr(p0)},{repr(p1)})'''
        return self._session.cmd(cmd)


class varextcfd:
    """Class wrapper for EnSight varextcfd module

    This class acts as a proxy for the EnSight Python module ensight.varextcfd
    """
    def __init__(self, session: Session):
        self._session = session

    def density(self, p0: str) -> int:
        """Set the density basis variable.
        
        | For extended CFD variables to be computed, the basis variables must be identified and the basis constants defined.
        
        Args:
            p0:
                'var' name of the density variable
        
        Examples:
            ::
        
                #
                # Activating all variables in this case
                #
                ensight.variables.activate_all()
                #
                # Making extended variables available
                #
                ensight.varextcfd.show_extended("ON")
                #
                # Setting the basis variables and constants
                #
                ensight.varextcfd.modify_begin()
                ensight.varextcfd.density("Density")
                ensight.varextcfd.momentum("Momentum")
                ensight.varextcfd.total_energy("Energy")
                ensight.varextcfd.ratio_of_spec_heat("1.4000e+00")
                ensight.varextcfd.freestream_mach(1.0000e+00)
                ensight.varextcfd.gas_constant(1.0000e+00)
                ensight.varextcfd.freestream_density(1.0000e+00)
                ensight.varextcfd.freestream_speed_sound(1.0000e+00)
                ensight.varextcfd.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.varextcfd.density({repr(p0)})'''
        return self._session.cmd(cmd)

    def freestream_density(self, p0: float) -> int:
        """Set the freestream density constant.
        
        | For extended CFD variables to be computed, the basis variables must be identified and the basis constants defined.
        
        Args:
            p0:
                'dens' desired value of the freestream density constant
        
        Examples:
            ::
        
                #
                # Activating all variables in this case
                #
                ensight.variables.activate_all()
                #
                # Making extended variables available
                #
                ensight.varextcfd.show_extended("ON")
                #
                # Setting the basis variables and constants
                #
                ensight.varextcfd.modify_begin()
                ensight.varextcfd.density("Density")
                ensight.varextcfd.momentum("Momentum")
                ensight.varextcfd.total_energy("Energy")
                ensight.varextcfd.ratio_of_spec_heat("1.4000e+00")
                ensight.varextcfd.freestream_mach(1.0000e+00)
                ensight.varextcfd.gas_constant(1.0000e+00)
                ensight.varextcfd.freestream_density(1.0000e+00)
                ensight.varextcfd.freestream_speed_sound(1.0000e+00)
                ensight.varextcfd.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.varextcfd.freestream_density({repr(p0)})'''
        return self._session.cmd(cmd)

    def freestream_mach(self, p0: float) -> int:
        """Set the freestream mach number constant.
        
        | For extended CFD variables to be computed, the basis variables must be identified and the basis constants defined.
        
        Args:
            p0:
                'num' desired value of the freestream mach number constant
        
        Examples:
            ::
        
                #
                # Activating all variables in this case
                #
                ensight.variables.activate_all()
                #
                # Making extended variables available
                #
                ensight.varextcfd.show_extended("ON")
                #
                # Setting the basis variables and constants
                #
                ensight.varextcfd.modify_begin()
                ensight.varextcfd.density("Density")
                ensight.varextcfd.momentum("Momentum")
                ensight.varextcfd.total_energy("Energy")
                ensight.varextcfd.ratio_of_spec_heat("1.4000e+00")
                ensight.varextcfd.freestream_mach(1.0000e+00)
                ensight.varextcfd.gas_constant(1.0000e+00)
                ensight.varextcfd.freestream_density(1.0000e+00)
                ensight.varextcfd.freestream_speed_sound(1.0000e+00)
                ensight.varextcfd.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.varextcfd.freestream_mach({repr(p0)})'''
        return self._session.cmd(cmd)

    def freestream_speed_sound(self, p0: float) -> int:
        """Set the freestream speed of sound constant.
        
        | For extended CFD variables to be computed, the basis variables must be identified and the basis constants defined.
        
        Args:
            p0:
                'num' desired value of the freestream speed of sound constant
        
        Examples:
            ::
        
                #
                # Activating all variables in this case
                #
                ensight.variables.activate_all()
                #
                # Making extended variables available
                #
                ensight.varextcfd.show_extended("ON")
                #
                # Setting the basis variables and constants
                #
                ensight.varextcfd.modify_begin()
                ensight.varextcfd.density("Density")
                ensight.varextcfd.momentum("Momentum")
                ensight.varextcfd.total_energy("Energy")
                ensight.varextcfd.ratio_of_spec_heat("1.4000e+00")
                ensight.varextcfd.freestream_mach(1.0000e+00)
                ensight.varextcfd.gas_constant(1.0000e+00)
                ensight.varextcfd.freestream_density(1.0000e+00)
                ensight.varextcfd.freestream_speed_sound(1.0000e+00)
                ensight.varextcfd.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.varextcfd.freestream_speed_sound({repr(p0)})'''
        return self._session.cmd(cmd)

    def gas_constant(self, p0: float) -> int:
        """Set the gas constant.
        
        | For extended CFD variables to be computed, the basis variables must be identified and the basis constants defined.
        
        Args:
            p0:
                'num' desired value of the gas constant
        
        Examples:
            ::
        
                #
                # Activating all variables in this case
                #
                ensight.variables.activate_all()
                #
                # Making extended variables available
                #
                ensight.varextcfd.show_extended("ON")
                #
                # Setting the basis variables and constants
                #
                ensight.varextcfd.modify_begin()
                ensight.varextcfd.density("Density")
                ensight.varextcfd.momentum("Momentum")
                ensight.varextcfd.total_energy("Energy")
                ensight.varextcfd.ratio_of_spec_heat("1.4000e+00")
                ensight.varextcfd.freestream_mach(1.0000e+00)
                ensight.varextcfd.gas_constant(1.0000e+00)
                ensight.varextcfd.freestream_density(1.0000e+00)
                ensight.varextcfd.freestream_speed_sound(1.0000e+00)
                ensight.varextcfd.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.varextcfd.gas_constant({repr(p0)})'''
        return self._session.cmd(cmd)

    def modify_begin(self) -> int:
        """Delimit the modifications to the extended CFD attributes.
        
        | For extended CFD variables to be computed, the basis variables must be identified and the basis constants defined.
        | These are optional commands which increase performance since all changes are made at one time.
        
        Args:
            p0:
                'varextcfd_command' any of the varextcfd commands
        
        Examples:
            ::
        
                #
                # Activating all variables in this case
                #
                ensight.variables.activate_all()
                #
                # Making extended variables available
                #
                ensight.varextcfd.show_extended("ON")
                #
                # Setting the basis variables and constants
                #
                ensight.varextcfd.modify_begin()
                ensight.varextcfd.density("Density")
                ensight.varextcfd.momentum("Momentum")
                ensight.varextcfd.total_energy("Energy")
                ensight.varextcfd.ratio_of_spec_heat("1.4000e+00")
                ensight.varextcfd.freestream_mach(1.0000e+00)
                ensight.varextcfd.gas_constant(1.0000e+00)
                ensight.varextcfd.freestream_density(1.0000e+00)
                ensight.varextcfd.freestream_speed_sound(1.0000e+00)
                ensight.varextcfd.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.varextcfd.modify_begin()'''
        return self._session.cmd(cmd)

    def modify_end(self) -> int:
        """Delimit the modifications to the extended CFD attributes.
        
        | For extended CFD variables to be computed, the basis variables must be identified and the basis constants defined.
        | These are optional commands which increase performance since all changes are made at one time.
        
        Args:
            p0:
                'varextcfd_command' any of the varextcfd commands
        
        Examples:
            ::
        
                #
                # Activating all variables in this case
                #
                ensight.variables.activate_all()
                #
                # Making extended variables available
                #
                ensight.varextcfd.show_extended("ON")
                #
                # Setting the basis variables and constants
                #
                ensight.varextcfd.modify_begin()
                ensight.varextcfd.density("Density")
                ensight.varextcfd.momentum("Momentum")
                ensight.varextcfd.total_energy("Energy")
                ensight.varextcfd.ratio_of_spec_heat("1.4000e+00")
                ensight.varextcfd.freestream_mach(1.0000e+00)
                ensight.varextcfd.gas_constant(1.0000e+00)
                ensight.varextcfd.freestream_density(1.0000e+00)
                ensight.varextcfd.freestream_speed_sound(1.0000e+00)
                ensight.varextcfd.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.varextcfd.modify_end()'''
        return self._session.cmd(cmd)

    def momentum(self, p0: str) -> int:
        """Set the momentum basis variable.
        
        | For extended CFD variables to be computed, the basis variables must be identified and the basis constants defined. You must define either momentum or velocity for a basis, but not both.
        
        Args:
            p0:
                'var' name of the momentum variable
        
        Examples:
            ::
        
                #
                # Activating all variables in this case
                #
                ensight.variables.activate_all()
                #
                # Making extended variables available
                #
                ensight.varextcfd.show_extended("ON")
                #
                # Setting the basis variables and constants
                #
                ensight.varextcfd.modify_begin()
                ensight.varextcfd.density("Density")
                ensight.varextcfd.momentum("Momentum")
                ensight.varextcfd.total_energy("Energy")
                ensight.varextcfd.ratio_of_spec_heat("1.4000e+00")
                ensight.varextcfd.freestream_mach(1.0000e+00)
                ensight.varextcfd.gas_constant(1.0000e+00)
                ensight.varextcfd.freestream_density(1.0000e+00)
                ensight.varextcfd.freestream_speed_sound(1.0000e+00)
                ensight.varextcfd.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.varextcfd.momentum({repr(p0)})'''
        return self._session.cmd(cmd)

    def ratio_of_spec_heat(self, p0: str) -> int:
        """Varextcfd: ratio_of_spec_heat

        """
        cmd = f'''ensight.varextcfd.ratio_of_spec_heat({repr(p0)})'''
        return self._session.cmd(cmd)

    def show_extended(self, p0: str) -> int:
        """Make extended CFD variables available or not.
        
        | For extended CFD variables to be computed, the basis variables must be identified and the basis constants defined.  Once the basis variables and constants are defined, and this command makes them available - the variables can be computed when activated or used.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                #
                # Activating all variables in this case
                #
                ensight.variables.activate_all()
                #
                # Making extended variables available
                #
                ensight.varextcfd.show_extended("ON")
                #
                # Setting the basis variables and constants
                #
                ensight.varextcfd.modify_begin()
                ensight.varextcfd.density("Density")
                ensight.varextcfd.momentum("Momentum")
                ensight.varextcfd.total_energy("Energy")
                ensight.varextcfd.ratio_of_spec_heat("1.4000e+00")
                ensight.varextcfd.freestream_mach(1.0000e+00)
                ensight.varextcfd.gas_constant(1.0000e+00)
                ensight.varextcfd.freestream_density(1.0000e+00)
                ensight.varextcfd.freestream_speed_sound(1.0000e+00)
                ensight.varextcfd.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.varextcfd.show_extended({repr(p0)})'''
        return self._session.cmd(cmd)

    def total_energy(self, p0: str) -> int:
        """Set the total_energy basis variable.
        
        | For extended CFD variables to be computed, the basis variables must be identified and the basis constants defined.
        
        Args:
            p0:
                'var' name of the total_energy variable
        
        Examples:
            ::
        
                #
                # Activating all variables in this case
                #
                ensight.variables.activate_all()
                #
                # Making extended variables available
                #
                ensight.varextcfd.show_extended("ON")
                #
                # Setting the basis variables and constants
                #
                ensight.varextcfd.modify_begin()
                ensight.varextcfd.density("Density")
                ensight.varextcfd.momentum("Momentum")
                ensight.varextcfd.total_energy("Energy")
                ensight.varextcfd.ratio_of_spec_heat("1.4000e+00")
                ensight.varextcfd.freestream_mach(1.0000e+00)
                ensight.varextcfd.gas_constant(1.0000e+00)
                ensight.varextcfd.freestream_density(1.0000e+00)
                ensight.varextcfd.freestream_speed_sound(1.0000e+00)
                ensight.varextcfd.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.varextcfd.total_energy({repr(p0)})'''
        return self._session.cmd(cmd)

    def velocity(self, p0: str) -> int:
        """Set the velocity basis variable.
        
        | For extended CFD variables to be computed, the basis variables must be identified and the basis constants defined.  You must define either momentum or velocity for a basis, but not both.
        
        Args:
            p0:
                'var' name of the velocity variable
        
        Examples:
            ::
        
                #
                # Activating all variables in this case
                #
                ensight.variables.activate_all()
                #
                # Making extended variables available
                #
                ensight.varextcfd.show_extended("ON")
                #
                # Setting the basis variables and constants
                #
                ensight.varextcfd.modify_begin()
                ensight.varextcfd.density("Density")
                ensight.varextcfd.velocity("Velocity")
                ensight.varextcfd.total_energy("Energy")
                ensight.varextcfd.ratio_of_spec_heat("1.4000e+00")
                ensight.varextcfd.freestream_mach(1.0000e+00)
                ensight.varextcfd.gas_constant(1.0000e+00)
                ensight.varextcfd.freestream_density(1.0000e+00)
                ensight.varextcfd.freestream_speed_sound(1.0000e+00)
                ensight.varextcfd.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.varextcfd.velocity({repr(p0)})'''
        return self._session.cmd(cmd)


class user:
    """Class wrapper for EnSight user module

    This class acts as a proxy for the EnSight Python module ensight.user
    """
    def __init__(self, session: Session):
        self._session = session

    def replace(self, p0: str) -> int:
        """User: replace

        """
        cmd = f'''ensight.user.replace({repr(p0)})'''
        return self._session.cmd(cmd)

    def type(self, p0: str) -> int:
        """User: type

        """
        cmd = f'''ensight.user.type({repr(p0)})'''
        return self._session.cmd(cmd)


class tools:
    """Class wrapper for EnSight tools module

    This class acts as a proxy for the EnSight Python module ensight.tools
    """
    def __init__(self, session: Session):
        self._session = session

    def box(self, p0: str) -> int:
        """Turns the box tool on or off.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.tools.box("ON")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.tools.box({repr(p0)})'''
        return self._session.cmd(cmd)

    def cursor(self, p0: str) -> int:
        """Turns the cursor tool on or off.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.tools.cursor("ON")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.tools.cursor({repr(p0)})'''
        return self._session.cmd(cmd)

    def element_blank_domain(self, p0: str) -> int:
        """Determines the domain to blank out elements using the element blank tool.
        
        Args:
            p0:
                '' inside
            p1:
                '' outside
        
        Examples:
            ::
        
                ensight.tools.element_blank_domain("inside")
                ensight.tools.element_blank_domain("outside")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.tools.element_blank_domain({repr(p0)})'''
        return self._session.cmd(cmd)

    def element_blank_layer(self, p0: str) -> int:
        """Determines the domain layer to blank out elements using the element blank tool.
        
        Args:
            p0:
                '' top
            p1:
                '' all
        
        Examples:
            ::
        
                ensight.tools.element_blank_layer("top")
                ensight.tools.element_blank_layer("all")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.tools.element_blank_layer({repr(p0)})'''
        return self._session.cmd(cmd)

    def line(self, p0: str) -> int:
        """Turns the line tool on or off.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.tools.line("ON")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.tools.line({repr(p0)})'''
        return self._session.cmd(cmd)

    def line_normal(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.tools.line_normal({repr(p0)})'''
        return self._session.cmd(cmd)

    def line_restricttosurface(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.tools.line_restricttosurface({repr(p0)})'''
        return self._session.cmd(cmd)

    def plane(self, p0: str) -> int:
        """Turns the plane tool on or off.
        
        Args:
            p0:
                'option'
        
                * ON
                * OFF
                * LINE
                * FILLED
        
        Examples:
            ::
        
                ensight.tools.plane("ON")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.tools.plane({repr(p0)})'''
        return self._session.cmd(cmd)

    def quadric(self, p0: str) -> int:
        """Turns the quadric tool on or off.
        
        Args:
            p0:
                'option'
        
                * CYLINDER
                * SPHERE
                * CONE
                * REVOLUTION
                * NONE
        
        Examples:
            ::
        
                ensight.tools.quadric("SPHERE")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.tools.quadric({repr(p0)})'''
        return self._session.cmd(cmd)

    def select_tool(self, p0: str) -> int:
        """Turns the selection tool on or off.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.tools.select_tool("ON")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.tools.select_tool({repr(p0)})'''
        return self._session.cmd(cmd)


class texture:
    """Class wrapper for EnSight texture module

    This class acts as a proxy for the EnSight Python module ensight.texture
    """
    def __init__(self, session: Session):
        self._session = session

    def autoscale(self, p0: str) -> int:
        """Sets the state of temporal autoscaling for the currently selected texture. If enabled, the time limits for the texture will always be the minimum and maximum solution times currently loaded into EnSight. 
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.texture.select(1)
                ensight.texture.autoscale("ON")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.texture.autoscale({repr(p0)})'''
        return self._session.cmd(cmd)

    def border_rgb(self, p0: float, p1: float, p2: float) -> int:
        """Selects a texture slot for editing. 
        
        Args:
            p0:
                'red_val' red, green, blue components of the color (range 0.0 to 1.0)
            p1:
                'grn_val' red, green, blue components of the color (range 0.0 to 1.0)
            p2:
                'blu_val' red, green, blue components of the color (range 0.0 to 1.0)
        
        Examples:
            ::
        
                ensight.texture.select(1)
                ensight.texture.border_rgb(1,.5,0.)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.texture.border_rgb({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def border_transparency(self, p0: float) -> int:
        """Sets the transparency value that will be used outside of the texture space when the texture is clamped
        
        Args:
            p0:
                'alpha' A 0 to 1 transparency value.  0 is fully transparent while 1 is fully opaque
        
        Examples:
            ::
        
                ensight.texture.select(1)
                ensight.texture.border_rgb(1,.5,0.)
                ensight.texture.border_transparency(0.)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.texture.border_transparency({repr(p0)})'''
        return self._session.cmd(cmd)

    def clear(self) -> int:
        """Remove the texture from the texture slot. 
        
        Examples:
            ::
        
                ensight.texture.select(0)
                ensight.texture.clear()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.texture.clear()'''
        return self._session.cmd(cmd)

    def compress(self, p0: str) -> int:
        """Sets the internal compression scheme EnSight uses in memory for the currently selected texture. Scenario files will contain textures stored with the selected form of compression. 
        
        Args:
            p0:
                'RAW'
        
                * compression scheme to use.
            p1:
                'RLE'
        
                * compression scheme to use.
            p2:
                'GZIP'
        
                * compression scheme to use.
        
        Examples:
            ::
        
                ensight.texture.select(1)
                ensight.texture.compress("RLE")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.texture.compress({repr(p0)})'''
        return self._session.cmd(cmd)

    def display_type(self, p0: str) -> int:
        """Set the texture to accept color, color+alpha, or just alpha from the loaded image.
        
        Args:
            p0:
                'type'
        
                * rgba
                * rgb
                * a
        
        Examples:
            ::
        
                ensight.texture.select(0)
                ensight.texture.display_type("rgb")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.texture.display_type({repr(p0)})'''
        return self._session.cmd(cmd)

    def frame_limits(self, p0: int, p1: int) -> int:
        """Sets the starting and ending frame numbers for the currently selected texture. These values along with the current EnSight solution time and texture time limits, select which animation frame to display for an animated texture. 
        
        Args:
            p0:
                'start_frame' start and end frames for the texture
            p1:
                'end_frame' start and end frames for the texture
        
        Examples:
            ::
        
                ensight.texture.select(0)
                ensight.texture.frame_limits(0,24)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.texture.frame_limits({repr(p0)},{repr(p1)})'''
        return self._session.cmd(cmd)

    def read(self, p0: str) -> int:
        """Load a texture. 
        
        | Textures must have a resolution of powers of 2.   Any image resolution outside of the acceptable resolution will be truncated.
        
        Args:
            p0:
                'filename' the image filename to be used as the texture
        
        Examples:
            ::
        
                ensight.texture.select(0)
                ensight.texture.read("/tmp/grass.jpg")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.texture.read({repr(p0)})'''
        return self._session.cmd(cmd)

    def select(self, p0: int) -> int:
        """Selects a texture slot for editing. 
        
        Args:
            p0:
                'num' the texture slot for editing (0 to 7 inclusive)
        
        Examples:
            ::
        
                ensight.texture.select(0)
                ensight.texture.read("/tmp/grass.jpg")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.texture.select({repr(p0)})'''
        return self._session.cmd(cmd)

    def time_limits(self, p0: float, p1: float) -> int:
        """Sets the starting and ending solution time for the currently selected texture. These values along with the current EnSight solution time and texture frame limits, select which animation frame to display for an animated texture. Note: if autoscaling is enabled, these values are ignored
        
        Args:
            p0:
                'start_time' start and end times for the texture
            p1:
                'end_time' start and end times for the texture
        
        Examples:
            ::
        
                ensight.texture.select(0)
                ensight.texture.time_limits(0.0,5.163)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.texture.time_limits({repr(p0)},{repr(p1)})'''
        return self._session.cmd(cmd)


class text:
    """Class wrapper for EnSight text module

    This class acts as a proxy for the EnSight Python module ensight.text
    """
    def __init__(self, session: Session):
        self._session = session

    def change_text(self, p0: str) -> int:
        """Replaces the currently selected annotation text. 
        
        Args:
            p0:
                'revised_text' desired revised text
        
        Examples:
            ::
        
                ensight.text.select_begin(1)
                ensight.text.change_text("this is the revised text!")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.text.change_text({repr(p0)})'''
        return self._session.cmd(cmd)

    def code(self, p0: str) -> int:
        """Text: code

        """
        cmd = f'''ensight.text.code({repr(p0)})'''
        return self._session.cmd(cmd)

    def color(self, p0: int) -> int:
        """Text: color

        """
        cmd = f'''ensight.text.color({repr(p0)})'''
        return self._session.cmd(cmd)

    def delete(self) -> int:
        """Deletes the currently selected text in the graphics window. 
        
        Examples:
            ::
        
                ensight.text.select_begin(1,2,3)
                ensight.text.delete()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.text.delete()'''
        return self._session.cmd(cmd)

    def description(self, p0: str) -> int:
        """Text: description

        """
        cmd = f'''ensight.text.description({repr(p0)})'''
        return self._session.cmd(cmd)

    def deselect_all(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.text.deselect_all()'''
        return self._session.cmd(cmd)

    def justification(self, p0: str) -> int:
        """Specifies the placement of the selected text in the graphics window, in relation to the point specified in the text: location_x and location_y commands.
        
        | The default value for justification is left.
        | Also denotes the point about which the text rotates.
        
        Args:
            p0:
                'justification_type'
        
                * Must have one of the following values:
                * left
                * center
                * right
        
        Examples:
            ::
        
                ensight.text.select_begin(1)
                ensight.text.location_x(0.5)
                ensight.text.location_y(0.6)
                ensight.text.justification("left")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.text.justification({repr(p0)})'''
        return self._session.cmd(cmd)

    def location_x(self, p0: float) -> int:
        """Specifies the x/y coordinate of the selected text in the currently selected viewport.
        
        | The text position can also be in reference to a specific viewport.
        | See "text: relative_viewport" command.
        
        Args:
            p0:
                'coord' A value of 0.0 indicates the left/bottom side of the window, while a value of 1.0 indicates the right/top side.
        
        Examples:
            ::
        
                ensight.text.select_begin(1)
                ensight.text.relative_viewport(2)
                ensight.text.location_x(0.5)
                ensight.text.location_y(0.5)
                ensight.text.justification("center")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.text.location_x({repr(p0)})'''
        return self._session.cmd(cmd)

    def location_y(self, p0: float) -> int:
        """Specifies the x/y coordinate of the selected text in the currently selected viewport.
        
        | The text position can also be in reference to a specific viewport.
        | See "text: relative_viewport" command.
        
        Args:
            p0:
                'coord' A value of 0.0 indicates the left/bottom side of the window, while a value of 1.0 indicates the right/top side.
        
        Examples:
            ::
        
                ensight.text.select_begin(1)
                ensight.text.relative_viewport(2)
                ensight.text.location_x(0.5)
                ensight.text.location_y(0.5)
                ensight.text.justification("center")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.text.location_y({repr(p0)})'''
        return self._session.cmd(cmd)

    def mix_rgb(self, p0: float, p1: float, p2: float, p3: float) -> int:
        """Text: mix_rgb

        """
        cmd = f'''ensight.text.mix_rgb({repr(p0)},{repr(p1)},{repr(p2)},{repr(p3)})'''
        return self._session.cmd(cmd)

    def modify_begin(self) -> int:
        """Delimit the modifications for text attributes.
        
        | These optional commands can be used to execute a number of attribute changes at one time for better performance.
        
        Examples:
            ::
        
                ensight.text.select_begin(1)
                ensight.text.modify_begin()
                ensight.text.rgb(1,0,0)
                ensight.text.location_x(100)
                ensight.text.location_y(20)
                ensight.text.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.text.modify_begin()'''
        return self._session.cmd(cmd)

    def modify_end(self) -> int:
        """Delimit the modifications for text attributes.
        
        | These optional commands can be used to execute a number of attribute changes at one time for better performance.
        
        Examples:
            ::
        
                ensight.text.select_begin(1)
                ensight.text.modify_begin()
                ensight.text.rgb(1,0,0)
                ensight.text.location_x(100)
                ensight.text.location_y(20)
                ensight.text.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.text.modify_end()'''
        return self._session.cmd(cmd)

    def new_or_mod_text(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.text.new_or_mod_text({repr(p0)})'''
        return self._session.cmd(cmd)

    def new_text(self, p0: str) -> int:
        """Creates new text in the graphics window. 
        
        Args:
            p0:
                'text' desired text
        
        Examples:
            ::
        
                ensight.text.new_text("This is the new text!")
                ensight.text.location_x(0.5)
                ensight.text.location_y(0.6)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.text.new_text({repr(p0)})'''
        return self._session.cmd(cmd)

    def origin(self, p0: float, p1: float, p2: float) -> int:
        """Text: origin

        """
        cmd = f'''ensight.text.origin({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def origin_by(self, p0: str) -> int:
        """Text: origin_by

        """
        cmd = f'''ensight.text.origin_by({repr(p0)})'''
        return self._session.cmd(cmd)

    def origin_frame(self, p0: int) -> int:
        """Text: origin_frame

        """
        cmd = f'''ensight.text.origin_frame({repr(p0)})'''
        return self._session.cmd(cmd)

    def query_count(self, args: Any) -> int:
        """Text: query_count

        """
        cmd = f'''ensight.text.query_count({repr(args)})'''
        return self._session.cmd(cmd)

    def query_display_attributes(self, args: Any) -> int:
        """Text: query_display_attributes

        """
        cmd = f'''ensight.text.query_display_attributes({repr(args)})'''
        return self._session.cmd(cmd)

    def query_selected_objects(self, args: Any) -> int:
        """Text: query_selected_objects

        """
        cmd = f'''ensight.text.query_selected_objects({repr(args)})'''
        return self._session.cmd(cmd)

    def query_text(self, args: Any) -> int:
        """Text: query_text

        """
        cmd = f'''ensight.text.query_text({repr(args)})'''
        return self._session.cmd(cmd)

    def relative_to(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.text.relative_to({repr(p0)})'''
        return self._session.cmd(cmd)

    def relative_viewport(self, p0: int) -> int:
        """Specifies the viewport to which location of the selected text will be relative, when specified by the text: location_x and location_y commands.
        
        | A value of zero indicates the graphics window.
        
        Args:
            p0:
                'viewport' specifies the viewport
        
        Examples:
            ::
        
                ensight.text.select_begin(1)
                ensight.text.relative_viewport(0)
                ensight.text.location_x(0.5)
                ensight.text.location_y(0.6)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.text.relative_viewport({repr(p0)})'''
        return self._session.cmd(cmd)

    def rgb(self, p0: float, p1: float, p2: float) -> int:
        """Specifies the RGB color value of the selected text in the graphics window.
        
        Args:
            p0:
                'red_val' red, green, blue color components, ( 0.0 to 1.0).
            p1:
                'grn_val' red, green, blue color components, ( 0.0 to 1.0).
            p2:
                'blu_val' red, green, blue color components, ( 0.0 to 1.0).
        
        Examples:
            ::
        
                ensight.text.select_begin(1)
                ensight.text.rgb(1.0,0,0)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.text.rgb({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def rotational_angle(self, p0: float) -> int:
        """Specifies the angle of rotation of the selected text in the graphics window.
        
        | A value of 0 for rotation corresponds to the normal, upright orientation of text, with clockwise rotation at higher values.
        | The text rotates about the justification point.
        
        Args:
            p0:
                'angle' must be within the range of 0.0 to 360.0
        
        Examples:
            ::
        
                ensight.text.select_begin(1)
                ensight.text.rotational_angle(45.0)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.text.rotational_angle({repr(p0)})'''
        return self._session.cmd(cmd)

    def select_all(self) -> int:
        """Text: select_all

        """
        cmd = f'''ensight.text.select_all()'''
        return self._session.cmd(cmd)

    def select_all_invisible(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.text.select_all_invisible()'''
        return self._session.cmd(cmd)

    def select_all_visible(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.text.select_all_visible()'''
        return self._session.cmd(cmd)

    def select_begin(self, *args, **kwargs) -> Any:
        """Selects one or more text strings in the graphics window as the target for future text: commands 
        
        Args:
            p0:
                'indexN' The text annotation ID
        
        Examples:
            ::
        
                ensight.text.select_begin(1,2)
                ensight.text.rgb(1,0,0)
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.text.select_begin({arg_string})"
        return self._session.cmd(cmd)

    def select_default(self) -> int:
        """Causes any following text commands to affect the default settings, rather than a particular text object.
        
        | All text commands following text: select_default will affect default settings until a new text object is selected using text: select_begin/select_end. 
        
        Examples:
            ::
        
                ensight.text.select_default()
                ensight.text.visible("OFF")
                ensight.text.rgb(1,0,0)
                ensight.text.select_begin(1)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.text.select_default()'''
        return self._session.cmd(cmd)

    def shadow_intensity(self, p0: float) -> int:
        """Text: shadow_intensity

        """
        cmd = f'''ensight.text.shadow_intensity({repr(p0)})'''
        return self._session.cmd(cmd)

    def shadow_offset(self, p0: int) -> int:
        """Text: shadow_offset

        """
        cmd = f'''ensight.text.shadow_offset({repr(p0)})'''
        return self._session.cmd(cmd)

    def size(self, p0: int) -> int:
        """Specifies the size of the selected text in the graphics window.
        
        | Text size is specified in arbitrary units, with 0 being the smallest possible text and 100 the largest.
        | The text scales with the size of the graphics window.     
        
        Args:
            p0:
                'size' must be within the range of 0 to 100
        
        Examples:
            ::
        
                ensight.text.select_begin(1)
                ensight.text.size(25)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.text.size({repr(p0)})'''
        return self._session.cmd(cmd)

    def string(self, p0: str) -> int:
        """Text: string

        """
        cmd = f'''ensight.text.string({repr(p0)})'''
        return self._session.cmd(cmd)

    def update(self) -> int:
        """Text: update

        """
        cmd = f'''ensight.text.update()'''
        return self._session.cmd(cmd)

    def visible(self, p0: str) -> int:
        """Controls the visibility of the selected text in the graphics window. 
        
        | Text is visible by default. 
        
        Args:
            p0:
                'toggle' ON
            p1:
                'toggle' OFF
        
        Examples:
            ::
        
                ensight.text.select_begin(1)
                ensight.text.visible("ON")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.text.visible({repr(p0)})'''
        return self._session.cmd(cmd)


class tensor:
    """Class wrapper for EnSight tensor module

    This class acts as a proxy for the EnSight Python module ensight.tensor
    """
    def __init__(self, session: Session):
        self._session = session

    def begin(self) -> int:
        """Delimit the modifications for tensor parts.
        
        | These commands are used to set the attributes for tensor glyph part creation.
        
        Args:
            p0:
                'tensor_command' any of the tensor attribute commands
        
        Examples:
            ::
        
                #
                # Activating a tensor variable
                #
                ensight.variables.activate("uniaxial_tensor")
                #
                # Selecting all parts as parents
                #
                ensight.part.select_all()
                #
                # Grouping a bunch of tensor attribute commands
                # 
                ensight.tensor.begin()
                ensight.tensor.variable("uniaxial_tensor")
                ensight.tensor.display_compression("ON")
                ensight.tensor.display_tension("ON")
                ensight.tensor.display_major("ON")
                ensight.tensor.display_minor("ON")
                ensight.tensor.display_middle("ON")
                ensight.tensor.tip_shape("triangle")
                ensight.tensor.tip_size(1.0000e-01)
                ensight.tensor.color_by("direction")
                ensight.tensor.compression_rgb(1.0000e+00,0.0000e+00,4.0000e-01)
                ensight.tensor.tension_rgb(0.0000e+00,8.0000e-01,1.0000e+00)
                ensight.tensor.line_width_by("direction")
                ensight.tensor.compression_line_width(2)
                ensight.tensor.tension_line_width(4)
                ensight.tensor.end()
                #
                # Creating the tensor glyph part
                #
                ensight.tensor.create()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.tensor.begin()'''
        return self._session.cmd(cmd)

    def color_by(self, p0: str) -> int:
        """Sets the method by which a tensor glyph part is colored.
        
        Args:
            p0:
                'method'
        
                * part
                * direction
        
        Examples:
            ::
        
                #
                # Activating a tensor variable
                #
                ensight.variables.activate("uniaxial_tensor")
                #
                # Selecting all parts as parents
                #
                ensight.part.select_all()
                #
                # Grouping a bunch of tensor attribute commands
                # 
                ensight.tensor.begin()
                ensight.tensor.variable("uniaxial_tensor")
                ensight.tensor.display_compression("ON")
                ensight.tensor.display_tension("ON")
                ensight.tensor.display_major("ON")
                ensight.tensor.display_minor("ON")
                ensight.tensor.display_middle("ON")
                ensight.tensor.tip_shape("triangle")
                ensight.tensor.tip_size(1.0000e-01)
                ensight.tensor.color_by("direction")
                ensight.tensor.compression_rgb(1.0000e+00,0.0000e+00,4.0000e-01)
                ensight.tensor.tension_rgb(0.0000e+00,8.0000e-01,1.0000e+00)
                ensight.tensor.line_width_by("direction")
                ensight.tensor.compression_line_width(2)
                ensight.tensor.tension_line_width(4)
                ensight.tensor.end()
                #
                # Creating the tensor glyph part
                #
                ensight.tensor.create()
                #
                # Now selecting the tensor glyph part
                #
                ensight.part.select_begin(5)
                #
                # And changing to color by part instead of direction
                #
                ensight.part.modify_begin()
                ensight.tensor.color_by("part")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.tensor.color_by({repr(p0)})'''
        return self._session.cmd(cmd)

    def compression_line_width(self, p0: int) -> int:
        """Sets the line width (in pixels) that will be used for the compression portion of a tensor glyph if the "tensor: line_width_by" command method is set to "direction".
        
        | If the "tensor: line_width_by" command method is set to "part", the tensor glyph part is line width is set in the same manner as any other part.
        
        Args:
            p0:
                'width' width in pixels for the compression portion of a tensor glyph (range is 1 to 4)
        
        Examples:
            ::
        
                #
                # Activating a tensor variable
                #
                ensight.variables.activate("uniaxial_tensor")
                #
                # Selecting all parts as parents
                #
                ensight.part.select_all()
                #
                # Grouping a bunch of tensor attribute commands
                # (included is the one to make compression
                #  lines 2 pixels wide)
                # 
                ensight.tensor.begin()
                ensight.tensor.variable("uniaxial_tensor")
                ensight.tensor.display_compression("ON")
                ensight.tensor.display_tension("ON")
                ensight.tensor.display_major("ON")
                ensight.tensor.display_minor("ON")
                ensight.tensor.display_middle("ON")
                ensight.tensor.tip_shape("triangle")
                ensight.tensor.tip_size(1.0000e-01)
                ensight.tensor.color_by("direction")
                ensight.tensor.compression_rgb(1.0000e+00,0.0000e+00,4.0000e-01)
                ensight.tensor.tension_rgb(0.0000e+00,8.0000e-01,1.0000e+00)
                ensight.tensor.line_width_by("direction")
                ensight.tensor.compression_line_width(2)
                ensight.tensor.tension_line_width(4)
                ensight.tensor.end()
                #
                # Creating the tensor glyph part
                #
                ensight.tensor.create()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.tensor.compression_line_width({repr(p0)})'''
        return self._session.cmd(cmd)

    def compression_rgb(self, p0: float, p1: float, p2: float) -> int:
        """Sets the color that will be used for the compression portion of a tensor glyph if the "tensor: color_by" command method is set to "direction".
        
        | If the "tensor: color_by" command method is set to "part", the tensor glyph part is colored like any other part.
        
        Args:
            p0:
                'red_val' red, green, blue color components for the compression line (0.0 to 1.0)
            p1:
                'grn_val' red, green, blue color components for the compression line (0.0 to 1.0)
            p2:
                'blu_val' red, green, blue color components for the compression line (0.0 to 1.0)
        
        Examples:
            ::
        
                #
                # Activating a tensor variable
                #
                ensight.variables.activate("uniaxial_tensor")
                #
                # Selecting all parts as parents
                #
                ensight.part.select_all()
                #
                # Grouping a bunch of tensor attribute commands
                # (included is the one to make compression
                #  lines a particular color)
                # 
                ensight.tensor.begin()
                ensight.tensor.variable("uniaxial_tensor")
                ensight.tensor.display_compression("ON")
                ensight.tensor.display_tension("ON")
                ensight.tensor.display_major("ON")
                ensight.tensor.display_minor("ON")
                ensight.tensor.display_middle("ON")
                ensight.tensor.tip_shape("triangle")
                ensight.tensor.tip_size(1.0000e-01)
                ensight.tensor.color_by("direction")
                ensight.tensor.compression_rgb(1.0000e+00,0.0000e+00,4.0000e-01)
                ensight.tensor.tension_rgb(0.0000e+00,8.0000e-01,1.0000e+00)
                ensight.tensor.line_width_by("direction")
                ensight.tensor.compression_line_width(2)
                ensight.tensor.tension_line_width(4)
                ensight.tensor.end()
                #
                # Creating the tensor glyph part
                #
                ensight.tensor.create()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.tensor.compression_rgb({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def create(self) -> int:
        """Causes a tensor glyph part to be created according to previously set attributes or defaults.
        
        | The selection of parent part(s) is required.
        
        Examples:
            ::
        
                #
                # Activating a tensor variable
                #
                ensight.variables.activate("uniaxial_tensor")
                #
                # Selecting all parts as parents
                #
                ensight.part.select_all()
                #
                # Grouping a bunch of tensor attribute commands
                # 
                ensight.tensor.begin()
                ensight.tensor.variable("uniaxial_tensor")
                ensight.tensor.display_compression("ON")
                ensight.tensor.display_tension("ON")
                ensight.tensor.display_major("ON")
                ensight.tensor.display_minor("ON")
                ensight.tensor.display_middle("ON")
                ensight.tensor.tip_shape("triangle")
                ensight.tensor.tip_size(1.0000e-01)
                ensight.tensor.color_by("direction")
                ensight.tensor.compression_rgb(1.0000e+00,0.0000e+00,4.0000e-01)
                ensight.tensor.tension_rgb(0.0000e+00,8.0000e-01,1.0000e+00)
                ensight.tensor.line_width_by("direction")
                ensight.tensor.compression_line_width(2)
                ensight.tensor.tension_line_width(4)
                ensight.tensor.end()
                #
                # Creating the tensor glyph part
                #
                ensight.tensor.create()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.tensor.create()'''
        return self._session.cmd(cmd)

    def display_compression(self, p0: str) -> int:
        """Specifies whether the compression portion of a tensor glyph will be displayed or not.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                #
                # Activating a tensor variable
                #
                ensight.variables.activate("uniaxial_tensor")
                #
                # Selecting all parts as parents
                #
                ensight.part.select_all()
                #
                # Grouping a bunch of tensor attribute commands
                # (One of which is to have the compression displayed)
                # 
                ensight.tensor.begin()
                ensight.tensor.variable("uniaxial_tensor")
                ensight.tensor.display_compression("ON")
                ensight.tensor.display_tension("ON")
                ensight.tensor.display_major("ON")
                ensight.tensor.display_minor("ON")
                ensight.tensor.display_middle("ON")
                ensight.tensor.tip_shape("triangle")
                ensight.tensor.tip_size(1.0000e-01)
                ensight.tensor.color_by("direction")
                ensight.tensor.compression_rgb(1.0000e+00,0.0000e+00,4.0000e-01)
                ensight.tensor.tension_rgb(0.0000e+00,8.0000e-01,1.0000e+00)
                ensight.tensor.line_width_by("direction")
                ensight.tensor.compression_line_width(2)
                ensight.tensor.tension_line_width(4)
                ensight.tensor.end()
                #
                # Creating the tensor glyph part
                #
                ensight.tensor.create()
                #
                # Selecting the newly created tensor glyph part
                #
                ensight.part.select_begin(5)
                #
                # And turning compression portion off - to
                # show how it can be done
                #
                ensight.part.modify_begin()
                ensight.tensor.display_compression("OFF")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.tensor.display_compression({repr(p0)})'''
        return self._session.cmd(cmd)

    def display_major(self, p0: str) -> int:
        """Specifies whether the major, middle, or minor eigenvectors of a tensor glyph will be displayed. 
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                #
                # Activating a tensor variable
                #
                ensight.variables.activate("uniaxial_tensor")
                #
                # Selecting all parts as parents
                #
                ensight.part.select_all()
                #
                # Grouping a bunch of tensor attribute commands
                # (Note that all eigenvectors are set to be displayed)
                # 
                ensight.tensor.begin()
                ensight.tensor.variable("uniaxial_tensor")
                ensight.tensor.display_compression("ON")
                ensight.tensor.display_tension("ON")
                ensight.tensor.display_major("ON")
                ensight.tensor.display_minor("ON")
                ensight.tensor.display_middle("ON")
                ensight.tensor.tip_shape("triangle")
                ensight.tensor.tip_size(1.0000e-01)
                ensight.tensor.color_by("direction")
                ensight.tensor.compression_rgb(1.0000e+00,0.0000e+00,4.0000e-01)
                ensight.tensor.tension_rgb(0.0000e+00,8.0000e-01,1.0000e+00)
                ensight.tensor.line_width_by("direction")
                ensight.tensor.compression_line_width(2)
                ensight.tensor.tension_line_width(4)
                ensight.tensor.end()
                #
                # Creating the tensor glyph part
                #
                ensight.tensor.create()
                #
                # Selecting the newly created tensor glyph part
                #
                ensight.part.select_begin(5)
                #
                # And turning off the middle eigenvector
                #
                ensight.part.modify_begin()
                ensight.tensor.display_middle("OFF")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.tensor.display_major({repr(p0)})'''
        return self._session.cmd(cmd)

    def display_middle(self, p0: str) -> int:
        """Specifies whether the major, middle, or minor eigenvectors of a tensor glyph will be displayed. 
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                #
                # Activating a tensor variable
                #
                ensight.variables.activate("uniaxial_tensor")
                #
                # Selecting all parts as parents
                #
                ensight.part.select_all()
                #
                # Grouping a bunch of tensor attribute commands
                # (Note that all eigenvectors are set to be displayed)
                # 
                ensight.tensor.begin()
                ensight.tensor.variable("uniaxial_tensor")
                ensight.tensor.display_compression("ON")
                ensight.tensor.display_tension("ON")
                ensight.tensor.display_major("ON")
                ensight.tensor.display_minor("ON")
                ensight.tensor.display_middle("ON")
                ensight.tensor.tip_shape("triangle")
                ensight.tensor.tip_size(1.0000e-01)
                ensight.tensor.color_by("direction")
                ensight.tensor.compression_rgb(1.0000e+00,0.0000e+00,4.0000e-01)
                ensight.tensor.tension_rgb(0.0000e+00,8.0000e-01,1.0000e+00)
                ensight.tensor.line_width_by("direction")
                ensight.tensor.compression_line_width(2)
                ensight.tensor.tension_line_width(4)
                ensight.tensor.end()
                #
                # Creating the tensor glyph part
                #
                ensight.tensor.create()
                #
                # Selecting the newly created tensor glyph part
                #
                ensight.part.select_begin(5)
                #
                # And turning off the middle eigenvector
                #
                ensight.part.modify_begin()
                ensight.tensor.display_middle("OFF")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.tensor.display_middle({repr(p0)})'''
        return self._session.cmd(cmd)

    def display_minor(self, p0: str) -> int:
        """Specifies whether the major, middle, or minor eigenvectors of a tensor glyph will be displayed. 
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                #
                # Activating a tensor variable
                #
                ensight.variables.activate("uniaxial_tensor")
                #
                # Selecting all parts as parents
                #
                ensight.part.select_all()
                #
                # Grouping a bunch of tensor attribute commands
                # (Note that all eigenvectors are set to be displayed)
                # 
                ensight.tensor.begin()
                ensight.tensor.variable("uniaxial_tensor")
                ensight.tensor.display_compression("ON")
                ensight.tensor.display_tension("ON")
                ensight.tensor.display_major("ON")
                ensight.tensor.display_minor("ON")
                ensight.tensor.display_middle("ON")
                ensight.tensor.tip_shape("triangle")
                ensight.tensor.tip_size(1.0000e-01)
                ensight.tensor.color_by("direction")
                ensight.tensor.compression_rgb(1.0000e+00,0.0000e+00,4.0000e-01)
                ensight.tensor.tension_rgb(0.0000e+00,8.0000e-01,1.0000e+00)
                ensight.tensor.line_width_by("direction")
                ensight.tensor.compression_line_width(2)
                ensight.tensor.tension_line_width(4)
                ensight.tensor.end()
                #
                # Creating the tensor glyph part
                #
                ensight.tensor.create()
                #
                # Selecting the newly created tensor glyph part
                #
                ensight.part.select_begin(5)
                #
                # And turning off the middle eigenvector
                #
                ensight.part.modify_begin()
                ensight.tensor.display_middle("OFF")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.tensor.display_minor({repr(p0)})'''
        return self._session.cmd(cmd)

    def display_tension(self, p0: str) -> int:
        """Specifies whether the tension portion of a tensor glyph will be displayed.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                #
                # Activating a tensor variable
                #
                ensight.variables.activate("uniaxial_tensor")
                #
                # Selecting all parts as parents
                #
                ensight.part.select_all()
                #
                # Grouping a bunch of tensor attribute commands
                # (One of which is to have the tension displayed)
                # 
                ensight.tensor.begin()
                ensight.tensor.variable("uniaxial_tensor")
                ensight.tensor.display_compression("ON")
                ensight.tensor.display_tension("ON")
                ensight.tensor.display_major("ON")
                ensight.tensor.display_minor("ON")
                ensight.tensor.display_middle("ON")
                ensight.tensor.tip_shape("triangle")
                ensight.tensor.tip_size(1.0000e-01)
                ensight.tensor.color_by("direction")
                ensight.tensor.compression_rgb(1.0000e+00,0.0000e+00,4.0000e-01)
                ensight.tensor.tension_rgb(0.0000e+00,8.0000e-01,1.0000e+00)
                ensight.tensor.line_width_by("direction")
                ensight.tensor.compression_line_width(2)
                ensight.tensor.tension_line_width(4)
                ensight.tensor.end()
                #
                # Creating the tensor glyph part
                #
                ensight.tensor.create()
                #
                # Selecting the newly created tensor glyph part
                #
                ensight.part.select_begin(5)
                #
                # And turning tension portion off - to
                # show how it can be done
                #
                ensight.part.modify_begin()
                ensight.tensor.display_tension("OFF")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.tensor.display_tension({repr(p0)})'''
        return self._session.cmd(cmd)

    def end(self) -> int:
        """Delimit the modifications for tensor parts.
        
        | These commands are used to set the attributes for tensor glyph part creation.
        
        Args:
            p0:
                'tensor_command' any of the tensor attribute commands
        
        Examples:
            ::
        
                #
                # Activating a tensor variable
                #
                ensight.variables.activate("uniaxial_tensor")
                #
                # Selecting all parts as parents
                #
                ensight.part.select_all()
                #
                # Grouping a bunch of tensor attribute commands
                # 
                ensight.tensor.begin()
                ensight.tensor.variable("uniaxial_tensor")
                ensight.tensor.display_compression("ON")
                ensight.tensor.display_tension("ON")
                ensight.tensor.display_major("ON")
                ensight.tensor.display_minor("ON")
                ensight.tensor.display_middle("ON")
                ensight.tensor.tip_shape("triangle")
                ensight.tensor.tip_size(1.0000e-01)
                ensight.tensor.color_by("direction")
                ensight.tensor.compression_rgb(1.0000e+00,0.0000e+00,4.0000e-01)
                ensight.tensor.tension_rgb(0.0000e+00,8.0000e-01,1.0000e+00)
                ensight.tensor.line_width_by("direction")
                ensight.tensor.compression_line_width(2)
                ensight.tensor.tension_line_width(4)
                ensight.tensor.end()
                #
                # Creating the tensor glyph part
                #
                ensight.tensor.create()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.tensor.end()'''
        return self._session.cmd(cmd)

    def line_width_by(self, p0: str) -> int:
        """Sets the method by which a tensor glyph part's line width is controlled.
        
        Args:
            p0:
                'method'
        
                * part
                * direction
        
        Examples:
            ::
        
                #
                # Activating a tensor variable
                #
                ensight.variables.activate("uniaxial_tensor")
                #
                # Selecting all parts as parents
                #
                ensight.part.select_all()
                #
                # Grouping a bunch of tensor attribute commands
                # (Note line width set by direction)
                # 
                ensight.tensor.begin()
                ensight.tensor.variable("uniaxial_tensor")
                ensight.tensor.display_compression("ON")
                ensight.tensor.display_tension("ON")
                ensight.tensor.display_major("ON")
                ensight.tensor.display_minor("ON")
                ensight.tensor.display_middle("ON")
                ensight.tensor.tip_shape("triangle")
                ensight.tensor.tip_size(1.0000e-01)
                ensight.tensor.color_by("direction")
                ensight.tensor.compression_rgb(1.0000e+00,0.0000e+00,4.0000e-01)
                ensight.tensor.tension_rgb(0.0000e+00,8.0000e-01,1.0000e+00)
                ensight.tensor.line_width_by("direction")
                ensight.tensor.compression_line_width(2)
                ensight.tensor.tension_line_width(4)
                ensight.tensor.end()
                #
                # Creating the tensor glyph part
                #
                ensight.tensor.create()
                #
                # Now selecting the tensor glyph part
                #
                ensight.part.select_begin(5)
                #
                # And changing to line width to be by part instead of direction
                #
                ensight.part.modify_begin()
                ensight.tensor.line_width_by("part")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.tensor.line_width_by({repr(p0)})'''
        return self._session.cmd(cmd)

    def scale_factor(self, p0: float) -> int:
        """Sets the scale factor to be applied to the tensor glyph.
        
        | The factor is applied to major, middle, and minor eigenvectors.
        
        Args:
            p0:
                'value' the scale factor that to apply to the tensor glyph
        
        Examples:
            ::
        
                #
                # Activating a tensor variable
                #
                ensight.variables.activate("uniaxial_tensor")
                #
                # Selecting all parts as parents
                #
                ensight.part.select_all()
                #
                # Grouping a bunch of tensor attribute commands
                # (One of which is the scale factor)
                # 
                ensight.tensor.begin()
                ensight.tensor.variable("uniaxial_tensor")
                ensight.tensor.scale_factor(1.6700e+00)
                ensight.tensor.display_compression("ON")
                ensight.tensor.display_tension("ON")
                ensight.tensor.display_major("ON")
                ensight.tensor.display_minor("ON")
                ensight.tensor.display_middle("ON")
                ensight.tensor.tip_shape("triangle")
                ensight.tensor.tip_size(1.0000e-01)
                ensight.tensor.color_by("direction")
                ensight.tensor.compression_rgb(1.0000e+00,0.0000e+00,4.0000e-01)
                ensight.tensor.tension_rgb(0.0000e+00,8.0000e-01,1.0000e+00)
                ensight.tensor.line_width_by("direction")
                ensight.tensor.compression_line_width(2)
                ensight.tensor.tension_line_width(4)
                ensight.tensor.end()
                #
                # Creating the tensor glyph part
                #
                ensight.tensor.create()
                #
                # Now selecting the tensor glyph part
                #
                ensight.part.select_begin(5)
                #
                # And changing the scale factor back to 1
                #
                ensight.part.modify_begin()
                ensight.tensor.scale_factor(1.0000e+00)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.tensor.scale_factor({repr(p0)})'''
        return self._session.cmd(cmd)

    def select_default(self) -> int:
        """Sets default as the current tensor glyph selection, so subsequent attribute modifications will affect the default.
        
        | When certain attributes will be common to future tensor glyph parts, it is useful to set these once as the default.
        
        Examples:
            ::
        
                #
                # Setting to default
                #
                ensight.tensor.select_default()
                #
                # Setting a few things as defaults
                #
                ensight.part.modify_begin()
                ensight.tensor.scale_factor(1.5000e+00)
                ensight.tensor.display_middle("OFF")
                ensight.tensor.color_by("direction")
                ensight.tensor.compression_rgb(1.0000e+00,0.0000e+00,0.0000e+00)
                ensight.tensor.tension_rgb(0.0000e+00,0.0000e+00,1.0000e+00)
                ensight.tensor.line_width_by("part")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.tensor.select_default()'''
        return self._session.cmd(cmd)

    def tension_line_width(self, p0: int) -> int:
        """Sets the line width (in pixels) that will be used for the tension portion of a tensor glyph if the "tensor: line_width_by" command method is set to "direction".
        
        | If the "tensor: line_width_by" command method is set to "part", the tensor glyph part is line width is set in the same manner as any other part.
        
        Args:
            p0:
                'width' width in pixels for the tension portion of a tensor glyph (range is 1 to 4)
        
        Examples:
            ::
        
                #
                # Activating a tensor variable
                #
                ensight.variables.activate("uniaxial_tensor")
                #
                # Selecting all parts as parents
                #
                ensight.part.select_all()
                #
                # Grouping a bunch of tensor attribute commands
                # (included is the one to make tension
                #  lines 4 pixels wide)
                # 
                ensight.tensor.begin()
                ensight.tensor.variable("uniaxial_tensor")
                ensight.tensor.display_compression("ON")
                ensight.tensor.display_tension("ON")
                ensight.tensor.display_major("ON")
                ensight.tensor.display_minor("ON")
                ensight.tensor.display_middle("ON")
                ensight.tensor.tip_shape("triangle")
                ensight.tensor.tip_size(1.0000e-01)
                ensight.tensor.color_by("direction")
                ensight.tensor.compression_rgb(1.0000e+00,0.0000e+00,4.0000e-01)
                ensight.tensor.tension_rgb(0.0000e+00,8.0000e-01,1.0000e+00)
                ensight.tensor.line_width_by("direction")
                ensight.tensor.compression_line_width(2)
                ensight.tensor.tension_line_width(4)
                ensight.tensor.end()
                #
                # Creating the tensor glyph part
                #
                ensight.tensor.create()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.tensor.tension_line_width({repr(p0)})'''
        return self._session.cmd(cmd)

    def tension_rgb(self, p0: float, p1: float, p2: float) -> int:
        """Sets the color that will be used for the tension portion of a tensor glyph if the "tensor: color_by" command method is set to "direction".
        
        | If the "tensor: color_by" command method is set to "part", the tensor glyph part is colored like any other part.
        
        Args:
            p0:
                'red_val' red, green, blue color components for the tension line (0.0 to 1.0)
            p1:
                'grn_val' red, green, blue color components for the tension line (0.0 to 1.0)
            p2:
                'blu_val' red, green, blue color components for the tension line (0.0 to 1.0)
        
        Examples:
            ::
        
                #
                # Activating a tensor variable
                #
                ensight.variables.activate("uniaxial_tensor")
                #
                # Selecting all parts as parents
                #
                ensight.part.select_all()
                #
                # Grouping a bunch of tensor attribute commands
                # (included is the one to make tension
                #  lines a particular color)
                # 
                ensight.tensor.begin()
                ensight.tensor.variable("uniaxial_tensor")
                ensight.tensor.display_compression("ON")
                ensight.tensor.display_tension("ON")
                ensight.tensor.display_major("ON")
                ensight.tensor.display_minor("ON")
                ensight.tensor.display_middle("ON")
                ensight.tensor.tip_shape("triangle")
                ensight.tensor.tip_size(1.0000e-01)
                ensight.tensor.color_by("direction")
                ensight.tensor.compression_rgb(1.0000e+00,0.0000e+00,4.0000e-01)
                ensight.tensor.tension_rgb(0.0000e+00,8.0000e-01,1.0000e+00)
                ensight.tensor.line_width_by("direction")
                ensight.tensor.compression_line_width(2)
                ensight.tensor.tension_line_width(4)
                ensight.tensor.end()
                #
                # Creating the tensor glyph part
                #
                ensight.tensor.create()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.tensor.tension_rgb({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def tip_shape(self, p0: str) -> int:
        """Sets the shape of the tips on the tensor glyphs
        
        | The direction of the arrowheads will be towards each for compression and away from each other for tension.
        
        Args:
            p0:
                'shape'
        
                * none
                * normal
                * triangle
        
        Examples:
            ::
        
                #
                # Activating a tensor variable
                #
                ensight.variables.activate("uniaxial_tensor")
                #
                # Selecting all parts as parents
                #
                ensight.part.select_all()
                #
                # Grouping a bunch of tensor attribute commands
                # (included is the one to make triangle arrowhead tips)
                # 
                ensight.tensor.begin()
                ensight.tensor.variable("uniaxial_tensor")
                ensight.tensor.display_compression("ON")
                ensight.tensor.display_tension("ON")
                ensight.tensor.display_major("ON")
                ensight.tensor.display_minor("ON")
                ensight.tensor.display_middle("ON")
                ensight.tensor.tip_shape("triangle")
                ensight.tensor.tip_size(1.0000e-01)
                ensight.tensor.color_by("direction")
                ensight.tensor.compression_rgb(1.0000e+00,0.0000e+00,4.0000e-01)
                ensight.tensor.tension_rgb(0.0000e+00,8.0000e-01,1.0000e+00)
                ensight.tensor.line_width_by("direction")
                ensight.tensor.compression_line_width(2)
                ensight.tensor.tension_line_width(4)
                ensight.tensor.end()
                #
                # Creating the tensor glyph part
                #
                ensight.tensor.create()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.tensor.tip_shape({repr(p0)})'''
        return self._session.cmd(cmd)

    def tip_size(self, p0: float) -> int:
        """Sets the size of the tips on the tensor glyphs
        
        Args:
            p0:
                'size' a relative size factor for tensor glyph tips
        
        Examples:
            ::
        
                #
                # Activating a tensor variable
                #
                ensight.variables.activate("uniaxial_tensor")
                #
                # Selecting all parts as parents
                #
                ensight.part.select_all()
                #
                # Grouping a bunch of tensor attribute commands
                # (included is the one to set tip size)
                # 
                ensight.tensor.begin()
                ensight.tensor.variable("uniaxial_tensor")
                ensight.tensor.display_compression("ON")
                ensight.tensor.display_tension("ON")
                ensight.tensor.display_major("ON")
                ensight.tensor.display_minor("ON")
                ensight.tensor.display_middle("ON")
                ensight.tensor.tip_shape("triangle")
                ensight.tensor.tip_size(1.0000e-01)
                ensight.tensor.color_by("direction")
                ensight.tensor.compression_rgb(1.0000e+00,0.0000e+00,4.0000e-01)
                ensight.tensor.tension_rgb(0.0000e+00,8.0000e-01,1.0000e+00)
                ensight.tensor.line_width_by("direction")
                ensight.tensor.compression_line_width(2)
                ensight.tensor.tension_line_width(4)
                ensight.tensor.end()
                #
                # Creating the tensor glyph part
                #
                ensight.tensor.create()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.tensor.tip_size({repr(p0)})'''
        return self._session.cmd(cmd)

    def tip_size_rep(self, p0: str) -> int:
        """Tensor: tip_size_rep

        """
        cmd = f'''ensight.tensor.tip_size_rep({repr(p0)})'''
        return self._session.cmd(cmd)

    def variable(self, p0: Any) -> int:
        """Specifies the name of the tensor variable that the tensor glyphs will represent.
        
        Args:
            p0:
                'name' name of the tensor variable
        
        Examples:
            ::
        
                #
                # Activating a tensor variable
                #
                ensight.variables.activate("uniaxial_tensor")
                #
                # Selecting all parts as parents
                #
                ensight.part.select_all()
                #
                # Grouping a bunch of tensor attribute commands
                # (included the one that specifies the name)
                # 
                ensight.tensor.begin()
                ensight.tensor.variable("uniaxial_tensor")
                ensight.tensor.display_compression("ON")
                ensight.tensor.display_tension("ON")
                ensight.tensor.display_major("ON")
                ensight.tensor.display_minor("ON")
                ensight.tensor.display_middle("ON")
                ensight.tensor.tip_shape("triangle")
                ensight.tensor.tip_size(1.0000e-01)
                ensight.tensor.color_by("direction")
                ensight.tensor.compression_rgb(1.0000e+00,0.0000e+00,4.0000e-01)
                ensight.tensor.tension_rgb(0.0000e+00,8.0000e-01,1.0000e+00)
                ensight.tensor.line_width_by("direction")
                ensight.tensor.compression_line_width(2)
                ensight.tensor.tension_line_width(4)
                ensight.tensor.end()
                #
                # Creating the tensor glyph part
                #
                ensight.tensor.create()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.tensor.variable({repr(p0)})'''
        return self._session.cmd(cmd)


class subset:
    """Class wrapper for EnSight subset module

    This class acts as a proxy for the EnSight Python module ensight.subset
    """
    def __init__(self, session: Session):
        self._session = session

    def begin(self) -> int:
        """Delimit the modifications for subset part attributes.
        
        | These commands are used to set the attributes for a subset part creation.
        
        Args:
            p0:
                'subset_commands' any of the subset attribute commands
        
        Examples:
            ::
        
                ensight.subset.begin()
                ensight.subset.begin_subsetdesc()
                #WARNING: the following line failed to translate because the function could not be found in the ensight python module
                #   Actual error: module 'ensight' has no attribute 'part_num'
                ensight.sendmesg(r"part_num 1 ")
                #WARNING: the following line failed to translate because the function could not be found in the ensight python module
                #   Actual error: module 'ensight' has no attribute 'nodes'
                ensight.sendmesg(r"nodes ")
                #WARNING: the following line failed to translate because the function could not be found in the ensight python module
                #   Actual error: module 'ensight' has no attribute '_1-10'
                ensight.sendmesg(r"1-10 ")
                #WARNING: the following line failed to translate because the function could not be found in the ensight python module
                #   Actual error: module 'ensight' has no attribute 'elements'
                ensight.sendmesg(r"elements ")
                #WARNING: the following line failed to translate because the function could not be found in the ensight python module
                #   Actual error: module 'ensight' has no attribute '_20-30'
                ensight.sendmesg(r"20-30 ")
                ensight.subset.end_subsetdesc()
                ensight.subset.end()
                ensight.subset.create()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.subset.begin()'''
        return self._session.cmd(cmd)

    def begin_subsetdesc(self) -> int:
        """Encloses the information for parent part number, nodes, and elements for a subset part.
        
        Args:
            p0:
                'num' Parent part number of the subset part. Place it on the line with the keyword "part_num", as shown in the example.
            p1:
                'nodes_string' List of nodes to include in the subset part. Place the keyword "nodes" on a line, then place this string on subsequent lines. Note that the list is a comma separated list of node ids which can also include dash separated ranges of nodes.
            p2:
                'elements_string' List of elements to include in the subset part. Place the keyword "elements" on a line, then place this string on subsequent lines. Note that the list is a comma separated list of element ids which can also include dash separated ranges of elements.
        
        Examples:
            ::
        
                ensight.subset.begin()
                ensight.subset.begin_subsetdesc()
                #WARNING: the following line failed to translate because the function could not be found in the ensight python module
                #   Actual error: module 'ensight' has no attribute 'part_num'
                ensight.sendmesg(r"part_num 1 ")
                #WARNING: the following line failed to translate because the function could not be found in the ensight python module
                #   Actual error: module 'ensight' has no attribute 'nodes'
                ensight.sendmesg(r"nodes ")
                #WARNING: the following line failed to translate because the function could not be found in the ensight python module
                #   Actual error: module 'ensight' has no attribute '_13,1-10,103,104,200-3000'
                ensight.sendmesg(r"13,1-10,103,104,200-3000 ")
                #WARNING: the following line failed to translate because the function could not be found in the ensight python module
                #   Actual error: module 'ensight' has no attribute 'elements'
                ensight.sendmesg(r"elements ")
                #WARNING: the following line failed to translate because the function could not be found in the ensight python module
                #   Actual error: module 'ensight' has no attribute '_20-30,100-200,355'
                ensight.sendmesg(r"20-30,100-200,355 ")
                ensight.subset.end_subsetdesc()
                ensight.subset.end()
                ensight.subset.create()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.subset.begin_subsetdesc()'''
        return self._session.cmd(cmd)

    def create(self) -> int:
        """Creates a subset part according to previously defined attributes or defaults.
        
        Examples:
            ::
        
                ensight.subset.begin()
                ensight.subset.begin_subsetdesc()
                #WARNING: the following line failed to translate because the function could not be found in the ensight python module
                #   Actual error: module 'ensight' has no attribute 'part_num'
                ensight.sendmesg(r"part_num 1 ")
                #WARNING: the following line failed to translate because the function could not be found in the ensight python module
                #   Actual error: module 'ensight' has no attribute 'nodes'
                ensight.sendmesg(r"nodes ")
                #WARNING: the following line failed to translate because the function could not be found in the ensight python module
                #   Actual error: module 'ensight' has no attribute '_13,1-10,103,104,200-3000'
                ensight.sendmesg(r"13,1-10,103,104,200-3000 ")
                #WARNING: the following line failed to translate because the function could not be found in the ensight python module
                #   Actual error: module 'ensight' has no attribute 'elements'
                ensight.sendmesg(r"elements ")
                #WARNING: the following line failed to translate because the function could not be found in the ensight python module
                #   Actual error: module 'ensight' has no attribute '_20-30,100-200,355'
                ensight.sendmesg(r"20-30,100-200,355 ")
                ensight.subset.end_subsetdesc()
                ensight.subset.end()
                ensight.subset.create()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.subset.create()'''
        return self._session.cmd(cmd)

    def create_desc(self, args: Any) -> int:
        """Subset: create_desc

        """
        cmd = f'''ensight.subset.create_desc({repr(args)})'''
        return self._session.cmd(cmd)

    def dummy_chng_slot(self, args: Any) -> int:
        """Subset: dummy_chng_slot

        """
        cmd = f'''ensight.subset.dummy_chng_slot({repr(args)})'''
        return self._session.cmd(cmd)

    def end(self) -> int:
        """Delimit the modifications for subset part attributes.
        
        | These commands are used to set the attributes for a subset part creation.
        
        Args:
            p0:
                'subset_commands' any of the subset attribute commands
        
        Examples:
            ::
        
                ensight.subset.begin()
                ensight.subset.begin_subsetdesc()
                #WARNING: the following line failed to translate because the function could not be found in the ensight python module
                #   Actual error: module 'ensight' has no attribute 'part_num'
                ensight.sendmesg(r"part_num 1 ")
                #WARNING: the following line failed to translate because the function could not be found in the ensight python module
                #   Actual error: module 'ensight' has no attribute 'nodes'
                ensight.sendmesg(r"nodes ")
                #WARNING: the following line failed to translate because the function could not be found in the ensight python module
                #   Actual error: module 'ensight' has no attribute '_1-10'
                ensight.sendmesg(r"1-10 ")
                #WARNING: the following line failed to translate because the function could not be found in the ensight python module
                #   Actual error: module 'ensight' has no attribute 'elements'
                ensight.sendmesg(r"elements ")
                #WARNING: the following line failed to translate because the function could not be found in the ensight python module
                #   Actual error: module 'ensight' has no attribute '_20-30'
                ensight.sendmesg(r"20-30 ")
                ensight.subset.end_subsetdesc()
                ensight.subset.end()
                ensight.subset.create()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.subset.end()'''
        return self._session.cmd(cmd)

    def end_subsetdesc(self) -> int:
        """Encloses the information for parent part number, nodes, and elements for a subset part.
        
        Args:
            p0:
                'num' Parent part number of the subset part. Place it on the line with the keyword "part_num", as shown in the example.
            p1:
                'nodes_string' List of nodes to include in the subset part. Place the keyword "nodes" on a line, then place this string on subsequent lines. Note that the list is a comma separated list of node ids which can also include dash separated ranges of nodes.
            p2:
                'elements_string' List of elements to include in the subset part. Place the keyword "elements" on a line, then place this string on subsequent lines. Note that the list is a comma separated list of element ids which can also include dash separated ranges of elements.
        
        Examples:
            ::
        
                ensight.subset.begin()
                ensight.subset.begin_subsetdesc()
                #WARNING: the following line failed to translate because the function could not be found in the ensight python module
                #   Actual error: module 'ensight' has no attribute 'part_num'
                ensight.sendmesg(r"part_num 1 ")
                #WARNING: the following line failed to translate because the function could not be found in the ensight python module
                #   Actual error: module 'ensight' has no attribute 'nodes'
                ensight.sendmesg(r"nodes ")
                #WARNING: the following line failed to translate because the function could not be found in the ensight python module
                #   Actual error: module 'ensight' has no attribute '_13,1-10,103,104,200-3000'
                ensight.sendmesg(r"13,1-10,103,104,200-3000 ")
                #WARNING: the following line failed to translate because the function could not be found in the ensight python module
                #   Actual error: module 'ensight' has no attribute 'elements'
                ensight.sendmesg(r"elements ")
                #WARNING: the following line failed to translate because the function could not be found in the ensight python module
                #   Actual error: module 'ensight' has no attribute '_20-30,100-200,355'
                ensight.sendmesg(r"20-30,100-200,355 ")
                ensight.subset.end_subsetdesc()
                ensight.subset.end()
                ensight.subset.create()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.subset.end_subsetdesc()'''
        return self._session.cmd(cmd)

    def select_default(self) -> int:
        """Sets to default subset part, so subsequent attribute changes will apply to the defaults. 
        
        Examples:
            ::
        
                ensight.subset.select_default()
                ensight.part.modify_begin()
                ensight.part.colorby_rgb(6.0000e-01,0.0000e+00,1.0000e+00)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.subset.select_default()'''
        return self._session.cmd(cmd)


class species:
    """Class wrapper for EnSight species module

    This class acts as a proxy for the EnSight Python module ensight.species
    """
    def __init__(self, session: Session):
        self._session = session

    def select_all(self) -> int:
        """Species: select_all

        """
        cmd = f'''ensight.species.select_all()'''
        return self._session.cmd(cmd)

    def select_byname_begin(self, *args, **kwargs) -> Any:
        """Species: select_byname_begin

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.species.select_byname_begin({arg_string})"
        return self._session.cmd(cmd)

    def select_byname_end(self) -> int:
        """Species: select_byname_end

        """
        cmd = f'''ensight.species.select_byname_end()'''
        return self._session.cmd(cmd)


class solution_time:
    """Class wrapper for EnSight solution_time module

    This class acts as a proxy for the EnSight Python module ensight.solution_time
    """
    def __init__(self, session: Session):
        self._session = session

    def begin_simtime(self, p0: float) -> int:
        """Sets the solution time to be used as the beginning/ending time for subsequent time use. 
        
        | This is used when the "solution_time: show_as" command is set to "time".  Also, it will be truncated to a solution time directly associated with a time step if "solution_time: update_type" is set to "discrete". 
        | Can be greater/lesser or equal to the smallest/largest time available.
        
        Args:
            p0:
                'time' solution time to use as the beginning/ending time
        
        Examples:
            ::
        
                #
                # This sets several of the attributes using simulation time
                #
                ensight.solution_time.show_as("time")
                ensight.solution_time.update_type("continuous")
                ensight.solution_time.begin_simtime(0.0000e+00)
                ensight.solution_time.end_simtime(1.6000e+01)
                ensight.solution_time.current_simtime(9.0000e+00)
                ensight.solution_time.update_to_current()
                ensight.solution_time.number_of_cycles(1)
                ensight.solution_time.increment(2.0000e+00)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.solution_time.begin_simtime({repr(p0)})'''
        return self._session.cmd(cmd)

    def begin_step(self, p0: int) -> int:
        """Sets the time step to be used as the beginning/ending time step for subsequent time use. 
        
        | This is used when the "solution_time: show_as" command is set to "step".
        | Can be greater/lesser or equal to the smallest/largest time step available.
        
        Args:
            p0:
                'step' time step to use as the beginning/ending time step
        
        Examples:
            ::
        
                #
                # This sets several of the attributes using time steps
                #
                ensight.solution_time.show_as("step")
                ensight.solution_time.update_type("discrete")
                ensight.solution_time.begin_step(0)
                ensight.solution_time.end_step(16)
                ensight.solution_time.current_step(0)
                ensight.solution_time.update_to_current()
                ensight.solution_time.number_of_cycles(1)
                ensight.solution_time.increment(1.0000e+00)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.solution_time.begin_step({repr(p0)})'''
        return self._session.cmd(cmd)

    def convergence_value(self, p0: float) -> int:
        """Solution_time: convergence_value

        """
        cmd = f'''ensight.solution_time.convergence_value({repr(p0)})'''
        return self._session.cmd(cmd)

    def current_simtime(self, p0: float) -> int:
        """Sets the current simulation time.  Must be between the beginning time and the ending time.
        
        | This is used when the "solution_time: show_as" command is set to "time".
        
        Args:
            p0:
                'time' The simulation time to use as the current time. If "solution_time: update_type" is "continuous", this can be set to be any time between the beginning and ending times, even if it lies between data points (interpolation will take place).  If the "solution_time: update_type" is "discrete", this should be the time associated with a time step.
        
        Examples:
            ::
        
                #
                # This sets several of the attributes using simulation time
                #
                ensight.solution_time.show_as("time")
                ensight.solution_time.update_type("continuous")
                ensight.solution_time.begin_simtime(0.0000e+00)
                ensight.solution_time.end_simtime(1.6000e+01)
                ensight.solution_time.current_simtime(9.0000e+00)
                ensight.solution_time.update_to_current()
                ensight.solution_time.number_of_cycles(1)
                ensight.solution_time.increment(2.0000e+00)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.solution_time.current_simtime({repr(p0)})'''
        return self._session.cmd(cmd)

    def current_step(self, p0: float) -> int:
        """Sets the current time step.  Must be between the beginning time step and the ending time step.
        
        Args:
            p0:
                'step' The time step to use as the current time step. If "solution_time: update_type" is "continuous", this can be float and thus can be set to be fractionally between time steps (interpolation will take place).  If the "solution_time: update_type" is "discrete", this should be an integer.
        
        Examples:
            ::
        
                #
                # This sets several of the attributes using time steps,
                # but the current is set 40% between steps 2 and 3.
                #
                ensight.solution_time.show_as("step")
                ensight.solution_time.update_type("continuous")
                ensight.solution_time.begin_step(0)
                ensight.solution_time.end_step(16)
                ensight.solution_time.current_step(2.4)
                ensight.solution_time.update_to_current()
                ensight.solution_time.number_of_cycles(1)
                ensight.solution_time.increment(1.0000e+00)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.solution_time.current_step({repr(p0)})'''
        return self._session.cmd(cmd)

    def custom_timeline_begin(self, p0: str) -> int:
        """Solution_time: custom_timeline_begin

        """
        cmd = f'''ensight.solution_time.custom_timeline_begin({repr(p0)})'''
        return self._session.cmd(cmd)

    def custom_timeline_end(self, p0: str) -> int:
        """Solution_time: custom_timeline_end

        """
        cmd = f'''ensight.solution_time.custom_timeline_end({repr(p0)})'''
        return self._session.cmd(cmd)

    def custom_timeline_readapply(self, p0: str) -> int:
        """Solution_time: custom_timeline_readapply

        """
        cmd = f'''ensight.solution_time.custom_timeline_readapply({repr(p0)})'''
        return self._session.cmd(cmd)

    def end_simtime(self, p0: float) -> int:
        """Sets the solution time to be used as the beginning/ending time for subsequent time use. 
        
        | This is used when the "solution_time: show_as" command is set to "time".  Also, it will be truncated to a solution time directly associated with a time step if "solution_time: update_type" is set to "discrete". 
        | Can be greater/lesser or equal to the smallest/largest time available.
        
        Args:
            p0:
                'time' solution time to use as the beginning/ending time
        
        Examples:
            ::
        
                #
                # This sets several of the attributes using simulation time
                #
                ensight.solution_time.show_as("time")
                ensight.solution_time.update_type("continuous")
                ensight.solution_time.begin_simtime(0.0000e+00)
                ensight.solution_time.end_simtime(1.6000e+01)
                ensight.solution_time.current_simtime(9.0000e+00)
                ensight.solution_time.update_to_current()
                ensight.solution_time.number_of_cycles(1)
                ensight.solution_time.increment(2.0000e+00)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.solution_time.end_simtime({repr(p0)})'''
        return self._session.cmd(cmd)

    def end_step(self, p0: int) -> int:
        """Sets the time step to be used as the beginning/ending time step for subsequent time use. 
        
        | This is used when the "solution_time: show_as" command is set to "step".
        | Can be greater/lesser or equal to the smallest/largest time step available.
        
        Args:
            p0:
                'step' time step to use as the beginning/ending time step
        
        Examples:
            ::
        
                #
                # This sets several of the attributes using time steps
                #
                ensight.solution_time.show_as("step")
                ensight.solution_time.update_type("discrete")
                ensight.solution_time.begin_step(0)
                ensight.solution_time.end_step(16)
                ensight.solution_time.current_step(0)
                ensight.solution_time.update_to_current()
                ensight.solution_time.number_of_cycles(1)
                ensight.solution_time.increment(1.0000e+00)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.solution_time.end_step({repr(p0)})'''
        return self._session.cmd(cmd)

    def increment(self, p0: float) -> int:
        """Sets the number of steps that are moved when the solution time dialog time stepper buttons are clicked.
        
        | This is a user interface attribute.
        
        Args:
            p0:
                'step_by' number of time steps to advance by or decrease by with one click of the solution time stepper buttons
        
        Examples:
            ::
        
                #
                # This sets several of the attributes using simulation time
                # (but at the end it sets the stepper button increment)
                #
                ensight.solution_time.show_as("time")
                ensight.solution_time.update_type("continuous")
                ensight.solution_time.begin_simtime(0.0000e+00)
                ensight.solution_time.end_simtime(1.6000e+01)
                ensight.solution_time.current_simtime(9.0000e+00)
                ensight.solution_time.update_to_current()
                ensight.solution_time.number_of_cycles(1)
                ensight.solution_time.increment(2.0000e+00)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.solution_time.increment({repr(p0)})'''
        return self._session.cmd(cmd)

    def master_timeline(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.solution_time.master_timeline({repr(p0)})'''
        return self._session.cmd(cmd)

    def monitor_for_new_steps(self, p0: str) -> int:
        """Solution_time: monitor_for_new_steps

        """
        cmd = f'''ensight.solution_time.monitor_for_new_steps({repr(p0)})'''
        return self._session.cmd(cmd)

    def number_of_cycles(self, p0: int) -> int:
        """Solution_time: #_of_cycles

        """
        cmd = f'''ensight.solution_time.number_of_cycles({repr(p0)})'''
        return self._session.cmd(cmd)

    def play_backward(self) -> int:
        """Causes the model to be displayed backward/forward through time. 
        
        | Is only in effect when the application is idle.
        
        Examples:
            ::
        
                ensight.solution_time.play_backward()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.solution_time.play_backward()'''
        return self._session.cmd(cmd)

    def play_forward(self) -> int:
        """Causes the model to be displayed backward/forward through time. 
        
        | Is only in effect when the application is idle.
        
        Examples:
            ::
        
                ensight.solution_time.play_backward()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.solution_time.play_forward()'''
        return self._session.cmd(cmd)

    def play_style(self) -> int:
        """Solution_time: play_style

        """
        cmd = f'''ensight.solution_time.play_style()'''
        return self._session.cmd(cmd)

    def select_all_timesteps(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.solution_time.select_all_timesteps()'''
        return self._session.cmd(cmd)

    def set_beg_to_min(self) -> int:
        """Solution_time: set_beg_to_min

        """
        cmd = f'''ensight.solution_time.set_beg_to_min()'''
        return self._session.cmd(cmd)

    def set_end_to_max(self) -> int:
        """Solution_time: set_end_to_max

        """
        cmd = f'''ensight.solution_time.set_end_to_max()'''
        return self._session.cmd(cmd)

    def show_as(self, p0: str) -> int:
        """Sets method to use for specifying time - either as solution time directly or as time steps of data. 
        
        Args:
            p0:
                'method'
        
                * step
                * time
        
        Examples:
            ::
        
                #
                # This sets several of the attributes using simulation time
                #
                ensight.solution_time.show_as("time")
                ensight.solution_time.update_type("continuous")
                ensight.solution_time.begin_simtime(0.0000e+00)
                ensight.solution_time.end_simtime(1.6000e+01)
                ensight.solution_time.current_simtime(9.0000e+00)
                ensight.solution_time.update_to_current()
                ensight.solution_time.number_of_cycles(1)
                ensight.solution_time.increment(2.0000e+00)
                #
                # But here we change it to use time steps
                #
                ensight.solution_time.show_as("step")
                ensight.solution_time.update_type("discrete")
                ensight.solution_time.begin_step(0)
                ensight.solution_time.end_step(16)
                ensight.solution_time.current_step(5)
                ensight.solution_time.update_to_current()
                ensight.solution_time.number_of_cycles(1)
                ensight.solution_time.increment(1.0000e+00)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.solution_time.show_as({repr(p0)})'''
        return self._session.cmd(cmd)

    def step_backward(self) -> int:
        """Causes the model to be displayed at previous/next time. 
        
        | This command is not generated by the EnSight GUI, but is intended for use with batch or context operations where the time of the first step could vary from model to model.
        
        Examples:
            ::
        
                ensight.solution_time.step_backward()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.solution_time.step_backward()'''
        return self._session.cmd(cmd)

    def step_forward(self) -> int:
        """Causes the model to be displayed at previous/next time. 
        
        | This command is not generated by the EnSight GUI, but is intended for use with batch or context operations where the time of the first step could vary from model to model.
        
        Examples:
            ::
        
                ensight.solution_time.step_backward()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.solution_time.step_forward()'''
        return self._session.cmd(cmd)

    def stop(self) -> int:
        """Stops the model from being displayed through time. 
        
        Examples:
            ::
        
                ensight.solution_time.stop()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.solution_time.stop()'''
        return self._session.cmd(cmd)

    def time_annotation(self, p0: str) -> int:
        """Sets whether time annotation will automatically be displayed on the screen during animation.
        
        | None.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.solution_time.time_annotation("ON")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.solution_time.time_annotation({repr(p0)})'''
        return self._session.cmd(cmd)

    def timeset_between(self, p0: str) -> int:
        """When the current time lies between the steps of a given timeset, this command sets how to handle the situation in the span. 
        
        Args:
            p0:
                'method'
        
                * undefined
                * interpolate
                * nearest
                * left
                * right
        
        Examples:
            ::
        
                #
                # Selecting the timeset
                #
                ensight.solution_time.timeset_select(2)
                #
                # Setting the timeset span handling methods
                # (Note that we will interpolate if between)
                #
                ensight.solution_time.timeset_leftof("undefined")
                ensight.solution_time.timeset_between("interpolate")
                ensight.solution_time.timeset_rightof("nearest")
                #
                # Update timesets and model display
                #
                ensight.solution_time.timeset_update()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.solution_time.timeset_between({repr(p0)})'''
        return self._session.cmd(cmd)

    def timeset_leftof(self, p0: str) -> int:
        """When the current time lies before the beginning step of a given timeset, this command sets how to handle the situation. 
        
        | The geometry and each variable can be specified according to its own timeset, with different beginning and ending times and number of steps. These timesets are combined into the solution time range in the solution dialog. But, with this general capability comes the need to know what to do when a current time lies outside the extents of, or between the steps of a given timeset.
        
        Args:
            p0:
                'method'
        
                * undefined
                * nearest
        
        Examples:
            ::
        
                #
                # Selecting the timeset
                #
                ensight.solution_time.timeset_select(2)
                #
                # Setting the timeset span handling methods
                # (Note that we will treat as undefined if left of)
                #
                ensight.solution_time.timeset_leftof("undefined")
                ensight.solution_time.timeset_between("interpolate")
                ensight.solution_time.timeset_rightof("nearest")
                #
                # Update timesets and model display
                #
                ensight.solution_time.timeset_update()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.solution_time.timeset_leftof({repr(p0)})'''
        return self._session.cmd(cmd)

    def timeset_rightof(self, p0: str) -> int:
        """When the current time lies after the ending step of a given timeset, this command sets how to handle the situation. 
        
        | The geometry and each variable can be specified according to its own timeset, with different beginning and ending times and number of steps. These timesets are combined into the solution time range in the solution dialog. But, with this general capability comes the need to know what to do when a current time lies outside the extents of, or between the steps of a given timeset.
        
        Args:
            p0:
                'method'
        
                * undefined
                * nearest
        
        Examples:
            ::
        
                #
                # Selecting the timeset
                #
                ensight.solution_time.timeset_select(2)
                #
                # Setting the timeset span handling methods
                # (Note that we will treat as nearest if right of)
                #
                ensight.solution_time.timeset_leftof("undefined")
                ensight.solution_time.timeset_between("interpolate")
                ensight.solution_time.timeset_rightof("nearest")
                #
                # Update timesets and model display
                #
                ensight.solution_time.timeset_update()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.solution_time.timeset_rightof({repr(p0)})'''
        return self._session.cmd(cmd)

    def timeset_select(self, p0: int) -> int:
        """Selects the timeset to modify.
        
        Args:
            p0:
                'ts_num' timeset number
        
        Examples:
            ::
        
                #
                # Selecting the timeset
                #
                ensight.solution_time.timeset_select(2)
                #
                # Setting the timeset span handling methods
                # (Note that we will treat as nearest if right of)
                #
                ensight.solution_time.timeset_leftof("undefined")
                ensight.solution_time.timeset_between("interpolate")
                ensight.solution_time.timeset_rightof("nearest")
                #
                # Update timesets and model display 
                #
                ensight.solution_time.timeset_update()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.solution_time.timeset_select({repr(p0)})'''
        return self._session.cmd(cmd)

    def timeset_update(self) -> int:
        """Updates the selected timeset and any associated display of the model according to the span handling methods specified. 
        
        Examples:
            ::
        
                #
                # Selecting the timeset
                #
                ensight.solution_time.timeset_select(2)
                #
                # Setting the timeset span handling methods
                # (Note that we will treat as nearest if right of)
                #
                ensight.solution_time.timeset_leftof("undefined")
                ensight.solution_time.timeset_between("interpolate")
                ensight.solution_time.timeset_rightof("nearest")
                #
                # Update timesets and model display
                #
                ensight.solution_time.timeset_update()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.solution_time.timeset_update()'''
        return self._session.cmd(cmd)

    def update_time_steps(self) -> int:
        """Solution_time: update_time_steps

        """
        cmd = f'''ensight.solution_time.update_time_steps()'''
        return self._session.cmd(cmd)

    def update_to_current(self) -> int:
        """Causes the display and all associated computations of the model to be updated to the currently specified time or step. 
        
        Examples:
            ::
        
                #
                # This sets several of the attributes using simulation time
                #
                ensight.solution_time.show_as("time")
                ensight.solution_time.update_type("continuous")
                ensight.solution_time.begin_simtime(0.0000e+00)
                ensight.solution_time.end_simtime(1.6000e+01)
                ensight.solution_time.current_simtime(9.0000e+00)
                ensight.solution_time.update_to_current()
                ensight.solution_time.number_of_cycles(1)
                ensight.solution_time.increment(2.0000e+00)
                #
                # But here we change it to use time steps
                #
                ensight.solution_time.show_as("step")
                ensight.solution_time.update_type("discrete")
                ensight.solution_time.begin_step(0)
                ensight.solution_time.end_step(16)
                ensight.solution_time.current_step(5)
                ensight.solution_time.update_to_current()
                ensight.solution_time.number_of_cycles(1)
                ensight.solution_time.increment(1.0000e+00)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.solution_time.update_to_current()'''
        return self._session.cmd(cmd)

    def update_to_first(self) -> int:
        """Causes the display and all associated computations of the model to be updated to the first time or step of the model. 
        
        | This command is not generated by the EnSight GUI, but is intended for use with batch or context operations where the time of the first step could vary from model to model.
        
        Examples:
            ::
        
                ensight.solution_time.update_to_first()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.solution_time.update_to_first()'''
        return self._session.cmd(cmd)

    def update_to_last(self) -> int:
        """Causes the display and all associated computations of the model to be updated to the last time or step of the model. 
        
        | This command is not generated by the EnSight GUI, but is intended for use with batch or context operations where the time of the last step could vary from model to model.
        
        Examples:
            ::
        
                ensight.solution_time.update_to_last()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.solution_time.update_to_last()'''
        return self._session.cmd(cmd)

    def update_type(self, p0: str) -> int:
        """Sets whether times or time steps can be specified between the data steps in the model, thus causing interpolation to be needed.
        
        | This command and "solution_time: show_as" combine to control whether interpolation will be needed.
        
        Args:
            p0:
                'method'
        
                * discrete
                * continuous
        
        Examples:
            ::
        
                #
                # This sets several of the attributes using simulation time
                #
                ensight.solution_time.show_as("time")
                ensight.solution_time.update_type("continuous")
                ensight.solution_time.begin_simtime(0.0000e+00)
                ensight.solution_time.end_simtime(1.6000e+01)
                ensight.solution_time.current_simtime(9.0000e+00)
                ensight.solution_time.update_to_current()
                ensight.solution_time.number_of_cycles(1)
                ensight.solution_time.increment(2.0000e+00)
                #
                # But here we change it to use time steps
                #
                ensight.solution_time.show_as("step")
                ensight.solution_time.update_type("discrete")
                ensight.solution_time.begin_step(0)
                ensight.solution_time.end_step(16)
                ensight.solution_time.current_step(5)
                ensight.solution_time.update_to_current()
                ensight.solution_time.number_of_cycles(1)
                ensight.solution_time.increment(1.0000e+00)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.solution_time.update_type({repr(p0)})'''
        return self._session.cmd(cmd)

    def use_custom_timeline(self, p0: str) -> int:
        """Solution_time: use_custom_timeline

        """
        cmd = f'''ensight.solution_time.use_custom_timeline({repr(p0)})'''
        return self._session.cmd(cmd)

    def zoomin(self, p0: float, p1: float) -> int:
        """Solution_time: zoomin

        """
        cmd = f'''ensight.solution_time.zoomin({repr(p0)},{repr(p1)})'''
        return self._session.cmd(cmd)

    def zoomout(self) -> int:
        """Resets the begin and end steps (or begin and end simtimes) to the widest possible settings.
        
        | This may be desirable after one has modified (narrowed) the begin and end steps or time for a given temporary purpose.
        
        Examples:
            ::
        
                ensight.solution_time.show_as("step")
                ensight.solution_time.update_type("discrete")
                ensight.solution_time.begin_step(3)
                ensight.solution_time.end_step(12)
                ensight.solution_time.current_step(5)
                ensight.solution_time.update_to_current()
                ensight.solution_time.number_of_cycles(1)
                ensight.solution_time.increment(1.0000e+00)
                #
                # One could load a flipbook or something like 
                # that at this point, using the narrowed range
                # of 3 to 12.  Then could use the next command
                # to get the range back to 0 to 16
                #
                ensight.solution_time.zoomout()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.solution_time.zoomout()'''
        return self._session.cmd(cmd)


class show_info:
    """Class wrapper for EnSight show_info module

    This class acts as a proxy for the EnSight Python module ensight.show_info
    """
    def __init__(self, session: Session):
        self._session = session

    def cursor(self, p0: float, p1: float, p2: float) -> int:
        """Show corresponding part and values of all active variables at the specified x, y, z model location.
        
        | Used in conjunction with the following commands.
        | view_transf: function cursor 
        | view_transf: action translate 
        | view_transf: cursor
        
        Args:
            p0:
                'x-coord' x, y, z  locations of the cursor in model coordinates
            p1:
                'y-coord' x, y, z  locations of the cursor in model coordinates
            p2:
                'z-coord' x, y, z  locations of the cursor in model coordinates
        
        Examples:
            ::
        
                # 
                # Toggle-on and position the cursor tool 
                # 
                ensight.view_transf.function("cursor")
                ensight.tools.cursor("ON")
                ensight.view_transf.action("translate")
                ensight.view_transf.cursor(-1.0000e+00,0.500000,0.500000)
                # 
                # Revert back to global transformation mode 
                # 
                ensight.view_transf.function("global")
                # 
                # Show part and all active variable information at cursor location 
                # 
                ensight.show_info.cursor(-1.0000e+00,0.0000e+00,0.0000e+00)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.show_info.cursor({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def element(self, p0: int) -> int:
        """Query/show the associated part connectivity and values of all active variables for the specified element id label.
        
        Args:
            p0:
                'element_id_number' a valid element id corresponding to the specified part
        
        Examples:
            ::
        
                # 
                # Specify which part 
                # 
                ensight.part.select_begin(1)
                # 
                # from which to show the corresponding element information. 
                # 
                ensight.show_info.element(20)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.show_info.element({repr(p0)})'''
        return self._session.cmd(cmd)

    def ijk(self, p0: float, p1: float, p2: float) -> int:
        """Query/show the associated part connectivity and values of all active variables for the specified i, j, and k location.
        
        | Only applicable for structured parts.
        
        Args:
            p0:
                'i-plane_value' corresponding i, j, k-plane values
            p1:
                'j-plane_value' corresponding i, j, k-plane values
            p2:
                'k-plane_value' corresponding i, j, k-plane values
        
        Examples:
            ::
        
                # 
                # Specify the part ... 
                # 
                ensight.part.select_begin(1)
                # 
                # and active variables ... 
                # 
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.show_info.ijk({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def node(self, p0: int) -> int:
        """Query/show the associated part connectivity and values of all active variables for the specified node id label.
        
        Args:
            p0:
                'node_id_number' valid node id corresponding to the specified part
        
        Examples:
            ::
        
                # WARNING: following line includes OBSOLETE call (ensight.variables.select_varname_begin).
                ensight.variables.select_varname_begin("Density ","Energy ","Momentum ","Velo ","variables: select_varname_end ","# ","# at which to show the specified ijk information. ","# ","show_info: ijk 1 41 1","# ","# Specify to show the information of node 8000 of part 1 ","# ","part: select_begin ","1 ")
                ensight.show_info.node(8000)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.show_info.node({repr(p0)})'''
        return self._session.cmd(cmd)

    def part(self, p0: int) -> int:
        """Query/show the associated model information and extent values for the specified part id. 
        
        Args:
            p0:
                'part_id_number' the part GUI number
        
        Examples:
            ::
        
                # 
                # First, select the part ... 
                # 
                ensight.part.select_begin(1)
                # 
                # Then, specify to show its corresponding information. 
                # 
                ensight.show_info.part(1)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.show_info.part({repr(p0)})'''
        return self._session.cmd(cmd)

    def point(self, p0: float, p1: float, p2: float) -> int:
        """Show_info: point

        """
        cmd = f'''ensight.show_info.point({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)


class shock:
    """Class wrapper for EnSight shock module

    This class acts as a proxy for the EnSight Python module ensight.shock
    """
    def __init__(self, session: Session):
        self._session = session

    def begin(self) -> int:
        """Delimit the modifications for shock part attributes.
        
        | These commands are used to set the attributtes for a shock part creation.
        
        Args:
            p0:
                'shock_command' "shock: variable" commands
        
        Examples:
            ::
        
                #
                # Specify the 3D parent part(s) 
                # from which to create the shock part
                #
                ensight.part.select_begin(1)
                #
                # Compute the shock part by the Surface method
                #
                ensight.shock.begin()
                ensight.shock.variable("Pressure")
                ensight.shock.end()
                ensight.shock.create()
                #
                # Now select the newly created shock part 
                # for subsequent operations
                #
                ensight.part.select_begin(5)
        
            ::
        
                #
                # Specify the 3D parent part(s) 
                # from which to create the shock part
                #
                ensight.part.select_begin(1)
                #
                # Compute the shock part by the Region method
                #
                ensight.shock.begin()
                ensight.shock.variable("none")
                ensight.shock.end()
                ensight.shock.create()
                #
                # Now select the newly created shock part 
                # for subsequent operations
                #
                ensight.part.select_begin(5)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.shock.begin()'''
        return self._session.cmd(cmd)

    def create(self) -> int:
        """Create a shock part with the currently defined attributes using the currently selected 3D part(s).
        
        Examples:
            ::
        
                #
                # Specify the 3D parent part(s)
                # from which to create the shock part
                #
                ensight.part.select_begin(1)
                #
                # Compute the shock part by the Surface method
                #
                ensight.shock.begin()
                ensight.shock.variable("Pressure")
                ensight.shock.end()
                ensight.shock.create()
                #
                # Now select the newly created shock part 
                # for subsequent operations
                #
                ensight.part.select_begin(5)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.shock.create()'''
        return self._session.cmd(cmd)

    def density(self, p0: Any) -> int:
        """Specify the density variable to use in creating/updating a shock part or the default attributes.
        
        | This variable is assigned automatically if the variable name <Density> exists. 
        | Since the computation of separation and attachment lines depend on density, either the density variable must be defined or both the pressure and temperature variables must be defined to obtain the density variable.
        
        Args:
            p0:
                'variable_name' name of the density variable (the default name <none> means to use nothing)
        
        Examples:
            ::
        
                ensight.variables.activate("Density")
                ensight.shock.select_default()
                ensight.part.modify_begin()
                ensight.shock.density("Density")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.shock.density({repr(p0)})'''
        return self._session.cmd(cmd)

    def end(self) -> int:
        """Delimit the modifications for shock part attributes.
        
        | These commands are used to set the attributtes for a shock part creation.
        
        Args:
            p0:
                'shock_command' "shock: variable" commands
        
        Examples:
            ::
        
                #
                # Specify the 3D parent part(s) 
                # from which to create the shock part
                #
                ensight.part.select_begin(1)
                #
                # Compute the shock part by the Surface method
                #
                ensight.shock.begin()
                ensight.shock.variable("Pressure")
                ensight.shock.end()
                ensight.shock.create()
                #
                # Now select the newly created shock part 
                # for subsequent operations
                #
                ensight.part.select_begin(5)
        
            ::
        
                #
                # Specify the 3D parent part(s) 
                # from which to create the shock part
                #
                ensight.part.select_begin(1)
                #
                # Compute the shock part by the Region method
                #
                ensight.shock.begin()
                ensight.shock.variable("none")
                ensight.shock.end()
                ensight.shock.create()
                #
                # Now select the newly created shock part 
                # for subsequent operations
                #
                ensight.part.select_begin(5)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.shock.end()'''
        return self._session.cmd(cmd)

    def enthalpy(self, p0: Any) -> int:
        """Specify the enthalpy variable to use in creating/updating a shock part or the default attributes.
        
        | This variable is not needed unless you are computing the shock via the Region method and transient (moving) shocks are specified via the "test: toggle_moving_shock" command.
        
        Args:
            p0:
                'variable_name' name of the enthalpy variable (the default name <none> means to use nothing).
        
        Examples:
            ::
        
                ensight.variables.activate("Enthalpy")
                ensight.shock.select_default()
                ensight.part.modify_begin()
                ensight.shock.density("Enthalpy")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.shock.enthalpy({repr(p0)})'''
        return self._session.cmd(cmd)

    def gas_constant(self, args: Any) -> int:
        """Specify the gas constant as a constant value or a variable name to use in creating/updating a shock part or the default attributes.
        
        Args:
            p0:
                'name' scalar field variable name for the gas constant
            p1:
                'value' a constant value (default =1.) for the gas constant
        
        Examples:
            ::
        
                ensight.shock.select_default()
                ensight.part.modify_begin()
                ensight.shock.gas_constant(1.)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.shock.gas_constant({repr(args)})'''
        return self._session.cmd(cmd)

    def mach(self, p0: Any) -> int:
        """Specify the mach variable to use in creating/updating a shock part or the default attributes.
        
        | Although the specification of this variable is optional, if it exists, its specification will save the creation of a temporary variable.  If this variable is not specified or does not exist, it will be created on-the-fly temporarily as needed from dependent density, energy or pressure, velocity or momentum, and ratio of specific heats variables and values.
        
        Args:
            p0:
                'variable_name' name of the mach variable (the default name <none> means to use nothing)
        
        Examples:
            ::
        
                ensight.variables.activate("Mach")
                ensight.vortexcore.select_default()
                ensight.part.modify_begin()
                ensight.vortexcore.density("Mach")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.shock.mach({repr(p0)})'''
        return self._session.cmd(cmd)

    def method(self, p0: str) -> int:
        """Specify the algorithm to use for the computation of  the shock part.
        
        | The Surface method requires the specification of a shock threshold variable.  The Region method does not require the specification of a shock threshold variable.
        
        Args:
            p0:
                'algorithm'
        
                * region
                * surface
        
        Examples:
            ::
        
                ensight.part.select_begin(8)
                ensight.part.modify_begin()
                ensight.shock.method("region")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.shock.method({repr(p0)})'''
        return self._session.cmd(cmd)

    def momentum(self, p0: Any) -> int:
        """Specify the momentum variable to use in creating/updating a shock part or the default attributes.
        
        | This variable is assigned automatically if the variable name "momentum" exists. 
        | Since the computation of shock depends on velocity, either the velocity variable must be defined or both the density and momentum variables must be defined to obtain the velocity variable.
        
        Args:
            p0:
                'variable_name' name of the momentum variable (the default name <none> means to use nothing
        
        Examples:
            ::
        
                ensight.variables.activate("momentum")
                ensight.shock.select_default()
                ensight.part.modify_begin()
                ensight.shock.momentum("momentum")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.shock.momentum({repr(p0)})'''
        return self._session.cmd(cmd)

    def pressure(self, p0: Any) -> int:
        """Specify the pressure variable to use in creating/updating a shock part or the default attributes.
        
        | This variable is used throughout the shock calculation. Although the specification of this variable is optional, if it exists, its specification will save the creation of a temporary variable.  If this variable is not specified or does not exist, it will be created on-the-fly temporarily as needed from dependent density, energy, velocity or momentum, and ratio of specific heats variables and values.
        
        Args:
            p0:
                'variable_name' name of the pressure variable (the default name <none> means to use nothing
        
        Examples:
            ::
        
                ensight.variables.activate("Pressure")
                ensight.shock.select_default()
                ensight.part.modify_begin()
                ensight.shock.pressure("Pressure")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.shock.pressure({repr(p0)})'''
        return self._session.cmd(cmd)

    def ratio_of_spec_heat(self, args: Any) -> int:
        """Specify the ratio of specific heat constant value or variable name to use in creating/updating a shock part or the default attributes.
        
        Args:
            p0:
                'name' scalar field variable name for the ratio of specific heats
            p1:
                'value' a constant value (default = 1.4) for the ratio of specific heats
        
        Examples:
            ::
        
                ensight.shock.select_default()
                ensight.part.modify_begin()
                ensight.shock.ratio_of_spec_heat(1.4)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.shock.ratio_of_spec_heat({repr(args)})'''
        return self._session.cmd(cmd)

    def region_threshold_max(self, p0: float) -> int:
        """Shock: region_threshold_max

        """
        cmd = f'''ensight.shock.region_threshold_max({repr(p0)})'''
        return self._session.cmd(cmd)

    def region_threshold_min(self, p0: float) -> int:
        """Shock: region_threshold_min

        """
        cmd = f'''ensight.shock.region_threshold_min({repr(p0)})'''
        return self._session.cmd(cmd)

    def region_threshold_value(self, p0: float) -> int:
        """Shock: region_threshold_value

        """
        cmd = f'''ensight.shock.region_threshold_value({repr(p0)})'''
        return self._session.cmd(cmd)

    def select_default(self) -> int:
        """Specify that the default attributes of the shock part are to be set for all subsequent shock attribute  updates.
        
        Examples:
            ::
        
                ensight.vortexcore.select_default()
                ensight.part.modify_begin()
                ensight.shock.momentum("none")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.shock.select_default()'''
        return self._session.cmd(cmd)

    def specific_gas(self, args: Any) -> int:
        """Shock: specific_gas

        """
        cmd = f'''ensight.shock.specific_gas({repr(args)})'''
        return self._session.cmd(cmd)

    def surface_threshold_max(self, p0: float) -> int:
        """Shock: surface_threshold_max

        """
        cmd = f'''ensight.shock.surface_threshold_max({repr(p0)})'''
        return self._session.cmd(cmd)

    def surface_threshold_min(self, p0: float) -> int:
        """Shock: surface_threshold_min

        """
        cmd = f'''ensight.shock.surface_threshold_min({repr(p0)})'''
        return self._session.cmd(cmd)

    def surface_threshold_value(self, p0: float) -> int:
        """Shock: surface_threshold_value

        """
        cmd = f'''ensight.shock.surface_threshold_value({repr(p0)})'''
        return self._session.cmd(cmd)

    def temperature(self, p0: Any) -> int:
        """Specify the temperature variable to use in creating/updating a shock part or the default attributes.
        
        | Although the specification of this variable is optional, if it exists, its specification will save the creation of a temporary variable.  
        | This variable is required for the creation of Density if Density does not exist.  If Density exists, no need to create this variable, unless you would like to use this as the shock creation variable for the Surface method.
        
        Args:
            p0:
                'variable_name' name of the temperature variable (the default name <none> means to use nothing
        
        Examples:
            ::
        
                ensight.variables.activate("Temperature")
                ensight.shock.select_default()
                ensight.part.modify_begin()
                ensight.shock.momentum("Temperature")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.shock.temperature({repr(p0)})'''
        return self._session.cmd(cmd)

    def threshold(self, p0: Any) -> int:
        """Specify the threshold variable description by which to filter the segments of the selected shock part.
        
        | The default threshold for the Region shock part is "SHK_Threshold". The default threshold for the Region shock part is "SHK_xxx", where xxx is the name of the variable used as the shock creation variable.
        
        Args:
            p0:
                'variable_name' name of the scalar variable by which to filter the vortex core segments
        
        Examples:
            ::
        
                ensight.part.select_begin(8)
                ensight.part.modify_begin()
                ensight.shock.threshold("Density")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.shock.threshold({repr(p0)})'''
        return self._session.cmd(cmd)

    def threshold_filter(self, p0: str) -> int:
        """Specify how to filter out segments of the specified shock part, according to the specified threshold variable and value.
        
        Args:
            p0:
                'option'
        
                * <=
                * >=
        
        Examples:
            ::
        
                ensight.part.select_begin(8)
                ensight.part.modify_begin()
                ensight.shock.threshold_filter(">=")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.shock.threshold_filter({repr(p0)})'''
        return self._session.cmd(cmd)

    def threshold_max(self, p0: float) -> int:
        """Specify the maximum/minimum threshold limit under which to filter the threshold value of the selected shock part(s).
        
        | Max must be greater than the min value, and be a valid threshold variable value. 
        
        Args:
            p0:
                'threshold_value' maximum/minimum threshold variable range limit below/above which to threshold the shock part
        
        Examples:
            ::
        
                ensight.part.select_begin(8)
                ensight.part.modify_begin()
                ensight.shock.threshold_min(0.1)
                ensight.shock.threshold_max(10.0)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.shock.threshold_max({repr(p0)})'''
        return self._session.cmd(cmd)

    def threshold_min(self, p0: float) -> int:
        """Specify the maximum/minimum threshold limit under which to filter the threshold value of the selected shock part(s).
        
        | Max must be greater than the min value, and be a valid threshold variable value. 
        
        Args:
            p0:
                'threshold_value' maximum/minimum threshold variable range limit below/above which to threshold the shock part
        
        Examples:
            ::
        
                ensight.part.select_begin(8)
                ensight.part.modify_begin()
                ensight.shock.threshold_min(0.1)
                ensight.shock.threshold_max(10.0)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.shock.threshold_min({repr(p0)})'''
        return self._session.cmd(cmd)

    def threshold_value(self, p0: float) -> int:
        """Specify the threshold value by which to filter the elements from the selected shock part(s).
        
        | This value is automatically set to a value that should approximate the valid region in which the shock part should exist.  Although for some models, further refinement and adjustment of the threshold min/max values is required. 
        | This value must lie within the threshold variable interval [threshold_min, threshold_max].
        
        Args:
            p0:
                'threshold_value' variable value by which to apply the threshold filter to the shock elements
        
        Examples:
            ::
        
                ensight.part.select_begin(8)
                ensight.part.modify_begin()
                ensight.shock.threshold_value(5.0000e-01)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.shock.threshold_value({repr(p0)})'''
        return self._session.cmd(cmd)

    def total_energy(self, p0: Any) -> int:
        """Specify the total energy variable to use in creating/updating a shock part or the default attributes.
        
        | Although the specification of this variable is optional, if it exists, its specification will save the creation of a temporary variable.  
        | This variable is required for the creation of Pressure if Pressure does not exist.  If Pressure exists, no need to create this variable, unless you would like to use this as the shock creation variable for the Surface method.
        
        Args:
            p0:
                'variable_name' name of the total energy variable (the default <none> means to use nothing)
        
        Examples:
            ::
        
                ensight.variables.activate("TotalEnergy")
                ensight.vortexcore.select_default()
                ensight.part.modify_begin()
                ensight.shock.velocity("TotalEnergy")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.shock.total_energy({repr(p0)})'''
        return self._session.cmd(cmd)

    def variable(self, p0: Any) -> int:
        """Specify the variable (i.e Density, Energy, Pressure, or Temperature) in which to create the Surface method shock part(s).
        
        | For the Surface method, this variable is either Density, Energy, Pressure, or Temperature; and this variable must have previously been defined via its respective shock: density, energy, pressure, or temperature definition. 
        | For the Region method, this variable is always pressure, and thus the specification is not needed; thus, <none> is used as the shock variable.
        
        Args:
            p0:
                'variable_name' name of the variable in which to use as the creation variable or the variable in which to apply the gradient calculations for the shock function
        
        Examples:
            ::
        
                #
                # Specify the 3D parent part(s) 
                # from which to create the shock part
                #
                ensight.part.select_begin(1)
                #
                # Compute the shock part by the Surface method
                #
                ensight.shock.begin()
                ensight.shock.variable("Pressure")
                ensight.shock.end()
                ensight.shock.create()
                #
                # Now select the newly created shock part 
                # for subsequent operations
                #
                ensight.part.select_begin(5)
        
            ::
        
                #
                # Specify the 3D parent part(s) 
                # from which to create the shock part
                #
                ensight.part.select_begin(1)
                #
                # Compute the shock part by the Region method
                #
                ensight.shock.begin()
                ensight.shock.variable("none")
                ensight.shock.end()
                ensight.shock.create()
                #
                # Now select the newly created shock part 
                # for subsequent operations
                #
                ensight.part.select_begin(5)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.shock.variable({repr(p0)})'''
        return self._session.cmd(cmd)

    def velocity(self, p0: Any) -> int:
        """Specify the velocity variable to use in creating/updating a shock part or the default attributes.
        
        | Since the computation of shock depends on velocity, either  the velocity variable must be defined or both the density and  momentum variables must be defined to obtain the velocity variable.
        
        Args:
            p0:
                'variable_name' name of the velocity variable (the default <none> means to use nothing)
        
        Examples:
            ::
        
                ensight.variables.activate("Velocity")
                ensight.shock.select_default()
                ensight.part.modify_begin()
                ensight.shock.velocity("Velocity")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.shock.velocity({repr(p0)})'''
        return self._session.cmd(cmd)


class shell:
    """Class wrapper for EnSight shell module

    This class acts as a proxy for the EnSight Python module ensight.shell
    """
    def __init__(self, session: Session):
        self._session = session

    def replace(self, p0: str) -> int:
        """Shell: replace

        """
        cmd = f'''ensight.shell.replace({repr(p0)})'''
        return self._session.cmd(cmd)

    def type(self, p0: str) -> int:
        """Shell: type

        """
        cmd = f'''ensight.shell.type({repr(p0)})'''
        return self._session.cmd(cmd)


class shape:
    """Class wrapper for EnSight shape module

    This class acts as a proxy for the EnSight Python module ensight.shape
    """
    def __init__(self, session: Session):
        self._session = session

    def arrow_tip_length(self, p0: float) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.shape.arrow_tip_length({repr(p0)})'''
        return self._session.cmd(cmd)

    def arrow_tip_size(self, p0: float) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.shape.arrow_tip_size({repr(p0)})'''
        return self._session.cmd(cmd)

    def delete(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.shape.delete()'''
        return self._session.cmd(cmd)

    def description(self, p0: str) -> int:
        """Shape: description

        """
        cmd = f'''ensight.shape.description({repr(p0)})'''
        return self._session.cmd(cmd)

    def deselect_all(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.shape.deselect_all()'''
        return self._session.cmd(cmd)

    def diameter(self, p0: float) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.shape.diameter({repr(p0)})'''
        return self._session.cmd(cmd)

    def fill(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.shape.fill({repr(p0)})'''
        return self._session.cmd(cmd)

    def height(self, p0: float) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.shape.height({repr(p0)})'''
        return self._session.cmd(cmd)

    def length(self, p0: float) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.shape.length({repr(p0)})'''
        return self._session.cmd(cmd)

    def line_width(self, p0: int) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.shape.line_width({repr(p0)})'''
        return self._session.cmd(cmd)

    def location_x(self, p0: float) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.shape.location_x({repr(p0)})'''
        return self._session.cmd(cmd)

    def location_y(self, p0: float) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.shape.location_y({repr(p0)})'''
        return self._session.cmd(cmd)

    def modify_begin(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.shape.modify_begin()'''
        return self._session.cmd(cmd)

    def modify_end(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.shape.modify_end()'''
        return self._session.cmd(cmd)

    def new_or_mod_shape(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.shape.new_or_mod_shape({repr(p0)})'''
        return self._session.cmd(cmd)

    def new_shape(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.shape.new_shape({repr(p0)})'''
        return self._session.cmd(cmd)

    def query_count(self, args: Any) -> int:
        """Shape: query_count

        """
        cmd = f'''ensight.shape.query_count({repr(args)})'''
        return self._session.cmd(cmd)

    def query_display_attributes(self, args: Any) -> int:
        """Shape: query_display_attributes

        """
        cmd = f'''ensight.shape.query_display_attributes({repr(args)})'''
        return self._session.cmd(cmd)

    def query_selected_objects(self, args: Any) -> int:
        """Shape: query_selected_objects

        """
        cmd = f'''ensight.shape.query_selected_objects({repr(args)})'''
        return self._session.cmd(cmd)

    def rgb(self, p0: float, p1: float, p2: float) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.shape.rgb({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def rotational_angle(self, p0: float) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.shape.rotational_angle({repr(p0)})'''
        return self._session.cmd(cmd)

    def select_all(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.shape.select_all()'''
        return self._session.cmd(cmd)

    def select_all_arrows(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.shape.select_all_arrows()'''
        return self._session.cmd(cmd)

    def select_all_circles(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.shape.select_all_circles()'''
        return self._session.cmd(cmd)

    def select_all_invisible(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.shape.select_all_invisible()'''
        return self._session.cmd(cmd)

    def select_all_rectangles(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.shape.select_all_rectangles()'''
        return self._session.cmd(cmd)

    def select_all_visible(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.shape.select_all_visible()'''
        return self._session.cmd(cmd)

    def select_begin(self, *args, **kwargs) -> Any:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.shape.select_begin({arg_string})"
        return self._session.cmd(cmd)

    def select_default(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.shape.select_default()'''
        return self._session.cmd(cmd)

    def special1(self, args: Any) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.shape.special1({repr(args)})'''
        return self._session.cmd(cmd)

    def special2(self, args: Any) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.shape.special2({repr(args)})'''
        return self._session.cmd(cmd)

    def texture_object(self, p0: int) -> int:
        """This command has not yet been completey documented.
        
        | Selects a texture object to be used on the currently selected 2D shape annotation.
        
        Args:
            p0:
                'num' texture number.  Value can be from 0 to 8.  The value of zero disables textures for the annotation.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.shape.texture_object({repr(p0)})'''
        return self._session.cmd(cmd)

    def type(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.shape.type({repr(p0)})'''
        return self._session.cmd(cmd)

    def visible(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.shape.visible({repr(p0)})'''
        return self._session.cmd(cmd)

    def width(self, p0: float) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.shape.width({repr(p0)})'''
        return self._session.cmd(cmd)


class set_visenv:
    """Class wrapper for EnSight set_visenv module

    This class acts as a proxy for the EnSight Python module ensight.set_visenv
    """
    def __init__(self, session: Session):
        self._session = session

    def begin(self) -> int:
        """Set_visenv: begin

        """
        cmd = f'''ensight.set_visenv.begin()'''
        return self._session.cmd(cmd)

    def component(self, p0: float, p1: float, p2: float) -> int:
        """Set_visenv: component

        """
        cmd = f'''ensight.set_visenv.component({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def create(self) -> int:
        """Set_visenv: create

        """
        cmd = f'''ensight.set_visenv.create()'''
        return self._session.cmd(cmd)

    def end(self) -> int:
        """Set_visenv: end

        """
        cmd = f'''ensight.set_visenv.end()'''
        return self._session.cmd(cmd)

    def offset(self, p0: float) -> int:
        """Set_visenv: offset

        """
        cmd = f'''ensight.set_visenv.offset({repr(p0)})'''
        return self._session.cmd(cmd)

    def offset_from_part(self, p0: int) -> int:
        """Set_visenv: offset_from_part

        """
        cmd = f'''ensight.set_visenv.offset_from_part({repr(p0)})'''
        return self._session.cmd(cmd)

    def offset_scale(self, p0: float) -> int:
        """Set_visenv: offset_scale

        """
        cmd = f'''ensight.set_visenv.offset_scale({repr(p0)})'''
        return self._session.cmd(cmd)

    def offset_vector(self, p0: float, p1: float, p2: float) -> int:
        """Set_visenv: offset_vector

        """
        cmd = f'''ensight.set_visenv.offset_vector({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def scale_factor(self, p0: float) -> int:
        """Set_visenv: scale_factor

        """
        cmd = f'''ensight.set_visenv.scale_factor({repr(p0)})'''
        return self._session.cmd(cmd)

    def select_default(self) -> int:
        """Set_visenv: select_default

        """
        cmd = f'''ensight.set_visenv.select_default()'''
        return self._session.cmd(cmd)

    def sidewall(self, p0: str) -> int:
        """Set_visenv: sidewall

        """
        cmd = f'''ensight.set_visenv.sidewall({repr(p0)})'''
        return self._session.cmd(cmd)

    def surface(self, p0: str) -> int:
        """Set_visenv: surface

        """
        cmd = f'''ensight.set_visenv.surface({repr(p0)})'''
        return self._session.cmd(cmd)

    def type(self, p0: str) -> int:
        """Set_visenv: type

        """
        cmd = f'''ensight.set_visenv.type({repr(p0)})'''
        return self._session.cmd(cmd)

    def use_surface_normals(self, p0: str) -> int:
        """Set_visenv: use_surface_normals

        """
        cmd = f'''ensight.set_visenv.use_surface_normals({repr(p0)})'''
        return self._session.cmd(cmd)

    def var_type(self, p0: str) -> int:
        """Set_visenv: var_type

        """
        cmd = f'''ensight.set_visenv.var_type({repr(p0)})'''
        return self._session.cmd(cmd)

    def variable(self, p0: Any) -> int:
        """Set_visenv: variable

        """
        cmd = f'''ensight.set_visenv.variable({repr(p0)})'''
        return self._session.cmd(cmd)


class set_tdata:
    """Class wrapper for EnSight set_tdata module

    This class acts as a proxy for the EnSight Python module ensight.set_tdata
    """
    def __init__(self, session: Session):
        self._session = session

    def begin(self) -> int:
        """Set_tdata: begin

        """
        cmd = f'''ensight.set_tdata.begin()'''
        return self._session.cmd(cmd)

    def component(self, p0: float, p1: float, p2: float) -> int:
        """Set_tdata: component

        """
        cmd = f'''ensight.set_tdata.component({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def create(self) -> int:
        """Set_tdata: create

        """
        cmd = f'''ensight.set_tdata.create()'''
        return self._session.cmd(cmd)

    def end(self) -> int:
        """Set_tdata: end

        """
        cmd = f'''ensight.set_tdata.end()'''
        return self._session.cmd(cmd)

    def offset(self, p0: float) -> int:
        """Set_tdata: offset

        """
        cmd = f'''ensight.set_tdata.offset({repr(p0)})'''
        return self._session.cmd(cmd)

    def offset_from_part(self, p0: int) -> int:
        """Set_tdata: offset_from_part

        """
        cmd = f'''ensight.set_tdata.offset_from_part({repr(p0)})'''
        return self._session.cmd(cmd)

    def offset_scale(self, p0: float) -> int:
        """Set_tdata: offset_scale

        """
        cmd = f'''ensight.set_tdata.offset_scale({repr(p0)})'''
        return self._session.cmd(cmd)

    def offset_vector(self, p0: float, p1: float, p2: float) -> int:
        """Set_tdata: offset_vector

        """
        cmd = f'''ensight.set_tdata.offset_vector({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def scale_factor(self, p0: float) -> int:
        """Set_tdata: scale_factor

        """
        cmd = f'''ensight.set_tdata.scale_factor({repr(p0)})'''
        return self._session.cmd(cmd)

    def select_default(self) -> int:
        """Set_tdata: select_default

        """
        cmd = f'''ensight.set_tdata.select_default()'''
        return self._session.cmd(cmd)

    def sidewall(self, p0: str) -> int:
        """Set_tdata: sidewall

        """
        cmd = f'''ensight.set_tdata.sidewall({repr(p0)})'''
        return self._session.cmd(cmd)

    def surface(self, p0: str) -> int:
        """Set_tdata: surface

        """
        cmd = f'''ensight.set_tdata.surface({repr(p0)})'''
        return self._session.cmd(cmd)

    def type(self, p0: str) -> int:
        """Set_tdata: type

        """
        cmd = f'''ensight.set_tdata.type({repr(p0)})'''
        return self._session.cmd(cmd)

    def use_surface_normals(self, p0: str) -> int:
        """Set_tdata: use_surface_normals

        """
        cmd = f'''ensight.set_tdata.use_surface_normals({repr(p0)})'''
        return self._session.cmd(cmd)

    def var_type(self, p0: str) -> int:
        """Set_tdata: var_type

        """
        cmd = f'''ensight.set_tdata.var_type({repr(p0)})'''
        return self._session.cmd(cmd)

    def variable(self, p0: Any) -> int:
        """Set_tdata: variable

        """
        cmd = f'''ensight.set_tdata.variable({repr(p0)})'''
        return self._session.cmd(cmd)


class sepattach:
    """Class wrapper for EnSight sepattach module

    This class acts as a proxy for the EnSight Python module ensight.sepattach
    """
    def __init__(self, session: Session):
        self._session = session

    def begin(self) -> int:
        """Delimit the modifications for separation or attachment line attributes.
        
        | These commands are used to set the attributes for a separation or attachment line part creation.
        
        Examples:
            ::
        
                #
                # Specify the 2D parent part(s) from which
                # to create the separation and attachment lines
                #
                ensight.part.select_begin(2,3)
                #
                # Compute the separation and attachment lines parts
                #
                ensight.sepattach.begin()
                ensight.sepattach.end()
                ensight.sepattach.create()
                #
                # Now select the newly created separation and 
                # attachment line parts for subsequent operations
                #
                ensight.part.select_begin(6,7)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.sepattach.begin()'''
        return self._session.cmd(cmd)

    def create(self) -> int:
        """Create separation and attachment line parts using the currently selected 2D parts and defined attributes.
        
        | This feature is different from other features in that it creates two parts, i.e. a separation line part, and an attachment line part.  In addition, both of these parts are modified with any command change applied to either one or both of these parts.
        
        Examples:
            ::
        
                #
                # Specify the 2D parent part(s) from which
                # to create the separation and attachment lines
                #
                ensight.part.select_begin(2,3)
                #
                # Compute the separation and attachment lines parts
                #
                ensight.sepattach.begin()
                ensight.sepattach.end()
                ensight.sepattach.create()
                #
                # Now select the newly created separation and 
                # attachment line parts for subsequent operations
                #
                ensight.part.select_begin(6,7)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.sepattach.create()'''
        return self._session.cmd(cmd)

    def density(self, p0: Any) -> int:
        """Specify the density variable to use in creating/updating the default separation and attachment line part attributes and/or the selected separation and attachment line part(s).
        
        | This variable is assigned automatically if the variable name description <Density> exists. Since the computation of separation and attachment lines depend on velocity, either the velocity variable must be defined or both the density and momentum variables must be defined to obtain the velocity variable.
        
        Args:
            p0:
                'variable_name' name of the density variable (the default <none> means to use nothing)
        
        Examples:
            ::
        
                ensight.variables.activate("Density")
                ensight.sepattach.select_default()
                ensight.part.modify_begin()
                ensight.sepattach.density("Density")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.sepattach.density({repr(p0)})'''
        return self._session.cmd(cmd)

    def display_offset(self, p0: float) -> int:
        """Specify the offset from the 2D parent part(s) surface from which to display (or lift) the separation and attachment line parts.
        
        | This offset measures in model coordinate units, in the normal direction from the 2D parent part(s) surface(s); and thus, may need to be specified as either a + or - number.
        
        Args:
            p0:
                'offset_value' numerical offset value from the 2D surface, (default = 0.)
        
        Examples:
            ::
        
                ensight.part.modify_begin()
                ensight.sepattach.display_offset(-1.0000e-03)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.sepattach.display_offset({repr(p0)})'''
        return self._session.cmd(cmd)

    def end(self) -> int:
        """Delimit the modifications for separation or attachment line attributes.
        
        | These commands are used to set the attributes for a separation or attachment line part creation.
        
        Examples:
            ::
        
                #
                # Specify the 2D parent part(s) from which
                # to create the separation and attachment lines
                #
                ensight.part.select_begin(2,3)
                #
                # Compute the separation and attachment lines parts
                #
                ensight.sepattach.begin()
                ensight.sepattach.end()
                ensight.sepattach.create()
                #
                # Now select the newly created separation and 
                # attachment line parts for subsequent operations
                #
                ensight.part.select_begin(6,7)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.sepattach.end()'''
        return self._session.cmd(cmd)

    def method(self, p0: str) -> int:
        """Specify the method, or algorithm, in which to compute the separation and attachment line parts, from either 2D parent part(s) or in recomputing existing 1D separation and attachment line parts.
        
        | Currently only one algorithm offered.
        
        Args:
            p0:
                'option'
        
                * phase_plane
        
        Examples:
            ::
        
                ensight.part.select_begin(6,7)
                ensight.part.modify_begin()
                ensight.sepattach.method("phase_plane")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.sepattach.method({repr(p0)})'''
        return self._session.cmd(cmd)

    def momentum(self, p0: Any) -> int:
        """Specify the momentum variable to use in creating/updating the default separation and attachment line part attributes and/or the selected separation and attachment line part(s).
        
        | This variable is assigned automatically if the variable name description <Momentum> exists. Since the computation of separation and attachment lines depend on velocity, either the velocity variable must be defined or both the density and momentum variables must be defined to obtain the velocity variable.
        
        Args:
            p0:
                'variable_name' name of the momentum variable (the default <none> means to use nothing)
        
        Examples:
            ::
        
                ensight.variables.activate("Momentum")
                ensight.sepattach.select_default()
                ensight.part.modify_begin()
                ensight.sepattach.momentum("Momentum")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.sepattach.momentum({repr(p0)})'''
        return self._session.cmd(cmd)

    def ratio_of_spec_heat(self, args: Any) -> int:
        """Specify the ratio of specific heat constant value or variable name to use in creating/updating the default separation and attachment line attributes and/or selected separation and attachment part(s).
        
        | The <name or value> can be multiple types depending on variable definition.
        
        Args:
            p0:
                'name' scalar field variable name for the ratio of specific heats
            p1:
                'value' constant value (default = 1.4) for the ratio of specific heats
        
        Examples:
            ::
        
                ensight.sepattach.select_default()
                ensight.part.modify_begin()
                ensight.sepattach.ratio_of_spec_heat(1.4)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.sepattach.ratio_of_spec_heat({repr(args)})'''
        return self._session.cmd(cmd)

    def select_default(self) -> int:
        """Specify that the default attributes of the separation and attachment line parts are to be set for all subsequent separation and attachment line creates and updates.
        
        Examples:
            ::
        
                ensight.sepattach.select_default()
                ensight.part.modify_begin()
                ensight.sepattach.momentum("none")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.sepattach.select_default()'''
        return self._session.cmd(cmd)

    def threshold(self, p0: Any) -> int:
        """Specify the threshold variable description by which to filter the segments of the selected separation and attachment line parts.
        
        | The default threshold variable for vortex cores is "fx_sep_att_strengh".
        
        Args:
            p0:
                'variable_name' name of the scalar variable by which to filter the vortex core segments
        
        Examples:
            ::
        
                ensight.part.select_begin(5)
                ensight.part.modify_begin()
                ensight.sepattach.threshold("Density")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.sepattach.threshold({repr(p0)})'''
        return self._session.cmd(cmd)

    def threshold_filter(self, p0: str) -> int:
        """Specify how to filter out segments of the specified separation and attachment line part, according to the specified threshold variable and value.
        
        Args:
            p0:
                'option'
        
                * <=
                * >=
        
        Examples:
            ::
        
                ensight.part.select_begin(5)
                ensight.part.modify_begin()
                ensight.sepattach.threshold_filter(">=")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.sepattach.threshold_filter({repr(p0)})'''
        return self._session.cmd(cmd)

    def threshold_max(self, p0: float) -> int:
        """Specify the maximum/minimum threshold limit under which to filter the threshold value of the selected separation and attachment line part(s).
        
        | This max must be greater than the min value, and be a valid threshold variable value.  
        
        Args:
            p0:
                'threshold_value' maximum/minimum threshold variable range limit below which to threshold the separation and attachment lines parts
        
        Examples:
            ::
        
                ensight.part.select_begin(5)
                ensight.part.modify_begin()
                ensight.sepattach.threshold_max(1.0000e+01)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.sepattach.threshold_max({repr(p0)})'''
        return self._session.cmd(cmd)

    def threshold_min(self, p0: float) -> int:
        """Specify the maximum/minimum threshold limit under which to filter the threshold value of the selected separation and attachment line part(s).
        
        | This max must be greater than the min value, and be a valid threshold variable value.  
        
        Args:
            p0:
                'threshold_value' maximum/minimum threshold variable range limit below which to threshold the separation and attachment lines parts
        
        Examples:
            ::
        
                ensight.part.select_begin(5)
                ensight.part.modify_begin()
                ensight.sepattach.threshold_max(1.0000e+01)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.sepattach.threshold_min({repr(p0)})'''
        return self._session.cmd(cmd)

    def threshold_value(self, p0: float) -> int:
        """Specify the threshold value by which to filter the segments from the selected separation and attachment line part(s).
        
        | This value is automatically set to the minimum separation and attachment line strength variable value of the separation and attachment line parts.
        
        Args:
            p0:
                'threshold_value' variable value by which to apply the threshold filter to the vortex core segments
        
        Examples:
            ::
        
                ensight.part.select_begin(5)
                ensight.part.modify_begin()
                ensight.sepattach.threshold_value(5.0000e-01)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.sepattach.threshold_value({repr(p0)})'''
        return self._session.cmd(cmd)

    def velocity(self, p0: Any) -> int:
        """Specify the velocity variable to use in creating/updating the default separation and attachment line part attributes and/or the selected separation and attachment line part(s).
        
        | This variable is assigned automatically if the variable name description <Velocity> exists.  Since the computation of separation and attachment lines depend on velocity, either the velocity variable must be defined or both the density and momentum variables must be defined to obtain the velocity variable.
        
        Args:
            p0:
                'variable_name' name of the velocity variable (the default <none> means to use nothing)
        
        Examples:
            ::
        
                ensight.variables.activate("Velocity")
                ensight.sepattach.select_default()
                ensight.part.modify_begin()
                ensight.sepattach.velocity("Velocity")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.sepattach.velocity({repr(p0)})'''
        return self._session.cmd(cmd)


class scene:
    """Class wrapper for EnSight scene module

    This class acts as a proxy for the EnSight Python module ensight.scene
    """
    def __init__(self, session: Session):
        self._session = session

    def active(self, p0: str) -> int:
        """Scene: active

        """
        cmd = f'''ensight.scene.active({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_visible(self, p0: str) -> int:
        """Scene: axis_visible

        """
        cmd = f'''ensight.scene.axis_visible({repr(p0)})'''
        return self._session.cmd(cmd)

    def environment_map_name(self, args: Any) -> int:
        """Scene: environment_map_name

        """
        cmd = f'''ensight.scene.environment_map_name({repr(args)})'''
        return self._session.cmd(cmd)

    def envmap_savedinfo(self, p0: float, p1: float, p2: float, p3: float, p4: float, p5: float, p6: float, p7: float, p8: float, p9: float, p10: float, p11: float, p12: float, p13: float, p14: float, p15: float, p16: float, p17: float, p18: float, p19: float, p20: float, p21: float, p22: float, p23: float, p24: float, p25: float, p26: float, p27: float, p28: float, p29: float, p30: float, p31: float, p32: float, p33: float, p34: float, p35: float, p36: float, p37: float, p38: float, p39: float, p40: float, p41: float, p42: float, p43: float, p44: float, p45: float, p46: float, p47: float, p48: float, p49: float, p50: float, p51: float, p52: float, p53: float, p54: float, p55: float, p56: float, p57: float, p58: float, p59: float, p60: float, p61: float, p62: float, p63: float) -> int:
        """Scene: envmap_savedinfo

        """
        cmd = f'''ensight.scene.envmap_savedinfo({repr(p0)},{repr(p1)},{repr(p2)},{repr(p3)},{repr(p4)},{repr(p5)},{repr(p6)},{repr(p7)},{repr(p8)},{repr(p9)},{repr(p10)},{repr(p11)},{repr(p12)},{repr(p13)},{repr(p14)},{repr(p15)},{repr(p16)},{repr(p17)},{repr(p18)},{repr(p19)},{repr(p20)},{repr(p21)},{repr(p22)},{repr(p23)},{repr(p24)},{repr(p25)},{repr(p26)},{repr(p27)},{repr(p28)},{repr(p29)},{repr(p30)},{repr(p31)},{repr(p32)},{repr(p33)},{repr(p34)},{repr(p35)},{repr(p36)},{repr(p37)},{repr(p38)},{repr(p39)},{repr(p40)},{repr(p41)},{repr(p42)},{repr(p43)},{repr(p44)},{repr(p45)},{repr(p46)},{repr(p47)},{repr(p48)},{repr(p49)},{repr(p50)},{repr(p51)},{repr(p52)},{repr(p53)},{repr(p54)},{repr(p55)},{repr(p56)},{repr(p57)},{repr(p58)},{repr(p59)},{repr(p60)},{repr(p61)},{repr(p62)},{repr(p63)})'''
        return self._session.cmd(cmd)

    def ground_plane_color(self, p0: float, p1: float, p2: float) -> int:
        """Scene: ground_plane_color

        """
        cmd = f'''ensight.scene.ground_plane_color({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def ground_plane_color1(self, p0: float, p1: float, p2: float) -> int:
        """Scene: ground_plane_color1

        """
        cmd = f'''ensight.scene.ground_plane_color1({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def ground_plane_color2(self, p0: float, p1: float, p2: float) -> int:
        """Scene: ground_plane_color2

        """
        cmd = f'''ensight.scene.ground_plane_color2({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def ground_plane_grid(self, p0: str) -> int:
        """Scene: ground_plane_grid

        """
        cmd = f'''ensight.scene.ground_plane_grid({repr(p0)})'''
        return self._session.cmd(cmd)

    def ground_plane_gridcolora(self, p0: float, p1: float, p2: float) -> int:
        """Scene: ground_plane_gridcolora

        """
        cmd = f'''ensight.scene.ground_plane_gridcolora({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def ground_plane_gridcolora1(self, p0: float, p1: float, p2: float) -> int:
        """Scene: ground_plane_gridcolora1

        """
        cmd = f'''ensight.scene.ground_plane_gridcolora1({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def ground_plane_gridcolora2(self, p0: float, p1: float, p2: float) -> int:
        """Scene: ground_plane_gridcolora2

        """
        cmd = f'''ensight.scene.ground_plane_gridcolora2({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def ground_plane_gridcolorb(self, p0: float, p1: float, p2: float) -> int:
        """Scene: ground_plane_gridcolorb

        """
        cmd = f'''ensight.scene.ground_plane_gridcolorb({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def ground_plane_gridcolorb1(self, p0: float, p1: float, p2: float) -> int:
        """Scene: ground_plane_gridcolorb1

        """
        cmd = f'''ensight.scene.ground_plane_gridcolorb1({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def ground_plane_gridcolorb2(self, p0: float, p1: float, p2: float) -> int:
        """Scene: ground_plane_gridcolorb2

        """
        cmd = f'''ensight.scene.ground_plane_gridcolorb2({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def ground_plane_gridsize(self, p0: float) -> int:
        """Scene: ground_plane_gridsize

        """
        cmd = f'''ensight.scene.ground_plane_gridsize({repr(p0)})'''
        return self._session.cmd(cmd)

    def ground_plane_heightoffset(self, p0: float) -> int:
        """Scene: ground_plane_heightoffset

        """
        cmd = f'''ensight.scene.ground_plane_heightoffset({repr(p0)})'''
        return self._session.cmd(cmd)

    def ground_plane_lockplane(self, p0: str) -> int:
        """Scene: ground_plane_lockplane

        """
        cmd = f'''ensight.scene.ground_plane_lockplane({repr(p0)})'''
        return self._session.cmd(cmd)

    def ground_plane_normal(self, args: Any) -> int:
        """Scene: ground_plane_normal

        """
        cmd = f'''ensight.scene.ground_plane_normal({repr(args)})'''
        return self._session.cmd(cmd)

    def ground_plane_radius(self, p0: float) -> int:
        """Scene: ground_plane_radius

        """
        cmd = f'''ensight.scene.ground_plane_radius({repr(p0)})'''
        return self._session.cmd(cmd)

    def ground_plane_reflection(self, p0: str) -> int:
        """Scene: ground_plane_reflection

        """
        cmd = f'''ensight.scene.ground_plane_reflection({repr(p0)})'''
        return self._session.cmd(cmd)

    def ground_plane_savedinfo(self, p0: float, p1: float, p2: float, p3: float, p4: float, p5: float, p6: float, p7: float, p8: float, p9: float, p10: float, p11: float, p12: float, p13: float, p14: float, p15: float, p16: float, p17: float, p18: float, p19: float, p20: float, p21: float, p22: float, p23: float, p24: float, p25: float, p26: float, p27: float, p28: float, p29: float, p30: float, p31: float, p32: float, p33: float, p34: float, p35: float, p36: float, p37: float, p38: float, p39: float, p40: float, p41: float, p42: float, p43: float, p44: float, p45: float, p46: float, p47: float, p48: float, p49: float, p50: float, p51: float, p52: float, p53: float, p54: float, p55: float, p56: float, p57: float, p58: float, p59: float, p60: float, p61: float, p62: float, p63: float, p64: float, p65: float, p66: float, p67: float, p68: float, p69: float, p70: float, p71: float, p72: float, p73: float, p74: float, p75: float, p76: float, p77: float, p78: float, p79: float, p80: float, p81: float, p82: float, p83: float, p84: float, p85: float, p86: float, p87: float, p88: float, p89: float, p90: float, p91: float, p92: float, p93: float, p94: float, p95: float, p96: float, p97: float, p98: float, p99: float, p100: float, p101: float, p102: float, p103: float, p104: float, p105: float, p106: float, p107: float, p108: float, p109: float, p110: float, p111: float, p112: float, p113: float, p114: float, p115: float, p116: float, p117: float, p118: float, p119: float, p120: float, p121: float, p122: float, p123: float, p124: float, p125: float, p126: float, p127: float, p128: float, p129: float, p130: float, p131: float, p132: float, p133: float, p134: float, p135: float, p136: float, p137: float, p138: float, p139: float, p140: float, p141: float, p142: float, p143: float, p144: float, p145: float, p146: float, p147: float, p148: float, p149: float, p150: float, p151: float, p152: float, p153: float, p154: float, p155: float, p156: float, p157: float, p158: float, p159: float) -> int:
        """Scene: ground_plane_savedinfo

        """
        cmd = f'''ensight.scene.ground_plane_savedinfo({repr(p0)},{repr(p1)},{repr(p2)},{repr(p3)},{repr(p4)},{repr(p5)},{repr(p6)},{repr(p7)},{repr(p8)},{repr(p9)},{repr(p10)},{repr(p11)},{repr(p12)},{repr(p13)},{repr(p14)},{repr(p15)},{repr(p16)},{repr(p17)},{repr(p18)},{repr(p19)},{repr(p20)},{repr(p21)},{repr(p22)},{repr(p23)},{repr(p24)},{repr(p25)},{repr(p26)},{repr(p27)},{repr(p28)},{repr(p29)},{repr(p30)},{repr(p31)},{repr(p32)},{repr(p33)},{repr(p34)},{repr(p35)},{repr(p36)},{repr(p37)},{repr(p38)},{repr(p39)},{repr(p40)},{repr(p41)},{repr(p42)},{repr(p43)},{repr(p44)},{repr(p45)},{repr(p46)},{repr(p47)},{repr(p48)},{repr(p49)},{repr(p50)},{repr(p51)},{repr(p52)},{repr(p53)},{repr(p54)},{repr(p55)},{repr(p56)},{repr(p57)},{repr(p58)},{repr(p59)},{repr(p60)},{repr(p61)},{repr(p62)},{repr(p63)},{repr(p64)},{repr(p65)},{repr(p66)},{repr(p67)},{repr(p68)},{repr(p69)},{repr(p70)},{repr(p71)},{repr(p72)},{repr(p73)},{repr(p74)},{repr(p75)},{repr(p76)},{repr(p77)},{repr(p78)},{repr(p79)},{repr(p80)},{repr(p81)},{repr(p82)},{repr(p83)},{repr(p84)},{repr(p85)},{repr(p86)},{repr(p87)},{repr(p88)},{repr(p89)},{repr(p90)},{repr(p91)},{repr(p92)},{repr(p93)},{repr(p94)},{repr(p95)},{repr(p96)},{repr(p97)},{repr(p98)},{repr(p99)},{repr(p100)},{repr(p101)},{repr(p102)},{repr(p103)},{repr(p104)},{repr(p105)},{repr(p106)},{repr(p107)},{repr(p108)},{repr(p109)},{repr(p110)},{repr(p111)},{repr(p112)},{repr(p113)},{repr(p114)},{repr(p115)},{repr(p116)},{repr(p117)},{repr(p118)},{repr(p119)},{repr(p120)},{repr(p121)},{repr(p122)},{repr(p123)},{repr(p124)},{repr(p125)},{repr(p126)},{repr(p127)},{repr(p128)},{repr(p129)},{repr(p130)},{repr(p131)},{repr(p132)},{repr(p133)},{repr(p134)},{repr(p135)},{repr(p136)},{repr(p137)},{repr(p138)},{repr(p139)},{repr(p140)},{repr(p141)},{repr(p142)},{repr(p143)},{repr(p144)},{repr(p145)},{repr(p146)},{repr(p147)},{repr(p148)},{repr(p149)},{repr(p150)},{repr(p151)},{repr(p152)},{repr(p153)},{repr(p154)},{repr(p155)},{repr(p156)},{repr(p157)},{repr(p158)},{repr(p159)})'''
        return self._session.cmd(cmd)

    def ground_plane_shadow(self, p0: str) -> int:
        """Scene: ground_plane_shadow

        """
        cmd = f'''ensight.scene.ground_plane_shadow({repr(p0)})'''
        return self._session.cmd(cmd)

    def ground_plane_texscale(self, p0: float) -> int:
        """Scene: ground_plane_texscale

        """
        cmd = f'''ensight.scene.ground_plane_texscale({repr(p0)})'''
        return self._session.cmd(cmd)

    def ground_plane_texture(self, p0: str) -> int:
        """Scene: ground_plane_texture

        """
        cmd = f'''ensight.scene.ground_plane_texture({repr(p0)})'''
        return self._session.cmd(cmd)

    def ground_plane_visible(self, p0: str) -> int:
        """Scene: ground_plane_visible

        """
        cmd = f'''ensight.scene.ground_plane_visible({repr(p0)})'''
        return self._session.cmd(cmd)

    def modify_begin(self) -> int:
        """Scene: modify_begin

        """
        cmd = f'''ensight.scene.modify_begin()'''
        return self._session.cmd(cmd)

    def modify_end(self) -> int:
        """Scene: modify_end

        """
        cmd = f'''ensight.scene.modify_end()'''
        return self._session.cmd(cmd)

    def origin(self, p0: float, p1: float, p2: float) -> int:
        """Scene: origin

        """
        cmd = f'''ensight.scene.origin({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def radius(self, p0: float) -> int:
        """Scene: radius

        """
        cmd = f'''ensight.scene.radius({repr(p0)})'''
        return self._session.cmd(cmd)

    def scale(self, p0: float) -> int:
        """Scene: scale

        """
        cmd = f'''ensight.scene.scale({repr(p0)})'''
        return self._session.cmd(cmd)

    def shadow(self, p0: str) -> int:
        """Scene: shadow

        """
        cmd = f'''ensight.scene.shadow({repr(p0)})'''
        return self._session.cmd(cmd)


class savegeom:
    """Class wrapper for EnSight savegeom module

    This class acts as a proxy for the EnSight Python module ensight.savegeom
    """
    def __init__(self, session: Session):
        self._session = session

    def begin_step(self, p0: int) -> int:
        """Specify the beginning/ending time step for exporting the selected part(s) and active variable(s).
        
        Args:
            p0:
                'step' the beginning/ending time step in the range I[0,n], where n is the last time step
        
        Examples:
            ::
        
                ensight.part.select_all()
                ensight.savegeom.format("case")
                ensight.savegeom.binary("ON")
                ensight.savegeom.single_file("OFF")
                ensight.savegeom.begin_step(0)
                ensight.savegeom.end_step(16)
                ensight.savegeom.step_by(1)
                ensight.savegeom.save_geometric_entities("/tmp/file_prefix")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.savegeom.begin_step({repr(p0)})'''
        return self._session.cmd(cmd)

    def binary(self, p0: str) -> int:
        """Specify either binary or ASCII as the format for the exported files.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.part.select_all()
                ensight.savegeom.format("case")
                ensight.savegeom.binary("ON")
                ensight.savegeom.single_file("OFF")
                ensight.savegeom.select_all_steps()
                ensight.savegeom.save_geometric_entities("/tmp/file_prefix")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.savegeom.binary({repr(p0)})'''
        return self._session.cmd(cmd)

    def brick_format(self, p0: str) -> int:
        """Specify the format of the values to write out when using brick format.
        
        | Used in conjunction with savegeom: format brick
        
        Args:
            p0:
                'option'
        
                * bytes
                * floats
        
        Examples:
            ::
        
                ensight.part.select_all()
                ensight.savegeom.format("brick")
                ensight.savegeom.brick_format("floats")
                ensight.savegeom.resolution(128,128,128)
                ensight.savegeom.undefined(-1.2345e-10)
                ensight.savegeom.variable("pressure")
                ensight.savegeom.save_geometric_entities("/tmp/file_prefix")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.savegeom.brick_format({repr(p0)})'''
        return self._session.cmd(cmd)

    def compression_quality(self, p0: str) -> int:
        """Savegeom: compression_quality

        """
        cmd = f'''ensight.savegeom.compression_quality({repr(p0)})'''
        return self._session.cmd(cmd)

    def end_step(self, p0: int) -> int:
        """Specify the beginning/ending time step for exporting the selected part(s) and active variable(s).
        
        Args:
            p0:
                'step' the beginning/ending time step in the range I[0,n], where n is the last time step
        
        Examples:
            ::
        
                ensight.part.select_all()
                ensight.savegeom.format("case")
                ensight.savegeom.binary("ON")
                ensight.savegeom.single_file("OFF")
                ensight.savegeom.begin_step(0)
                ensight.savegeom.end_step(16)
                ensight.savegeom.step_by(1)
                ensight.savegeom.save_geometric_entities("/tmp/file_prefix")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.savegeom.end_step({repr(p0)})'''
        return self._session.cmd(cmd)

    def format(self, p0: str) -> int:
        """Specify the export data file format for the selected part(s) and active variable(s).
        
        | The option is the format of an included internal format usch as case or vrml, or a user-defined format that can be site specific.
        
        Args:
            p0:
                'option'
        
                * Include one of the following:
                * brick
                * case
                * vrml
                * UDWName
        
        Examples:
            ::
        
                ensight.part.select_all()
                ensight.savegeom.format("case")
                ensight.savegeom.binary("ON")
                ensight.savegeom.single_file("OFF")
                ensight.savegeom.select_all_steps()
                ensight.savegeom.save_geometric_entities("/tmp/file_prefix")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.savegeom.format({repr(p0)})'''
        return self._session.cmd(cmd)

    def maximum_file_size(self, p0: float) -> int:
        """Specify the maximum file size (in MBs) for exporting time step data into single file format.
        
        | This default value is the maximum file size limit of either 2 Giga-Bytes for 32-bit architecture, or 4 Tera-Bytes for 64-bit architecture machines.
        
        Args:
            p0:
                'size' file size limit in MB (Mega-Bytes)
        
        Examples:
            ::
        
                ensight.part.select_all()
                ensight.savegeom.format("case")
                ensight.savegeom.binary("ON")
                ensight.savegeom.single_file("ON")
                ensight.savegeom.maximum_file_size(2147.479980)
                ensight.savegeom.select_all_steps()
                ensight.savegeom.save_geometric_entities("/tmp/file_prefix")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.savegeom.maximum_file_size({repr(p0)})'''
        return self._session.cmd(cmd)

    def parameters(self, p0: str) -> int:
        """Pass into the User-defined writer a string that can be used to modify the behavior, or supply additional parameters.
        
        | This can be used to provide parameters to a user-defined writer.
        
        Args:
            p0:
                'input_string' up to 200 characters of information that will be passed into the user-defined writer selected.
        
        Examples:
            ::
        
                ensight.part.select_all()
                ensight.savegeom.format("STL")
                ensight.savegeom.parameters("test string")
                ensight.savegeom.save_geometric_entities("/tmp/file_prefix")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.savegeom.parameters({repr(p0)})'''
        return self._session.cmd(cmd)

    def quadrics_quality(self, p0: str) -> int:
        """Savegeom: quadrics_quality

        """
        cmd = f'''ensight.savegeom.quadrics_quality({repr(p0)})'''
        return self._session.cmd(cmd)

    def resolution(self, p0: int, p1: int, p2: int) -> int:
        """Specify the Brick of Values resolution in the x, y, and z directions.
        
        | Used in conjunction with savegeom: format brick
        
        Args:
            p0:
                'x' x, y, z direction resolution
            p1:
                'y' x, y, z direction resolution
            p2:
                'z' x, y, z direction resolution
        
        Examples:
            ::
        
                ensight.part.select_all()
                ensight.savegeom.format("brick")
                ensight.savegeom.brick_format("floats")
                ensight.savegeom.resolution(128,128,128)
                ensight.savegeom.undefined(-1.2345e-10)
                ensight.savegeom.variable("pressure")
                ensight.savegeom.save_geometric_entities("/tmp/file_prefix")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.savegeom.resolution({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def save_geometric_entities(self, p0: str) -> int:
        """Specify the file name path and prefix for the selected part and active variable data to be exported.
        
        | The exported files will be saved in the current working directory of the server if no path is provided.
        | If the format (as defined by savegeom: format) is VRML, the filename given will be used directly.  If the format is CASE, the multiple files (case, geometry, and variables) are written using the supplied name as the prefix.
        
        Args:
            p0:
                'filename_prefix' directory path and filename prefix to be used for the exported data file
        
        Examples:
            ::
        
                ensight.part.select_all()
                ensight.savegeom.format("case")
                ensight.savegeom.binary("ON")
                ensight.savegeom.single_file("OFF")
                ensight.savegeom.select_all_steps()
                ensight.savegeom.save_geometric_entities("/tmp/file_prefix")
        
            ::
        
                ensight.part.select_begin(1)
                ensight.savegeom.format("case")
                ensight.savegeom.binary("ON")
                ensight.savegeom.single_file("OFF")
                ensight.savegeom.select_all_steps()
                ensight.savegeom.save_geometric_entities("/tmp/file_prefix")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.savegeom.save_geometric_entities({repr(p0)})'''
        return self._session.cmd(cmd)

    def select_all_steps(self) -> int:
        """Specify all time step data of selected parts (geometry) and active variables to be exported to an EnSight case or VRML file(s).
        
        Examples:
            ::
        
                ensight.part.select_all()
                ensight.savegeom.format("case")
                ensight.savegeom.binary("ON")
                ensight.savegeom.single_file("OFF")
                ensight.savegeom.select_all_steps()
                ensight.savegeom.save_geometric_entities("/tmp/file_prefix")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.savegeom.select_all_steps()'''
        return self._session.cmd(cmd)

    def select_all_timesteps(self) -> int:
        """Savegeom: select_all_timesteps

        """
        cmd = f'''ensight.savegeom.select_all_timesteps()'''
        return self._session.cmd(cmd)

    def select_begin(self, *args, **kwargs) -> Any:
        """Savegeom: select_begin

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.savegeom.select_begin({arg_string})"
        return self._session.cmd(cmd)

    def single_file(self, p0: str) -> int:
        """Specify whether the selected part(s), or geometry, and each active variable will be exported to a single or to separate time step files.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.part.select_all()
                ensight.savegeom.format("case")
                ensight.savegeom.binary("ON")
                ensight.savegeom.single_file("ON")
                ensight.savegeom.maximum_file_size(2147.479980)
                ensight.savegeom.select_all_steps()
                ensight.savegeom.save_geometric_entities("/tmp/file_prefix")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.savegeom.single_file({repr(p0)})'''
        return self._session.cmd(cmd)

    def step_by(self, p0: int) -> int:
        """Specify the increment step by which to stride the time steps in exporting the selected part(s) and active variable(s).
        
        Args:
            p0:
                'increment' increment to stride the time steps in the range of the beginning and ending time steps
        
        Examples:
            ::
        
                ensight.part.select_all()
                ensight.savegeom.format("case")
                ensight.savegeom.binary("ON")
                ensight.savegeom.single_file("OFF")
                ensight.savegeom.begin_step(0)
                ensight.savegeom.end_step(16)
                ensight.savegeom.step_by(1)
                ensight.savegeom.save_geometric_entities("/tmp/file_prefix")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.savegeom.step_by({repr(p0)})'''
        return self._session.cmd(cmd)

    def undefined(self, p0: float) -> int:
        """Specify the value to write out as undefined when using brick format.
        
        | Used in conjunction with savegeom: format brick
        
        Args:
            p0:
                'undef_value' any undefined value is written out as this value
        
        Examples:
            ::
        
                ensight.part.select_all()
                ensight.savegeom.format("brick")
                ensight.savegeom.brick_format("floats")
                ensight.savegeom.resolution(128,128,128)
                ensight.savegeom.undefined(-1.2345e-10)
                ensight.savegeom.variable("pressure")
                ensight.savegeom.save_geometric_entities("/tmp/file_prefix")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.savegeom.undefined({repr(p0)})'''
        return self._session.cmd(cmd)

    def variable(self, p0: str) -> int:
        """Specify the name of the variable to save when using brick format.
        
        | Used in conjunction with savegeom: format brick
        
        Args:
            p0:
                'var_name' variable name
        
        Examples:
            ::
        
                ensight.part.select_all()
                ensight.savegeom.format("brick")
                ensight.savegeom.brick_format("floats")
                ensight.savegeom.resolution(128,128,128)
                ensight.savegeom.undefined(-1.2345e-10)
                ensight.savegeom.variable("pressure")
                ensight.savegeom.save_geometric_entities("/tmp/file_prefix")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.savegeom.variable({repr(p0)})'''
        return self._session.cmd(cmd)


class query_interact:
    """Class wrapper for EnSight query_interact module

    This class acts as a proxy for the EnSight Python module ensight.query_interact
    """
    def __init__(self, session: Session):
        self._session = session

    def action(self, p0: str) -> int:
        """Query_interact: action

        """
        cmd = f'''ensight.query_interact.action({repr(p0)})'''
        return self._session.cmd(cmd)

    def coord_report_by_x(self, p0: str) -> int:
        """Query_interact: coord_report_by_x

        """
        cmd = f'''ensight.query_interact.coord_report_by_x({repr(p0)})'''
        return self._session.cmd(cmd)

    def coord_report_by_y(self, p0: str) -> int:
        """Query_interact: coord_report_by_y

        """
        cmd = f'''ensight.query_interact.coord_report_by_y({repr(p0)})'''
        return self._session.cmd(cmd)

    def coord_report_by_z(self, p0: str) -> int:
        """Query_interact: coord_report_by_z

        """
        cmd = f'''ensight.query_interact.coord_report_by_z({repr(p0)})'''
        return self._session.cmd(cmd)

    def create(self, args: Any) -> int:
        """Creates a query using the current settings.
        
        | The parameters vary based on the type of query being used.  (See query_interact: query)
        | Query is performed at location specified or at closest node if query_interact: search closest_node is specified.
        
        Args:
            p0:
                '' 
            p1:
                'screen_x' xy normalized screen coordinates (0.0 to 1.0)
            p2:
                'screen_y' xy normalized screen coordinates (0.0 to 1.0)
            p3:
                'screen_y' xy normalized screen coordinates (0.0 to 1.0)
            p4:
                'screen_y' xy normalized screen coordinates (0.0 to 1.0)
            p5:
                'x_coord' xyz model coordinates
            p6:
                'y_coord' xyz model coordinates
            p7:
                'z_coord' xyz model coordinates
            p8:
                'z_coord' xyz model coordinates
            p9:
                'z_coord' xyz model coordinates
            p10:
                'node_id' node id for query
            p11:
                'node_id' node id for query
            p12:
                'node_id' node id for query
            p13:
                'i_coord' ijk coordinates for query
            p14:
                'j_coord' ijk coordinates for query
            p15:
                'k_coord' ijk coordinates for query
            p16:
                'k_coord' ijk coordinates for query
            p17:
                'k_coord' ijk coordinates for query
            p18:
                'element_id' element id for query
            p19:
                'element_id' element id for query
            p20:
                'element_id' element id for query
            p21:
                'x_coord' xyz model coordinates
            p22:
                'y_coord' xyz model coordinates
            p23:
                'z_coord' xyz model coordinates
        
        Examples:
            ::
        
                #WARNING: the following line failed to translate because the function could not be found in the ensight python module
                #   Actual error: module 'ensight' has no attribute 'variable'
                ensight.sendmesg(r"variable: activate pressure")
                ensight.query_interact.select_varname_begin("pressure")
                ensight.query_interact.query("xyz")
                ensight.query_interact.create(12.0,15.1,10.3)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.query_interact.create({repr(args)})'''
        return self._session.cmd(cmd)

    def display_expansion_factor(self, p0: int) -> int:
        """This command has not yet been documented. 
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.query_interact.display_expansion_factor({repr(p0)})'''
        return self._session.cmd(cmd)

    def display_id(self, p0: str) -> int:
        """Causes the node located for the query to be reported. 
        
        | This command is used with query_interact: search closest_node to get reporting of the actual node that was used for the query.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                #WARNING: the following line failed to translate because the function could not be found in the ensight python module
                #   Actual error: module 'ensight' has no attribute 'variable'
                ensight.sendmesg(r"variable: activate pressure")
                ensight.query_interact.select_varname_begin("pressure")
                ensight.query_interact.query("cursor")
                ensight.query_interact.search("closest_node")
                ensight.query_interact.display_id("ON")
                ensight.query_interact.create(12.0,15.1,10.3)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.query_interact.display_id({repr(p0)})'''
        return self._session.cmd(cmd)

    def display_node_number(self, p0: str) -> int:
        """Query_interact: display_node_number

        """
        cmd = f'''ensight.query_interact.display_node_number({repr(p0)})'''
        return self._session.cmd(cmd)

    def label_always_on_top(self, p0: str) -> int:
        """Causes the label written beside the query marker in the graphics window to be rendered on top of any surface that would normally hide or obscure it.
        
        | This attribute is ON by default. 
        
        Args:
            p0:
                'toggle'
        
                * ON 
                * OFF
        
        Examples:
            ::
        
                #WARNING: the following line failed to translate because the function could not be found in the ensight python module
                #   Actual error: module 'ensight' has no attribute 'variable'
                ensight.sendmesg(r"variable: activate pressure")
                ensight.query_interact.select_varname_begin("pressure")
                ensight.query_interact.query("cursor")
                ensight.query_interact.label_always_on_top("ON")
                ensight.query_interact.create(12.0,15.1,10.3)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.query_interact.label_always_on_top({repr(p0)})'''
        return self._session.cmd(cmd)

    def label_decimal_places(self, p0: int) -> int:
        """Query_interact: label_decimal_places

        """
        cmd = f'''ensight.query_interact.label_decimal_places({repr(p0)})'''
        return self._session.cmd(cmd)

    def label_format(self, p0: str) -> int:
        """Query_interact: label_format

        """
        cmd = f'''ensight.query_interact.label_format({repr(p0)})'''
        return self._session.cmd(cmd)

    def label_rgb(self, p0: float, p1: float, p2: float) -> int:
        """Specifies the RGB color value of the label written next to the query marker in the graphics window.    
        
        Args:
            p0:
                'red_val' red, green, blue contributions of the color within range of  0.0 to 1.0
            p1:
                'grn_val' red, green, blue contributions of the color within range of  0.0 to 1.0
            p2:
                'blu_val' red, green, blue contributions of the color within range of  0.0 to 1.0
        
        Examples:
            ::
        
                #WARNING: the following line failed to translate because the function could not be found in the ensight python module
                #   Actual error: module 'ensight' has no attribute 'variable'
                ensight.sendmesg(r"variable: activate pressure")
                ensight.query_interact.select_varname_begin("pressure")
                ensight.query_interact.query("cursor")
                ensight.query_interact.label_rgb(0,1,1)
                ensight.query_interact.create(12.0,15.1,10.3)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.query_interact.label_rgb({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def label_visible(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.query_interact.label_visible({repr(p0)})'''
        return self._session.cmd(cmd)

    def marker_rgb(self, p0: float, p1: float, p2: float) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.query_interact.marker_rgb({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def marker_size(self, p0: float) -> int:
        """Query_interact: marker_size

        """
        cmd = f'''ensight.query_interact.marker_size({repr(p0)})'''
        return self._session.cmd(cmd)

    def marker_size_normalized(self, p0: float) -> int:
        """Specify the size of a query marker.
        
        | The default marker scale value is 1.0.
        | A size of 1.0 indicates to use the computed size
        | Values >1 scale the computed size larger while values <1 (but >0) shrink the marker.
        
        Args:
            p0:
                'scale' size of marker
        
        Examples:
            ::
        
                #WARNING: the following line failed to translate because the function could not be found in the ensight python module
                #   Actual error: module 'ensight' has no attribute 'variable'
                ensight.sendmesg(r"variable: activate pressure")
                # WARNING: following line includes OBSOLETE call (ensight.query_interact.variable).
                ensight.query_interact.variable("pressure")
                ensight.query_interact.query("cursor")
                ensight.query_interact.label_visible("OFF")
                ensight.query_interact.marker_size_normalized(0.5)
                ensight.query_interact.create(12.0,15.1,10.3)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.query_interact.marker_size_normalized({repr(p0)})'''
        return self._session.cmd(cmd)

    def marker_visible(self, p0: str) -> int:
        """Sets the visibility of the query marker in the graphics window.
        
        | Marker visibility is ON by default.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                #WARNING: the following line failed to translate because the function could not be found in the ensight python module
                #   Actual error: module 'ensight' has no attribute 'variable'
                ensight.sendmesg(r"variable: activate pressure")
                ensight.query_interact.select_varname_begin("pressure")
                ensight.query_interact.query("cursor")
                ensight.query_interact.label_visible("OFF")
                ensight.query_interact.marker_visible("OFF")
                ensight.query_interact.create(12.0,15.1,10.3)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.query_interact.marker_visible({repr(p0)})'''
        return self._session.cmd(cmd)

    def number_displayed(self, p0: int) -> int:
        """Query_interact: #_displayed

        """
        cmd = f'''ensight.query_interact.number_displayed({repr(p0)})'''
        return self._session.cmd(cmd)

    def output(self, args: Any) -> int:
        """Query_interact: output

        """
        cmd = f'''ensight.query_interact.output({repr(args)})'''
        return self._session.cmd(cmd)

    def query(self, p0: str) -> int:
        """Sets the type of query to be performed.
        
        | The exact location of the query, as specified above, may be modified by the query_interact: search command; i.e. if an exact set of coordinates or a cursor position is specified, the actual query may be done at the closest node to this point if query_interact: search closest_node has been specified. 
        
        Args:
            p0:
                'query_type'
        
                * may be any of the following values:
                * surface
                * cursor
                * node
                * ijk
                * element
                * xyz
                * none
                * min
                * max
        
        Examples:
            ::
        
                #WARNING: the following line failed to translate because the function could not be found in the ensight python module
                #   Actual error: module 'ensight' has no attribute 'variable'
                ensight.sendmesg(r"variable: activate pressure")
                ensight.query_interact.select_varname_begin("pressure")
                ensight.query_interact.query("cursor")
                ensight.query_interact.search("closest_node")
                ensight.query_interact.create(12.0,15.1,10.3)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.query_interact.query({repr(p0)})'''
        return self._session.cmd(cmd)

    def query_attributes(self, args: Any) -> int:
        """Query_interact: query_attributes

        """
        cmd = f'''ensight.query_interact.query_attributes({repr(args)})'''
        return self._session.cmd(cmd)

    def query_count(self, args: Any) -> int:
        """Query_interact: query_count

        """
        cmd = f'''ensight.query_interact.query_count({repr(args)})'''
        return self._session.cmd(cmd)

    def request_method(self, p0: str) -> int:
        """Sets the request method for surface pick or cursor-based queries to be on a request or continuous basis.
        
        | In continuous mode, the query will be updated continuously while the mouse or cursor is being moved.
        
        Args:
            p0:
                'method'
        
                * may be any of the following values: 
                * continuous
                * pick
        
        Examples:
            ::
        
                #WARNING: the following line failed to translate because the function could not be found in the ensight python module
                #   Actual error: module 'ensight' has no attribute 'variable'
                ensight.sendmesg(r"variable: activate pressure")
                ensight.query_interact.select_varname_begin("pressure")
                ensight.query_interact.query("cursor")
                ensight.query_interact.request_method("pick")
                ensight.query_interact.create(12.0,15.1,10.3)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.query_interact.request_method({repr(p0)})'''
        return self._session.cmd(cmd)

    def request_mode(self, p0: str) -> int:
        """Query_interact: request_mode

        """
        cmd = f'''ensight.query_interact.request_mode({repr(p0)})'''
        return self._session.cmd(cmd)

    def save(self, p0: str) -> int:
        """Specifies the filename into which the Interactive Probe Query Results Table will be saved.
        
        Args:
            p0:
                'filename' filename to receive the results table information
        
        Examples:
            ::
        
                #WARNING: the following line failed to translate because the function could not be found in the ensight python module
                #   Actual error: module 'ensight' has no attribute 'variable'
                ensight.sendmesg(r"variable: activate pressure")
                ensight.query_interact.select_varname_begin("pressure")
                ensight.query_interact.query("xyz")
                ensight.query_interact.number_displayed(3)
                ensight.query_interact.create(12.0,15.1,10.3)
                ensight.query_interact.create(11.0,15.0,10.1)
                ensight.query_interact.create(10.0,15.0,10.3)
                ensight.query_interact.save("/home/users/me/probe.txt")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.query_interact.save({repr(p0)})'''
        return self._session.cmd(cmd)

    def search(self, p0: str) -> int:
        """Sets the search mode for surface pick or cursor queries.
        
        Args:
            p0:
                'search_mode'
        
                * may be any of the following values:
                * exact
                * closest_node
        
        Examples:
            ::
        
                #WARNING: the following line failed to translate because the function could not be found in the ensight python module
                #   Actual error: module 'ensight' has no attribute 'variable'
                ensight.sendmesg(r"variable: activate pressure")
                ensight.query_interact.select_varname_begin("pressure")
                ensight.query_interact.query("cursor")
                ensight.query_interact.search("closest_node")
                ensight.query_interact.create(12.0,15.1,10.3)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.query_interact.search({repr(p0)})'''
        return self._session.cmd(cmd)

    def select_all(self) -> int:
        """Query_interact: select_all

        """
        cmd = f'''ensight.query_interact.select_all()'''
        return self._session.cmd(cmd)

    def select_begin(self, *args, **kwargs) -> Any:
        """Query_interact: select_begin

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.query_interact.select_begin({arg_string})"
        return self._session.cmd(cmd)

    def select_default(self) -> int:
        """Causes any following query_interact: commands to affect the default query settings.    
        
        | All query_interact: commands following query_interact: select_default will affect default settings until a new variable is selected to query using
        | query_interact: select_varname_begin.
        
        Examples:
            ::
        
                ensight.query_interact.select_default()
                ensight.query_interact.marker_visible("OFF")
                ensight.query_interact.marker_rgb(1,0,0)
                ensight.query_interact.select_varname_begin("pressure")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.query_interact.select_default()'''
        return self._session.cmd(cmd)

    def select_varname_begin(self, args: Any) -> int:
        """Specifies the variables to be queried.
        
        Args:
            p0:
                'varnameN' names of variables to be queried
        
        Examples:
            ::
        
                #WARNING: the following line failed to translate because the function could not be found in the ensight python module
                #   Actual error: module 'ensight' has no attribute 'variable'
                ensight.sendmesg(r"variable: activate pressure")
                #WARNING: the following line failed to translate because the function could not be found in the ensight python module
                #   Actual error: module 'ensight' has no attribute 'variable'
                ensight.sendmesg(r"variable: activate temperature")
                ensight.query_interact.select_varname_begin("pressure","temperature ")
                ensight.query_interact.query("cursor")
                ensight.query_interact.create(12.0,15.1,10.3)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.query_interact.select_varname_begin({repr(args)})'''
        return self._session.cmd(cmd)

    def select_varname_default(self) -> int:
        """Query_interact: select_varname_default

        """
        cmd = f'''ensight.query_interact.select_varname_default()'''
        return self._session.cmd(cmd)

    def select_varname_end(self) -> int:
        """Query_interact: select_varname_end

        """
        cmd = f'''ensight.query_interact.select_varname_end()'''
        return self._session.cmd(cmd)

    def type(self, args: Any) -> int:
        """Query_interact: type

        """
        cmd = f'''ensight.query_interact.type({repr(args)})'''
        return self._session.cmd(cmd)

    def update_probe(self, p0: float, p1: float, p2: float) -> int:
        """Query_interact: update_probe

        """
        cmd = f'''ensight.query_interact.update_probe({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def variable(self, p0: Any) -> int:
        """Query_interact: variable

        """
        cmd = f'''ensight.query_interact.variable({repr(p0)})'''
        return self._session.cmd(cmd)

    def vector_report_by_mag(self, p0: str) -> int:
        """Query_interact: vector_report_by_mag

        """
        cmd = f'''ensight.query_interact.vector_report_by_mag({repr(p0)})'''
        return self._session.cmd(cmd)

    def vector_report_by_x(self, p0: str) -> int:
        """Query_interact: vector_report_by_x

        """
        cmd = f'''ensight.query_interact.vector_report_by_x({repr(p0)})'''
        return self._session.cmd(cmd)

    def vector_report_by_y(self, p0: str) -> int:
        """Query_interact: vector_report_by_y

        """
        cmd = f'''ensight.query_interact.vector_report_by_y({repr(p0)})'''
        return self._session.cmd(cmd)

    def vector_report_by_z(self, p0: str) -> int:
        """Query_interact: vector_report_by_z

        """
        cmd = f'''ensight.query_interact.vector_report_by_z({repr(p0)})'''
        return self._session.cmd(cmd)


class query_ent_var:
    """Class wrapper for EnSight query_ent_var module

    This class acts as a proxy for the EnSight Python module ensight.query_ent_var
    """
    def __init__(self, session: Session):
        self._session = session

    def auto_plot_checkexisting(self, p0: str) -> int:
        """Specifies to check for existing plotters with the same abscissa when auto plotting query information.
        
        | Only applicable with the "query_ent_var: auto_plot_queries ON" command. 
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.query_ent_var.auto_plot_checkexisting("ON")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.query_ent_var.auto_plot_checkexisting({repr(p0)})'''
        return self._session.cmd(cmd)

    def auto_plot_queries(self, p0: str) -> int:
        """Specify that any created query to be plotted automatically.
        
        | See also the "query_ent_var: auto_plot_checkexisting" command. 
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.query_ent_var.auto_plot_queries("ON")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.query_ent_var.auto_plot_queries({repr(p0)})'''
        return self._session.cmd(cmd)

    def begin(self) -> int:
        """Delimit the modifications for query attributes.
        
        | These commands are used to set the attributes for a query creation.
        
        Examples:
            ::
        
                ensight.part.select_begin(1)
                ensight.query_ent_var.begin()
                ensight.query_ent_var.description("")
                # WARNING: following line includes OBSOLETE call (ensight.query_ent_var.type).
                ensight.query_ent_var.type("distance")
                ensight.query_ent_var.number_of_sample_pts(20)
                ensight.query_ent_var.constrain("line_tool")
                ensight.query_ent_var.line_loc(1,2.7770e-01,7.7363e-02,1.1348e-02)
                ensight.query_ent_var.line_loc(2,7.6144e-01,1.7007e-01,5.5697e-02)
                # WARNING: following line includes OBSOLETE call (ensight.query_ent_var.variable).
                ensight.query_ent_var.variable("Density")
                ensight.query_ent_var.end()
                ensight.query_ent_var.query()
                ensight.curve.select_begin(0)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.query_ent_var.begin()'''
        return self._session.cmd(cmd)

    def begin_simtime(self, p0: float) -> int:
        """Specify the beginning simuation time to start the query over time.
        
        | This command must lie between either a "query_ent_var: begin" and "query_ent_var: end" pair, or a "query_ent_var: modify_begin" and "query_ent_var: modify_end" pair.  
        | Only applicable with the "query_ent_var: type time" command.
        
        Args:
            p0:
                'time_value' beginning simulation time value (that corresponds to a valid time step) in which to start the query over time
        
        Examples:
            ::
        
                # 
                # Select part 
                # 
                ensight.part.select_begin(2)
                # 
                # Query over time 
                # 
                ensight.query_ent_var.begin()
                ensight.query_ent_var.description("")
                # WARNING: following line includes OBSOLETE call (ensight.query_ent_var.type).
                ensight.query_ent_var.type("time")
                ensight.query_ent_var.number_of_sample_pts(84)
                ensight.query_ent_var.begin_simtime(2.2300e+02)
                ensight.query_ent_var.end_simtime(4.8800e+02)
                ensight.query_ent_var.constrain("node")
                ensight.query_ent_var.sample_by("value")
                ensight.query_ent_var.node_id(1)
                # WARNING: following line includes OBSOLETE call (ensight.query_ent_var.variable).
                ensight.query_ent_var.variable("temp")
                ensight.query_ent_var.end()
                ensight.query_ent_var.query()
                # 
                # Select resulting plot curve 
                # 
                ensight.curve.select_begin(0)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.query_ent_var.begin_simtime({repr(p0)})'''
        return self._session.cmd(cmd)

    def constpart_setparttobegin(self) -> int:
        """Query_ent_var: constpart_setparttobegin

        """
        cmd = f'''ensight.query_ent_var.constpart_setparttobegin()'''
        return self._session.cmd(cmd)

    def constpart_setparttoend(self) -> int:
        """Query_ent_var: constpart_setparttoend

        """
        cmd = f'''ensight.query_ent_var.constpart_setparttoend()'''
        return self._session.cmd(cmd)

    def constpart_sweepbegin(self) -> int:
        """Query_ent_var: constpart_sweepbegin

        """
        cmd = f'''ensight.query_ent_var.constpart_sweepbegin()'''
        return self._session.cmd(cmd)

    def constpart_sweepend(self) -> int:
        """Query_ent_var: constpart_sweepend

        """
        cmd = f'''ensight.query_ent_var.constpart_sweepend()'''
        return self._session.cmd(cmd)

    def constrain(self, p0: str) -> int:
        """Specify the manner in which to constrain the query of the variable.
        
        | This command must lie between either a "query_ent_var: begin" and "query_ent_var: end" pair, or a "query_ent_var: modify_begin" and "query_ent_var: modify_end" pair.
        
        Args:
            p0:
                'option'
        
                * query type Over Time choices are:
                * cursor
                * element
                * ijk
                * max
                * min
                * node
                * scalar
                * query type Distance choices are:
                * 1d_part
                * line_tool
                * spline
        
        Examples:
            ::
        
                # 
                # Modification change: 
                # 
                ensight.query_ent_var.modify_begin()
                # WARNING: following line includes OBSOLETE call (ensight.query_ent_var.type).
                ensight.query_ent_var.type("distance")
                ensight.query_ent_var.number_of_sample_pts(20)
                ensight.query_ent_var.constrain("line_tool")
                ensight.query_ent_var.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.query_ent_var.constrain({repr(p0)})'''
        return self._session.cmd(cmd)

    def cursor_loc(self, p0: float, p1: float, p2: float) -> int:
        """Specify the x,y,z coordinates of the cursor location to be queried.
        
        | This command must lie between either a "query_ent_var: begin" and "query_ent_var: end" pair, or a "query_ent_var: modify_begin" and "query_ent_var: modify_end" pair.
        | Used in conjunction with the "query_ent_var: type time" and the "query_ent_var: constrain cursor" commands.
        
        Args:
            p0:
                'x_coord' specify the x, y, z coordinate locations of the cursor in model space
            p1:
                'y_coord' specify the x, y, z coordinate locations of the cursor in model space
            p2:
                'z_coord' specify the x, y, z coordinate locations of the cursor in model space
        
        Examples:
            ::
        
                # 
                # Specify part on which to perform query 
                # 
                ensight.part.select_begin(2)
                ensight.query_ent_var.begin()
                ensight.query_ent_var.description("")
                # WARNING: following line includes OBSOLETE call (ensight.query_ent_var.type).
                ensight.query_ent_var.type("time")
                ensight.query_ent_var.number_of_sample_pts(84)
                ensight.query_ent_var.begin_simtime()
                ensight.query_ent_var.end_simtime()
                ensight.query_ent_var.constrain("cursor")
                ensight.query_ent_var.sample_by("value")
                ensight.query_ent_var.cursor_loc(1.4870e+00,4.3663e-01,1.1934e+01)
                # WARNING: following line includes OBSOLETE call (ensight.query_ent_var.variable).
                ensight.query_ent_var.variable("temp")
                ensight.query_ent_var.end()
                ensight.query_ent_var.query()
                # 
                # Specify new curve to be current 
                # 
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.query_ent_var.cursor_loc({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def data01(self, args: Any) -> int:
        """Query_ent_var: data01

        """
        cmd = f'''ensight.query_ent_var.data01({repr(args)})'''
        return self._session.cmd(cmd)

    def data02(self, args: Any) -> int:
        """Query_ent_var: data02

        """
        cmd = f'''ensight.query_ent_var.data02({repr(args)})'''
        return self._session.cmd(cmd)

    def data03(self, args: Any) -> int:
        """Query_ent_var: data03

        """
        cmd = f'''ensight.query_ent_var.data03({repr(args)})'''
        return self._session.cmd(cmd)

    def data04(self, args: Any) -> int:
        """Query_ent_var: data04

        """
        cmd = f'''ensight.query_ent_var.data04({repr(args)})'''
        return self._session.cmd(cmd)

    def data05(self, args: Any) -> int:
        """Query_ent_var: data05

        """
        cmd = f'''ensight.query_ent_var.data05({repr(args)})'''
        return self._session.cmd(cmd)

    def data06(self, args: Any) -> int:
        """Query_ent_var: data06

        """
        cmd = f'''ensight.query_ent_var.data06({repr(args)})'''
        return self._session.cmd(cmd)

    def description(self, p0: str) -> int:
        """Specify the text description for the query entity.
        
        | This command must lie between a "query_ent_var: begin" and "query_ent_var: end" pair.
        
        Args:
            p0:
                'desc' text description for the query entity
        
        Examples:
            ::
        
                ensight.curve.select_begin(1,"curve:","select_begin","part:","select_begin",2)
                ensight.query_ent_var.begin()
                ensight.query_ent_var.description("Temp Vs. Time")
                # WARNING: following line includes OBSOLETE call (ensight.query_ent_var.type).
                ensight.query_ent_var.type("time")
                ensight.query_ent_var.number_of_sample_pts(10)
                ensight.query_ent_var.begin_simtime(2.2300e+02)
                ensight.query_ent_var.end_simtime(4.8800e+02)
                ensight.query_ent_var.constrain("cursor")
                ensight.query_ent_var.sample_by("value")
                ensight.query_ent_var.cursor_loc(1.4870e+00,4.3663e-01,1.1934e+01)
                # WARNING: following line includes OBSOLETE call (ensight.query_ent_var.variable).
                ensight.query_ent_var.variable("temp")
                ensight.query_ent_var.end()
                ensight.query_ent_var.query()
                ensight.curve.select_begin(2)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.query_ent_var.description({repr(p0)})'''
        return self._session.cmd(cmd)

    def distance(self, p0: str) -> int:
        """Specify how to parameterize the distance of the computed query (also, how the Distance is labeled on the plot).
        
        | This command must lie between either a "query_ent_var: begin" and "query_ent_var: end" pair, or a "query_ent_var: modify_begin" and "query_ent_var: modify_end" pair.
        | Only applicable with the "query_ent_var: type distance" command.
        
        Args:
            p0:
                'option'
        
                * arc_length
                * x_arc_length
                * y_arc_length
                * z_arc_length
                * from_origin
                * x_from_origin
                * y_from_origin
                * z_from_origin
        
        Examples:
            ::
        
                # 
                # Modify to parameterize using only the x-component of the arc length 
                # 
                ensight.query_ent_var.modify_begin()
                # WARNING: following line includes OBSOLETE call (ensight.query_ent_var.type).
                ensight.query_ent_var.type("distance")
                ensight.query_ent_var.constrain("line_tool")
                ensight.query_ent_var.distance("x_arc_length")
                ensight.query_ent_var.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.query_ent_var.distance({repr(p0)})'''
        return self._session.cmd(cmd)

    def distance_in(self, p0: str) -> int:
        """Query_ent_var: distance_in

        """
        cmd = f'''ensight.query_ent_var.distance_in({repr(p0)})'''
        return self._session.cmd(cmd)

    def elem_id(self, p0: int) -> int:
        """Specify the element id used to perform the specified element constrained query.
        
        | This command must lie between either a "query_ent_var: begin" and "query_ent_var: end" pair, or a "query_ent_var: modify_begin" and "query_ent_var: modify_end" pair. 
        | Only applicable with the "query_ent_var: type time" and "query_ent_var: constrain element" commands. 
        | Only applicable on element-based variables. 
        | Only applicable with the "query_ent_var: constrain element" and "query_ent_var: type time" commands.
        
        Args:
            p0:
                'element_id_#' valid element id number (0-bias
        
        Examples:
            ::
        
                ensight.part.select_begin(4)
                ensight.query_ent_var.begin()
                ensight.query_ent_var.description("")
                # WARNING: following line includes OBSOLETE call (ensight.query_ent_var.type).
                ensight.query_ent_var.type("time")
                ensight.query_ent_var.number_of_sample_pts(10)
                ensight.query_ent_var.begin_simtime(2.2300e+02)
                ensight.query_ent_var.end_simtime(4.8800e+02)
                ensight.query_ent_var.constrain("element")
                ensight.query_ent_var.sample_by("value")
                # WARNING: following line includes OBSOLETE call (ensight.query_ent_var.variable).
                ensight.query_ent_var.variable("NodeToElem")
                ensight.query_ent_var.elem_id(14)
                ensight.query_ent_var.end()
                ensight.query_ent_var.query()
                ensight.curve.select_begin(0)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.query_ent_var.elem_id({repr(p0)})'''
        return self._session.cmd(cmd)

    def end(self) -> int:
        """Delimit the modifications for query attributes.
        
        | These commands are used to set the attributes for a query creation.
        
        Examples:
            ::
        
                ensight.part.select_begin(1)
                ensight.query_ent_var.begin()
                ensight.query_ent_var.description("")
                # WARNING: following line includes OBSOLETE call (ensight.query_ent_var.type).
                ensight.query_ent_var.type("distance")
                ensight.query_ent_var.number_of_sample_pts(20)
                ensight.query_ent_var.constrain("line_tool")
                ensight.query_ent_var.line_loc(1,2.7770e-01,7.7363e-02,1.1348e-02)
                ensight.query_ent_var.line_loc(2,7.6144e-01,1.7007e-01,5.5697e-02)
                # WARNING: following line includes OBSOLETE call (ensight.query_ent_var.variable).
                ensight.query_ent_var.variable("Density")
                ensight.query_ent_var.end()
                ensight.query_ent_var.query()
                ensight.curve.select_begin(0)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.query_ent_var.end()'''
        return self._session.cmd(cmd)

    def end_simtime(self, p0: float) -> int:
        """Specify the ending simulation time used to stop the query over time.
        
        | This command must lie between either a "query_ent_var: begin" and "query_ent_var: end" pair, or a "query_ent_var: modify_begin" and "query_ent_var: modify_end" pair. 
        | Only applicable with the "query_ent_var: type time" command.
        
        Args:
            p0:
                'time_value' ending simulation time value (that corresponds to a time step) at which to stop the computed query over time
        
        Examples:
            ::
        
                # 
                # Select part 
                # 
                ensight.part.select_begin(2)
                # 
                # Query over time 
                # 
                ensight.query_ent_var.begin()
                ensight.query_ent_var.description("")
                # WARNING: following line includes OBSOLETE call (ensight.query_ent_var.type).
                ensight.query_ent_var.type("time")
                ensight.query_ent_var.number_of_sample_pts(84)
                ensight.query_ent_var.begin_simtime(2.2300e+02)
                ensight.query_ent_var.end_simtime(4.8800e+02)
                ensight.query_ent_var.constrain("node")
                ensight.query_ent_var.sample_by("value")
                ensight.query_ent_var.node_id(1)
                # WARNING: following line includes OBSOLETE call (ensight.query_ent_var.variable).
                ensight.query_ent_var.variable("temp")
                ensight.query_ent_var.end()
                ensight.query_ent_var.query()
                # 
                # Select resulting plot curve 
                # 
                ensight.curve.select_begin(0)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.query_ent_var.end_simtime({repr(p0)})'''
        return self._session.cmd(cmd)

    def frame(self, p0: int) -> int:
        """Query_ent_var: frame

        """
        cmd = f'''ensight.query_ent_var.frame({repr(p0)})'''
        return self._session.cmd(cmd)

    def generate_over(self, p0: str) -> int:
        """Specify whether the query is over time or distance.
        
        | This command must lie between either a "query_ent_var: begin" and "query_ent_var: end" pair, or a "query_ent_var: modify_begin" and "query_ent_var: modify_end" pair.
        
        Args:
            p0:
                'type'
        
                * distance
                * time
        
        Examples:
            ::
        
                ensight.part.select_all()
                ensight.query_ent_var.begin()
                ensight.query_ent_var.description("")
                ensight.query_ent_var.query_type("generated")
                ensight.query_ent_var.number_of_sample_pts(20)
                ensight.query_ent_var.begin_simtime(0.0000e+00)
                ensight.query_ent_var.end_simtime(0.1900e+02)
                ensight.query_ent_var.constrain("node")
                ensight.query_ent_var.sample_by("value")
                ensight.query_ent_var.node_id(139)
                ensight.query_ent_var.variable_1("temperature")
                ensight.query_ent_var.generate_over("time")
                ensight.query_ent_var.variable_2("TIME")
                ensight.query_ent_var.end()
                ensight.query_ent_var.query()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.query_ent_var.generate_over({repr(p0)})'''
        return self._session.cmd(cmd)

    def ijk(self, p0: int, p1: int, p2: int) -> int:
        """Specify the ijk location used to perform the specified ijk constrained query.
        
        | This command must lie between either a "query_ent_var: begin" and "query_ent_var: end" pair, or a "query_ent_var: modify_begin" and "query_ent_var: modify_end" pair. 
        | Only applicable with the "query_ent_var: constrain ijk" and "query_ent_var: type time" commands.
        
        Args:
            p0:
                'i-plane_#' i, j, and k component values which must lie within the min/max of the i, j, and k range
            p1:
                'j-plane_#' i, j, and k component values which must lie within the min/max of the i, j, and k range
            p2:
                'k-plane_#' i, j, and k component values which must lie within the min/max of the i, j, and k range
        
        Examples:
            ::
        
                ensight.part.select_begin(4)
                ensight.query_ent_var.begin()
                ensight.query_ent_var.description("")
                # WARNING: following line includes OBSOLETE call (ensight.query_ent_var.type).
                ensight.query_ent_var.type("time")
                ensight.query_ent_var.number_of_sample_pts(10)
                ensight.query_ent_var.begin_simtime(2.2300e+02)
                ensight.query_ent_var.end_simtime(4.8800e+02)
                ensight.query_ent_var.constrain("ijk")
                ensight.query_ent_var.sample_by("value")
                # WARNING: following line includes OBSOLETE call (ensight.query_ent_var.variable).
                ensight.query_ent_var.variable("temp")
                ensight.query_ent_var.ijk(2,4,14)
                ensight.query_ent_var.end()
                ensight.query_ent_var.query()
                ensight.curve.select_begin(0)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.query_ent_var.ijk({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def line_loc(self, p0: float, p1: float, p2: float, p3: float) -> int:
        """Specify the location of the line used for distance queries when the constraint is set to line_tool. 
        
        | This command must lie between either a "query_ent_var: begin" and "query_ent_var: end" pair, or a "query_ent_var: modify_begin" and "query_ent_var: modify_end" pair.
        
        Args:
            p0:
                'end_point_id' endpoints of the line, either 1 or 2
            p1:
                'x_comp' x , y, or z component of the corresponding line endpoint in model coordinates
            p2:
                'y_comp' x , y, or z component of the corresponding line endpoint in model coordinates
            p3:
                'z_comp' x , y, or z component of the corresponding line endpoint in model coordinates
        
        Examples:
            ::
        
                ensight.part.select_begin(1)
                ensight.query_ent_var.begin()
                ensight.query_ent_var.description("")
                # WARNING: following line includes OBSOLETE call (ensight.query_ent_var.type).
                ensight.query_ent_var.type("distance")
                ensight.query_ent_var.number_of_sample_pts(20)
                ensight.query_ent_var.constrain("line_tool")
                ensight.query_ent_var.line_loc(1,2.7770e-01,7.7363e-02,1.1348e-02)
                ensight.query_ent_var.line_loc(2,7.6144e-01,1.7007e-01,5.5697e-02)
                # WARNING: following line includes OBSOLETE call (ensight.query_ent_var.variable).
                ensight.query_ent_var.variable("Density")
                ensight.query_ent_var.end()
                ensight.query_ent_var.query()
                ensight.curve.select_begin(0)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.query_ent_var.line_loc({repr(p0)},{repr(p1)},{repr(p2)},{repr(p3)})'''
        return self._session.cmd(cmd)

    def marker_rgb(self, p0: float, p1: float, p2: float) -> int:
        """Specify the color for the visible markers indicating query location.
        
        | This command must lie between either a "query_ent_var: begin" and "query_ent_var: end" pair, or a "query_ent_var: modify_begin" and "query_ent_var: modify_end" pair.
        | Used only if query_ent_var: marker_visible is on.
        
        Args:
            p0:
                'red_val' red, green, or blue component of color (0. to 1.)
            p1:
                'grn_val' red, green, or blue component of color (0. to 1.)
            p2:
                'blu_val' red, green, or blue component of color (0. to 1.)
        
        Examples:
            ::
        
                ensight.query_ent_var.modify_begin()
                # WARNING: following line includes OBSOLETE call (ensight.query_ent_var.type).
                ensight.query_ent_var.type("distance")
                ensight.query_ent_var.constrain("1d_part")
                ensight.query_ent_var.marker_rgb(1.0000e+00,0.0000e+00,1.0000e+00)
                ensight.query_ent_var.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.query_ent_var.marker_rgb({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def marker_size(self, p0: float) -> int:
        """Query_ent_var: marker_size

        """
        cmd = f'''ensight.query_ent_var.marker_size({repr(p0)})'''
        return self._session.cmd(cmd)

    def marker_size_normalized(self, p0: float) -> int:
        """Specify the size of a query marker.
        
        | This command must lie between either a "query_ent_var: begin" and "query_ent_var: end" pair, or a "query_ent_var: modify_begin" and "query_ent_var: modify_end" pair.
        | Used only if query_ent_var:marker_visible is on.
        | A size of 1.0 indicates to use the computed size.
        | Values >1 scale the computed size larger while values <1 (but >0) shrink the marker.
        
        Args:
            p0:
                'size_value' size of the marker
        
        Examples:
            ::
        
                ensight.query_ent_var.modify_begin()
                # WARNING: following line includes OBSOLETE call (ensight.query_ent_var.type).
                ensight.query_ent_var.type("distance")
                ensight.query_ent_var.constrain("1d_part")
                ensight.query_ent_var.marker_size_normalized(2.0000e+00)
                ensight.query_ent_var.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.query_ent_var.marker_size_normalized({repr(p0)})'''
        return self._session.cmd(cmd)

    def marker_visible(self, p0: str) -> int:
        """The begin/end construct in which to modify query entity attributes.
        
        | This command must lie between either a "query_ent_var: begin" and "query_ent_var: end" pair, or a "query_ent_var: modify_begin" and "query_ent_var: modify_end" pair. 
        | If the query type is distance, then the marker is placed at the location of the origin (starting endpoint).
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.query_ent_var.modify_begin()
                # WARNING: following line includes OBSOLETE call (ensight.query_ent_var.type).
                ensight.query_ent_var.type("time")
                ensight.query_ent_var.constrain("element")
                ensight.query_ent_var.marker_visible("OFF")
                ensight.query_ent_var.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.query_ent_var.marker_visible({repr(p0)})'''
        return self._session.cmd(cmd)

    def modify_begin(self) -> int:
        """Delimit the modifications for query entity attributes.
        
        | These commands are used to set the attributes for a query entity. 
        
        Examples:
            ::
        
                # 
                # Modification change: 
                # 
                ensight.query_ent_var.modify_begin()
                # WARNING: following line includes OBSOLETE call (ensight.query_ent_var.type).
                ensight.query_ent_var.type("distance")
                ensight.query_ent_var.number_of_sample_pts(20)
                ensight.query_ent_var.constrain("line_tool")
                ensight.query_ent_var.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.query_ent_var.modify_begin()'''
        return self._session.cmd(cmd)

    def modify_end(self) -> int:
        """Delimit the modifications for query entity attributes.
        
        | These commands are used to set the attributes for a query entity. 
        
        Examples:
            ::
        
                # 
                # Modification change: 
                # 
                ensight.query_ent_var.modify_begin()
                # WARNING: following line includes OBSOLETE call (ensight.query_ent_var.type).
                ensight.query_ent_var.type("distance")
                ensight.query_ent_var.number_of_sample_pts(20)
                ensight.query_ent_var.constrain("line_tool")
                ensight.query_ent_var.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.query_ent_var.modify_end()'''
        return self._session.cmd(cmd)

    def multiple_segments_by(self, p0: str) -> int:
        """Treat multiple line segments of a distance query as multiple queries, (i.e., reset the distance to 0. for each segment) or as a continuous line.
        
        | This command must lie between either a "query_ent_var: begin" and "query_ent_var: end" pair, or a "query_ent_var: modify_begin" and "query_ent_var: modify_end" pair. 
        | Only applicable with the "query_ent_var: type distance" command.
        
        Args:
            p0:
                'option'
        
                * accumulation
                * reset_each
        
        Examples:
            ::
        
                ensight.query_ent_var.modify_begin()
                # WARNING: following line includes OBSOLETE call (ensight.query_ent_var.type).
                ensight.query_ent_var.type("distance")
                ensight.query_ent_var.constrain("1d_part")
                ensight.query_ent_var.multiple_segments_by("reset_each")
                ensight.query_ent_var.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.query_ent_var.multiple_segments_by({repr(p0)})'''
        return self._session.cmd(cmd)

    def node_id(self, p0: int) -> int:
        """Specify the node id in which to perform the specified node constrained query.
        
        | This command must lie between either a "query_ent_var: begin" and "query_ent_var: end" pair, or a "query_ent_var: modify_begin" and "query_ent_var: modify_end" pair. 
        | Only applicable with the "query_ent_var: constrain node" command. Only applicable on node-based variables.
        
        Args:
            p0:
                'node_id_#' node id, or label, number
        
        Examples:
            ::
        
                # 
                # Select part 
                # 
                ensight.part.select_begin(2)
                # 
                # Query over time 
                # 
                ensight.query_ent_var.begin()
                ensight.query_ent_var.description("")
                # WARNING: following line includes OBSOLETE call (ensight.query_ent_var.type).
                ensight.query_ent_var.type("time")
                ensight.query_ent_var.number_of_sample_pts(84)
                ensight.query_ent_var.begin_simtime(2.2300e+02)
                ensight.query_ent_var.end_simtime(4.8800e+02)
                ensight.query_ent_var.constrain("node")
                ensight.query_ent_var.sample_by("value")
                ensight.query_ent_var.node_id(1)
                # WARNING: following line includes OBSOLETE call (ensight.query_ent_var.variable).
                ensight.query_ent_var.variable("temp")
                ensight.query_ent_var.end()
                ensight.query_ent_var.query()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.query_ent_var.node_id({repr(p0)})'''
        return self._session.cmd(cmd)

    def number_of_sample_pts(self, p0: int) -> int:
        """Specify the number of evenly spaced points to sample either along the line tool or over the specified range of time steps.
        
        | This command must lie between either a "query_ent_var: begin" and "query_ent_var: end" pair, or a "query_ent_var: modify_begin" and "query_ent_var: modify_end" pair.  
        | If you specify more or fewer sample points than the number of time steps, EnSight linearly interpolates between the adjoining time steps. 
        | If the query is an FFT sampling, the number of frequencies output will be (a power of two) less than or equal to the number of sample points.
        
        Args:
            p0:
                'total_points' For queries over Distance using the Line Tool, this specifies the number of equally spaced points to query along the line (default = 20).  For queries Over Time, this specifies how many evenly timed moments over the specified range of time steps at which to query. If equal to the number of timesteps then you get a sample at each timestep.
        
        Examples:
            ::
        
                # 
                # Creation example... 
                # 
                ensight.part.select_begin(1)
                ensight.query_ent_var.begin()
                ensight.query_ent_var.description("")
                # WARNING: following line includes OBSOLETE call (ensight.query_ent_var.type).
                ensight.query_ent_var.type("distance")
                ensight.query_ent_var.number_of_sample_pts(20)
                ensight.query_ent_var.constrain("line_tool")
                ensight.query_ent_var.line_loc(1,2.7770e-01,7.7363e-02,1.1348e-02)
                ensight.query_ent_var.line_loc(2,7.6144e-01,1.7007e-01,5.5697e-02)
                # WARNING: following line includes OBSOLETE call (ensight.query_ent_var.variable).
                ensight.query_ent_var.variable("Density")
                ensight.query_ent_var.end()
                ensight.query_ent_var.query()
                ensight.curve.select_begin(0)
                # 
                # Modification example... 
                # 
                ensight.query_ent_var.modify_begin()
                # WARNING: following line includes OBSOLETE call (ensight.query_ent_var.type).
                ensight.query_ent_var.type("distance")
                ensight.query_ent_var.number_of_sample_pts(20)
                ensight.query_ent_var.constrain("line_tool")
                ensight.query_ent_var.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.query_ent_var.number_of_sample_pts({repr(p0)})'''
        return self._session.cmd(cmd)

    def operation(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.query_ent_var.operation({repr(p0)})'''
        return self._session.cmd(cmd)

    def operation_factor1(self, p0: float) -> int:
        """Specify the scale factor to apply to the one or two existing queries of an operation query. 
        
        | This command must lie between either a "query_ent_var: begin" and "query_ent_var: end" pair, or a "query_ent_var: modify_begin" and "query_ent_var: modify_end" pair.
        
        Args:
            p0:
                'scale' value to scale the respective query by
        
        Examples:
            ::
        
                ensight.query_ent_var.begin()
                ensight.query_ent_var.description("")
                ensight.query_ent_var.query_type("operation")
                ensight.query_ent_var.operation_factor1(2.0000e+00)
                ensight.query_ent_var.operation_factor2(-1.5000e+01)
                ensight.query_ent_var.operation_query1byname("Distance","vs.","temp","for","line","tool")
                ensight.query_ent_var.operation_query2byname("Time","vs.","temp","for","Node",1)
                ensight.query_ent_var.end()
                ensight.query_ent_var.query()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.query_ent_var.operation_factor1({repr(p0)})'''
        return self._session.cmd(cmd)

    def operation_factor2(self, p0: float) -> int:
        """Specify the scale factor to apply to the one or two existing queries of an operation query. 
        
        | This command must lie between either a "query_ent_var: begin" and "query_ent_var: end" pair, or a "query_ent_var: modify_begin" and "query_ent_var: modify_end" pair.
        
        Args:
            p0:
                'scale' value to scale the respective query by
        
        Examples:
            ::
        
                ensight.query_ent_var.begin()
                ensight.query_ent_var.description("")
                ensight.query_ent_var.query_type("operation")
                ensight.query_ent_var.operation_factor1(2.0000e+00)
                ensight.query_ent_var.operation_factor2(-1.5000e+01)
                ensight.query_ent_var.operation_query1byname("Distance","vs.","temp","for","line","tool")
                ensight.query_ent_var.operation_query2byname("Time","vs.","temp","for","Node",1)
                ensight.query_ent_var.end()
                ensight.query_ent_var.query()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.query_ent_var.operation_factor2({repr(p0)})'''
        return self._session.cmd(cmd)

    def operation_query1byname(self, args: Any) -> int:
        """Specify the name of the one or two existing queries of an operation query. 
        
        | This command must lie between either a "query_ent_var: begin" and "query_ent_var: end" pair, or a "query_ent_var: modify_begin" and "query_ent_var: modify_end" pair.
        
        Args:
            p0:
                'name' existing query name
        
        Examples:
            ::
        
                ensight.query_ent_var.begin()
                ensight.query_ent_var.description("")
                ensight.query_ent_var.query_type("operation")
                ensight.query_ent_var.operation_factor1(2.0000e+00)
                ensight.query_ent_var.operation_factor2(-1.5000e+01)
                ensight.query_ent_var.operation_query1byname("Distance","vs.","temp","for","line","tool")
                ensight.query_ent_var.operation_query2byname("Time","vs.","temp","for","Node",1)
                ensight.query_ent_var.end()
                ensight.query_ent_var.query()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.query_ent_var.operation_query1byname({repr(args)})'''
        return self._session.cmd(cmd)

    def operation_query2byname(self, args: Any) -> int:
        """Specify the name of the one or two existing queries of an operation query. 
        
        | This command must lie between either a "query_ent_var: begin" and "query_ent_var: end" pair, or a "query_ent_var: modify_begin" and "query_ent_var: modify_end" pair.
        
        Args:
            p0:
                'name' existing query name
        
        Examples:
            ::
        
                ensight.query_ent_var.begin()
                ensight.query_ent_var.description("")
                ensight.query_ent_var.query_type("operation")
                ensight.query_ent_var.operation_factor1(2.0000e+00)
                ensight.query_ent_var.operation_factor2(-1.5000e+01)
                ensight.query_ent_var.operation_query1byname("Distance","vs.","temp","for","line","tool")
                ensight.query_ent_var.operation_query2byname("Time","vs.","temp","for","Node",1)
                ensight.query_ent_var.end()
                ensight.query_ent_var.query()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.query_ent_var.operation_query2byname({repr(args)})'''
        return self._session.cmd(cmd)

    def origin(self, p0: float, p1: float, p2: float) -> int:
        """Specify a location which will be used to select the origin of a distance plot when performing the query on a 1D part.
        
        | This command must lie between either a "query_ent_var: begin" and "query_ent_var: end" pair, or a "query_ent_var: modify_begin" and "query_ent_var: modify_end" pair. 
        | Only applicable with the "querey_ent_var: type distance" and "query_ent_var: constrain 1d_part" commands.
        | The end point closest to the origin specified will be used as the "origin" of the query, i.e., where distance = 0.
        | If the ID part is a closed loop (i.e., there are no end points), the closest point on the loop is used as the "origin".
        
        Args:
            p0:
                'x_coord' x, y, or z coordinate value in model coordinates
            p1:
                'y_coord' x, y, or z coordinate value in model coordinates
            p2:
                'z_coord' x, y, or z coordinate value in model coordinates
        
        Examples:
            ::
        
                ensight.query_ent_var.modify_begin()
                ensight.query_ent_var.origin(2.3596e+00,1.8494e+00,1.1773e+01)
                ensight.query_ent_var.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.query_ent_var.origin({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def part_delta_value(self, p0: float) -> int:
        """Query_ent_var: part_delta_value

        """
        cmd = f'''ensight.query_ent_var.part_delta_value({repr(p0)})'''
        return self._session.cmd(cmd)

    def part_id(self, args: Any) -> int:
        """Specify the 1D part number to query when performing a query over distance with a part constraint.
        
        | This command must lie between either a "query_ent_var: begin" and "query_ent_var: end" pair, or a "query_ent_var: modify_begin" and "query_ent_var: modify_end" pair.
        
        Args:
            p0:
                'part_id_#' GUI number of the part
        
        Examples:
            ::
        
                ensight.part.select_begin(4)
                ensight.query_ent_var.begin()
                ensight.query_ent_var.description("")
                # WARNING: following line includes OBSOLETE call (ensight.query_ent_var.type).
                ensight.query_ent_var.type("distance")
                ensight.query_ent_var.part_id(4)
                ensight.query_ent_var.constrain("1d_part")
                ensight.query_ent_var.distance("arc_length")
                # WARNING: following line includes OBSOLETE call (ensight.query_ent_var.variable).
                ensight.query_ent_var.variable("temp")
                ensight.query_ent_var.end()
                ensight.query_ent_var.query()
                ensight.curve.select_begin(0)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.query_ent_var.part_id({repr(args)})'''
        return self._session.cmd(cmd)

    def part_idbyname(self, args: Any) -> int:
        """Specify the 1D part name to query when performing a query over distance with a part constraint.
        
        | This command must lie between either a "query_ent_var: begin" and "query_ent_var: end" pair, or a "query_ent_var: modify_begin" and "query_ent_var: modify_end" pair.
        
        Args:
            p0:
                'part_name' GUI name of the part
        
        Examples:
            ::
        
                ensight.part.select_begin("Flow","Field")
                ensight.query_ent_var.begin()
                ensight.query_ent_var.description("")
                # WARNING: following line includes OBSOLETE call (ensight.query_ent_var.type).
                ensight.query_ent_var.type("distance")
                ensight.query_ent_var.part_idbyname("Line","Clip")
                ensight.query_ent_var.constrain("1d_part")
                ensight.query_ent_var.distance("arc_length")
                # WARNING: following line includes OBSOLETE call (ensight.query_ent_var.variable).
                ensight.query_ent_var.variable("temp")
                ensight.query_ent_var.end()
                ensight.query_ent_var.query()
                ensight.curve.select_begin(0)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.query_ent_var.part_idbyname({repr(args)})'''
        return self._session.cmd(cmd)

    def part_max_value(self, p0: float) -> int:
        """Query_ent_var: part_max_value

        """
        cmd = f'''ensight.query_ent_var.part_max_value({repr(p0)})'''
        return self._session.cmd(cmd)

    def part_min_value(self, p0: float) -> int:
        """Query_ent_var: part_min_value

        """
        cmd = f'''ensight.query_ent_var.part_min_value({repr(p0)})'''
        return self._session.cmd(cmd)

    def point_1(self, p0: float, p1: float, p2: float) -> int:
        """Query_ent_var: point_1

        """
        cmd = f'''ensight.query_ent_var.point_1({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def point_2(self, p0: float, p1: float, p2: float) -> int:
        """Query_ent_var: point_2

        """
        cmd = f'''ensight.query_ent_var.point_2({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def query(self) -> int:
        """Specify the creation of a query entity.
        
        | The query is created using the current query attributes.
        
        Examples:
            ::
        
                ensight.part.select_begin(1)
                ensight.query_ent_var.begin()
                ensight.query_ent_var.description("")
                # WARNING: following line includes OBSOLETE call (ensight.query_ent_var.type).
                ensight.query_ent_var.type("distance")
                ensight.query_ent_var.number_of_sample_pts(20)
                ensight.query_ent_var.constrain("line_tool")
                ensight.query_ent_var.line_loc(1,2.7770e-01,7.7363e-02,1.1348e-02)
                ensight.query_ent_var.line_loc(2,7.6144e-01,1.7007e-01,5.5697e-02)
                # WARNING: following line includes OBSOLETE call (ensight.query_ent_var.variable).
                ensight.query_ent_var.variable("Density")
                ensight.query_ent_var.end()
                ensight.query_ent_var.query()
                ensight.curve.select_begin(0)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.query_ent_var.query()'''
        return self._session.cmd(cmd)

    def query_count(self, args: Any) -> int:
        """Query_ent_var: query_count

        """
        cmd = f'''ensight.query_ent_var.query_count({repr(args)})'''
        return self._session.cmd(cmd)

    def query_create_attributes(self, args: Any) -> int:
        """Query_ent_var: query_create_attributes

        """
        cmd = f'''ensight.query_ent_var.query_create_attributes({repr(args)})'''
        return self._session.cmd(cmd)

    def query_display_attributes(self, args: Any) -> int:
        """Query_ent_var: query_display_attributes

        """
        cmd = f'''ensight.query_ent_var.query_display_attributes({repr(args)})'''
        return self._session.cmd(cmd)

    def query_object_atwindowxy(self, args: Any) -> int:
        """Query_ent_var: query_object_atwindowxy

        """
        cmd = f'''ensight.query_ent_var.query_object_atwindowxy({repr(args)})'''
        return self._session.cmd(cmd)

    def query_type(self, p0: str) -> int:
        """Specify the type of query to be created.
        
        | This command must lie between either a "query_ent_var: begin" and "query_ent_var: end" pair, or a "query_ent_var: modify_begin" and "query_ent_var: modify_end" pair.
        
        Args:
            p0:
                'type'
        
                * generated
                * operation
                * external
        
        Examples:
            ::
        
                ensight.part.select_all()
                #
                # At line tool over distance query
                #
                ensight.query_ent_var.begin()
                ensight.query_ent_var.description("")
                ensight.query_ent_var.query_type("generated")
                ensight.query_ent_var.number_of_sample_pts(20)
                ensight.query_ent_var.constrain("line_tool")
                ensight.query_ent_var.constrain("line_tool")
                ensight.query_ent_var.line_loc(1,-7.5000e-01,1.1561e+00,1.0000e+00)
                ensight.query_ent_var.line_loc(2,1.7500e+00,1.1561e+00,1.0000e+00)
                ensight.query_ent_var.variable_1("temperature")
                ensight.query_ent_var.generate_over("distance")
                ensight.query_ent_var.variable_2("DISTANCE")
                ensight.query_ent_var.end()
                ensight.query_ent_var.query()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.query_ent_var.query_type({repr(p0)})'''
        return self._session.cmd(cmd)

    def sample_by(self, p0: str) -> int:
        """Specify how to report values queried over time.
        
        | This command must lie between either a "query_ent_var: begin" and "query_ent_var: end" pair, or a "query_ent_var: modify_begin" and "query_ent_var: modify_end" pair. 
        | Only applicable with the "query_ent_var: type time" command.
        
        Args:
            p0:
                'option'
        
                * value
                * fft
        
        Examples:
            ::
        
                # 
                # Select part 
                # 
                ensight.part.select_begin(2)
                # 
                # Query over time 
                # 
                ensight.query_ent_var.begin()
                ensight.query_ent_var.description("")
                # WARNING: following line includes OBSOLETE call (ensight.query_ent_var.type).
                ensight.query_ent_var.type("time")
                ensight.query_ent_var.number_of_sample_pts(84)
                ensight.query_ent_var.begin_simtime(2.2300e+02)
                ensight.query_ent_var.end_simtime(4.8800e+02)
                ensight.query_ent_var.constrain("node")
                ensight.query_ent_var.sample_by("value")
                ensight.query_ent_var.node_id(1)
                # WARNING: following line includes OBSOLETE call (ensight.query_ent_var.variable).
                ensight.query_ent_var.variable("temp")
                ensight.query_ent_var.end()
                ensight.query_ent_var.query()
                # 
                # Select resulting plot curve 
                # 
                ensight.curve.select_begin(0)
                # 
                # Modified to sample by FFT 
                # 
                ensight.query_ent_var.modify_begin()
                # WARNING: following line includes OBSOLETE call (ensight.query_ent_var.type).
                ensight.query_ent_var.type("time")
                ensight.query_ent_var.constrain("node")
                ensight.query_ent_var.sample_by("fft")
                ensight.query_ent_var.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.query_ent_var.sample_by({repr(p0)})'''
        return self._session.cmd(cmd)

    def scalar_value(self, p0: int) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.query_ent_var.scalar_value({repr(p0)})'''
        return self._session.cmd(cmd)

    def scalar_variable(self, args: Any) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.query_ent_var.scalar_variable({repr(args)})'''
        return self._session.cmd(cmd)

    def select_all_timesteps(self) -> int:
        """Causes all current timesteps to be selected for querying.
        
        | This command is not generated by EnSight, but can be placed in a command file to generalize it so you do not have to know how many time steps are present.  It can replace the following commands:
        | query_ent_var: begin_simtime <time_value>
        | query_ent_var: end_simtime <time_value>
        | query_ent_var: number_of_sample_pts <total_points>
        
        Examples:
            ::
        
                ensight.part.select_begin(1)
                ensight.query_ent_var.begin()
                ensight.query_ent_var.description("")
                ensight.query_ent_var.query_type("generated")
                ensight.query_ent_var.select_all_timesteps()
                ensight.query_ent_var.constrain("node")
                ensight.query_ent_var.sample_by("value")
                ensight.query_ent_var.node_id(100)
                ensight.query_ent_var.variable_1("Stress")
                ensight.query_ent_var.generate_over("time")
                ensight.query_ent_var.variable_2("TIME")
                ensight.query_ent_var.end()
                ensight.query_ent_var.query()
                ensight.curve.select_begin(0)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.query_ent_var.select_all_timesteps()'''
        return self._session.cmd(cmd)

    def spline_id(self, p0: int) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.query_ent_var.spline_id({repr(p0)})'''
        return self._session.cmd(cmd)

    def spline_name(self, args: Any) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.query_ent_var.spline_name({repr(args)})'''
        return self._session.cmd(cmd)

    def sweep_build1(self, args: Any) -> int:
        """Query_ent_var: sweep_build1

        """
        cmd = f'''ensight.query_ent_var.sweep_build1({repr(args)})'''
        return self._session.cmd(cmd)

    def sweep_build2(self, args: Any) -> int:
        """Query_ent_var: sweep_build2

        """
        cmd = f'''ensight.query_ent_var.sweep_build2({repr(args)})'''
        return self._session.cmd(cmd)

    def sweep_build3(self, args: Any) -> int:
        """Query_ent_var: sweep_build3

        """
        cmd = f'''ensight.query_ent_var.sweep_build3({repr(args)})'''
        return self._session.cmd(cmd)

    def sweep_build4(self, args: Any) -> int:
        """Query_ent_var: sweep_build4

        """
        cmd = f'''ensight.query_ent_var.sweep_build4({repr(args)})'''
        return self._session.cmd(cmd)

    def time_step_begin(self, p0: float) -> int:
        """Query_ent_var: time_step_begin

        """
        cmd = f'''ensight.query_ent_var.time_step_begin({repr(p0)})'''
        return self._session.cmd(cmd)

    def time_step_end(self, p0: float) -> int:
        """Query_ent_var: time_step_end

        """
        cmd = f'''ensight.query_ent_var.time_step_end({repr(p0)})'''
        return self._session.cmd(cmd)

    def type(self, p0: str) -> int:
        """Query_ent_var: type

        """
        cmd = f'''ensight.query_ent_var.type({repr(p0)})'''
        return self._session.cmd(cmd)

    def update_with_newtimesteps(self, p0: str) -> int:
        """Query_ent_var: update_with_newtimesteps

        """
        cmd = f'''ensight.query_ent_var.update_with_newtimesteps({repr(p0)})'''
        return self._session.cmd(cmd)

    def variable(self, args: Any) -> int:
        """Query_ent_var: variable

        """
        cmd = f'''ensight.query_ent_var.variable({repr(args)})'''
        return self._session.cmd(cmd)

    def variable_1(self, args: Any) -> int:
        """Specify the variables to be queried. The first variable can be any active variable. The second variable can be distance, time, or a second active variable.
        
        | This command must lie between either a "query_ent_var: begin" and "query_ent_var: end" pair, or a "query_ent_var: modify_begin" and "query_ent_var: modify_end" pair.
        
        Args:
            p0:
                'name' name of the active variable. For variable_1 it can be any active variable. For variable_2, it can be DISTANCE if a non-scatter query over distance is being created, TIME if a non-scatter query over time is being created, or any active variable if a scatter query is being created.  If plotted, variable_1 will be the Y-axis variable and varibe_2 will be the X-axis variable.
        
        Examples:
            ::
        
                ensight.part.select_all()
                #
                # At line tool over distance query
                #
                ensight.query_ent_var.begin()
                ensight.query_ent_var.description("")
                ensight.query_ent_var.query_type("generated")
                ensight.query_ent_var.number_of_sample_pts(20)
                ensight.query_ent_var.constrain("line_tool")
                ensight.query_ent_var.constrain("line_tool")
                ensight.query_ent_var.line_loc(1,-7.5000e-01,1.1561e+00,1.0000e+00)
                ensight.query_ent_var.line_loc(2,1.7500e+00,1.1561e+00,1.0000e+00)
                ensight.query_ent_var.variable_1("temperature")
                ensight.query_ent_var.generate_over("distance")
                ensight.query_ent_var.variable_2("DISTANCE")
                ensight.query_ent_var.end()
                ensight.query_ent_var.query()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.query_ent_var.variable_1({repr(args)})'''
        return self._session.cmd(cmd)

    def variable_1_byname_begin(self, args: Any) -> int:
        """Query_ent_var: variable_1_byname_begin

        """
        cmd = f'''ensight.query_ent_var.variable_1_byname_begin({repr(args)})'''
        return self._session.cmd(cmd)

    def variable_1_byname_end(self) -> int:
        """Query_ent_var: variable_1_byname_end

        """
        cmd = f'''ensight.query_ent_var.variable_1_byname_end()'''
        return self._session.cmd(cmd)

    def variable_2(self, args: Any) -> int:
        """Specify the variables to be queried. The first variable can be any active variable. The second variable can be distance, time, or a second active variable.
        
        | This command must lie between either a "query_ent_var: begin" and "query_ent_var: end" pair, or a "query_ent_var: modify_begin" and "query_ent_var: modify_end" pair.
        
        Args:
            p0:
                'name' name of the active variable. For variable_1 it can be any active variable. For variable_2, it can be DISTANCE if a non-scatter query over distance is being created, TIME if a non-scatter query over time is being created, or any active variable if a scatter query is being created.  If plotted, variable_1 will be the Y-axis variable and varibe_2 will be the X-axis variable.
        
        Examples:
            ::
        
                ensight.part.select_all()
                #
                # At line tool over distance query
                #
                ensight.query_ent_var.begin()
                ensight.query_ent_var.description("")
                ensight.query_ent_var.query_type("generated")
                ensight.query_ent_var.number_of_sample_pts(20)
                ensight.query_ent_var.constrain("line_tool")
                ensight.query_ent_var.constrain("line_tool")
                ensight.query_ent_var.line_loc(1,-7.5000e-01,1.1561e+00,1.0000e+00)
                ensight.query_ent_var.line_loc(2,1.7500e+00,1.1561e+00,1.0000e+00)
                ensight.query_ent_var.variable_1("temperature")
                ensight.query_ent_var.generate_over("distance")
                ensight.query_ent_var.variable_2("DISTANCE")
                ensight.query_ent_var.end()
                ensight.query_ent_var.query()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.query_ent_var.variable_2({repr(args)})'''
        return self._session.cmd(cmd)


class ptrace_emitr:
    """Class wrapper for EnSight ptrace_emitr module

    This class acts as a proxy for the EnSight Python module ensight.ptrace_emitr
    """
    def __init__(self, session: Session):
        self._session = session

    def copy(self, p0: str) -> int:
        """Ptrace_emitr: copy

        """
        cmd = f'''ensight.ptrace_emitr.copy({repr(p0)})'''
        return self._session.cmd(cmd)

    def delete(self) -> int:
        """Ptrace_emitr: delete

        """
        cmd = f'''ensight.ptrace_emitr.delete()'''
        return self._session.cmd(cmd)

    def delta_time(self, p0: float) -> int:
        """Ptrace_emitr: delta_time

        """
        cmd = f'''ensight.ptrace_emitr.delta_time({repr(p0)})'''
        return self._session.cmd(cmd)

    def description(self, p0: str) -> int:
        """Ptrace_emitr: description

        """
        cmd = f'''ensight.ptrace_emitr.description({repr(p0)})'''
        return self._session.cmd(cmd)

    def elt_delete(self) -> int:
        """Ptrace_emitr: elt_delete

        """
        cmd = f'''ensight.ptrace_emitr.elt_delete()'''
        return self._session.cmd(cmd)

    def elt_net(self, p0: float, p1: float, p2: float, p3: float, p4: float, p5: float, p6: float, p7: float, p8: float, p9: float, p10: float) -> int:
        """Ptrace_emitr: elt_net

        """
        cmd = f'''ensight.ptrace_emitr.elt_net({repr(p0)},{repr(p1)},{repr(p2)},{repr(p3)},{repr(p4)},{repr(p5)},{repr(p6)},{repr(p7)},{repr(p8)},{repr(p9)},{repr(p10)})'''
        return self._session.cmd(cmd)

    def elt_part(self, p0: int) -> int:
        """Ptrace_emitr: elt_part

        """
        cmd = f'''ensight.ptrace_emitr.elt_part({repr(p0)})'''
        return self._session.cmd(cmd)

    def elt_point(self, p0: float, p1: float, p2: float) -> int:
        """Ptrace_emitr: elt_point

        """
        cmd = f'''ensight.ptrace_emitr.elt_point({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def elt_rake(self, p0: float, p1: float, p2: float, p3: float, p4: float, p5: float, p6: float) -> int:
        """Ptrace_emitr: elt_rake

        """
        cmd = f'''ensight.ptrace_emitr.elt_rake({repr(p0)},{repr(p1)},{repr(p2)},{repr(p3)},{repr(p4)},{repr(p5)},{repr(p6)})'''
        return self._session.cmd(cmd)

    def elt_surface_net(self, p0: float, p1: float, p2: float, p3: float, p4: float, p5: float) -> int:
        """Ptrace_emitr: elt_surface_net

        """
        cmd = f'''ensight.ptrace_emitr.elt_surface_net({repr(p0)},{repr(p1)},{repr(p2)},{repr(p3)},{repr(p4)},{repr(p5)})'''
        return self._session.cmd(cmd)

    def elt_surface_point(self, p0: float, p1: float) -> int:
        """Ptrace_emitr: elt_surface_point

        """
        cmd = f'''ensight.ptrace_emitr.elt_surface_point({repr(p0)},{repr(p1)})'''
        return self._session.cmd(cmd)

    def elt_surface_rake(self, p0: float, p1: float, p2: float, p3: float, p4: float) -> int:
        """Ptrace_emitr: elt_surface_rake

        """
        cmd = f'''ensight.ptrace_emitr.elt_surface_rake({repr(p0)},{repr(p1)},{repr(p2)},{repr(p3)},{repr(p4)})'''
        return self._session.cmd(cmd)

    def modify_begin(self) -> int:
        """Ptrace_emitr: modify_begin

        """
        cmd = f'''ensight.ptrace_emitr.modify_begin()'''
        return self._session.cmd(cmd)

    def modify_end(self) -> int:
        """Ptrace_emitr: modify_end

        """
        cmd = f'''ensight.ptrace_emitr.modify_end()'''
        return self._session.cmd(cmd)

    def new(self, p0: str) -> int:
        """Ptrace_emitr: new

        """
        cmd = f'''ensight.ptrace_emitr.new({repr(p0)})'''
        return self._session.cmd(cmd)

    def replaceelt_net(self, p0: float, p1: float, p2: float, p3: float, p4: float, p5: float, p6: float, p7: float, p8: float, p9: float, p10: float) -> int:
        """Ptrace_emitr: replaceelt_net

        """
        cmd = f'''ensight.ptrace_emitr.replaceelt_net({repr(p0)},{repr(p1)},{repr(p2)},{repr(p3)},{repr(p4)},{repr(p5)},{repr(p6)},{repr(p7)},{repr(p8)},{repr(p9)},{repr(p10)})'''
        return self._session.cmd(cmd)

    def replaceelt_point(self, p0: float, p1: float, p2: float) -> int:
        """Ptrace_emitr: replaceelt_point

        """
        cmd = f'''ensight.ptrace_emitr.replaceelt_point({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def replaceelt_rake(self, p0: float, p1: float, p2: float, p3: float, p4: float, p5: float, p6: float) -> int:
        """Ptrace_emitr: replaceelt_rake

        """
        cmd = f'''ensight.ptrace_emitr.replaceelt_rake({repr(p0)},{repr(p1)},{repr(p2)},{repr(p3)},{repr(p4)},{repr(p5)},{repr(p6)})'''
        return self._session.cmd(cmd)

    def restore(self, p0: str) -> int:
        """Ptrace_emitr: restore

        """
        cmd = f'''ensight.ptrace_emitr.restore({repr(p0)})'''
        return self._session.cmd(cmd)

    def rgb(self, p0: float, p1: float, p2: float) -> int:
        """Ptrace_emitr: rgb

        """
        cmd = f'''ensight.ptrace_emitr.rgb({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def save(self, p0: str) -> int:
        """Ptrace_emitr: save

        """
        cmd = f'''ensight.ptrace_emitr.save({repr(p0)})'''
        return self._session.cmd(cmd)

    def save_all(self, p0: str) -> int:
        """Ptrace_emitr: save_all

        """
        cmd = f'''ensight.ptrace_emitr.save_all({repr(p0)})'''
        return self._session.cmd(cmd)

    def select_begin(self, *args, **kwargs) -> Any:
        """Ptrace_emitr: select_begin

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.ptrace_emitr.select_begin({arg_string})"
        return self._session.cmd(cmd)

    def select_emitter_begin(self) -> int:
        """Ptrace_emitr: select_emitter_begin

        """
        cmd = f'''ensight.ptrace_emitr.select_emitter_begin()'''
        return self._session.cmd(cmd)

    def select_emitter_end(self) -> int:
        """Ptrace_emitr: select_emitter_end

        """
        cmd = f'''ensight.ptrace_emitr.select_emitter_end()'''
        return self._session.cmd(cmd)

    def start_time(self, p0: float) -> int:
        """Ptrace_emitr: start_time

        """
        cmd = f'''ensight.ptrace_emitr.start_time({repr(p0)})'''
        return self._session.cmd(cmd)

    def visible(self, p0: str) -> int:
        """Ptrace_emitr: visible

        """
        cmd = f'''ensight.ptrace_emitr.visible({repr(p0)})'''
        return self._session.cmd(cmd)


class ptrace:
    """Class wrapper for EnSight ptrace module

    This class acts as a proxy for the EnSight Python module ensight.ptrace
    """
    def __init__(self, session: Session):
        self._session = session

    def add_bypart(self, args: Any) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.ptrace.add_bypart({repr(args)})'''
        return self._session.cmd(cmd)

    def add_bypartname(self, p0: str, p1: str, p2: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.ptrace.add_bypartname({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def add_default_bypart(self, args: Any) -> int:
        """Ptrace: add_default_bypart

        """
        cmd = f'''ensight.ptrace.add_default_bypart({repr(args)})'''
        return self._session.cmd(cmd)

    def add_default_file(self, p0: str) -> int:
        """Ptrace: add_default_file

        """
        cmd = f'''ensight.ptrace.add_default_file({repr(p0)})'''
        return self._session.cmd(cmd)

    def add_default_net(self, p0: float, p1: float) -> int:
        """Ptrace: add_default_net

        """
        cmd = f'''ensight.ptrace.add_default_net({repr(p0)},{repr(p1)})'''
        return self._session.cmd(cmd)

    def add_default_pt(self) -> int:
        """Ptrace: add_default_pt

        """
        cmd = f'''ensight.ptrace.add_default_pt()'''
        return self._session.cmd(cmd)

    def add_default_rake(self, p0: float) -> int:
        """Ptrace: add_default_rake

        """
        cmd = f'''ensight.ptrace.add_default_rake({repr(p0)})'''
        return self._session.cmd(cmd)

    def add_default_surface_net(self, p0: float, p1: float, p2: float, p3: float, p4: float, p5: float) -> int:
        """Ptrace: add_default_surface_net

        """
        cmd = f'''ensight.ptrace.add_default_surface_net({repr(p0)},{repr(p1)},{repr(p2)},{repr(p3)},{repr(p4)},{repr(p5)})'''
        return self._session.cmd(cmd)

    def add_default_surface_pt(self, p0: float, p1: float) -> int:
        """Ptrace: add_default_surface_pt

        """
        cmd = f'''ensight.ptrace.add_default_surface_pt({repr(p0)},{repr(p1)})'''
        return self._session.cmd(cmd)

    def add_default_surface_rake(self, p0: float, p1: float, p2: float, p3: float, p4: float) -> int:
        """Ptrace: add_default_surface_rake

        """
        cmd = f'''ensight.ptrace.add_default_surface_rake({repr(p0)},{repr(p1)},{repr(p2)},{repr(p3)},{repr(p4)})'''
        return self._session.cmd(cmd)

    def add_file(self, p0: str) -> int:
        """Adds emitters (and thus more traces) to the current particle trace part(s) according to the time and locations as defined in the file.
        
        Args:
            p0:
                'filename' The name of the emitter file
        
        Examples:
            ::
        
                #
                # Add emitters to a currently defined particle trace part 3
                # 
                #
                ensight.part.select_begin(3)
                ensight.ptrace.add_file("/tmp/emitter.file")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.ptrace.add_file({repr(p0)})'''
        return self._session.cmd(cmd)

    def add_net(self, p0: float, p1: float) -> int:
        """Add emitters (and thus more traces) to the current particle trace part(s) from
        
        | Any existing particle trace parts can have emitters added to them. These trace parts must be selected, and the plane tool must be at the new position, before the addition.  The number of additional emitter points will be the product of num_in_x * num_in_y.
        
        Args:
            p0:
                'num_in_x ' number of equally spaced points in the x direction of the plane tool
            p1:
                'num_in_y' number of equally spaced points in the y direction of the plane tool
        
        Examples:
            ::
        
                #
                # Getting the plane tool to the desired location
                #
                ensight.view_transf.plane(1,1.750000,2.700000,0.000000)
                ensight.view_transf.plane(2,13.000000,2.700000,0.000000)
                ensight.view_transf.plane(3,13.000000,9.500000,0.000000)
                #
                # Selecting the parent part(s)
                #
                ensight.part.select_begin(1)
                #
                # Setting some attributes before creation
                # (others are the current defaults)
                #
                ensight.ptrace.begin()
                ensight.ptrace.variable("VITESSE")
                ensight.ptrace.type("streamline")
                ensight.ptrace.component(1.0000e+00,1.0000e+00,1.0000e+00)
                ensight.ptrace.representation("line")
                ensight.ptrace.emit_at_current_time("ON")
                ensight.ptrace.end()
                #
                # Creating 35 traces from the plane tool (becomes part 2)
                #
                ensight.ptrace.create_net(5,7)
                #
                # Moving the plane tool to a new location
                #
                ensight.tools.plane("ON")
                ensight.view_transf.function("plane")
                ensight.view_transf.scale(-0.522802,-1.195307,1.000000)
                ensight.view_transf.translate(-10.588167,-0.218373,0.000000)
                ensight.view_transf.function("global")
                #
                # Selecting the particle trace part to add to
                # and adding the 9 new emitters from which
                # more traces are made
                #
                ensight.part.select_begin(2)
                ensight.ptrace.add_net(3,3)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.ptrace.add_net({repr(p0)},{repr(p1)})'''
        return self._session.cmd(cmd)

    def add_part(self, p0: int) -> int:
        """Ptrace: add_part

        """
        cmd = f'''ensight.ptrace.add_part({repr(p0)})'''
        return self._session.cmd(cmd)

    def add_partbyname(self, p0: str) -> int:
        """Ptrace: add_partbyname

        """
        cmd = f'''ensight.ptrace.add_partbyname({repr(p0)})'''
        return self._session.cmd(cmd)

    def add_pt(self) -> int:
        """Adds emitters (and thus more traces) to the current particle trace part(s) from the current location of the cursor (a point).
        
        | Any existing particle trace part can have emitters added to them. These trace parts must be selected, and the cursor must be at the new location, before the addition.
        
        Examples:
            ::
        
                #
                # Getting the cursor to the desired location
                #
                ensight.view_transf.cursor(-0.927830,1.474020,0.000000)
                #
                # Selecting the parent part(s)
                #
                ensight.part.select_begin(1)
                #
                # Setting some attributes before creation
                # (others are the current defaults)
                #
                ensight.ptrace.begin()
                ensight.ptrace.variable("VITESSE")
                ensight.ptrace.type("streamline")
                ensight.ptrace.component(1.0000e+00,1.0000e+00,1.0000e+00)
                ensight.ptrace.representation("line")
                ensight.ptrace.emit_at_current_time("ON")
                ensight.ptrace.end()
                #
                # Creating trace from a point (becomes part 2)
                #
                ensight.ptrace.create_pt()
                #
                # Moving the cursor to a new location
                #
                ensight.tools.cursor("ON")
                ensight.view_transf.function("cursor")
                ensight.view_transf.translate(-7.368053,-0.491341,0.000000)
                ensight.view_transf.function("global")
                #
                # Selecting the particle trace part to add to
                # and adding the new emitter from which another
                # trace is made
                #
                ensight.part.select_begin(2)
                ensight.ptrace.add_pt()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.ptrace.add_pt()'''
        return self._session.cmd(cmd)

    def add_rake(self, p0: float) -> int:
        """Add emitters (and thus more traces) to the current particle trace part(s) from the current line tool.
        
        | Any existing particle trace part can have emitters added to them. These trace parts must be selected, and the line tool must be at the new position, before the addition.
        
        Args:
            p0:
                'num_points' number of equally spaced points on the line to use as emitters
        
        Examples:
            ::
        
                #
                # Getting the line tool to the desired location
                #
                ensight.view_transf.line(1,9.000000,6.000000,0.000000)
                ensight.view_transf.line(2,30.000000,6.000000,0.000000)
                #
                # Selecting the parent part(s)
                #
                ensight.part.select_begin(1)
                #
                # Setting some attributes before creation
                # (others are the current defaults)
                #
                ensight.ptrace.begin()
                ensight.ptrace.variable("VITESSE")
                ensight.ptrace.type("streamline")
                ensight.ptrace.component(1.0000e+00,1.0000e+00,1.0000e+00)
                ensight.ptrace.representation("line")
                ensight.ptrace.emit_at_current_time("ON")
                ensight.ptrace.end()
                #
                # Creating 10 traces from a line tool (becomes part 2)
                #
                ensight.ptrace.create_rake(10)
                #
                # Moving the line tool to a new location
                #
                ensight.tools.line("ON")
                ensight.view_transf.function("line")
                ensight.view_transf.translate(-4.202520,4.531246,0.000000)
                ensight.view_transf.function("global")
                #
                # Selecting the particle trace part to add to
                # and adding the 6 new emitters from which more
                # traces are made
                #
                ensight.part.select_begin(2)
                ensight.ptrace.add_rake(6)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.ptrace.add_rake({repr(p0)})'''
        return self._session.cmd(cmd)

    def add_surface_net(self, p0: float, p1: float, p2: float, p3: float, p4: float, p5: float) -> int:
        """Add emitters (and thus more traces) to the current particle trace part(s) from the grid of a screen box pick.
        
        | The "ptrace: surface_restricted" command must be ON prior to this command. 
        | Any existing particle trace parts can have emitters added to them. These trace parts must be selected before the addition. 
        | The number of additional emitter points will be the product of num_in_x * num_in_y.
        
        Args:
            p0:
                'num_in_x' number of equally spaced points in the x direction of the plane tool
            p1:
                'num_in_y' number of equally spaced points in the y direction of the plane tool
            p2:
                'x1' screen x coordinate of the first point on the diagonal of the box (0.0 to 1.0) 
            p3:
                'y1' screen y coordinate of the first point on the diagonal of the box (0.0 to 1.0)
            p4:
                'x2 ' screen x coordinate of the second point on the diagonal of the box (0.0 to 1.0)
            p5:
                'y2' screen y coordinate of the second point on the diagonal of the box (0.0 to 1.0)
        
        Examples:
            ::
        
                #
                # Selecting the parent part(s)
                #
                ensight.part.select_begin(1)
                #
                # Setting some attributes before creation
                # (surface_restricted must be on)
                #
                ensight.ptrace.begin()
                ensight.ptrace.surface_restricted("ON")
                ensight.ptrace.variable("VITESSE")
                ensight.ptrace.type("streamline")
                ensight.ptrace.component(1.0000e+00,1.0000e+00,1.0000e+00)
                ensight.ptrace.representation("line")
                ensight.ptrace.emit_at_current_time("ON")
                ensight.ptrace.end()
                #
                # Creating 35 surface restricted traces from
                # the box selection (becomes part 2)
                #
                ensight.ptrace.create_surface_net(5,7)
                #
                # Selecting the surface restricted particle trace
                # part to add to, and adding the 16 new emitters
                # from which more traces are made
                #
                ensight.part.select_begin(2)
                ensight.ptrace.create_surface_net(4,4,0.114734,0.424963,0.166667,0.362556)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.ptrace.add_surface_net({repr(p0)},{repr(p1)},{repr(p2)},{repr(p3)},{repr(p4)},{repr(p5)})'''
        return self._session.cmd(cmd)

    def add_surface_pt(self, p0: float, p1: float) -> int:
        """Adds emitters (and thus more traces) to the current surface restricted particle trace part(s) from a screen point pick location.
        
        | The "ptrace: surface_restricted" command must be ON prior to this command.  Any existing surface restricted particle trace part can have emitters added to them. These trace parts must be selected before the addition.
        
        Args:
            p0:
                'screen_x' screen x coordinate (0.0 to 1.0)
            p1:
                'screen_y' screen y coordinate (0.0 to 1.0)
        
        Examples:
            ::
        
                #
                # Getting the cursor to the desired location
                #
                ensight.view_transf.cursor(-0.927830,1.474020,0.000000)
                #
                # Selecting the parent part(s)
                #
                ensight.part.select_begin(1)
                #
                # Setting some attributes before creation
                # (surface_restricted must be on)
                #
                ensight.ptrace.begin()
                ensight.ptrace.surface_restricted("ON")
                ensight.ptrace.variable("VITESSE")
                ensight.ptrace.type("streamline")
                ensight.ptrace.component(1.0000e+00,1.0000e+00,1.0000e+00)
                ensight.ptrace.representation("line")
                ensight.ptrace.emit_at_current_time("ON")
                ensight.ptrace.end()
                #
                # Creating surface restricted trace from a
                # screen location (becomes part 2)
                #
                ensight.ptrace.create_surface_pt(0.148551,0.484398)
                #
                # Selecting the particle trace part to add to
                # and adding a couple of new emitters from which
                # more traces are made
                #
                ensight.part.select_begin(2)
                ensight.ptrace.add_surface_pt(0.136473,0.646360)
                ensight.ptrace.add_surface_pt(0.193237,0.546805)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.ptrace.add_surface_pt({repr(p0)},{repr(p1)})'''
        return self._session.cmd(cmd)

    def add_surface_rake(self, p0: float, p1: float, p2: float, p3: float, p4: float) -> int:
        """Add emitters (and thus more traces) to the current surface restricted particle trace part(s) from a screen pick rake location.
        
        | The "ptrace: surface_restricted" command must be ON prior to this command. Any existing particle trace parts can have emitters added to them. These trace parts must be selected before the addition.
        
        Args:
            p0:
                'num_points' number of equally spaced points on the line to use as emitters
            p1:
                'x1' screen x coordinate of the first end of the rake (0.0 to 1.0)
            p2:
                'y1' screen y coordinate of the first end of the rake (0.0 to 1.0)
            p3:
                'x2' screen x coordinate of the second end of the rake (0.0 to 1.0)
            p4:
                'y2' screen y coordinate of the second end of the rake (0.0 to1.0)
        
        Examples:
            ::
        
                #
                # Getting the line tool to the desired location
                #
                ensight.view_transf.line(1,9.000000,6.000000,0.000000)
                ensight.view_transf.line(2,30.000000,6.000000,0.000000)
                #
                # Selecting the parent part(s)
                #
                ensight.part.select_begin(1)
                #
                # Setting some attributes before creation
                # (surface_restricted must be on)
                #
                ensight.ptrace.begin()
                ensight.ptrace.surface_restricted("ON")
                ensight.ptrace.variable("VITESSE")
                ensight.ptrace.type("streamline")
                ensight.ptrace.component(1.0000e+00,1.0000e+00,1.0000e+00)
                ensight.ptrace.representation("line")
                ensight.ptrace.emit_at_current_time("ON")
                ensight.ptrace.end()
                #
                # Creating 10 surface restricted traces from
                # a rake pick location (becomes part 2)
                #
                ensight.ptrace.create_surface_rake(10,0.117150,0.540862,0.117150,0.442793)
                #
                # Selecting the particle trace part to add to
                # and adding 6 new emitters from which more
                # traces are made
                #
                ensight.part.select_begin(2)
                ensight.ptrace.add_surface_rake(6,0.129227,0.594354,0.188406,0.592868)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.ptrace.add_surface_rake({repr(p0)},{repr(p1)},{repr(p2)},{repr(p3)},{repr(p4)})'''
        return self._session.cmd(cmd)

    def animate(self, p0: str) -> int:
        """Toggles particle trace animation on or off for selected traces.  
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                #
                # Selecting the trace(s) to animate
                #
                ensight.part.select_begin(7,8)
                #
                # Turning on the animation for the two selected trace parts
                #
                ensight.part.modify_begin()
                ensight.ptrace.animate("ON")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.ptrace.animate({repr(p0)})'''
        return self._session.cmd(cmd)

    def arrow_size(self, p0: float) -> int:
        """Specify the size of arrowheads to show along particle traces.
        
        | The size is according to the magnitude of the model coordinates.
        
        Args:
            p0:
                'size' size of the arrowheads shown along each trace
        
        Examples:
            ::
        
                #
                # modifying an existing particle trace that has the default of
                # of 3 normal arrows per trace to be 5 cone arrows.
                #
                ensight.part.select_begin(2)
                ensight.part.modify_begin()
                ensight.ptrace.arrows("cone")
                ensight.ptrace.number_of_arrows(5)
                ensight.ptrace.arrow_size(0.15)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.ptrace.arrow_size({repr(p0)})'''
        return self._session.cmd(cmd)

    def arrows(self, p0: str) -> int:
        """Specify the type of arrowheads to show along particle traces.
        
        | None.
        
        Args:
            p0:
                'type'
        
                * none
                * cone
                * normal
                * triangles
        
        Examples:
            ::
        
                #
                # modifying an existing particle trace that has the default of
                # of 3 normal arrows per trace to be 5 cone arrows.
                #
                ensight.part.select_begin(2)
                ensight.part.modify_begin()
                ensight.ptrace.arrows("cone")
                ensight.ptrace.number_of_arrows(5)
                ensight.ptrace.arrow_size(0.15)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.ptrace.arrows({repr(p0)})'''
        return self._session.cmd(cmd)

    def begin(self) -> int:
        """Delimit the modifications for particle trace attributes.
        
        | These commands are used to set the attributes for particle trace part creation.
        
        Args:
            p0:
                'ptrace_command' any of the various attribute changing "ptrace:" commands
        
        Examples:
            ::
        
                #
                # Selecting the parent part
                #
                ensight.part.select_begin(1)
                #
                # Setting some attributes before creation
                #
                ensight.ptrace.begin()
                ensight.ptrace.type("streamline")
                ensight.ptrace.component(1.0000e+00,1.0000e+00,1.0000e+00)
                ensight.ptrace.representation("line")
                ensight.ptrace.end()
                #
                # Creating trace from a point
                #
                ensight.ptrace.create_pt()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.ptrace.begin()'''
        return self._session.cmd(cmd)

    def color_emission(self, p0: float, p1: float, p2: float, p3: float) -> int:
        """Ptrace: color_emission

        """
        cmd = f'''ensight.ptrace.color_emission({repr(p0)},{repr(p1)},{repr(p2)},{repr(p3)})'''
        return self._session.cmd(cmd)

    def component(self, p0: float, p1: float, p2: float) -> int:
        """Specifies the contribution of the components of the flow field vector variable through which the particle trace will be integrated.
        
        | The normal situation is to have all three set to 1.0, to get the true vector field.
        
        Args:
            p0:
                'x_scal' scale factor to apply to the x, y, z components of the vector
            p1:
                'y_scal' scale factor to apply to the x, y, z components of the vector
            p2:
                'z_scal' scale factor to apply to the x, y, z components of the vector
        
        Examples:
            ::
        
                #
                # Selecting the parent part
                #
                ensight.part.select_begin(1)
                #
                # Setting some attributes before creation
                # (the components are being set here)
                #
                ensight.ptrace.begin()
                ensight.ptrace.type("streamline")
                #
                # Create the particle trace with
                # the x and y components of the vector
                #
                ensight.ptrace.component(1.0000e+00,1.0000e+00,0.0000e+00)
                ensight.ptrace.representation("line")
                ensight.ptrace.end()
                #
                # Creating trace from a point
                #
                ensight.ptrace.create_pt()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.ptrace.component({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def compute_using_periodicity(self, p0: str) -> int:
        """Ptrace: compute_using_periodicity

        """
        cmd = f'''ensight.ptrace.compute_using_periodicity({repr(p0)})'''
        return self._session.cmd(cmd)

    def create_bypart(self, *args, **kwargs) -> Any:
        """Ptrace: create_bypart

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.ptrace.create_bypart({arg_string})"
        return self._session.cmd(cmd)

    def create_bypartname(self, p0: str, p1: str, p2: str) -> int:
        """Create a particle trace from the nodes of a part, where the part is referred to by name.
        
        | The default attributes and/or any "ptrace:" attribute commands between "ptrace: begin" and "ptrace: end" commands are used for the trace creation. A parent part or parts (containing the flow field) must be selected prior to this command. The number of emitter points will be the number of nodes in the part multiplied by the "ptrace: emit_density" value.
        
        Args:
            p0:
                'part_name' name of the part whose nodes will be used as an emitter
            p1:
                'numemitpoints' number of emitters to use.  The minimum of this value and the number of nodes in the part will be used.
        
        Examples:
            ::
        
                #
                # Selecting the parent part(s)
                #
                ensight.part.select_begin(1,3,4)
                #
                # Setting some attributes before creation
                # (others are the current defaults)
                #
                ensight.ptrace.begin()
                ensight.ptrace.variable("VITESSE")
                ensight.ptrace.type("streamline")
                ensight.ptrace.component(1.0000e+00,1.0000e+00,1.0000e+00)
                ensight.ptrace.representation("line")
                ensight.ptrace.emit_at_current_time("ON")
                # WARNING: following line includes OBSOLETE call (ensight.ptrace.emit_density).
                ensight.ptrace.emit_density(1.0000e+00)
                ensight.ptrace.end()
                #
                # Creating traces from all the nodes of the part 
                # entitled "(CASE:Case 1)Clip_line"
                #
                ensight.ptrace.create_bypartname("(CASE:Case","1)Clip_line","100")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.ptrace.create_bypartname({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def create_default(self) -> int:
        """Ptrace: create_default

        """
        cmd = f'''ensight.ptrace.create_default()'''
        return self._session.cmd(cmd)

    def create_file(self, p0: str) -> int:
        """Create particle traces from the current location of the line tool.
        
        Args:
            p0:
                'filename' The name of the emitter file
        
        Examples:
            ::
        
                #
                # Create particle traces through part 1 by releasing
                # emitters as defined in the given file
                #
                ensight.part.select_begin(1)
                ensight.ptrace.begin()
                ensight.ptrace.variable("VITESSE")
                ensight.ptrace.type("streamline")
                ensight.ptrace.create_file("/tmp/emitter.file")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.ptrace.create_file({repr(p0)})'''
        return self._session.cmd(cmd)

    def create_net(self, p0: int, p1: int) -> int:
        """Create particle traces from the plane tool.
        
        | The default attributes and/or any "ptrace:" attribute commands between "ptrace: begin" and "ptrace: end" commands are used for the trace creation. 
        | A parent part or parts (containing the flow field) must be selected prior to this command. You need the plane tool to be at the desired location.  
        | The number of emitter points will be the product of num_in_x * num_in_y.
        
        Args:
            p0:
                'num_in_x ' number of equally spaced points in the x direction of the plane tool
            p1:
                'num_in_y ' number of equally spaced points in the y direction of the plane tool
        
        Examples:
            ::
        
                #
                # Getting the plane tool to the desired location
                #
                ensight.view_transf.plane(1,1.750000,2.700000,0.000000)
                ensight.view_transf.plane(2,13.000000,2.700000,0.000000)
                ensight.view_transf.plane(3,13.000000,9.500000,0.000000)
                #
                # Selecting the parent part(s)
                #
                ensight.part.select_begin(1,3,4)
                #
                # Setting some attributes before creation
                # (others are the current defaults)
                #
                ensight.ptrace.begin()
                ensight.ptrace.variable("VITESSE")
                ensight.ptrace.type("streamline")
                ensight.ptrace.component(1.0000e+00,1.0000e+00,1.0000e+00)
                ensight.ptrace.representation("line")
                ensight.ptrace.emit_at_current_time("ON")
                ensight.ptrace.end()
                #
                # Creating 35 traces from the plane tool
                #
                ensight.ptrace.create_net(5,7)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.ptrace.create_net({repr(p0)},{repr(p1)})'''
        return self._session.cmd(cmd)

    def create_node_track(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.ptrace.create_node_track()'''
        return self._session.cmd(cmd)

    def create_part(self, p0: int) -> int:
        """Ptrace: create_part

        """
        cmd = f'''ensight.ptrace.create_part({repr(p0)})'''
        return self._session.cmd(cmd)

    def create_partbyname(self, p0: str) -> int:
        """Ptrace: create_partbyname

        """
        cmd = f'''ensight.ptrace.create_partbyname({repr(p0)})'''
        return self._session.cmd(cmd)

    def create_pt(self) -> int:
        """Create a particle trace from the current location of the cursor (a point).
        
        | The default attributes and/or any "ptrace:" attribute commands between "ptrace: begin" and "ptrace: end" commands are used for the trace creation. A parent part or parts (containing the flow field) must be selected prior to this command, and you need the cursor to be at the desired location.
        
        Examples:
            ::
        
                #
                # Getting the cursor to the desired location
                #
                ensight.view_transf.cursor(-0.927830,1.474020,0.000000)
                #
                # Selecting the parent part(s)
                #
                ensight.part.select_begin(1,3,4)
                #
                # Setting some attributes before creation
                # (others are the current defaults)
                #
                ensight.ptrace.begin()
                ensight.ptrace.variable("VITESSE")
                ensight.ptrace.type("streamline")
                ensight.ptrace.component(1.0000e+00,1.0000e+00,1.0000e+00)
                ensight.ptrace.representation("line")
                ensight.ptrace.emit_at_current_time("ON")
                ensight.ptrace.end()
                #
                # Creating trace from a point
                #
                ensight.ptrace.create_pt()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.ptrace.create_pt()'''
        return self._session.cmd(cmd)

    def create_rake(self, p0: int) -> int:
        """Create particle traces from the current location of the line tool.
        
        | The default attributes and/or any "ptrace:" attribute commands between "ptrace: begin" and "ptrace: end" commands are used for the trace creation. A parent part or parts (containing the flow field) must be selected prior to this command, and you need the line tool to be at the desired location.
        
        Args:
            p0:
                'num_points' number of equally spaced points on the line to use as emitters
        
        Examples:
            ::
        
                #
                # Getting the line tool to the desired location
                #
                ensight.view_transf.line(1,9.000000,6.000000,0.000000)
                ensight.view_transf.line(2,30.000000,6.000000,0.000000)
                #
                # Selecting the parent part(s)
                #
                ensight.part.select_begin(1,3,4)
                #
                # Setting some attributes before creation
                # (others are the current defaults)
                #
                ensight.ptrace.begin()
                ensight.ptrace.variable("VITESSE")
                ensight.ptrace.type("streamline")
                ensight.ptrace.component(1.0000e+00,1.0000e+00,1.0000e+00)
                ensight.ptrace.representation("line")
                ensight.ptrace.emit_at_current_time("ON")
                ensight.ptrace.end()
                #
                # Creating 10 traces from a line tool
                #
                ensight.ptrace.create_rake(10)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.ptrace.create_rake({repr(p0)})'''
        return self._session.cmd(cmd)

    def create_surface_net(self, p0: float, p1: float, p2: float, p3: float, p4: float, p5: float) -> int:
        """Create surface restricted particle traces from a screen box pick.
        
        | The "ptrace: surface_restricted" command must be ON prior to this command. 
        | The default attributes and/or any "ptrace:" attribute commands between "ptrace: begin" and "ptrace: end" commands are used for the trace creation. A parent part or parts (containing the flow field) must be selected prior to this command. The number of emitter points will be the product of num_in_x * num_in_y.
        
        Args:
            p0:
                'num_in_x' number of equally spaced points in the x direction of the box pick
            p1:
                'num_in_y' number of equally spaced points in the y direction of the box pick
            p2:
                'x1' screen x coordinate of the first point on the diagonal of the box (0.0 to 1.0)
            p3:
                'y1' screen y coordinate of the first point on the diagonal of the box (0.0 to 1.0)
            p4:
                'x2' screen x coordinate of the second point on the diagonal of the box (0.0 to 1.0)
            p5:
                'y2' screen y coordinate of the second point on the diagonal of the box (0.0 to 1.0)
        
        Examples:
            ::
        
                ensight.part.select_begin(1,3,4)
                #
                # Setting some attributes before creation
                # (surface_restricted must be on)
                #
                ensight.ptrace.begin()
                ensight.ptrace.surface_restricted("ON")
                ensight.ptrace.variable("VITESSE")
                ensight.ptrace.type("streamline")
                ensight.ptrace.component(1.0000e+00,1.0000e+00,1.0000e+00)
                ensight.ptrace.representation("line")
                ensight.ptrace.emit_at_current_time("ON")
                ensight.ptrace.end()
                #
                # Creating 35 traces from the box selection
                #
                ensight.ptrace.create_surface_net(5,7)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.ptrace.create_surface_net({repr(p0)},{repr(p1)},{repr(p2)},{repr(p3)},{repr(p4)},{repr(p5)})'''
        return self._session.cmd(cmd)

    def create_surface_pt(self, p0: float, p1: float) -> int:
        """Create a surface restricted particle trace from a screen point pick location.
        
        | The "ptrace: surface_restricted" command must be ON prior to this command. 
        | The default attributes and/or any "ptrace:" attribute commands between "ptrace: begin" and "ptrace: end" commands are used for the trace creation. A parent part or parts (containing the flow field) must be selected prior to this command.
        
        Args:
            p0:
                'screen_x' screen x coordinate (0.0 to 1.0)
            p1:
                'screen_y' screen y coordinate (0.0 to 1.0)
        
        Examples:
            ::
        
                #
                # Selecting the parent part(s)
                #
                ensight.part.select_begin(1,3,4)
                #
                # Setting some attributes before creation
                # (surface_restricted must be on)
                #
                ensight.ptrace.begin()
                ensight.ptrace.surface_restricted("ON")
                ensight.ptrace.variable("VITESSE")
                ensight.ptrace.type("streamline")
                ensight.ptrace.component(1.0000e+00,1.0000e+00,1.0000e+00)
                ensight.ptrace.representation("line")
                ensight.ptrace.emit_at_current_time("ON")
                ensight.ptrace.end()
                #
                # Creating surface restricted trace from a screen location
                #
                ensight.ptrace.create_surface_pt(0.148551,0.484398)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.ptrace.create_surface_pt({repr(p0)},{repr(p1)})'''
        return self._session.cmd(cmd)

    def create_surface_rake(self, p0: float, p1: float, p2: float, p3: float, p4: float) -> int:
        """Create surface restricted particle traces from a screen pick rake location.
        
        | The "ptrace: surface_restricted" command must be ON prior to this command. 
        | The default attributes and/or any "ptrace:" attribute commands between "ptrace: begin" and "ptrace: end" commands are used for the trace creation. A parent part or parts (containing the flow field) must be selected prior to this command.
        
        Args:
            p0:
                'num_points' number of equally spaced points along the rake to use as emitters
            p1:
                'x1' screen x coordinate of the first end of the rake (0.0 to 1.0)
            p2:
                'y1' screen y coordinate of the first end of the rake (0.0 to 1.0)
            p3:
                'x2' screen x coordinate of the second end of the rake (0.0 to 1.0)
            p4:
                'y2' screen y coordinate of the second end of the rake (0.0 to 1.0)
        
        Examples:
            ::
        
                #
                # Selecting the parent part(s)
                #
                ensight.part.select_begin(1,3,4)
                #
                # Setting some attributes before creation
                # (surface_restricted must be on)
                #
                ensight.ptrace.begin()
                ensight.ptrace.surface_restricted("ON")
                ensight.ptrace.variable("VITESSE")
                ensight.ptrace.type("streamline")
                ensight.ptrace.component(1.0000e+00,1.0000e+00,1.0000e+00)
                ensight.ptrace.representation("line")
                ensight.ptrace.emit_at_current_time("ON")
                ensight.ptrace.end()
                #
                # Creating 10 traces from a screen rake location
                #
                ensight.ptrace.create_surface_rake(10,0.117150,0.540862,0.117150,0.442793)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.ptrace.create_surface_rake({repr(p0)},{repr(p1)},{repr(p2)},{repr(p3)},{repr(p4)})'''
        return self._session.cmd(cmd)

    def create_varmax_track(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.ptrace.create_varmax_track()'''
        return self._session.cmd(cmd)

    def create_varmin_track(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.ptrace.create_varmin_track()'''
        return self._session.cmd(cmd)

    def default_emit_bypart(self, *args, **kwargs) -> Any:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.ptrace.default_emit_bypart({arg_string})"
        return self._session.cmd(cmd)

    def default_emit_bypartname(self, p0: str, p1: str, p2: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.ptrace.default_emit_bypartname({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def default_emit_file(self, p0: str) -> int:
        """Set the default filename for file emitters and sets the user interface Emit From option to be File.
        
        Args:
            p0:
                'filename' The default emitter file name
        
        Examples:
            ::
        
                #
                # Set the default file emitter
                #
                ensight.ptrace.default_emit_file("/tmp/emitter.file")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.ptrace.default_emit_file({repr(p0)})'''
        return self._session.cmd(cmd)

    def default_emit_net(self, p0: int, p1: int) -> int:
        """Set the default number of x and y grid points for net emitters, and sets the user interface Emit From option to be Plane.
        
        | Mainly used to set the default "Emit From" option in the user interface, but also sets the default number of x and y grid points. Any subsequent particle traces created using a net will use this unless changed specifically.
        
        Args:
            p0:
                'num_in_x' number of emission points to be the default for x direction of net
            p1:
                'num_in_y' number of emission points to be the default for y direction of net
        
        Examples:
            ::
        
                #
                # Set the default number of emission points
                # for nets to be 10 x 12 in this case
                #
                ensight.ptrace.default_emit_net(10,12)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.ptrace.default_emit_net({repr(p0)},{repr(p1)})'''
        return self._session.cmd(cmd)

    def default_emit_part(self, p0: int) -> int:
        """Ptrace: default_emit_part

        """
        cmd = f'''ensight.ptrace.default_emit_part({repr(p0)})'''
        return self._session.cmd(cmd)

    def default_emit_partbyname(self, p0: str) -> int:
        """Ptrace: default_emit_partbyname

        """
        cmd = f'''ensight.ptrace.default_emit_partbyname({repr(p0)})'''
        return self._session.cmd(cmd)

    def default_emit_pt(self) -> int:
        """Set the user interface Emit From option to be Cursor.
        
        | Sets the default "Emit From" in the user interface.
        
        Examples:
            ::
        
                ensight.ptrace.default_emit_pt()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.ptrace.default_emit_pt()'''
        return self._session.cmd(cmd)

    def default_emit_rake(self, p0: int) -> int:
        """Set the default number of emission points for rake emitters, and sets the user interface Emit From option to be Line.
        
        | Mainly used to set the default "Emit From" option in the user interface, but also sets the default number of rake emission points. Any subsequent particle traces created using a rake will use this unless changed specifically.
        
        Args:
            p0:
                'num' the number of emission points to be the default for rakes
        
        Examples:
            ::
        
                #
                # Set the default number of emission points
                # for rakes to be 10 in this case
                #
                ensight.ptrace.default_emit_rake(10)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.ptrace.default_emit_rake({repr(p0)})'''
        return self._session.cmd(cmd)

    def delete_emitter(self) -> int:
        """Remove emitters from a particle trace part (and their associated traces).
        
        | The desired emitter for the particle trace part must be selected before this command is issued.
        
        Examples:
            ::
        
                #
                # Selecting the parent part(s)
                #
                ensight.part.select_begin(2)
                #
                # Selecting the emitter within the part
                # (in this case we will delete the first 3 emitters)
                #
                ensight.ptrace.select_emitter_begin(0,1,2)
                ensight.ptrace.delete_emitter()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.ptrace.delete_emitter()'''
        return self._session.cmd(cmd)

    def delta_time(self, p0: float) -> int:
        """Specifies the time interval between emissions from the emitters.
        
        | Particles will be traced starting at the current time step or the time specified with ptrace: start_time.  Additional particles will be released every "emit_delta" time units.
        | Most useful for pathline generation.
        
        Args:
            p0:
                'emit_delta' the time interval between emissions. (The default is 0.0, which will cause only the initial emission to take place
        
        Examples:
            ::
        
                #
                # Selecting the parent part
                #
                ensight.part.select_begin(1)
                #
                # Setting some attributes before creation
                # (the delta_time is being set here, to emit
                #  every 2.5 time units)
                #
                ensight.ptrace.begin()
                ensight.ptrace.variable("VITESSE")
                ensight.ptrace.type("streamline")
                ensight.ptrace.component(1.0000e+00,1.0000e+00,1.0000e+00)
                ensight.ptrace.representation("line")
                ensight.ptrace.start_time(1.5000e+01)
                ensight.ptrace.delta_time(2.5000e+00)
                ensight.ptrace.end()
                #
                # Creating trace from a point
                #
                ensight.ptrace.create_pt()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.ptrace.delta_time({repr(p0)})'''
        return self._session.cmd(cmd)

    def display_offset(self, p0: float) -> int:
        """Sets the distance normal to the surface at which the surface restricted trace will be displayed. This can be used to avoid z-buffer display problems that arise because the trace lies in the same plane as the surface. 
        
        | A positive number moves the trace in the direction of the positive surface normal, while a negative number moves in the opposite direction.
        
        Args:
            p0:
                'offset_distance' the distance normal to the surface at which to display the trace
        
        Examples:
            ::
        
                #
                # Selecting the parent part
                #
                ensight.part.select_begin(1)
                #
                # Setting some attributes before creation
                # (the  display_offset for the surface restricted trace
                #  is being set here)
                #
                ensight.ptrace.begin()
                ensight.part.description("Particle trace part")
                ensight.ptrace.surface_restricted("ON")
                ensight.ptrace.variable_offset(1.0000e-01)
                ensight.ptrace.display_offset(-0.5000e+00)
                ensight.ptrace.total_time(2.0000e+02)
                ensight.ptrace.emit_at_current_time("ON")
                ensight.ptrace.end()
                #
                # Creating trace from a point
                #
                ensight.ptrace.create_pt()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.ptrace.display_offset({repr(p0)})'''
        return self._session.cmd(cmd)

    def dummy_chng_slot(self, args: Any) -> int:
        """Ptrace: dummy_chng_slot

        """
        cmd = f'''ensight.ptrace.dummy_chng_slot({repr(args)})'''
        return self._session.cmd(cmd)

    def elt_part(self, p0: int) -> int:
        """Ptrace: elt_part

        """
        cmd = f'''ensight.ptrace.elt_part({repr(p0)})'''
        return self._session.cmd(cmd)

    def elt_partbyname(self, p0: str) -> int:
        """Ptrace: elt_partbyname

        """
        cmd = f'''ensight.ptrace.elt_partbyname({repr(p0)})'''
        return self._session.cmd(cmd)

    def emit_at_current_time(self, p0: str) -> int:
        """Sets the emission time for a particle trace to be current time when the particle trace is created.  The particle trace is also updated whenever time is changed.
        
        | While this flag is ON, the "ptrace: start_time" is not used.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                #
                # Selecting the parent part
                #
                ensight.part.select_begin(1)
                #
                # Setting some attributes before creation
                # (the emit_at_current_time flag is being set here)
                #
                ensight.ptrace.begin()
                ensight.ptrace.variable("VITESSE")
                ensight.ptrace.type("streamline")
                ensight.ptrace.component(1.0000e+00,1.0000e+00,1.0000e+00)
                ensight.ptrace.representation("line")
                ensight.ptrace.emit_at_current_time("ON")
                ensight.ptrace.end()
                #
                # Creating trace from a point
                #
                ensight.ptrace.create_pt()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.ptrace.emit_at_current_time({repr(p0)})'''
        return self._session.cmd(cmd)

    def emit_density(self, p0: float) -> int:
        """Ptrace: emit_density

        """
        cmd = f'''ensight.ptrace.emit_density({repr(p0)})'''
        return self._session.cmd(cmd)

    def end(self) -> int:
        """Delimit the modifications for particle trace attributes.
        
        | These commands are used to set the attributes for particle trace part creation.
        
        Args:
            p0:
                'ptrace_command' any of the various attribute changing "ptrace:" commands
        
        Examples:
            ::
        
                #
                # Selecting the parent part
                #
                ensight.part.select_begin(1)
                #
                # Setting some attributes before creation
                #
                ensight.ptrace.begin()
                ensight.ptrace.type("streamline")
                ensight.ptrace.component(1.0000e+00,1.0000e+00,1.0000e+00)
                ensight.ptrace.representation("line")
                ensight.ptrace.end()
                #
                # Creating trace from a point
                #
                ensight.ptrace.create_pt()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.ptrace.end()'''
        return self._session.cmd(cmd)

    def hide_emission(self, p0: int) -> int:
        """Ptrace: hide_emission

        """
        cmd = f'''ensight.ptrace.hide_emission({repr(p0)})'''
        return self._session.cmd(cmd)

    def massed_ballistic_coef(self, p0: float) -> int:
        """If the massed_use_ballistic toggle is ON then this is the ballistic coefficient to use
        
        Args:
            p0:
                'coef' ballistic coefficient
        
        Examples:
            ::
        
                ensight.part.select_begin(2)
                ensight.part.modify_begin()
                ensight.ptrace.massed_buoyancy("OFF")
                ensight.ptrace.massed_use_ballistic("ON")
                ensight.ptrace.massed_ballistic_coef(0.01)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.ptrace.massed_ballistic_coef({repr(p0)})'''
        return self._session.cmd(cmd)

    def massed_buoyancy(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.ptrace.massed_buoyancy({repr(p0)})'''
        return self._session.cmd(cmd)

    def massed_coef_friction(self, p0: float) -> int:
        """Set the coefficient of friction for use with the massed particle rebound capability
        
        Args:
            p0:
                'friction' coefficient of friction
        
        Examples:
            ::
        
                ensight.ptrace.select_default()
                ensight.ptrace.default_emit_pt()
                ensight.view_transf.cursor(7.1,6,0.)
                ensight.part.modify_begin()
                ensight.ptrace.massed_particles("ON")
                ensight.ptrace.massed_rebound("ON")
                ensight.ptrace.massed_rebound_wallhits(4)
                ensight.ptrace.massed_coef_restitution(0.8)
                ensight.ptrace.massed_coef_friction(1.000000e-01)
                ensight.part.modify_end()
                ensight.part.select_all()
                ensight.ptrace.create_pt()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.ptrace.massed_coef_friction({repr(p0)})'''
        return self._session.cmd(cmd)

    def massed_coef_restitution(self, p0: float) -> int:
        """Set the coefficient of restitution for use with the massed particle rebound capability
        
        Args:
            p0:
                'rebound' coefficient of restitution
        
        Examples:
            ::
        
                ensight.ptrace.select_default()
                ensight.ptrace.default_emit_pt()
                ensight.view_transf.cursor(7.1,6,0.)
                ensight.part.modify_begin()
                ensight.ptrace.massed_particles("ON")
                ensight.ptrace.massed_rebound("ON")
                ensight.ptrace.massed_rebound_wallhits(4)
                ensight.ptrace.massed_coef_restitution(0.8)
                ensight.ptrace.massed_coef_friction(1.000000e-01)
                ensight.part.modify_end()
                ensight.part.select_all()
                ensight.ptrace.create_pt()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.ptrace.massed_coef_restitution({repr(p0)})'''
        return self._session.cmd(cmd)

    def massed_drag(self, p0: str) -> int:
        """Specify whether the drag force term is used in the massed-particle calculation.
        
        | The default setting is ON.  The "ptrace: massed_particles" command does not have to be ON in order to specify this command. Drag force term in the massed-particle momentum balance equation is computed according to the ptrace: massed_pressure_gradient setting.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                #
                # Create a massless point trace
                #
                ensight.part.select_all()
                ensight.ptrace.select_default()
                ensight.part.modify_begin()
                ensight.ptrace.variable("velocity")
                ensight.part.modify_end()
                ensight.part.select_all()
                ensight.ptrace.create_pt()
                ensight.part.select_begin(2)
                #
                # Toggle on massed-particle drag force term
                # Specify default drag coefficient function table
                #
                ensight.part.modify_begin()
                ensight.ptrace.massed_drag("ON")
                ensight.ptrace.massed_drag_coefficient("none")
                ensight.part.modify_end()
                #
                # Change part to massed trace using current settings
                #
                ensight.part.modify_begin()
                ensight.ptrace.massed_particles("ON")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.ptrace.massed_drag({repr(p0)})'''
        return self._session.cmd(cmd)

    def massed_drag_coefficient(self, p0: float) -> int:
        """Specify the name of the drag coefficient function table to be used in the drag force term of the massed-particle calculation.
        
        | The default setting is "none".  The "ptrace: massed_particles" command does not have to be ON in order to specify this command.  This parameter is only used when the drag force term "ptrace: massed_drag" is toggled ON. 
        | Also the three options "DragCoefPoly", "DragCoefPower", and "DragCoefTable1", are EnSight User-Defined Math Functions.  These math functions are typically located under $CEI_HOME/ensight92/src/math_functions, and are compiled as libraries by the user, and then dynamically liked via the _UDMF environment variable.
        
        Args:
            p0:
                'table_name' none
            p1:
                'table_name' DragCoefTable1
            p2:
                'table_name' DragCoefPower
            p3:
                'table_name' DragCoefPoly
            p4:
                'table_name' any User-Defined Math Function
        
        Examples:
            ::
        
                #
                # Create a massless point trace
                #
                ensight.part.select_all()
                ensight.ptrace.select_default()
                ensight.part.modify_begin()
                ensight.ptrace.variable("velocity")
                ensight.part.modify_end()
                ensight.part.select_all()
                ensight.ptrace.create_pt()
                ensight.part.select_begin(2)
                #
                # Toggle on massed-particle drag force term
                # Specify default drag coefficient function table
                #
                ensight.part.modify_begin()
                ensight.ptrace.massed_drag("ON")
                ensight.ptrace.massed_drag_coefficient("none")
                ensight.part.modify_end()
                #
                # Change part to massed trace using current settings
                #
                ensight.part.modify_begin()
                ensight.ptrace.massed_particles("ON")
                ensight.part.modify_end()
                #
                # Change the drag coefficient function to use the power formulation
                #
                ensight.part.modify_begin()
                ensight.ptrace.massed_drag_coefficient("DragCoefPower")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.ptrace.massed_drag_coefficient({repr(p0)})'''
        return self._session.cmd(cmd)

    def massed_fluid_density(self, p0: float) -> int:
        """Specify the density of the corresponding fluid field where the massed-particles are traced.
        
        | The default setting for this parameter is the constant value of "1.0", with the Fluid Density variable name set to "none".  This indicates that no variable name is used; rather the constant density is used in the calculations instead.  The "ptrace: massed_particles" command does not have to be ON in order to specify this command.  This parameter is figured only when the drag and gravity force terms of the massed-particle momentum balance equation are used.
        
        Args:
            p0:
                'density' the fluid density constant value of the corresponding fluid field
            p1:
                'density' the fluid density constant value of the corresponding fluid field
            p2:
                'density' the fluid density variable name of the corresponding fluid field - defaults to "none" when constant value used
        
        Examples:
            ::
        
                #
                # Create a massless point trace
                #
                ensight.part.select_all()
                ensight.ptrace.select_default()
                ensight.part.modify_begin()
                ensight.ptrace.variable("velocity")
                ensight.part.modify_end()
                ensight.part.select_all()
                ensight.ptrace.create_pt()
                ensight.part.select_begin(2)
                #
                # Specify density scalar field variable name of the fluid.
                #
                ensight.part.modify_begin()
                ensight.ptrace.massed_fluid_density("density")
                ensight.part.modify_end()
                #
                # Change part to massed trace using current settings
                #
                ensight.part.modify_begin()
                ensight.ptrace.massed_particles("ON")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.ptrace.massed_fluid_density({repr(p0)})'''
        return self._session.cmd(cmd)

    def massed_fluid_viscosity(self, p0: float) -> int:
        """Specify the dynamic viscosity of the corresponding fluid field where the massed-particles are traced.
        
        | The default setting for this parameter is the constant value of "1.9620e+05", with the Fluid Dynamic Viscosity variable name set to "none".  This indicates that no variable name is used; rather the constant dynamic viscosity is used in the calculations instead.  The "ptrace: massed_particles" command does not have to be ON in order to specify this command.  This parameter is figured only when the drag force term of the massed-particle momentum balance equation is used.
        
        Args:
            p0:
                'viscosity' the dynamic viscosity constant value of the corresponding fluid field
            p1:
                'viscosity' the dynamic viscosity constant value of the corresponding fluid field
            p2:
                'viscosity' the dynamic viscosity variable name of the corresponding fluid field - defaults to "none" when constant value used
        
        Examples:
            ::
        
                #
                # Create a massless point trace
                #
                ensight.part.select_all()
                ensight.ptrace.select_default()
                ensight.part.modify_begin()
                ensight.ptrace.variable("velocity")
                ensight.part.modify_end()
                ensight.part.select_all()
                ensight.ptrace.create_pt()
                ensight.part.select_begin(2)
                #
                # Specify dynamic viscosity scalar field variable name of the fluid.
                #
                ensight.part.modify_begin()
                ensight.ptrace.massed_fluid_viscosity("dynamic_viscosity")
                ensight.part.modify_end()
                #
                # Change part to massed trace using current settings
                #
                ensight.part.modify_begin()
                ensight.ptrace.massed_particles("ON")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.ptrace.massed_fluid_viscosity({repr(p0)})'''
        return self._session.cmd(cmd)

    def massed_gravity(self, p0: str) -> int:
        """Specify whether the gravity force term is used in the massed-particle calculation.
        
        | The default setting is ON.  The "ptrace: massed_particles" command does not have to be ON in order to specify this command.  If this command is ON, then the gravity force term in the massed-particle momentum balance equation is computed according to the "ptrace: massed_gravity_vector" setting.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                #
                # Create a massless point trace
                #
                ensight.part.select_all()
                ensight.ptrace.select_default()
                ensight.part.modify_begin()
                ensight.ptrace.variable("velocity")
                ensight.part.modify_end()
                ensight.part.select_all()
                ensight.ptrace.create_pt()
                ensight.part.select_begin(2)
                #
                # Toggle on massed-particle gravity force term
                # Specify gravity vector
                #
                ensight.part.modify_begin()
                ensight.ptrace.massed_gravity("ON")
                ensight.ptrace.massed_gravity_vector("0.00000e+00-9.81000e+00",0.00000e+00)
                ensight.part.modify_end()
                #
                # Change part to massed trace using current settings
                #
                ensight.part.modify_begin()
                ensight.ptrace.massed_particles("ON")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.ptrace.massed_gravity({repr(p0)})'''
        return self._session.cmd(cmd)

    def massed_gravity_vector(self, p0: float, p1: float, p2: float) -> int:
        """Specify the name of the gravity vector used in the pressure force term of the massed-particle calculation.
        
        | The default setting is <0., -9.81, 0.>.  The "ptrace: massed_particles" command does not have to be ON in order to specify this command.  
        
        Args:
            p0:
                'gx' the x-component of the gravity vector
            p1:
                'gy' the y-component of the gravity vector
            p2:
                'gz' the z-component of the gravity vector
        
        Examples:
            ::
        
                #
                # Create a massless point trace
                #
                ensight.part.select_all()
                ensight.ptrace.select_default()
                ensight.part.modify_begin()
                ensight.ptrace.variable("velocity")
                ensight.part.modify_end()
                ensight.part.select_all()
                ensight.ptrace.create_pt()
                ensight.part.select_begin(2)
                #
                # Toggle on massed-particle gravity force term
                # Specify the gravity vector
                #
                ensight.part.modify_begin()
                ensight.ptrace.massed_gravity("ON")
                ensight.ptrace.massed_gravity_vector("0.00000e+00-9.81000e+00",0.00000e+00)
                ensight.part.modify_end()
                #
                # Change part to massed trace using current settings
                #
                ensight.part.modify_begin()
                ensight.ptrace.massed_particles("ON")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.ptrace.massed_gravity_vector({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def massed_initial_use_fluid(self, p0: str) -> int:
        """Specify whether to use the velocity of the fluid at the particle emitter location as the initial velocity of the massed-particle.
        
        | The default value is ON.  The "ptrace: massed_particles" command does not have to be ON in order to specify this command.  This parameter is figured in all terms of the massed-particle momentum balance equation.  If the value of this command is OFF, then the massed-particle emitter will use the velocity specified via the "ptrace: massed_initial_velocity" command.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                #
                # Create a massless point trace
                #
                ensight.part.select_all()
                ensight.ptrace.select_default()
                ensight.part.modify_begin()
                ensight.ptrace.variable("velocity")
                ensight.part.modify_end()
                ensight.part.select_all()
                ensight.ptrace.create_pt()
                ensight.part.select_begin(2)
                #
                # Do not use the field velocity as the initial particle velocity
                # Specify the initial velocity value for all the massed-particles
                #
                ensight.part.modify_begin()
                ensight.ptrace.massed_initial_use_fluid("OFF")
                ensight.ptrace.massed_initial_velocity(1.0000e+00,1.0000e+00,1.0000e+00)
                ensight.part.modify_end()
                #
                # Change part to massed trace using current settings
                #
                ensight.part.modify_begin()
                ensight.ptrace.massed_particles("ON")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.ptrace.massed_initial_use_fluid({repr(p0)})'''
        return self._session.cmd(cmd)

    def massed_initial_velocity(self, p0: float, p1: float, p2: float) -> int:
        """Specify the initial emitter velocity vector to be used on all the massed-particles.
        
        | The default vector value is <1,1,1>.  The "ptrace: massed_particles" command does not have to be ON in order to specify this command.  This parameter is figured in all terms of the massed-particle momentum balance equation.  The values of this command take effect only if "ptrace: massed_initial_use_fluid" is toggled OFF.
        
        Args:
            p0:
                'vx' the x-component of the initial velocity vector
            p1:
                'vy' the y-component of the initial velocity vector
            p2:
                'vz' the z-component of the initial velocity vector
        
        Examples:
            ::
        
                #
                # Create a massless point trace
                #
                ensight.part.select_all()
                ensight.ptrace.select_default()
                ensight.part.modify_begin()
                ensight.ptrace.variable("velocity")
                ensight.part.modify_end()
                ensight.part.select_all()
                ensight.ptrace.create_pt()
                ensight.part.select_begin(2)
                #
                # Do not use the field velocity as the initial particle velocity
                # Specify the initial velocity value for all the massed-particles
                #
                ensight.part.modify_begin()
                ensight.ptrace.massed_initial_use_fluid("OFF")
                ensight.ptrace.massed_initial_velocity(1.0000e+00,1.0000e+00,1.0000e+00)
                ensight.part.modify_end()
                #
                # Change part to massed trace using current settings
                #
                ensight.part.modify_begin()
                ensight.ptrace.massed_particles("ON")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.ptrace.massed_initial_velocity({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def massed_particle_density(self, p0: float) -> int:
        """Specify the density of all the massed-particles.
        
        | The default value is 1.0e+03.  The "ptrace: massed_particles" command does not have to be ON in order to specify this command.  This parameter is figured in all terms of the massed-particle momentum balance equation.  Water particle densities are on the order of 1.0e+3, and air partilce densities are on the order of 1.0.
        
        Args:
            p0:
                'density' the density value of all the particles
        
        Examples:
            ::
        
                #
                # Create a massless point trace
                #
                ensight.part.select_all()
                ensight.ptrace.select_default()
                ensight.part.modify_begin()
                ensight.ptrace.variable("velocity")
                ensight.part.modify_end()
                ensight.part.select_all()
                ensight.ptrace.create_pt()
                ensight.part.select_begin(2)
                #
                # Specify density of all the massed particles
                #
                ensight.part.modify_begin()
                ensight.ptrace.massed_particle_density(1.0000e+03)
                ensight.part.modify_end()
                #
                # Change part to massed trace using current settings
                #
                ensight.part.modify_begin()
                ensight.ptrace.massed_particles("ON")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.ptrace.massed_particle_density({repr(p0)})'''
        return self._session.cmd(cmd)

    def massed_particle_diameter(self, p0: float) -> int:
        """Specify the diameter of all the massed-particles.
        
        | The default value is 1.0e-03.  The "ptrace: massed_particles" command does not have to be ON in order to specify this command.  This parameter is figured in all terms of the massed-particle momentum balance equation.  Water particle diameters are on the order of 1.0e-3, and air partilce diameters are on the order of 1.0e-6.
        
        Args:
            p0:
                'diameter' the diameter value of all the particles
        
        Examples:
            ::
        
                #
                # Create a massless point trace
                #
                ensight.part.select_all()
                ensight.ptrace.select_default()
                ensight.part.modify_begin()
                ensight.ptrace.variable("velocity")
                ensight.part.modify_end()
                ensight.part.select_all()
                ensight.ptrace.create_pt()
                ensight.part.select_begin(2)
                #
                # Specify diameter of the massed particle
                #
                ensight.part.modify_begin()
                ensight.ptrace.massed_particle_diameter(1.0000e-03)
                ensight.part.modify_end()
                #
                # Change part to massed trace using current settings
                #
                ensight.part.modify_begin()
                ensight.ptrace.massed_particles("ON")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.ptrace.massed_particle_diameter({repr(p0)})'''
        return self._session.cmd(cmd)

    def massed_particles(self, p0: str) -> int:
        """Enable or disable massed-particle trace calculation.
        
        | The default value is OFF.  The "ptrace: massed_particles" command does not have to be ON in order to specify the other massed-particle commands.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                #
                # Create a massless point trace
                #
                ensight.part.select_all()
                ensight.ptrace.select_default()
                ensight.part.modify_begin()
                ensight.ptrace.variable("velocity")
                ensight.part.modify_end()
                ensight.part.select_all()
                ensight.ptrace.create_pt()
                ensight.part.select_begin(2)
                #
                # Change part to massed trace using current settings
                #
                ensight.part.modify_begin()
                ensight.ptrace.massed_particles("ON")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.ptrace.massed_particles({repr(p0)})'''
        return self._session.cmd(cmd)

    def massed_pressure(self, p0: str) -> int:
        """Specify whether the pressure force term is used in the massed-particle calculation.
        
        | The default setting is OFF.  The "ptrace: massed_particles" command does not have to be ON in order to specify this command.  If this command is ON, then the pressure force term in the massed-particle momentum balance equation is computed according to the "ptrace: massed_pressure_gradient" setting.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                #
                # Create a massless point trace
                #
                ensight.part.select_all()
                ensight.ptrace.select_default()
                ensight.part.modify_begin()
                ensight.ptrace.variable("velocity")
                ensight.part.modify_end()
                ensight.part.select_all()
                ensight.ptrace.create_pt()
                ensight.part.select_begin(2)
                #
                # Toggle on massed-particle pressure force term
                # Specify pressure gradient variable
                #
                ensight.part.modify_begin()
                ensight.ptrace.massed_pressure("ON")
                ensight.ptrace.massed_pressure_gradient("grad_pressure")
                ensight.part.modify_end()
                #
                # Change part to massed trace using current settings
                #
                ensight.part.modify_begin()
                ensight.ptrace.massed_particles("ON")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.ptrace.massed_pressure({repr(p0)})'''
        return self._session.cmd(cmd)

    def massed_pressure_gradient(self, p0: Any) -> int:
        """Specify the name of the pressure gradient variable used in the pressure force term of the massed-particle calculation.
        
        | The "ptrace: massed_particles" command does not have to be ON in order to specify this command.  If "none" is specified, then the pressure force term is ignored in the massed-particle calculation.  The default setting is "none".
        
        Examples:
            ::
        
                #
                # Create a massless point trace
                #
                ensight.part.select_all()
                ensight.ptrace.select_default()
                ensight.part.modify_begin()
                ensight.ptrace.variable("velocity")
                ensight.part.modify_end()
                ensight.part.select_all()
                ensight.ptrace.create_pt()
                ensight.part.select_begin(2)
                #
                # Toggle on massed-particle pressure force term
                # Specify pressure gradient variable
                #
                ensight.part.modify_begin()
                ensight.ptrace.massed_pressure("ON")
                ensight.ptrace.massed_pressure_gradient("grad_pressure")
                ensight.part.modify_end()
                #
                # Change part to massed trace using current settings
                #
                ensight.part.modify_begin()
                ensight.ptrace.massed_particles("ON")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.ptrace.massed_pressure_gradient({repr(p0)})'''
        return self._session.cmd(cmd)

    def massed_rebound(self, p0: str) -> int:
        """Turn on/off the use of massed particle rebound coefficients.
        
        | Only used if the "ptrace: mass_particles" setting is ON
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.ptrace.select_default()
                ensight.ptrace.default_emit_pt()
                ensight.view_transf.cursor(7.1,6,0.)
                ensight.part.modify_begin()
                ensight.ptrace.massed_particles("ON")
                ensight.ptrace.massed_rebound("ON")
                ensight.ptrace.massed_rebound_wallhits(4)
                ensight.ptrace.massed_coef_restitution(0.8)
                ensight.ptrace.massed_coef_friction(1.000000e-01)
                ensight.part.modify_end()
                ensight.part.select_all()
                ensight.ptrace.create_pt()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.ptrace.massed_rebound({repr(p0)})'''
        return self._session.cmd(cmd)

    def massed_rebound_fraction(self, p0: float) -> int:
        """If using massed particle restitution this sets a termination criteria.  Only if the rebound velocity as a fraction of the initial impact velocity if greater than this value will the particle continue to be tracked.
        
        | There are other terminating particle trace criteria such as the time limit controlled by "ptrace: total_time" and the fraction of initial impact velocity controlled by "ptrace: mass_rebound_fraction"
        
        Args:
            p0:
                'fraction' the fraction of initial impact velocity
        
        Examples:
            ::
        
                ensight.part.select_begin(2)
                ensight.part.modify_begin()
                ensight.ptrace.massed_rebound_fraction(.01)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.ptrace.massed_rebound_fraction({repr(p0)})'''
        return self._session.cmd(cmd)

    def massed_rebound_wallhits(self, p0: int) -> int:
        """If using massed particle restitution this sets a termination criteria.  Only num_hits number of rebounds will be allowed at which time the particle trace will be terminated
        
        | There are other terminating particle trace criteria such as the time limit controlled by "ptrace: total_time" and the fraction of initial impact velocity controlled by "ptrace: mass_rebound_fraction"
        
        Args:
            p0:
                'num_hits' the number of rebounds that will be computed
        
        Examples:
            ::
        
                ensight.ptrace.select_default()
                ensight.ptrace.default_emit_pt()
                ensight.view_transf.cursor(7.1,6,0.)
                ensight.part.modify_begin()
                ensight.ptrace.massed_particles("ON")
                ensight.ptrace.massed_rebound("ON")
                ensight.ptrace.massed_rebound_wallhits(4)
                ensight.ptrace.massed_coef_restitution(0.8)
                ensight.ptrace.massed_coef_friction(1.000000e-01)
                ensight.part.modify_end()
                ensight.part.select_all()
                ensight.ptrace.create_pt()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.ptrace.massed_rebound_wallhits({repr(p0)})'''
        return self._session.cmd(cmd)

    def massed_use_ballistic(self, p0: str) -> int:
        """If using massed particle restitution this sets a termination criteria.  Only num_hits number of rebounds will be allowed at which time the particle trace will be terminated
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.part.select_begin(2)
                ensight.part.modify_begin()
                ensight.ptrace.massed_buoyancy("OFF")
                ensight.ptrace.massed_use_ballistic("ON")
                ensight.ptrace.massed_ballistic_coef(0.01)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.ptrace.massed_use_ballistic({repr(p0)})'''
        return self._session.cmd(cmd)

    def max_angle(self, p0: float) -> int:
        """Sets the maximum angle between successive particle trace line segments that will trigger a halving of the integration step.
        
        | When a particle trace starts curving, the integration step typically needs to be decreased. This attribute is one of the controls for such adaptation.
        
        Args:
            p0:
                'value' desired maximum angle (in degrees).  If the angle between successive segments is greater than this, the integration step will be halved. The range is 1.0 to 90.0 degrees
        
        Examples:
            ::
        
                #
                # Selecting the trace(s)
                #
                ensight.part.select_begin(7,8)
                #
                # Modifying attributes for the two selected trace parts
                # (max_angle is modified in here)
                #
                ensight.part.modify_begin()
                ensight.ptrace.min_steps(3)
                ensight.ptrace.min_angle(3.0000e+00)
                ensight.ptrace.max_angle(2.0000e+01)
                ensight.ptrace.rot_angle(3.2000e+01)
                #
                # Updates the traces with the modified attributes
                #
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.ptrace.max_angle({repr(p0)})'''
        return self._session.cmd(cmd)

    def min_angle(self, p0: float) -> int:
        """Sets the minimum angle between successive particle trace line segments that will trigger a doubling of the integration step.
        
        | When a particle trace is not curving, the integration step can typically be increased. This attribute is one of the controls for such adaptation.
        
        Args:
            p0:
                'value' desired minimum angle (in degrees).  If the angle between successive segments is less than this, the integration step will be doubled. The range is 1.0 to 90.0 degrees
        
        Examples:
            ::
        
                #
                # Selecting the trace(s)
                #
                ensight.part.select_begin(7,8)
                #
                # Modifying attributes for the two selected trace parts
                # (min_angle is modified in here)
                #
                ensight.part.modify_begin()
                ensight.ptrace.min_steps(3)
                ensight.ptrace.min_angle(3.0000e+00)
                ensight.ptrace.max_angle(2.0000e+01)
                ensight.ptrace.rot_angle(3.2000e+01)
                #
                # Updates the traces with the modified attributes
                #
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.ptrace.min_angle({repr(p0)})'''
        return self._session.cmd(cmd)

    def min_steps(self, p0: float) -> int:
        """Sets the minimum number of integration steps to perform in each element
        
        | A higher number increases the accuracy of the integration, but is more compute intensive and produces more segments to display.
        
        Args:
            p0:
                'num' desired minimum number of integration steps per element (range is 2 to 20)
        
        Examples:
            ::
        
                #
                # Selecting the trace(s)
                #
                ensight.part.select_begin(7,8)
                #
                # Modifying attributes for the two selected trace parts
                # (min_steps being modified in here)
                #
                ensight.part.modify_begin()
                ensight.ptrace.min_steps(3)
                ensight.ptrace.min_angle(3.0000e+00)
                ensight.ptrace.max_angle(2.0000e+01)
                ensight.ptrace.rot_angle(3.2000e+01)
                #
                # Updates the traces with the modified attributes
                #
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.ptrace.min_steps({repr(p0)})'''
        return self._session.cmd(cmd)

    def modify_bypartemit_byname(self, p0: str, p1: str, p2: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.ptrace.modify_bypartemit_byname({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def modify_bypartemit_num(self, args: Any) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.ptrace.modify_bypartemit_num({repr(args)})'''
        return self._session.cmd(cmd)

    def modify_emit_totoolloc(self, p0: int, p1: int) -> int:
        """Change the location of the emitter in a particle trace part.
        
        Args:
            p0:
                'part_num' particle trace part number
            p1:
                'emitter' emitter number (0-based)
        
        Examples:
            ::
        
                #
                # Change the location of the tool used for the emitter
                #
                ensight.view_transf.cursor(7.422632,-0.327560,0.000000)
                #
                # modify the trace emitter based on this tool
                # (in this case, it is emitter 0 in part 2
                #
                ensight.ptrace.modify_emit_totoolloc(2,0)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.ptrace.modify_emit_totoolloc({repr(p0)},{repr(p1)})'''
        return self._session.cmd(cmd)

    def modify_fileemit_name(self, p0: str) -> int:
        """Change the emitter file name for a file emitter.
        
        Args:
            p0:
                'emitter' Emitter number (0 based)
            p1:
                'filename' The new emitter file name
        
        Examples:
            ::
        
                #
                # Select an existing particle trace part 3
                # 
                #
                ensight.part.select_begin(3)
                # 
                # Change the emitter name for emitter 0
                #
                ensight.ptrace.modify_fileemit_name("0 /tmp/new_emitter.file")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.ptrace.modify_fileemit_name({repr(p0)})'''
        return self._session.cmd(cmd)

    def modify_netemit_points(self, p0: int, p1: int, p2: int) -> int:
        """Change the number of emission points for a particular net emitter in a particle trace part.
        
        Args:
            p0:
                'emitter' emitter number (0-based)
            p1:
                'new_num_in_x' desired new number of emission points for the grid x direction.
            p2:
                'new_num_in_y' desired new number of emission points for the grid y direction
        
        Examples:
            ::
        
                #
                # Selecting an existing particle trace part
                # (which contains some net emitters)
                #
                ensight.part.select_begin(3)
                #
                # Changing the number of points in the
                # first 2 net emitters (emitters 0 and 1)
                # to 5 x 6, and 9 x 15 respectively
                #
                ensight.ptrace.modify_netemit_points(0,5,6)
                ensight.ptrace.modify_netemit_points(1,9,15)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.ptrace.modify_netemit_points({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def modify_partemit_byname(self, p0: str, p1: str) -> int:
        """Ptrace: modify_partemit_byname

        """
        cmd = f'''ensight.ptrace.modify_partemit_byname({repr(p0)},{repr(p1)})'''
        return self._session.cmd(cmd)

    def modify_partemit_num(self, p0: int, p1: int) -> int:
        """Ptrace: modify_partemit_num

        """
        cmd = f'''ensight.ptrace.modify_partemit_num({repr(p0)},{repr(p1)})'''
        return self._session.cmd(cmd)

    def modify_rakeemit_points(self, p0: int, p1: int) -> int:
        """Change the number of emission points for a particular rake emitter in a particle trace part.
        
        Args:
            p0:
                'emitter' emitter number (0-based
            p1:
                'new_num_pts' desired new number of emission points along the rake
        
        Examples:
            ::
        
                #
                # Selecting an existing particle trace part
                # (which contains a rake emitter)
                #
                ensight.part.select_begin(3)
                #
                # Changing the number of points in the
                # first emitter (emitter 0), to 8
                #
                ensight.ptrace.modify_rakeemit_points(0,8)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.ptrace.modify_rakeemit_points({repr(p0)},{repr(p1)})'''
        return self._session.cmd(cmd)

    def node_id(self, args: Any) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.ptrace.node_id({repr(args)})'''
        return self._session.cmd(cmd)

    def number_of_arrows(self, p0: int) -> int:
        """Ptrace: #_of_arrows

        """
        cmd = f'''ensight.ptrace.number_of_arrows({repr(p0)})'''
        return self._session.cmd(cmd)

    def pick_surface_oncreatecmd(self, p0: str) -> int:
        """Ptrace: pick_surface_oncreatecmd

        """
        cmd = f'''ensight.ptrace.pick_surface_oncreatecmd({repr(p0)})'''
        return self._session.cmd(cmd)

    def random_color_emissions(self) -> int:
        """Ptrace: random_color_emissions

        """
        cmd = f'''ensight.ptrace.random_color_emissions()'''
        return self._session.cmd(cmd)

    def representation(self, p0: str) -> int:
        """Sets the display representation for a particle trace.
        
        | Use the ribbon or square_tubes representations whenever rotational effects need to be seen. Surface restricted traces can only be displayed in line representation.
        
        Args:
            p0:
                'rep'
        
                * line
                * ribbon
                * square_tubes
        
        Examples:
            ::
        
                #
                # Selecting the trace(s)
                #
                ensight.part.select_begin(7,8)
                #
                # Modifying attributes for the two selected trace parts
                # (representation is modified in here)
                #
                ensight.part.modify_begin()
                ensight.ptrace.representation("ribbon")
                ensight.ptrace.ribbon_width(2.0000e+00)
                #
                # Updates the traces with the modified attributes
                #
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.ptrace.representation({repr(p0)})'''
        return self._session.cmd(cmd)

    def ribbon_width(self, p0: float) -> int:
        """Sets the width for ribbon or square tube particle trace representations.
        
        | This attribute has no effect when using the "line" trace representation.
        
        Args:
            p0:
                'width' the width of the ribbon or square tube
        
        Examples:
            ::
        
                #
                # Selecting the trace(s)
                #
                ensight.part.select_begin(7,8)
                #
                # Modifying attributes for the two selected trace parts
                # (ribbon_width is modified in here)
                #
                ensight.part.modify_begin()
                ensight.ptrace.representation("square_tubes")
                ensight.ptrace.ribbon_width(2.0000e+00)
                #
                # Updates the traces with the modified attributes
                #
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.ptrace.ribbon_width({repr(p0)})'''
        return self._session.cmd(cmd)

    def rot_angle(self, p0: float) -> int:
        """Sets the angle between successive particle trace line segments that will trigger a halving of the integration step.  
        
        | When a particle begins experiencing rotational effects, the integration step typically needs to be decreased. This attribute is one of the controls for such adaptation.
        
        Args:
            p0:
                'value' desired rotational angle (in degrees). If the change in rotation angle is greater than this, the integration step will be halved.  range is 1.0 to 90.0 degrees
        
        Examples:
            ::
        
                #
                # Selecting the trace(s)
                #
                ensight.part.select_begin(7,8)
                #
                # Modifying attributes for the two selected trace parts
                # (rot_angle is modified in here)
                #
                ensight.part.modify_begin()
                ensight.ptrace.min_steps(3)
                ensight.ptrace.min_angle(3.0000e+00)
                ensight.ptrace.max_angle(2.0000e+01)
                ensight.ptrace.rot_angle(3.2000e+01)
                #
                # Updates the traces with the modified attributes
                #
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.ptrace.rot_angle({repr(p0)})'''
        return self._session.cmd(cmd)

    def select_begin(self, *args, **kwargs) -> Any:
        """Ptrace: select_begin

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.ptrace.select_begin({arg_string})"
        return self._session.cmd(cmd)

    def select_default(self) -> int:
        """Sets the currently selected particle trace parts to none, so any following attribute modifications will change the particle trace defaults.
        
        | When particle trace parts are created, the defaults, and any "ptrace:" attribute commands between "ptrace: begin" and "ptrace: end", are used in the creation.
        
        Examples:
            ::
        
                #
                # Setting to default particle traces
                #
                ensight.ptrace.select_default()
                #
                # modifying some attributes
                #
                ensight.part.modify_begin()
                ensight.ptrace.variable("VITESSE")
                ensight.ptrace.type("pathline")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.ptrace.select_default()'''
        return self._session.cmd(cmd)

    def select_emitname_begin(self) -> int:
        """Ptrace: select_emitname_begin

        """
        cmd = f'''ensight.ptrace.select_emitname_begin()'''
        return self._session.cmd(cmd)

    def select_emitname_end(self) -> int:
        """Ptrace: select_emitname_end

        """
        cmd = f'''ensight.ptrace.select_emitname_end()'''
        return self._session.cmd(cmd)

    def select_emitter_begin(self, *args, **kwargs) -> Any:
        """Select emitters within a particle trace part for the purpose of modifying emitter attributes, deleting, etc.
        
        Args:
            p0:
                'emitterN' emitter numbers (0-based)
        
        Examples:
            ::
        
                #
                # Selecting the parent part(s)
                #
                ensight.part.select_begin(2)
                #
                # Selecting the first 3 emitters within the part
                # for the purpose of deleting them
                #
                ensight.ptrace.select_emitter_begin(0,1,2)
                ensight.ptrace.delete_emitter()
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.ptrace.select_emitter_begin({arg_string})"
        return self._session.cmd(cmd)

    def show_emissions(self) -> int:
        """Ptrace: show_emissions

        """
        cmd = f'''ensight.ptrace.show_emissions()'''
        return self._session.cmd(cmd)

    def start_time(self, p0: float) -> int:
        """Specifies the solution time at which to begin particle emission.
        
        Args:
            p0:
                'emit_time' solution time for particle emission. Must be in the range of valid solution times
        
        Examples:
            ::
        
                #
                # Selecting the parent part
                #
                ensight.part.select_begin(1)
                #
                # Setting some attributes before creation
                # (the start_time is being set here)
                #
                ensight.ptrace.begin()
                ensight.ptrace.variable("VITESSE")
                ensight.ptrace.type("streamline")
                ensight.ptrace.component(1.0000e+00,1.0000e+00,1.0000e+00)
                ensight.ptrace.representation("line")
                ensight.ptrace.start_time(1.5000e+01)
                ensight.ptrace.delta_time(1.0000e+00)
                ensight.ptrace.end()
                #
                # Creating trace from a point
                #
                ensight.ptrace.create_pt()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.ptrace.start_time({repr(p0)})'''
        return self._session.cmd(cmd)

    def surface_restricted(self, p0: str) -> int:
        """Toggles trace creation to be surface restricted or not. 
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                #
                # Selecting the parent part
                #
                ensight.part.select_begin(1)
                #
                # Setting some attributes before creation
                # (the surface_restricted flag is being set here)
                #
                ensight.ptrace.begin()
                ensight.part.description("Particle trace part")
                ensight.ptrace.surface_restricted("ON")
                ensight.ptrace.variable_offset(1.0000e-01)
                ensight.ptrace.display_offset(0.5000e+00)
                ensight.ptrace.total_time(2.0000e+02)
                ensight.ptrace.emit_at_current_time("ON")
                ensight.ptrace.end()
                #
                # Creating trace from a point
                #
                ensight.ptrace.create_pt()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.ptrace.surface_restricted({repr(p0)})'''
        return self._session.cmd(cmd)

    def time_step_begin(self, p0: int) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.ptrace.time_step_begin({repr(p0)})'''
        return self._session.cmd(cmd)

    def time_step_end(self, p0: int) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.ptrace.time_step_end({repr(p0)})'''
        return self._session.cmd(cmd)

    def total_time(self, p0: float) -> int:
        """Sets the maximum length of time that the particle trace is allowed to continue.
        
        | A particle trace may terminate earlier than this for other reasons, but this limit avoids infinite calculations in recirculation zones.
        
        Args:
            p0:
                'limit' total time limit
        
        Examples:
            ::
        
                #
                # Selecting the trace(s)
                #
                ensight.part.select_begin(7,8)
                #
                # Modifying attributes for the two selected trace parts
                # (total_time is modified in here)
                #
                ensight.part.modify_begin()
                ensight.ptrace.total_time(2.0000e+02)
                ensight.ptrace.trace_direction("+/-")
                #
                # Updates the traces with the modified attributes
                #
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.ptrace.total_time({repr(p0)})'''
        return self._session.cmd(cmd)

    def trace_direction(self, p0: str) -> int:
        """Sets the integration direction for a particle trace - forward in time, backward in time, or both.
        
        | By setting this option appropriately, one can see where a particle will go if released from the emitter location (the + direction), or one can see the path that a particle took to get to the emitter location (the - direction). 
        
        Args:
            p0:
                'direction'
        
                * +
                * -
                * +/-
        
        Examples:
            ::
        
                #
                # Selecting the trace(s)
                #
                ensight.part.select_begin(7,8)
                #
                # Modifying attributes for the two selected trace parts
                # (trace_direction is modified in here)
                #
                ensight.part.modify_begin()
                ensight.ptrace.total_time(2.0000e+02)
                ensight.ptrace.trace_direction("+/-")
                #
                # Updates the traces with the modified attributes
                #
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.ptrace.trace_direction({repr(p0)})'''
        return self._session.cmd(cmd)

    def type(self, p0: str) -> int:
        """Sets the type of particle trace that will be created.
        
        | Pathline is only available for transient data cases.
        
        Args:
            p0:
                'option'
        
                * streamline
                * pathline
                * nodetrack
                * variablemintrack
                * variablemaxtrack
        
        Examples:
            ::
        
                #
                # Setting default particle trace variable
                #
                ensight.ptrace.select_default()
                ensight.part.modify_begin()
                ensight.ptrace.variable("VITESSE")
                ensight.part.modify_end()
                #
                # Selecting the parent part
                #
                ensight.part.select_begin(1)
                #
                # Setting some attributes before creation
                # (the type is being set here)
                #
                ensight.ptrace.begin()
                ensight.ptrace.type("streamline")
                ensight.ptrace.component(1.0000e+00,1.0000e+00,1.0000e+00)
                ensight.ptrace.representation("line")
                ensight.ptrace.end()
                #
                # Creating trace from a point
                #
                ensight.ptrace.create_pt()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.ptrace.type({repr(p0)})'''
        return self._session.cmd(cmd)

    def variable(self, p0: Any) -> int:
        """Specifies the vector variable to use for the flow field for the particle trace.
        
        Args:
            p0:
                'name' name of the vector variable
        
        Examples:
            ::
        
                #
                # Selecting the parent part
                #
                ensight.part.select_begin(1)
                #
                # Setting some attributes before creation
                # (the variable is being set here)
                #
                ensight.ptrace.begin()
                ensight.ptrace.variable("VITESSE")
                ensight.ptrace.type("streamline")
                ensight.ptrace.component(1.0000e+00,1.0000e+00,1.0000e+00)
                ensight.ptrace.representation("line")
                ensight.ptrace.end()
                #
                # Creating trace from a point
                #
                ensight.ptrace.create_pt()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.ptrace.variable({repr(p0)})'''
        return self._session.cmd(cmd)

    def variable_offset(self, p0: float) -> int:
        """Sets the distance from the surface into the flow field at which the velocity variable will be sampled.  The tangential component of the variable at this offset distance is the field that will be used to trace through for surface restricted traces.
        
        | A positive number moves the distance in the direction of the positive normal of the surface, while a negative number moves in the opposite direction.  If there is only flow on one side of the surface, the program will flip the sign internally.
        | Used only for surface restricted particle traces.
        
        Args:
            p0:
                'offset_distance' distance into the field
        
        Examples:
            ::
        
                #
                # Selecting the parent part
                #
                ensight.part.select_begin(1)
                #
                # Setting some attributes before creation
                # (the variable_offset for the surface_restricted trace
                #  is being set here)
                #
                ensight.ptrace.begin()
                ensight.part.description("Particle trace part")
                ensight.ptrace.surface_restricted("ON")
                ensight.ptrace.variable_offset(1.0000e-01)
                ensight.ptrace.display_offset(0.5000e+00)
                ensight.ptrace.total_time(2.0000e+02)
                ensight.ptrace.emit_at_current_time("ON")
                ensight.ptrace.end()
                #
                # Creating trace from a point
                #
                ensight.ptrace.create_pt()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.ptrace.variable_offset({repr(p0)})'''
        return self._session.cmd(cmd)

    def width_scale_factor(self, p0: float) -> int:
        """Ptrace: width_scale_factor

        """
        cmd = f'''ensight.ptrace.width_scale_factor({repr(p0)})'''
        return self._session.cmd(cmd)


class profile:
    """Class wrapper for EnSight profile module

    This class acts as a proxy for the EnSight Python module ensight.profile
    """
    def __init__(self, session: Session):
        self._session = session

    def begin(self) -> int:
        """Groups profile attribute commands to be applied together before a "profile: create" command.
        
        Args:
            p0:
                'profile_commands' any of the profile attribute commands
        
        Examples:
            ::
        
                ensight.profile.begin()
                ensight.profile.variable("VITESSE")
                ensight.profile.offset(0.0000e+00)
                ensight.profile.scale_factor(1.3603e+00)
                ensight.profile.end()
                ensight.profile.create()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.profile.begin()'''
        return self._session.cmd(cmd)

    def component(self, p0: float, p1: float, p2: float) -> int:
        """Specifies the contribution of a vector variable to be applied for profile generation.
        
        | If all the scale factors are set to 0.0, the magnitude of the vector will be used (this is the default).
        | Part selection and modify commands are used as needed since profiles are a part type based on a parent part.
        
        Args:
            p0:
                'x_scal' scale factor to apply to the x, y, z components of the vector
            p1:
                'y_scal' scale factor to apply to the x, y, z components of the vector
            p2:
                'z_scal' scale factor to apply to the x, y, z components of the vector
        
        Examples:
            ::
        
                ensight.profile.variable("VITESSE")
                ensight.part.select_begin(3)
                ensight.part.modify_begin()
                #
                # Use the y-component of the vector
                #
                ensight.profile.component(0.0000e+00,1.0000e+00,0.0000e+00)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.profile.component({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def create(self) -> int:
        """Create a profile part with the currently defined attributes using the currently selected parts as parents. 
        
        | The profile part is created using the currently selected parts as parents.  The profile part is creates using  the currently set profile attributes.
        
        Examples:
            ::
        
                #
                # Select parent part
                #
                ensight.part.select_begin(2)
                ensight.profile.begin()
                ensight.profile.variable("VITESSE")
                ensight.profile.offset(0.0000e+00)
                ensight.profile.scale_factor(1.3603e+00)
                ensight.profile.end()
                ensight.profile.create()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.profile.create()'''
        return self._session.cmd(cmd)

    def end(self) -> int:
        """Groups profile attribute commands to be applied together before a "profile: create" command.
        
        Args:
            p0:
                'profile_commands' any of the profile attribute commands
        
        Examples:
            ::
        
                ensight.profile.begin()
                ensight.profile.variable("VITESSE")
                ensight.profile.offset(0.0000e+00)
                ensight.profile.scale_factor(1.3603e+00)
                ensight.profile.end()
                ensight.profile.create()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.profile.end()'''
        return self._session.cmd(cmd)

    def from_point(self, p0: float, p1: float, p2: float) -> int:
        """Profile: from_point

        """
        cmd = f'''ensight.profile.from_point({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def in_plane(self, p0: float, p1: float, p2: float, p3: float) -> int:
        """Specify the location of the orientation points for profile generation.
        
        | Three points define the plane in which the profile will be projected. The corresponding 4th point is generated and the center of these 4 points determines which direction the profile will projected in the plane.
        
        Args:
            p0:
                'point' must be 1, 2, or 3 (indicating which point is being specified)
        
        Examples:
            ::
        
                #
                #  Select existing profile part
                #
                ensight.part.select_begin(3)
                ensight.part.modify_begin()
                ensight.profile.in_plane(1,1.1977e+00,2.5928e+00,-9.6950e+00)
                ensight.profile.in_plane(2,2.0198e+01,2.5928e+00,-9.6950e+00)
                ensight.profile.in_plane(3,2.0198e+01,9.5655e+00,7.9793e+00)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.profile.in_plane({repr(p0)},{repr(p1)},{repr(p2)},{repr(p3)})'''
        return self._session.cmd(cmd)

    def in_plane_1(self, p0: float, p1: float, p2: float) -> int:
        """Profile: in_plane 1

        """
        cmd = f'''ensight.profile.in_plane_1({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def in_plane_2(self, p0: float, p1: float, p2: float) -> int:
        """Profile: in_plane 2

        """
        cmd = f'''ensight.profile.in_plane_2({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def in_plane_3(self, p0: float, p1: float, p2: float) -> int:
        """Profile: in_plane 3

        """
        cmd = f'''ensight.profile.in_plane_3({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def offset(self, p0: float) -> int:
        """Add a value to the variable values before scaling the profile.
        
        | This command has the effect of shifting the profile up or down relative to the parent part(s). 
        
        Args:
            p0:
                'value'  value to add to the variable values before scaling
        
        Examples:
            ::
        
                #
                # Select existing profile part
                #
                ensight.part.select_begin(3)
                ensight.part.modify_begin()
                ensight.profile.offset(1.0000e+00)
                ensight.profile.scale_factor(2.0000e+00)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.profile.offset({repr(p0)})'''
        return self._session.cmd(cmd)

    def scale_factor(self, p0: float) -> int:
        """Apply a scale factor to the variable values of the profile.
        
        Args:
            p0:
                'value' scale factor to apply to the variable values
        
        Examples:
            ::
        
                #
                # Select existing profile part
                #
                ensight.part.select_begin(3)
                ensight.part.modify_begin()
                ensight.profile.offset(3.0000e+00)
                ensight.profile.scale_factor(1.5000e+01)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.profile.scale_factor({repr(p0)})'''
        return self._session.cmd(cmd)

    def select_default(self) -> int:
        """Sets the current profile to none, so that subsequent commands will modify the default profile attributes.
        
        | When profiles are created, the default attributes are used (unless overridden by attribute commands between "profile: begin / end" commands.  This command allows for changing of defaults.
        
        Examples:
            ::
        
                ensight.profile.select_default()
                ensight.profile.offset(0.0000e+00)
                ensight.profile.scale_factor(1.0000e+00)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.profile.select_default()'''
        return self._session.cmd(cmd)

    def var_type(self, p0: str) -> int:
        """Profile: var_type

        """
        cmd = f'''ensight.profile.var_type({repr(p0)})'''
        return self._session.cmd(cmd)

    def variable(self, p0: Any) -> int:
        """Sets the variable to use for profile creation or modification.
        
        Args:
            p0:
                'name' variable name
        
        Examples:
            ::
        
                #
                # Select existing profile part
                #
                ensight.part.select_begin(2)
                ensight.profile.begin()
                ensight.profile.variable("VITESSE")
                ensight.profile.end()
                ensight.profile.create()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.profile.variable({repr(p0)})'''
        return self._session.cmd(cmd)


class prefs:
    """Class wrapper for EnSight prefs module

    This class acts as a proxy for the EnSight Python module ensight.prefs
    """
    def __init__(self, session: Session):
        self._session = session

    def abort_server_operations(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.prefs.abort_server_operations({repr(p0)})'''
        return self._session.cmd(cmd)

    def abort_server_time(self, p0: int) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.prefs.abort_server_time({repr(p0)})'''
        return self._session.cmd(cmd)

    def allmodelusecompdisplace(self, p0: str) -> int:
        """Prefs: allmodelusecompdisplace

        """
        cmd = f'''ensight.prefs.allmodelusecompdisplace({repr(p0)})'''
        return self._session.cmd(cmd)

    def animate_model_axis(self, p0: str) -> int:
        """Prefs: animate_model_axis

        """
        cmd = f'''ensight.prefs.animate_model_axis({repr(p0)})'''
        return self._session.cmd(cmd)

    def auto_contrast_foreground(self, p0: str) -> int:
        """Prefs: auto_contrast_foreground

        """
        cmd = f'''ensight.prefs.auto_contrast_foreground({repr(p0)})'''
        return self._session.cmd(cmd)

    def auto_legend_display(self, p0: str) -> int:
        """Will cause the legend to automatically appear when you color a part by a variable.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.prefs.auto_legend_replace("ON")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.prefs.auto_legend_display({repr(p0)})'''
        return self._session.cmd(cmd)

    def auto_legend_replace(self, p0: str) -> int:
        """Preference that will cause legends to be automatically replaced when the current legend is no longer in use (i.e. no parts are colored by the variable) and a  new variable is in use.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.prefs.auto_legend_replace("ON")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.prefs.auto_legend_replace({repr(p0)})'''
        return self._session.cmd(cmd)

    def auto_load_parts(self, p0: str) -> int:
        """Allows you to have EnSight automatically load parts when the data file is read.
        
        Args:
            p0:
                'method'
        
                * Must be one of:
                * all
                * none
        
        Examples:
            ::
        
                ensight.prefs.starting_time_step("last")
                ensight.prefs.auto_load_parts("all")
                ensight.data.binary_files_are("big_endian")
                ensight.data.format("case")
                ensight.data.path("/usr/tmp")
                ensight.data.geometry("car_crash.case")
                ensight.data.read()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.prefs.auto_load_parts({repr(p0)})'''
        return self._session.cmd(cmd)

    def balloon_help(self, p0: str) -> int:
        """Prefs: balloon_help

        """
        cmd = f'''ensight.prefs.balloon_help({repr(p0)})'''
        return self._session.cmd(cmd)

    def binary_files_are(self, p0: str) -> int:
        """Prefs: binary_files_are

        """
        cmd = f'''ensight.prefs.binary_files_are({repr(p0)})'''
        return self._session.cmd(cmd)

    def cull_lines(self, p0: str) -> int:
        """Will only draw shared lines between polygons once.  May help performance.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.prefs.cull_lines("ON")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.prefs.cull_lines({repr(p0)})'''
        return self._session.cmd(cmd)

    def default_data_directory(self, p0: str) -> int:
        """Preference to set the default directory where the user's data resides.
        
        Args:
            p0:
                'directory_name' name of the default directory
        
        Examples:
            ::
        
                ensight.prefs.default_data_directory("/usr/local/bin/ensight92/data/ami")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.prefs.default_data_directory({repr(p0)})'''
        return self._session.cmd(cmd)

    def default_data_filefilter(self, p0: str) -> int:
        """Prefs: default_data_filefilter

        """
        cmd = f'''ensight.prefs.default_data_filefilter({repr(p0)})'''
        return self._session.cmd(cmd)

    def default_palette(self, p0: str) -> int:
        """Preference to override the default EnSight color palette with a user predefined palette.
        
        | When EnSight starts, it looks for user defined function color palettes located under                 $CEI_HOME/ensight92/site_preferences/palettes and in the ./palettes directory found in the user's home directory. These files must be named palette_name.cpal, where the palette_name will be the name of the color palette  in the Simple Interface area of the function dialog.
        
        Args:
            p0:
                'predefined_palette_name' palette name
        
        Examples:
            ::
        
                ensight.prefs.default_palette("FASTDefaultPalette")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.prefs.default_palette({repr(p0)})'''
        return self._session.cmd(cmd)

    def detailrep_point_res(self, p0: int) -> int:
        """Prefs: detailrep_point_res

        """
        cmd = f'''ensight.prefs.detailrep_point_res({repr(p0)})'''
        return self._session.cmd(cmd)

    def fastdisplay_point_res(self, p0: int) -> int:
        """Allows specification of fraction of nodes to display in fast display-point representation. The default is 1 (indicating all nodes), 2 (would be every other node), 3 (every third node), etc.
        
        | May help performance. 
        
        Args:
            p0:
                'value' >= 1
        
        Examples:
            ::
        
                ensight.view.fast_display("ON")
                ensight.prefs.static_fast_display("ON")
                ensight.prefs.fastdisplay_point_res(2)
                ensight.part.select_begin(1,3,4)
                ensight.part.modify_begin()
                ensight.part.bounding_rep("points")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.prefs.fastdisplay_point_res({repr(p0)})'''
        return self._session.cmd(cmd)

    def fastdisplay_sparse_res(self, p0: int) -> int:
        """Allows specification of the percentage of the model geometry that will be displayed. The default is 50. The range is 1-100 where 1 would be sparse and 100 would be full.
        
        | Will help performance but will degrade quality in the graphics window while interactively transforming the model.
        
        Args:
            p0:
                'value' (1-100)
        
        Examples:
            ::
        
                ensight.view.fast_display("ON")
                ensight.prefs.static_fast_display("ON")
                ensight.prefs.fastdisplay_sparse_res(75)
                ensight.part.select_begin(1,3,4)
                ensight.part.modify_begin()
                ensight.part.bounding_rep("sparse_model")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.prefs.fastdisplay_sparse_res({repr(p0)})'''
        return self._session.cmd(cmd)

    def frame_mode_allowed(self, p0: str) -> int:
        """Will display Frame as one of the modes along the left side of the EnSight main interface.
        
        | As EnSight reads in model Parts, they are all initially assigned to the same Frame of reference: Frame 0. Frame 0 corresponds to the model coordinate system (defined when the model was created). Using the Frame mode, you can create additional frames, reassign parts to different frames, and specify various attributes of the frames.  By default frame mode is not available because frame mode is an advanced feature not normally used by first time users.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.prefs.frame_mode_allowed("ON")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.prefs.frame_mode_allowed({repr(p0)})'''
        return self._session.cmd(cmd)

    def function_editor_type(self, p0: str) -> int:
        """Preference to set the default type of interface used for editing in the variable function editor.
        
        Args:
            p0:
                'interface_type'
        
                * must be one of:
                * simple
                * advanced
        
        Examples:
            ::
        
                # WARNING: following line includes OBSOLETE call (ensight.prefs.function_editor_type).
                ensight.prefs.function_editor_type("simple")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.prefs.function_editor_type({repr(p0)})'''
        return self._session.cmd(cmd)

    def highlight_textfields(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.prefs.highlight_textfields({repr(p0)})'''
        return self._session.cmd(cmd)

    def icon_help_labels(self, p0: str) -> int:
        """Will cause a help label to appear below the mode icons along the left side of the main EnSight interface.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.prefs.icon_help_labels("ON")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.prefs.icon_help_labels({repr(p0)})'''
        return self._session.cmd(cmd)

    def large_parts_list(self, p0: str) -> int:
        """Will cause a separate, larger parts list dialog (which can be expanded) to be used in place of the normal parts list.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.prefs.large_parts_list("ON")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.prefs.large_parts_list({repr(p0)})'''
        return self._session.cmd(cmd)

    def legend_colorby(self, p0: str) -> int:
        """Specifies whether color palettes will be RGB or textures.
        
        Args:
            p0:
                'option'
        
                * RGB
                * textures
        
        Examples:
            ::
        
                # WARNING: following line includes OBSOLETE call (ensight.prefs.legend_colorby).
                ensight.prefs.legend_colorby("textures")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.prefs.legend_colorby({repr(p0)})'''
        return self._session.cmd(cmd)

    def macro_panel(self, p0: str) -> int:
        """Toggles on/off the user defined macro panel. This is normally used with VR devices and user defined input. The macro panel will be displayed in the main graphics window.
        
        | Users define the macro panel layout and actions in the ~/./macros/hum.define file.  An example hum.define file is located at $CEI_HOME/ensight92/src/udi/HUM/hum.define on your client system.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.prefs.macro_panel("ON")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.prefs.macro_panel({repr(p0)})'''
        return self._session.cmd(cmd)

    def minimize_redraw(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.prefs.minimize_redraw({repr(p0)})'''
        return self._session.cmd(cmd)

    def model_axis_location(self, p0: float, p1: float) -> int:
        """Prefs: model_axis_location

        """
        cmd = f'''ensight.prefs.model_axis_location({repr(p0)},{repr(p1)})'''
        return self._session.cmd(cmd)

    def new_data_notification(self, p0: str) -> int:
        """Tells client how to handle dynamic data updates.
        
        | Used in conjunction with the dynamic data interface
        
        Args:
            p0:
                'type'
        
                * auto_update
                * ignore
                * prompt
        
        Examples:
            ::
        
                ensight.prefs.new_data_notification("auto_update")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.prefs.new_data_notification({repr(p0)})'''
        return self._session.cmd(cmd)

    def nfaced_decomp_method(self, p0: str) -> int:
        """Prefs: nfaced_decomp_method

        """
        cmd = f'''ensight.prefs.nfaced_decomp_method({repr(p0)})'''
        return self._session.cmd(cmd)

    def number_of_peels(self, p0: int) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.prefs.number_of_peels({repr(p0)})'''
        return self._session.cmd(cmd)

    def number_of_server_cpus(self, p0: int) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.prefs.number_of_server_cpus({repr(p0)})'''
        return self._session.cmd(cmd)

    def optimize_geometry(self, p0: str) -> int:
        """Prefs: optimize_geometry

        """
        cmd = f'''ensight.prefs.optimize_geometry({repr(p0)})'''
        return self._session.cmd(cmd)

    def part_panel(self, p0: str) -> int:
        """Toggles on/off the part panel which allows users to select parts to operate on.  Normally used with VR devices and user defined input when the main part list is not visible (ie. Full screen graphics window).  The part panel will be displayed in the main graphics window.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.prefs.part_panel("ON")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.prefs.part_panel({repr(p0)})'''
        return self._session.cmd(cmd)

    def partlist_details(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.prefs.partlist_details({repr(p0)})'''
        return self._session.cmd(cmd)

    def partlist_displayattr(self, p0: str, p1: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.prefs.partlist_displayattr({repr(p0)},{repr(p1)})'''
        return self._session.cmd(cmd)

    def partlist_displaycase(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.prefs.partlist_displaycase({repr(p0)})'''
        return self._session.cmd(cmd)

    def partlist_displaytree(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.prefs.partlist_displaytree({repr(p0)})'''
        return self._session.cmd(cmd)

    def partlist_sort(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.prefs.partlist_sort({repr(p0)})'''
        return self._session.cmd(cmd)

    def plane_tool_type(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.prefs.plane_tool_type({repr(p0)})'''
        return self._session.cmd(cmd)

    def prompt_on_quit(self, p0: str) -> int:
        """Prefs: prompt_on_quit

        """
        cmd = f'''ensight.prefs.prompt_on_quit({repr(p0)})'''
        return self._session.cmd(cmd)

    def resetlegend_ontimechange(self, p0: str) -> int:
        """Toggles on/off the preference of having the legend ranges update when time is changed or not.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.prefs.resetlegend_ontimechange("OFF")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.prefs.resetlegend_ontimechange({repr(p0)})'''
        return self._session.cmd(cmd)

    def starting_time_step(self, p0: str) -> int:
        """Preference to set the default starting time step for transient data.  When the data is read the first or the last step will be loaded as specified.
        
        Args:
            p0:
                'value'
        
                * must be one of:
                * first
                * last
        
        Examples:
            ::
        
                ensight.prefs.starting_time_step("last")
                ensight.data.binary_files_are("big_endian")
                ensight.data.format("case")
                ensight.data.path("/usr/tmp")
                ensight.data.geometry("car_crash.case")
                ensight.data.read()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.prefs.starting_time_step({repr(p0)})'''
        return self._session.cmd(cmd)

    def static_fast_display(self, p0: str) -> int:
        """Will cause the fast display representation to always be displayed when the fast display toggle is on.  If static_fast_display is off (the default), fast display will only be active during a transformation.
        
        | This is a performance enhancing attribute.  This attribute can be used to work with very large models.  Large models can be too slow in full element representation to manipulate (ie. transforming, positioning tools, etc.)
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.view.fast_display("ON")
                ensight.prefs.static_fast_display("ON")
                ensight.part.select_begin(1,3,4)
                ensight.part.modify_begin()
                ensight.part.bounding_rep("points")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.prefs.static_fast_display({repr(p0)})'''
        return self._session.cmd(cmd)

    def tool_tips(self, p0: str) -> int:
        """Will cause pop-up help information to appear when the mouse is placed over certain icons while running EnSight.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.prefs.tool_tips("ON")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.prefs.tool_tips({repr(p0)})'''
        return self._session.cmd(cmd)

    def transparency_resort(self, p0: str) -> int:
        """Prefs: transparency_resort

        """
        cmd = f'''ensight.prefs.transparency_resort({repr(p0)})'''
        return self._session.cmd(cmd)

    def transparency_sort(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.prefs.transparency_sort({repr(p0)})'''
        return self._session.cmd(cmd)

    def undo_redo_history_count(self, p0: int) -> int:
        """Prefs: undo_redo_history_count

        """
        cmd = f'''ensight.prefs.undo_redo_history_count({repr(p0)})'''
        return self._session.cmd(cmd)

    def use_continuous_perelem(self, p0: str) -> int:
        """If on, display element variables as per node for the purpose of creating contour (filled or line) images.
        
        | When on, the per element variable is averaged to the nodes using node count weighted algorithm.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                #
                # set the preference to show the per element colored as a per node variable
                ensight.prefs.use_continuous_perelem("ON")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.prefs.use_continuous_perelem({repr(p0)})'''
        return self._session.cmd(cmd)

    def user_defined_input(self, p0: str) -> int:
        """Toggles on/off the User Defined Input Device that is linked via a runtime library.  This is normally used with VR devices.
        
        | Steps outlining the implementation of this library and input device are found in the file: $CEI_HOME/ensight92/src/input/README.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.prefs.user_defined_input("ON")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.prefs.user_defined_input({repr(p0)})'''
        return self._session.cmd(cmd)

    def user_input_postranssens(self, p0: float) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.prefs.user_input_postranssens({repr(p0)})'''
        return self._session.cmd(cmd)

    def user_input_rotatesens(self, p0: float) -> int:
        """Specifies a scalar value that adjusts the sensitivity of rotates when using a User Defined Input Device (i.e. values < 1 are slower, and values > 1 are faster).
        
        | Steps outlining the implementation of the library for input devices are found in the file: $CEI_HOME/ensight92/src/input/README.
        
        Args:
            p0:
                'value' must be > 0.0
        
        Examples:
            ::
        
                ensight.prefs.user_defined_input("ON")
                ensight.prefs.user_input_rotateusing("Position")
                ensight.prefs.user_input_rotatesens(0.5)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.prefs.user_input_rotatesens({repr(p0)})'''
        return self._session.cmd(cmd)

    def user_input_rotateusing(self, p0: str) -> int:
        """Allows selection of the type of rotation mode used for rotate transformations for the User Defined Input Device.
        
        | Steps outlining the implementation of the library for input devices are found in the file: $CEI_HOME/ensight92/src/input/README.
        
        Args:
            p0:
                'rotate_mode'
        
                * must be one of:
                * mixed_mode 
                * direct_mode
        
        Examples:
            ::
        
                ensight.prefs.user_defined_input("ON")
                ensight.prefs.user_input_rotateusing("direct_mode")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.prefs.user_input_rotateusing({repr(p0)})'''
        return self._session.cmd(cmd)

    def user_input_rtzlimit(self, args: Any) -> int:
        """Prefs: user_input_rtzlimit

        """
        cmd = f'''ensight.prefs.user_input_rtzlimit({repr(args)})'''
        return self._session.cmd(cmd)

    def user_input_valtranssens(self, p0: float) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.prefs.user_input_valtranssens({repr(p0)})'''
        return self._session.cmd(cmd)

    def user_input_zoomsens(self, p0: float) -> int:
        """Specifies a value that adjusts the sensitivity of the zoom operation for the User Defined Input Device.
        
        | Steps outlining the implementation of the library for input devices are found in the file: $CEI_HOME/ensight92/src/input/README.
        
        Args:
            p0:
                'value' must be > 0.0  (< 1 slower, > 1 faster)
        
        Examples:
            ::
        
                ensight.prefs.user_defined_input("ON")
                ensight.prefs.user_input_zoomusing("position")
                ensight.prefs.user_input_zoomsens(1.5)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.prefs.user_input_zoomsens({repr(p0)})'''
        return self._session.cmd(cmd)

    def user_input_zoomusing(self, p0: str) -> int:
        """Allows selection of the mode used for zoom transformations for the User Defined Input Device.
        
        | Steps outlining the implementation of the library for input devices are found in the file: $CEI_HOME/ensight92/src/input/README.
        
        Args:
            p0:
                'mode'
        
                * must be one of:
                * valuator
                * position
        
        Examples:
            ::
        
                ensight.prefs.user_defined_input("ON")
                ensight.prefs.user_input_zoomusing("position")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.prefs.user_input_zoomusing({repr(p0)})'''
        return self._session.cmd(cmd)

    def view_mode_allowed(self, p0: str) -> int:
        """Will display View as one of the modes along the left side of the EnSight main interface.
        
        | View Mode is used to adjust the appearance of Parts in the Graphics Window (Perspective, Static Color, etc.), the visibility and appearance of Labels, to adjust Auxiliary Clipping status, and to toggle visibility of the Global Axis triad. By default, this mode is not available because the attributes are available under the View menu of the main interface.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.prefs.view_mode_allowed("ON")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.prefs.view_mode_allowed({repr(p0)})'''
        return self._session.cmd(cmd)

    def vr_annotation_center(self, p0: float, p1: float, p2: float) -> int:
        """Prefs: vr_annotation_center

        """
        cmd = f'''ensight.prefs.vr_annotation_center({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def vr_annotation_normal(self, p0: float, p1: float, p2: float) -> int:
        """Prefs: vr_annotation_normal

        """
        cmd = f'''ensight.prefs.vr_annotation_normal({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def vr_annotation_scale(self, p0: float, p1: float) -> int:
        """Prefs: vr_annotation_scale

        """
        cmd = f'''ensight.prefs.vr_annotation_scale({repr(p0)},{repr(p1)})'''
        return self._session.cmd(cmd)

    def vr_annotation_up(self, p0: float, p1: float, p2: float) -> int:
        """Prefs: vr_annotation_up

        """
        cmd = f'''ensight.prefs.vr_annotation_up({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def vr_view_center(self, p0: float, p1: float, p2: float) -> int:
        """Prefs: vr_view_center

        """
        cmd = f'''ensight.prefs.vr_view_center({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def vr_view_diagonal(self, p0: float) -> int:
        """Prefs: vr_view_diagonal

        """
        cmd = f'''ensight.prefs.vr_view_diagonal({repr(p0)})'''
        return self._session.cmd(cmd)

    def vr_view_scale(self, p0: float) -> int:
        """Prefs: vr_view_scale

        """
        cmd = f'''ensight.prefs.vr_view_scale({repr(p0)})'''
        return self._session.cmd(cmd)

    def vr_view_scalebydiagonal(self, p0: str) -> int:
        """Prefs: vr_view_scalebydiagonal

        """
        cmd = f'''ensight.prefs.vr_view_scalebydiagonal({repr(p0)})'''
        return self._session.cmd(cmd)


class pointpart:
    """Class wrapper for EnSight pointpart module

    This class acts as a proxy for the EnSight Python module ensight.pointpart
    """
    def __init__(self, session: Session):
        self._session = session

    def add_point(self, p0: float, p1: float, p2: float) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.pointpart.add_point({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def begin(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.pointpart.begin()'''
        return self._session.cmd(cmd)

    def create(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.pointpart.create({repr(p0)})'''
        return self._session.cmd(cmd)

    def delete_points(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.pointpart.delete_points()'''
        return self._session.cmd(cmd)

    def edit_point(self, p0: float, p1: float, p2: float) -> int:
        """Pointpart: edit_point

        """
        cmd = f'''ensight.pointpart.edit_point({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def elt_defined_by(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Args:
            p0:
                'option'
        
                * mesh_points_toline
                * mesh_points_totris
                * mesh_points_totris
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.pointpart.elt_defined_by({repr(p0)})'''
        return self._session.cmd(cmd)

    def end(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.pointpart.end()'''
        return self._session.cmd(cmd)

    def load_from_file(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.pointpart.load_from_file({repr(p0)})'''
        return self._session.cmd(cmd)

    def point_select_begin(self, *args, **kwargs) -> Any:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.pointpart.point_select_begin({arg_string})"
        return self._session.cmd(cmd)

    def select_all_points(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.pointpart.select_all_points()'''
        return self._session.cmd(cmd)

    def select_default(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.pointpart.select_default()'''
        return self._session.cmd(cmd)

    def update_points(self, args: Any) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.pointpart.update_points({repr(args)})'''
        return self._session.cmd(cmd)


class plot:
    """Class wrapper for EnSight plot module

    This class acts as a proxy for the EnSight Python module ensight.plot
    """
    def __init__(self, session: Session):
        self._session = session

    def animate_curves(self, p0: str) -> int:
        """Turns animation of curves with time on or off  for the currently selected plot(s). For use with transient flipbook or keyframe animations.
        
        Args:
            p0:
                'toggle'
        
                * ON  (default)
                * OFF
        
        Examples:
            ::
        
                ensight.plot.select_begin(1)
                ensight.plot.animate_curves("ON")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.plot.animate_curves({repr(p0)})'''
        return self._session.cmd(cmd)

    def auto_scale(self, p0: str) -> int:
        """Plot: auto_scale

        """
        cmd = f'''ensight.plot.auto_scale({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_2_autoscale(self, p0: str) -> int:
        """Plot: axis_2_autoscale

        """
        cmd = f'''ensight.plot.axis_2_autoscale({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_2_labelformat(self, p0: str) -> int:
        """Plot: axis_2_labelformat

        """
        cmd = f'''ensight.plot.axis_2_labelformat({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_2_labelrgb(self, p0: float, p1: float, p2: float) -> int:
        """Plot: axis_2_labelrgb

        """
        cmd = f'''ensight.plot.axis_2_labelrgb({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def axis_2_labelsize(self, p0: int) -> int:
        """Plot: axis_2_labelsize

        """
        cmd = f'''ensight.plot.axis_2_labelsize({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_2_labeltype(self, p0: str) -> int:
        """Plot: axis_2_labeltype

        """
        cmd = f'''ensight.plot.axis_2_labeltype({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_2_max(self, p0: float) -> int:
        """Plot: axis_2_max

        """
        cmd = f'''ensight.plot.axis_2_max({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_2_min(self, p0: float) -> int:
        """Plot: axis_2_min

        """
        cmd = f'''ensight.plot.axis_2_min({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_2_title(self, p0: str) -> int:
        """Plot: axis_2_title

        """
        cmd = f'''ensight.plot.axis_2_title({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_2_titlergb(self, p0: float, p1: float, p2: float) -> int:
        """Plot: axis_2_titlergb

        """
        cmd = f'''ensight.plot.axis_2_titlergb({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def axis_2_titlesize(self, p0: int) -> int:
        """Plot: axis_2_titlesize

        """
        cmd = f'''ensight.plot.axis_2_titlesize({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_2_variable(self, p0: Any) -> int:
        """Plot: axis_2_variable

        """
        cmd = f'''ensight.plot.axis_2_variable({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_2_visible(self, p0: str) -> int:
        """Plot: axis_2_visible

        """
        cmd = f'''ensight.plot.axis_2_visible({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_auto_layout(self, p0: str) -> int:
        """Plot: axis_auto_layout

        """
        cmd = f'''ensight.plot.axis_auto_layout({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_auto_update(self, p0: str) -> int:
        """Plot: axis_auto_update

        """
        cmd = f'''ensight.plot.axis_auto_update({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_linewidth(self, p0: int) -> int:
        """Sets the axis line width of the currently selected plot(s).
        
        Args:
            p0:
                'width' specifies the width in pixels and can be any value from  1 to 4
        
        Examples:
            ::
        
                ensight.plot.select_begin(1)
                ensight.plot.axis_linewidth(2)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.plot.axis_linewidth({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_rgb(self, p0: float, p1: float, p2: float) -> int:
        """Specifies the RGB color value of the axis for the currently selected plot(s).
        
        Args:
            p0:
                'red_val' red, green, blue color components, must be between 0.0 and 1.0
            p1:
                'grn_val' red, green, blue color components, must be between 0.0 and 1.0
            p2:
                'blu_val' red, green, blue color components, must be between 0.0 and 1.0
        
        Examples:
            ::
        
                ensight.plot.select_begin(1)
                #
                # Set the plot axis to blue
                #
                ensight.plot.axis_rgb(0,0,1)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.plot.axis_rgb({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def axis_swap(self, p0: str) -> int:
        """Plot: axis_swap

        """
        cmd = f'''ensight.plot.axis_swap({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_swap_minmax(self, p0: str) -> int:
        """Swaps the axis min and max values for the specified axis of the currently selected plot.
        
        | By default the values increase along the axis.
        
        Args:
            p0:
                'axis'
        
                * must be either x or y
        
        Examples:
            ::
        
                ensight.plot.select_begin(1)
                ensight.plot.axis_swap_minmax("x")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.plot.axis_swap_minmax({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_title(self, p0: str) -> int:
        """Plot: axis_title

        """
        cmd = f'''ensight.plot.axis_title({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_titles(self, p0: str) -> int:
        """Plot: axis_titles

        """
        cmd = f'''ensight.plot.axis_titles({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_x_autoscale(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.plot.axis_x_autoscale({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_x_gridtype(self, p0: str) -> int:
        """Specifies the type of grid that will be drawn for the x/y axis of the currently selected plot.
        
        |  The default grid type is tick.
        
        Args:
            p0:
                'grid_type'
        
                * Can be any of the following values:
                * none
                * grid
                * tick
        
        Examples:
            ::
        
                ensight.plot.select_begin(1)
                ensight.plot.axis_x_gridtype("tick")
                ensight.plot.axis_y_gridtype("grid")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.plot.axis_x_gridtype({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_x_labelformat(self, p0: str) -> int:
        """Sets the format to be used for x/y axis value labels in the currently selected plot.
        
        Args:
            p0:
                'format' may be any valid C language print format string
        
        Examples:
            ::
        
                ensight.plot.select_begin(1)
                ensight.plot.axis_x_labelformat("%.2e")
                ensight.plot.axis_y_labelformat("%.3e")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.plot.axis_x_labelformat({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_x_labelrgb(self, p0: float, p1: float, p2: float) -> int:
        """Specifies the RGB color value of the x/y axis label for the currently selected plot(s).
        
        Args:
            p0:
                'red_val' red, green, blue color components, must be between 0.0 and 1.0.
            p1:
                'grn_val' red, green, blue color components, must be between 0.0 and 1.0.
            p2:
                'blu_val' red, green, blue color components, must be between 0.0 and 1.0.
        
        Examples:
            ::
        
                ensight.plot.select_begin(1)
                ensight.plot.axis_x_labelrgb(0,0,1)
                ensight.plot.axis_y_labelrgb(1,0,0)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.plot.axis_x_labelrgb({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def axis_x_labelsize(self, p0: int) -> int:
        """Sets the size of the x/y axis label text in the currently selected plot.
        
        Args:
            p0:
                'size' label text size; can be any value from 1 to 100.0, with a value of one specifying the smallest text and 100 the largest.
        
        Examples:
            ::
        
                ensight.plot.select_begin(1)
                ensight.plot.axis_x_labelsize(10)
                ensight.plot.axis_y_labelsize(10)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.plot.axis_x_labelsize({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_x_labeltype(self, p0: str) -> int:
        """Specifies how the x/y axis is labeled in the currently selected  plot.
        
        |  The default value for x/y axis label type is all.
        
        Args:
            p0:
                'label_type'
        
                * Can be any of the following values:
                * none
                * all
                * beg_end
        
        Examples:
            ::
        
                ensight.plot.select_begin(1)
                ensight.plot.axis_x_labeltype("none")
                ensight.plot.axis_y_labeltype("beg_end")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.plot.axis_x_labeltype({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_x_max(self, p0: float) -> int:
        """Sets the maximum value for the x/y axis labels in the currently selected plot.
        
        Args:
            p0:
                'max' max label number on the axis; can be any valid floating-point value
        
        Examples:
            ::
        
                ensight.plot.select_begin(1)
                ensight.plot.axis_x_max(9.5)
                ensight.plot.axis_y_max(5.3)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.plot.axis_x_max({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_x_min(self, p0: float) -> int:
        """Sets the minimum value for the x/y axis labels in the currently selected plot.
        
        Args:
            p0:
                'min' min label number on the axis; can be any valid floating-point value
        
        Examples:
            ::
        
                ensight.plot.select_begin(1)
                ensight.plot.axis_x_min(1.5)
                ensight.plot.axis_y_min(1.5)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.plot.axis_x_min({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_x_numgrid(self, p0: float) -> int:
        """Sets the number of grid lines to be used along the x/y axis of the currently selected plot(s).
        
        Args:
            p0:
                'num' number of grid lines along the axis; can be any whole number
        
        Examples:
            ::
        
                ensight.plot.select_begin(1)
                ensight.plot.axis_x_numgrid(10)
                ensight.plot.axis_y_numgrid(6)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.plot.axis_x_numgrid({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_x_numsubgrid(self, p0: float) -> int:
        """Sets the number of subgrid lines to be used along the x/y axis of the currently selected plot(s).
        
        | While the argument to this command is a floating-point value, the actual number of grid lines drawn will be truncated to an integer.
        
        Args:
            p0:
                'num' number of subgrid lines (or ticks) to be used between grid lines along an axis; can be any whole number
        
        Examples:
            ::
        
                ensight.plot.select_begin(1)
                ensight.plot.axis_x_numsubgrid(2)
                ensight.plot.axis_y_numsubgrid(1)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.plot.axis_x_numsubgrid({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_x_origin(self, p0: float) -> int:
        """Sets the value of the x/y axis origin for the currently selected plot(s).
        
        | The default x/y axis origin is 0.
        
        Args:
            p0:
                'origin' x or y location of origin within the plotter; range is the normalized values 0.0 to 1.0
        
        Examples:
            ::
        
                ensight.plot.select_begin(1)
                ensight.plot.axis_x_origin(0.25)
                ensight.plot.axis_y_origin(0.18)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.plot.axis_x_origin({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_x_scale(self, p0: str) -> int:
        """Selects the type of scale used for the x/y axis of the currently selected plot(s).
        
        |  The default scale is linear. 
        
        Args:
            p0:
                'scale_type'
        
                * one of the following:
                * linear
                * logarithmic
        
        Examples:
            ::
        
                ensight.plot.select_begin(1)
                ensight.plot.axis_x_scale("logarithmic")
                ensight.plot.axis_y_scale("linear")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.plot.axis_x_scale({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_x_sgridtype(self, p0: str) -> int:
        """Specifies the type of subgrid that will be drawn for the x/y axis of the currently selected  plot.
        
        |  The default subgrid type is none.
        
        Args:
            p0:
                'grid_type'
        
                * Can be any of the following values:
                * none
                * grid
                * tick
        
        Examples:
            ::
        
                ensight.plot.select_begin(1)
                ensight.plot.axis_x_sgridtype("tick")
                ensight.plot.axis_y_sgridtype("grid")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.plot.axis_x_sgridtype({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_x_size(self, p0: float) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.plot.axis_x_size({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_x_title(self, p0: str) -> int:
        """Sets the title string for the x/y axis of the currently selected plot.
        
        Args:
            p0:
                'title' x/y axis title
        
        Examples:
            ::
        
                ensight.plot.select_begin(1)
                ensight.plot.axis_x_title("Time in Seconds")
                ensight.plot.axis_y_title("Pressure")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.plot.axis_x_title({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_x_titlergb(self, p0: float, p1: float, p2: float) -> int:
        """Specifies the RGB color value of the x/y axis title for the currently selected plot(s).
        
        Args:
            p0:
                'red_val' red, green, blue color components, must be between 0.0 and 1.0
            p1:
                'grn_val' red, green, blue color components, must be between 0.0 and 1.0
            p2:
                'blu_val' red, green, blue color components, must be between 0.0 and 1.0
        
        Examples:
            ::
        
                ensight.plot.select_begin(1)
                ensight.plot.axis_x_titlergb(0,0,1)
                ensight.plot.axis_y_titlergb(0,1,0)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.plot.axis_x_titlergb({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def axis_x_titlesize(self, p0: int) -> int:
        """Sets the size of the x/y axis title in the currently selected plot.
        
        Args:
            p0:
                'size' axis title text size; can be any value from 1 to 100.0, with a value of one specifying the smallest text and 100 the largest.
        
        Examples:
            ::
        
                ensight.plot.select_begin(1)
                ensight.plot.axis_x_titlesize(10)
                ensight.plot.axis_y_titlesize(12)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.plot.axis_x_titlesize({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_x_visible(self, p0: str) -> int:
        """Controls the visibility of the x/y axis of the currently selected plot(s).
        
        |  Plot axes are visible by default.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.plot.select_begin(1)
                ensight.plot.axis_x_visible("OFF")
                ensight.plot.axis_y_visible("ON")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.plot.axis_x_visible({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_y_autoscale(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.plot.axis_y_autoscale({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_y_gridtype(self, p0: str) -> int:
        """Specifies the type of grid that will be drawn for the x/y axis of the currently selected plot.
        
        |  The default grid type is tick.
        
        Args:
            p0:
                'grid_type'
        
                * Can be any of the following values:
                * none
                * grid
                * tick
        
        Examples:
            ::
        
                ensight.plot.select_begin(1)
                ensight.plot.axis_x_gridtype("tick")
                ensight.plot.axis_y_gridtype("grid")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.plot.axis_y_gridtype({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_y_labelformat(self, p0: str) -> int:
        """Sets the format to be used for x/y axis value labels in the currently selected plot.
        
        Args:
            p0:
                'format' may be any valid C language print format string
        
        Examples:
            ::
        
                ensight.plot.select_begin(1)
                ensight.plot.axis_x_labelformat("%.2e")
                ensight.plot.axis_y_labelformat("%.3e")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.plot.axis_y_labelformat({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_y_labelrgb(self, p0: float, p1: float, p2: float) -> int:
        """Specifies the RGB color value of the x/y axis label for the currently selected plot(s).
        
        Args:
            p0:
                'red_val' red, green, blue color components, must be between 0.0 and 1.0.
            p1:
                'grn_val' red, green, blue color components, must be between 0.0 and 1.0.
            p2:
                'blu_val' red, green, blue color components, must be between 0.0 and 1.0.
        
        Examples:
            ::
        
                ensight.plot.select_begin(1)
                ensight.plot.axis_x_labelrgb(0,0,1)
                ensight.plot.axis_y_labelrgb(1,0,0)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.plot.axis_y_labelrgb({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def axis_y_labelsize(self, p0: int) -> int:
        """Sets the size of the x/y axis label text in the currently selected plot.
        
        Args:
            p0:
                'size' label text size; can be any value from 1 to 100.0, with a value of one specifying the smallest text and 100 the largest.
        
        Examples:
            ::
        
                ensight.plot.select_begin(1)
                ensight.plot.axis_x_labelsize(10)
                ensight.plot.axis_y_labelsize(10)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.plot.axis_y_labelsize({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_y_labeltype(self, p0: str) -> int:
        """Specifies how the x/y axis is labeled in the currently selected  plot.
        
        |  The default value for x/y axis label type is all.
        
        Args:
            p0:
                'label_type'
        
                * Can be any of the following values:
                * none
                * all
                * beg_end
        
        Examples:
            ::
        
                ensight.plot.select_begin(1)
                ensight.plot.axis_x_labeltype("none")
                ensight.plot.axis_y_labeltype("beg_end")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.plot.axis_y_labeltype({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_y_max(self, p0: float) -> int:
        """Sets the maximum value for the x/y axis labels in the currently selected plot.
        
        Args:
            p0:
                'max' max label number on the axis; can be any valid floating-point value
        
        Examples:
            ::
        
                ensight.plot.select_begin(1)
                ensight.plot.axis_x_max(9.5)
                ensight.plot.axis_y_max(5.3)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.plot.axis_y_max({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_y_min(self, p0: float) -> int:
        """Sets the minimum value for the x/y axis labels in the currently selected plot.
        
        Args:
            p0:
                'min' min label number on the axis; can be any valid floating-point value
        
        Examples:
            ::
        
                ensight.plot.select_begin(1)
                ensight.plot.axis_x_min(1.5)
                ensight.plot.axis_y_min(1.5)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.plot.axis_y_min({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_y_numgrid(self, p0: float) -> int:
        """Sets the number of grid lines to be used along the x/y axis of the currently selected plot(s).
        
        Args:
            p0:
                'num' number of grid lines along the axis; can be any whole number
        
        Examples:
            ::
        
                ensight.plot.select_begin(1)
                ensight.plot.axis_x_numgrid(10)
                ensight.plot.axis_y_numgrid(6)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.plot.axis_y_numgrid({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_y_numsubgrid(self, p0: float) -> int:
        """Sets the number of subgrid lines to be used along the x/y axis of the currently selected plot(s).
        
        | While the argument to this command is a floating-point value, the actual number of grid lines drawn will be truncated to an integer.
        
        Args:
            p0:
                'num' number of subgrid lines (or ticks) to be used between grid lines along an axis; can be any whole number
        
        Examples:
            ::
        
                ensight.plot.select_begin(1)
                ensight.plot.axis_x_numsubgrid(2)
                ensight.plot.axis_y_numsubgrid(1)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.plot.axis_y_numsubgrid({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_y_origin(self, p0: float) -> int:
        """Sets the value of the x/y axis origin for the currently selected plot(s).
        
        | The default x/y axis origin is 0.
        
        Args:
            p0:
                'origin' x or y location of origin within the plotter; range is the normalized values 0.0 to 1.0
        
        Examples:
            ::
        
                ensight.plot.select_begin(1)
                ensight.plot.axis_x_origin(0.25)
                ensight.plot.axis_y_origin(0.18)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.plot.axis_y_origin({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_y_scale(self, p0: str) -> int:
        """Selects the type of scale used for the x/y axis of the currently selected plot(s).
        
        |  The default scale is linear. 
        
        Args:
            p0:
                'scale_type'
        
                * one of the following:
                * linear
                * logarithmic
        
        Examples:
            ::
        
                ensight.plot.select_begin(1)
                ensight.plot.axis_x_scale("logarithmic")
                ensight.plot.axis_y_scale("linear")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.plot.axis_y_scale({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_y_sgridtype(self, p0: str) -> int:
        """Specifies the type of subgrid that will be drawn for the x/y axis of the currently selected  plot.
        
        |  The default subgrid type is none.
        
        Args:
            p0:
                'grid_type'
        
                * Can be any of the following values:
                * none
                * grid
                * tick
        
        Examples:
            ::
        
                ensight.plot.select_begin(1)
                ensight.plot.axis_x_sgridtype("tick")
                ensight.plot.axis_y_sgridtype("grid")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.plot.axis_y_sgridtype({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_y_size(self, p0: float) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.plot.axis_y_size({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_y_title(self, p0: str) -> int:
        """Sets the title string for the x/y axis of the currently selected plot.
        
        Args:
            p0:
                'title' x/y axis title
        
        Examples:
            ::
        
                ensight.plot.select_begin(1)
                ensight.plot.axis_x_title("Time in Seconds")
                ensight.plot.axis_y_title("Pressure")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.plot.axis_y_title({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_y_titlergb(self, p0: float, p1: float, p2: float) -> int:
        """Specifies the RGB color value of the x/y axis title for the currently selected plot(s).
        
        Args:
            p0:
                'red_val' red, green, blue color components, must be between 0.0 and 1.0
            p1:
                'grn_val' red, green, blue color components, must be between 0.0 and 1.0
            p2:
                'blu_val' red, green, blue color components, must be between 0.0 and 1.0
        
        Examples:
            ::
        
                ensight.plot.select_begin(1)
                ensight.plot.axis_x_titlergb(0,0,1)
                ensight.plot.axis_y_titlergb(0,1,0)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.plot.axis_y_titlergb({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def axis_y_titlesize(self, p0: int) -> int:
        """Sets the size of the x/y axis title in the currently selected plot.
        
        Args:
            p0:
                'size' axis title text size; can be any value from 1 to 100.0, with a value of one specifying the smallest text and 100 the largest.
        
        Examples:
            ::
        
                ensight.plot.select_begin(1)
                ensight.plot.axis_x_titlesize(10)
                ensight.plot.axis_y_titlesize(12)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.plot.axis_y_titlesize({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_y_variable(self, p0: Any) -> int:
        """Plot: axis_y_variable

        """
        cmd = f'''ensight.plot.axis_y_variable({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_y_visible(self, p0: str) -> int:
        """Controls the visibility of the x/y axis of the currently selected plot(s).
        
        |  Plot axes are visible by default.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.plot.select_begin(1)
                ensight.plot.axis_x_visible("OFF")
                ensight.plot.axis_y_visible("ON")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.plot.axis_y_visible({repr(p0)})'''
        return self._session.cmd(cmd)

    def background_rgb(self, p0: float, p1: float, p2: float) -> int:
        """Specifies the background RGB color value for the currently selected plot(s).
        
        | Used only if plot: background_type is set to solid.
        
        Args:
            p0:
                'red_val' red, green, blue color components, must be between 0.0 and 1.0
            p1:
                'grn_val' red, green, blue color components, must be between 0.0 and 1.0
            p2:
                'blu_val' red, green, blue color components, must be between 0.0 and 1.0
        
        Examples:
            ::
        
                ensight.plot.select_begin(1)
                ensight.plot.background_rgb(0,0,1)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.plot.background_rgb({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def background_transparency(self, p0: float) -> int:
        """Plot: background_transparency

        """
        cmd = f'''ensight.plot.background_transparency({repr(p0)})'''
        return self._session.cmd(cmd)

    def background_type(self, p0: str) -> int:
        """Specifies the background type of the currently selected plot.
        
        | The default for plot background type is none.
        
        Args:
            p0:
                'type'
        
                * Can be any of the following values:
                * none
                * solid
        
        Examples:
            ::
        
                ensight.plot.select_begin(1)
                ensight.plot.background_type("solid")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.plot.background_type({repr(p0)})'''
        return self._session.cmd(cmd)

    def border_rgb(self, p0: float, p1: float, p2: float) -> int:
        """Specifies the border RGB color value for the currently selected plot(s).
        
        | Used only if plot: border_visible is set to ON.
        
        Args:
            p0:
                'red_val' red, green, blue color components, must be between 0.0 and 1.0
            p1:
                'grn_val' red, green, blue color components, must be between 0.0 and 1.0
            p2:
                'blu_val' red, green, blue color components, must be between 0.0 and 1.0
        
        Examples:
            ::
        
                ensight.plot.select_begin(1)
                ensight.plot.border_rgb(0,0,1)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.plot.border_rgb({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def border_visible(self, p0: str) -> int:
        """Controls the visibility of the border of the currently selected plot(s).
        
        | Plot borders are visible by default.
        | The border will be drawn according to plot: border_rgb
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.plot.select_begin(1)
                ensight.plot.border_visible("ON")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.plot.border_visible({repr(p0)})'''
        return self._session.cmd(cmd)

    def curve_title(self, p0: str) -> int:
        """Plot: curve_title

        """
        cmd = f'''ensight.plot.curve_title({repr(p0)})'''
        return self._session.cmd(cmd)

    def delete(self) -> int:
        """Plot: delete

        """
        cmd = f'''ensight.plot.delete()'''
        return self._session.cmd(cmd)

    def delete_plot(self) -> int:
        """Deletes the currently selected plot(s).
        
        Examples:
            ::
        
                ensight.plot.select_begin(1,2,3)
                ensight.plot.delete_plot()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.plot.delete_plot()'''
        return self._session.cmd(cmd)

    def detached_background_rgb(self, p0: float, p1: float, p2: float) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.plot.detached_background_rgb({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def detached_window(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.plot.detached_window({repr(p0)})'''
        return self._session.cmd(cmd)

    def entity_select_begin(self) -> int:
        """Plot: entity_select_begin

        """
        cmd = f'''ensight.plot.entity_select_begin()'''
        return self._session.cmd(cmd)

    def entity_select_end(self) -> int:
        """Plot: entity_select_end

        """
        cmd = f'''ensight.plot.entity_select_end()'''
        return self._session.cmd(cmd)

    def graph_title(self, p0: str) -> int:
        """Plot: graph_title

        """
        cmd = f'''ensight.plot.graph_title({repr(p0)})'''
        return self._session.cmd(cmd)

    def graph_titles(self, p0: str) -> int:
        """Plot: graph_titles

        """
        cmd = f'''ensight.plot.graph_titles({repr(p0)})'''
        return self._session.cmd(cmd)

    def grid_linetype(self, p0: str) -> int:
        """Specifies the type of grid lines that will be drawn for the currently selected  plot.
        
        | The grid line_type is solid by default.
        
        Args:
            p0:
                'line_type'
        
                * Can be any of the following values:
                * solid
                * dotted
                * dash
        
        Examples:
            ::
        
                ensight.plot.select_begin(1)
                ensight.plot.grid_linetype("solid")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.plot.grid_linetype({repr(p0)})'''
        return self._session.cmd(cmd)

    def grid_linewidth(self, p0: int) -> int:
        """Sets the grid line width of the currently selected plot(s).
        
        Args:
            p0:
                'width' specifies the line width in pixels of the grid lines, and can be any value from 1 to 4
        
        Examples:
            ::
        
                ensight.plot.select_begin(1)
                ensight.plot.grid_linewidth(2)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.plot.grid_linewidth({repr(p0)})'''
        return self._session.cmd(cmd)

    def grid_rgb(self, p0: float, p1: float, p2: float) -> int:
        """Specifies the RGB color value of the grid for the currently selected plot(s).
        
        Args:
            p0:
                'red_val' red, green, blue color components, must be between 0.0 and 1.0
            p1:
                'grn_val' red, green, blue color components, must be between 0.0 and 1.0
            p2:
                'blu_val' red, green, blue color components, must be between 0.0 and 1.0
        
        Examples:
            ::
        
                ensight.plot.select_begin(1)
                ensight.plot.grid_rgb(0,0,1)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.plot.grid_rgb({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def group(self, p0: str) -> int:
        """Plot: group

        """
        cmd = f'''ensight.plot.group({repr(p0)})'''
        return self._session.cmd(cmd)

    def height(self, p0: float) -> int:
        """Sets the height of the currently selected plot.
        
        | Plots are drawn in reference to the graphics window.  A value of 1.0 is the height of the window.
        
        Args:
            p0:
                'height' height of plot viewport in normalized coordinates, namely any value between 0 and 1.0, with a value of one corresponding to the height of the graphics window
        
        Examples:
            ::
        
                ensight.plot.select_begin(1)
                ensight.plot.width(0.5)
                ensight.plot.height(0.4)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.plot.height({repr(p0)})'''
        return self._session.cmd(cmd)

    def legend_color_by(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.plot.legend_color_by({repr(p0)})'''
        return self._session.cmd(cmd)

    def legend_minmax_origin_x(self, p0: float) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.plot.legend_minmax_origin_x({repr(p0)})'''
        return self._session.cmd(cmd)

    def legend_minmax_origin_y(self, p0: float) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.plot.legend_minmax_origin_y({repr(p0)})'''
        return self._session.cmd(cmd)

    def legend_minmax_textsize(self, p0: int) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.plot.legend_minmax_textsize({repr(p0)})'''
        return self._session.cmd(cmd)

    def legend_minmax_visible(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.plot.legend_minmax_visible({repr(p0)})'''
        return self._session.cmd(cmd)

    def legend_origin_x(self, p0: float) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.plot.legend_origin_x({repr(p0)})'''
        return self._session.cmd(cmd)

    def legend_origin_y(self, p0: float) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.plot.legend_origin_y({repr(p0)})'''
        return self._session.cmd(cmd)

    def legend_rgb(self, p0: float, p1: float, p2: float) -> int:
        """Specifies the RGB color value of the legend for the currently selected plot(s).
        
        | Used only if plot: legend_visible is ON.
        
        Args:
            p0:
                'red_val' red, green, blue color components, must be between 0.0 and 1.0
            p1:
                'grn_val' red, green, blue color components, must be between 0.0 and 1.0
            p2:
                'blu_val' red, green, blue color components, must be between 0.0 and 1.0
        
        Examples:
            ::
        
                ensight.plot.select_begin(1)
                ensight.plot.legend_rgb(0,0,1)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.plot.legend_rgb({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def legend_textsize(self, p0: int) -> int:
        """Sets the size of legend text in the currently selected plot.
        
        Args:
            p0:
                'size' size of legend text; any value from 1 to 100.0, with a value of one specifying the smallest text and 100 the largest
        
        Examples:
            ::
        
                ensight.plot.select_begin(1)
                ensight.plot.legend_textsize(10)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.plot.legend_textsize({repr(p0)})'''
        return self._session.cmd(cmd)

    def legend_visible(self, p0: str) -> int:
        """Controls the visibility of the legend for the currently selected plot(s).
        
        |  Plot legends are visible by default. 
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.plot.select_begin(1)
                ensight.plot.legend_visible("OFF")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.plot.legend_visible({repr(p0)})'''
        return self._session.cmd(cmd)

    def new_plot(self) -> int:
        """Plot: new_plot

        """
        cmd = f'''ensight.plot.new_plot()'''
        return self._session.cmd(cmd)

    def new_plot_ifnotexist(self, p0: int) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.plot.new_plot_ifnotexist({repr(p0)})'''
        return self._session.cmd(cmd)

    def origin_x(self, p0: float) -> int:
        """Specifies the x/y coordinate of the origin of the selected plot in the graphics window.
        
        | The origin of the plot will be positioned at  this point (x,y) in the graphics window 
        
        Args:
            p0:
                'coord' normalized coordinate of lower left corner of the plot viewport. A value of 0.0 indicates the left/bottom side of the window, while a value of 1.0 indicates the right/top side.
        
        Examples:
            ::
        
                ensight.plot.select_begin(1)
                ensight.plot.origin_x(0.5)
                ensight.plot.origin_y(0.5)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.plot.origin_x({repr(p0)})'''
        return self._session.cmd(cmd)

    def origin_y(self, p0: float) -> int:
        """Specifies the x/y coordinate of the origin of the selected plot in the graphics window.
        
        | The origin of the plot will be positioned at  this point (x,y) in the graphics window 
        
        Args:
            p0:
                'coord' normalized coordinate of lower left corner of the plot viewport. A value of 0.0 indicates the left/bottom side of the window, while a value of 1.0 indicates the right/top side.
        
        Examples:
            ::
        
                ensight.plot.select_begin(1)
                ensight.plot.origin_x(0.5)
                ensight.plot.origin_y(0.5)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.plot.origin_y({repr(p0)})'''
        return self._session.cmd(cmd)

    def plot_activate(self) -> int:
        """Plot: plot_activate

        """
        cmd = f'''ensight.plot.plot_activate()'''
        return self._session.cmd(cmd)

    def plot_desc(self, p0: str) -> int:
        """Plot: plot_desc

        """
        cmd = f'''ensight.plot.plot_desc({repr(p0)})'''
        return self._session.cmd(cmd)

    def plot_title(self, p0: str) -> int:
        """Sets the title string for the currently selected plot.
        
        Args:
            p0:
                'title' plot title
        
        Examples:
            ::
        
                ensight.plot.select_begin(1)
                ensight.plot.plot_title("My Plot Title")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.plot.plot_title({repr(p0)})'''
        return self._session.cmd(cmd)

    def query_count(self, args: Any) -> int:
        """Plot: query_count

        """
        cmd = f'''ensight.plot.query_count({repr(args)})'''
        return self._session.cmd(cmd)

    def query_display_attributes(self, args: Any) -> int:
        """Plot: query_display_attributes

        """
        cmd = f'''ensight.plot.query_display_attributes({repr(args)})'''
        return self._session.cmd(cmd)

    def query_object_atwindowxy(self, args: Any) -> int:
        """Plot: query_object_atwindowxy

        """
        cmd = f'''ensight.plot.query_object_atwindowxy({repr(args)})'''
        return self._session.cmd(cmd)

    def query_objects_atwindowxy(self, args: Any) -> int:
        """Plot: query_objects_atwindowxy

        """
        cmd = f'''ensight.plot.query_objects_atwindowxy({repr(args)})'''
        return self._session.cmd(cmd)

    def rescale(self, p0: str) -> int:
        """Plot: rescale

        """
        cmd = f'''ensight.plot.rescale({repr(p0)})'''
        return self._session.cmd(cmd)

    def restore(self, p0: str) -> int:
        """Plot: restore

        """
        cmd = f'''ensight.plot.restore({repr(p0)})'''
        return self._session.cmd(cmd)

    def save(self, p0: str) -> int:
        """Plot: save

        """
        cmd = f'''ensight.plot.save({repr(p0)})'''
        return self._session.cmd(cmd)

    def select_all(self) -> int:
        """Selects all of the plots in the graphics window as the target for future plot: commands.
        
        Examples:
            ::
        
                ensight.plot.select_all()
                ensight.plot.delete_plot()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.plot.select_all()'''
        return self._session.cmd(cmd)

    def select_axis(self, p0: str) -> int:
        """Plot: select_axis

        """
        cmd = f'''ensight.plot.select_axis({repr(p0)})'''
        return self._session.cmd(cmd)

    def select_begin(self, *args, **kwargs) -> Any:
        """Selects one or more plots in the graphics window as the  target for future plot: commands 
        
        Args:
            p0:
                'indexN' plot number (zero based). Up to 10 numbers per line are allowed, but as many lines as needed can be used
        
        Examples:
            ::
        
                ensight.plot.select_begin(1,2)
                ensight.plot.delete_plot()
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.plot.select_begin({arg_string})"
        return self._session.cmd(cmd)

    def select_default(self) -> int:
        """Plot: select_default

        """
        cmd = f'''ensight.plot.select_default()'''
        return self._session.cmd(cmd)

    def subgrid_linetype(self, p0: str) -> int:
        """Specifies the type of subgrid lines that will be drawn for the currently selected  plot.
        
        | The subgrid line_type is solid by default
        
        Args:
            p0:
                'line_type'
        
                * Can be any of the following values:
                * solid
                * dotted
                * dash
        
        Examples:
            ::
        
                ensight.plot.select_begin(1)
                ensight.plot.subgrid_linetype("solid")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.plot.subgrid_linetype({repr(p0)})'''
        return self._session.cmd(cmd)

    def subgrid_linewidth(self, p0: int) -> int:
        """Sets the subgrid line width of the currently selected plot(s).
        
        Args:
            p0:
                'width' the line width in pixels for subgrid lines (or tics); can be any value from 1 to 4
        
        Examples:
            ::
        
                ensight.plot.select_begin(1)
                ensight.plot.subgrid_linewidth(2)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.plot.subgrid_linewidth({repr(p0)})'''
        return self._session.cmd(cmd)

    def subgrid_rgb(self, p0: float, p1: float, p2: float) -> int:
        """Specifies the RGB color value of the subgrid for the currently selected plot(s).
        
        Args:
            p0:
                'red_val' red, green, blue color components, must be between 0.0 and 1.0
            p1:
                'grn_val' red, green, blue color components, must be between 0.0 and 1.0
            p2:
                'blu_val' red, green, blue color components, must be between 0.0 and 1.0
        
        Examples:
            ::
        
                ensight.plot.select_begin(1)
                ensight.plot.subgrid_rgb(0,0,1)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.plot.subgrid_rgb({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def time_marker(self, p0: str) -> int:
        """Controls the visibility of the time marker in the selected plot(s). For use with transient flipbook or keyframe animations.
        
        | The time marker is visible by default. 
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.plot.select_begin(1)
                ensight.plot.animate_curves("ON")
                ensight.plot.time_marker("ON")
                ensight.plot.time_marker_rgb(1.0,1.0,0.0)
                ensight.plot.time_marker_style("dotted")
                ensight.plot.time_marker_width(2)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.plot.time_marker({repr(p0)})'''
        return self._session.cmd(cmd)

    def time_marker_rgb(self, p0: float, p1: float, p2: float) -> int:
        """Controls the color of the time marker in the selected plot(s). For use with transient flipbook or keyframe animations.
        
        | The time marker is white by default. 
        
        Args:
            p0:
                'red_val' red, green, blue contributions of the color (0.0 to 1.0)
            p1:
                'grn_val' red, green, blue contributions of the color (0.0 to 1.0)
            p2:
                'blu_val' red, green, blue contributions of the color (0.0 to 1.0)
        
        Examples:
            ::
        
                ensight.plot.select_begin(1)
                ensight.plot.animate_curves("ON")
                ensight.plot.time_marker("ON")
                ensight.plot.time_marker_rgb(1.0,1.0,0.0)
                ensight.plot.time_marker_style("dotted")
                ensight.plot.time_marker_width(2)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.plot.time_marker_rgb({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def time_marker_style(self, p0: str) -> int:
        """Controls the line style of the time marker in the selected plot(s). For use with transient flipbook or keyframe animations.
        
        | The time marker is solid by default. 
        
        Args:
            p0:
                'style'
        
                * solid
                * dotted
                * dash
        
        Examples:
            ::
        
                ensight.plot.select_begin(1)
                ensight.plot.animate_curves("ON")
                ensight.plot.time_marker("ON")
                ensight.plot.time_marker_rgb(1.0,1.0,0.0)
                ensight.plot.time_marker_style("dotted")
                ensight.plot.time_marker_width(2)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.plot.time_marker_style({repr(p0)})'''
        return self._session.cmd(cmd)

    def time_marker_value(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.plot.time_marker_value({repr(p0)})'''
        return self._session.cmd(cmd)

    def time_marker_width(self, p0: int) -> int:
        """Controls the width of the time marker in the selected plot(s). For use with transient flipbook or keyframe animations.
        
        | The time marker is 2 pixels wide by default. 
        
        Args:
            p0:
                'width' number of pixels in width of the marker line
        
        Examples:
            ::
        
                ensight.plot.select_begin(1)
                ensight.plot.animate_curves("ON")
                ensight.plot.time_marker("ON")
                ensight.plot.time_marker_rgb(1.0,1.0,0.0)
                ensight.plot.time_marker_style("dotted")
                ensight.plot.time_marker_width(2)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.plot.time_marker_width({repr(p0)})'''
        return self._session.cmd(cmd)

    def title_rgb(self, p0: float, p1: float, p2: float) -> int:
        """Specifies the RGB color value of the title for the currently selected plot(s).
        
        Args:
            p0:
                'red_val' red, green, blue color components, must be between 0.0 and 1.0
            p1:
                'grn_val' red, green, blue color components, must be between 0.0 and 1.0
            p2:
                'blu_val' red, green, blue color components, must be between 0.0 and 1.0
        
        Examples:
            ::
        
                ensight.plot.select_begin(1)
                ensight.plot.title_rgb(0,0,1)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.plot.title_rgb({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def title_textsize(self, p0: int) -> int:
        """Sets the size of title text in the currently selected plot. 
        
        Args:
            p0:
                'size' size of title text; any value from 1 to 100.0, with a value of one specifying the smallest text and 100 the largest 
        
        Examples:
            ::
        
                ensight.plot.select_begin(1)
                ensight.plot.title_textsize(10)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.plot.title_textsize({repr(p0)})'''
        return self._session.cmd(cmd)

    def unplot_deactivate(self) -> int:
        """Plot: unplot_deactivate

        """
        cmd = f'''ensight.plot.unplot_deactivate()'''
        return self._session.cmd(cmd)

    def visible(self, p0: str) -> int:
        """Controls the visibility of the selected plot(s) in the graphics window.
        
        | Plots are visible by default. 
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.plot.select_begin(1)
                ensight.plot.visible("OFF")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.plot.visible({repr(p0)})'''
        return self._session.cmd(cmd)

    def width(self, p0: float) -> int:
        """Sets the width of the currently selected plot. 
        
        Args:
            p0:
                'width' width of plot viewport in normalized coordinates, namely any value between 0 and 1.0, with a value of 1.0 corresponding to the width of the graphics window
        
        Examples:
            ::
        
                ensight.plot.select_begin(1)
                ensight.plot.width(0.5)
                ensight.plot.height(0.4)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.plot.width({repr(p0)})'''
        return self._session.cmd(cmd)


class part:
    """Class wrapper for EnSight part module

    This class acts as a proxy for the EnSight Python module ensight.part
    """
    def __init__(self, session: Session):
        self._session = session

    def active(self, p0: str) -> int:
        """Activates or deactivates the currently selected part(s).
        
        | When a part is deactivated, the data for that part will not be updated from the server on any future timestep changes, until the part is activated again
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.part.select_begin(1)
                ensight.part.modify_begin()
                ensight.part.active("OFF")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.active({repr(p0)})'''
        return self._session.cmd(cmd)

    def allow_default_editing(self) -> int:
        """Allow or disallow editing of part defaults.
        
        | This is a command for preferences and is written out in the ensight_allparts_prefs.def file.
        | If the user edits a part attribute when no parts are selected the default is normally edited.  With this toggle OFF the user will no be able to edit part defaults.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.part.allow_default_editing("OFF")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.allow_default_editing()'''
        return self._session.cmd(cmd)

    def alpha_by(self, p0: str) -> int:
        """Part: alpha_by

        """
        cmd = f'''ensight.part.alpha_by({repr(p0)})'''
        return self._session.cmd(cmd)

    def alpha_by_palette(self, args: Any) -> int:
        """Part: alpha_by_palette

        """
        cmd = f'''ensight.part.alpha_by_palette({repr(args)})'''
        return self._session.cmd(cmd)

    def alpha_by_subpalette(self, args: Any) -> int:
        """Part: alpha_by_subpalette

        """
        cmd = f'''ensight.part.alpha_by_subpalette({repr(args)})'''
        return self._session.cmd(cmd)

    def begin(self) -> int:
        """Part: begin

        """
        cmd = f'''ensight.part.begin()'''
        return self._session.cmd(cmd)

    def blank_elts(self, p0: float, p1: float, p2: float, p3: float) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.blank_elts({repr(p0)},{repr(p1)},{repr(p2)},{repr(p3)})'''
        return self._session.cmd(cmd)

    def bounding_rep(self, p0: str) -> int:
        """Specifies the type of fast-display representation used to for the currently selected part(s).
        
        | For reduced, uses factor as set by part: reduce_polygons_factor <factor>.
        
        Args:
            p0:
                'type'
        
                * Can have any of the following values:
                * OFF
                * box
                * points
                * sparse_model
                * reduced
                * invisible
        
        Examples:
            ::
        
                ensight.part.select_begin(1)
                ensight.part.modify_begin()
                ensight.part.bounding_rep("sparse_model")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.bounding_rep({repr(p0)})'''
        return self._session.cmd(cmd)

    def clear_blanked_elts(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.clear_blanked_elts()'''
        return self._session.cmd(cmd)

    def clearall_blanked_elts(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.clearall_blanked_elts()'''
        return self._session.cmd(cmd)

    def clip(self, p0: str) -> int:
        """Turns auxiliary clipping on or off for the currently selected part(s).
        
        | The global toggle for auxiliary clipping must be on - See view: clipping
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.view.clipping("ON")
                ensight.part.select_begin(1)
                ensight.part.modify_begin()
                ensight.part.clip("ON")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.clip({repr(p0)})'''
        return self._session.cmd(cmd)

    def clone(self, p0: int, p1: int) -> int:
        """Part: clone

        """
        cmd = f'''ensight.part.clone({repr(p0)},{repr(p1)})'''
        return self._session.cmd(cmd)

    def clone_byname(self, p0: str, p1: str) -> int:
        """Part: clone_byname

        """
        cmd = f'''ensight.part.clone_byname({repr(p0)},{repr(p1)})'''
        return self._session.cmd(cmd)

    def collect(self, p0: str) -> int:
        """Part: collect

        """
        cmd = f'''ensight.part.collect({repr(p0)})'''
        return self._session.cmd(cmd)

    def colorby_palette(self, args: Any) -> int:
        """Colors the currently selected part(s) based on the value of the specified variable at each node or element (depending on whether data is node or element based) 
        
        Args:
            p0:
                'varname' the name of an existing variable (or the word "none") 
        
        Examples:
            ::
        
                ensight.part.select_begin(1)
                ensight.part.modify_begin()
                ensight.part.colorby_palette("pressure")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.colorby_palette({repr(args)})'''
        return self._session.cmd(cmd)

    def colorby_rgb(self, p0: float, p1: float, p2: float) -> int:
        """Colors the currently selected part(s) using the specified rgb value.
        
        Args:
            p0:
                'red_val' red, green, blue color components (must be between 0.0 and 1.0)
            p1:
                'grn_val' red, green, blue color components (must be between 0.0 and 1.0)
            p2:
                'blu_val' red, green, blue color components (must be between 0.0 and 1.0)
        
        Examples:
            ::
        
                ensight.part.select_begin(1)
                ensight.part.modify_begin()
                ensight.part.colorby_rgb(1.0,0.4,0.0)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.colorby_rgb({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def colorby_selected_var(self) -> int:
        """Colors a part by the palette tied to the variable selected in the main variable list.
        
        | Used with the HUM to tie parts selected to variables selected.
        
        Examples:
            ::
        
                ensight.variables.get_mainvarlist_select()
                ensight.part.get_mainpartlist_select()
                ensight.part.modify_begin()
                ensight.part.colorby_selected_var()
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.colorby_selected_var()'''
        return self._session.cmd(cmd)

    def colorby_subpalette(self, args: Any) -> int:
        """Part: colorby_subpalette

        """
        cmd = f'''ensight.part.colorby_subpalette({repr(args)})'''
        return self._session.cmd(cmd)

    def copy(self) -> int:
        """Creates a copy of the currently selected part(s).
        
        | The Copy operation creates a dependent copy of the original part.
        | The copy is created on the client and its existence is not known to the EnSight Server process. A copy shares geometric data and variable data with the original part.
        
        Examples:
            ::
        
                ensight.part.select_begin(1)
                ensight.part.copy()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.copy()'''
        return self._session.cmd(cmd)

    def copy_noframecreate(self) -> int:
        """Part: copy_noframecreate

        """
        cmd = f'''ensight.part.copy_noframecreate()'''
        return self._session.cmd(cmd)

    def create_assign_viewport(self) -> int:
        """Creates a new viewport and assigns the currently selected part(s) to it.
        
        Examples:
            ::
        
                ensight.part.select_begin(3,5)
                ensight.part.create_assign_viewport()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.create_assign_viewport()'''
        return self._session.cmd(cmd)

    def create_assign_viewports(self) -> int:
        """Creates a new viewport for each of the currently selected part(s) and assigns one part to each viewport.
        
        Examples:
            ::
        
                ensight.part.select_begin(3,5)
                ensight.part.create_assign_viewports()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.create_assign_viewports()'''
        return self._session.cmd(cmd)

    def cull_elements(self, p0: str) -> int:
        """Part: cull_elements

        """
        cmd = f'''ensight.part.cull_elements({repr(p0)})'''
        return self._session.cmd(cmd)

    def cut_remove(self) -> int:
        """Part: cut_remove

        """
        cmd = f'''ensight.part.cut_remove()'''
        return self._session.cmd(cmd)

    def cut_split(self) -> int:
        """Part: cut_split

        """
        cmd = f'''ensight.part.cut_split()'''
        return self._session.cmd(cmd)

    def delete(self) -> int:
        """Deletes the currently selected part(s).
        
        Examples:
            ::
        
                ensight.part.select_begin(1)
                ensight.part.delete()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.delete()'''
        return self._session.cmd(cmd)

    def description(self, p0: str) -> int:
        """Specifies a description string for the currently selected part.  This string will appear in lists that include the part.
        
        Args:
            p0:
                'desc' name that will show up in the user interface; can be up to 50 characters in length
        
        Examples:
            ::
        
                ensight.part.select_begin(1)
                ensight.part.modify_begin()
                ensight.part.description("compressor inlet")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.description({repr(p0)})'''
        return self._session.cmd(cmd)

    def displace_by(self, p0: Any) -> int:
        """Specifies the variable to be used to displace the nodes and elements of the currently selected part(s).
        
        | The displacement factor can be changed before or after the part: displace_by command is issued.
        
        Args:
            p0:
                'variable_name' name of an activated variable
        
        Examples:
            ::
        
                ensight.part.select_begin(1)
                ensight.part.modify_begin()
                ensight.part.displace_factor(0.9)
                ensight.part.displace_by("pressure")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.displace_by({repr(p0)})'''
        return self._session.cmd(cmd)

    def displace_factor(self, p0: float) -> int:
        """Specifies the displacement factor to be applied to the source variable to calculate displacement for the currently selected part(s).
        
        | The displacement factor can be changed before or after the part: displace_by command is issued.  
        
        Args:
            p0:
                'disp_factor' the scaling factor that will be applied to the displacement values.
        
        Examples:
            ::
        
                ensight.part.select_begin(1)
                ensight.part.modify_begin()
                ensight.part.displace_factor(0.9)
                ensight.part.displace_by("pressure")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.displace_factor({repr(p0)})'''
        return self._session.cmd(cmd)

    def double_sided(self, p0: str) -> int:
        """Part: double_sided

        """
        cmd = f'''ensight.part.double_sided({repr(p0)})'''
        return self._session.cmd(cmd)

    def elt_blanking(self, p0: str) -> int:
        """Specifies whether element blanking is allowed for the part.
        
        Args:
            p0:
                ' toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.part.select_begin(1)
                ensight.part.modify_begin()
                ensight.part.elt_blanking("ON")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.elt_blanking({repr(p0)})'''
        return self._session.cmd(cmd)

    def elt_failure_logicalop(self, p0: str) -> int:
        """Specifies the logical operation to use for element failure.
        
        Args:
            p0:
                ' operation'
        
                * and
                * or
                * none
        
        Examples:
            ::
        
                ensight.part.modify_begin()
                # WARNING: following line includes OBSOLETE call (ensight.part.elt_failure_variable).
                ensight.part.elt_failure_variable("NodeToElem")
                # WARNING: following line includes OBSOLETE call (ensight.part.elt_failure_op1).
                ensight.part.elt_failure_op1("<")
                # WARNING: following line includes OBSOLETE call (ensight.part.elt_failure_op2).
                ensight.part.elt_failure_op2(">")
                # WARNING: following line includes OBSOLETE call (ensight.part.elt_failure_op1value).
                ensight.part.elt_failure_op1value(2.00000e-01)
                # WARNING: following line includes OBSOLETE call (ensight.part.elt_failure_op2value).
                ensight.part.elt_failure_op2value(5.00000e-01)
                # WARNING: following line includes OBSOLETE call (ensight.part.elt_failure_logicalop).
                ensight.part.elt_failure_logicalop("or")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.elt_failure_logicalop({repr(p0)})'''
        return self._session.cmd(cmd)

    def elt_failure_op1(self, p0: str) -> int:
        """Specifies the relational operation to use for element failure.
        
        Args:
            p0:
                ' operation'
        
                * >
                * <
                * =
                * !=
                * Not used
        
        Examples:
            ::
        
                ensight.part.modify_begin()
                # WARNING: following line includes OBSOLETE call (ensight.part.elt_failure_variable).
                ensight.part.elt_failure_variable("NodeToElem")
                # WARNING: following line includes OBSOLETE call (ensight.part.elt_failure_op1).
                ensight.part.elt_failure_op1("<")
                # WARNING: following line includes OBSOLETE call (ensight.part.elt_failure_op2).
                ensight.part.elt_failure_op2(">")
                # WARNING: following line includes OBSOLETE call (ensight.part.elt_failure_op1value).
                ensight.part.elt_failure_op1value(2.00000e-01)
                # WARNING: following line includes OBSOLETE call (ensight.part.elt_failure_op2value).
                ensight.part.elt_failure_op2value(5.00000e-01)
                # WARNING: following line includes OBSOLETE call (ensight.part.elt_failure_logicalop).
                ensight.part.elt_failure_logicalop("or")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.elt_failure_op1({repr(p0)})'''
        return self._session.cmd(cmd)

    def elt_failure_op1value(self, p0: float) -> int:
        """Specifies the values for the operations for element failure.
        
        Args:
            p0:
                ' value' the values 
        
        Examples:
            ::
        
                ensight.part.modify_begin()
                # WARNING: following line includes OBSOLETE call (ensight.part.elt_failure_variable).
                ensight.part.elt_failure_variable("NodeToElem")
                # WARNING: following line includes OBSOLETE call (ensight.part.elt_failure_op1).
                ensight.part.elt_failure_op1("<")
                # WARNING: following line includes OBSOLETE call (ensight.part.elt_failure_op2).
                ensight.part.elt_failure_op2(">")
                # WARNING: following line includes OBSOLETE call (ensight.part.elt_failure_op1value).
                ensight.part.elt_failure_op1value(2.00000e-01)
                # WARNING: following line includes OBSOLETE call (ensight.part.elt_failure_op2value).
                ensight.part.elt_failure_op2value(5.00000e-01)
                # WARNING: following line includes OBSOLETE call (ensight.part.elt_failure_logicalop).
                ensight.part.elt_failure_logicalop("or")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.elt_failure_op1value({repr(p0)})'''
        return self._session.cmd(cmd)

    def elt_failure_op2(self, p0: str) -> int:
        """Specifies the relational operation to use for element failure.
        
        Args:
            p0:
                ' operation'
        
                * >
                * <
                * =
                * !=
                * Not used
        
        Examples:
            ::
        
                ensight.part.modify_begin()
                # WARNING: following line includes OBSOLETE call (ensight.part.elt_failure_variable).
                ensight.part.elt_failure_variable("NodeToElem")
                # WARNING: following line includes OBSOLETE call (ensight.part.elt_failure_op1).
                ensight.part.elt_failure_op1("<")
                # WARNING: following line includes OBSOLETE call (ensight.part.elt_failure_op2).
                ensight.part.elt_failure_op2(">")
                # WARNING: following line includes OBSOLETE call (ensight.part.elt_failure_op1value).
                ensight.part.elt_failure_op1value(2.00000e-01)
                # WARNING: following line includes OBSOLETE call (ensight.part.elt_failure_op2value).
                ensight.part.elt_failure_op2value(5.00000e-01)
                # WARNING: following line includes OBSOLETE call (ensight.part.elt_failure_logicalop).
                ensight.part.elt_failure_logicalop("or")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.elt_failure_op2({repr(p0)})'''
        return self._session.cmd(cmd)

    def elt_failure_op2value(self, p0: float) -> int:
        """Specifies the values for the operations for element failure.
        
        Args:
            p0:
                ' value' the values 
        
        Examples:
            ::
        
                ensight.part.modify_begin()
                # WARNING: following line includes OBSOLETE call (ensight.part.elt_failure_variable).
                ensight.part.elt_failure_variable("NodeToElem")
                # WARNING: following line includes OBSOLETE call (ensight.part.elt_failure_op1).
                ensight.part.elt_failure_op1("<")
                # WARNING: following line includes OBSOLETE call (ensight.part.elt_failure_op2).
                ensight.part.elt_failure_op2(">")
                # WARNING: following line includes OBSOLETE call (ensight.part.elt_failure_op1value).
                ensight.part.elt_failure_op1value(2.00000e-01)
                # WARNING: following line includes OBSOLETE call (ensight.part.elt_failure_op2value).
                ensight.part.elt_failure_op2value(5.00000e-01)
                # WARNING: following line includes OBSOLETE call (ensight.part.elt_failure_logicalop).
                ensight.part.elt_failure_logicalop("or")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.elt_failure_op2value({repr(p0)})'''
        return self._session.cmd(cmd)

    def elt_failure_variable(self, p0: Any) -> int:
        """Specifies the variable to use for element failure.
        
        | Must be a per-element variable.
        
        Args:
            p0:
                ' var_name' the name of the variable to use for element failure
        
        Examples:
            ::
        
                ensight.part.modify_begin()
                # WARNING: following line includes OBSOLETE call (ensight.part.elt_failure_variable).
                ensight.part.elt_failure_variable("NodeToElem")
                # WARNING: following line includes OBSOLETE call (ensight.part.elt_failure_op1).
                ensight.part.elt_failure_op1("<")
                # WARNING: following line includes OBSOLETE call (ensight.part.elt_failure_op2).
                ensight.part.elt_failure_op2(">")
                # WARNING: following line includes OBSOLETE call (ensight.part.elt_failure_op1value).
                ensight.part.elt_failure_op1value(2.00000e-01)
                # WARNING: following line includes OBSOLETE call (ensight.part.elt_failure_op2value).
                ensight.part.elt_failure_op2value(5.00000e-01)
                # WARNING: following line includes OBSOLETE call (ensight.part.elt_failure_logicalop).
                ensight.part.elt_failure_logicalop("or")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.elt_failure_variable({repr(p0)})'''
        return self._session.cmd(cmd)

    def elt_feature_angle(self, p0: float) -> int:
        """Specifies the angle to be used in feature angle element representation for the currently selected part(s).
        
        Args:
            p0:
                ' angle' angle between adjacent polygons, above which the edge will be drawn, below which the edge will not be drawn. the range is 0.0 to 180.0 degrees
        
        Examples:
            ::
        
                ensight.part.select_begin(1)
                ensight.part.modify_begin()
                ensight.part.elt_representation("feature_angle")
                ensight.part.elt_feature_angle(20.0)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.elt_feature_angle({repr(p0)})'''
        return self._session.cmd(cmd)

    def elt_rep_pointsnormals(self, p0: str) -> int:
        """Allow option to load the given element representation as points + normals.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.part.modify_begin()
                ensight.part.elt_rep_pointsnormals("ON")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.elt_rep_pointsnormals({repr(p0)})'''
        return self._session.cmd(cmd)

    def elt_representation(self, p0: str) -> int:
        """Specifies the type of element representation used for the currently selected part(s).
        
        Args:
            p0:
                'type'
        
                * can have any of the following values:
                * 3D_border_2D_full
                * border
                * feature angle
                * full
                * not_loaded
                * bounding_box
                * 3D_feature_2D_full
                * 3D_notloaded_2D_full
        
        Examples:
            ::
        
                ensight.part.select_begin(1)
                ensight.part.modify_begin()
                ensight.part.elt_representation("full")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.elt_representation({repr(p0)})'''
        return self._session.cmd(cmd)

    def elt_shrink_factor(self, p0: float) -> int:
        """Specifies a scaling factor (fraction) by which to shrink every element toward its centroid.
        
        Args:
            p0:
                'scale_factor' shrinkage factor which must be within the range of 0.0 to 1.0. The default is 0.0 for no shrinkage.  If set to 1.0, elements will completely disappear.
        
        Examples:
            ::
        
                ensight.part.select_begin(1)
                ensight.part.modify_begin()
                ensight.part.elt_shrink_factor(0.5)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.elt_shrink_factor({repr(p0)})'''
        return self._session.cmd(cmd)

    def end(self) -> int:
        """Part: end

        """
        cmd = f'''ensight.part.end()'''
        return self._session.cmd(cmd)

    def entity_label_elt(self, p0: str) -> int:
        """Turns element labeling on or off for the currently selected part(s).
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.part.select_begin(1)
                ensight.part.modify_begin()
                ensight.part.entity_label_elt("ON")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.entity_label_elt({repr(p0)})'''
        return self._session.cmd(cmd)

    def entity_label_node(self, p0: str) -> int:
        """Turns node labeling on or off for the currently selected part(s).
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.part.select_begin(1)
                ensight.part.modify_begin()
                ensight.part.entity_label_node("ON")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.entity_label_node({repr(p0)})'''
        return self._session.cmd(cmd)

    def entity_label_part(self, p0: str) -> int:
        """Part: entity_label_part

        """
        cmd = f'''ensight.part.entity_label_part({repr(p0)})'''
        return self._session.cmd(cmd)

    def extract(self) -> int:
        """Creates an extract of the currently selected part(s).
        
        | Extracts a new part from the selected part(s)  using the part representation in effect at the time (full, border, or feature). If more than one part is selected, then they are joined into a single part which is assigned to Frame 0.
        | The part: extract command creates a new part using the geometry of the current representation (what you see is what you get). Extracted parts which are in Full Representation are actual copies of the original, but extracted parts which are in Border Representation are only the shell or boundary of the original.
        
        Examples:
            ::
        
                ensight.part.select_begin(1)
                ensight.part.extract()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.extract()'''
        return self._session.cmd(cmd)

    def fill_pattern(self, p0: int) -> int:
        """Specifies a fill pattern of variable transparency to be used on the surfaces of the currently selected part(s).
        
        | This command provides a means of simulating surface transparency which requires less computation than true transparency.  Part opaqueness (controlled by the part: opaqueness command) must be 1.0 in order for part: fill_pattern to take effect.
        
        Args:
            p0:
                'pattern_num' must be within the range of  0 to 3.  transparency value of 0 specifies an opaque surface, while a value of 3 specifies a sparse (transparent) fill pattern
        
        Examples:
            ::
        
                ensight.view.hidden_surface("ON")
                ensight.part.select_begin(1)
                ensight.part.modify_begin()
                ensight.part.hidden_surface("ON")
                ensight.part.fill_pattern(2)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.fill_pattern({repr(p0)})'''
        return self._session.cmd(cmd)

    def fluent_texture_axis(self, p0: str) -> int:
        """Part: fluent_texture_axis

        """
        cmd = f'''ensight.part.fluent_texture_axis({repr(p0)})'''
        return self._session.cmd(cmd)

    def fluent_texture_rotangle(self, p0: float) -> int:
        """Part: fluent_texture_rotangle

        """
        cmd = f'''ensight.part.fluent_texture_rotangle({repr(p0)})'''
        return self._session.cmd(cmd)

    def fluent_texture_scale(self, p0: float) -> int:
        """Part: fluent_texture_scale

        """
        cmd = f'''ensight.part.fluent_texture_scale({repr(p0)})'''
        return self._session.cmd(cmd)

    def get_mainpartlist_select(self) -> int:
        """Causes the parts highlighted in the main part list to become the currently selected parts.
        
        Examples:
            ::
        
                ensight.part.get_mainpartlist_select()
                ensight.part.modify_begin()
                ensight.part.mirror_original("OFF")
                ensight.part.colorby_rgb(1,0,0)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.get_mainpartlist_select()'''
        return self._session.cmd(cmd)

    def get_mouseclick_select(self) -> int:
        """Part: get_mouseclick_select

        """
        cmd = f'''ensight.part.get_mouseclick_select()'''
        return self._session.cmd(cmd)

    def group(self, p0: str) -> int:
        """Groups the currently selected parts into a group with the specified name.
        
        Args:
            p0:
                'groupname' name of the group
        
        Examples:
            ::
        
                ensight.part.select_begin(3,5)
                # WARNING: following line includes OBSOLETE call (ensight.part.group).
                ensight.part.group("yinyang")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.group({repr(p0)})'''
        return self._session.cmd(cmd)

    def hidden_line(self, p0: str) -> int:
        """Causes lines which are behind any portion of the currently selected part(s) to not be drawn.
        
        | The part: hidden_line command also causes the visible drawing lines to be rendered on shaded surfaces of the currently selected part(s).  View: hidden_line ON must be issued in order for  part: hidden_line ON to take effect.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.view.hidden_line("ON")
                ensight.part.select_begin(1)
                ensight.part.modify_begin()
                ensight.part.hidden_line("ON")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.hidden_line({repr(p0)})'''
        return self._session.cmd(cmd)

    def hidden_surface(self, p0: str) -> int:
        """Causes the currently selected part(s) to be drawn with shaded surfaces.
        
        | View: hidden_surface ON must be issued in order for part: hidden_surface ON to take effect. 
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.view.hidden_surface("ON")
                ensight.part.select_begin(1)
                ensight.part.modify_begin()
                ensight.part.hidden_surface("ON")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.hidden_surface({repr(p0)})'''
        return self._session.cmd(cmd)

    def ijk_axis(self, p0: str) -> int:
        """Part: ijk_axis

        """
        cmd = f'''ensight.part.ijk_axis({repr(p0)})'''
        return self._session.cmd(cmd)

    def ijk_axis_scale(self, p0: float) -> int:
        """Part: ijk_axis_scale

        """
        cmd = f'''ensight.part.ijk_axis_scale({repr(p0)})'''
        return self._session.cmd(cmd)

    def light_ambient(self, p0: float) -> int:
        """Part: light_ambient

        """
        cmd = f'''ensight.part.light_ambient({repr(p0)})'''
        return self._session.cmd(cmd)

    def light_diff(self, p0: float) -> int:
        """Specifies the lighting diffusion value used in shading the surfaces of the currently selected part(s).
        
        Args:
            p0:
                'diffuse' diffuse light value, must be within the range of 0.0 to 1.0
        
        Examples:
            ::
        
                ensight.part.select_begin(1)
                ensight.part.modify_begin()
                # WARNING: following line includes OBSOLETE call (ensight.part.light_diff).
                ensight.part.light_diff(0.9)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.light_diff({repr(p0)})'''
        return self._session.cmd(cmd)

    def light_diffuse(self, p0: float) -> int:
        """Part: light_diffuse

        """
        cmd = f'''ensight.part.light_diffuse({repr(p0)})'''
        return self._session.cmd(cmd)

    def light_emissive(self, p0: float) -> int:
        """Part: light_emissive

        """
        cmd = f'''ensight.part.light_emissive({repr(p0)})'''
        return self._session.cmd(cmd)

    def light_h_int(self, p0: float) -> int:
        """Specifies the highlight intensity value used in shading the surfaces of the currently selected part(s).
        
        Args:
            p0:
                'intensity' highlight intensity, must be within the range of 0.0 to 1.0
        
        Examples:
            ::
        
                ensight.part.select_begin(1)
                ensight.part.modify_begin()
                # WARNING: following line includes OBSOLETE call (ensight.part.light_h_int).
                ensight.part.light_h_int(0.5)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.light_h_int({repr(p0)})'''
        return self._session.cmd(cmd)

    def light_refraction(self, p0: float) -> int:
        """Part: light_refraction

        """
        cmd = f'''ensight.part.light_refraction({repr(p0)})'''
        return self._session.cmd(cmd)

    def light_shin(self, p0: float) -> int:
        """Specifies the "shinyness" value used in shading the surfaces of the currently selected part(s).
        
        | Highlight intensity (part: light_h_int) must be non-zero for shinyness to have any effect.
        
        Args:
            p0:
                'shiny' "shinyness" value, must be within the range of 1.0 to 100.0 . Lower values specify less shine
        
        Examples:
            ::
        
                ensight.part.select_begin(1)
                ensight.part.modify_begin()
                # WARNING: following line includes OBSOLETE call (ensight.part.light_h_int).
                ensight.part.light_h_int(0.9)
                # WARNING: following line includes OBSOLETE call (ensight.part.light_shin).
                ensight.part.light_shin(50.0)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.light_shin({repr(p0)})'''
        return self._session.cmd(cmd)

    def light_specular_intensity(self, p0: float) -> int:
        """Part: light_specular_intensity

        """
        cmd = f'''ensight.part.light_specular_intensity({repr(p0)})'''
        return self._session.cmd(cmd)

    def light_specular_reflection(self, p0: float) -> int:
        """Part: light_specular_reflection

        """
        cmd = f'''ensight.part.light_specular_reflection({repr(p0)})'''
        return self._session.cmd(cmd)

    def light_specular_shine(self, p0: float) -> int:
        """Part: light_specular_shine

        """
        cmd = f'''ensight.part.light_specular_shine({repr(p0)})'''
        return self._session.cmd(cmd)

    def light_specular_tint(self, p0: float) -> int:
        """Part: light_specular_tint

        """
        cmd = f'''ensight.part.light_specular_tint({repr(p0)})'''
        return self._session.cmd(cmd)

    def line_hidden_line(self, p0: str) -> int:
        """Part: line_hidden_line

        """
        cmd = f'''ensight.part.line_hidden_line({repr(p0)})'''
        return self._session.cmd(cmd)

    def line_style(self, p0: str) -> int:
        """Specifies the line style used to draw the currently selected part(s).
        
        Args:
            p0:
                'style'
        
                * can have any of the following values:
                * solid
                * dotted
                * dot_dash
        
        Examples:
            ::
        
                ensight.part.select_begin(1)
                ensight.part.modify_begin()
                ensight.part.line_style("dotted")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.line_style({repr(p0)})'''
        return self._session.cmd(cmd)

    def line_width(self, p0: int) -> int:
        """Specifies the line width in pixels used to draw the currently selected part(s).
        
        Args:
            p0:
                'width' pixel width of line; must be within the range of  1 to 4.
        
        Examples:
            ::
        
                ensight.part.select_begin(1)
                ensight.part.modify_begin()
                ensight.part.line_width(2)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.line_width({repr(p0)})'''
        return self._session.cmd(cmd)

    def material_base_type(self, p0: str) -> int:
        """Part: material_base_type

        """
        cmd = f'''ensight.part.material_base_type({repr(p0)})'''
        return self._session.cmd(cmd)

    def merge(self) -> int:
        """Merges the currently selected parts into a single part.
        
        Examples:
            ::
        
                ensight.part.select_begin(3,5)
                ensight.part.merge()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.merge()'''
        return self._session.cmd(cmd)

    def mirror_original(self, p0: str) -> int:
        """Turns visibility of the non-mirrored currently selected parts on or off.
        
        | This command is normally used to remove the original image of parts which have been mirrored in one or more dimensions 
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.part.select_begin(1)
                ensight.part.modify_begin()
                # WARNING: following line includes OBSOLETE call (ensight.part.mirror_z).
                ensight.part.mirror_z("ON")
                ensight.part.mirror_original("OFF")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.mirror_original({repr(p0)})'''
        return self._session.cmd(cmd)

    def mirror_x(self, p0: str) -> int:
        """Part: mirror_x

        """
        cmd = f'''ensight.part.mirror_x({repr(p0)})'''
        return self._session.cmd(cmd)

    def mirror_xy(self, p0: str) -> int:
        """Part: mirror_xy

        """
        cmd = f'''ensight.part.mirror_xy({repr(p0)})'''
        return self._session.cmd(cmd)

    def mirror_xyz(self, p0: str) -> int:
        """Part: mirror_xyz

        """
        cmd = f'''ensight.part.mirror_xyz({repr(p0)})'''
        return self._session.cmd(cmd)

    def mirror_xz(self, p0: str) -> int:
        """Part: mirror_xz

        """
        cmd = f'''ensight.part.mirror_xz({repr(p0)})'''
        return self._session.cmd(cmd)

    def mirror_y(self, p0: str) -> int:
        """Part: mirror_y

        """
        cmd = f'''ensight.part.mirror_y({repr(p0)})'''
        return self._session.cmd(cmd)

    def mirror_yz(self, p0: str) -> int:
        """Part: mirror_yz

        """
        cmd = f'''ensight.part.mirror_yz({repr(p0)})'''
        return self._session.cmd(cmd)

    def mirror_z(self, p0: str) -> int:
        """Part: mirror_z

        """
        cmd = f'''ensight.part.mirror_z({repr(p0)})'''
        return self._session.cmd(cmd)

    def modify_begin(self) -> int:
        """These commands are used to demarcate part attribute changing commands.  The attributes within them will be changed when the modify_end is reached.
        
        Examples:
            ::
        
                ensight.part.select_begin(1)
                ensight.part.modify_begin()
                ensight.part.colorby_rgb(1,0,0)
                ensight.part.visibility_node("ON")
                ensight.part.node_type("sphere")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.modify_begin()'''
        return self._session.cmd(cmd)

    def modify_end(self) -> int:
        """These commands are used to demarcate part attribute changing commands.  The attributes within them will be changed when the modify_end is reached.
        
        Examples:
            ::
        
                ensight.part.select_begin(1)
                ensight.part.modify_begin()
                ensight.part.colorby_rgb(1,0,0)
                ensight.part.visibility_node("ON")
                ensight.part.node_type("sphere")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.modify_end()'''
        return self._session.cmd(cmd)

    def node_detail(self, p0: int) -> int:
        """Sets the detail level for drawing spherical nodes in the currently selected part(s).
        
        | Higher values of level result in more polygons being used to draw the spheres. 
        
        Args:
            p0:
                'level' detail level for the spheres used to represent the nodes; must be within the range of  2 to 10.
        
        Examples:
            ::
        
                ensight.part.select_begin(1)
                ensight.part.modify_begin()
                ensight.part.node_type("sphere")
                ensight.part.node_detail(5)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.node_detail({repr(p0)})'''
        return self._session.cmd(cmd)

    def node_orientation_angle(self, p0: Any) -> int:
        """Part: node_orientation_angle

        """
        cmd = f'''ensight.part.node_orientation_angle({repr(p0)})'''
        return self._session.cmd(cmd)

    def node_orientation_axis(self, p0: Any) -> int:
        """Part: node_orientation_axis

        """
        cmd = f'''ensight.part.node_orientation_axis({repr(p0)})'''
        return self._session.cmd(cmd)

    def node_scale(self, p0: float) -> int:
        """Sets the scale factor used to determine node size for the currently selected part(s).
        
        Args:
            p0:
                'scale' scaling factor to be applied to the node cross or sphere representation; can be any valid floating point value
        
        Examples:
            ::
        
                ensight.part.select_begin(1)
                ensight.part.modify_begin()
                ensight.part.node_scale(1.5)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.node_scale({repr(p0)})'''
        return self._session.cmd(cmd)

    def node_size_by(self, p0: str) -> int:
        """Selects the source for calculating node size in the currently selected part(s).
        
        Args:
            p0:
                'source_type'
        
                * Can have any of the following values:
                * constant
                * scalar
                * vector_mag
                * vector_xcomp
                * vector_ycomp
                * vector_zcomp
        
        Examples:
            ::
        
                ensight.part.select_begin(1)
                ensight.part.modify_begin()
                ensight.part.node_type("sphere")
                ensight.part.node_size_by("vector_mag")
                ensight.part.node_variable("velocity")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.node_size_by({repr(p0)})'''
        return self._session.cmd(cmd)

    def node_type(self, p0: str) -> int:
        """Selects the node representation mode for the currently selected part(s).
        
        Args:
            p0:
                'type'
        
                * dot
                * cross
                * sphere
        
        Examples:
            ::
        
                ensight.part.select_begin(1)
                ensight.part.modify_begin()
                ensight.part.node_type("sphere")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.node_type({repr(p0)})'''
        return self._session.cmd(cmd)

    def node_variable(self, p0: Any) -> int:
        """Specifies the variable to be used in calculating the size of spherical nodes in the currently  selected part(s).
        
        Args:
            p0:
                'variable_name' the name of an activated variable
        
        Examples:
            ::
        
                ensight.part.select_begin(1)
                ensight.part.modify_begin()
                ensight.part.node_type("sphere")
                ensight.part.node_size_by("vector_mag")
                ensight.part.node_variable("velocity")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.node_variable({repr(p0)})'''
        return self._session.cmd(cmd)

    def opacity(self, p0: float) -> int:
        """Part: opacity

        """
        cmd = f'''ensight.part.opacity({repr(p0)})'''
        return self._session.cmd(cmd)

    def opaqueness(self, p0: float) -> int:
        """Specifies the opaqueness of the currently selected part(s).
        
        | A value of 1.0 is fully opaque.
        
        Args:
            p0:
                'value' opaqueness; must be within the range of 0.0 to 1.0
        
        Examples:
            ::
        
                ensight.part.select_begin(1)
                ensight.part.modify_begin()
                # WARNING: following line includes OBSOLETE call (ensight.part.opaqueness).
                ensight.part.opaqueness(0.4)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.opaqueness({repr(p0)})'''
        return self._session.cmd(cmd)

    def periodic_sections(self, args: Any) -> int:
        """Part: periodic_sections

        """
        cmd = f'''ensight.part.periodic_sections({repr(args)})'''
        return self._session.cmd(cmd)

    def predefined_material(self, args: Any) -> int:
        """Part: predefined_material

        """
        cmd = f'''ensight.part.predefined_material({repr(args)})'''
        return self._session.cmd(cmd)

    def query_display_attributes(self, args: Any) -> int:
        """Part: query_display_attributes

        """
        cmd = f'''ensight.part.query_display_attributes({repr(args)})'''
        return self._session.cmd(cmd)

    def query_eltid_atwindowxy(self, args: Any) -> int:
        """Part: query_eltid_atwindowxy

        """
        cmd = f'''ensight.part.query_eltid_atwindowxy({repr(args)})'''
        return self._session.cmd(cmd)

    def query_eltid_atxyz(self, args: Any) -> int:
        """Part: query_eltid_atxyz

        """
        cmd = f'''ensight.part.query_eltid_atxyz({repr(args)})'''
        return self._session.cmd(cmd)

    def query_nodeid_atwindowxy(self, args: Any) -> int:
        """Part: query_nodeid_atwindowxy

        """
        cmd = f'''ensight.part.query_nodeid_atwindowxy({repr(args)})'''
        return self._session.cmd(cmd)

    def query_nodeid_atxyz(self, args: Any) -> int:
        """Part: query_nodeid_atxyz

        """
        cmd = f'''ensight.part.query_nodeid_atxyz({repr(args)})'''
        return self._session.cmd(cmd)

    def query_object_atwindowxy(self, args: Any) -> int:
        """Part: query_object_atwindowxy

        """
        cmd = f'''ensight.part.query_object_atwindowxy({repr(args)})'''
        return self._session.cmd(cmd)

    def query_objects(self, args: Any) -> int:
        """Part: query_objects

        """
        cmd = f'''ensight.part.query_objects({repr(args)})'''
        return self._session.cmd(cmd)

    def query_selected_objects(self, args: Any) -> int:
        """Part: query_selected_objects

        """
        cmd = f'''ensight.part.query_selected_objects({repr(args)})'''
        return self._session.cmd(cmd)

    def recompute_cancel(self, p0: str) -> int:
        """Part: recompute_cancel

        """
        cmd = f'''ensight.part.recompute_cancel({repr(p0)})'''
        return self._session.cmd(cmd)

    def recompute_pending(self, p0: str) -> int:
        """Part: recompute_pending

        """
        cmd = f'''ensight.part.recompute_pending({repr(p0)})'''
        return self._session.cmd(cmd)

    def record_selected(self) -> int:
        """Part: record_selected

        """
        cmd = f'''ensight.part.record_selected()'''
        return self._session.cmd(cmd)

    def record_selected_ifchanged(self) -> int:
        """Part: record_selected_ifchanged

        """
        cmd = f'''ensight.part.record_selected_ifchanged()'''
        return self._session.cmd(cmd)

    def reduce_polygons(self, p0: str) -> int:
        """Reduce the number of polygons for display.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.part.select_begin(1)
                ensight.part.modify_begin()
                ensight.part.reduce_polygons_factor(1)
                ensight.part.reduce_polygons("ON")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.reduce_polygons({repr(p0)})'''
        return self._session.cmd(cmd)

    def reduce_polygons_factor(self, p0: int) -> int:
        """Set the polygon reduction factor.
        
        | Used only if reduce_polygons is ON
        | If no polygons were removed during the process the original geometry will be shown.
        
        Args:
            p0:
                'factor' 0 (less) to 10 (more) controlling the number of polygons
        
        Examples:
            ::
        
                ensight.part.select_begin(1)
                ensight.part.modify_begin()
                ensight.part.reduce_polygons_factor(1)
                ensight.part.reduce_polygons("ON")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.reduce_polygons_factor({repr(p0)})'''
        return self._session.cmd(cmd)

    def ref_frame(self, p0: int) -> int:
        """Assigns the currently selected part(s) to the specified reference frame.
        
        Args:
            p0:
                'frame#' an existing reference frame number
        
        Examples:
            ::
        
                ensight.part.select_begin(1,2,5)
                ensight.part.modify_begin()
                ensight.part.ref_frame(2)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.ref_frame({repr(p0)})'''
        return self._session.cmd(cmd)

    def rendering_reflection_id(self, p0: int) -> int:
        """Part: rendering_reflection_id

        """
        cmd = f'''ensight.part.rendering_reflection_id({repr(p0)})'''
        return self._session.cmd(cmd)

    def restore_selected(self) -> int:
        """Restores the selected parts from a previous seleciton using the store_selected command.  Note that this does NOT cause the parts to be selected as the target for future part: commands.
        
        | To make the highlighted parts the currently selected parts, use part: get_mainpartlist_select or part: select_all.
        
        Examples:
            ::
        
                ensight.part.store_selected()
                #
                # EnSight commands here...
                #
                ensight.part.restore_selected()
                ensight.part.get_mainpartlist_select()
                ensight.part.modify_begin()
                ensight.part.colorby_rgb(1,0,0)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.restore_selected()'''
        return self._session.cmd(cmd)

    def reverse_normal(self, p0: str) -> int:
        """Part: reverse_normal

        """
        cmd = f'''ensight.part.reverse_normal({repr(p0)})'''
        return self._session.cmd(cmd)

    def select_all(self) -> int:
        """Selects all parts as the target for future part: commands.
        
        Examples:
            ::
        
                ensight.part.select_all()
                ensight.part.modify_begin()
                ensight.part.colorby_rgb(1,0,0)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.select_all()'''
        return self._session.cmd(cmd)

    def select_all_case(self) -> int:
        """Selects all parts in the current case as the target for future part: commands.
        
        Examples:
            ::
        
                ensight.part.select_all_case()
                ensight.part.modify_begin()
                ensight.part.colorby_rgb(1,0,0)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.select_all_case()'''
        return self._session.cmd(cmd)

    def select_all_default(self) -> int:
        """Causes any following part editing commands to affect the default settings for all parts of any type.
        
        | All part: commands following part: select_all_default will affect default settings until a new part is selected using part: select_begin/end. 
        
        Examples:
            ::
        
                ensight.part.select_all_default()
                ensight.part.modify_begin()
                ensight.part.mirror_original("OFF")
                ensight.part.colorby_rgb(1,0,0)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.select_all_default()'''
        return self._session.cmd(cmd)

    def select_begin(self, *args, **kwargs) -> Any:
        """Selects one or more parts as the target for future part: commands 
        
        Args:
            p0:
                'pnN' part number(s).  Up to a maximum of  10 per line, but can use as many lines as needed.
        
        Examples:
            ::
        
                ensight.part.select_begin(1,2)
                ensight.part.modify_begin()
                ensight.part.colorby_rgb(1,0,0)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.part.select_begin({arg_string})"
        return self._session.cmd(cmd)

    def select_byexpr_begin(self, args: Any) -> int:
        """Selects parts using an expression.
        
        | Is used in command files only, i.e., EnSight does not generate these commands
        
        Args:
            p0:
                'exprN' part expression (partial name with asterisk(s))
        
        Examples:
            ::
        
                ensight.part.select_byexpr_begin("flui*","soli*")
                ensight.part.modify_begin()
                ensight.part.reduce_polygons_factor(1)
                ensight.part.reduce_polygons("ON")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.select_byexpr_begin({repr(args)})'''
        return self._session.cmd(cmd)

    def select_byexpr_end(self) -> int:
        """Selects parts using an expression.
        
        | Is used in command files only, i.e., EnSight does not generate these commands
        
        Args:
            p0:
                'exprN' part expression (partial name with asterisk(s))
        
        Examples:
            ::
        
                ensight.part.select_byexpr_begin("flui*","soli*")
                ensight.part.modify_begin()
                ensight.part.reduce_polygons_factor(1)
                ensight.part.reduce_polygons("ON")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.select_byexpr_end()'''
        return self._session.cmd(cmd)

    def select_byname_begin(self, *args, **kwargs) -> Any:
        """Selects parts by name.
        
        Args:
            p0:
                'nameN' part name (as opposed to number)
        
        Examples:
            ::
        
                ensight.part.select_byname_begin("impeller","main chamber","exhaust port")
                ensight.part.modify_begin()
                ensight.part.colorby_rgb(1,0,0)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.part.select_byname_begin({arg_string})"
        return self._session.cmd(cmd)

    def select_byname_end(self) -> int:
        """Selects parts by name.
        
        Args:
            p0:
                'nameN' part name (as opposed to number)
        
        Examples:
            ::
        
                ensight.part.select_byname_begin("impeller","main chamber","exhaust port")
                ensight.part.modify_begin()
                ensight.part.colorby_rgb(1,0,0)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.select_byname_end()'''
        return self._session.cmd(cmd)

    def select_default(self) -> int:
        """Causes any following part editing commands to affect the default settings for all parts belonging to the part type of the next edit command.
        
        | All part editing commands following part: select_default will affect default settings until a new part is selected using part: select_begin/select_end.
        
        Examples:
            ::
        
                ensight.part.select_default()
                ensight.part.modify_begin()
                ensight.part.mirror_original("OFF")
                ensight.part.colorby_rgb(1,0,0)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.select_default()'''
        return self._session.cmd(cmd)

    def select_invert(self) -> int:
        """Part: select_invert

        """
        cmd = f'''ensight.part.select_invert()'''
        return self._session.cmd(cmd)

    def select_invisible(self) -> int:
        """Causes all parts invisible parts to be highlighted.  Note that this does NOT cause the parts to be selected as the target for future part: commands.
        
        | To make the highlighted parts the currently selected parts, use part: get_mainpartlist_select or part: select_all.
        
        Examples:
            ::
        
                ensight.part.select_invisible()
                ensight.part.get_mainpartlist_select()
                ensight.part.modify_begin()
                ensight.part.colorby_rgb(1,0,0)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.select_invisible()'''
        return self._session.cmd(cmd)

    def select_lastcreatedpart(self) -> int:
        """Selects all of the parts created in the last part-creating operation.
        
        Examples:
            ::
        
                ensight.part.select_lastcreatedpart()
                ensight.part.modify_begin()
                ensight.part.colorby_rgb(1,0,0)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.select_lastcreatedpart()'''
        return self._session.cmd(cmd)

    def select_lastonecreated(self) -> int:
        """Selects the last single part from the last part-creating operation.
        
        Examples:
            ::
        
                ensight.part.select_lastonecreated()
                ensight.part.modify_begin()
                ensight.part.colorby_rgb(1,0,0)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.select_lastonecreated()'''
        return self._session.cmd(cmd)

    def select_mainpartlist_all(self) -> int:
        """Causes all parts in the main part list to be highlighted.  Note that this does NOT cause the parts to be selected as the target for future part: commands.
        
        | To make the highlighted parts the currently selected parts, use part: get_mainpartlist_select or part: select_all.
        
        Examples:
            ::
        
                ensight.part.select_mainpartlist_all()
                ensight.part.get_mainpartlist_select()
                ensight.part.modify_begin()
                ensight.part.colorby_rgb(1,0,0)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.select_mainpartlist_all()'''
        return self._session.cmd(cmd)

    def select_partexpr_begin(self, args: Any) -> int:
        """Part: select_partexpr_begin

        """
        cmd = f'''ensight.part.select_partexpr_begin({repr(args)})'''
        return self._session.cmd(cmd)

    def select_partexpr_end(self) -> int:
        """Part: select_partexpr_end

        """
        cmd = f'''ensight.part.select_partexpr_end()'''
        return self._session.cmd(cmd)

    def select_partname_begin(self, args: Any) -> int:
        """Part: select_partname_begin

        """
        cmd = f'''ensight.part.select_partname_begin({repr(args)})'''
        return self._session.cmd(cmd)

    def select_partname_end(self) -> int:
        """Part: select_partname_end

        """
        cmd = f'''ensight.part.select_partname_end()'''
        return self._session.cmd(cmd)

    def select_showing(self) -> int:
        """Causes all parts showing parts to be highlighted.  Note that this does NOT cause the parts to be selected as the target for future part: commands.
        
        | To make the highlighted parts the currently selected parts, use part: get_mainpartlist_select or part: select_all.
        
        Examples:
            ::
        
                ensight.part.select_showing()
                ensight.part.get_mainpartlist_select()
                ensight.part.modify_begin()
                ensight.part.colorby_rgb(1,0,0)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.select_showing()'''
        return self._session.cmd(cmd)

    def select_visible(self) -> int:
        """Causes all parts visible parts to be highlighted.  Note that this does NOT cause the parts to be selected as the target for future part: commands.
        
        | To make the highlighted parts the currently selected parts, use part: get_mainpartlist_select or part: select_all.
        
        Examples:
            ::
        
                ensight.part.select_visible()
                ensight.part.get_mainpartlist_select()
                ensight.part.modify_begin()
                ensight.part.colorby_rgb(1,0,0)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.select_visible()'''
        return self._session.cmd(cmd)

    def shading(self, p0: str) -> int:
        """Specifies the type of surface shading used on the currently selected part(s).
        
        Args:
            p0:
                'type'
        
                * Can have any of the following values:
                * flat
                * gouraud
                * smooth
        
        Examples:
            ::
        
                ensight.view.hidden_surface("ON")
                ensight.part.select_begin(1)
                ensight.part.modify_begin()
                ensight.part.hidden_surface("ON")
                ensight.part.shading("gouraud")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.shading({repr(p0)})'''
        return self._session.cmd(cmd)

    def show_selection_inmainlist(self) -> int:
        """Updates the Part List GUI menu to reflect the currently selected part(s).
        
        Examples:
            ::
        
                ensight.view.hidden_surface("ON")
                ensight.part.select_begin(1)
                ensight.part.show_selection_inmainlist()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.show_selection_inmainlist()'''
        return self._session.cmd(cmd)

    def show_sft(self, p0: str) -> int:
        """Part: show_sft

        """
        cmd = f'''ensight.part.show_sft({repr(p0)})'''
        return self._session.cmd(cmd)

    def specify_symmetry_origin(self, p0: str) -> int:
        """Part: specify_symmetry_origin

        """
        cmd = f'''ensight.part.specify_symmetry_origin({repr(p0)})'''
        return self._session.cmd(cmd)

    def store_selected(self) -> int:
        """Stores the selected parts to be used later using the restore_selected command.  Note that this does NOT cause the parts to be selected as the target for future part: commands.
        
        | To make the highlighted parts the currently selected parts, use part: get_mainpartlist_select or part: select_all.
        
        Examples:
            ::
        
                ensight.part.store_selected()
                #
                # EnSight commands here...
                #
                ensight.part.restore_selected()
                ensight.part.get_mainpartlist_select()
                ensight.part.modify_begin()
                ensight.part.colorby_rgb(1,0,0)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.store_selected()'''
        return self._session.cmd(cmd)

    def surface_fill_pattern(self, p0: int) -> int:
        """Part: surface_fill_pattern

        """
        cmd = f'''ensight.part.surface_fill_pattern({repr(p0)})'''
        return self._session.cmd(cmd)

    def surface_hidden_surface(self, p0: str) -> int:
        """Part: surface_hidden_surface

        """
        cmd = f'''ensight.part.surface_hidden_surface({repr(p0)})'''
        return self._session.cmd(cmd)

    def surface_type(self, p0: str) -> int:
        """Part: surface_type

        """
        cmd = f'''ensight.part.surface_type({repr(p0)})'''
        return self._session.cmd(cmd)

    def symmetry_angle(self, p0: float) -> int:
        """Specifies the rotational symmetry angle.
        
        | Used only when part: symmetry_type is set to rotational.
        
        Args:
            p0:
                'angle' The angle (in degrees) for the rotation
        
        Examples:
            ::
        
                ensight.part.select_begin(1)
                ensight.part.modify_begin()
                #
                # turn on rotational symmetry about the x axis
                # use 4 instances rotated 90 degrees
                #
                ensight.part.symmetry_type("rotational")
                ensight.part.symmetry_axis("x")
                ensight.part.symmetry_rinstances(4)
                ensight.part.symmetry_angle(90.)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.symmetry_angle({repr(p0)})'''
        return self._session.cmd(cmd)

    def symmetry_axis(self, p0: str) -> int:
        """Specifies the rotational symmetry axis.
        
        | Used only when part: symmetry_type is set to rotational.
        | The axis is in reference to the part coordinate frame.
        
        Args:
            p0:
                'axis'
        
                * x
                * y
                * z
        
        Examples:
            ::
        
                ensight.part.select_begin(1)
                ensight.part.modify_begin()
                #
                # turn on rotational symmetry about the x axis
                # use 4 instances rotated 90 degrees
                #
                ensight.part.symmetry_type("rotational")
                ensight.part.symmetry_axis("x")
                ensight.part.symmetry_rinstances(4)
                ensight.part.symmetry_angle(90.)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.symmetry_axis({repr(p0)})'''
        return self._session.cmd(cmd)

    def symmetry_delta(self, p0: float, p1: float, p2: float) -> int:
        """Part: symmetry_delta

        """
        cmd = f'''ensight.part.symmetry_delta({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def symmetry_mirror_x(self, p0: str) -> int:
        """Set the flag for visual symmetry mirror images of currently selected parts in the x / y / z / xy / yz / xz / xyz directions.
        
        | The part is reflected about the frame that it is assigned to (part: ref_frame)
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.part.select_begin(1)
                ensight.part.modify_begin()
                ensight.part.symmetry_mirror_x("ON")
                ensight.part.symmetry_mirror_y("ON")
                ensight.part.symmetry_mirror_xy("ON")
                ensight.part.symmetry_mirror_xyz("ON")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.symmetry_mirror_x({repr(p0)})'''
        return self._session.cmd(cmd)

    def symmetry_mirror_xy(self, p0: str) -> int:
        """Set the flag for visual symmetry mirror images of currently selected parts in the x / y / z / xy / yz / xz / xyz directions.
        
        | The part is reflected about the frame that it is assigned to (part: ref_frame)
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.part.select_begin(1)
                ensight.part.modify_begin()
                ensight.part.symmetry_mirror_x("ON")
                ensight.part.symmetry_mirror_y("ON")
                ensight.part.symmetry_mirror_xy("ON")
                ensight.part.symmetry_mirror_xyz("ON")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.symmetry_mirror_xy({repr(p0)})'''
        return self._session.cmd(cmd)

    def symmetry_mirror_xyz(self, p0: str) -> int:
        """Set the flag for visual symmetry mirror images of currently selected parts in the x / y / z / xy / yz / xz / xyz directions.
        
        | The part is reflected about the frame that it is assigned to (part: ref_frame)
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.part.select_begin(1)
                ensight.part.modify_begin()
                ensight.part.symmetry_mirror_x("ON")
                ensight.part.symmetry_mirror_y("ON")
                ensight.part.symmetry_mirror_xy("ON")
                ensight.part.symmetry_mirror_xyz("ON")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.symmetry_mirror_xyz({repr(p0)})'''
        return self._session.cmd(cmd)

    def symmetry_mirror_xz(self, p0: str) -> int:
        """Set the flag for visual symmetry mirror images of currently selected parts in the x / y / z / xy / yz / xz / xyz directions.
        
        | The part is reflected about the frame that it is assigned to (part: ref_frame)
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.part.select_begin(1)
                ensight.part.modify_begin()
                ensight.part.symmetry_mirror_x("ON")
                ensight.part.symmetry_mirror_y("ON")
                ensight.part.symmetry_mirror_xy("ON")
                ensight.part.symmetry_mirror_xyz("ON")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.symmetry_mirror_xz({repr(p0)})'''
        return self._session.cmd(cmd)

    def symmetry_mirror_y(self, p0: str) -> int:
        """Set the flag for visual symmetry mirror images of currently selected parts in the x / y / z / xy / yz / xz / xyz directions.
        
        | The part is reflected about the frame that it is assigned to (part: ref_frame)
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.part.select_begin(1)
                ensight.part.modify_begin()
                ensight.part.symmetry_mirror_x("ON")
                ensight.part.symmetry_mirror_y("ON")
                ensight.part.symmetry_mirror_xy("ON")
                ensight.part.symmetry_mirror_xyz("ON")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.symmetry_mirror_y({repr(p0)})'''
        return self._session.cmd(cmd)

    def symmetry_mirror_yz(self, p0: str) -> int:
        """Set the flag for visual symmetry mirror images of currently selected parts in the x / y / z / xy / yz / xz / xyz directions.
        
        | The part is reflected about the frame that it is assigned to (part: ref_frame)
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.part.select_begin(1)
                ensight.part.modify_begin()
                ensight.part.symmetry_mirror_x("ON")
                ensight.part.symmetry_mirror_y("ON")
                ensight.part.symmetry_mirror_xy("ON")
                ensight.part.symmetry_mirror_xyz("ON")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.symmetry_mirror_yz({repr(p0)})'''
        return self._session.cmd(cmd)

    def symmetry_mirror_z(self, p0: str) -> int:
        """Set the flag for visual symmetry mirror images of currently selected parts in the x / y / z / xy / yz / xz / xyz directions.
        
        | The part is reflected about the frame that it is assigned to (part: ref_frame)
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.part.select_begin(1)
                ensight.part.modify_begin()
                ensight.part.symmetry_mirror_x("ON")
                ensight.part.symmetry_mirror_y("ON")
                ensight.part.symmetry_mirror_xy("ON")
                ensight.part.symmetry_mirror_xyz("ON")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.symmetry_mirror_z({repr(p0)})'''
        return self._session.cmd(cmd)

    def symmetry_origin(self, p0: float, p1: float, p2: float) -> int:
        """Part: symmetry_origin

        """
        cmd = f'''ensight.part.symmetry_origin({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def symmetry_rinstances(self, p0: int) -> int:
        """Specifies the rotational instances.
        
        | Used only when part: symmetry_type is set to rotational.
        
        Args:
            p0:
                'num' The number of rotational instances
        
        Examples:
            ::
        
                ensight.part.select_begin(1)
                ensight.part.modify_begin()
                #
                # turn on rotational symmetry about the x axis
                # use 4 instances rotated 90 degrees
                #
                ensight.part.symmetry_type("rotational")
                ensight.part.symmetry_axis("x")
                ensight.part.symmetry_rinstances(4)
                ensight.part.symmetry_angle(90.)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.symmetry_rinstances({repr(p0)})'''
        return self._session.cmd(cmd)

    def symmetry_type(self, p0: str) -> int:
        """Turn on symmetry display.
        
        Args:
            p0:
                'sym_type'
        
                * mirror
                * rotational
                * none
        
        Examples:
            ::
        
                ensight.part.select_begin(1)
                ensight.part.modify_begin()
                #
                # turn on rotational symmetry about the x axis
                # use 4 instances rotated 90 degrees
                #
                ensight.part.symmetry_type("rotational")
                ensight.part.symmetry_axis("x")
                ensight.part.symmetry_rinstances(4)
                ensight.part.symmetry_angle(90.)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.symmetry_type({repr(p0)})'''
        return self._session.cmd(cmd)

    def texture_coord_type(self, p0: str) -> int:
        """Sets the texture mapping to use a projection or to use two variables describing the s and t vector values.
        
        Args:
            p0:
                'type'
        
                * projection
                * variable
        
        Examples:
            ::
        
                ensight.part.select_begin(1)
                ensight.part.modify_begin()
                ensight.part.texture_coord_type("projection")
                ensight.part.texture_origin(-1,.2,1)
                ensight.part.texture_svector(2,0,0)
                ensight.part.texture_tvector(0,2,0)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.texture_coord_type({repr(p0)})'''
        return self._session.cmd(cmd)

    def texture_interpolation(self, p0: str) -> int:
        """Sets the texture interpolation mode to use the nearest texture pixel or interpolate.
        
        Args:
            p0:
                'mode'
        
                * nearest
                * linear
        
        Examples:
            ::
        
                ensight.part.select_begin(1)
                ensight.part.modify_begin()
                ensight.part.texture_object(1)
                ensight.part.texture_repeat_mode("clamp")
                ensight.part.texture_interpolation("linear")
                ensight.part.texture_mode("decal")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.texture_interpolation({repr(p0)})'''
        return self._session.cmd(cmd)

    def texture_mode(self, p0: str) -> int:
        """Set the texture mode to be used for the part coloring.
        
        Args:
            p0:
                'mode'
        
                * replace
                * decal
                * modulate
        
        Examples:
            ::
        
                ensight.part.select_begin(1)
                ensight.part.modify_begin()
                ensight.part.texture_object(1)
                ensight.part.texture_repeat_mode("clamp")
                ensight.part.texture_mode("decal")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.texture_mode({repr(p0)})'''
        return self._session.cmd(cmd)

    def texture_object(self, p0: int) -> int:
        """Color the selected part by a texture.
        
        Args:
            p0:
                'num' the texture object to color by
        
        Examples:
            ::
        
                ensight.part.select_begin(1)
                ensight.part.modify_begin()
                ensight.part.texture_object(1)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.texture_object({repr(p0)})'''
        return self._session.cmd(cmd)

    def texture_origin(self, p0: float, p1: float, p2: float) -> int:
        """Sets the texture origin offset in model space.  This describes the "lower left" corner of the texture in world coordinates.  This is an offset amount if the Projection offset is relative to a node ID.  If not, it is an offset from the world coordinate origin, i.e., it becomes an absolute origin.
        
        | Only used if texture_coord_type is set to projection
        
        Args:
            p0:
                'x_orig' the x coordinate for the texture origin
            p1:
                'y_orig' the y coordinate for the texture origin
            p2:
                'z_orig' the z coordinate for the texture origin
        
        Examples:
            ::
        
                ensight.part.select_begin(1)
                ensight.part.modify_begin()
                ensight.part.texture_origin(-1,.2,1)
                ensight.part.texture_svector(2,0,0)
                ensight.part.texture_tvector(0,2,0)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.texture_origin({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def texture_origin_nodeid(self, p0: int) -> int:
        """Sets the texture origin offset relative to this node id.
        
        | The texture origin becomes the x/y/z coordinate of this node offset (if any) by the texture_origin command
        | Only used if the texture_coord_type is set to projection
        
        Args:
            p0:
                'node_id' The node id that will be used as the origin offset
        
        Examples:
            ::
        
                ensight.part.select_begin(1)
                ensight.part.modify_begin()
                ensight.part.texture_coord_type("projection")
                #
                # offset the texture by one unit in the x direction from nodeid 3443
                #
                ensight.part.texture_origin_use("offset_by_nodeid")
                ensight.part.texture_origin_nodeid(3443)
                ensight.part.texture_origin(1,0,0)
                ensight.part.texture_svector(2,0,0)
                ensight.part.texture_tvector(0,2,0)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.texture_origin_nodeid({repr(p0)})'''
        return self._session.cmd(cmd)

    def texture_origin_use(self, p0: str) -> int:
        """Sets how the texture origin and orientation will be defined.
        
        | Only used if the texture_coord_type is set to projection.
        
        Args:
            p0:
                'projection'
        
                * absolute
                * offset_by_nodeid
                * offsetvectors_by_nodeid
        
        Examples:
            ::
        
                ensight.part.select_begin(1)
                ensight.part.modify_begin()
                ensight.part.texture_coord_type("projection")
                #
                # offset the texture by one unit in the x direction from nodeid 3443
                #
                ensight.part.texture_origin_use("offset_by_nodeid")
                ensight.part.texture_origin_nodeid(3443)
                ensight.part.texture_origin(1,0,0)
                ensight.part.texture_svector(2,0,0)
                ensight.part.texture_tvector(0,2,0)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.texture_origin_use({repr(p0)})'''
        return self._session.cmd(cmd)

    def texture_repeat_mode(self, p0: str) -> int:
        """Indicates that a texture repeats outside of the defined target area or uses the border color.
        
        Args:
            p0:
                'mode'
        
                * repeat
                * clamp
        
        Examples:
            ::
        
                ensight.part.select_begin(1)
                ensight.part.modify_begin()
                ensight.part.texture_object(1)
                ensight.part.texture_repeat_mode("clamp")
                ensight.part.texture_mode("decal")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.texture_repeat_mode({repr(p0)})'''
        return self._session.cmd(cmd)

    def texture_sorigin_nodeid(self, p0: int) -> int:
        """Sets the s and t vector orientation according to the node ids described
        
        | Only used if the texture_coord_type is set to projection and the texture_origin_use is set to offsetvectors_by_nodeid
        
        Args:
            p0:
                'node_id' The node id to use to describe the s/t texture direction.
        
        Examples:
            ::
        
                ensight.part.select_begin(1)
                ensight.part.modify_begin()
                ensight.part.texture_coord_type("projection")
                ensight.part.texture_origin_use("offsetvectors_by_nodeid")
                ensight.part.texture_origin_nodeid(3443)
                ensight.part.texture_sorigin_nodeid(4944)
                ensight.part.texture_torigin_nodeid(5998)
                ensight.part.texture_origin(1,0,0)
                ensight.part.texture_svector(2,0,0)
                ensight.part.texture_tvector(0,2,0)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.texture_sorigin_nodeid({repr(p0)})'''
        return self._session.cmd(cmd)

    def texture_svariable(self, p0: Any) -> int:
        """For texture_coord_type set to variable these describe the variables to use for the s/t texture color
        
        | A name of "none" is acceptable - this indicates that a constant s/t coordinate of 0.5 will be used
        
        Args:
            p0:
                'name' s/t variable name
        
        Examples:
            ::
        
                ensight.part.select_begin(1)
                ensight.part.modify_begin()
                ensight.part.texture_coord_type("variables")
                ensight.part.texture_svariable("norm_temperature")
                ensight.part.texture_tvariable("none")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.texture_svariable({repr(p0)})'''
        return self._session.cmd(cmd)

    def texture_svector(self, p0: float, p1: float, p2: float) -> int:
        """Sets the texture s-vector orientation and size.  The s-vector maps to the horizontal direction of the texture.
        
        | Only used if texture_coord_type is set to projection
        
        Args:
            p0:
                'x' s vector x value in world coordinates
            p1:
                'y' s vector y value in world coordinates
            p2:
                'z' s vector z value in world coordinates
        
        Examples:
            ::
        
                ensight.part.select_begin(1)
                ensight.part.modify_begin()
                ensight.part.texture_origin(-1,.2,1)
                ensight.part.texture_svector(2,0,0)
                ensight.part.texture_tvector(0,2,0)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.texture_svector({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def texture_torigin_nodeid(self, p0: int) -> int:
        """Sets the s and t vector orientation according to the node ids described
        
        | Only used if the texture_coord_type is set to projection and the texture_origin_use is set to offsetvectors_by_nodeid
        
        Args:
            p0:
                'node_id' The node id to use to describe the s/t texture direction.
        
        Examples:
            ::
        
                ensight.part.select_begin(1)
                ensight.part.modify_begin()
                ensight.part.texture_coord_type("projection")
                ensight.part.texture_origin_use("offsetvectors_by_nodeid")
                ensight.part.texture_origin_nodeid(3443)
                ensight.part.texture_sorigin_nodeid(4944)
                ensight.part.texture_torigin_nodeid(5998)
                ensight.part.texture_origin(1,0,0)
                ensight.part.texture_svector(2,0,0)
                ensight.part.texture_tvector(0,2,0)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.texture_torigin_nodeid({repr(p0)})'''
        return self._session.cmd(cmd)

    def texture_tvariable(self, p0: Any) -> int:
        """For texture_coord_type set to variable these describe the variables to use for the s/t texture color
        
        | A name of "none" is acceptable - this indicates that a constant s/t coordinate of 0.5 will be used
        
        Args:
            p0:
                'name' s/t variable name
        
        Examples:
            ::
        
                ensight.part.select_begin(1)
                ensight.part.modify_begin()
                ensight.part.texture_coord_type("variables")
                ensight.part.texture_svariable("norm_temperature")
                ensight.part.texture_tvariable("none")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.texture_tvariable({repr(p0)})'''
        return self._session.cmd(cmd)

    def texture_tvector(self, p0: float, p1: float, p2: float) -> int:
        """Sets the texture t-vector orientation and size.  The t-vector maps to the vertical direction of the texture.
        
        | Only used if texture_coord_type is set to projection
        
        Args:
            p0:
                'x' t vector x value in world coordinates
            p1:
                'y' t vector y value in world coordinates
            p2:
                'z' t vector z value in world coordinates
        
        Examples:
            ::
        
                ensight.part.select_begin(1)
                ensight.part.modify_begin()
                ensight.part.texture_origin(-1,.2,1)
                ensight.part.texture_svector(2,0,0)
                ensight.part.texture_tvector(0,2,0)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.texture_tvector({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def transparency(self, p0: float) -> int:
        """Part: transparency

        """
        cmd = f'''ensight.part.transparency({repr(p0)})'''
        return self._session.cmd(cmd)

    def ungroup(self) -> int:
        """Ungroups the currently selected (grouped) parts.
        
        Examples:
            ::
        
                ensight.part.select_begin(3,5)
                ensight.part.ungroup()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.ungroup()'''
        return self._session.cmd(cmd)

    def updtparts(self, p0: int) -> int:
        """Updates the parent part for the currently selected part(s)
        
        Args:
            p0:
                'parent' part number of the new parent(s)
        
        Examples:
            ::
        
                ensight.part.select_begin(3,5)
                ensight.part.updtparts(2)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.updtparts({repr(p0)})'''
        return self._session.cmd(cmd)

    def viewport_vis(self, *args, **kwargs) -> Any:
        """Controls visibility of the currently selected part(s) in the specified viewport(s).
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
            p1:
                'vportN'
        
                * viewport numbers in which to modify part visibility
        
        Examples:
            ::
        
                ensight.part.select_begin(1,2,5)
                ensight.part.modify_begin()
                ensight.part.viewport_vis("OFF",1,3)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.part.viewport_vis({arg_string})"
        return self._session.cmd(cmd)

    def visibility_elt(self, p0: str) -> int:
        """Turns element visibility on or off for the currently selected part(s).
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.part.select_begin(1)
                ensight.part.modify_begin()
                ensight.part.visibility_elt("OFF")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.visibility_elt({repr(p0)})'''
        return self._session.cmd(cmd)

    def visibility_line(self, p0: str) -> int:
        """Turns line visibility on or off for the currently selected part(s).
        
        | "Line" refers to the 1D bar elements.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.part.select_begin(1)
                ensight.part.modify_begin()
                ensight.part.visibility_line("OFF")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.visibility_line({repr(p0)})'''
        return self._session.cmd(cmd)

    def visibility_node(self, p0: str) -> int:
        """Turns node visibility on or off for the currently selected part(s).
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.part.select_begin(1)
                ensight.part.modify_begin()
                ensight.part.visibility_node("ON")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.visibility_node({repr(p0)})'''
        return self._session.cmd(cmd)

    def visible(self, p0: str) -> int:
        """Controls the visibility of  the currently selected part(s).
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.part.select_begin(1,2,5)
                ensight.part.modify_begin()
                ensight.part.visible("OFF")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.part.visible({repr(p0)})'''
        return self._session.cmd(cmd)

    def volume_quality(self, p0: str) -> int:
        """Part: volume_quality

        """
        cmd = f'''ensight.part.volume_quality({repr(p0)})'''
        return self._session.cmd(cmd)


class enums:
    """Class wrapper for EnSight enums module

    This class acts as a proxy for the EnSight Python module ensight.objs.enums

    Attributes:
        ACTIVE (int):
            Instance specific constant

        ADJCOORDSCALEFACTOR (int):
            Instance specific constant

        ADJCOORDTRANSVEC (int):
            Instance specific constant

        ADJCOORDVARSCALEFACTOR (int):
            Instance specific constant

        ADJCOORDXVARIABLE (int):
            Instance specific constant

        ADJCOORDYVARIABLE (int):
            Instance specific constant

        ADJCOORDZVARIABLE (int):
            Instance specific constant

        ALLOW_MRU_UPDATE (int):
            Instance specific constant

        ALPHABY (int):
            Instance specific constant

        ALPHABYPALETTE (int):
            Instance specific constant

        ALPHA_VOLUME_SCALE (int):
            Instance specific constant

        AMBIENT_COMPONENT (int):
            Instance specific constant

        ANGLE (int):
            Instance specific constant

        ANIMATE (int):
            Instance specific constant

        ANIMATECURVES (int):
            Instance specific constant

        ANIMATING (int):
            Instance specific constant

        ANIMDELTA (int):
            Instance specific constant

        ANIMOBJS (int):
            Instance specific constant

        ANNOTATIONTEXTID (int):
            Instance specific constant

        ANNOTINDEX (int):
            Instance specific constant

        ANNOTS (int):
            Instance specific constant

        ANNOTTYPE (int):
            Instance specific constant

        ANNOT_2D_SPACE (int):
            Instance specific constant

        ANNOT_3D_SPACE (int):
            Instance specific constant

        ANNOT_SHAPE_ARROW (int):
            Instance specific constant

        ANNOT_SHAPE_CIRCLE (int):
            Instance specific constant

        ANNOT_SHAPE_RECT (int):
            Instance specific constant

        ANNO_ARROW (int):
            Instance specific constant

        ANNO_DIAL (int):
            Instance specific constant

        ANNO_GAUGE (int):
            Instance specific constant

        ANNO_LGND (int):
            Instance specific constant

        ANNO_LINE (int):
            Instance specific constant

        ANNO_LOGO (int):
            Instance specific constant

        ANNO_SHAPE (int):
            Instance specific constant

        ANNO_TEXT (int):
            Instance specific constant

        ANSYS_DRAW_LOGO (int):
            Instance specific constant

        ANSYS_FLAG_ALPHA (int):
            Instance specific constant

        ANSYS_FLAG_BETA (int):
            Instance specific constant

        ANSYS_VERSION (int):
            Instance specific constant

        ANSYS_VERSION_STRING (int):
            Instance specific constant

        ANTIALIAS_FILTER_ALGORITHM (int):
            Instance specific constant

        ANTIALIAS_MODE (int):
            Instance specific constant

        ANTIALIAS_NUM_SAMPLES (int):
            Instance specific constant

        ANTIALIAS_PARAM_COMPRESSION (int):
            Instance specific constant

        ANTIALIAS_PARAM_GAMMA (int):
            Instance specific constant

        ANTIALIAS_PARAM_SMOOTH (int):
            Instance specific constant

        APPENDLOCATIONVALUE (int):
            Instance specific constant

        ARLOC_ELTC (int):
            Instance specific constant

        ARLOC_NODE (int):
            Instance specific constant

        ARLOC_VERT (int):
            Instance specific constant

        ARROWATTACH (int):
            Instance specific constant

        ARROWHEAD (int):
            Instance specific constant

        ARROWLOCATION (int):
            Instance specific constant

        ARROWS (int):
            Instance specific constant

        ARROWSIZE (int):
            Instance specific constant

        ARROWTIPLENGTH (int):
            Instance specific constant

        ARROWTIPSIZE (int):
            Instance specific constant

        ARROWTYPE (int):
            Instance specific constant

        ARROWWIDTH (int):
            Instance specific constant

        ARROW_3D_FORCES (int):
            Instance specific constant

        ARROW_3D_MOMENTS (int):
            Instance specific constant

        ARROW_3D_QUERY_LOCAT (int):
            Instance specific constant

        ARROW_3D_XYZ_LOCAT (int):
            Instance specific constant

        ARROW_ALL (int):
            Instance specific constant

        ARROW_COMP (int):
            Instance specific constant

        ARROW_NORM (int):
            Instance specific constant

        ARROW_SHAFT_LINE (int):
            Instance specific constant

        ARROW_SHAFT_SOLID (int):
            Instance specific constant

        ARROW_TAIL_AT_POINT (int):
            Instance specific constant

        ARROW_TANG (int):
            Instance specific constant

        ARROW_TIP_AT_POINT (int):
            Instance specific constant

        ARRW_CURV (int):
            Instance specific constant

        ARRW_FIXD (int):
            Instance specific constant

        ARRW_RECT (int):
            Instance specific constant

        ASSIGNED_CURVE_TO_YLEFT (int):
            Instance specific constant

        ASSIGNED_CURVE_TO_YRIGHT (int):
            Instance specific constant

        ASSIGNTOYAXIS (int):
            Instance specific constant

        ATRACE_COLBY_CALC (int):
            Instance specific constant

        ATRACE_COLBY_CONST (int):
            Instance specific constant

        ATRACE_HEAD_ARROW (int):
            Instance specific constant

        ATRACE_HEAD_NONE (int):
            Instance specific constant

        ATRACE_HEAD_SPHERE (int):
            Instance specific constant

        ATRACE_SIZE_CONST (int):
            Instance specific constant

        ATRACE_SIZE_SCALAR (int):
            Instance specific constant

        ATRACE_SIZE_VEC_MAG (int):
            Instance specific constant

        ATRACE_SIZE_VEC_X (int):
            Instance specific constant

        ATRACE_SIZE_VEC_Y (int):
            Instance specific constant

        ATRACE_SIZE_VEC_Z (int):
            Instance specific constant

        AUTOSCALE (int):
            Instance specific constant

        AUTOSIZE (int):
            Instance specific constant

        AUXCLIPPING (int):
            Instance specific constant

        AUX_GEOM_NORMAL_INWARD (int):
            Instance specific constant

        AUX_GEOM_NORMAL_OUTWARD (int):
            Instance specific constant

        AUX_GEOM_SHAPE_BOX (int):
            Instance specific constant

        AXESVISIBLE (int):
            Instance specific constant

        AXIS (int):
            Instance specific constant

        AXIS2AUTOSCALE (int):
            Instance specific constant

        AXIS2LABELFORMAT (int):
            Instance specific constant

        AXIS2LABELRGB (int):
            Instance specific constant

        AXIS2LABELSIZE (int):
            Instance specific constant

        AXIS2LABELTYPE (int):
            Instance specific constant

        AXIS2MAX (int):
            Instance specific constant

        AXIS2MIN (int):
            Instance specific constant

        AXIS2TITLE (int):
            Instance specific constant

        AXIS2TITLERGB (int):
            Instance specific constant

        AXIS2TITLESIZE (int):
            Instance specific constant

        AXIS2VISIBLE (int):
            Instance specific constant

        AXISAUTOLAYOUT (int):
            Instance specific constant

        AXISAUTOUPDATE (int):
            Instance specific constant

        AXISGLOBAL (int):
            Instance specific constant

        AXISHEIGHT (int):
            Instance specific constant

        AXISLINEWIDTH (int):
            Instance specific constant

        AXISLOCAL (int):
            Instance specific constant

        AXISMODEL (int):
            Instance specific constant

        AXISMODEL_ANIMATE (int):
            Instance specific constant

        AXISMODEL_LOCATION (int):
            Instance specific constant

        AXISRGB (int):
            Instance specific constant

        AXISSWAP (int):
            Instance specific constant

        AXISWIDTH (int):
            Instance specific constant

        AXISXAUTOSCALE (int):
            Instance specific constant

        AXISXDISPLAYONEDGE (int):
            Instance specific constant

        AXISXFORMAT (int):
            Instance specific constant

        AXISXGRIDEXTENTLOC (int):
            Instance specific constant

        AXISXGRIDTYPE (int):
            Instance specific constant

        AXISXLABELAXISLOC (int):
            Instance specific constant

        AXISXLABELEXTENTLOC (int):
            Instance specific constant

        AXISXLABELFILTER (int):
            Instance specific constant

        AXISXLABELFORMAT (int):
            Instance specific constant

        AXISXLABELRGB (int):
            Instance specific constant

        AXISXLABELSIZE (int):
            Instance specific constant

        AXISXLABELTYPE (int):
            Instance specific constant

        AXISXMAX (int):
            Instance specific constant

        AXISXMIN (int):
            Instance specific constant

        AXISXNUMGRID (int):
            Instance specific constant

        AXISXNUMGRIDLOG (int):
            Instance specific constant

        AXISXNUMSUBGRID (int):
            Instance specific constant

        AXISXNUMSUBGRIDLOG (int):
            Instance specific constant

        AXISXORIG (int):
            Instance specific constant

        AXISXORIGIN (int):
            Instance specific constant

        AXISXSCALE (int):
            Instance specific constant

        AXISXSGRIDTYPE (int):
            Instance specific constant

        AXISXSIZE (int):
            Instance specific constant

        AXISXSUBTICK (int):
            Instance specific constant

        AXISXTICK (int):
            Instance specific constant

        AXISXTITLE (int):
            Instance specific constant

        AXISXTITLERGB (int):
            Instance specific constant

        AXISXTITLESIZE (int):
            Instance specific constant

        AXISXVISIBLE (int):
            Instance specific constant

        AXISXYMAXZMAX (int):
            Instance specific constant

        AXISXYMAXZMIN (int):
            Instance specific constant

        AXISXYMINZMAX (int):
            Instance specific constant

        AXISXYMINZMIN (int):
            Instance specific constant

        AXISYAUTOSCALE (int):
            Instance specific constant

        AXISYDISPLAYONEDGE (int):
            Instance specific constant

        AXISYFORMAT (int):
            Instance specific constant

        AXISYGRIDEXTENTLOC (int):
            Instance specific constant

        AXISYGRIDTYPE (int):
            Instance specific constant

        AXISYLABELAXISLOC (int):
            Instance specific constant

        AXISYLABELEXTENTLOC (int):
            Instance specific constant

        AXISYLABELFILTER (int):
            Instance specific constant

        AXISYLABELFORMAT (int):
            Instance specific constant

        AXISYLABELRGB (int):
            Instance specific constant

        AXISYLABELSIZE (int):
            Instance specific constant

        AXISYLABELTYPE (int):
            Instance specific constant

        AXISYMAX (int):
            Instance specific constant

        AXISYMIN (int):
            Instance specific constant

        AXISYNUMGRID (int):
            Instance specific constant

        AXISYNUMGRIDLOG (int):
            Instance specific constant

        AXISYNUMSUBGRID (int):
            Instance specific constant

        AXISYNUMSUBGRIDLOG (int):
            Instance specific constant

        AXISYORIG (int):
            Instance specific constant

        AXISYORIGIN (int):
            Instance specific constant

        AXISYSCALE (int):
            Instance specific constant

        AXISYSGRIDTYPE (int):
            Instance specific constant

        AXISYSIZE (int):
            Instance specific constant

        AXISYSUBTICK (int):
            Instance specific constant

        AXISYTICK (int):
            Instance specific constant

        AXISYTITLE (int):
            Instance specific constant

        AXISYTITLERGB (int):
            Instance specific constant

        AXISYTITLESIZE (int):
            Instance specific constant

        AXISYVISIBLE (int):
            Instance specific constant

        AXISYYMAXZMAX (int):
            Instance specific constant

        AXISYYMAXZMIN (int):
            Instance specific constant

        AXISYYMINZMAX (int):
            Instance specific constant

        AXISYYMINZMIN (int):
            Instance specific constant

        AXISZDISPLAYONEDGE (int):
            Instance specific constant

        AXISZFORMAT (int):
            Instance specific constant

        AXISZGRIDEXTENTLOC (int):
            Instance specific constant

        AXISZGRIDTYPE (int):
            Instance specific constant

        AXISZLABELAXISLOC (int):
            Instance specific constant

        AXISZLABELEXTENTLOC (int):
            Instance specific constant

        AXISZLABELFILTER (int):
            Instance specific constant

        AXISZLABELRGB (int):
            Instance specific constant

        AXISZMAX (int):
            Instance specific constant

        AXISZMIN (int):
            Instance specific constant

        AXISZNUMGRID (int):
            Instance specific constant

        AXISZNUMSUBGRID (int):
            Instance specific constant

        AXISZSGRIDTYPE (int):
            Instance specific constant

        AXISZSUBTICK (int):
            Instance specific constant

        AXISZTICK (int):
            Instance specific constant

        AXISZTITLE (int):
            Instance specific constant

        AXISZTITLESIZE (int):
            Instance specific constant

        AXISZYMAXZMAX (int):
            Instance specific constant

        AXISZYMAXZMIN (int):
            Instance specific constant

        AXISZYMINZMAX (int):
            Instance specific constant

        AXISZYMINZMIN (int):
            Instance specific constant

        AXI_TYPE_EXTRUDE (int):
            Instance specific constant

        AXI_TYPE_ROTATE (int):
            Instance specific constant

        BACKGROUND (int):
            Instance specific constant

        BACKGROUNDIMAGE (int):
            Instance specific constant

        BACKGROUNDIMAGENAME (int):
            Instance specific constant

        BACKGROUNDRGB (int):
            Instance specific constant

        BACKGROUNDTRANSPARENCY (int):
            Instance specific constant

        BACKGROUNDTYPE (int):
            Instance specific constant

        BEGINSIMTIME (int):
            Instance specific constant

        BIGHANDRANGE (int):
            Instance specific constant

        BIGHANDRGB (int):
            Instance specific constant

        BLANKINGALGORITHM (int):
            Instance specific constant

        BLANKINGCLIPALG (int):
            Instance specific constant

        BLANKINGTHRESHOLD (int):
            Instance specific constant

        BLANKINGVARIABLE1 (int):
            Instance specific constant

        BLANKINGVARIABLE2 (int):
            Instance specific constant

        BLENDLEVELS (int):
            Instance specific constant

        BLENDPOSITION2 (int):
            Instance specific constant

        BLENDPOSITION3 (int):
            Instance specific constant

        BLENDPOSITION4 (int):
            Instance specific constant

        BLENDRGB1 (int):
            Instance specific constant

        BLENDRGB2 (int):
            Instance specific constant

        BLENDRGB3 (int):
            Instance specific constant

        BLENDRGB4 (int):
            Instance specific constant

        BLENDRGB5 (int):
            Instance specific constant

        BORDER (int):
            Instance specific constant

        BORDERCOLOR (int):
            Instance specific constant

        BORDERREP (int):
            Instance specific constant

        BORDERRGB (int):
            Instance specific constant

        BORDERVISIBLE (int):
            Instance specific constant

        BORD_FULL (int):
            Instance specific constant

        BOTH_ARRW (int):
            Instance specific constant

        BOUNDARYFLAGXMAX (int):
            Instance specific constant

        BOUNDARYFLAGXMIN (int):
            Instance specific constant

        BOUNDARYFLAGYMAX (int):
            Instance specific constant

        BOUNDARYFLAGYMIN (int):
            Instance specific constant

        BOUNDARYFLAGZMAX (int):
            Instance specific constant

        BOUNDARYFLAGZMIN (int):
            Instance specific constant

        BOUNDINGBOX (int):
            Instance specific constant

        BOUNDINGREP (int):
            Instance specific constant

        BOUNDING_BOX (int):
            Instance specific constant

        BOUNDS (int):
            Instance specific constant

        BOXAXISX (int):
            Instance specific constant

        BOXAXISY (int):
            Instance specific constant

        BOXAXISZ (int):
            Instance specific constant

        BOXLENGTH (int):
            Instance specific constant

        BOXORIGIN (int):
            Instance specific constant

        BOX_DRAW_BOX (int):
            Instance specific constant

        BOX_DRAW_MODEL (int):
            Instance specific constant

        BOX_DRAW_NOTHING (int):
            Instance specific constant

        BOX_DRAW_POINTS (int):
            Instance specific constant

        BOX_DRAW_REDUCED (int):
            Instance specific constant

        BOX_DRAW_SPARSE_MODEL (int):
            Instance specific constant

        C1_POINTS (int):
            Instance specific constant

        C2_POINTS (int):
            Instance specific constant

        C3_POINTS (int):
            Instance specific constant

        C4_POINTS (int):
            Instance specific constant

        CALC_0D (int):
            Instance specific constant

        CALC_1D (int):
            Instance specific constant

        CALC_2D (int):
            Instance specific constant

        CALC_3D (int):
            Instance specific constant

        CALC_CASEID (int):
            Instance specific constant

        CALC_COMPONENT (int):
            Instance specific constant

        CALC_HINTS_MASK (int):
            Instance specific constant

        CALC_MASS_PTRACE (int):
            Instance specific constant

        CALC_NODEID (int):
            Instance specific constant

        CALC_PARTID (int):
            Instance specific constant

        CALC_TIMESTEP (int):
            Instance specific constant

        CALC_VAL_BOOLEAN (int):
            Instance specific constant

        CALC_VAL_ENUM (int):
            Instance specific constant

        CALC_VAL_FLOAT (int):
            Instance specific constant

        CALC_VAL_INT (int):
            Instance specific constant

        CALC_VAL_MASK (int):
            Instance specific constant

        CALC_VAR_ACTIVE (int):
            Instance specific constant

        CALC_VAR_CONST (int):
            Instance specific constant

        CALC_VAR_CONSTPPART (int):
            Instance specific constant

        CALC_VAR_CONSTPPOPT (int):
            Instance specific constant

        CALC_VAR_COORDS (int):
            Instance specific constant

        CALC_VAR_ELEMENT (int):
            Instance specific constant

        CALC_VAR_MASK (int):
            Instance specific constant

        CALC_VAR_MATERIAL (int):
            Instance specific constant

        CALC_VAR_NODAL (int):
            Instance specific constant

        CALC_VAR_NONEOK (int):
            Instance specific constant

        CALC_VAR_OBJECT (int):
            Instance specific constant

        CALC_VAR_PARTLIST (int):
            Instance specific constant

        CALC_VAR_SCALAR (int):
            Instance specific constant

        CALC_VAR_SCLCLPX (int):
            Instance specific constant

        CALC_VAR_SPECIES (int):
            Instance specific constant

        CALC_VAR_TENSOR (int):
            Instance specific constant

        CALC_VAR_TIME (int):
            Instance specific constant

        CALC_VAR_VECCLPX (int):
            Instance specific constant

        CALC_VAR_VECTOR (int):
            Instance specific constant

        CALC_VIEWPORT (int):
            Instance specific constant

        CAMERAS (int):
            Instance specific constant

        CAMERA_LENS_NORMAL (int):
            Instance specific constant

        CAMERA_LENS_VIEW_PYRAMID (int):
            Instance specific constant

        CAMERA_LOOK_AT_FORWARD (int):
            Instance specific constant

        CAMERA_LOOK_AT_NODE (int):
            Instance specific constant

        CAMERA_LOOK_AT_PLANE_TOOL (int):
            Instance specific constant

        CAMERA_LOOK_AT_SPLINE (int):
            Instance specific constant

        CAMERA_LOOK_AT_XYZ (int):
            Instance specific constant

        CAMERA_LOOK_FROM_NODE (int):
            Instance specific constant

        CAMERA_LOOK_FROM_PLANE_TOOL (int):
            Instance specific constant

        CAMERA_LOOK_FROM_SPLINE (int):
            Instance specific constant

        CAMERA_LOOK_FROM_XYZ (int):
            Instance specific constant

        CASELINKING (int):
            Instance specific constant

        CASENUMBER (int):
            Instance specific constant

        CASES (int):
            Instance specific constant

        CASE_LINKING_LABELS (int):
            Instance specific constant

        CASTS_SHADOWS (int):
            Instance specific constant

        CELLCOMPNUM (int):
            Instance specific constant

        CELLTYPE (int):
            Instance specific constant

        CELLVOLUMEFRACTION (int):
            Instance specific constant

        CENTROID (int):
            Instance specific constant

        CFD_VAR (int):
            Instance specific constant

        CHANGEALLOWED (int):
            Instance specific constant

        CHILDREN (int):
            Instance specific constant

        CLICKNGO_HANDLE_VISIBILITY (int):
            Instance specific constant

        CLIP (int):
            Instance specific constant

        CLIPBLANKINGVARIABLE (int):
            Instance specific constant

        CLIPLCTW (int):
            Instance specific constant

        CLIPLINEPT1 (int):
            Instance specific constant

        CLIPLINEPT2 (int):
            Instance specific constant

        CLIPPERIODICFLAGX (int):
            Instance specific constant

        CLIPPERIODICFLAGY (int):
            Instance specific constant

        CLIPPLANEPT1 (int):
            Instance specific constant

        CLIPPLANEPT2 (int):
            Instance specific constant

        CLIPPLANEPT3 (int):
            Instance specific constant

        CLIPTYPE (int):
            Instance specific constant

        CLIP_CHOICE_BETWEEN (int):
            Instance specific constant

        CLIP_CHOICE_GREATER (int):
            Instance specific constant

        CLIP_CHOICE_LESS (int):
            Instance specific constant

        CLIP_DOMAIN_CRINKLY (int):
            Instance specific constant

        CLIP_DOMAIN_IN (int):
            Instance specific constant

        CLIP_DOMAIN_INOUT (int):
            Instance specific constant

        CLIP_DOMAIN_INTER (int):
            Instance specific constant

        CLIP_DOMAIN_OUT (int):
            Instance specific constant

        CLIP_DOMAIN_RECT (int):
            Instance specific constant

        CLIP_DOMAIN_VOLUME (int):
            Instance specific constant

        CLIP_PLANE_FINITE (int):
            Instance specific constant

        CLIP_PLANE_INFINITE (int):
            Instance specific constant

        CMDLANG_REFERENCE (int):
            Instance specific constant

        COLOR (int):
            Instance specific constant

        COLORBY (int):
            Instance specific constant

        COLORBYPALETTE (int):
            Instance specific constant

        COLORBYPROJECTION (int):
            Instance specific constant

        COLORBYRGB (int):
            Instance specific constant

        COLORS_PER_LEVEL (int):
            Instance specific constant

        COLOR_SPACE (int):
            Instance specific constant

        COMPONENT (int):
            Instance specific constant

        COMPONENTNUMINCELL (int):
            Instance specific constant

        COMPOSITEMATRIX (int):
            Instance specific constant

        COMPRESSION (int):
            Instance specific constant

        COMPRESSIONLINEWIDTH (int):
            Instance specific constant

        COMPRESSIONRGB (int):
            Instance specific constant

        COMPRESSION_GZ (int):
            Instance specific constant

        COMPRESSION_JPEG (int):
            Instance specific constant

        COMPRESSION_NONE (int):
            Instance specific constant

        COMPRESSION_RLE (int):
            Instance specific constant

        COMPUTED (int):
            Instance specific constant

        COMPUTEUSINGPERIODICITY (int):
            Instance specific constant

        CONEANGLE (int):
            Instance specific constant

        CONEAXISVECT (int):
            Instance specific constant

        CONEENDPOINT (int):
            Instance specific constant

        CONEORIGIN (int):
            Instance specific constant

        CONNECTIVITY (int):
            Instance specific constant

        CONNECT_TIMEOUT (int):
            Instance specific constant

        CONSTANTRGB (int):
            Instance specific constant

        CONSTANT_VALUE (int):
            Instance specific constant

        CONSTRAINDISTANCE (int):
            Instance specific constant

        CONSTRAINT (int):
            Instance specific constant

        CONSTRAINTIME (int):
            Instance specific constant

        CONTOUR_LABEL_HORIZ (int):
            Instance specific constant

        CONTOUR_LABEL_TANGN (int):
            Instance specific constant

        CONTROLPOINTS (int):
            Instance specific constant

        COOLINGCHANNELCOMP (int):
            Instance specific constant

        COORDINATES (int):
            Instance specific constant

        CORE (int):
            Instance specific constant

        CORE2DTRANSFORM (int):
            Instance specific constant

        CORETRANSFORM (int):
            Instance specific constant

        CREATE_REPORT_TEMPLATE (int):
            Instance specific constant

        CT_BOX (int):
            Instance specific constant

        CT_CONE (int):
            Instance specific constant

        CT_CYLD (int):
            Instance specific constant

        CT_GENQ (int):
            Instance specific constant

        CT_IJK (int):
            Instance specific constant

        CT_LINE (int):
            Instance specific constant

        CT_PART (int):
            Instance specific constant

        CT_PLNE (int):
            Instance specific constant

        CT_REVO (int):
            Instance specific constant

        CT_RTZ (int):
            Instance specific constant

        CT_SPHR (int):
            Instance specific constant

        CT_SPLINE (int):
            Instance specific constant

        CT_XYZ (int):
            Instance specific constant

        CULLELEMENTS (int):
            Instance specific constant

        CULL_BACK_FACE (int):
            Instance specific constant

        CULL_FRONT_FACE (int):
            Instance specific constant

        CULL_NO_FACE (int):
            Instance specific constant

        CURRENT (int):
            Instance specific constant

        CURRENTCASE (int):
            Instance specific constant

        CURRENTFRAME (int):
            Instance specific constant

        CURRENTGUI (int):
            Instance specific constant

        CURRENTVIEWPORTID (int):
            Instance specific constant

        CURSORLOC (int):
            Instance specific constant

        CURVE_LINE_CONNECT (int):
            Instance specific constant

        CURVE_LINE_NONE (int):
            Instance specific constant

        CURVE_LINE_SMOOTH (int):
            Instance specific constant

        CURVE_MARKER_CIRCLE (int):
            Instance specific constant

        CURVE_MARKER_DOT (int):
            Instance specific constant

        CURVE_MARKER_NONE (int):
            Instance specific constant

        CURVE_MARKER_SQUARE (int):
            Instance specific constant

        CURVE_MARKER_TRIANGLE (int):
            Instance specific constant

        CVF_ATTRDEP_CHAIN_AND (int):
            Instance specific constant

        CVF_ATTRDEP_CHAIN_MASK (int):
            Instance specific constant

        CVF_ATTRDEP_CHAIN_OR (int):
            Instance specific constant

        CVF_ATTRDEP_CHAIN_XOR (int):
            Instance specific constant

        CVF_ATTRDEP_LEN_FOR (int):
            Instance specific constant

        CVF_ATTRDEP_LEN_OF (int):
            Instance specific constant

        CVF_ATTRDEP_MASK_OP (int):
            Instance specific constant

        CVF_ATTRDEP_SENS_AND (int):
            Instance specific constant

        CVF_ATTRDEP_SENS_EQ (int):
            Instance specific constant

        CVF_ATTRDEP_SENS_GT (int):
            Instance specific constant

        CVF_ATTRDEP_SENS_LT (int):
            Instance specific constant

        CVF_ATTRDEP_SENS_MASK (int):
            Instance specific constant

        CVF_ATTRDEP_SENS_NOT (int):
            Instance specific constant

        CVF_ATTRDEP_SENS_OR (int):
            Instance specific constant

        CVF_ATTRDEP_SENS_VALUE (int):
            Instance specific constant

        CVF_ATTRDEP_SENS_XOR (int):
            Instance specific constant

        CVF_ATTR_BIT_FLAGS (int):
            Instance specific constant

        CVF_ATTR_BOOL (int):
            Instance specific constant

        CVF_ATTR_COLOR_RGB (int):
            Instance specific constant

        CVF_ATTR_COLOR_RGBA (int):
            Instance specific constant

        CVF_ATTR_ENUM (int):
            Instance specific constant

        CVF_ATTR_FLOAT (int):
            Instance specific constant

        CVF_ATTR_FONT (int):
            Instance specific constant

        CVF_ATTR_GREATER (int):
            Instance specific constant

        CVF_ATTR_HAS_ENUMS (int):
            Instance specific constant

        CVF_ATTR_HAS_RANGE (int):
            Instance specific constant

        CVF_ATTR_IMAGE (int):
            Instance specific constant

        CVF_ATTR_INT (int):
            Instance specific constant

        CVF_ATTR_INT64 (int):
            Instance specific constant

        CVF_ATTR_LESS (int):
            Instance specific constant

        CVF_ATTR_NO_MAXIMUM (int):
            Instance specific constant

        CVF_ATTR_NO_MINIMUM (int):
            Instance specific constant

        CVF_ATTR_OBJPTR (int):
            Instance specific constant

        CVF_ATTR_PSTRING (int):
            Instance specific constant

        CVF_ATTR_PTR (int):
            Instance specific constant

        CVF_ATTR_READONLY (int):
            Instance specific constant

        CVF_ATTR_SOBJPTR (int):
            Instance specific constant

        CVF_ATTR_STRING (int):
            Instance specific constant

        CVF_ATTR_USERFLG_MASK (int):
            Instance specific constant

        CVF_ATTR_VARID (int):
            Instance specific constant

        CVF_CP_UTF8 (int):
            Instance specific constant

        CVF_FONT_BOLD (int):
            Instance specific constant

        CVF_FONT_DEMILIGHT (int):
            Instance specific constant

        CVF_FONT_ITALIC (int):
            Instance specific constant

        CVF_FONT_LIGHT (int):
            Instance specific constant

        CVF_FONT_NARROW (int):
            Instance specific constant

        CVF_FONT_OBLIQUE (int):
            Instance specific constant

        CVF_FONT_REGULAR (int):
            Instance specific constant

        CVF_FONT_ROMAN (int):
            Instance specific constant

        CVF_FONT_THIN (int):
            Instance specific constant

        CVF_GFX_RAM_UNKNOWN (int):
            Instance specific constant

        CVF_HILITE_METHOD_GEOMETRY (int):
            Instance specific constant

        CVF_HILITE_METHOD_IMAGE (int):
            Instance specific constant

        CVF_JLC_APPCMDLINE (int):
            Instance specific constant

        CVF_JLC_CWD (int):
            Instance specific constant

        CVF_JLC_HOSTNAME (int):
            Instance specific constant

        CVF_JLC_LAUNCHCFGNAME (int):
            Instance specific constant

        CVF_JLC_LAUNCHMETHOD (int):
            Instance specific constant

        CVF_JLC_LAUNCHOPT (int):
            Instance specific constant

        CVF_JLC_NAME (int):
            Instance specific constant

        CVF_JLC_NNODES (int):
            Instance specific constant

        CVF_JLC_RSH (int):
            Instance specific constant

        CVF_JLC_RSHOPT (int):
            Instance specific constant

        CVF_JLC_RSHPORT (int):
            Instance specific constant

        CVF_JLC_RUSERNAME (int):
            Instance specific constant

        CVF_JLC_TIMEOUT (int):
            Instance specific constant

        CVF_LANG_UNKNOWN (int):
            Instance specific constant

        CVF_PALETTE_UNDEFINED_AS_ZERO_VALUE (int):
            Instance specific constant

        CVF_PALETTE_UNDEFINED_BY_INVISIBLE (int):
            Instance specific constant

        CVF_PALETTE_UNDEFINED_BY_PART_COLOR (int):
            Instance specific constant

        CVF_PALETTE_UNDEFINED_BY_UNDEF_COLOR (int):
            Instance specific constant

        CYLDAXISVECT (int):
            Instance specific constant

        CYLDENDPOINT (int):
            Instance specific constant

        CYLDORIGIN (int):
            Instance specific constant

        CYLDRADIUS (int):
            Instance specific constant

        CYLINDERS (int):
            Instance specific constant

        DATA_BIGENDIAN (int):
            Instance specific constant

        DATA_LITTLEENDIAN (int):
            Instance specific constant

        DATA_NATIVE (int):
            Instance specific constant

        DEFAULTANNOTS (int):
            Instance specific constant

        DEFAULTPARTS (int):
            Instance specific constant

        DEFAULTPLOT (int):
            Instance specific constant

        DEFAULTPOLYLINE (int):
            Instance specific constant

        DEFAULTQUERY (int):
            Instance specific constant

        DEFAULTREADERID (int):
            Instance specific constant

        DEFAULTVARIABLE (int):
            Instance specific constant

        DEFAULTVPORT (int):
            Instance specific constant

        DEFAULT_3DANNOT_FONTSIZE (int):
            Instance specific constant

        DEFAULT_ANNOT_FONTFAMILY (int):
            Instance specific constant

        DEFAULT_ANNOT_FONTSTYLE (int):
            Instance specific constant

        DEFAULT_CORE_FONTFAMILY (int):
            Instance specific constant

        DEFAULT_CORE_FONTSCALE (int):
            Instance specific constant

        DEFAULT_CORE_FONTSTYLE (int):
            Instance specific constant

        DEFAULT_JLC (int):
            Instance specific constant

        DEFAULT_SYMBOL_FONTFAMILY (int):
            Instance specific constant

        DEFAULT_SYMBOL_FONTSTYLE (int):
            Instance specific constant

        DEFAULT_VALUE (float):
            Instance specific constant

        DEGREE (int):
            Instance specific constant

        DELAY_REFRESH (int):
            Instance specific constant

        DELTA (int):
            Instance specific constant

        DELTATIME (int):
            Instance specific constant

        DENSITY (int):
            Instance specific constant

        DESCRIPTION (int):
            Instance specific constant

        DIAMETER (int):
            Instance specific constant

        DIFFUSE_COMPONENT (int):
            Instance specific constant

        DIMENSION (int):
            Instance specific constant

        DIMENSION2 (int):
            Instance specific constant

        DIMENSION2STEP (int):
            Instance specific constant

        DIMENSION3 (int):
            Instance specific constant

        DIMENSION3STEP (int):
            Instance specific constant

        DIMENSIONS (int):
            Instance specific constant

        DIRECTION (int):
            Instance specific constant

        DIRECTIONVECTOR (int):
            Instance specific constant

        DIRENTRY_DIR (int):
            Instance specific constant

        DIRENTRY_READABLE (int):
            Instance specific constant

        DIRENTRY_SYMLINK (int):
            Instance specific constant

        DIRENTRY_WRITABLE (int):
            Instance specific constant

        DISPLACEBY (int):
            Instance specific constant

        DISPLACEFACTOR (int):
            Instance specific constant

        DISPLAYCOMPRESSION (int):
            Instance specific constant

        DISPLAYMAJOR (int):
            Instance specific constant

        DISPLAYMIDDLE (int):
            Instance specific constant

        DISPLAYMINOR (int):
            Instance specific constant

        DISPLAYOFFSET (int):
            Instance specific constant

        DISPLAYTENSION (int):
            Instance specific constant

        DISPLAYUNDEFINED (int):
            Instance specific constant

        DISPLAY_THEME (int):
            Instance specific constant

        DISPLAY_THEME_NONE (int):
            Instance specific constant

        DISPLAY_THEME_PRINTCOLORS (int):
            Instance specific constant

        DISTANCE (int):
            Instance specific constant

        DISTANCE_SCALE (int):
            Instance specific constant

        DISTRIBUTION (int):
            Instance specific constant

        DOMAIN (int):
            Instance specific constant

        DOMAINBOX (int):
            Instance specific constant

        DOMAINXYZRTZLINE (int):
            Instance specific constant

        DOUBLESIDED (int):
            Instance specific constant

        DTA_BLOCK (int):
            Instance specific constant

        EDIT_TARGET (int):
            Instance specific constant

        ELEMCOUNT (int):
            Instance specific constant

        ELEMID (int):
            Instance specific constant

        ELE_FAILED_EQUAL (int):
            Instance specific constant

        ELE_FAILED_GREATER (int):
            Instance specific constant

        ELE_FAILED_LESS (int):
            Instance specific constant

        ELE_FAILED_LOGIC_AND (int):
            Instance specific constant

        ELE_FAILED_LOGIC_NONE (int):
            Instance specific constant

        ELE_FAILED_LOGIC_OR (int):
            Instance specific constant

        ELE_FAILED_NOT_EQUAL (int):
            Instance specific constant

        ELTBLANKING (int):
            Instance specific constant

        ELTDEFINEDBY (int):
            Instance specific constant

        ELTFEATUREANGLE (int):
            Instance specific constant

        ELTFILTER1ACTIVE (int):
            Instance specific constant

        ELTFILTER1TESTOP (int):
            Instance specific constant

        ELTFILTER1TESTVALUE (int):
            Instance specific constant

        ELTFILTER1TESTVARCOMP (int):
            Instance specific constant

        ELTFILTER1TESTVARIABLE (int):
            Instance specific constant

        ELTFILTER1VARCOMP (int):
            Instance specific constant

        ELTFILTER1VARIABLE (int):
            Instance specific constant

        ELTFILTER2ACTIVE (int):
            Instance specific constant

        ELTFILTER2LOGICALOP (int):
            Instance specific constant

        ELTFILTER2TESTOP (int):
            Instance specific constant

        ELTFILTER2TESTVALUE (int):
            Instance specific constant

        ELTFILTER2TESTVARCOMP (int):
            Instance specific constant

        ELTFILTER2TESTVARIABLE (int):
            Instance specific constant

        ELTFILTER2VARCOMP (int):
            Instance specific constant

        ELTFILTER2VARIABLE (int):
            Instance specific constant

        ELTFILTER3ACTIVE (int):
            Instance specific constant

        ELTFILTER3LOGICALOP (int):
            Instance specific constant

        ELTFILTER3TESTOP (int):
            Instance specific constant

        ELTFILTER3TESTVALUE (int):
            Instance specific constant

        ELTFILTER3TESTVARCOMP (int):
            Instance specific constant

        ELTFILTER3TESTVARIABLE (int):
            Instance specific constant

        ELTFILTER3VARCOMP (int):
            Instance specific constant

        ELTFILTER3VARIABLE (int):
            Instance specific constant

        ELTFILTER4ACTIVE (int):
            Instance specific constant

        ELTFILTER4LOGICALOP (int):
            Instance specific constant

        ELTFILTER4TESTOP (int):
            Instance specific constant

        ELTFILTER4TESTVALUE (int):
            Instance specific constant

        ELTFILTER4TESTVARCOMP (int):
            Instance specific constant

        ELTFILTER4TESTVARIABLE (int):
            Instance specific constant

        ELTFILTER4VARCOMP (int):
            Instance specific constant

        ELTFILTER4VARIABLE (int):
            Instance specific constant

        ELTFILTER5ACTIVE (int):
            Instance specific constant

        ELTFILTER5LOGICALOP (int):
            Instance specific constant

        ELTFILTER5TESTOP (int):
            Instance specific constant

        ELTFILTER5TESTVALUE (int):
            Instance specific constant

        ELTFILTER5TESTVARCOMP (int):
            Instance specific constant

        ELTFILTER5TESTVARIABLE (int):
            Instance specific constant

        ELTFILTER5VARCOMP (int):
            Instance specific constant

        ELTFILTER5VARIABLE (int):
            Instance specific constant

        ELTFILTER6ACTIVE (int):
            Instance specific constant

        ELTFILTER6LOGICALOP (int):
            Instance specific constant

        ELTFILTER6TESTOP (int):
            Instance specific constant

        ELTFILTER6TESTVALUE (int):
            Instance specific constant

        ELTFILTER6TESTVARCOMP (int):
            Instance specific constant

        ELTFILTER6TESTVARIABLE (int):
            Instance specific constant

        ELTFILTER6VARCOMP (int):
            Instance specific constant

        ELTFILTER6VARIABLE (int):
            Instance specific constant

        ELTREPPOINTSNORMALS (int):
            Instance specific constant

        ELTREPRESENTATION (int):
            Instance specific constant

        ELTSHRINKFACTOR (int):
            Instance specific constant

        EMISSIVE_COMPONENT (int):
            Instance specific constant

        EMITATCURRENTTIME (int):
            Instance specific constant

        EMITTERS (int):
            Instance specific constant

        ENDPOINT (int):
            Instance specific constant

        ENDSIMTIME (int):
            Instance specific constant

        ENSHELL_LOG (int):
            Instance specific constant

        ENSJLC_DR_EPILOGUE (int):
            Instance specific constant

        ENSJLC_DR_NAME (int):
            Instance specific constant

        ENSJLC_DR_PROLOGUE (int):
            Instance specific constant

        ENSJLC_HUB_EPILOGUE (int):
            Instance specific constant

        ENSJLC_HUB_NAME (int):
            Instance specific constant

        ENSJLC_HUB_PROLOGUE (int):
            Instance specific constant

        ENSJLC_SERVER_EPILOGUE (int):
            Instance specific constant

        ENSJLC_SERVER_NAME (int):
            Instance specific constant

        ENSJLC_SERVER_PROLOGUE (int):
            Instance specific constant

        ENSJLC_SOS_EPILOGUE (int):
            Instance specific constant

        ENSJLC_SOS_NAME (int):
            Instance specific constant

        ENSJLC_SOS_PROLOGUE (int):
            Instance specific constant

        ENSMODEL_FLUSH_ALL (int):
            Instance specific constant

        ENSMODEL_FLUSH_FEATURES (int):
            Instance specific constant

        ENSMODEL_FLUSH_MODELS (int):
            Instance specific constant

        ENSMODEL_FLUSH_NONE (int):
            Instance specific constant

        ENSMODEL_SHOW_ANNOTS (int):
            Instance specific constant

        ENSMODEL_SHOW_ANY (int):
            Instance specific constant

        ENSMODEL_SHOW_CALCTOOLS (int):
            Instance specific constant

        ENSMODEL_SHOW_CASES (int):
            Instance specific constant

        ENSMODEL_SHOW_FRAMES (int):
            Instance specific constant

        ENSMODEL_SHOW_NONE (int):
            Instance specific constant

        ENSMODEL_SHOW_PLOTTERS (int):
            Instance specific constant

        ENSMODEL_SHOW_QUERIES (int):
            Instance specific constant

        ENSMODEL_SHOW_VARS (int):
            Instance specific constant

        ENSMODEL_SHOW_VIEWPORTS (int):
            Instance specific constant

        ENSMODEL_UPDATE_ATTR_UPDATE (int):
            Instance specific constant

        ENSMODEL_UPDATE_CTOR (int):
            Instance specific constant

        ENSMODEL_UPDATE_DTOR (int):
            Instance specific constant

        ENSMODEL_UPDATE_SELECTION (int):
            Instance specific constant

        ENSMODEL_UPDATE_SELECTION_FED (int):
            Instance specific constant

        ENS_ATTR_EMITTERLIST (int):
            Instance specific constant

        ENS_ATTR_ENSLEGENDOBJ (int):
            Instance specific constant

        ENS_ATTR_ENSPARTOBJ (int):
            Instance specific constant

        ENS_ATTR_ENSPLOTOBJ (int):
            Instance specific constant

        ENS_ATTR_ENSVARCOMP (int):
            Instance specific constant

        ENS_ATTR_ENSVAROBJ (int):
            Instance specific constant

        ENS_ATTR_MATRIX44 (int):
            Instance specific constant

        ENS_ATTR_METADATATYPE (int):
            Instance specific constant

        ENS_ATTR_METATAG_BASE (int):
            Instance specific constant

        ENS_ATTR_OBJECT_DTOR (int):
            Instance specific constant

        ENS_ATTR_PALETTEOBJ (int):
            Instance specific constant

        ENS_ATTR_PYDICTIONARY (int):
            Instance specific constant

        ENS_ATTR_PYDICTLIST (int):
            Instance specific constant

        ENS_ATTR_PYOBJECT (int):
            Instance specific constant

        ENS_ATTR_QUATERNION (int):
            Instance specific constant

        ENS_ATTR_SOURCEOBJ (int):
            Instance specific constant

        ENS_ATTR_STATEOBJ (int):
            Instance specific constant

        ENS_ATTR_TEXTUREOBJ (int):
            Instance specific constant

        ENS_ATTR_USERDEF_BASE (int):
            Instance specific constant

        ENS_ATTR_VAR_CONST (int):
            Instance specific constant

        ENS_ATTR_VAR_CONST_PER_PART (int):
            Instance specific constant

        ENS_ATTR_VAR_COORD (int):
            Instance specific constant

        ENS_ATTR_VAR_ELEM (int):
            Instance specific constant

        ENS_ATTR_VAR_FILTER (int):
            Instance specific constant

        ENS_ATTR_VAR_MODEL (int):
            Instance specific constant

        ENS_ATTR_VAR_NODE (int):
            Instance specific constant

        ENS_ATTR_VAR_NONE_ILLEGAL (int):
            Instance specific constant

        ENS_ATTR_VAR_SCALAR (int):
            Instance specific constant

        ENS_ATTR_VAR_SCLCOMPLEX (int):
            Instance specific constant

        ENS_ATTR_VAR_TENSOR (int):
            Instance specific constant

        ENS_ATTR_VAR_TIME (int):
            Instance specific constant

        ENS_ATTR_VAR_VCTCOMPLEX (int):
            Instance specific constant

        ENS_ATTR_VAR_VECTOR (int):
            Instance specific constant

        ENS_DEFPATH_CMDPLY (int):
            Instance specific constant

        ENS_DEFPATH_CMDREC (int):
            Instance specific constant

        ENS_DEFPATH_GBLMACRO (int):
            Instance specific constant

        ENS_DEFPATH_IMAGE (int):
            Instance specific constant

        ENS_DEFPATH_LCLMACRO (int):
            Instance specific constant

        ENS_DEFPATH_MISC (int):
            Instance specific constant

        ENS_DEFPATH_PYEDIT (int):
            Instance specific constant

        ENS_DEFPATH_REMOTE (int):
            Instance specific constant

        ENS_DEFPATH_SCENARIO (int):
            Instance specific constant

        ENS_DEFPATH_TEXTURE (int):
            Instance specific constant

        ENS_DEFPATH_VIDEO (int):
            Instance specific constant

        ENS_DETAILS (int):
            Instance specific constant

        ENS_FEATURE_ACTIONBAR (int):
            Instance specific constant

        ENS_FEATURE_FDEWIDGET (int):
            Instance specific constant

        ENS_FEATURE_FEATUREBAR (int):
            Instance specific constant

        ENS_KIND (int):
            Instance specific constant

        ENS_MAINWIN (int):
            Instance specific constant

        ENS_MAINWINMENUS (int):
            Instance specific constant

        ENS_MATERIAL (int):
            Instance specific constant

        ENS_PANELPARENT (int):
            Instance specific constant

        ENS_PARENT_PART (int):
            Instance specific constant

        ENS_PLIST_KEY_SEL_0 (int):
            Instance specific constant

        ENS_PLIST_KEY_SEL_1 (int):
            Instance specific constant

        ENS_PLIST_KEY_SEL_2 (int):
            Instance specific constant

        ENS_PLIST_KEY_SEL_3 (int):
            Instance specific constant

        ENS_PLIST_KEY_SEL_4 (int):
            Instance specific constant

        ENS_PLIST_KEY_SEL_5 (int):
            Instance specific constant

        ENS_PLIST_KEY_SEL_6 (int):
            Instance specific constant

        ENS_PLIST_KEY_SEL_7 (int):
            Instance specific constant

        ENS_PLIST_KEY_SEL_8 (int):
            Instance specific constant

        ENS_PLIST_KEY_SEL_9 (int):
            Instance specific constant

        ENS_SYMMETRY_AXIS (int):
            Instance specific constant

        ENS_SYMMETRY_COUNT (int):
            Instance specific constant

        ENS_TURBO_ANNO (int):
            Instance specific constant

        ENS_TURBO_STAGE (int):
            Instance specific constant

        ENS_TURBO_VDIM (int):
            Instance specific constant

        ENS_TURBO_VIEW (int):
            Instance specific constant

        ENS_TURBO_VPORT (int):
            Instance specific constant

        ENS_UNITS_DIMS (int):
            Instance specific constant

        ENS_UNITS_LABEL (int):
            Instance specific constant

        ENS_UNITS_SYSTEM_NAME (int):
            Instance specific constant

        ENS_VAR_CASE (int):
            Instance specific constant

        ENS_VAR_CONSTANT (int):
            Instance specific constant

        ENS_VAR_CONSTANT_PER_PART (int):
            Instance specific constant

        ENS_VAR_COORDS (int):
            Instance specific constant

        ENS_VAR_ELEM (int):
            Instance specific constant

        ENS_VAR_ENOD (int):
            Instance specific constant

        ENS_VAR_NODE (int):
            Instance specific constant

        ENS_VAR_SCALAR (int):
            Instance specific constant

        ENS_VAR_SCALAR_COMPLEX (int):
            Instance specific constant

        ENS_VAR_TENSOR (int):
            Instance specific constant

        ENS_VAR_TIME_FUNC (int):
            Instance specific constant

        ENS_VAR_UNKNOWN (int):
            Instance specific constant

        ENS_VAR_VECTOR (int):
            Instance specific constant

        ENS_VAR_VECTOR_COMPLEX (int):
            Instance specific constant

        ENTHALPY (int):
            Instance specific constant

        ENTITYLABELELT (int):
            Instance specific constant

        ENTITYLABELNODE (int):
            Instance specific constant

        ENVMAP_SAVEDINFO (int):
            Instance specific constant

        EPSILON (int):
            Instance specific constant

        EQUATION (int):
            Instance specific constant

        EXIST_CASE (int):
            Instance specific constant

        EXPRESSION (int):
            Instance specific constant

        EXTENTS (int):
            Instance specific constant

        E_FORMAT (int):
            Instance specific constant

        FACEAREAFRACTION (int):
            Instance specific constant

        FACEXMAXGRID (int):
            Instance specific constant

        FACEXMAXGRIDFILTER (int):
            Instance specific constant

        FACEXMAXSUBGRID (int):
            Instance specific constant

        FACEXMINGRID (int):
            Instance specific constant

        FACEXMINGRIDFILTER (int):
            Instance specific constant

        FACEXMINSUBGRID (int):
            Instance specific constant

        FACEYMAXGRID (int):
            Instance specific constant

        FACEYMAXGRIDFILTER (int):
            Instance specific constant

        FACEYMAXSUBGRID (int):
            Instance specific constant

        FACEYMINGRID (int):
            Instance specific constant

        FACEYMINGRIDFILTER (int):
            Instance specific constant

        FACEYMINSUBGRID (int):
            Instance specific constant

        FACEZMAXGRID (int):
            Instance specific constant

        FACEZMAXGRIDFILTER (int):
            Instance specific constant

        FACEZMAXSUBGRID (int):
            Instance specific constant

        FACEZMINGRID (int):
            Instance specific constant

        FACEZMINGRIDFILTER (int):
            Instance specific constant

        FACEZMINSUBGRID (int):
            Instance specific constant

        FALSE (int):
            Instance specific constant

        FASTDISPLAY (int):
            Instance specific constant

        FEATURE_ANGLE (int):
            Instance specific constant

        FEATURE_FULL (int):
            Instance specific constant

        FEA_VAR (int):
            Instance specific constant

        FILENAME (int):
            Instance specific constant

        FILL (int):
            Instance specific constant

        FILLPATTERN (int):
            Instance specific constant

        FLIPBOOKS (int):
            Instance specific constant

        FLOATINGZCLIP (int):
            Instance specific constant

        FLOW3DINFO (int):
            Instance specific constant

        FLUENTTEXTUREAXIS (int):
            Instance specific constant

        FLUENTTEXTUREROTANGLE (int):
            Instance specific constant

        FLUENTTEXTURESCALE (int):
            Instance specific constant

        FNC_BAND (int):
            Instance specific constant

        FNC_CONST (int):
            Instance specific constant

        FNC_CONTIN (int):
            Instance specific constant

        FNC_LIMCOL (int):
            Instance specific constant

        FNC_LIMVIS (int):
            Instance specific constant

        FNC_LINEAR (int):
            Instance specific constant

        FNC_LOG (int):
            Instance specific constant

        FNC_NOLIMIT (int):
            Instance specific constant

        FNC_QUAD (int):
            Instance specific constant

        FONTFAMILIES (int):
            Instance specific constant

        FORMAT (int):
            Instance specific constant

        FRAMES (int):
            Instance specific constant

        FRAME_DURATION (int):
            Instance specific constant

        FRST_ARRW (int):
            Instance specific constant

        FULL (int):
            Instance specific constant

        FULLSCREEN (int):
            Instance specific constant

        FX_SEPNATT_PARALLEL_VECTOR (int):
            Instance specific constant

        FX_SEPNATT_PHASE_PLANE (int):
            Instance specific constant

        FX_SHOCK_REGION (int):
            Instance specific constant

        FX_SHOCK_SURFACE (int):
            Instance specific constant

        FX_VCORE_EIGENANALYSIS (int):
            Instance specific constant

        FX_VCORE_VORTICITY (int):
            Instance specific constant

        F_FORMAT (int):
            Instance specific constant

        GASCONSTANT (int):
            Instance specific constant

        GENERATEOVER (int):
            Instance specific constant

        GENERATION_PENDING (int):
            Instance specific constant

        GEOMETRICTYPE (int):
            Instance specific constant

        GEOMETRY_FORM (int):
            Instance specific constant

        GEOMS (int):
            Instance specific constant

        GEOM_CONN_CHANGE (int):
            Instance specific constant

        GEOM_COORD_CHANGE (int):
            Instance specific constant

        GEOM_NO_CHANGE (int):
            Instance specific constant

        GLASS_MATERIAL (int):
            Instance specific constant

        GLOBALAXISLOCATION (int):
            Instance specific constant

        GLOBALAXISVISIBLE (int):
            Instance specific constant

        GLOBALAXISXLABEL (int):
            Instance specific constant

        GLOBALAXISYLABEL (int):
            Instance specific constant

        GLOBALAXISZLABEL (int):
            Instance specific constant

        GRIDLINETYPE (int):
            Instance specific constant

        GRIDLINEWIDTH (int):
            Instance specific constant

        GRIDPTS (int):
            Instance specific constant

        GRIDRGB (int):
            Instance specific constant

        GROUND_ACTIVE (int):
            Instance specific constant

        GROUND_BLENDSCALE (int):
            Instance specific constant

        GROUND_COLOR (int):
            Instance specific constant

        GROUND_GRIDCOLORA (int):
            Instance specific constant

        GROUND_GRIDCOLORB (int):
            Instance specific constant

        GROUND_GRIDSCALE (int):
            Instance specific constant

        GROUND_HASGRID (int):
            Instance specific constant

        GROUND_HASREFL (int):
            Instance specific constant

        GROUND_HASSHADOW (int):
            Instance specific constant

        GROUND_HASTEXTURE (int):
            Instance specific constant

        GROUND_HEIGHTOFFSET (int):
            Instance specific constant

        GROUND_LOCK (int):
            Instance specific constant

        GROUND_SAVEDINFO (int):
            Instance specific constant

        GROUND_TEXSCALE (int):
            Instance specific constant

        GROUND_UPDIR (int):
            Instance specific constant

        GROUPS (int):
            Instance specific constant

        GRPC_UDS_PATHNAME (int):
            Instance specific constant

        GRP_COLLAPSE (int):
            Instance specific constant

        GRP_EXPAND (int):
            Instance specific constant

        HANDLES_ENABLED (int):
            Instance specific constant

        HANDLE_UNDEFINED_VALUE (int):
            Instance specific constant

        HAS0DELEMENTS (int):
            Instance specific constant

        HAS1DELEMENTS (int):
            Instance specific constant

        HAS2DELEMENTS (int):
            Instance specific constant

        HAS3DELEMENTS (int):
            Instance specific constant

        HASTRANSPARENT (int):
            Instance specific constant

        HEADDETAIL (int):
            Instance specific constant

        HEADSCALE (int):
            Instance specific constant

        HEADSIZEBY (int):
            Instance specific constant

        HEADTYPE (int):
            Instance specific constant

        HEADVARIABLE (int):
            Instance specific constant

        HEIGHT (int):
            Instance specific constant

        HIDDENLINE (int):
            Instance specific constant

        HIDDENLINE_RGB (int):
            Instance specific constant

        HIDDENLINE_USE_RGB (int):
            Instance specific constant

        HIDDENLINE_WEIGHT (int):
            Instance specific constant

        HIDDENSURFACE (int):
            Instance specific constant

        HILITE_BACK_COLOR_FILL (int):
            Instance specific constant

        HILITE_METHOD (int):
            Instance specific constant

        HILITE_SELECT_COLOR (int):
            Instance specific constant

        HILITE_SELECT_COLOR_FILL (int):
            Instance specific constant

        HILITE_TARGET_COLOR (int):
            Instance specific constant

        HILITE_TARGET_COLOR_FILL (int):
            Instance specific constant

        HISTO_SCALE (int):
            Instance specific constant

        HTML (int):
            Instance specific constant

        ICON_SIZE (int):
            Instance specific constant

        ID (int):
            Instance specific constant

        IJK (int):
            Instance specific constant

        IJKAXIS (int):
            Instance specific constant

        IJKAXISSCALE (int):
            Instance specific constant

        IJKSCALE (int):
            Instance specific constant

        IMAGE (int):
            Instance specific constant

        INDEX (int):
            Instance specific constant

        INPLANE1 (int):
            Instance specific constant

        INPLANE2 (int):
            Instance specific constant

        INPLANE3 (int):
            Instance specific constant

        INTENSITY (int):
            Instance specific constant

        INTERACTIVEAUTODELTA (int):
            Instance specific constant

        INTERACTIVERANGEMAX (int):
            Instance specific constant

        INTERACTIVERANGEMIN (int):
            Instance specific constant

        INTERACTIVESTEP (int):
            Instance specific constant

        INTERACTIVEXMAX (int):
            Instance specific constant

        INTERACTIVEXMIN (int):
            Instance specific constant

        INTERACTIVEYMAX (int):
            Instance specific constant

        INTERACTIVEYMIN (int):
            Instance specific constant

        INTERACTIVEZMAX (int):
            Instance specific constant

        INTERACTIVEZMIN (int):
            Instance specific constant

        INTERP (int):
            Instance specific constant

        INT_QUERY_ELEMID (int):
            Instance specific constant

        INT_QUERY_EXACT (int):
            Instance specific constant

        INT_QUERY_IJK (int):
            Instance specific constant

        INT_QUERY_MAX (int):
            Instance specific constant

        INT_QUERY_MIN (int):
            Instance specific constant

        INT_QUERY_NODE (int):
            Instance specific constant

        INT_QUERY_NODEID (int):
            Instance specific constant

        INT_QUERY_NONE (int):
            Instance specific constant

        INT_QUERY_POINT (int):
            Instance specific constant

        INT_QUERY_SURFACE (int):
            Instance specific constant

        INT_QUERY_XYZ (int):
            Instance specific constant

        ISGROUP (int):
            Instance specific constant

        ISO_SURF_SOLID (int):
            Instance specific constant

        ISO_SURF_SURFACE (int):
            Instance specific constant

        JLCS (int):
            Instance specific constant

        JOBINFO (int):
            Instance specific constant

        JUSTIFICATION (int):
            Instance specific constant

        KEYFRAMEDATA (int):
            Instance specific constant

        LABELALWAYSONTOP (int):
            Instance specific constant

        LABELAUTOVISIBLE (int):
            Instance specific constant

        LABELCOUNT (int):
            Instance specific constant

        LABELCUSTOMVISIBLE (int):
            Instance specific constant

        LABELDECIMALPLACES (int):
            Instance specific constant

        LABELFORMAT (int):
            Instance specific constant

        LABELOFFSET (int):
            Instance specific constant

        LABELORIENTATION (int):
            Instance specific constant

        LABELRGB (int):
            Instance specific constant

        LABELSIZE (int):
            Instance specific constant

        LABELSIZE2D (int):
            Instance specific constant

        LABELSIZE3D (int):
            Instance specific constant

        LABELSPACING (int):
            Instance specific constant

        LABELTEXT (int):
            Instance specific constant

        LABELTEXTID (int):
            Instance specific constant

        LABELVISIBLE (int):
            Instance specific constant

        LANGUAGE_INFO (int):
            Instance specific constant

        LAST_DATA_RELOAD (int):
            Instance specific constant

        LEGEND (int):
            Instance specific constant

        LEGENDCOLORBY (int):
            Instance specific constant

        LEGENDMINMAXORIGINX (int):
            Instance specific constant

        LEGENDMINMAXORIGINY (int):
            Instance specific constant

        LEGENDMINMAXTEXTSIZE (int):
            Instance specific constant

        LEGENDMINMAXVISIBLE (int):
            Instance specific constant

        LEGENDORIGINX (int):
            Instance specific constant

        LEGENDORIGINY (int):
            Instance specific constant

        LEGENDRGB (int):
            Instance specific constant

        LEGENDTEXTSIZE (int):
            Instance specific constant

        LEGENDTITLE (int):
            Instance specific constant

        LEGENDTYPE (int):
            Instance specific constant

        LEGENDVISIBLE (int):
            Instance specific constant

        LEGEND_CONT (int):
            Instance specific constant

        LEGEND_DISC (int):
            Instance specific constant

        LEGEND_LEFT (int):
            Instance specific constant

        LEGEND_RIGHT (int):
            Instance specific constant

        LEGEND_TITLE_BOTTOM (int):
            Instance specific constant

        LEGEND_TITLE_TOP (int):
            Instance specific constant

        LEGEND_TITLE_VISOFF (int):
            Instance specific constant

        LEGEND_TXT_VISOFF (int):
            Instance specific constant

        LENGTH (int):
            Instance specific constant

        LENS (int):
            Instance specific constant

        LEVELRGB (int):
            Instance specific constant

        LEVELS (int):
            Instance specific constant

        LEVELSVISIBLE (int):
            Instance specific constant

        LEVELS_AND_COLORS (int):
            Instance specific constant

        LEVELS_LOCK (int):
            Instance specific constant

        LIGHT1AZIMUTH (int):
            Instance specific constant

        LIGHT1ELEVATION (int):
            Instance specific constant

        LIGHT1POSITION (int):
            Instance specific constant

        LIGHT2INTENSITY (int):
            Instance specific constant

        LIGHTAMBIENT (int):
            Instance specific constant

        LIGHTDIFF (int):
            Instance specific constant

        LIGHTDIFFUSE (int):
            Instance specific constant

        LIGHTEMISSIVE (int):
            Instance specific constant

        LIGHTHINT (int):
            Instance specific constant

        LIGHTREFRACTION (int):
            Instance specific constant

        LIGHTSHIN (int):
            Instance specific constant

        LIGHTSOURCES (int):
            Instance specific constant

        LIGHTSPECULARINTENSITY (int):
            Instance specific constant

        LIGHTSPECULARREFLECTION (int):
            Instance specific constant

        LIGHTSPECULARSHINE (int):
            Instance specific constant

        LIGHTSPECULARTINT (int):
            Instance specific constant

        LIGHT_AREA_ENV (int):
            Instance specific constant

        LIGHT_AREA_QUAD (int):
            Instance specific constant

        LIGHT_AT_CAMERA (int):
            Instance specific constant

        LIGHT_DIRECTIONAL (int):
            Instance specific constant

        LIGHT_ENV_TEXNUM (int):
            Instance specific constant

        LIGHT_POINT (int):
            Instance specific constant

        LIGHT_QUAD_SIZE (int):
            Instance specific constant

        LIGHT_QUAD_XDIR (int):
            Instance specific constant

        LIGHT_SOURCE_ABSOLUTE (int):
            Instance specific constant

        LIGHT_SOURCE_RELATIVE (int):
            Instance specific constant

        LIGHT_SPOT (int):
            Instance specific constant

        LIGHT_TYPE (int):
            Instance specific constant

        LIMITFRINGES (int):
            Instance specific constant

        LIMIT_FRINGES (int):
            Instance specific constant

        LINES (int):
            Instance specific constant

        LINESTYLE (int):
            Instance specific constant

        LINETYPE (int):
            Instance specific constant

        LINEWIDTH (int):
            Instance specific constant

        LINEWIDTHBY (int):
            Instance specific constant

        LINE_DOTDSH (int):
            Instance specific constant

        LINE_DOTTED (int):
            Instance specific constant

        LINE_SOLID (int):
            Instance specific constant

        LINKED (int):
            Instance specific constant

        LINK_GROUP1 (int):
            Instance specific constant

        LITTLEHAND (int):
            Instance specific constant

        LITTLEHANDRANGE (int):
            Instance specific constant

        LITTLEHANDRGB (int):
            Instance specific constant

        LOCATION (int):
            Instance specific constant

        LOCATIONX (int):
            Instance specific constant

        LOCATIONX1 (int):
            Instance specific constant

        LOCATIONX2 (int):
            Instance specific constant

        LOCATIONY (int):
            Instance specific constant

        LOCATIONY1 (int):
            Instance specific constant

        LOCATIONY2 (int):
            Instance specific constant

        LOCK_DIRECTION (int):
            Instance specific constant

        LOGO_DATA (int):
            Instance specific constant

        LOOKATPOINT (int):
            Instance specific constant

        LOOKAT_NODE_ID (int):
            Instance specific constant

        LOOKAT_OPTION (int):
            Instance specific constant

        LOOKAT_PART_ID (int):
            Instance specific constant

        LOOKAT_SPLINE_ID (int):
            Instance specific constant

        LOOKAT_SPLINE_VALUE (int):
            Instance specific constant

        LOOKAT_XYZ (int):
            Instance specific constant

        LOOKFROMPOINT (int):
            Instance specific constant

        LPARTNUMELE (int):
            Instance specific constant

        LPARTPARENT (int):
            Instance specific constant

        LPARTS (int):
            Instance specific constant

        LPARTS_OFF (int):
            Instance specific constant

        LPARTS_ON (int):
            Instance specific constant

        LPARTS_SELECTIVE (int):
            Instance specific constant

        MACH (int):
            Instance specific constant

        MACHINEARCH (int):
            Instance specific constant

        MARKER (int):
            Instance specific constant

        MARKERRGB (int):
            Instance specific constant

        MARKERSCALE (int):
            Instance specific constant

        MARKERSIZENORMALIZED (int):
            Instance specific constant

        MARKERVISIBLE (int):
            Instance specific constant

        MARKER_COLOR (int):
            Instance specific constant

        MARKER_CROSS (int):
            Instance specific constant

        MARKER_DOT (int):
            Instance specific constant

        MARKER_SCREENSPACE_SURFACE (int):
            Instance specific constant

        MARKER_SIZE_CONSTANT (int):
            Instance specific constant

        MARKER_SIZE_SCALAR (int):
            Instance specific constant

        MARKER_SIZE_VECMAG (int):
            Instance specific constant

        MARKER_SIZE_VECXCOMP (int):
            Instance specific constant

        MARKER_SIZE_VECYCOMP (int):
            Instance specific constant

        MARKER_SIZE_VECZCOMP (int):
            Instance specific constant

        MARKER_SPHER (int):
            Instance specific constant

        MARKER_USER_DEFINED (int):
            Instance specific constant

        MARKER_WIDTH (int):
            Instance specific constant

        MASSEDBALLISTICCOEF (int):
            Instance specific constant

        MASSEDBUOYANCY (int):
            Instance specific constant

        MASSEDCOEFFRICTION (int):
            Instance specific constant

        MASSEDCOEFRESTITUTION (int):
            Instance specific constant

        MASSEDDRAG (int):
            Instance specific constant

        MASSEDDRAGCOEFFICIENT (int):
            Instance specific constant

        MASSEDDRAGCOEFFICIENTVAL (int):
            Instance specific constant

        MASSEDFLUIDDENSITY (int):
            Instance specific constant

        MASSEDFLUIDDENSITYVAL (int):
            Instance specific constant

        MASSEDFLUIDVISCOSITY (int):
            Instance specific constant

        MASSEDFLUIDVISCOSITYVAL (int):
            Instance specific constant

        MASSEDGRAVITY (int):
            Instance specific constant

        MASSEDGRAVITYVECTOR (int):
            Instance specific constant

        MASSEDINITIALUSEFLUID (int):
            Instance specific constant

        MASSEDINITIALVELOCITY (int):
            Instance specific constant

        MASSEDPARTICLEDENSITY (int):
            Instance specific constant

        MASSEDPARTICLEDIAMETER (int):
            Instance specific constant

        MASSEDPARTICLES (int):
            Instance specific constant

        MASSEDPRESSURE (int):
            Instance specific constant

        MASSEDPRESSUREGRADIENT (int):
            Instance specific constant

        MASSEDREBOUND (int):
            Instance specific constant

        MASSEDREBOUNDFRACTION (int):
            Instance specific constant

        MASSEDREBOUNDWALLHITS (int):
            Instance specific constant

        MASSEDUSEBALLISTIC (int):
            Instance specific constant

        MATERIALBASETYPE (int):
            Instance specific constant

        MATERIALDESCRIPTION (int):
            Instance specific constant

        MATERIALS (int):
            Instance specific constant

        MATRIX (int):
            Instance specific constant

        MATTE_MATERIAL (int):
            Instance specific constant

        MAX (int):
            Instance specific constant

        MAXANGLE (int):
            Instance specific constant

        MAXIMUM (int):
            Instance specific constant

        MAXTIME (int):
            Instance specific constant

        MAX_MARKERS (int):
            Instance specific constant

        MAX_TRACK (int):
            Instance specific constant

        MESHPLANE (int):
            Instance specific constant

        MESHPLANEIJK (int):
            Instance specific constant

        MESHPLANERTZ (int):
            Instance specific constant

        MESHPLANEXYZ (int):
            Instance specific constant

        MESHRESOLUTION (int):
            Instance specific constant

        MESHTYPE (int):
            Instance specific constant

        MESH_2D (int):
            Instance specific constant

        MESH_2D_X (int):
            Instance specific constant

        MESH_2D_Y (int):
            Instance specific constant

        MESH_2D_Z (int):
            Instance specific constant

        MESH_3D (int):
            Instance specific constant

        MESH_LINE (int):
            Instance specific constant

        MESH_NONE (int):
            Instance specific constant

        MESH_SLICEI (int):
            Instance specific constant

        MESH_SLICEJ (int):
            Instance specific constant

        MESH_SLICEK (int):
            Instance specific constant

        MESH_SLICE_RTZ_R (int):
            Instance specific constant

        MESH_SLICE_RTZ_T (int):
            Instance specific constant

        MESH_SLICE_RTZ_Z (int):
            Instance specific constant

        MESH_SLICE_X (int):
            Instance specific constant

        MESH_SLICE_Y (int):
            Instance specific constant

        MESH_SLICE_Z (int):
            Instance specific constant

        MESH_TRIS (int):
            Instance specific constant

        METADATA (int):
            Instance specific constant

        METALLICPAINT_MATERIAL (int):
            Instance specific constant

        METAL_MATERIAL (int):
            Instance specific constant

        METHOD (int):
            Instance specific constant

        MFNTS_JUMP_TO_END (int):
            Instance specific constant

        MFNTS_OFF (int):
            Instance specific constant

        MFNTS_STAY_AT_CURRENT (int):
            Instance specific constant

        MIN (int):
            Instance specific constant

        MINANGLE (int):
            Instance specific constant

        MINIMUM (int):
            Instance specific constant

        MINMAX (int):
            Instance specific constant

        MINMAXCONST (int):
            Instance specific constant

        MINSTEPS (int):
            Instance specific constant

        MIN_TRACK (int):
            Instance specific constant

        MIRRORORIGINAL (int):
            Instance specific constant

        MIRROR_MATERIAL (int):
            Instance specific constant

        MI_ALG_SMOOTH (int):
            Instance specific constant

        MI_ALG_YOUNGS (int):
            Instance specific constant

        MI_TYPE_DOMAIN (int):
            Instance specific constant

        MI_TYPE_INTERFACE (int):
            Instance specific constant

        MODEL_RECORD_CMD_LANG_GLOBAL (int):
            Instance specific constant

        MODEL_RECORD_CMD_LANG_HONOR (int):
            Instance specific constant

        MODEL_RECORD_CMD_LANG_OFF (int):
            Instance specific constant

        MODEL_RECORD_CMD_LANG_ON (int):
            Instance specific constant

        MOMENTUM (int):
            Instance specific constant

        MOUSE_ACTION_NONE (int):
            Instance specific constant

        MOUSE_BTN_ALL (int):
            Instance specific constant

        MOUSE_BTN_LEFT (int):
            Instance specific constant

        MOUSE_BTN_LEFT_MIDDLE (int):
            Instance specific constant

        MOUSE_BTN_LEFT_RIGHT (int):
            Instance specific constant

        MOUSE_BTN_MIDDLE (int):
            Instance specific constant

        MOUSE_BTN_RIGHT (int):
            Instance specific constant

        MOUSE_BTN_RIGHT_MIDDLE (int):
            Instance specific constant

        MOUSE_NORMAL_ACTION (int):
            Instance specific constant

        MOUSE_PICK_ACTION (int):
            Instance specific constant

        MOUSE_PICK_BLANK_ELEMENTS (int):
            Instance specific constant

        MOUSE_PICK_CURSOR (int):
            Instance specific constant

        MOUSE_PICK_PART (int):
            Instance specific constant

        MOUSE_PICK_PART_OPTIONS (int):
            Instance specific constant

        MOUSE_PICK_TRANSFORM_CENTER (int):
            Instance specific constant

        MOUSE_ROTATE (int):
            Instance specific constant

        MOUSE_SELECT_TOOL (int):
            Instance specific constant

        MOUSE_TRANSLATE (int):
            Instance specific constant

        MOUSE_USER_DEFINED (int):
            Instance specific constant

        MOUSE_ZOOM (int):
            Instance specific constant

        MOUSE_ZOOMBAND (int):
            Instance specific constant

        MRU (int):
            Instance specific constant

        MULTIPLEPULSES (int):
            Instance specific constant

        MULTIPLESEGMENTSBY (int):
            Instance specific constant

        NEGATIVE_SURFACE_DIRECTION (int):
            Instance specific constant

        NEG_TIME (int):
            Instance specific constant

        NLEVELS (int):
            Instance specific constant

        NODEDETAIL (int):
            Instance specific constant

        NODEID (int):
            Instance specific constant

        NODEMAX (int):
            Instance specific constant

        NODEMIN (int):
            Instance specific constant

        NODEORIENTATIONANGLE (int):
            Instance specific constant

        NODEORIENTATIONAXIS (int):
            Instance specific constant

        NODERANGESTEPI (int):
            Instance specific constant

        NODERANGESTEPJ (int):
            Instance specific constant

        NODERANGESTEPK (int):
            Instance specific constant

        NODESCALE (int):
            Instance specific constant

        NODESIZEBY (int):
            Instance specific constant

        NODESTEP (int):
            Instance specific constant

        NODETYPE (int):
            Instance specific constant

        NODEVARIABLE (int):
            Instance specific constant

        NODE_LOCK (int):
            Instance specific constant

        NODE_TRACKS (int):
            Instance specific constant

        NORMAL (int):
            Instance specific constant

        NORMALIZEDWIDTH (int):
            Instance specific constant

        NORMALIZEX (int):
            Instance specific constant

        NORMALIZEY (int):
            Instance specific constant

        NORMALSPOINT (int):
            Instance specific constant

        NOTLOAD_FULL (int):
            Instance specific constant

        NOT_LOADED (int):
            Instance specific constant

        NO_ARRW (int):
            Instance specific constant

        NO_TRACKING (int):
            Instance specific constant

        NUMCONTROLPOINTS (int):
            Instance specific constant

        NUMDISPLAYED (int):
            Instance specific constant

        NUMFRAMES (int):
            Instance specific constant

        NUMOFARROWS (int):
            Instance specific constant

        NUMOFLEVELS (int):
            Instance specific constant

        NUMOFSAMPLEPTS (int):
            Instance specific constant

        NUMOFSLICES (int):
            Instance specific constant

        NUMPOINTS (int):
            Instance specific constant

        OBJECTFOCUS (int):
            Instance specific constant

        OBJECT_API_JOURNAL (int):
            Instance specific constant

        OBJECT_DTOR (int):
            Instance specific constant

        OFFSET (int):
            Instance specific constant

        OFFSETFROMPART (int):
            Instance specific constant

        OFFSETSCALE (int):
            Instance specific constant

        OFFSETVECTOR (int):
            Instance specific constant

        ONE (int):
            Instance specific constant

        OPAQUENESS (int):
            Instance specific constant

        OPERATION (int):
            Instance specific constant

        OPERATIONFACTOR1 (int):
            Instance specific constant

        OPERATIONFACTOR2 (int):
            Instance specific constant

        OPERATIONQUERY1BYNAME (int):
            Instance specific constant

        OPERATIONQUERY2BYNAME (int):
            Instance specific constant

        OPTION_NONE (int):
            Instance specific constant

        ORDER (int):
            Instance specific constant

        ORIENTATION (int):
            Instance specific constant

        ORIGIN (int):
            Instance specific constant

        ORIGIN1 (int):
            Instance specific constant

        ORIGIN2 (int):
            Instance specific constant

        ORIGINBY (int):
            Instance specific constant

        ORIGINBY1 (int):
            Instance specific constant

        ORIGINBY2 (int):
            Instance specific constant

        ORIGINBYPARTCENTROID (int):
            Instance specific constant

        ORIGINFRAME (int):
            Instance specific constant

        ORIGINX (int):
            Instance specific constant

        ORIGINY (int):
            Instance specific constant

        ORIGIN_NODE_ID (int):
            Instance specific constant

        ORIGIN_OPTION (int):
            Instance specific constant

        ORIGIN_PART_ID (int):
            Instance specific constant

        ORIGIN_SPLINE_ID (int):
            Instance specific constant

        ORIGIN_SPLINE_VALUE (int):
            Instance specific constant

        ORIGIN_XYZ_DELTA (int):
            Instance specific constant

        OVERRIDEGTACTIVE (int):
            Instance specific constant

        OVERRIDEGTMIN (int):
            Instance specific constant

        OVERRIDEGTRGB (int):
            Instance specific constant

        OVERRIDEGTUSEABS (int):
            Instance specific constant

        OVERRIDELTACTIVE (int):
            Instance specific constant

        OVERRIDELTMIN (int):
            Instance specific constant

        OVERRIDELTRGB (int):
            Instance specific constant

        OVERRIDELTUSEABS (int):
            Instance specific constant

        OVERRIDERANGEACTIVE (int):
            Instance specific constant

        OVERRIDERANGEMAX (int):
            Instance specific constant

        OVERRIDERANGEMIN (int):
            Instance specific constant

        OVERRIDERANGERGB (int):
            Instance specific constant

        OVERRIDERANGEUSEABS (int):
            Instance specific constant

        PAGE_DETAILS (int):
            Instance specific constant

        PALETTE (int):
            Instance specific constant

        PALETTES (int):
            Instance specific constant

        PALETTE_ALPHA_BY_COLOR_PALETTE (int):
            Instance specific constant

        PALETTE_ALPHA_NONE (int):
            Instance specific constant

        PALETTE_BANDED (int):
            Instance specific constant

        PALETTE_CONSTANT (int):
            Instance specific constant

        PALETTE_CONTINUOUS (int):
            Instance specific constant

        PALETTE_HSV (int):
            Instance specific constant

        PALETTE_LIMIT_FRINGES_INVISIBLE (int):
            Instance specific constant

        PALETTE_LIMIT_FRINGES_NO (int):
            Instance specific constant

        PALETTE_LIMIT_FRINGES_PART_COLOR (int):
            Instance specific constant

        PALETTE_LINEAR (int):
            Instance specific constant

        PALETTE_NODE_LOCK_ALL (int):
            Instance specific constant

        PALETTE_NODE_LOCK_COLOR (int):
            Instance specific constant

        PALETTE_NODE_LOCK_NONE (int):
            Instance specific constant

        PALETTE_RGB (int):
            Instance specific constant

        PALETTE_SCALE_LINEAR (int):
            Instance specific constant

        PALETTE_SCALE_LOG (int):
            Instance specific constant

        PALETTE_SCALE_QUADRATIC (int):
            Instance specific constant

        PALETTE_SPLINE (int):
            Instance specific constant

        PALETTE_UNDEFINED_AS_ZERO_VALUE (int):
            Instance specific constant

        PALETTE_UNDEFINED_BY_INVISIBLE (int):
            Instance specific constant

        PALETTE_UNDEFINED_BY_PART_COLOR (int):
            Instance specific constant

        PALETTE_UNDEFINED_BY_UNDEF_COLOR (int):
            Instance specific constant

        PALID (int):
            Instance specific constant

        PALMISC (int):
            Instance specific constant

        PARENT (int):
            Instance specific constant

        PARTDELTAVALUE (int):
            Instance specific constant

        PARTHIGHLIGHT (int):
            Instance specific constant

        PARTICLETIME (int):
            Instance specific constant

        PARTID (int):
            Instance specific constant

        PARTMAXVALUE (int):
            Instance specific constant

        PARTMINVALUE (int):
            Instance specific constant

        PARTNUMBER (int):
            Instance specific constant

        PARTNUMELE (int):
            Instance specific constant

        PARTNUMELECLIENT (int):
            Instance specific constant

        PARTS (int):
            Instance specific constant

        PARTTYPE (int):
            Instance specific constant

        PARTTYPEENUM (int):
            Instance specific constant

        PART_AUX_GEOM (int):
            Instance specific constant

        PART_AXI_SYMMETRIC (int):
            Instance specific constant

        PART_BUILT_UP (int):
            Instance specific constant

        PART_CLIP_PLANE (int):
            Instance specific constant

        PART_CONTOUR (int):
            Instance specific constant

        PART_DEVELOPED_SURFACE (int):
            Instance specific constant

        PART_DISCRETE_PARTICLE (int):
            Instance specific constant

        PART_ELEVATED_SURFACE (int):
            Instance specific constant

        PART_FILTER_PART (int):
            Instance specific constant

        PART_FRAME (int):
            Instance specific constant

        PART_FX_SEP_ATT (int):
            Instance specific constant

        PART_FX_SHOCK (int):
            Instance specific constant

        PART_FX_VORTEX_CORE (int):
            Instance specific constant

        PART_ISO_SURFACE (int):
            Instance specific constant

        PART_ISO_VOLUME (int):
            Instance specific constant

        PART_MATERIAL_INTERFACE (int):
            Instance specific constant

        PART_MODEL (int):
            Instance specific constant

        PART_MODEL_BOUNDARY (int):
            Instance specific constant

        PART_MODEL_CUT (int):
            Instance specific constant

        PART_MODEL_EXTRACT (int):
            Instance specific constant

        PART_MODEL_MERGE (int):
            Instance specific constant

        PART_MULT (int):
            Instance specific constant

        PART_PARTICLE_TRACE (int):
            Instance specific constant

        PART_POINT (int):
            Instance specific constant

        PART_PROFILE (int):
            Instance specific constant

        PART_TENSOR_GLYPH (int):
            Instance specific constant

        PART_VECTOR_ARROW (int):
            Instance specific constant

        PART_VOF (int):
            Instance specific constant

        PATHLINE (int):
            Instance specific constant

        PATHLINE_SYNC (int):
            Instance specific constant

        PATHNAME (int):
            Instance specific constant

        PERIODICSECTIONS (int):
            Instance specific constant

        PERSPECTIVE (int):
            Instance specific constant

        PERSPECTIVEANGLE (int):
            Instance specific constant

        PICKANDGO_PARTS (int):
            Instance specific constant

        PICK_SELECTION (int):
            Instance specific constant

        PLASTIC_MATERIAL (int):
            Instance specific constant

        PLAYING_COMMAND_FILE (int):
            Instance specific constant

        PLOTS (int):
            Instance specific constant

        PLOTTER_LEGEND_COLOR_RGB (int):
            Instance specific constant

        PLOTTER_LEGEND_COLOR_USE_CURVE (int):
            Instance specific constant

        PLOTTER_TIME_CLIPPING (int):
            Instance specific constant

        PLOTTITLE (int):
            Instance specific constant

        PLOT_BG_NONE (int):
            Instance specific constant

        PLOT_BG_SOLID (int):
            Instance specific constant

        PL_TYPE_GRID (int):
            Instance specific constant

        PL_TYPE_GRID_FULL (int):
            Instance specific constant

        PL_TYPE_MESH (int):
            Instance specific constant

        POINT1 (int):
            Instance specific constant

        POINT2 (int):
            Instance specific constant

        POINTS (int):
            Instance specific constant

        POINTSIZE (int):
            Instance specific constant

        POINTVISIBLE (int):
            Instance specific constant

        POLYGON_OFFSET (int):
            Instance specific constant

        POLYLINES (int):
            Instance specific constant

        POSITIVE_SURFACE_DIRECTION (int):
            Instance specific constant

        POS_NEG_TIME (int):
            Instance specific constant

        POS_TIME (int):
            Instance specific constant

        PREDEFINEDMATERIAL (int):
            Instance specific constant

        PREDEFINEDPALETTES (int):
            Instance specific constant

        PREF_DATADIR (int):
            Instance specific constant

        PREF_DATAFILEFILTER (int):
            Instance specific constant

        PREF_DATAFORMAT (int):
            Instance specific constant

        PRESETS (int):
            Instance specific constant

        PRESSURE (int):
            Instance specific constant

        PRIVATE (int):
            Instance specific constant

        PROBENUMBER (int):
            Instance specific constant

        PROBES (int):
            Instance specific constant

        PROBE_DATA (int):
            Instance specific constant

        PROJECTION (int):
            Instance specific constant

        PROJECTION_AXIS_MATERIAL (int):
            Instance specific constant

        PROJECTION_AXIS_X (int):
            Instance specific constant

        PROJECTION_AXIS_Y (int):
            Instance specific constant

        PROJECTION_AXIS_Z (int):
            Instance specific constant

        PROJECT_CREATION_MASK (int):
            Instance specific constant

        PROJECT_MASK (int):
            Instance specific constant

        PROJECT_VISIBLE_MASK (int):
            Instance specific constant

        PROJ_M_R (int):
            Instance specific constant

        PROJ_M_THETA (int):
            Instance specific constant

        PROJ_R_Z (int):
            Instance specific constant

        PROJ_THETA_R (int):
            Instance specific constant

        PROJ_THETA_Z (int):
            Instance specific constant

        PULSEINTERVAL (int):
            Instance specific constant

        QRY_ASSIGN_TO_Y_AXIS_AUTO (int):
            Instance specific constant

        QRY_ASSIGN_TO_Y_LEFT (int):
            Instance specific constant

        QRY_ASSIGN_TO_Y_RIGHT (int):
            Instance specific constant

        QRY_CONS_BY_NODE (int):
            Instance specific constant

        QRY_CONS_BY_PART (int):
            Instance specific constant

        QRY_CONS_BY_POINT (int):
            Instance specific constant

        QRY_CONS_ELEM (int):
            Instance specific constant

        QRY_CONS_IJK (int):
            Instance specific constant

        QRY_CONS_LINE_TOOL (int):
            Instance specific constant

        QRY_CONS_MAX_VALUE (int):
            Instance specific constant

        QRY_CONS_MIN_VALUE (int):
            Instance specific constant

        QRY_CONS_NO (int):
            Instance specific constant

        QRY_CONS_NODE (int):
            Instance specific constant

        QRY_CONS_PART (int):
            Instance specific constant

        QRY_CONS_POINT (int):
            Instance specific constant

        QRY_CONS_SCALAR (int):
            Instance specific constant

        QRY_CONS_SCATTER_ON_PART (int):
            Instance specific constant

        QRY_CONS_SPLINE (int):
            Instance specific constant

        QRY_DIST_ALL (int):
            Instance specific constant

        QRY_DIST_ALL_ORIGIN (int):
            Instance specific constant

        QRY_DIST_X (int):
            Instance specific constant

        QRY_DIST_X_ORIGIN (int):
            Instance specific constant

        QRY_DIST_Y (int):
            Instance specific constant

        QRY_DIST_Y_ORIGIN (int):
            Instance specific constant

        QRY_DIST_Z (int):
            Instance specific constant

        QRY_DIST_Z_ORIGIN (int):
            Instance specific constant

        QRY_EXTERNAL (int):
            Instance specific constant

        QRY_FFT (int):
            Instance specific constant

        QRY_GENERATED (int):
            Instance specific constant

        QRY_MSEG_ACCUMU (int):
            Instance specific constant

        QRY_MSEG_RESET (int):
            Instance specific constant

        QRY_OPERATE (int):
            Instance specific constant

        QRY_PART_VS_CONSTANT (int):
            Instance specific constant

        QRY_SCATTER_GEN_OVER_DISTANCE (int):
            Instance specific constant

        QRY_SCATTER_GEN_OVER_TIME (int):
            Instance specific constant

        QRY_VALUE (int):
            Instance specific constant

        QRY_VARIABLE_DIST (int):
            Instance specific constant

        QRY_VARIABLE_TIME (int):
            Instance specific constant

        QRY_VARIABLE_UNKNOWN (int):
            Instance specific constant

        QRY_VARIABLE_VAR (int):
            Instance specific constant

        QUADS (int):
            Instance specific constant

        QUERIES (int):
            Instance specific constant

        QUERY (int):
            Instance specific constant

        QUERYLINETOOLPOINT1 (int):
            Instance specific constant

        QUERYLINETOOLPOINT2 (int):
            Instance specific constant

        QUERYTYPE (int):
            Instance specific constant

        QUERY_DATA (int):
            Instance specific constant

        QUERY_PROBE_DATA (int):
            Instance specific constant

        QY_CMB (int):
            Instance specific constant

        QY_DIF (int):
            Instance specific constant

        QY_DIV (int):
            Instance specific constant

        QY_INT (int):
            Instance specific constant

        QY_MLT (int):
            Instance specific constant

        RADII (int):
            Instance specific constant

        RADIUS (int):
            Instance specific constant

        RADIUS_SCALE (int):
            Instance specific constant

        RANGE (int):
            Instance specific constant

        RATIOOFSPECHEAT (int):
            Instance specific constant

        RAY_END (int):
            Instance specific constant

        REALTIME_AUTO (int):
            Instance specific constant

        REALTIME_AUTO_CYCLE (int):
            Instance specific constant

        REALTIME_CLIPS (int):
            Instance specific constant

        REALTIME_ISOS (int):
            Instance specific constant

        REALTIME_MANUAL (int):
            Instance specific constant

        REALTIME_OFF (int):
            Instance specific constant

        RECORDING (int):
            Instance specific constant

        REDUCEPOLYGONS (int):
            Instance specific constant

        REDUCEPOLYGONSFACTOR (int):
            Instance specific constant

        REFFRAME (int):
            Instance specific constant

        REFLECTIVE_COMPONENT (int):
            Instance specific constant

        REFRACTONINDEX_COMPONENT (int):
            Instance specific constant

        RELATIVETO (int):
            Instance specific constant

        RELATIVEVIEWPORT (int):
            Instance specific constant

        RELATIVEVIEWPORT1 (int):
            Instance specific constant

        RELATIVEVIEWPORT2 (int):
            Instance specific constant

        RELOAD_DATA (int):
            Instance specific constant

        RELOAD_NONE (int):
            Instance specific constant

        RELOAD_PARTS (int):
            Instance specific constant

        RELOAD_QUERIES (int):
            Instance specific constant

        RELOAD_TIME (int):
            Instance specific constant

        RELOAD_VARS (int):
            Instance specific constant

        REMOTEHOST (int):
            Instance specific constant

        RENDERINGREFLECTIONID (int):
            Instance specific constant

        REPRESENTATION (int):
            Instance specific constant

        REQUESTMETHOD (int):
            Instance specific constant

        RESET_RANGE_ON_TIME_CHANGE (int):
            Instance specific constant

        REV1DAXISVECT (int):
            Instance specific constant

        REV1DORIGIN (int):
            Instance specific constant

        REVERSENORMAL (int):
            Instance specific constant

        REVOLVEPART (int):
            Instance specific constant

        REVPOINTDISTANCE1 (int):
            Instance specific constant

        REVPOINTDISTANCE10 (int):
            Instance specific constant

        REVPOINTDISTANCE2 (int):
            Instance specific constant

        REVPOINTDISTANCE3 (int):
            Instance specific constant

        REVPOINTDISTANCE4 (int):
            Instance specific constant

        REVPOINTDISTANCE5 (int):
            Instance specific constant

        REVPOINTDISTANCE6 (int):
            Instance specific constant

        REVPOINTDISTANCE7 (int):
            Instance specific constant

        REVPOINTDISTANCE8 (int):
            Instance specific constant

        REVPOINTDISTANCE9 (int):
            Instance specific constant

        REVPOINTRADII1 (int):
            Instance specific constant

        REVPOINTRADII10 (int):
            Instance specific constant

        REVPOINTRADII2 (int):
            Instance specific constant

        REVPOINTRADII3 (int):
            Instance specific constant

        REVPOINTRADII4 (int):
            Instance specific constant

        REVPOINTRADII5 (int):
            Instance specific constant

        REVPOINTRADII6 (int):
            Instance specific constant

        REVPOINTRADII7 (int):
            Instance specific constant

        REVPOINTRADII8 (int):
            Instance specific constant

        REVPOINTRADII9 (int):
            Instance specific constant

        REVTOOLAXIS (int):
            Instance specific constant

        REVTOOLNUMPTS (int):
            Instance specific constant

        REVTOOLORIGIN (int):
            Instance specific constant

        RGB (int):
            Instance specific constant

        ROP_GTEQ (int):
            Instance specific constant

        ROP_LTEQ (int):
            Instance specific constant

        ROTANGLE (int):
            Instance specific constant

        ROTATION (int):
            Instance specific constant

        ROTATIONALANGLE (int):
            Instance specific constant

        ROT_SYMM_X_AXIS (int):
            Instance specific constant

        ROT_SYMM_Y_AXIS (int):
            Instance specific constant

        ROT_SYMM_Z_AXIS (int):
            Instance specific constant

        RTZAXIS (int):
            Instance specific constant

        SAMPLEBY (int):
            Instance specific constant

        SAMPLEPOINTSLINE (int):
            Instance specific constant

        SAMPLEPOINTSSPLINE (int):
            Instance specific constant

        SAMPLETYPE (int):
            Instance specific constant

        SAMPLEXYZ (int):
            Instance specific constant

        SAMPLE_UNIFORM (int):
            Instance specific constant

        SCALARVALUE (int):
            Instance specific constant

        SCALARVARIABLE (int):
            Instance specific constant

        SCALE (int):
            Instance specific constant

        SCALEBYLOCATIONVALUE (int):
            Instance specific constant

        SCALEFACTOR (int):
            Instance specific constant

        SCALEFACTORU (int):
            Instance specific constant

        SCALEFACTORV (int):
            Instance specific constant

        SCALEMAXFACTOR (int):
            Instance specific constant

        SCALEMAXVALUE (int):
            Instance specific constant

        SCALEMINFACTOR (int):
            Instance specific constant

        SCALEMINVALUE (int):
            Instance specific constant

        SCALE_METHOD (int):
            Instance specific constant

        SCENE (int):
            Instance specific constant

        SCND_ARRW (int):
            Instance specific constant

        SEAMVECTOR (int):
            Instance specific constant

        SEARCH (int):
            Instance specific constant

        SECURITY_TOKEN (int):
            Instance specific constant

        SELECTED (int):
            Instance specific constant

        SELECTIONS (int):
            Instance specific constant

        SEQUENCE (int):
            Instance specific constant

        SERVERBYTESWAP (int):
            Instance specific constant

        SERVERCEIHOME (int):
            Instance specific constant

        SERVERCWD (int):
            Instance specific constant

        SERVERDIR (int):
            Instance specific constant

        SERVERINFO (int):
            Instance specific constant

        SERVERXML (int):
            Instance specific constant

        SETMAXTIME (int):
            Instance specific constant

        SEVEN (int):
            Instance specific constant

        SFTBRIGHTNESS (int):
            Instance specific constant

        SFTCONTRAST (int):
            Instance specific constant

        SFTDENSITY (int):
            Instance specific constant

        SFTINTEGRATIONSTEP (int):
            Instance specific constant

        SFTLENGTH (int):
            Instance specific constant

        SFTNORMALIZE (int):
            Instance specific constant

        SFTNORMINTEGRATIONSTEP (int):
            Instance specific constant

        SFTNORMLENGTH (int):
            Instance specific constant

        SFTVARIABLE (int):
            Instance specific constant

        SHADING (int):
            Instance specific constant

        SHADOWINTENSITY (int):
            Instance specific constant

        SHADOWOFFSET (int):
            Instance specific constant

        SHAD_FLAT (int):
            Instance specific constant

        SHAD_GOURAUD (int):
            Instance specific constant

        SHAD_SMOOTH (int):
            Instance specific constant

        SHAD_SMOOTH_REFINED (int):
            Instance specific constant

        SHINYMETAL_MATERIAL (int):
            Instance specific constant

        SHOWAS (int):
            Instance specific constant

        SHOWBACKGROUND (int):
            Instance specific constant

        SHOWMINMAXMARKER (int):
            Instance specific constant

        SHOWOUTLINE (int):
            Instance specific constant

        SHOWPLANEXMAX (int):
            Instance specific constant

        SHOWPLANEXMIN (int):
            Instance specific constant

        SHOWPLANEYMAX (int):
            Instance specific constant

        SHOWPLANEYMIN (int):
            Instance specific constant

        SHOWPLANEZMAX (int):
            Instance specific constant

        SHOWPLANEZMIN (int):
            Instance specific constant

        SHOWRAYTRACEDIMAGE (int):
            Instance specific constant

        SHOWSFT (int):
            Instance specific constant

        SHOW_LOCATION (int):
            Instance specific constant

        SHP_CONE (int):
            Instance specific constant

        SHP_NONE (int):
            Instance specific constant

        SHP_NORM (int):
            Instance specific constant

        SHP_TIP (int):
            Instance specific constant

        SHP_TRI (int):
            Instance specific constant

        SIDEWALL (int):
            Instance specific constant

        SIZE (int):
            Instance specific constant

        SIZ_FIXED (int):
            Instance specific constant

        SIZ_PROP (int):
            Instance specific constant

        SLIDERRANGEIJK (int):
            Instance specific constant

        SLIDERSTEP (int):
            Instance specific constant

        SLIDERSTEPIJK (int):
            Instance specific constant

        SLIDERX (int):
            Instance specific constant

        SLIDERY (int):
            Instance specific constant

        SLIDERZ (int):
            Instance specific constant

        SLIM_TIMEOUT (int):
            Instance specific constant

        SMOOTHSUBPOINTS (int):
            Instance specific constant

        SNAP_NORM (int):
            Instance specific constant

        SNAP_SURF (int):
            Instance specific constant

        SOLUTIONTIME (int):
            Instance specific constant

        SOLUTIONTIME_LIMITS (int):
            Instance specific constant

        SOLUTIONTIME_MONITOR (int):
            Instance specific constant

        SOURCE (int):
            Instance specific constant

        SOURCES (int):
            Instance specific constant

        SPECIES (int):
            Instance specific constant

        SPECIFYCELLCOMPNUM (int):
            Instance specific constant

        SPECIFYLABELCOUNT (int):
            Instance specific constant

        SPECIFYSYMMETRYORIGIN (int):
            Instance specific constant

        SPECULARSHINE_COMPONENT (int):
            Instance specific constant

        SPECULARTINT_COMPONENT (int):
            Instance specific constant

        SPECULAR_COMPONENT (int):
            Instance specific constant

        SPHERES (int):
            Instance specific constant

        SPHRAXISENDPOINT1 (int):
            Instance specific constant

        SPHRAXISENDPOINT2 (int):
            Instance specific constant

        SPHRAXISVECT (int):
            Instance specific constant

        SPHRORIGIN (int):
            Instance specific constant

        SPHRRADIUS (int):
            Instance specific constant

        SPLINEID (int):
            Instance specific constant

        SPOT_ANGLE (int):
            Instance specific constant

        SPOT_FALLOFF (int):
            Instance specific constant

        STACKING_ORDER (int):
            Instance specific constant

        STAGE_LABEL_BACK_FACES (int):
            Instance specific constant

        STAGE_LABEL_FRONT_AND_BACK_FACES (int):
            Instance specific constant

        STAGE_LABEL_FRONT_FACES (int):
            Instance specific constant

        STAGE_SHOW_STUFF_MAXIMUM (int):
            Instance specific constant

        STAGE_SHOW_STUFF_MINANDMAX (int):
            Instance specific constant

        STAGE_SHOW_STUFF_MINIMUM (int):
            Instance specific constant

        STARTTIME (int):
            Instance specific constant

        STATES (int):
            Instance specific constant

        STATUS_STRING (int):
            Instance specific constant

        STEREO (int):
            Instance specific constant

        STEREO_CAPABLE (int):
            Instance specific constant

        STEREO_SEPARATION (int):
            Instance specific constant

        STREAMLINE (int):
            Instance specific constant

        SUBGRIDLINETYPE (int):
            Instance specific constant

        SUBGRIDLINEWIDTH (int):
            Instance specific constant

        SUBGRIDRGB (int):
            Instance specific constant

        SUBLEVELS (int):
            Instance specific constant

        SUBLEVELSVISIBLE (int):
            Instance specific constant

        SUBSTRATE_MATERIAL (int):
            Instance specific constant

        SUBTICKSCALEFACTOR (int):
            Instance specific constant

        SURFACE (int):
            Instance specific constant

        SURFACERESTRICTED (int):
            Instance specific constant

        SYMMETRY (int):
            Instance specific constant

        SYMMETRYANGLE (int):
            Instance specific constant

        SYMMETRYAXIS (int):
            Instance specific constant

        SYMMETRYDELTA (int):
            Instance specific constant

        SYMMETRYMIRRORX (int):
            Instance specific constant

        SYMMETRYMIRRORXY (int):
            Instance specific constant

        SYMMETRYMIRRORXYZ (int):
            Instance specific constant

        SYMMETRYMIRRORXZ (int):
            Instance specific constant

        SYMMETRYMIRRORY (int):
            Instance specific constant

        SYMMETRYMIRRORYZ (int):
            Instance specific constant

        SYMMETRYMIRRORZ (int):
            Instance specific constant

        SYMMETRYORIGIN (int):
            Instance specific constant

        SYMMETRYRINSTANCES (int):
            Instance specific constant

        SYMMETRYTYPE (int):
            Instance specific constant

        SYNCTOPALETTE (int):
            Instance specific constant

        SYNCTOTRANSIENT (int):
            Instance specific constant

        SYNTHETIC_MENU (int):
            Instance specific constant

        TAGS (int):
            Instance specific constant

        TARGETS (int):
            Instance specific constant

        TEMPERATURE (int):
            Instance specific constant

        TEMPLATE_NAME (int):
            Instance specific constant

        TEMPORAL_XY_QUERIES (int):
            Instance specific constant

        TENSIONLINEWIDTH (int):
            Instance specific constant

        TENSIONRGB (int):
            Instance specific constant

        TENSOR_COLBY_DRCT (int):
            Instance specific constant

        TENSOR_COLBY_PART (int):
            Instance specific constant

        TENSOR_LINEWBY_DRCT (int):
            Instance specific constant

        TENSOR_LINEWBY_PART (int):
            Instance specific constant

        TEXTPOSITION (int):
            Instance specific constant

        TEXTRGB (int):
            Instance specific constant

        TEXTSIZE (int):
            Instance specific constant

        TEXTTYPE (int):
            Instance specific constant

        TEXTURECOORDTYPE (int):
            Instance specific constant

        TEXTUREINTERPOLATION (int):
            Instance specific constant

        TEXTUREMODE (int):
            Instance specific constant

        TEXTUREOBJECT (int):
            Instance specific constant

        TEXTUREORIGIN (int):
            Instance specific constant

        TEXTUREORIGINNODEID (int):
            Instance specific constant

        TEXTUREORIGINUSE (int):
            Instance specific constant

        TEXTUREREPEATMODE (int):
            Instance specific constant

        TEXTURES (int):
            Instance specific constant

        TEXTURESORIGINNODEID (int):
            Instance specific constant

        TEXTURESVARIABLE (int):
            Instance specific constant

        TEXTURESVECTOR (int):
            Instance specific constant

        TEXTURETORIGINNODEID (int):
            Instance specific constant

        TEXTURETVARIABLE (int):
            Instance specific constant

        TEXTURETVECTOR (int):
            Instance specific constant

        TEXTURE_COORDS_BY_PROJECTION (int):
            Instance specific constant

        TEXTURE_COORDS_BY_TWOSCALARS (int):
            Instance specific constant

        TEXTURE_INTERPOLATE_LINEAR (int):
            Instance specific constant

        TEXTURE_INTERPOLATE_NEAREST (int):
            Instance specific constant

        TEXTURE_MODE_DECAL (int):
            Instance specific constant

        TEXTURE_MODE_MODULATE (int):
            Instance specific constant

        TEXTURE_MODE_REPLACE (int):
            Instance specific constant

        TEXTURE_REPEAT_CLAMPED (int):
            Instance specific constant

        TEXTURE_REPEAT_CLAMPTEXTURE (int):
            Instance specific constant

        TEXTURE_REPEAT_REPEAT (int):
            Instance specific constant

        THRESHOLD (int):
            Instance specific constant

        THRESHOLDFILTER (int):
            Instance specific constant

        THRESHOLDHIGH (int):
            Instance specific constant

        THRESHOLDLOW (int):
            Instance specific constant

        THRESHOLDMAX (int):
            Instance specific constant

        THRESHOLDMIN (int):
            Instance specific constant

        THRESHOLDS (int):
            Instance specific constant

        THRESHOLDVALUE (int):
            Instance specific constant

        THRS_BAND (int):
            Instance specific constant

        THRS_HIGH (int):
            Instance specific constant

        THRS_LOHI (int):
            Instance specific constant

        THRS_LOW (int):
            Instance specific constant

        THRS_NONE (int):
            Instance specific constant

        TICKMARKS (int):
            Instance specific constant

        TICKSCALEFACTOR (int):
            Instance specific constant

        TIMEMARKER (int):
            Instance specific constant

        TIMEMARKERRGB (int):
            Instance specific constant

        TIMEMARKERSTYLE (int):
            Instance specific constant

        TIMEMARKERVALUE (int):
            Instance specific constant

        TIMEMARKERWIDTH (int):
            Instance specific constant

        TIMES (int):
            Instance specific constant

        TIMESETS (int):
            Instance specific constant

        TIMESTEP (int):
            Instance specific constant

        TIMESTEPBEGIN (int):
            Instance specific constant

        TIMESTEPEND (int):
            Instance specific constant

        TIMESTEP_LIMITS (int):
            Instance specific constant

        TIMETRACK (int):
            Instance specific constant

        TIMEVALUES (int):
            Instance specific constant

        TIME_RANGE (int):
            Instance specific constant

        TIPLENGTH (int):
            Instance specific constant

        TIPRADIUS (int):
            Instance specific constant

        TIPRGB (int):
            Instance specific constant

        TIPSHAFT (int):
            Instance specific constant

        TIPSHAPE (int):
            Instance specific constant

        TIPSIZE (int):
            Instance specific constant

        TIPSIZEFIXED (int):
            Instance specific constant

        TIPSIZEPROPORTIONAL (int):
            Instance specific constant

        TIPSIZEREP (int):
            Instance specific constant

        TITLELOCATION (int):
            Instance specific constant

        TITLERGB (int):
            Instance specific constant

        TITLETEXTSIZE (int):
            Instance specific constant

        TOOL (int):
            Instance specific constant

        TOOLS (int):
            Instance specific constant

        TOOLTYPE (int):
            Instance specific constant

        TOOL_BOX (int):
            Instance specific constant

        TOOL_CONE (int):
            Instance specific constant

        TOOL_CURSOR (int):
            Instance specific constant

        TOOL_CYLINDER (int):
            Instance specific constant

        TOOL_LINE (int):
            Instance specific constant

        TOOL_ORIENTATION (int):
            Instance specific constant

        TOOL_PLANE (int):
            Instance specific constant

        TOOL_REVOLUTION (int):
            Instance specific constant

        TOOL_SPHERE (int):
            Instance specific constant

        TOOL_USERDEFINED (int):
            Instance specific constant

        TOTALENERGY (int):
            Instance specific constant

        TOTALROTATION (int):
            Instance specific constant

        TOTALTIME (int):
            Instance specific constant

        TOTALTRANSLATION (int):
            Instance specific constant

        TRACEDIRECTION (int):
            Instance specific constant

        TRACE_LINE (int):
            Instance specific constant

        TRACE_RIBBON (int):
            Instance specific constant

        TRACE_SQUBE (int):
            Instance specific constant

        TRACE_TUBE (int):
            Instance specific constant

        TRACK (int):
            Instance specific constant

        TRACKINGNODEID (int):
            Instance specific constant

        TRACKINGPARTID (int):
            Instance specific constant

        TRACK_NODE_NUMBER (int):
            Instance specific constant

        TRACK_PART_CENTROID (int):
            Instance specific constant

        TRACK_PART_XMAX (int):
            Instance specific constant

        TRACK_PART_XMIN (int):
            Instance specific constant

        TRACK_PART_YMAX (int):
            Instance specific constant

        TRACK_PART_YMIN (int):
            Instance specific constant

        TRACK_PART_ZMAX (int):
            Instance specific constant

        TRACK_PART_ZMIN (int):
            Instance specific constant

        TRANSFORMATION_DELTA (int):
            Instance specific constant

        TRANSFORMCENTER (int):
            Instance specific constant

        TRANSFORM_WITH_MODEL (int):
            Instance specific constant

        TRANSLATION (int):
            Instance specific constant

        TRANSLUCENT_MATERIAL (int):
            Instance specific constant

        TRANSMITIVE_COMPONENT (int):
            Instance specific constant

        TRANSPARENCY (int):
            Instance specific constant

        TRANSPARENT_METHOD (int):
            Instance specific constant

        TRANSPARENT_NUMPEELS (int):
            Instance specific constant

        TRANSP_SORT_DELAYED (int):
            Instance specific constant

        TRANSP_SORT_DEPTHPEEL (int):
            Instance specific constant

        TRANSP_SORT_INTERACTIVE (int):
            Instance specific constant

        TRIANGLES (int):
            Instance specific constant

        TRUE (int):
            Instance specific constant

        TS_CENTER (int):
            Instance specific constant

        TS_LEFT (int):
            Instance specific constant

        TS_RIGHT (int):
            Instance specific constant

        TS_SCREEN_RELATIVE (int):
            Instance specific constant

        TS_VIEWPORT_RELATIVE (int):
            Instance specific constant

        TYPE (int):
            Instance specific constant

        TYPE_ELEVATED_SURFACE (int):
            Instance specific constant

        TYPE_OFFSET_SURFACE (int):
            Instance specific constant

        UBER_MATERIAL (int):
            Instance specific constant

        UNDEFINEDCOLOR (int):
            Instance specific constant

        UNDEFINED_COLOR (int):
            Instance specific constant

        UNIQUENAME (int):
            Instance specific constant

        UPDATEWITHNEWTIMESTEPS (int):
            Instance specific constant

        UPVEC_NX (int):
            Instance specific constant

        UPVEC_NY (int):
            Instance specific constant

        UPVEC_NZ (int):
            Instance specific constant

        UPVEC_X (int):
            Instance specific constant

        UPVEC_Y (int):
            Instance specific constant

        UPVEC_Z (int):
            Instance specific constant

        USEANNOTATIONTEXT (int):
            Instance specific constant

        USEDOUBLESIDEDWALLS (int):
            Instance specific constant

        USENORMALIZEDWIDTH (int):
            Instance specific constant

        USESURFACENORMALS (int):
            Instance specific constant

        USE_CONTINUOUS (int):
            Instance specific constant

        USE_LOGO (int):
            Instance specific constant

        UUID (int):
            Instance specific constant

        VALUE (int):
            Instance specific constant

        VALUEDECIMALPLACES (int):
            Instance specific constant

        VALUEFORMAT (int):
            Instance specific constant

        VALUEIJK (int):
            Instance specific constant

        VALUELOCATION (int):
            Instance specific constant

        VALUERGB (int):
            Instance specific constant

        VALUERTZ (int):
            Instance specific constant

        VALUESIZE (int):
            Instance specific constant

        VALUESPLINE (int):
            Instance specific constant

        VALUEXYZ (int):
            Instance specific constant

        VARCOMP (int):
            Instance specific constant

        VARIABLE (int):
            Instance specific constant

        VARIABLE1 (int):
            Instance specific constant

        VARIABLE2 (int):
            Instance specific constant

        VARIABLEOFFSET (int):
            Instance specific constant

        VARIABLES (int):
            Instance specific constant

        VARIABLETREE (int):
            Instance specific constant

        VARTYPE (int):
            Instance specific constant

        VARTYPEENUM (int):
            Instance specific constant

        VAR_XAXIS (int):
            Instance specific constant

        VAR_XAXIS_OBJ (int):
            Instance specific constant

        VAR_YAXIS_LEFT (int):
            Instance specific constant

        VAR_YAXIS_LEFT_OBJ (int):
            Instance specific constant

        VAR_YAXIS_RIGHT (int):
            Instance specific constant

        VAR_YAXIS_RIGHT_OBJ (int):
            Instance specific constant

        VECTOR_MAGNITUDE (int):
            Instance specific constant

        VECTOR_X_COMP (int):
            Instance specific constant

        VECTOR_Y_COMP (int):
            Instance specific constant

        VECTOR_Z_COMP (int):
            Instance specific constant

        VELOCITY (int):
            Instance specific constant

        VIEWDIMENSION (int):
            Instance specific constant

        VIEWPORT00 (int):
            Instance specific constant

        VIEWPORT01 (int):
            Instance specific constant

        VIEWPORT02 (int):
            Instance specific constant

        VIEWPORT03 (int):
            Instance specific constant

        VIEWPORT04 (int):
            Instance specific constant

        VIEWPORT05 (int):
            Instance specific constant

        VIEWPORT06 (int):
            Instance specific constant

        VIEWPORT07 (int):
            Instance specific constant

        VIEWPORT08 (int):
            Instance specific constant

        VIEWPORT09 (int):
            Instance specific constant

        VIEWPORT10 (int):
            Instance specific constant

        VIEWPORT11 (int):
            Instance specific constant

        VIEWPORT12 (int):
            Instance specific constant

        VIEWPORT13 (int):
            Instance specific constant

        VIEWPORT14 (int):
            Instance specific constant

        VIEWPORT15 (int):
            Instance specific constant

        VIEWPORT16 (int):
            Instance specific constant

        VIEWPORT17 (int):
            Instance specific constant

        VIEWPORT18 (int):
            Instance specific constant

        VIEWPORT19 (int):
            Instance specific constant

        VIEWPORT20 (int):
            Instance specific constant

        VIEWPORT21 (int):
            Instance specific constant

        VIEWPORT22 (int):
            Instance specific constant

        VIEWPORT23 (int):
            Instance specific constant

        VIEWPORT24 (int):
            Instance specific constant

        VIEWPORT25 (int):
            Instance specific constant

        VIEWPORT26 (int):
            Instance specific constant

        VIEWPORT27 (int):
            Instance specific constant

        VIEWPORT28 (int):
            Instance specific constant

        VIEWPORT29 (int):
            Instance specific constant

        VIEWPORT30 (int):
            Instance specific constant

        VIEWPORT31 (int):
            Instance specific constant

        VIEWPORTVIS (int):
            Instance specific constant

        VIEWPORT_USE (int):
            Instance specific constant

        VISIBILITYELT (int):
            Instance specific constant

        VISIBILITYLINE (int):
            Instance specific constant

        VISIBILITYNODE (int):
            Instance specific constant

        VISIBLE (int):
            Instance specific constant

        VISUAL_SYMM_MIRROR (int):
            Instance specific constant

        VISUAL_SYMM_NONE (int):
            Instance specific constant

        VISUAL_SYMM_ROTATE (int):
            Instance specific constant

        VISUAL_SYMM_TRANSLATE (int):
            Instance specific constant

        VOFCLIPVALUE (int):
            Instance specific constant

        VOFCLIPZTEST (int):
            Instance specific constant

        VOFCLIP_CONTOURS_PLUS_OBSTACLES (int):
            Instance specific constant

        VOFCLIP_INCREASE_RESOLUTION (int):
            Instance specific constant

        VOFCLIP_OBSTACLES_ONLY (int):
            Instance specific constant

        VOFCLIP_USE_CELL_CENTER_VALUES (int):
            Instance specific constant

        VOFISOVALUE (int):
            Instance specific constant

        VOFISOZTEST (int):
            Instance specific constant

        VOFISO_BLANK_ALGORITHM1 (int):
            Instance specific constant

        VOFISO_BLANK_ALGORITHM2 (int):
            Instance specific constant

        VOFISO_FLUID (int):
            Instance specific constant

        VOFISO_FLUID_AND_OBSTACLES_OPEN_VOLUME (int):
            Instance specific constant

        VOFISO_FLUID_AND_OBSTACLE_SOLID_VOLUME (int):
            Instance specific constant

        VOFISO_FLUID_FRACTION (int):
            Instance specific constant

        VOFISO_LIQUID (int):
            Instance specific constant

        VOFISO_OPEN_VOLUME (int):
            Instance specific constant

        VOFISO_SHALLOW_WATER_3D_SURFACE (int):
            Instance specific constant

        VOFISO_SHALLOW_WATER_OPEN_VOLUME (int):
            Instance specific constant

        VOFISO_SHALLOW_WATER_SOLID_VOLUME (int):
            Instance specific constant

        VOFISO_SOLIDIFIED_LIQUID (int):
            Instance specific constant

        VOFISO_SOLID_VOLUME (int):
            Instance specific constant

        VOFISO_VOID (int):
            Instance specific constant

        VOFISO_VOLUME_FRACTION (int):
            Instance specific constant

        VOF_TYPE_CLIP (int):
            Instance specific constant

        VOF_TYPE_ISO (int):
            Instance specific constant

        VOLREND_STRUCTURED (int):
            Instance specific constant

        VOLREND_UNSTRUCTURED (int):
            Instance specific constant

        VOLUME (int):
            Instance specific constant

        VOLUMEQUALITY (int):
            Instance specific constant

        VOLUMERENDERINGTYPE (int):
            Instance specific constant

        VOLUME_CHUNKING_NUM_TETS (int):
            Instance specific constant

        VOLUME_NUM_PASSES (int):
            Instance specific constant

        VOL_RENDER_QUALITY_BEST (int):
            Instance specific constant

        VOL_RENDER_QUALITY_HIGH (int):
            Instance specific constant

        VOL_RENDER_QUALITY_LOW (int):
            Instance specific constant

        VOL_RENDER_QUALITY_MEDIUM (int):
            Instance specific constant

        VPORTS (int):
            Instance specific constant

        VPORT_0 (int):
            Instance specific constant

        VPORT_1 (int):
            Instance specific constant

        VPORT_10 (int):
            Instance specific constant

        VPORT_11 (int):
            Instance specific constant

        VPORT_12 (int):
            Instance specific constant

        VPORT_13 (int):
            Instance specific constant

        VPORT_14 (int):
            Instance specific constant

        VPORT_15 (int):
            Instance specific constant

        VPORT_2 (int):
            Instance specific constant

        VPORT_3 (int):
            Instance specific constant

        VPORT_4 (int):
            Instance specific constant

        VPORT_5 (int):
            Instance specific constant

        VPORT_6 (int):
            Instance specific constant

        VPORT_7 (int):
            Instance specific constant

        VPORT_8 (int):
            Instance specific constant

        VPORT_9 (int):
            Instance specific constant

        VPORT_BLEND (int):
            Instance specific constant

        VPORT_CONS (int):
            Instance specific constant

        VPORT_IMAGE (int):
            Instance specific constant

        VPORT_SET (int):
            Instance specific constant

        VPORT_TRANSPARENT (int):
            Instance specific constant

        VR_ANNOT_CENTER (int):
            Instance specific constant

        VR_ANNOT_NORMAL (int):
            Instance specific constant

        VR_ANNOT_SCALE (int):
            Instance specific constant

        VR_ANNOT_UP (int):
            Instance specific constant

        VR_CAVE_CENTER (int):
            Instance specific constant

        VR_CAVE_DIAGONAL (int):
            Instance specific constant

        VR_CAVE_SCALE (int):
            Instance specific constant

        WALLTHICKNESS (int):
            Instance specific constant

        WATERMARK (int):
            Instance specific constant

        WHICH_HISTOGRAM (int):
            Instance specific constant

        WIDTH (int):
            Instance specific constant

        WIDTHSCALEFACTOR (int):
            Instance specific constant

        WINDOWSIZE (int):
            Instance specific constant

        XAXIS_TYPE (int):
            Instance specific constant

        XY_GRID_GRID (int):
            Instance specific constant

        XY_GRID_NONE (int):
            Instance specific constant

        XY_GRID_TICK (int):
            Instance specific constant

        XY_LABEL_ALL (int):
            Instance specific constant

        XY_LABEL_BEG_END (int):
            Instance specific constant

        XY_LABEL_NONE (int):
            Instance specific constant

        ZCLIPLIMITS (int):
            Instance specific constant

        ZERO (int):
            Instance specific constant

        ZONES_BOTH (int):
            Instance specific constant

        ZONES_DEF (int):
            Instance specific constant

        ZONES_EXT (int):
            Instance specific constant

        ZONES_INT (int):
            Instance specific constant


    """
    def __init__(self, session: Session):
        self._session = session
        self.ACTIVE: int = 1610612739
        self.ADJCOORDSCALEFACTOR: int = 1610613198
        self.ADJCOORDTRANSVEC: int = 1610613203
        self.ADJCOORDVARSCALEFACTOR: int = 1610613199
        self.ADJCOORDXVARIABLE: int = 1610613200
        self.ADJCOORDYVARIABLE: int = 1610613201
        self.ADJCOORDZVARIABLE: int = 1610613202
        self.ALLOW_MRU_UPDATE: int = 1610612896
        self.ALPHABY: int = 1610613119
        self.ALPHABYPALETTE: int = 1610612802
        self.ALPHA_VOLUME_SCALE: int = 1610612992
        self.AMBIENT_COMPONENT: int = 1
        self.ANGLE: int = 1610613043
        self.ANIMATE: int = 1610613363
        self.ANIMATECURVES: int = 1610613754
        self.ANIMATING: int = 1610612873
        self.ANIMDELTA: int = 1610613359
        self.ANIMOBJS: int = 1610612876
        self.ANNOTATIONTEXTID: int = 1610613576
        self.ANNOTINDEX: int = 1610612999
        self.ANNOTS: int = 1610612837
        self.ANNOTTYPE: int = 1610612998
        self.ANNOT_2D_SPACE: int = 0
        self.ANNOT_3D_SPACE: int = 1
        self.ANNOT_SHAPE_ARROW: int = 2
        self.ANNOT_SHAPE_CIRCLE: int = 1
        self.ANNOT_SHAPE_RECT: int = 0
        self.ANNO_ARROW: int = 5
        self.ANNO_DIAL: int = 6
        self.ANNO_GAUGE: int = 7
        self.ANNO_LGND: int = 3
        self.ANNO_LINE: int = 1
        self.ANNO_LOGO: int = 2
        self.ANNO_SHAPE: int = 8
        self.ANNO_TEXT: int = 0
        self.ANSYS_DRAW_LOGO: int = 1610612946
        self.ANSYS_FLAG_ALPHA: int = 1610612945
        self.ANSYS_FLAG_BETA: int = 1610612944
        self.ANSYS_VERSION: int = 1610612942
        self.ANSYS_VERSION_STRING: int = 1610612943
        self.ANTIALIAS_FILTER_ALGORITHM: int = 1610612916
        self.ANTIALIAS_MODE: int = 1610612914
        self.ANTIALIAS_NUM_SAMPLES: int = 1610612915
        self.ANTIALIAS_PARAM_COMPRESSION: int = 1610612919
        self.ANTIALIAS_PARAM_GAMMA: int = 1610612917
        self.ANTIALIAS_PARAM_SMOOTH: int = 1610612918
        self.APPENDLOCATIONVALUE: int = 1610613574
        self.ARLOC_ELTC: int = 2
        self.ARLOC_NODE: int = 0
        self.ARLOC_VERT: int = 1
        self.ARROWATTACH: int = 1610613425
        self.ARROWHEAD: int = 1610613529
        self.ARROWLOCATION: int = 1610613424
        self.ARROWS: int = 1610613366
        self.ARROWSIZE: int = 1610613367
        self.ARROWTIPLENGTH: int = 1610613600
        self.ARROWTIPSIZE: int = 1610613601
        self.ARROWTYPE: int = 1610613423
        self.ARROWWIDTH: int = 1610613598
        self.ARROW_3D_FORCES: int = 2
        self.ARROW_3D_MOMENTS: int = 3
        self.ARROW_3D_QUERY_LOCAT: int = 1
        self.ARROW_3D_XYZ_LOCAT: int = 0
        self.ARROW_ALL: int = 0
        self.ARROW_COMP: int = 3
        self.ARROW_NORM: int = 1
        self.ARROW_SHAFT_LINE: int = 0
        self.ARROW_SHAFT_SOLID: int = 1
        self.ARROW_TAIL_AT_POINT: int = 0
        self.ARROW_TANG: int = 2
        self.ARROW_TIP_AT_POINT: int = 1
        self.ARRW_CURV: int = 1
        self.ARRW_FIXD: int = 2
        self.ARRW_RECT: int = 0
        self.ASSIGNED_CURVE_TO_YLEFT: int = 0
        self.ASSIGNED_CURVE_TO_YRIGHT: int = 1
        self.ASSIGNTOYAXIS: int = 1610613815
        self.ATRACE_COLBY_CALC: int = 0
        self.ATRACE_COLBY_CONST: int = 1
        self.ATRACE_HEAD_ARROW: int = 2
        self.ATRACE_HEAD_NONE: int = 0
        self.ATRACE_HEAD_SPHERE: int = 1
        self.ATRACE_SIZE_CONST: int = 0
        self.ATRACE_SIZE_SCALAR: int = 1
        self.ATRACE_SIZE_VEC_MAG: int = 2
        self.ATRACE_SIZE_VEC_X: int = 3
        self.ATRACE_SIZE_VEC_Y: int = 4
        self.ATRACE_SIZE_VEC_Z: int = 5
        self.AUTOSCALE: int = 1610613058
        self.AUTOSIZE: int = 1610613652
        self.AUXCLIPPING: int = 1610612864
        self.AUX_GEOM_NORMAL_INWARD: int = 0
        self.AUX_GEOM_NORMAL_OUTWARD: int = 1
        self.AUX_GEOM_SHAPE_BOX: int = 0
        self.AXESVISIBLE: int = 1610613651
        self.AXIS: int = 1610613337
        self.AXIS2AUTOSCALE: int = 1610613805
        self.AXIS2LABELFORMAT: int = 1610613803
        self.AXIS2LABELRGB: int = 1610613802
        self.AXIS2LABELSIZE: int = 1610613801
        self.AXIS2LABELTYPE: int = 1610613800
        self.AXIS2MAX: int = 1610613807
        self.AXIS2MIN: int = 1610613806
        self.AXIS2TITLE: int = 1610613797
        self.AXIS2TITLERGB: int = 1610613799
        self.AXIS2TITLESIZE: int = 1610613798
        self.AXIS2VISIBLE: int = 1610613804
        self.AXISAUTOLAYOUT: int = 1610613772
        self.AXISAUTOUPDATE: int = 1610613773
        self.AXISGLOBAL: int = 1610612931
        self.AXISHEIGHT: int = 1610613695
        self.AXISLINEWIDTH: int = 1610613653
        self.AXISLOCAL: int = 1610612930
        self.AXISMODEL: int = 1610612932
        self.AXISMODEL_ANIMATE: int = 1610612933
        self.AXISMODEL_LOCATION: int = 1610612934
        self.AXISRGB: int = 1610613654
        self.AXISSWAP: int = 1610613774
        self.AXISWIDTH: int = 1610613673
        self.AXISXAUTOSCALE: int = 1610613783
        self.AXISXDISPLAYONEDGE: int = 1610613679
        self.AXISXFORMAT: int = 1610613677
        self.AXISXGRIDEXTENTLOC: int = 1610613690
        self.AXISXGRIDTYPE: int = 1610613684
        self.AXISXLABELAXISLOC: int = 1610613674
        self.AXISXLABELEXTENTLOC: int = 1610613675
        self.AXISXLABELFILTER: int = 1610613676
        self.AXISXLABELFORMAT: int = 1610613779
        self.AXISXLABELRGB: int = 1610613678
        self.AXISXLABELSIZE: int = 1610613777
        self.AXISXLABELTYPE: int = 1610613776
        self.AXISXMAX: int = 1610613671
        self.AXISXMIN: int = 1610613670
        self.AXISXNUMGRID: int = 1610613686
        self.AXISXNUMGRIDLOG: int = 1610613780
        self.AXISXNUMSUBGRID: int = 1610613689
        self.AXISXNUMSUBGRIDLOG: int = 1610613781
        self.AXISXORIG: int = 1610613672
        self.AXISXORIGIN: int = 1610613784
        self.AXISXSCALE: int = 1610613778
        self.AXISXSGRIDTYPE: int = 1610613687
        self.AXISXSIZE: int = 1610613785
        self.AXISXSUBTICK: int = 1610613688
        self.AXISXTICK: int = 1610613685
        self.AXISXTITLE: int = 1610613667
        self.AXISXTITLERGB: int = 1610613775
        self.AXISXTITLESIZE: int = 1610613669
        self.AXISXVISIBLE: int = 1610613782
        self.AXISXYMAXZMAX: int = 1610613683
        self.AXISXYMAXZMIN: int = 1610613682
        self.AXISXYMINZMAX: int = 1610613681
        self.AXISXYMINZMIN: int = 1610613680
        self.AXISYAUTOSCALE: int = 1610613794
        self.AXISYDISPLAYONEDGE: int = 1610613701
        self.AXISYFORMAT: int = 1610613699
        self.AXISYGRIDEXTENTLOC: int = 1610613713
        self.AXISYGRIDTYPE: int = 1610613707
        self.AXISYLABELAXISLOC: int = 1610613696
        self.AXISYLABELEXTENTLOC: int = 1610613698
        self.AXISYLABELFILTER: int = 1610613697
        self.AXISYLABELFORMAT: int = 1610613790
        self.AXISYLABELRGB: int = 1610613700
        self.AXISYLABELSIZE: int = 1610613788
        self.AXISYLABELTYPE: int = 1610613787
        self.AXISYMAX: int = 1610613693
        self.AXISYMIN: int = 1610613692
        self.AXISYNUMGRID: int = 1610613709
        self.AXISYNUMGRIDLOG: int = 1610613791
        self.AXISYNUMSUBGRID: int = 1610613712
        self.AXISYNUMSUBGRIDLOG: int = 1610613792
        self.AXISYORIG: int = 1610613694
        self.AXISYORIGIN: int = 1610613795
        self.AXISYSCALE: int = 1610613789
        self.AXISYSGRIDTYPE: int = 1610613710
        self.AXISYSIZE: int = 1610613796
        self.AXISYSUBTICK: int = 1610613711
        self.AXISYTICK: int = 1610613708
        self.AXISYTITLE: int = 1610613668
        self.AXISYTITLERGB: int = 1610613786
        self.AXISYTITLESIZE: int = 1610613691
        self.AXISYVISIBLE: int = 1610613793
        self.AXISYYMAXZMAX: int = 1610613706
        self.AXISYYMAXZMIN: int = 1610613705
        self.AXISYYMINZMAX: int = 1610613704
        self.AXISYYMINZMIN: int = 1610613703
        self.AXISZDISPLAYONEDGE: int = 1610613702
        self.AXISZFORMAT: int = 1610613721
        self.AXISZGRIDEXTENTLOC: int = 1610613733
        self.AXISZGRIDTYPE: int = 1610613727
        self.AXISZLABELAXISLOC: int = 1610613718
        self.AXISZLABELEXTENTLOC: int = 1610613720
        self.AXISZLABELFILTER: int = 1610613719
        self.AXISZLABELRGB: int = 1610613722
        self.AXISZMAX: int = 1610613717
        self.AXISZMIN: int = 1610613716
        self.AXISZNUMGRID: int = 1610613729
        self.AXISZNUMSUBGRID: int = 1610613732
        self.AXISZSGRIDTYPE: int = 1610613730
        self.AXISZSUBTICK: int = 1610613731
        self.AXISZTICK: int = 1610613728
        self.AXISZTITLE: int = 1610613714
        self.AXISZTITLESIZE: int = 1610613715
        self.AXISZYMAXZMAX: int = 1610613726
        self.AXISZYMAXZMIN: int = 1610613725
        self.AXISZYMINZMAX: int = 1610613724
        self.AXISZYMINZMIN: int = 1610613723
        self.AXI_TYPE_EXTRUDE: int = 1
        self.AXI_TYPE_ROTATE: int = 0
        self.BACKGROUND: int = 1610613586
        self.BACKGROUNDIMAGE: int = 1610613015
        self.BACKGROUNDIMAGENAME: int = 1610613639
        self.BACKGROUNDRGB: int = 1610613588
        self.BACKGROUNDTRANSPARENCY: int = 1610613760
        self.BACKGROUNDTYPE: int = 1610613628
        self.BEGINSIMTIME: int = 1610613821
        self.BIGHANDRANGE: int = 1610613582
        self.BIGHANDRGB: int = 1610613580
        self.BLANKINGALGORITHM: int = 1610613500
        self.BLANKINGCLIPALG: int = 1610613499
        self.BLANKINGTHRESHOLD: int = 1610613498
        self.BLANKINGVARIABLE1: int = 1610613494
        self.BLANKINGVARIABLE2: int = 1610613495
        self.BLENDLEVELS: int = 1610613630
        self.BLENDPOSITION2: int = 1610613638
        self.BLENDPOSITION3: int = 1610613637
        self.BLENDPOSITION4: int = 1610613636
        self.BLENDRGB1: int = 1610613635
        self.BLENDRGB2: int = 1610613634
        self.BLENDRGB3: int = 1610613633
        self.BLENDRGB4: int = 1610613632
        self.BLENDRGB5: int = 1610613631
        self.BORDER: int = 1610613578
        self.BORDERCOLOR: int = 1610613059
        self.BORDERREP: int = 1
        self.BORDERRGB: int = 1610613761
        self.BORDERVISIBLE: int = 1610613650
        self.BORD_FULL: int = 0
        self.BOTH_ARRW: int = 3
        self.BOUNDARYFLAGXMAX: int = 1610613502
        self.BOUNDARYFLAGXMIN: int = 1610613501
        self.BOUNDARYFLAGYMAX: int = 1610613504
        self.BOUNDARYFLAGYMIN: int = 1610613503
        self.BOUNDARYFLAGZMAX: int = 1610613506
        self.BOUNDARYFLAGZMIN: int = 1610613505
        self.BOUNDINGBOX: int = 1610613026
        self.BOUNDINGREP: int = 1610613191
        self.BOUNDING_BOX: int = 5
        self.BOUNDS: int = 1610612950
        self.BOXAXISX: int = 1610613285
        self.BOXAXISY: int = 1610613286
        self.BOXAXISZ: int = 1610613287
        self.BOXLENGTH: int = 1610613284
        self.BOXORIGIN: int = 1610613283
        self.BOX_DRAW_BOX: int = 1
        self.BOX_DRAW_MODEL: int = 0
        self.BOX_DRAW_NOTHING: int = 5
        self.BOX_DRAW_POINTS: int = 2
        self.BOX_DRAW_REDUCED: int = 4
        self.BOX_DRAW_SPARSE_MODEL: int = 3
        self.C1_POINTS: int = 1610612982
        self.C2_POINTS: int = 1610612983
        self.C3_POINTS: int = 1610612984
        self.C4_POINTS: int = 1610612985
        self.CALC_0D: int = 16
        self.CALC_1D: int = 1
        self.CALC_2D: int = 2
        self.CALC_3D: int = 4
        self.CALC_CASEID: int = 268435456
        self.CALC_COMPONENT: int = 16777216
        self.CALC_HINTS_MASK: int = 1072693248
        self.CALC_MASS_PTRACE: int = 8
        self.CALC_NODEID: int = 67108864
        self.CALC_PARTID: int = 134217728
        self.CALC_TIMESTEP: int = 536870912
        self.CALC_VAL_BOOLEAN: int = 1048576
        self.CALC_VAL_ENUM: int = 8388608
        self.CALC_VAL_FLOAT: int = 4194304
        self.CALC_VAL_INT: int = 2097152
        self.CALC_VAL_MASK: int = 15728640
        self.CALC_VAR_ACTIVE: int = 64
        self.CALC_VAR_CONST: int = 1
        self.CALC_VAR_CONSTPPART: int = 4096
        self.CALC_VAR_CONSTPPOPT: int = 65536
        self.CALC_VAR_COORDS: int = 1024
        self.CALC_VAR_ELEMENT: int = 128
        self.CALC_VAR_MASK: int = 1048575
        self.CALC_VAR_MATERIAL: int = 16384
        self.CALC_VAR_NODAL: int = 256
        self.CALC_VAR_NONEOK: int = 32768
        self.CALC_VAR_OBJECT: int = 2048
        self.CALC_VAR_PARTLIST: int = 1073741824
        self.CALC_VAR_SCALAR: int = 2
        self.CALC_VAR_SCLCLPX: int = 16
        self.CALC_VAR_SPECIES: int = 8192
        self.CALC_VAR_TENSOR: int = 8
        self.CALC_VAR_TIME: int = 512
        self.CALC_VAR_VECCLPX: int = 32
        self.CALC_VAR_VECTOR: int = 4
        self.CALC_VIEWPORT: int = 33554432
        self.CAMERAS: int = 1610612826
        self.CAMERA_LENS_NORMAL: int = 0
        self.CAMERA_LENS_VIEW_PYRAMID: int = 1
        self.CAMERA_LOOK_AT_FORWARD: int = 0
        self.CAMERA_LOOK_AT_NODE: int = 1
        self.CAMERA_LOOK_AT_PLANE_TOOL: int = 4
        self.CAMERA_LOOK_AT_SPLINE: int = 3
        self.CAMERA_LOOK_AT_XYZ: int = 2
        self.CAMERA_LOOK_FROM_NODE: int = 0
        self.CAMERA_LOOK_FROM_PLANE_TOOL: int = 3
        self.CAMERA_LOOK_FROM_SPLINE: int = 2
        self.CAMERA_LOOK_FROM_XYZ: int = 1
        self.CASELINKING: int = 1610612888
        self.CASENUMBER: int = 1610612738
        self.CASES: int = 1610612814
        self.CASE_LINKING_LABELS: int = 1610612861
        self.CASTS_SHADOWS: int = 1610613074
        self.CELLCOMPNUM: int = 1610613492
        self.CELLTYPE: int = 1610613475
        self.CELLVOLUMEFRACTION: int = 1610613474
        self.CENTROID: int = 1610613039
        self.CFD_VAR: int = 1677721600
        self.CHANGEALLOWED: int = 1610612952
        self.CHILDREN: int = 1610612741
        self.CLICKNGO_HANDLE_VISIBILITY: int = 1610612920
        self.CLIP: int = 1610613084
        self.CLIPBLANKINGVARIABLE: int = 1610613486
        self.CLIPLCTW: int = 1610613471
        self.CLIPLINEPT1: int = 1610613274
        self.CLIPLINEPT2: int = 1610613275
        self.CLIPPERIODICFLAGX: int = 1610613487
        self.CLIPPERIODICFLAGY: int = 1610613488
        self.CLIPPLANEPT1: int = 1610613277
        self.CLIPPLANEPT2: int = 1610613278
        self.CLIPPLANEPT3: int = 1610613279
        self.CLIPTYPE: int = 1610613470
        self.CLIP_CHOICE_BETWEEN: int = 14
        self.CLIP_CHOICE_GREATER: int = 12
        self.CLIP_CHOICE_LESS: int = 13
        self.CLIP_DOMAIN_CRINKLY: int = 4
        self.CLIP_DOMAIN_IN: int = 1
        self.CLIP_DOMAIN_INOUT: int = 3
        self.CLIP_DOMAIN_INTER: int = 0
        self.CLIP_DOMAIN_OUT: int = 2
        self.CLIP_DOMAIN_RECT: int = 6
        self.CLIP_DOMAIN_VOLUME: int = 5
        self.CLIP_PLANE_FINITE: int = 1
        self.CLIP_PLANE_INFINITE: int = 0
        self.CMDLANG_REFERENCE: int = 1610612764
        self.COLOR: int = 1610613032
        self.COLORBY: int = 1610613443
        self.COLORBYPALETTE: int = 1610612801
        self.COLORBYPROJECTION: int = 1610613427
        self.COLORBYRGB: int = 1610613117
        self.COLORS_PER_LEVEL: int = 1610612975
        self.COLOR_SPACE: int = 1610612974
        self.COMPONENT: int = 1610613339
        self.COMPONENTNUMINCELL: int = 1610613476
        self.COMPOSITEMATRIX: int = 1610613030
        self.COMPRESSION: int = 1610613053
        self.COMPRESSIONLINEWIDTH: int = 1610613447
        self.COMPRESSIONRGB: int = 1610613444
        self.COMPRESSION_GZ: int = 2
        self.COMPRESSION_JPEG: int = 3
        self.COMPRESSION_NONE: int = 0
        self.COMPRESSION_RLE: int = 1
        self.COMPUTED: int = 1610612957
        self.COMPUTEUSINGPERIODICITY: int = 1610613378
        self.CONEANGLE: int = 1610613292
        self.CONEAXISVECT: int = 1610613294
        self.CONEENDPOINT: int = 1610613295
        self.CONEORIGIN: int = 1610613293
        self.CONNECTIVITY: int = 1610612754
        self.CONNECT_TIMEOUT: int = 1610612923
        self.CONSTANTRGB: int = 1610613629
        self.CONSTANT_VALUE: int = 1610612968
        self.CONSTRAINDISTANCE: int = 1610613843
        self.CONSTRAINT: int = 1610613356
        self.CONSTRAINTIME: int = 1610613844
        self.CONTOUR_LABEL_HORIZ: int = 0
        self.CONTOUR_LABEL_TANGN: int = 1
        self.CONTROLPOINTS: int = 1610613037
        self.COOLINGCHANNELCOMP: int = 1610613493
        self.COORDINATES: int = 1610612753
        self.CORE: int = 1610613048
        self.CORE2DTRANSFORM: int = 1610613024
        self.CORETRANSFORM: int = 1610613023
        self.CREATE_REPORT_TEMPLATE: int = 1610612761
        self.CT_BOX: int = 10
        self.CT_CONE: int = 4
        self.CT_CYLD: int = 2
        self.CT_GENQ: int = 7
        self.CT_IJK: int = 8
        self.CT_LINE: int = 0
        self.CT_PART: int = 6
        self.CT_PLNE: int = 1
        self.CT_REVO: int = 5
        self.CT_RTZ: int = 11
        self.CT_SPHR: int = 3
        self.CT_SPLINE: int = 12
        self.CT_XYZ: int = 9
        self.CULLELEMENTS: int = 1610613189
        self.CULL_BACK_FACE: int = 0
        self.CULL_FRONT_FACE: int = 1
        self.CULL_NO_FACE: int = 2
        self.CURRENT: int = 1610612762
        self.CURRENTCASE: int = 1610612828
        self.CURRENTFRAME: int = 1610613055
        self.CURRENTGUI: int = 1610612885
        self.CURRENTVIEWPORTID: int = 1610612829
        self.CURSORLOC: int = 1610613833
        self.CURVE_LINE_CONNECT: int = 1
        self.CURVE_LINE_NONE: int = 0
        self.CURVE_LINE_SMOOTH: int = 2
        self.CURVE_MARKER_CIRCLE: int = 2
        self.CURVE_MARKER_DOT: int = 1
        self.CURVE_MARKER_NONE: int = 0
        self.CURVE_MARKER_SQUARE: int = 4
        self.CURVE_MARKER_TRIANGLE: int = 3
        self.CVF_ATTRDEP_CHAIN_AND: int = 0
        self.CVF_ATTRDEP_CHAIN_MASK: int = 251658240
        self.CVF_ATTRDEP_CHAIN_OR: int = 16777216
        self.CVF_ATTRDEP_CHAIN_XOR: int = 33554432
        self.CVF_ATTRDEP_LEN_FOR: int = 2
        self.CVF_ATTRDEP_LEN_OF: int = 3
        self.CVF_ATTRDEP_MASK_OP: int = 15
        self.CVF_ATTRDEP_SENS_AND: int = 16384
        self.CVF_ATTRDEP_SENS_EQ: int = 256
        self.CVF_ATTRDEP_SENS_GT: int = 512
        self.CVF_ATTRDEP_SENS_LT: int = 1024
        self.CVF_ATTRDEP_SENS_MASK: int = 65280
        self.CVF_ATTRDEP_SENS_NOT: int = 4096
        self.CVF_ATTRDEP_SENS_OR: int = 8192
        self.CVF_ATTRDEP_SENS_VALUE: int = 1
        self.CVF_ATTRDEP_SENS_XOR: int = 32768
        self.CVF_ATTR_BIT_FLAGS: int = 2
        self.CVF_ATTR_BOOL: int = 0
        self.CVF_ATTR_COLOR_RGB: int = 5
        self.CVF_ATTR_COLOR_RGBA: int = 6
        self.CVF_ATTR_ENUM: int = 3
        self.CVF_ATTR_FLOAT: int = 2
        self.CVF_ATTR_FONT: int = 11
        self.CVF_ATTR_GREATER: int = 64
        self.CVF_ATTR_HAS_ENUMS: int = 4
        self.CVF_ATTR_HAS_RANGE: int = 1
        self.CVF_ATTR_IMAGE: int = 10
        self.CVF_ATTR_INT: int = 1
        self.CVF_ATTR_INT64: int = 14
        self.CVF_ATTR_LESS: int = 32
        self.CVF_ATTR_NO_MAXIMUM: int = 8
        self.CVF_ATTR_NO_MINIMUM: int = 16
        self.CVF_ATTR_OBJPTR: int = 13
        self.CVF_ATTR_PSTRING: int = 8
        self.CVF_ATTR_PTR: int = 9
        self.CVF_ATTR_READONLY: int = 256
        self.CVF_ATTR_SOBJPTR: int = 12
        self.CVF_ATTR_STRING: int = 7
        self.CVF_ATTR_USERFLG_MASK: int = -65536
        self.CVF_ATTR_VARID: int = 4
        self.CVF_CP_UTF8: int = 65001
        self.CVF_FONT_BOLD: int = 2
        self.CVF_FONT_DEMILIGHT: int = 256
        self.CVF_FONT_ITALIC: int = 4
        self.CVF_FONT_LIGHT: int = 128
        self.CVF_FONT_NARROW: int = 32
        self.CVF_FONT_OBLIQUE: int = 8
        self.CVF_FONT_REGULAR: int = 1
        self.CVF_FONT_ROMAN: int = 16
        self.CVF_FONT_THIN: int = 64
        self.CVF_GFX_RAM_UNKNOWN: int = 129
        self.CVF_HILITE_METHOD_GEOMETRY: int = 0
        self.CVF_HILITE_METHOD_IMAGE: int = 1
        self.CVF_JLC_APPCMDLINE: int = 7011
        self.CVF_JLC_CWD: int = 7012
        self.CVF_JLC_HOSTNAME: int = 7002
        self.CVF_JLC_LAUNCHCFGNAME: int = 7008
        self.CVF_JLC_LAUNCHMETHOD: int = 7007
        self.CVF_JLC_LAUNCHOPT: int = 7009
        self.CVF_JLC_NAME: int = 7001
        self.CVF_JLC_NNODES: int = 7013
        self.CVF_JLC_RSH: int = 7003
        self.CVF_JLC_RSHOPT: int = 7004
        self.CVF_JLC_RSHPORT: int = 7005
        self.CVF_JLC_RUSERNAME: int = 7006
        self.CVF_JLC_TIMEOUT: int = 7010
        self.CVF_LANG_UNKNOWN: int = 0
        self.CVF_PALETTE_UNDEFINED_AS_ZERO_VALUE: int = 30
        self.CVF_PALETTE_UNDEFINED_BY_INVISIBLE: int = 20
        self.CVF_PALETTE_UNDEFINED_BY_PART_COLOR: int = 10
        self.CVF_PALETTE_UNDEFINED_BY_UNDEF_COLOR: int = 40
        self.CYLDAXISVECT: int = 1610613291
        self.CYLDENDPOINT: int = 1610613290
        self.CYLDORIGIN: int = 1610613289
        self.CYLDRADIUS: int = 1610613288
        self.CYLINDERS: int = 4
        self.DATA_BIGENDIAN: int = 0
        self.DATA_LITTLEENDIAN: int = 1
        self.DATA_NATIVE: int = 2
        self.DEFAULTANNOTS: int = 1610612831
        self.DEFAULTPARTS: int = 1610612830
        self.DEFAULTPLOT: int = 1610612833
        self.DEFAULTPOLYLINE: int = 1610612834
        self.DEFAULTQUERY: int = 1610612832
        self.DEFAULTREADERID: int = 1610612772
        self.DEFAULTVARIABLE: int = 1610612836
        self.DEFAULTVPORT: int = 1610612835
        self.DEFAULT_3DANNOT_FONTSIZE: int = 1610612910
        self.DEFAULT_ANNOT_FONTFAMILY: int = 1610612903
        self.DEFAULT_ANNOT_FONTSTYLE: int = 1610612904
        self.DEFAULT_CORE_FONTFAMILY: int = 1610612907
        self.DEFAULT_CORE_FONTSCALE: int = 1610612909
        self.DEFAULT_CORE_FONTSTYLE: int = 1610612908
        self.DEFAULT_JLC: int = 1610612844
        self.DEFAULT_SYMBOL_FONTFAMILY: int = 1610612905
        self.DEFAULT_SYMBOL_FONTSTYLE: int = 1610612906
        self.DEFAULT_VALUE: float = -1.2345000022229158e-10
        self.DEGREE: int = 1610612976
        self.DELAY_REFRESH: int = 1610612853
        self.DELTA: int = 1610613001
        self.DELTATIME: int = 1610613373
        self.DENSITY: int = 1610613413
        self.DESCRIPTION: int = 1610612740
        self.DIAMETER: int = 1610613597
        self.DIFFUSE_COMPONENT: int = 2
        self.DIMENSION: int = 1610613656
        self.DIMENSION2: int = 1610613260
        self.DIMENSION2STEP: int = 1610613261
        self.DIMENSION3: int = 1610613262
        self.DIMENSION3STEP: int = 1610613263
        self.DIMENSIONS: int = 1610613007
        self.DIRECTION: int = 1610613070
        self.DIRECTIONVECTOR: int = 1610613469
        self.DIRENTRY_DIR: int = 8
        self.DIRENTRY_READABLE: int = 1
        self.DIRENTRY_SYMLINK: int = 4
        self.DIRENTRY_WRITABLE: int = 2
        self.DISPLACEBY: int = 1610613167
        self.DISPLACEFACTOR: int = 1610613168
        self.DISPLAYCOMPRESSION: int = 1610613438
        self.DISPLAYMAJOR: int = 1610613439
        self.DISPLAYMIDDLE: int = 1610613440
        self.DISPLAYMINOR: int = 1610613441
        self.DISPLAYOFFSET: int = 1610613384
        self.DISPLAYTENSION: int = 1610613437
        self.DISPLAYUNDEFINED: int = 1610613560
        self.DISPLAY_THEME: int = 1610612854
        self.DISPLAY_THEME_NONE: int = 0
        self.DISPLAY_THEME_PRINTCOLORS: int = 1
        self.DISTANCE: int = 1610613045
        self.DISTANCE_SCALE: int = 1610613097
        self.DISTRIBUTION: int = 1610613342
        self.DOMAIN: int = 1610613005
        self.DOMAINBOX: int = 1610613280
        self.DOMAINXYZRTZLINE: int = 1610613257
        self.DOUBLESIDED: int = 1610613132
        self.DTA_BLOCK: int = 1677721601
        self.EDIT_TARGET: int = 1610612749
        self.ELEMCOUNT: int = 1610613006
        self.ELEMID: int = 1610613832
        self.ELE_FAILED_EQUAL: int = 3
        self.ELE_FAILED_GREATER: int = 1
        self.ELE_FAILED_LESS: int = 2
        self.ELE_FAILED_LOGIC_AND: int = 1
        self.ELE_FAILED_LOGIC_NONE: int = 0
        self.ELE_FAILED_LOGIC_OR: int = 2
        self.ELE_FAILED_NOT_EQUAL: int = 4
        self.ELTBLANKING: int = 1610613188
        self.ELTDEFINEDBY: int = 1610613197
        self.ELTFEATUREANGLE: int = 1610613183
        self.ELTFILTER1ACTIVE: int = 1610613207
        self.ELTFILTER1TESTOP: int = 1610613210
        self.ELTFILTER1TESTVALUE: int = 1610613211
        self.ELTFILTER1TESTVARCOMP: int = 1610613213
        self.ELTFILTER1TESTVARIABLE: int = 1610613212
        self.ELTFILTER1VARCOMP: int = 1610613209
        self.ELTFILTER1VARIABLE: int = 1610613208
        self.ELTFILTER2ACTIVE: int = 1610613214
        self.ELTFILTER2LOGICALOP: int = 1610613215
        self.ELTFILTER2TESTOP: int = 1610613218
        self.ELTFILTER2TESTVALUE: int = 1610613219
        self.ELTFILTER2TESTVARCOMP: int = 1610613221
        self.ELTFILTER2TESTVARIABLE: int = 1610613220
        self.ELTFILTER2VARCOMP: int = 1610613217
        self.ELTFILTER2VARIABLE: int = 1610613216
        self.ELTFILTER3ACTIVE: int = 1610613222
        self.ELTFILTER3LOGICALOP: int = 1610613223
        self.ELTFILTER3TESTOP: int = 1610613226
        self.ELTFILTER3TESTVALUE: int = 1610613227
        self.ELTFILTER3TESTVARCOMP: int = 1610613229
        self.ELTFILTER3TESTVARIABLE: int = 1610613228
        self.ELTFILTER3VARCOMP: int = 1610613225
        self.ELTFILTER3VARIABLE: int = 1610613224
        self.ELTFILTER4ACTIVE: int = 1610613230
        self.ELTFILTER4LOGICALOP: int = 1610613231
        self.ELTFILTER4TESTOP: int = 1610613234
        self.ELTFILTER4TESTVALUE: int = 1610613235
        self.ELTFILTER4TESTVARCOMP: int = 1610613237
        self.ELTFILTER4TESTVARIABLE: int = 1610613236
        self.ELTFILTER4VARCOMP: int = 1610613233
        self.ELTFILTER4VARIABLE: int = 1610613232
        self.ELTFILTER5ACTIVE: int = 1610613238
        self.ELTFILTER5LOGICALOP: int = 1610613239
        self.ELTFILTER5TESTOP: int = 1610613242
        self.ELTFILTER5TESTVALUE: int = 1610613243
        self.ELTFILTER5TESTVARCOMP: int = 1610613245
        self.ELTFILTER5TESTVARIABLE: int = 1610613244
        self.ELTFILTER5VARCOMP: int = 1610613241
        self.ELTFILTER5VARIABLE: int = 1610613240
        self.ELTFILTER6ACTIVE: int = 1610613246
        self.ELTFILTER6LOGICALOP: int = 1610613247
        self.ELTFILTER6TESTOP: int = 1610613250
        self.ELTFILTER6TESTVALUE: int = 1610613251
        self.ELTFILTER6TESTVARCOMP: int = 1610613253
        self.ELTFILTER6TESTVARIABLE: int = 1610613252
        self.ELTFILTER6VARCOMP: int = 1610613249
        self.ELTFILTER6VARIABLE: int = 1610613248
        self.ELTREPPOINTSNORMALS: int = 1610613184
        self.ELTREPRESENTATION: int = 1610613182
        self.ELTSHRINKFACTOR: int = 1610613187
        self.EMISSIVE_COMPONENT: int = 256
        self.EMITATCURRENTTIME: int = 1610613371
        self.EMITTERS: int = 1610612803
        self.ENDPOINT: int = 1610613338
        self.ENDSIMTIME: int = 1610613822
        self.ENSHELL_LOG: int = 1610612921
        self.ENSJLC_DR_EPILOGUE: int = 7111
        self.ENSJLC_DR_NAME: int = 7109
        self.ENSJLC_DR_PROLOGUE: int = 7110
        self.ENSJLC_HUB_EPILOGUE: int = 7108
        self.ENSJLC_HUB_NAME: int = 7106
        self.ENSJLC_HUB_PROLOGUE: int = 7107
        self.ENSJLC_SERVER_EPILOGUE: int = 7102
        self.ENSJLC_SERVER_NAME: int = 7100
        self.ENSJLC_SERVER_PROLOGUE: int = 7101
        self.ENSJLC_SOS_EPILOGUE: int = 7105
        self.ENSJLC_SOS_NAME: int = 7103
        self.ENSJLC_SOS_PROLOGUE: int = 7104
        self.ENSMODEL_FLUSH_ALL: int = 65535
        self.ENSMODEL_FLUSH_FEATURES: int = 2
        self.ENSMODEL_FLUSH_MODELS: int = 1
        self.ENSMODEL_FLUSH_NONE: int = 0
        self.ENSMODEL_SHOW_ANNOTS: int = 4
        self.ENSMODEL_SHOW_ANY: int = 511
        self.ENSMODEL_SHOW_CALCTOOLS: int = 128
        self.ENSMODEL_SHOW_CASES: int = 1
        self.ENSMODEL_SHOW_FRAMES: int = 64
        self.ENSMODEL_SHOW_NONE: int = 0
        self.ENSMODEL_SHOW_PLOTTERS: int = 16
        self.ENSMODEL_SHOW_QUERIES: int = 8
        self.ENSMODEL_SHOW_VARS: int = 2
        self.ENSMODEL_SHOW_VIEWPORTS: int = 32
        self.ENSMODEL_UPDATE_ATTR_UPDATE: int = 4
        self.ENSMODEL_UPDATE_CTOR: int = 1
        self.ENSMODEL_UPDATE_DTOR: int = 2
        self.ENSMODEL_UPDATE_SELECTION: int = 16
        self.ENSMODEL_UPDATE_SELECTION_FED: int = 32
        self.ENS_ATTR_EMITTERLIST: int = 1610612723
        self.ENS_ATTR_ENSLEGENDOBJ: int = 1610612730
        self.ENS_ATTR_ENSPARTOBJ: int = 1610612729
        self.ENS_ATTR_ENSPLOTOBJ: int = 1610612728
        self.ENS_ATTR_ENSVARCOMP: int = 1610612731
        self.ENS_ATTR_ENSVAROBJ: int = 1610612732
        self.ENS_ATTR_MATRIX44: int = 1610612727
        self.ENS_ATTR_METADATATYPE: int = 1610612722
        self.ENS_ATTR_METATAG_BASE: int = 1677721600
        self.ENS_ATTR_OBJECT_DTOR: int = 1610612925
        self.ENS_ATTR_PALETTEOBJ: int = 1610612725
        self.ENS_ATTR_PYDICTIONARY: int = 1610612734
        self.ENS_ATTR_PYDICTLIST: int = 1610612735
        self.ENS_ATTR_PYOBJECT: int = 1610612733
        self.ENS_ATTR_QUATERNION: int = 1610612726
        self.ENS_ATTR_SOURCEOBJ: int = 1610612720
        self.ENS_ATTR_STATEOBJ: int = 1610612719
        self.ENS_ATTR_TEXTUREOBJ: int = 1610612724
        self.ENS_ATTR_USERDEF_BASE: int = 1744830464
        self.ENS_ATTR_VAR_CONST: int = 524288
        self.ENS_ATTR_VAR_CONST_PER_PART: int = 536870912
        self.ENS_ATTR_VAR_COORD: int = 2097152
        self.ENS_ATTR_VAR_ELEM: int = 67108864
        self.ENS_ATTR_VAR_FILTER: int = 65536
        self.ENS_ATTR_VAR_MODEL: int = 134217728
        self.ENS_ATTR_VAR_NODE: int = 33554432
        self.ENS_ATTR_VAR_NONE_ILLEGAL: int = 268435456
        self.ENS_ATTR_VAR_SCALAR: int = 131072
        self.ENS_ATTR_VAR_SCLCOMPLEX: int = 8388608
        self.ENS_ATTR_VAR_TENSOR: int = 1048576
        self.ENS_ATTR_VAR_TIME: int = 4194304
        self.ENS_ATTR_VAR_VCTCOMPLEX: int = 16777216
        self.ENS_ATTR_VAR_VECTOR: int = 262144
        self.ENS_DEFPATH_CMDPLY: int = 2
        self.ENS_DEFPATH_CMDREC: int = 3
        self.ENS_DEFPATH_GBLMACRO: int = 4
        self.ENS_DEFPATH_IMAGE: int = 7
        self.ENS_DEFPATH_LCLMACRO: int = 5
        self.ENS_DEFPATH_MISC: int = 6
        self.ENS_DEFPATH_PYEDIT: int = 1
        self.ENS_DEFPATH_REMOTE: int = 10
        self.ENS_DEFPATH_SCENARIO: int = 9
        self.ENS_DEFPATH_TEXTURE: int = 0
        self.ENS_DEFPATH_VIDEO: int = 8
        self.ENS_DETAILS: int = 1677721603
        self.ENS_FEATURE_ACTIONBAR: int = 1
        self.ENS_FEATURE_FDEWIDGET: int = 2
        self.ENS_FEATURE_FEATUREBAR: int = 0
        self.ENS_KIND: int = 1677721602
        self.ENS_MAINWIN: int = 3
        self.ENS_MAINWINMENUS: int = 5
        self.ENS_MATERIAL: int = 1677721604
        self.ENS_PANELPARENT: int = 4
        self.ENS_PARENT_PART: int = 1677721605
        self.ENS_PLIST_KEY_SEL_0: int = 1677721606
        self.ENS_PLIST_KEY_SEL_1: int = 1677721607
        self.ENS_PLIST_KEY_SEL_2: int = 1677721608
        self.ENS_PLIST_KEY_SEL_3: int = 1677721609
        self.ENS_PLIST_KEY_SEL_4: int = 1677721610
        self.ENS_PLIST_KEY_SEL_5: int = 1677721611
        self.ENS_PLIST_KEY_SEL_6: int = 1677721612
        self.ENS_PLIST_KEY_SEL_7: int = 1677721613
        self.ENS_PLIST_KEY_SEL_8: int = 1677721614
        self.ENS_PLIST_KEY_SEL_9: int = 1677721615
        self.ENS_SYMMETRY_AXIS: int = 1677721620
        self.ENS_SYMMETRY_COUNT: int = 1677721621
        self.ENS_TURBO_ANNO: int = 1677721626
        self.ENS_TURBO_STAGE: int = 1677721622
        self.ENS_TURBO_VDIM: int = 1677721624
        self.ENS_TURBO_VIEW: int = 1677721623
        self.ENS_TURBO_VPORT: int = 1677721625
        self.ENS_UNITS_DIMS: int = 1677721617
        self.ENS_UNITS_LABEL: int = 1677721616
        self.ENS_UNITS_SYSTEM_NAME: int = 1677721618
        self.ENS_VAR_CASE: int = 8
        self.ENS_VAR_CONSTANT: int = 5
        self.ENS_VAR_CONSTANT_PER_PART: int = 9
        self.ENS_VAR_COORDS: int = 7
        self.ENS_VAR_ELEM: int = 1
        self.ENS_VAR_ENOD: int = 3
        self.ENS_VAR_NODE: int = 2
        self.ENS_VAR_SCALAR: int = 0
        self.ENS_VAR_SCALAR_COMPLEX: int = 3
        self.ENS_VAR_TENSOR: int = 2
        self.ENS_VAR_TIME_FUNC: int = 6
        self.ENS_VAR_UNKNOWN: int = -1
        self.ENS_VAR_VECTOR: int = 1
        self.ENS_VAR_VECTOR_COMPLEX: int = 4
        self.ENTHALPY: int = 1610613459
        self.ENTITYLABELELT: int = 1610613181
        self.ENTITYLABELNODE: int = 1610613170
        self.ENVMAP_SAVEDINFO: int = 1610613116
        self.EPSILON: int = 1610613477
        self.EQUATION: int = 1610613327
        self.EXIST_CASE: int = 1610612962
        self.EXPRESSION: int = 1610612958
        self.EXTENTS: int = 1610613256
        self.E_FORMAT: int = 1
        self.FACEAREAFRACTION: int = 1610613473
        self.FACEXMAXGRID: int = 1610613747
        self.FACEXMAXGRIDFILTER: int = 1610613751
        self.FACEXMAXSUBGRID: int = 1610613750
        self.FACEXMINGRID: int = 1610613734
        self.FACEXMINGRIDFILTER: int = 1610613742
        self.FACEXMINSUBGRID: int = 1610613735
        self.FACEYMAXGRID: int = 1610613745
        self.FACEYMAXGRIDFILTER: int = 1610613748
        self.FACEYMAXSUBGRID: int = 1610613746
        self.FACEYMINGRID: int = 1610613736
        self.FACEYMINGRIDFILTER: int = 1610613738
        self.FACEYMINSUBGRID: int = 1610613737
        self.FACEZMAXGRID: int = 1610613743
        self.FACEZMAXGRIDFILTER: int = 1610613744
        self.FACEZMAXSUBGRID: int = 1610613749
        self.FACEZMINGRID: int = 1610613739
        self.FACEZMINGRIDFILTER: int = 1610613741
        self.FACEZMINSUBGRID: int = 1610613740
        self.FALSE: int = 0
        self.FASTDISPLAY: int = 1610612862
        self.FEATURE_ANGLE: int = 2
        self.FEATURE_FULL: int = 6
        self.FEA_VAR: int = 1677721619
        self.FILENAME: int = 1610613051
        self.FILL: int = 1610613596
        self.FILLPATTERN: int = 1610613121
        self.FLIPBOOKS: int = 1610612851
        self.FLOATINGZCLIP: int = 1610612895
        self.FLOW3DINFO: int = 1610613008
        self.FLUENTTEXTUREAXIS: int = 1610613150
        self.FLUENTTEXTUREROTANGLE: int = 1610613149
        self.FLUENTTEXTURESCALE: int = 1610613148
        self.FNC_BAND: int = 10
        self.FNC_CONST: int = 30
        self.FNC_CONTIN: int = 20
        self.FNC_LIMCOL: int = 20
        self.FNC_LIMVIS: int = 30
        self.FNC_LINEAR: int = 10
        self.FNC_LOG: int = 20
        self.FNC_NOLIMIT: int = 10
        self.FNC_QUAD: int = 30
        self.FONTFAMILIES: int = 1610612845
        self.FORMAT: int = 1610613551
        self.FRAMES: int = 1610612823
        self.FRAME_DURATION: int = 1610612875
        self.FRST_ARRW: int = 1
        self.FULL: int = 3
        self.FULLSCREEN: int = 1610612887
        self.FX_SEPNATT_PARALLEL_VECTOR: int = 1
        self.FX_SEPNATT_PHASE_PLANE: int = 0
        self.FX_SHOCK_REGION: int = 0
        self.FX_SHOCK_SURFACE: int = 1
        self.FX_VCORE_EIGENANALYSIS: int = 1
        self.FX_VCORE_VORTICITY: int = 0
        self.F_FORMAT: int = 0
        self.GASCONSTANT: int = 1610613462
        self.GENERATEOVER: int = 1610613842
        self.GENERATION_PENDING: int = 1610612766
        self.GEOMETRICTYPE: int = 1610613489
        self.GEOMETRY_FORM: int = 1610612778
        self.GEOMS: int = 1610612827
        self.GEOM_CONN_CHANGE: int = 4
        self.GEOM_COORD_CHANGE: int = 2
        self.GEOM_NO_CHANGE: int = 1
        self.GLASS_MATERIAL: int = 1
        self.GLOBALAXISLOCATION: int = 1610613649
        self.GLOBALAXISVISIBLE: int = 1610613648
        self.GLOBALAXISXLABEL: int = 1610613012
        self.GLOBALAXISYLABEL: int = 1610613013
        self.GLOBALAXISZLABEL: int = 1610613014
        self.GRIDLINETYPE: int = 1610613660
        self.GRIDLINEWIDTH: int = 1610613659
        self.GRIDPTS: int = 1610613276
        self.GRIDRGB: int = 1610613661
        self.GROUND_ACTIVE: int = 1610613101
        self.GROUND_BLENDSCALE: int = 1610613103
        self.GROUND_COLOR: int = 1610613106
        self.GROUND_GRIDCOLORA: int = 1610613107
        self.GROUND_GRIDCOLORB: int = 1610613108
        self.GROUND_GRIDSCALE: int = 1610613105
        self.GROUND_HASGRID: int = 1610613113
        self.GROUND_HASREFL: int = 1610613109
        self.GROUND_HASSHADOW: int = 1610613110
        self.GROUND_HASTEXTURE: int = 1610613112
        self.GROUND_HEIGHTOFFSET: int = 1610613114
        self.GROUND_LOCK: int = 1610613111
        self.GROUND_SAVEDINFO: int = 1610613115
        self.GROUND_TEXSCALE: int = 1610613104
        self.GROUND_UPDIR: int = 1610613102
        self.GROUPS: int = 1610612815
        self.GRPC_UDS_PATHNAME: int = 1610612866
        self.GRP_COLLAPSE: int = 0
        self.GRP_EXPAND: int = 1
        self.HANDLES_ENABLED: int = 1610612752
        self.HANDLE_UNDEFINED_VALUE: int = 1610612978
        self.HAS0DELEMENTS: int = 1610612804
        self.HAS1DELEMENTS: int = 1610612805
        self.HAS2DELEMENTS: int = 1610612806
        self.HAS3DELEMENTS: int = 1610612807
        self.HASTRANSPARENT: int = 1610613056
        self.HEADDETAIL: int = 1610613622
        self.HEADSCALE: int = 1610613623
        self.HEADSIZEBY: int = 1610613624
        self.HEADTYPE: int = 1610613621
        self.HEADVARIABLE: int = 1610613625
        self.HEIGHT: int = 1610613546
        self.HIDDENLINE: int = 1610612856
        self.HIDDENLINE_RGB: int = 1610612857
        self.HIDDENLINE_USE_RGB: int = 1610612859
        self.HIDDENLINE_WEIGHT: int = 1610612858
        self.HIDDENSURFACE: int = 1610613190
        self.HILITE_BACK_COLOR_FILL: int = 1610612894
        self.HILITE_METHOD: int = 1610612889
        self.HILITE_SELECT_COLOR: int = 1610612892
        self.HILITE_SELECT_COLOR_FILL: int = 1610612893
        self.HILITE_TARGET_COLOR: int = 1610612890
        self.HILITE_TARGET_COLOR_FILL: int = 1610612891
        self.HISTO_SCALE: int = 1610612993
        self.HTML: int = 1610612756
        self.ICON_SIZE: int = 1610613076
        self.ID: int = 1610612743
        self.IJK: int = 1610613831
        self.IJKAXIS: int = 1610613194
        self.IJKAXISSCALE: int = 1610613195
        self.IJKSCALE: int = 1610613264
        self.IMAGE: int = 1610613052
        self.INDEX: int = 1610612744
        self.INPLANE1: int = 1610613410
        self.INPLANE2: int = 1610613411
        self.INPLANE3: int = 1610613412
        self.INTENSITY: int = 1610613073
        self.INTERACTIVEAUTODELTA: int = 1610613362
        self.INTERACTIVERANGEMAX: int = 1610613361
        self.INTERACTIVERANGEMIN: int = 1610613360
        self.INTERACTIVESTEP: int = 1610613485
        self.INTERACTIVEXMAX: int = 1610613480
        self.INTERACTIVEXMIN: int = 1610613479
        self.INTERACTIVEYMAX: int = 1610613482
        self.INTERACTIVEYMIN: int = 1610613481
        self.INTERACTIVEZMAX: int = 1610613484
        self.INTERACTIVEZMIN: int = 1610613483
        self.INTERP: int = 1610612973
        self.INT_QUERY_ELEMID: int = 3
        self.INT_QUERY_EXACT: int = 1
        self.INT_QUERY_IJK: int = 4
        self.INT_QUERY_MAX: int = 8
        self.INT_QUERY_MIN: int = 7
        self.INT_QUERY_NODE: int = 0
        self.INT_QUERY_NODEID: int = 5
        self.INT_QUERY_NONE: int = 0
        self.INT_QUERY_POINT: int = 2
        self.INT_QUERY_SURFACE: int = 1
        self.INT_QUERY_XYZ: int = 6
        self.ISGROUP: int = 1610612800
        self.ISO_SURF_SOLID: int = 1
        self.ISO_SURF_SURFACE: int = 0
        self.JLCS: int = 1610612843
        self.JOBINFO: int = 1610612774
        self.JUSTIFICATION: int = 1610613519
        self.KEYFRAMEDATA: int = 1610612841
        self.LABELALWAYSONTOP: int = 1610613849
        self.LABELAUTOVISIBLE: int = 1610613347
        self.LABELCOUNT: int = 1610613557
        self.LABELCUSTOMVISIBLE: int = 1610613355
        self.LABELDECIMALPLACES: int = 1610613352
        self.LABELFORMAT: int = 1610613351
        self.LABELOFFSET: int = 1610613577
        self.LABELORIENTATION: int = 1610613354
        self.LABELRGB: int = 1610613349
        self.LABELSIZE: int = 1610613353
        self.LABELSIZE2D: int = 1610613657
        self.LABELSIZE3D: int = 1610613658
        self.LABELSPACING: int = 1610613350
        self.LABELTEXT: int = 1610613573
        self.LABELTEXTID: int = 1610613531
        self.LABELVISIBLE: int = 1610613348
        self.LANGUAGE_INFO: int = 1610612902
        self.LAST_DATA_RELOAD: int = 1610612792
        self.LEGEND: int = 1610612961
        self.LEGENDCOLORBY: int = 1610613766
        self.LEGENDMINMAXORIGINX: int = 1610613769
        self.LEGENDMINMAXORIGINY: int = 1610613770
        self.LEGENDMINMAXTEXTSIZE: int = 1610613771
        self.LEGENDMINMAXVISIBLE: int = 1610613768
        self.LEGENDORIGINX: int = 1610613763
        self.LEGENDORIGINY: int = 1610613764
        self.LEGENDRGB: int = 1610613767
        self.LEGENDTEXTSIZE: int = 1610613765
        self.LEGENDTITLE: int = 1610613808
        self.LEGENDTYPE: int = 1610613554
        self.LEGENDVISIBLE: int = 1610613762
        self.LEGEND_CONT: int = 0
        self.LEGEND_DISC: int = 1
        self.LEGEND_LEFT: int = 0
        self.LEGEND_RIGHT: int = 1
        self.LEGEND_TITLE_BOTTOM: int = 1
        self.LEGEND_TITLE_TOP: int = 0
        self.LEGEND_TITLE_VISOFF: int = 2
        self.LEGEND_TXT_VISOFF: int = 2
        self.LENGTH: int = 1610613599
        self.LENS: int = 1610613083
        self.LEVELRGB: int = 1610613595
        self.LEVELS: int = 1610613343
        self.LEVELSVISIBLE: int = 1610613345
        self.LEVELS_AND_COLORS: int = 1610612990
        self.LEVELS_LOCK: int = 1610612991
        self.LIGHT1AZIMUTH: int = 1610613642
        self.LIGHT1ELEVATION: int = 1610613643
        self.LIGHT1POSITION: int = 1610613641
        self.LIGHT2INTENSITY: int = 1610613644
        self.LIGHTAMBIENT: int = 1610613122
        self.LIGHTDIFF: int = 1610613562
        self.LIGHTDIFFUSE: int = 1610613123
        self.LIGHTEMISSIVE: int = 1610613124
        self.LIGHTHINT: int = 1610613564
        self.LIGHTREFRACTION: int = 1610613129
        self.LIGHTSHIN: int = 1610613563
        self.LIGHTSOURCES: int = 1610612824
        self.LIGHTSPECULARINTENSITY: int = 1610613126
        self.LIGHTSPECULARREFLECTION: int = 1610613127
        self.LIGHTSPECULARSHINE: int = 1610613125
        self.LIGHTSPECULARTINT: int = 1610613128
        self.LIGHT_AREA_ENV: int = 5
        self.LIGHT_AREA_QUAD: int = 3
        self.LIGHT_AT_CAMERA: int = 4
        self.LIGHT_DIRECTIONAL: int = 0
        self.LIGHT_ENV_TEXNUM: int = 1610613081
        self.LIGHT_POINT: int = 2
        self.LIGHT_QUAD_SIZE: int = 1610613080
        self.LIGHT_QUAD_XDIR: int = 1610613079
        self.LIGHT_SOURCE_ABSOLUTE: int = 1
        self.LIGHT_SOURCE_RELATIVE: int = 0
        self.LIGHT_SPOT: int = 1
        self.LIGHT_TYPE: int = 1610613069
        self.LIMITFRINGES: int = 1610613559
        self.LIMIT_FRINGES: int = 1610612980
        self.LINES: int = 1
        self.LINESTYLE: int = 1610613179
        self.LINETYPE: int = 1610613809
        self.LINEWIDTH: int = 1610613035
        self.LINEWIDTHBY: int = 1610613446
        self.LINE_DOTDSH: int = 2
        self.LINE_DOTTED: int = 1
        self.LINE_SOLID: int = 0
        self.LINKED: int = 1610613020
        self.LINK_GROUP1: int = 1
        self.LITTLEHAND: int = 1610613583
        self.LITTLEHANDRANGE: int = 1610613585
        self.LITTLEHANDRGB: int = 1610613584
        self.LOCATION: int = 1610612954
        self.LOCATIONX: int = 1610613526
        self.LOCATIONX1: int = 1610613532
        self.LOCATIONX2: int = 1610613534
        self.LOCATIONY: int = 1610613527
        self.LOCATIONY1: int = 1610613533
        self.LOCATIONY2: int = 1610613535
        self.LOCK_DIRECTION: int = 1610613078
        self.LOGO_DATA: int = 1610612759
        self.LOOKATPOINT: int = 1610613016
        self.LOOKAT_NODE_ID: int = 1610613087
        self.LOOKAT_OPTION: int = 1610613085
        self.LOOKAT_PART_ID: int = 1610613086
        self.LOOKAT_SPLINE_ID: int = 1610613088
        self.LOOKAT_SPLINE_VALUE: int = 1610613089
        self.LOOKAT_XYZ: int = 1610613090
        self.LOOKFROMPOINT: int = 1610613017
        self.LPARTNUMELE: int = 1610612780
        self.LPARTPARENT: int = 1610612798
        self.LPARTS: int = 1610612777
        self.LPARTS_OFF: int = 0
        self.LPARTS_ON: int = 1
        self.LPARTS_SELECTIVE: int = 2
        self.MACH: int = 1610613460
        self.MACHINEARCH: int = 1610612768
        self.MARKER: int = 1610613811
        self.MARKERRGB: int = 1610613817
        self.MARKERSCALE: int = 1610613812
        self.MARKERSIZENORMALIZED: int = 1610613818
        self.MARKERVISIBLE: int = 1610613816
        self.MARKER_COLOR: int = 1610612987
        self.MARKER_CROSS: int = 1
        self.MARKER_DOT: int = 0
        self.MARKER_SCREENSPACE_SURFACE: int = 3
        self.MARKER_SIZE_CONSTANT: int = 0
        self.MARKER_SIZE_SCALAR: int = 1
        self.MARKER_SIZE_VECMAG: int = 2
        self.MARKER_SIZE_VECXCOMP: int = 3
        self.MARKER_SIZE_VECYCOMP: int = 4
        self.MARKER_SIZE_VECZCOMP: int = 5
        self.MARKER_SPHER: int = 2
        self.MARKER_USER_DEFINED: int = 4
        self.MARKER_WIDTH: int = 1610612988
        self.MASSEDBALLISTICCOEF: int = 1610613394
        self.MASSEDBUOYANCY: int = 1610613401
        self.MASSEDCOEFFRICTION: int = 1610613406
        self.MASSEDCOEFRESTITUTION: int = 1610613405
        self.MASSEDDRAG: int = 1610613386
        self.MASSEDDRAGCOEFFICIENT: int = 1610613389
        self.MASSEDDRAGCOEFFICIENTVAL: int = 1610613390
        self.MASSEDFLUIDDENSITY: int = 1610613396
        self.MASSEDFLUIDDENSITYVAL: int = 1610613398
        self.MASSEDFLUIDVISCOSITY: int = 1610613391
        self.MASSEDFLUIDVISCOSITYVAL: int = 1610613392
        self.MASSEDGRAVITY: int = 1610613399
        self.MASSEDGRAVITYVECTOR: int = 1610613400
        self.MASSEDINITIALUSEFLUID: int = 1610613395
        self.MASSEDINITIALVELOCITY: int = 1610613397
        self.MASSEDPARTICLEDENSITY: int = 1610613388
        self.MASSEDPARTICLEDIAMETER: int = 1610613387
        self.MASSEDPARTICLES: int = 1610613385
        self.MASSEDPRESSURE: int = 1610613402
        self.MASSEDPRESSUREGRADIENT: int = 1610613403
        self.MASSEDREBOUND: int = 1610613404
        self.MASSEDREBOUNDFRACTION: int = 1610613407
        self.MASSEDREBOUNDWALLHITS: int = 1610613408
        self.MASSEDUSEBALLISTIC: int = 1610613393
        self.MATERIALBASETYPE: int = 1610613118
        self.MATERIALDESCRIPTION: int = 1610612809
        self.MATERIALS: int = 1610612819
        self.MATRIX: int = 1610613031
        self.MATTE_MATERIAL: int = 3
        self.MAX: int = 1610613358
        self.MAXANGLE: int = 1610613376
        self.MAXIMUM: int = 1610613591
        self.MAXTIME: int = 1610613617
        self.MAX_MARKERS: int = 1610612986
        self.MAX_TRACK: int = 4
        self.MESHPLANE: int = 1610613334
        self.MESHPLANEIJK: int = 1610613258
        self.MESHPLANERTZ: int = 1610613267
        self.MESHPLANEXYZ: int = 1610613266
        self.MESHRESOLUTION: int = 1610613513
        self.MESHTYPE: int = 1610612737
        self.MESH_2D: int = 2
        self.MESH_2D_X: int = 4
        self.MESH_2D_Y: int = 8
        self.MESH_2D_Z: int = 16
        self.MESH_3D: int = 1
        self.MESH_LINE: int = 32
        self.MESH_NONE: int = 0
        self.MESH_SLICEI: int = 0
        self.MESH_SLICEJ: int = 1
        self.MESH_SLICEK: int = 2
        self.MESH_SLICE_RTZ_R: int = 0
        self.MESH_SLICE_RTZ_T: int = 1
        self.MESH_SLICE_RTZ_Z: int = 2
        self.MESH_SLICE_X: int = 0
        self.MESH_SLICE_Y: int = 1
        self.MESH_SLICE_Z: int = 2
        self.MESH_TRIS: int = 64
        self.METADATA: int = 1610612746
        self.METALLICPAINT_MATERIAL: int = 5
        self.METAL_MATERIAL: int = 6
        self.METHOD: int = 1610613452
        self.MFNTS_JUMP_TO_END: int = 3
        self.MFNTS_OFF: int = 2
        self.MFNTS_STAY_AT_CURRENT: int = 4
        self.MIN: int = 1610613357
        self.MINANGLE: int = 1610613375
        self.MINIMUM: int = 1610613581
        self.MINMAX: int = 1610612959
        self.MINMAXCONST: int = 1610612969
        self.MINSTEPS: int = 1610613374
        self.MIN_TRACK: int = 3
        self.MIRRORORIGINAL: int = 1610613152
        self.MIRROR_MATERIAL: int = 7
        self.MI_ALG_SMOOTH: int = 0
        self.MI_ALG_YOUNGS: int = 1
        self.MI_TYPE_DOMAIN: int = 1
        self.MI_TYPE_INTERFACE: int = 0
        self.MODEL_RECORD_CMD_LANG_GLOBAL: int = 3
        self.MODEL_RECORD_CMD_LANG_HONOR: int = 2
        self.MODEL_RECORD_CMD_LANG_OFF: int = 0
        self.MODEL_RECORD_CMD_LANG_ON: int = 1
        self.MOMENTUM: int = 1610613449
        self.MOUSE_ACTION_NONE: int = 13
        self.MOUSE_BTN_ALL: int = 7
        self.MOUSE_BTN_LEFT: int = 4
        self.MOUSE_BTN_LEFT_MIDDLE: int = 6
        self.MOUSE_BTN_LEFT_RIGHT: int = 5
        self.MOUSE_BTN_MIDDLE: int = 2
        self.MOUSE_BTN_RIGHT: int = 1
        self.MOUSE_BTN_RIGHT_MIDDLE: int = 3
        self.MOUSE_NORMAL_ACTION: int = 10
        self.MOUSE_PICK_ACTION: int = 11
        self.MOUSE_PICK_BLANK_ELEMENTS: int = 9
        self.MOUSE_PICK_CURSOR: int = 7
        self.MOUSE_PICK_PART: int = 5
        self.MOUSE_PICK_PART_OPTIONS: int = 12
        self.MOUSE_PICK_TRANSFORM_CENTER: int = 6
        self.MOUSE_ROTATE: int = 0
        self.MOUSE_SELECT_TOOL: int = 4
        self.MOUSE_TRANSLATE: int = 1
        self.MOUSE_USER_DEFINED: int = 14
        self.MOUSE_ZOOM: int = 2
        self.MOUSE_ZOOMBAND: int = 3
        self.MRU: int = 1610612842
        self.MULTIPLEPULSES: int = 1610613618
        self.MULTIPLESEGMENTSBY: int = 1610613825
        self.NEGATIVE_SURFACE_DIRECTION: int = 1
        self.NEG_TIME: int = 1
        self.NLEVELS: int = 1610612989
        self.NODEDETAIL: int = 1610613175
        self.NODEID: int = 1610613379
        self.NODEMAX: int = 1610613003
        self.NODEMIN: int = 1610613002
        self.NODEORIENTATIONANGLE: int = 1610613177
        self.NODEORIENTATIONAXIS: int = 1610613176
        self.NODERANGESTEPI: int = 1610613204
        self.NODERANGESTEPJ: int = 1610613205
        self.NODERANGESTEPK: int = 1610613206
        self.NODESCALE: int = 1610613174
        self.NODESIZEBY: int = 1610613172
        self.NODESTEP: int = 1610613004
        self.NODETYPE: int = 1610613171
        self.NODEVARIABLE: int = 1610613173
        self.NODE_LOCK: int = 1610612981
        self.NODE_TRACKS: int = 2
        self.NORMAL: int = 1610613047
        self.NORMALIZEDWIDTH: int = 1610613543
        self.NORMALIZEX: int = 1610613813
        self.NORMALIZEY: int = 1610613814
        self.NORMALSPOINT: int = 1610613515
        self.NOTLOAD_FULL: int = 7
        self.NOT_LOADED: int = 4
        self.NO_ARRW: int = 0
        self.NO_TRACKING: int = 0
        self.NUMCONTROLPOINTS: int = 1610613036
        self.NUMDISPLAYED: int = 1610613850
        self.NUMFRAMES: int = 1610613054
        self.NUMOFARROWS: int = 1610613368
        self.NUMOFLEVELS: int = 1610613558
        self.NUMOFSAMPLEPTS: int = 1610613824
        self.NUMOFSLICES: int = 1610613464
        self.NUMPOINTS: int = 1610613044
        self.OBJECTFOCUS: int = 1610612951
        self.OBJECT_API_JOURNAL: int = 1610612877
        self.OBJECT_DTOR: int = 1610612925
        self.OFFSET: int = 1610612813
        self.OFFSETFROMPART: int = 1610613431
        self.OFFSETSCALE: int = 1610613432
        self.OFFSETVECTOR: int = 1610613433
        self.ONE: int = 1
        self.OPAQUENESS: int = 1610613120
        self.OPERATION: int = 1610613840
        self.OPERATIONFACTOR1: int = 1610613836
        self.OPERATIONFACTOR2: int = 1610613837
        self.OPERATIONQUERY1BYNAME: int = 1610613838
        self.OPERATIONQUERY2BYNAME: int = 1610613839
        self.OPTION_NONE: int = -1
        self.ORDER: int = 1610612953
        self.ORIENTATION: int = 1610613545
        self.ORIGIN: int = 1610613336
        self.ORIGIN1: int = 1610613538
        self.ORIGIN2: int = 1610613539
        self.ORIGINBY: int = 1610613525
        self.ORIGINBY1: int = 1610613541
        self.ORIGINBY2: int = 1610613540
        self.ORIGINBYPARTCENTROID: int = 1610613467
        self.ORIGINFRAME: int = 1610613528
        self.ORIGINX: int = 1610613626
        self.ORIGINY: int = 1610613627
        self.ORIGIN_NODE_ID: int = 1610613093
        self.ORIGIN_OPTION: int = 1610613091
        self.ORIGIN_PART_ID: int = 1610613092
        self.ORIGIN_SPLINE_ID: int = 1610613094
        self.ORIGIN_SPLINE_VALUE: int = 1610613095
        self.ORIGIN_XYZ_DELTA: int = 1610613096
        self.OVERRIDEGTACTIVE: int = 1610613606
        self.OVERRIDEGTMIN: int = 1610613608
        self.OVERRIDEGTRGB: int = 1610613609
        self.OVERRIDEGTUSEABS: int = 1610613607
        self.OVERRIDELTACTIVE: int = 1610613602
        self.OVERRIDELTMIN: int = 1610613604
        self.OVERRIDELTRGB: int = 1610613605
        self.OVERRIDELTUSEABS: int = 1610613603
        self.OVERRIDERANGEACTIVE: int = 1610613610
        self.OVERRIDERANGEMAX: int = 1610613613
        self.OVERRIDERANGEMIN: int = 1610613612
        self.OVERRIDERANGERGB: int = 1610613614
        self.OVERRIDERANGEUSEABS: int = 1610613611
        self.PAGE_DETAILS: int = 1610613067
        self.PALETTE: int = 1610612965
        self.PALETTES: int = 1610612847
        self.PALETTE_ALPHA_BY_COLOR_PALETTE: int = 1
        self.PALETTE_ALPHA_NONE: int = 0
        self.PALETTE_BANDED: int = 10
        self.PALETTE_CONSTANT: int = 30
        self.PALETTE_CONTINUOUS: int = 20
        self.PALETTE_HSV: int = 20
        self.PALETTE_LIMIT_FRINGES_INVISIBLE: int = 30
        self.PALETTE_LIMIT_FRINGES_NO: int = 10
        self.PALETTE_LIMIT_FRINGES_PART_COLOR: int = 20
        self.PALETTE_LINEAR: int = 10
        self.PALETTE_NODE_LOCK_ALL: int = 10
        self.PALETTE_NODE_LOCK_COLOR: int = 20
        self.PALETTE_NODE_LOCK_NONE: int = 30
        self.PALETTE_RGB: int = 10
        self.PALETTE_SCALE_LINEAR: int = 10
        self.PALETTE_SCALE_LOG: int = 20
        self.PALETTE_SCALE_QUADRATIC: int = 30
        self.PALETTE_SPLINE: int = 20
        self.PALETTE_UNDEFINED_AS_ZERO_VALUE: int = 30
        self.PALETTE_UNDEFINED_BY_INVISIBLE: int = 20
        self.PALETTE_UNDEFINED_BY_PART_COLOR: int = 10
        self.PALETTE_UNDEFINED_BY_UNDEF_COLOR: int = 40
        self.PALID: int = 1610612960
        self.PALMISC: int = 1610612967
        self.PARENT: int = 1610612736
        self.PARTDELTAVALUE: int = 1610613830
        self.PARTHIGHLIGHT: int = 1610612840
        self.PARTICLETIME: int = 1610613620
        self.PARTID: int = 1610613468
        self.PARTMAXVALUE: int = 1610613829
        self.PARTMINVALUE: int = 1610613828
        self.PARTNUMBER: int = 1610612793
        self.PARTNUMELE: int = 1610612796
        self.PARTNUMELECLIENT: int = 1610612797
        self.PARTS: int = 1610612820
        self.PARTTYPE: int = 1610612795
        self.PARTTYPEENUM: int = 1610612794
        self.PART_AUX_GEOM: int = 25
        self.PART_AXI_SYMMETRIC: int = 22
        self.PART_BUILT_UP: int = 15
        self.PART_CLIP_PLANE: int = 1
        self.PART_CONTOUR: int = 2
        self.PART_DEVELOPED_SURFACE: int = 10
        self.PART_DISCRETE_PARTICLE: int = 3
        self.PART_ELEVATED_SURFACE: int = 9
        self.PART_FILTER_PART: int = 26
        self.PART_FRAME: int = 4
        self.PART_FX_SEP_ATT: int = 19
        self.PART_FX_SHOCK: int = 18
        self.PART_FX_VORTEX_CORE: int = 17
        self.PART_ISO_SURFACE: int = 5
        self.PART_ISO_VOLUME: int = 14
        self.PART_MATERIAL_INTERFACE: int = 20
        self.PART_MODEL: int = 0
        self.PART_MODEL_BOUNDARY: int = 13
        self.PART_MODEL_CUT: int = 12
        self.PART_MODEL_EXTRACT: int = 11
        self.PART_MODEL_MERGE: int = 23
        self.PART_MULT: int = 27
        self.PART_PARTICLE_TRACE: int = 6
        self.PART_POINT: int = 21
        self.PART_PROFILE: int = 7
        self.PART_TENSOR_GLYPH: int = 16
        self.PART_VECTOR_ARROW: int = 8
        self.PART_VOF: int = 24
        self.PATHLINE: int = 1
        self.PATHLINE_SYNC: int = 1610612884
        self.PATHNAME: int = 1610612811
        self.PERIODICSECTIONS: int = 1610613165
        self.PERSPECTIVE: int = 1610612863
        self.PERSPECTIVEANGLE: int = 1610613018
        self.PICKANDGO_PARTS: int = 1610612927
        self.PICK_SELECTION: int = 1610612883
        self.PLASTIC_MATERIAL: int = 9
        self.PLAYING_COMMAND_FILE: int = 1610612922
        self.PLOTS: int = 1610612848
        self.PLOTTER_LEGEND_COLOR_RGB: int = 0
        self.PLOTTER_LEGEND_COLOR_USE_CURVE: int = 1
        self.PLOTTER_TIME_CLIPPING: int = 1610612926
        self.PLOTTITLE: int = 1610613060
        self.PLOT_BG_NONE: int = 0
        self.PLOT_BG_SOLID: int = 1
        self.PL_TYPE_GRID: int = 1
        self.PL_TYPE_GRID_FULL: int = 2
        self.PL_TYPE_MESH: int = 0
        self.POINT1: int = 1610613040
        self.POINT2: int = 1610613041
        self.POINTS: int = 0
        self.POINTSIZE: int = 1610613034
        self.POINTVISIBLE: int = 1610613033
        self.POLYGON_OFFSET: int = 1610612812
        self.POLYLINES: int = 1610612852
        self.POSITIVE_SURFACE_DIRECTION: int = 0
        self.POS_NEG_TIME: int = 2
        self.POS_TIME: int = 0
        self.PREDEFINEDMATERIAL: int = 1610613130
        self.PREDEFINEDPALETTES: int = 1610612846
        self.PREF_DATADIR: int = 1610612911
        self.PREF_DATAFILEFILTER: int = 1610612913
        self.PREF_DATAFORMAT: int = 1610612912
        self.PRESETS: int = 1610613082
        self.PRESSURE: int = 1610613461
        self.PRIVATE: int = 1610612963
        self.PROBENUMBER: int = 1610613565
        self.PROBES: int = 1610612850
        self.PROBE_DATA: int = 1610613011
        self.PROJECTION: int = 1610613426
        self.PROJECTION_AXIS_MATERIAL: int = 0
        self.PROJECTION_AXIS_X: int = 1
        self.PROJECTION_AXIS_Y: int = 2
        self.PROJECTION_AXIS_Z: int = 3
        self.PROJECT_CREATION_MASK: int = 1610612928
        self.PROJECT_MASK: int = 1610612750
        self.PROJECT_VISIBLE_MASK: int = 1610612929
        self.PROJ_M_R: int = 4
        self.PROJ_M_THETA: int = 2
        self.PROJ_R_Z: int = 0
        self.PROJ_THETA_R: int = 5
        self.PROJ_THETA_Z: int = 1
        self.PULSEINTERVAL: int = 1610613619
        self.QRY_ASSIGN_TO_Y_AXIS_AUTO: int = 0
        self.QRY_ASSIGN_TO_Y_LEFT: int = 1
        self.QRY_ASSIGN_TO_Y_RIGHT: int = 2
        self.QRY_CONS_BY_NODE: int = 103
        self.QRY_CONS_BY_PART: int = 100
        self.QRY_CONS_BY_POINT: int = 105
        self.QRY_CONS_ELEM: int = 6
        self.QRY_CONS_IJK: int = 4
        self.QRY_CONS_LINE_TOOL: int = 1
        self.QRY_CONS_MAX_VALUE: int = 8
        self.QRY_CONS_MIN_VALUE: int = 7
        self.QRY_CONS_NO: int = 104
        self.QRY_CONS_NODE: int = 3
        self.QRY_CONS_PART: int = 0
        self.QRY_CONS_POINT: int = 5
        self.QRY_CONS_SCALAR: int = 10
        self.QRY_CONS_SCATTER_ON_PART: int = 13
        self.QRY_CONS_SPLINE: int = 9
        self.QRY_DIST_ALL: int = 3
        self.QRY_DIST_ALL_ORIGIN: int = 4
        self.QRY_DIST_X: int = 0
        self.QRY_DIST_X_ORIGIN: int = 5
        self.QRY_DIST_Y: int = 1
        self.QRY_DIST_Y_ORIGIN: int = 6
        self.QRY_DIST_Z: int = 2
        self.QRY_DIST_Z_ORIGIN: int = 7
        self.QRY_EXTERNAL: int = 2
        self.QRY_FFT: int = 1
        self.QRY_GENERATED: int = 0
        self.QRY_MSEG_ACCUMU: int = 1
        self.QRY_MSEG_RESET: int = 0
        self.QRY_OPERATE: int = 1
        self.QRY_PART_VS_CONSTANT: int = 11
        self.QRY_SCATTER_GEN_OVER_DISTANCE: int = 1
        self.QRY_SCATTER_GEN_OVER_TIME: int = 0
        self.QRY_VALUE: int = 0
        self.QRY_VARIABLE_DIST: int = -2
        self.QRY_VARIABLE_TIME: int = -3
        self.QRY_VARIABLE_UNKNOWN: int = 1
        self.QRY_VARIABLE_VAR: int = 0
        self.QUADS: int = 3
        self.QUERIES: int = 1610612849
        self.QUERY: int = 1610613846
        self.QUERYLINETOOLPOINT1: int = 1610613826
        self.QUERYLINETOOLPOINT2: int = 1610613827
        self.QUERYTYPE: int = 1610613841
        self.QUERY_DATA: int = 1610613009
        self.QUERY_PROBE_DATA: int = 1610612871
        self.QY_CMB: int = 2
        self.QY_DIF: int = 0
        self.QY_DIV: int = 4
        self.QY_INT: int = 1
        self.QY_MLT: int = 3
        self.RADII: int = 1610612755
        self.RADIUS: int = 1610613042
        self.RADIUS_SCALE: int = 1610613100
        self.RANGE: int = 1610613341
        self.RATIOOFSPECHEAT: int = 1610613451
        self.RAY_END: int = 1610613077
        self.REALTIME_AUTO: int = 2
        self.REALTIME_AUTO_CYCLE: int = 3
        self.REALTIME_CLIPS: int = 1610612870
        self.REALTIME_ISOS: int = 1610612869
        self.REALTIME_MANUAL: int = 1
        self.REALTIME_OFF: int = 0
        self.RECORDING: int = 1610612874
        self.REDUCEPOLYGONS: int = 1610613185
        self.REDUCEPOLYGONSFACTOR: int = 1610613186
        self.REFFRAME: int = 1610613192
        self.REFLECTIVE_COMPONENT: int = 32
        self.REFRACTONINDEX_COMPONENT: int = 128
        self.RELATIVETO: int = 1610613521
        self.RELATIVEVIEWPORT: int = 1610613522
        self.RELATIVEVIEWPORT1: int = 1610613536
        self.RELATIVEVIEWPORT2: int = 1610613537
        self.RELOAD_DATA: int = 16
        self.RELOAD_NONE: int = 0
        self.RELOAD_PARTS: int = 4
        self.RELOAD_QUERIES: int = 8
        self.RELOAD_TIME: int = 1
        self.RELOAD_VARS: int = 2
        self.REMOTEHOST: int = 1610612776
        self.RENDERINGREFLECTIONID: int = 1610613131
        self.REPRESENTATION: int = 1610613364
        self.REQUESTMETHOD: int = 1610613848
        self.RESET_RANGE_ON_TIME_CHANGE: int = 1610612996
        self.REV1DAXISVECT: int = 1610613303
        self.REV1DORIGIN: int = 1610613302
        self.REVERSENORMAL: int = 1610613133
        self.REVOLVEPART: int = 1610613301
        self.REVPOINTDISTANCE1: int = 1610613317
        self.REVPOINTDISTANCE10: int = 1610613326
        self.REVPOINTDISTANCE2: int = 1610613318
        self.REVPOINTDISTANCE3: int = 1610613319
        self.REVPOINTDISTANCE4: int = 1610613320
        self.REVPOINTDISTANCE5: int = 1610613321
        self.REVPOINTDISTANCE6: int = 1610613322
        self.REVPOINTDISTANCE7: int = 1610613323
        self.REVPOINTDISTANCE8: int = 1610613324
        self.REVPOINTDISTANCE9: int = 1610613325
        self.REVPOINTRADII1: int = 1610613307
        self.REVPOINTRADII10: int = 1610613316
        self.REVPOINTRADII2: int = 1610613308
        self.REVPOINTRADII3: int = 1610613309
        self.REVPOINTRADII4: int = 1610613310
        self.REVPOINTRADII5: int = 1610613311
        self.REVPOINTRADII6: int = 1610613312
        self.REVPOINTRADII7: int = 1610613313
        self.REVPOINTRADII8: int = 1610613314
        self.REVPOINTRADII9: int = 1610613315
        self.REVTOOLAXIS: int = 1610613306
        self.REVTOOLNUMPTS: int = 1610613304
        self.REVTOOLORIGIN: int = 1610613305
        self.RGB: int = 1610613518
        self.ROP_GTEQ: int = 5
        self.ROP_LTEQ: int = 3
        self.ROTANGLE: int = 1610613377
        self.ROTATION: int = 1610613027
        self.ROTATIONALANGLE: int = 1610613520
        self.ROT_SYMM_X_AXIS: int = 0
        self.ROT_SYMM_Y_AXIS: int = 1
        self.ROT_SYMM_Z_AXIS: int = 2
        self.RTZAXIS: int = 1610613269
        self.SAMPLEBY: int = 1610613823
        self.SAMPLEPOINTSLINE: int = 1610613273
        self.SAMPLEPOINTSSPLINE: int = 1610613272
        self.SAMPLETYPE: int = 1610613281
        self.SAMPLEXYZ: int = 1610613282
        self.SAMPLE_UNIFORM: int = 0
        self.SCALARVALUE: int = 1610613835
        self.SCALARVARIABLE: int = 1610613834
        self.SCALE: int = 1610613029
        self.SCALEBYLOCATIONVALUE: int = 1610613568
        self.SCALEFACTOR: int = 1610613409
        self.SCALEFACTORU: int = 1610613434
        self.SCALEFACTORV: int = 1610613435
        self.SCALEMAXFACTOR: int = 1610613572
        self.SCALEMAXVALUE: int = 1610613571
        self.SCALEMINFACTOR: int = 1610613570
        self.SCALEMINVALUE: int = 1610613569
        self.SCALE_METHOD: int = 1610612977
        self.SCENE: int = 1610612825
        self.SCND_ARRW: int = 2
        self.SEAMVECTOR: int = 1610613436
        self.SEARCH: int = 1610613847
        self.SECURITY_TOKEN: int = 1610612865
        self.SELECTED: int = 1610612742
        self.SELECTIONS: int = 1610612839
        self.SEQUENCE: int = 1610612964
        self.SERVERBYTESWAP: int = 1610612773
        self.SERVERCEIHOME: int = 1610612771
        self.SERVERCWD: int = 1610612770
        self.SERVERDIR: int = 1610612769
        self.SERVERINFO: int = 1610612775
        self.SERVERXML: int = 1610612790
        self.SETMAXTIME: int = 1610613615
        self.SEVEN: int = 7
        self.SFTBRIGHTNESS: int = 1610612785
        self.SFTCONTRAST: int = 1610612783
        self.SFTDENSITY: int = 1610612784
        self.SFTINTEGRATIONSTEP: int = 1610612789
        self.SFTLENGTH: int = 1610612788
        self.SFTNORMALIZE: int = 1610612782
        self.SFTNORMINTEGRATIONSTEP: int = 1610612787
        self.SFTNORMLENGTH: int = 1610612786
        self.SFTVARIABLE: int = 1610612781
        self.SHADING: int = 1610612855
        self.SHADOWINTENSITY: int = 1610613524
        self.SHADOWOFFSET: int = 1610613523
        self.SHAD_FLAT: int = 0
        self.SHAD_GOURAUD: int = 1
        self.SHAD_SMOOTH: int = 2
        self.SHAD_SMOOTH_REFINED: int = 3
        self.SHINYMETAL_MATERIAL: int = 10
        self.SHOWAS: int = 1610613590
        self.SHOWBACKGROUND: int = 1610613555
        self.SHOWMINMAXMARKER: int = 1610613553
        self.SHOWOUTLINE: int = 1610613514
        self.SHOWPLANEXMAX: int = 1610613508
        self.SHOWPLANEXMIN: int = 1610613507
        self.SHOWPLANEYMAX: int = 1610613510
        self.SHOWPLANEYMIN: int = 1610613509
        self.SHOWPLANEZMAX: int = 1610613512
        self.SHOWPLANEZMIN: int = 1610613511
        self.SHOWRAYTRACEDIMAGE: int = 1610613544
        self.SHOWSFT: int = 1610613151
        self.SHOW_LOCATION: int = 1610613075
        self.SHP_CONE: int = 4
        self.SHP_NONE: int = 0
        self.SHP_NORM: int = 1
        self.SHP_TIP: int = 3
        self.SHP_TRI: int = 2
        self.SIDEWALL: int = 1610613429
        self.SIZE: int = 1610613046
        self.SIZ_FIXED: int = 0
        self.SIZ_PROP: int = 1
        self.SLIDERRANGEIJK: int = 1610613331
        self.SLIDERSTEP: int = 1610613332
        self.SLIDERSTEPIJK: int = 1610613333
        self.SLIDERX: int = 1610613328
        self.SLIDERY: int = 1610613329
        self.SLIDERZ: int = 1610613330
        self.SLIM_TIMEOUT: int = 1610612924
        self.SMOOTHSUBPOINTS: int = 1610613810
        self.SNAP_NORM: int = 1610613050
        self.SNAP_SURF: int = 1610613049
        self.SOLUTIONTIME: int = 1610612881
        self.SOLUTIONTIME_LIMITS: int = 1610612880
        self.SOLUTIONTIME_MONITOR: int = 1610612949
        self.SOURCE: int = 1610612763
        self.SOURCES: int = 1610612799
        self.SPECIES: int = 1610612818
        self.SPECIFYCELLCOMPNUM: int = 1610613491
        self.SPECIFYLABELCOUNT: int = 1610613556
        self.SPECIFYSYMMETRYORIGIN: int = 1610613163
        self.SPECULARSHINE_COMPONENT: int = 8
        self.SPECULARTINT_COMPONENT: int = 16
        self.SPECULAR_COMPONENT: int = 4
        self.SPHERES: int = 5
        self.SPHRAXISENDPOINT1: int = 1610613299
        self.SPHRAXISENDPOINT2: int = 1610613300
        self.SPHRAXISVECT: int = 1610613298
        self.SPHRORIGIN: int = 1610613297
        self.SPHRRADIUS: int = 1610613296
        self.SPLINEID: int = 1610613271
        self.SPOT_ANGLE: int = 1610613071
        self.SPOT_FALLOFF: int = 1610613072
        self.STACKING_ORDER: int = 1610613025
        self.STAGE_LABEL_BACK_FACES: int = 2
        self.STAGE_LABEL_FRONT_AND_BACK_FACES: int = 0
        self.STAGE_LABEL_FRONT_FACES: int = 1
        self.STAGE_SHOW_STUFF_MAXIMUM: int = 1
        self.STAGE_SHOW_STUFF_MINANDMAX: int = 2
        self.STAGE_SHOW_STUFF_MINIMUM: int = 0
        self.STARTTIME: int = 1610613372
        self.STATES: int = 1610612947
        self.STATUS_STRING: int = 1610612872
        self.STEREO: int = 1610612897
        self.STEREO_CAPABLE: int = 1610612868
        self.STEREO_SEPARATION: int = 1610612867
        self.STREAMLINE: int = 0
        self.SUBGRIDLINETYPE: int = 1610613664
        self.SUBGRIDLINEWIDTH: int = 1610613663
        self.SUBGRIDRGB: int = 1610613665
        self.SUBLEVELS: int = 1610613344
        self.SUBLEVELSVISIBLE: int = 1610613346
        self.SUBSTRATE_MATERIAL: int = 11
        self.SUBTICKSCALEFACTOR: int = 1610613666
        self.SURFACE: int = 1610613428
        self.SURFACERESTRICTED: int = 1610613382
        self.SYMMETRY: int = 1610613497
        self.SYMMETRYANGLE: int = 1610613196
        self.SYMMETRYAXIS: int = 1610613162
        self.SYMMETRYDELTA: int = 1610613166
        self.SYMMETRYMIRRORX: int = 1610613154
        self.SYMMETRYMIRRORXY: int = 1610613157
        self.SYMMETRYMIRRORXYZ: int = 1610613160
        self.SYMMETRYMIRRORXZ: int = 1610613159
        self.SYMMETRYMIRRORY: int = 1610613155
        self.SYMMETRYMIRRORYZ: int = 1610613158
        self.SYMMETRYMIRRORZ: int = 1610613156
        self.SYMMETRYORIGIN: int = 1610613164
        self.SYMMETRYRINSTANCES: int = 1610613161
        self.SYMMETRYTYPE: int = 1610613153
        self.SYNCTOPALETTE: int = 1610613340
        self.SYNCTOTRANSIENT: int = 1610613616
        self.SYNTHETIC_MENU: int = 1610612948
        self.TAGS: int = 1610612757
        self.TARGETS: int = 1610612767
        self.TEMPERATURE: int = 1610613463
        self.TEMPLATE_NAME: int = 1610612760
        self.TEMPORAL_XY_QUERIES: int = 1610612791
        self.TENSIONLINEWIDTH: int = 1610613448
        self.TENSIONRGB: int = 1610613445
        self.TENSOR_COLBY_DRCT: int = 1
        self.TENSOR_COLBY_PART: int = 0
        self.TENSOR_LINEWBY_DRCT: int = 1
        self.TENSOR_LINEWBY_PART: int = 0
        self.TEXTPOSITION: int = 1610613549
        self.TEXTRGB: int = 1610613548
        self.TEXTSIZE: int = 1610613547
        self.TEXTTYPE: int = 1610613550
        self.TEXTURECOORDTYPE: int = 1610613138
        self.TEXTUREINTERPOLATION: int = 1610613137
        self.TEXTUREMODE: int = 1610613135
        self.TEXTUREOBJECT: int = 1610613134
        self.TEXTUREORIGIN: int = 1610613139
        self.TEXTUREORIGINNODEID: int = 1610613145
        self.TEXTUREORIGINUSE: int = 1610613144
        self.TEXTUREREPEATMODE: int = 1610613136
        self.TEXTURES: int = 1610612821
        self.TEXTURESORIGINNODEID: int = 1610613146
        self.TEXTURESVARIABLE: int = 1610613142
        self.TEXTURESVECTOR: int = 1610613140
        self.TEXTURETORIGINNODEID: int = 1610613147
        self.TEXTURETVARIABLE: int = 1610613143
        self.TEXTURETVECTOR: int = 1610613141
        self.TEXTURE_COORDS_BY_PROJECTION: int = 0
        self.TEXTURE_COORDS_BY_TWOSCALARS: int = 1
        self.TEXTURE_INTERPOLATE_LINEAR: int = 1
        self.TEXTURE_INTERPOLATE_NEAREST: int = 0
        self.TEXTURE_MODE_DECAL: int = 1
        self.TEXTURE_MODE_MODULATE: int = 2
        self.TEXTURE_MODE_REPLACE: int = 0
        self.TEXTURE_REPEAT_CLAMPED: int = 1
        self.TEXTURE_REPEAT_CLAMPTEXTURE: int = 2
        self.TEXTURE_REPEAT_REPEAT: int = 0
        self.THRESHOLD: int = 1610613453
        self.THRESHOLDFILTER: int = 1610613454
        self.THRESHOLDHIGH: int = 1610613422
        self.THRESHOLDLOW: int = 1610613421
        self.THRESHOLDMAX: int = 1610613457
        self.THRESHOLDMIN: int = 1610613456
        self.THRESHOLDS: int = 1610613420
        self.THRESHOLDVALUE: int = 1610613455
        self.THRS_BAND: int = 2
        self.THRS_HIGH: int = 3
        self.THRS_LOHI: int = 4
        self.THRS_LOW: int = 1
        self.THRS_NONE: int = 0
        self.TICKMARKS: int = 1610613579
        self.TICKSCALEFACTOR: int = 1610613662
        self.TIMEMARKER: int = 1610613755
        self.TIMEMARKERRGB: int = 1610613756
        self.TIMEMARKERSTYLE: int = 1610613758
        self.TIMEMARKERVALUE: int = 1610613759
        self.TIMEMARKERWIDTH: int = 1610613757
        self.TIMES: int = 1610613057
        self.TIMESETS: int = 1610612779
        self.TIMESTEP: int = 1610612879
        self.TIMESTEPBEGIN: int = 1610613380
        self.TIMESTEPEND: int = 1610613381
        self.TIMESTEP_LIMITS: int = 1610612878
        self.TIMETRACK: int = 1610612765
        self.TIMEVALUES: int = 1610612882
        self.TIME_RANGE: int = 1610612994
        self.TIPLENGTH: int = 1610613566
        self.TIPRADIUS: int = 1610613567
        self.TIPRGB: int = 1610613419
        self.TIPSHAFT: int = 1610613415
        self.TIPSHAPE: int = 1610613414
        self.TIPSIZE: int = 1610613442
        self.TIPSIZEFIXED: int = 1610613417
        self.TIPSIZEPROPORTIONAL: int = 1610613418
        self.TIPSIZEREP: int = 1610613416
        self.TITLELOCATION: int = 1610613552
        self.TITLERGB: int = 1610613753
        self.TITLETEXTSIZE: int = 1610613752
        self.TOOL: int = 1610613254
        self.TOOLS: int = 1610612822
        self.TOOLTYPE: int = 1610613038
        self.TOOL_BOX: int = 3
        self.TOOL_CONE: int = 5
        self.TOOL_CURSOR: int = 0
        self.TOOL_CYLINDER: int = 4
        self.TOOL_LINE: int = 1
        self.TOOL_ORIENTATION: int = 1610613099
        self.TOOL_PLANE: int = 2
        self.TOOL_REVOLUTION: int = 7
        self.TOOL_SPHERE: int = 6
        self.TOOL_USERDEFINED: int = 8
        self.TOTALENERGY: int = 1610613458
        self.TOTALROTATION: int = 1610613465
        self.TOTALTIME: int = 1610613370
        self.TOTALTRANSLATION: int = 1610613466
        self.TRACEDIRECTION: int = 1610613369
        self.TRACE_LINE: int = 0
        self.TRACE_RIBBON: int = 1
        self.TRACE_SQUBE: int = 2
        self.TRACE_TUBE: int = 3
        self.TRACK: int = 1610613645
        self.TRACKINGNODEID: int = 1610613647
        self.TRACKINGPARTID: int = 1610613646
        self.TRACK_NODE_NUMBER: int = 8
        self.TRACK_PART_CENTROID: int = 1
        self.TRACK_PART_XMAX: int = 3
        self.TRACK_PART_XMIN: int = 2
        self.TRACK_PART_YMAX: int = 5
        self.TRACK_PART_YMIN: int = 4
        self.TRACK_PART_ZMAX: int = 7
        self.TRACK_PART_ZMIN: int = 6
        self.TRANSFORMATION_DELTA: int = 1610613021
        self.TRANSFORMCENTER: int = 1610613022
        self.TRANSFORM_WITH_MODEL: int = 1610613068
        self.TRANSLATION: int = 1610613028
        self.TRANSLUCENT_MATERIAL: int = 14
        self.TRANSMITIVE_COMPONENT: int = 64
        self.TRANSPARENCY: int = 1610613655
        self.TRANSPARENT_METHOD: int = 1610612900
        self.TRANSPARENT_NUMPEELS: int = 1610612901
        self.TRANSP_SORT_DELAYED: int = 0
        self.TRANSP_SORT_DEPTHPEEL: int = 2
        self.TRANSP_SORT_INTERACTIVE: int = 1
        self.TRIANGLES: int = 2
        self.TRUE: int = 1
        self.TS_CENTER: int = 1
        self.TS_LEFT: int = 0
        self.TS_RIGHT: int = 2
        self.TS_SCREEN_RELATIVE: int = 0
        self.TS_VIEWPORT_RELATIVE: int = 1
        self.TYPE: int = 1610613255
        self.TYPE_ELEVATED_SURFACE: int = 0
        self.TYPE_OFFSET_SURFACE: int = 1
        self.UBER_MATERIAL: int = 15
        self.UNDEFINEDCOLOR: int = 1610613561
        self.UNDEFINED_COLOR: int = 1610612979
        self.UNIQUENAME: int = 1610612810
        self.UPDATEWITHNEWTIMESTEPS: int = 1610613845
        self.UPVEC_NX: int = 1
        self.UPVEC_NY: int = 3
        self.UPVEC_NZ: int = 5
        self.UPVEC_X: int = 0
        self.UPVEC_Y: int = 2
        self.UPVEC_Z: int = 4
        self.USEANNOTATIONTEXT: int = 1610613575
        self.USEDOUBLESIDEDWALLS: int = 1610613516
        self.USENORMALIZEDWIDTH: int = 1610613542
        self.USESURFACENORMALS: int = 1610613430
        self.USE_CONTINUOUS: int = 1610612997
        self.USE_LOGO: int = 1610612758
        self.UUID: int = 1610612747
        self.VALUE: int = 1610613335
        self.VALUEDECIMALPLACES: int = 1610613594
        self.VALUEFORMAT: int = 1610613593
        self.VALUEIJK: int = 1610613259
        self.VALUELOCATION: int = 1610613592
        self.VALUERGB: int = 1610613587
        self.VALUERTZ: int = 1610613268
        self.VALUESIZE: int = 1610613589
        self.VALUESPLINE: int = 1610613270
        self.VALUEXYZ: int = 1610613265
        self.VARCOMP: int = 1610613000
        self.VARIABLE: int = 1610612995
        self.VARIABLE1: int = 1610613819
        self.VARIABLE2: int = 1610613820
        self.VARIABLEOFFSET: int = 1610613383
        self.VARIABLES: int = 1610612816
        self.VARIABLETREE: int = 1610612817
        self.VARTYPE: int = 1610612955
        self.VARTYPEENUM: int = 1610612956
        self.VAR_XAXIS: int = 1610613061
        self.VAR_XAXIS_OBJ: int = 1610613064
        self.VAR_YAXIS_LEFT: int = 1610613063
        self.VAR_YAXIS_LEFT_OBJ: int = 1610613066
        self.VAR_YAXIS_RIGHT: int = 1610613062
        self.VAR_YAXIS_RIGHT_OBJ: int = 1610613065
        self.VECTOR_MAGNITUDE: int = 0
        self.VECTOR_X_COMP: int = 1
        self.VECTOR_Y_COMP: int = 2
        self.VECTOR_Z_COMP: int = 3
        self.VELOCITY: int = 1610613450
        self.VIEWDIMENSION: int = 1610613640
        self.VIEWPORT00: int = 1
        self.VIEWPORT01: int = 2
        self.VIEWPORT02: int = 4
        self.VIEWPORT03: int = 8
        self.VIEWPORT04: int = 16
        self.VIEWPORT05: int = 32
        self.VIEWPORT06: int = 64
        self.VIEWPORT07: int = 128
        self.VIEWPORT08: int = 256
        self.VIEWPORT09: int = 512
        self.VIEWPORT10: int = 1024
        self.VIEWPORT11: int = 2048
        self.VIEWPORT12: int = 4096
        self.VIEWPORT13: int = 8192
        self.VIEWPORT14: int = 16384
        self.VIEWPORT15: int = 32768
        self.VIEWPORT16: int = 65536
        self.VIEWPORT17: int = 131072
        self.VIEWPORT18: int = 262144
        self.VIEWPORT19: int = 524288
        self.VIEWPORT20: int = 1048576
        self.VIEWPORT21: int = 2097152
        self.VIEWPORT22: int = 4194304
        self.VIEWPORT23: int = 8388608
        self.VIEWPORT24: int = 16777216
        self.VIEWPORT25: int = 33554432
        self.VIEWPORT26: int = 67108864
        self.VIEWPORT27: int = 134217728
        self.VIEWPORT28: int = 268435456
        self.VIEWPORT29: int = 536870912
        self.VIEWPORT30: int = 1073741824
        self.VIEWPORT31: int = -2147483648
        self.VIEWPORTVIS: int = 1610612751
        self.VIEWPORT_USE: int = 1610613098
        self.VISIBILITYELT: int = 1610613180
        self.VISIBILITYLINE: int = 1610613178
        self.VISIBILITYNODE: int = 1610613169
        self.VISIBLE: int = 1610612745
        self.VISUAL_SYMM_MIRROR: int = 1
        self.VISUAL_SYMM_NONE: int = 0
        self.VISUAL_SYMM_ROTATE: int = 2
        self.VISUAL_SYMM_TRANSLATE: int = 3
        self.VOFCLIPVALUE: int = 1610613472
        self.VOFCLIPZTEST: int = 1610613478
        self.VOFCLIP_CONTOURS_PLUS_OBSTACLES: int = 1
        self.VOFCLIP_INCREASE_RESOLUTION: int = 2
        self.VOFCLIP_OBSTACLES_ONLY: int = 0
        self.VOFCLIP_USE_CELL_CENTER_VALUES: int = 3
        self.VOFISOVALUE: int = 1610613490
        self.VOFISOZTEST: int = 1610613496
        self.VOFISO_BLANK_ALGORITHM1: int = 0
        self.VOFISO_BLANK_ALGORITHM2: int = 1
        self.VOFISO_FLUID: int = 1
        self.VOFISO_FLUID_AND_OBSTACLES_OPEN_VOLUME: int = 4
        self.VOFISO_FLUID_AND_OBSTACLE_SOLID_VOLUME: int = 5
        self.VOFISO_FLUID_FRACTION: int = 0
        self.VOFISO_LIQUID: int = 6
        self.VOFISO_OPEN_VOLUME: int = 0
        self.VOFISO_SHALLOW_WATER_3D_SURFACE: int = 6
        self.VOFISO_SHALLOW_WATER_OPEN_VOLUME: int = 10
        self.VOFISO_SHALLOW_WATER_SOLID_VOLUME: int = 11
        self.VOFISO_SOLIDIFIED_LIQUID: int = 5
        self.VOFISO_SOLID_VOLUME: int = 3
        self.VOFISO_VOID: int = 4
        self.VOFISO_VOLUME_FRACTION: int = 1
        self.VOF_TYPE_CLIP: int = 0
        self.VOF_TYPE_ISO: int = 1
        self.VOLREND_STRUCTURED: int = 1
        self.VOLREND_UNSTRUCTURED: int = 0
        self.VOLUME: int = 8
        self.VOLUMEQUALITY: int = 1610613193
        self.VOLUMERENDERINGTYPE: int = 1610612808
        self.VOLUME_CHUNKING_NUM_TETS: int = 1610612898
        self.VOLUME_NUM_PASSES: int = 1610612899
        self.VOL_RENDER_QUALITY_BEST: int = 3
        self.VOL_RENDER_QUALITY_HIGH: int = 2
        self.VOL_RENDER_QUALITY_LOW: int = 0
        self.VOL_RENDER_QUALITY_MEDIUM: int = 1
        self.VPORTS: int = 1610612838
        self.VPORT_0: int = 0
        self.VPORT_1: int = 1
        self.VPORT_10: int = 10
        self.VPORT_11: int = 11
        self.VPORT_12: int = 12
        self.VPORT_13: int = 13
        self.VPORT_14: int = 14
        self.VPORT_15: int = 15
        self.VPORT_2: int = 2
        self.VPORT_3: int = 3
        self.VPORT_4: int = 4
        self.VPORT_5: int = 5
        self.VPORT_6: int = 6
        self.VPORT_7: int = 7
        self.VPORT_8: int = 8
        self.VPORT_9: int = 9
        self.VPORT_BLEND: int = 3
        self.VPORT_CONS: int = 2
        self.VPORT_IMAGE: int = 4
        self.VPORT_SET: int = 1
        self.VPORT_TRANSPARENT: int = 0
        self.VR_ANNOT_CENTER: int = 1610612935
        self.VR_ANNOT_NORMAL: int = 1610612936
        self.VR_ANNOT_SCALE: int = 1610612938
        self.VR_ANNOT_UP: int = 1610612937
        self.VR_CAVE_CENTER: int = 1610612940
        self.VR_CAVE_DIAGONAL: int = 1610612941
        self.VR_CAVE_SCALE: int = 1610612939
        self.WALLTHICKNESS: int = 1610613517
        self.WATERMARK: int = 1610612860
        self.WHICH_HISTOGRAM: int = 1610612966
        self.WIDTH: int = 1610613530
        self.WIDTHSCALEFACTOR: int = 1610613365
        self.WINDOWSIZE: int = 1610612886
        self.XAXIS_TYPE: int = 1610613010
        self.XY_GRID_GRID: int = 1
        self.XY_GRID_NONE: int = 0
        self.XY_GRID_TICK: int = 2
        self.XY_LABEL_ALL: int = 1
        self.XY_LABEL_BEG_END: int = 2
        self.XY_LABEL_NONE: int = 0
        self.ZCLIPLIMITS: int = 1610613019
        self.ZERO: int = 0
        self.ZONES_BOTH: int = 2
        self.ZONES_DEF: int = -1
        self.ZONES_EXT: int = 0
        self.ZONES_INT: int = 1


class objs:
    """Class wrapper for EnSight objs module

    This class acts as a proxy for the EnSight Python module ensight.objs

    Attributes:
        ANIMOBJ_FLG_ALLFRAMES (int):
            Instance specific constant

        ANIMOBJ_FLG_FRACFRAMES (int):
            Instance specific constant

        ANIMOBJ_FLG_ONESHOT (int):
            Instance specific constant

        ANIMOBJ_PLAY_FWD (int):
            Instance specific constant

        ANIMOBJ_PLAY_REV (int):
            Instance specific constant

        ANIMOBJ_PLAY_STEP_FWD (int):
            Instance specific constant

        ANIMOBJ_PLAY_STEP_REV (int):
            Instance specific constant

        ANIMOBJ_PLAY_STOP (int):
            Instance specific constant

        ANIMOBJ_STATE_PLAYOFF (int):
            Instance specific constant

        ANIMOBJ_STATE_PLAYON (int):
            Instance specific constant

        EMIT_CURSOR (int):
            Instance specific constant

        EMIT_FILE (int):
            Instance specific constant

        EMIT_LINE (int):
            Instance specific constant

        EMIT_PART (int):
            Instance specific constant

        EMIT_PLANE (int):
            Instance specific constant

        ENS_ANNOT (ENS_ANNOT):
            EnSight ENS_ANNOT proxy class

        ENS_ANNOT_TEXT (ENS_ANNOT_TEXT):
            EnSight ENS_ANNOT_TEXT proxy class

        ENS_ANNOT_LINE (ENS_ANNOT_LINE):
            EnSight ENS_ANNOT_LINE proxy class

        ENS_ANNOT_LOGO (ENS_ANNOT_LOGO):
            EnSight ENS_ANNOT_LOGO proxy class

        ENS_ANNOT_LGND (ENS_ANNOT_LGND):
            EnSight ENS_ANNOT_LGND proxy class

        ENS_ANNOT_MARKER (ENS_ANNOT_MARKER):
            EnSight ENS_ANNOT_MARKER proxy class

        ENS_ANNOT_ARROW (ENS_ANNOT_ARROW):
            EnSight ENS_ANNOT_ARROW proxy class

        ENS_ANNOT_DIAL (ENS_ANNOT_DIAL):
            EnSight ENS_ANNOT_DIAL proxy class

        ENS_ANNOT_GAUGE (ENS_ANNOT_GAUGE):
            EnSight ENS_ANNOT_GAUGE proxy class

        ENS_ANNOT_SHAPE (ENS_ANNOT_SHAPE):
            EnSight ENS_ANNOT_SHAPE proxy class

        ENS_CAMERA (ENS_CAMERA):
            EnSight ENS_CAMERA proxy class

        ENS_CASE (ENS_CASE):
            EnSight ENS_CASE proxy class

        ENS_FLIPBOOK (ENS_FLIPBOOK):
            EnSight ENS_FLIPBOOK proxy class

        ENS_FRAME (ENS_FRAME):
            EnSight ENS_FRAME proxy class

        ENS_GEOM (ENS_GEOM):
            EnSight ENS_GEOM proxy class

        ENS_GLOBALS (ENS_GLOBALS):
            EnSight ENS_GLOBALS proxy class

        ENS_GROUP (ENS_GROUP):
            EnSight ENS_GROUP proxy class

        ENS_LIGHTSOURCE (ENS_LIGHTSOURCE):
            EnSight ENS_LIGHTSOURCE proxy class

        ENS_LPART (ENS_LPART):
            EnSight ENS_LPART proxy class

        ENS_MAT (ENS_MAT):
            EnSight ENS_MAT proxy class

        ENS_PALETTE (ENS_PALETTE):
            EnSight ENS_PALETTE proxy class

        ENS_PART (ENS_PART):
            EnSight ENS_PART proxy class

        ENS_PART_MODEL (ENS_PART_MODEL):
            EnSight ENS_PART_MODEL proxy class

        ENS_PART_CLIP (ENS_PART_CLIP):
            EnSight ENS_PART_CLIP proxy class

        ENS_PART_CONTOUR (ENS_PART_CONTOUR):
            EnSight ENS_PART_CONTOUR proxy class

        ENS_PART_DISCRETE_PARTICLE (ENS_PART_DISCRETE_PARTICLE):
            EnSight ENS_PART_DISCRETE_PARTICLE proxy class

        ENS_PART_FRAME (ENS_PART_FRAME):
            EnSight ENS_PART_FRAME proxy class

        ENS_PART_ISOSURFACE (ENS_PART_ISOSURFACE):
            EnSight ENS_PART_ISOSURFACE proxy class

        ENS_PART_PARTICLE_TRACE (ENS_PART_PARTICLE_TRACE):
            EnSight ENS_PART_PARTICLE_TRACE proxy class

        ENS_PART_PROFILE (ENS_PART_PROFILE):
            EnSight ENS_PART_PROFILE proxy class

        ENS_PART_VECTOR_ARROW (ENS_PART_VECTOR_ARROW):
            EnSight ENS_PART_VECTOR_ARROW proxy class

        ENS_PART_ELEVATED_SURFACE (ENS_PART_ELEVATED_SURFACE):
            EnSight ENS_PART_ELEVATED_SURFACE proxy class

        ENS_PART_DEVELOPED_SURFACE (ENS_PART_DEVELOPED_SURFACE):
            EnSight ENS_PART_DEVELOPED_SURFACE proxy class

        ENS_PART_BUILT_UP (ENS_PART_BUILT_UP):
            EnSight ENS_PART_BUILT_UP proxy class

        ENS_PART_TENSOR_GLYPH (ENS_PART_TENSOR_GLYPH):
            EnSight ENS_PART_TENSOR_GLYPH proxy class

        ENS_PART_FX_VORTEX_CORE (ENS_PART_FX_VORTEX_CORE):
            EnSight ENS_PART_FX_VORTEX_CORE proxy class

        ENS_PART_FX_SHOCK (ENS_PART_FX_SHOCK):
            EnSight ENS_PART_FX_SHOCK proxy class

        ENS_PART_FX_SEP_ATT (ENS_PART_FX_SEP_ATT):
            EnSight ENS_PART_FX_SEP_ATT proxy class

        ENS_PART_MAT_INTERFACE (ENS_PART_MAT_INTERFACE):
            EnSight ENS_PART_MAT_INTERFACE proxy class

        ENS_PART_POINT (ENS_PART_POINT):
            EnSight ENS_PART_POINT proxy class

        ENS_PART_AXISYMMETRIC (ENS_PART_AXISYMMETRIC):
            EnSight ENS_PART_AXISYMMETRIC proxy class

        ENS_PART_VOF (ENS_PART_VOF):
            EnSight ENS_PART_VOF proxy class

        ENS_PART_AUX_GEOM (ENS_PART_AUX_GEOM):
            EnSight ENS_PART_AUX_GEOM proxy class

        ENS_PART_FILTER (ENS_PART_FILTER):
            EnSight ENS_PART_FILTER proxy class

        ENS_PLOTTER (ENS_PLOTTER):
            EnSight ENS_PLOTTER proxy class

        ENS_POLYLINE (ENS_POLYLINE):
            EnSight ENS_POLYLINE proxy class

        ENS_PROBE (ENS_PROBE):
            EnSight ENS_PROBE proxy class

        ENS_QUERY (ENS_QUERY):
            EnSight ENS_QUERY proxy class

        ENS_SCENE (ENS_SCENE):
            EnSight ENS_SCENE proxy class

        ENS_SOURCE (ENS_SOURCE):
            EnSight ENS_SOURCE proxy class

        ENS_SPEC (ENS_SPEC):
            EnSight ENS_SPEC proxy class

        ENS_STATE (ENS_STATE):
            EnSight ENS_STATE proxy class

        ENS_TEXTURE (ENS_TEXTURE):
            EnSight ENS_TEXTURE proxy class

        ENS_TOOL (ENS_TOOL):
            EnSight ENS_TOOL proxy class

        ENS_TOOL_CURSOR (ENS_TOOL_CURSOR):
            EnSight ENS_TOOL_CURSOR proxy class

        ENS_TOOL_LINE (ENS_TOOL_LINE):
            EnSight ENS_TOOL_LINE proxy class

        ENS_TOOL_PLANE (ENS_TOOL_PLANE):
            EnSight ENS_TOOL_PLANE proxy class

        ENS_TOOL_BOX (ENS_TOOL_BOX):
            EnSight ENS_TOOL_BOX proxy class

        ENS_TOOL_CYLINDER (ENS_TOOL_CYLINDER):
            EnSight ENS_TOOL_CYLINDER proxy class

        ENS_TOOL_CONE (ENS_TOOL_CONE):
            EnSight ENS_TOOL_CONE proxy class

        ENS_TOOL_SPHERE (ENS_TOOL_SPHERE):
            EnSight ENS_TOOL_SPHERE proxy class

        ENS_TOOL_REVOLUTION (ENS_TOOL_REVOLUTION):
            EnSight ENS_TOOL_REVOLUTION proxy class

        ENS_VAR (ENS_VAR):
            EnSight ENS_VAR proxy class

        ENS_VPORT (ENS_VPORT):
            EnSight ENS_VPORT proxy class

        EVENTMAP_FLAG_COMP_GLOBAL (int):
            Instance specific constant

        EVENTMAP_FLAG_COMP_LOCAL (int):
            Instance specific constant

        EVENTMAP_FLAG_IMMEDIATE (int):
            Instance specific constant

        SHOW_ANNOTS (int):
            Instance specific constant

        SHOW_ANY (int):
            Instance specific constant

        SHOW_CALCTOOLS (int):
            Instance specific constant

        SHOW_CASES (int):
            Instance specific constant

        SHOW_FRAMES (int):
            Instance specific constant

        SHOW_NONE (int):
            Instance specific constant

        SHOW_PLOTTERS (int):
            Instance specific constant

        SHOW_QUERIES (int):
            Instance specific constant

        SHOW_STATES (int):
            Instance specific constant

        SHOW_TRACK_SELECTION (int):
            Instance specific constant

        SHOW_TYPE_MASK (int):
            Instance specific constant

        SHOW_VARS (int):
            Instance specific constant

        SHOW_VIEWPORTS (int):
            Instance specific constant

        core (ENS_GLOBALS):
            Instance specific constant

        ens_animobj (ens_animobj):
            EnSight ens_animobj proxy class

        ens_emitterobj (ens_emitterobj):
            EnSight ens_emitterobj proxy class

        enums:
            EnSight module instance class


    """
    def __init__(self, session: Session):
        self._session = session
        self.ANIMOBJ_FLG_ALLFRAMES: int = 1
        self.ANIMOBJ_FLG_FRACFRAMES: int = 2
        self.ANIMOBJ_FLG_ONESHOT: int = 4
        self.ANIMOBJ_PLAY_FWD: int = 1
        self.ANIMOBJ_PLAY_REV: int = -1
        self.ANIMOBJ_PLAY_STEP_FWD: int = 2
        self.ANIMOBJ_PLAY_STEP_REV: int = -2
        self.ANIMOBJ_PLAY_STOP: int = 0
        self.ANIMOBJ_STATE_PLAYOFF: int = 0
        self.ANIMOBJ_STATE_PLAYON: int = 1
        self.EMIT_CURSOR: int = 3
        self.EMIT_FILE: int = 28
        self.EMIT_LINE: int = 4
        self.EMIT_PART: int = 7
        self.EMIT_PLANE: int = 5
        self.EVENTMAP_FLAG_COMP_GLOBAL: int = 4
        self.EVENTMAP_FLAG_COMP_LOCAL: int = 2
        self.EVENTMAP_FLAG_IMMEDIATE: int = 1
        self.SHOW_ANNOTS: int = 4
        self.SHOW_ANY: int = 511
        self.SHOW_CALCTOOLS: int = 128
        self.SHOW_CASES: int = 1
        self.SHOW_FRAMES: int = 64
        self.SHOW_NONE: int = 0
        self.SHOW_PLOTTERS: int = 16
        self.SHOW_QUERIES: int = 8
        self.SHOW_STATES: int = 256
        self.SHOW_TRACK_SELECTION: int = 4096
        self.SHOW_TYPE_MASK: int = 4095
        self.SHOW_VARS: int = 2
        self.SHOW_VIEWPORTS: int = 32
        self.core: 'ENS_GLOBALS'
        self.enums: 'enums' = enums(self._session)
        self.ENS_ANNOT: 'ENS_ANNOT' = ENS_ANNOT
        self.ENS_ANNOT_TEXT: 'ENS_ANNOT_TEXT' = ENS_ANNOT_TEXT
        self.ENS_ANNOT_LINE: 'ENS_ANNOT_LINE' = ENS_ANNOT_LINE
        self.ENS_ANNOT_LOGO: 'ENS_ANNOT_LOGO' = ENS_ANNOT_LOGO
        self.ENS_ANNOT_LGND: 'ENS_ANNOT_LGND' = ENS_ANNOT_LGND
        self.ENS_ANNOT_MARKER: 'ENS_ANNOT_MARKER' = ENS_ANNOT_MARKER
        self.ENS_ANNOT_ARROW: 'ENS_ANNOT_ARROW' = ENS_ANNOT_ARROW
        self.ENS_ANNOT_DIAL: 'ENS_ANNOT_DIAL' = ENS_ANNOT_DIAL
        self.ENS_ANNOT_GAUGE: 'ENS_ANNOT_GAUGE' = ENS_ANNOT_GAUGE
        self.ENS_ANNOT_SHAPE: 'ENS_ANNOT_SHAPE' = ENS_ANNOT_SHAPE
        self.ENS_CAMERA: 'ENS_CAMERA' = ENS_CAMERA
        self.ENS_CASE: 'ENS_CASE' = ENS_CASE
        self.ENS_FLIPBOOK: 'ENS_FLIPBOOK' = ENS_FLIPBOOK
        self.ENS_FRAME: 'ENS_FRAME' = ENS_FRAME
        self.ENS_GEOM: 'ENS_GEOM' = ENS_GEOM
        self.ENS_GLOBALS: 'ENS_GLOBALS' = ENS_GLOBALS
        self.ENS_GROUP: 'ENS_GROUP' = ENS_GROUP
        self.ENS_LIGHTSOURCE: 'ENS_LIGHTSOURCE' = ENS_LIGHTSOURCE
        self.ENS_LPART: 'ENS_LPART' = ENS_LPART
        self.ENS_MAT: 'ENS_MAT' = ENS_MAT
        self.ENS_PALETTE: 'ENS_PALETTE' = ENS_PALETTE
        self.ENS_PART: 'ENS_PART' = ENS_PART
        self.ENS_PART_MODEL: 'ENS_PART_MODEL' = ENS_PART_MODEL
        self.ENS_PART_CLIP: 'ENS_PART_CLIP' = ENS_PART_CLIP
        self.ENS_PART_CONTOUR: 'ENS_PART_CONTOUR' = ENS_PART_CONTOUR
        self.ENS_PART_DISCRETE_PARTICLE: 'ENS_PART_DISCRETE_PARTICLE' = ENS_PART_DISCRETE_PARTICLE
        self.ENS_PART_FRAME: 'ENS_PART_FRAME' = ENS_PART_FRAME
        self.ENS_PART_ISOSURFACE: 'ENS_PART_ISOSURFACE' = ENS_PART_ISOSURFACE
        self.ENS_PART_PARTICLE_TRACE: 'ENS_PART_PARTICLE_TRACE' = ENS_PART_PARTICLE_TRACE
        self.ENS_PART_PROFILE: 'ENS_PART_PROFILE' = ENS_PART_PROFILE
        self.ENS_PART_VECTOR_ARROW: 'ENS_PART_VECTOR_ARROW' = ENS_PART_VECTOR_ARROW
        self.ENS_PART_ELEVATED_SURFACE: 'ENS_PART_ELEVATED_SURFACE' = ENS_PART_ELEVATED_SURFACE
        self.ENS_PART_DEVELOPED_SURFACE: 'ENS_PART_DEVELOPED_SURFACE' = ENS_PART_DEVELOPED_SURFACE
        self.ENS_PART_BUILT_UP: 'ENS_PART_BUILT_UP' = ENS_PART_BUILT_UP
        self.ENS_PART_TENSOR_GLYPH: 'ENS_PART_TENSOR_GLYPH' = ENS_PART_TENSOR_GLYPH
        self.ENS_PART_FX_VORTEX_CORE: 'ENS_PART_FX_VORTEX_CORE' = ENS_PART_FX_VORTEX_CORE
        self.ENS_PART_FX_SHOCK: 'ENS_PART_FX_SHOCK' = ENS_PART_FX_SHOCK
        self.ENS_PART_FX_SEP_ATT: 'ENS_PART_FX_SEP_ATT' = ENS_PART_FX_SEP_ATT
        self.ENS_PART_MAT_INTERFACE: 'ENS_PART_MAT_INTERFACE' = ENS_PART_MAT_INTERFACE
        self.ENS_PART_POINT: 'ENS_PART_POINT' = ENS_PART_POINT
        self.ENS_PART_AXISYMMETRIC: 'ENS_PART_AXISYMMETRIC' = ENS_PART_AXISYMMETRIC
        self.ENS_PART_VOF: 'ENS_PART_VOF' = ENS_PART_VOF
        self.ENS_PART_AUX_GEOM: 'ENS_PART_AUX_GEOM' = ENS_PART_AUX_GEOM
        self.ENS_PART_FILTER: 'ENS_PART_FILTER' = ENS_PART_FILTER
        self.ENS_PLOTTER: 'ENS_PLOTTER' = ENS_PLOTTER
        self.ENS_POLYLINE: 'ENS_POLYLINE' = ENS_POLYLINE
        self.ENS_PROBE: 'ENS_PROBE' = ENS_PROBE
        self.ENS_QUERY: 'ENS_QUERY' = ENS_QUERY
        self.ENS_SCENE: 'ENS_SCENE' = ENS_SCENE
        self.ENS_SOURCE: 'ENS_SOURCE' = ENS_SOURCE
        self.ENS_SPEC: 'ENS_SPEC' = ENS_SPEC
        self.ENS_STATE: 'ENS_STATE' = ENS_STATE
        self.ENS_TEXTURE: 'ENS_TEXTURE' = ENS_TEXTURE
        self.ENS_TOOL: 'ENS_TOOL' = ENS_TOOL
        self.ENS_TOOL_CURSOR: 'ENS_TOOL_CURSOR' = ENS_TOOL_CURSOR
        self.ENS_TOOL_LINE: 'ENS_TOOL_LINE' = ENS_TOOL_LINE
        self.ENS_TOOL_PLANE: 'ENS_TOOL_PLANE' = ENS_TOOL_PLANE
        self.ENS_TOOL_BOX: 'ENS_TOOL_BOX' = ENS_TOOL_BOX
        self.ENS_TOOL_CYLINDER: 'ENS_TOOL_CYLINDER' = ENS_TOOL_CYLINDER
        self.ENS_TOOL_CONE: 'ENS_TOOL_CONE' = ENS_TOOL_CONE
        self.ENS_TOOL_SPHERE: 'ENS_TOOL_SPHERE' = ENS_TOOL_SPHERE
        self.ENS_TOOL_REVOLUTION: 'ENS_TOOL_REVOLUTION' = ENS_TOOL_REVOLUTION
        self.ENS_VAR: 'ENS_VAR' = ENS_VAR
        self.ENS_VPORT: 'ENS_VPORT' = ENS_VPORT
        self.ens_animobj: 'ens_animobj' = ens_animobj
        self.ens_emitterobj: 'ens_emitterobj' = ens_emitterobj

    def addcallback(self, target: Union["ENSOBJ", str], obj: Any, method: str, userdata: Any = None,            attrs: List[int] = [], flags: int = 0) -> int:
        """Set up a Python callback that will be executed when the selected conditions are met.
        
        
        Note: this method should only be used in EnSight Python scripts.  For
        PyEnSight scripts, use:  :meth:`pyensight.Session.add_callback`
        instead.
        
        
        This function will register a callback on the ``target``. The target can either be an EnSight
        ENSOBJ object or the name of a class (e.g. "ENS_PART").
        A Python function of the form::
        
        
            class obj:
                def method(self, target: "ENSOBJ", attribute: int, userdata: Any) -> int:
                    return 0
        
        
        will be called whenever an attribute of the target object/class changes.  The object whose
        attribute changed will be passed to the callback as ``target``.
        The actual attribute that changed is passed to the callback as the ``attribute`` parameter.
        By default, the callback is made for all attributes, but a restricted list of attributes
        can be provided by the ``attrs`` keyword.
        If a value is specified via the ``userdata`` keyword, it will passed to the callback as well.
        The return value of the callback controls if the callback will be made again in the future.
        If any value other than 0 is returned, the callback is removed from the queue and will
        not be called again.
        
        Args:
            target:
                The ENSOBJ instance or the string name of the ENSOBJ subclass that the callback should
                respond to attribute changes on.
            obj:
                The Python object that has the named callback method.
            method:
                The string name of the method on ``obj`` that should be called when the attribute
                change conditions are met.
            userdata:
                An optional object that will be passed to the callback.  Often used as a differentiator
                when the same method is register for multiple target/attribute tuples.
            attrs:
                The list of attribute IDs.  If there is a change in any of the attributes on the
                target object, then the callback will be executed.
            flags:
                ``ensight.objs.EVENTMAP_FLAG_IMMEDIATE`` causes the callback to be called immediately
                instead of being queued up for later when EnSight is idle. Use this flag with caution,
                it can be very expensive and can lead to recursion issues.
                ``ensight.objs.EVENTMAP_FLAG_COMP_LOCAL`` causes multiple consecutive instances of
                this callback in the deferred event queue to be consolidated into a single event.
                ``ensight.objs.EVENTMAP_FLAG_COMP_GLOBAL`` performs the same consolidation, but allows
                for discontinuous instances of the callback to be collapsed to the last callback instance.
        
        Returns:
            The registered callback id on success or -1 if the callback could not be registered.

        """
        arg_list: List[str] = []
        arg_list.append(target.__repr__())
        arg_list.append(obj.__repr__())
        arg_list.append(method.__repr__())
        arg_list.append(f"userdata={userdata.__repr__()}")
        arg_list.append(f"attrs={attrs.__repr__()}")
        arg_list.append(f"flags={flags.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.objs.addcallback({arg_string})"
        return self._session.cmd(cmd)

    def allocextattr(self, *args, **kwargs) -> Any:
        """Allocate a class specific attribute

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.objs.allocextattr({arg_string})"
        return self._session.cmd(cmd)

    def classify_file(self, *args, **kwargs) -> Any:
        """Classifies a file by its extension

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.objs.classify_file({arg_string})"
        return self._session.cmd(cmd)

    def ensxml_context_list_writer(self, *args, **kwargs) -> Any:
        """Output context node to the xml file

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.objs.ensxml_context_list_writer({arg_string})"
        return self._session.cmd(cmd)

    def ensxml_restore_element(self, *args, **kwargs) -> Any:
        """Restore a node from the xml file

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.objs.ensxml_restore_element({arg_string})"
        return self._session.cmd(cmd)

    def ensxml_restore_file(self, *args, **kwargs) -> Any:
        """Restore a session to an xml file

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.objs.ensxml_restore_file({arg_string})"
        return self._session.cmd(cmd)

    def ensxml_save_file(self, *args, **kwargs) -> Any:
        """Save a session to an xml file

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.objs.ensxml_save_file({arg_string})"
        return self._session.cmd(cmd)

    def enum_to_name(self, attrid: int) -> str:
        """Convert an attribute id into the associated string name
        
        
        For a given attribute id, return the ASCII name of the
        attribute.  If the input id is not a valid attribute,
        a RuntimeError will be raised.
        
        
        Args:
            attrid:
                An attribute id number.
        
        
        Returns:
            The string name for the attribute number.
        
        Example:
            ::
        
                ensight.objs.enum_to_name(1610613151)
                'NODEVARIABLE'

        """
        arg_list: List[str] = []
        arg_list.append(attrid.__repr__())
        arg_string = ",".join(arg_list)
        cmd = f"ensight.objs.enum_to_name({arg_string})"
        return self._session.cmd(cmd)

    def events_queued(self, *args, **kwargs) -> Any:
        """Return a list of events pending dispatch

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.objs.events_queued({arg_string})"
        return self._session.cmd(cmd)

    def events_resume(self, *args, **kwargs) -> Any:
        """Resume event dispatch

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.objs.events_resume({arg_string})"
        return self._session.cmd(cmd)

    def events_suspend(self, *args, **kwargs) -> Any:
        """Suspend event dispatch

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.objs.events_suspend({arg_string})"
        return self._session.cmd(cmd)

    def next_id(self, ) -> int:
        """Return the object id of the next object EnSight will allocate
        
        
        All EnSight objects have a unique object ID.  These IDs are monotonically increasing.
        This function returns the id number that EnSight will assign to the next object that
        it creates.  It can be used to detect if an object is new, relative to when this function
        is called.
        
        
        Returns:
            The ENSOBJ object id of the next allocated object.

        """
        arg_list: List[str] = []
        arg_string = ",".join(arg_list)
        cmd = f"ensight.objs.next_id({arg_string})"
        return self._session.cmd(cmd)

    def release_id(self, *args, **kwargs) -> Any:
        """Release ID owned by external session

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.objs.release_id({arg_string})"
        return self._session.cmd(cmd)

    def removecallback(self, id: int) -> int:
        """Remove a callback that was registered using ensight.objs.addcallback()
        
        Note: this method should only be used in EnSight Python scripts.  For
        PyEnSight scripts, use:  :meth:`pyensight.Session.remove_callback`
        instead.
        
        Args:
            id:
                A callback number returned by addcallback().
        
        
        Returns:
            0 on success or -1 if the passed id could not be removed.

        """
        arg_list: List[str] = []
        arg_list.append(id.__repr__())
        arg_string = ",".join(arg_list)
        cmd = f"ensight.objs.removecallback({arg_string})"
        return self._session.cmd(cmd)

    def valid_id(self, id: int) -> bool:
        """Check to see if a given id corresponds to an existing EnSight object
        
        
        Args:
            id:
                An object id number.
        
        
        Returns:
            True if the EnSight object with the passed id currently exists.

        """
        arg_list: List[str] = []
        arg_list.append(id.__repr__())
        arg_string = ",".join(arg_list)
        cmd = f"ensight.objs.valid_id({arg_string})"
        return self._session.cmd(cmd)

    def version(self, *args, **kwargs) -> Any:
        """EnSight Python API version

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.objs.version({arg_string})"
        return self._session.cmd(cmd)

    def wrap_id(self, id: int) -> "ENSOBJ":
        """Return the Python proxy object for a specific EnSight object id
        
        
        The EnSight Python object interface uses proxy objects.  This method creates
        a proxy object associated with a given object id.  If the specified id does
        not exist, a RuntimeError exception is raised.
        
        Args:
            id:
                An object id number.
        
        
        Returns:
            The ENSOBJ proxy object associated with the specified id.

        """
        arg_list: List[str] = []
        arg_list.append(id.__repr__())
        arg_string = ",".join(arg_list)
        cmd = f"ensight.objs.wrap_id({arg_string})"
        return self._session.cmd(cmd)


class nvc:
    """Class wrapper for EnSight nvc module

    This class acts as a proxy for the EnSight Python module ensight.nvc
    """
    def __init__(self, session: Session):
        self._session = session

    def delete(self) -> int:
        """Nvc: delete

        """
        cmd = f'''ensight.nvc.delete()'''
        return self._session.cmd(cmd)

    def description(self, p0: str) -> int:
        """Nvc: description

        """
        cmd = f'''ensight.nvc.description({repr(p0)})'''
        return self._session.cmd(cmd)

    def deselect_all(self) -> int:
        """Nvc: deselect_all

        """
        cmd = f'''ensight.nvc.deselect_all()'''
        return self._session.cmd(cmd)

    def location_x(self, p0: float) -> int:
        """Nvc: location_x

        """
        cmd = f'''ensight.nvc.location_x({repr(p0)})'''
        return self._session.cmd(cmd)

    def location_y(self, p0: float) -> int:
        """Nvc: location_y

        """
        cmd = f'''ensight.nvc.location_y({repr(p0)})'''
        return self._session.cmd(cmd)

    def modify_begin(self) -> int:
        """Nvc: modify_begin

        """
        cmd = f'''ensight.nvc.modify_begin()'''
        return self._session.cmd(cmd)

    def modify_end(self) -> int:
        """Nvc: modify_end

        """
        cmd = f'''ensight.nvc.modify_end()'''
        return self._session.cmd(cmd)

    def new_logo(self, p0: str) -> int:
        """Nvc: new_logo

        """
        cmd = f'''ensight.nvc.new_logo({repr(p0)})'''
        return self._session.cmd(cmd)

    def new_or_mod_logo(self, p0: str) -> int:
        """Nvc: new_or_mod_logo

        """
        cmd = f'''ensight.nvc.new_or_mod_logo({repr(p0)})'''
        return self._session.cmd(cmd)

    def normalized_width(self, p0: float) -> int:
        """Nvc: normalized_width

        """
        cmd = f'''ensight.nvc.normalized_width({repr(p0)})'''
        return self._session.cmd(cmd)

    def query_count(self, args: Any) -> int:
        """Nvc: query_count

        """
        cmd = f'''ensight.nvc.query_count({repr(args)})'''
        return self._session.cmd(cmd)

    def query_display_attributes(self, args: Any) -> int:
        """Nvc: query_display_attributes

        """
        cmd = f'''ensight.nvc.query_display_attributes({repr(args)})'''
        return self._session.cmd(cmd)

    def query_selected_objects(self, args: Any) -> int:
        """Nvc: query_selected_objects

        """
        cmd = f'''ensight.nvc.query_selected_objects({repr(args)})'''
        return self._session.cmd(cmd)

    def read(self, p0: str) -> int:
        """Nvc: read

        """
        cmd = f'''ensight.nvc.read({repr(p0)})'''
        return self._session.cmd(cmd)

    def rgb(self, p0: float, p1: float, p2: float) -> int:
        """Nvc: rgb

        """
        cmd = f'''ensight.nvc.rgb({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def scale(self, p0: float, p1: float) -> int:
        """Nvc: scale

        """
        cmd = f'''ensight.nvc.scale({repr(p0)},{repr(p1)})'''
        return self._session.cmd(cmd)

    def select_all(self) -> int:
        """Nvc: select_all

        """
        cmd = f'''ensight.nvc.select_all()'''
        return self._session.cmd(cmd)

    def select_all_invisible(self) -> int:
        """Nvc: select_all_invisible

        """
        cmd = f'''ensight.nvc.select_all_invisible()'''
        return self._session.cmd(cmd)

    def select_all_visible(self) -> int:
        """Nvc: select_all_visible

        """
        cmd = f'''ensight.nvc.select_all_visible()'''
        return self._session.cmd(cmd)

    def select_begin(self, *args, **kwargs) -> Any:
        """Nvc: select_begin

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.nvc.select_begin({arg_string})"
        return self._session.cmd(cmd)

    def select_default(self) -> int:
        """Nvc: select_default

        """
        cmd = f'''ensight.nvc.select_default()'''
        return self._session.cmd(cmd)

    def show_raytraced_image(self, p0: str) -> int:
        """Nvc: show_raytraced_image

        """
        cmd = f'''ensight.nvc.show_raytraced_image({repr(p0)})'''
        return self._session.cmd(cmd)

    def use_normalized_width(self, p0: str) -> int:
        """Nvc: use_normalized_width

        """
        cmd = f'''ensight.nvc.use_normalized_width({repr(p0)})'''
        return self._session.cmd(cmd)

    def visible(self, p0: str) -> int:
        """Nvc: visible

        """
        cmd = f'''ensight.nvc.visible({repr(p0)})'''
        return self._session.cmd(cmd)


class nplot:
    """Class wrapper for EnSight nplot module

    This class acts as a proxy for the EnSight Python module ensight.nplot
    """
    def __init__(self, session: Session):
        self._session = session

    def cursor(self, p0: float, p1: float, p2: float) -> int:
        """Nplot: cursor

        """
        cmd = f'''ensight.nplot.cursor({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def element(self, p0: int) -> int:
        """Nplot: element

        """
        cmd = f'''ensight.nplot.element({repr(p0)})'''
        return self._session.cmd(cmd)

    def ijk(self, p0: float, p1: float, p2: float) -> int:
        """Nplot: ijk

        """
        cmd = f'''ensight.nplot.ijk({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def node(self, p0: int) -> int:
        """Nplot: node

        """
        cmd = f'''ensight.nplot.node({repr(p0)})'''
        return self._session.cmd(cmd)

    def part(self, p0: int) -> int:
        """Nplot: part

        """
        cmd = f'''ensight.nplot.part({repr(p0)})'''
        return self._session.cmd(cmd)

    def point(self, p0: float, p1: float, p2: float) -> int:
        """Nplot: point

        """
        cmd = f'''ensight.nplot.point({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)


class model:
    """Class wrapper for EnSight model module

    This class acts as a proxy for the EnSight Python module ensight.model
    """
    def __init__(self, session: Session):
        self._session = session

    def adjcoord_scale_factor(self, p0: float) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.model.adjcoord_scale_factor({repr(p0)})'''
        return self._session.cmd(cmd)

    def adjcoord_transvec(self, p0: float, p1: float, p2: float) -> int:
        """Model: adjcoord_transvec

        """
        cmd = f'''ensight.model.adjcoord_transvec({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def adjcoord_varscale_factor(self, p0: float) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.model.adjcoord_varscale_factor({repr(p0)})'''
        return self._session.cmd(cmd)

    def adjcoord_x_variable(self, p0: Any) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.model.adjcoord_x_variable({repr(p0)})'''
        return self._session.cmd(cmd)

    def adjcoord_y_variable(self, p0: Any) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.model.adjcoord_y_variable({repr(p0)})'''
        return self._session.cmd(cmd)

    def adjcoord_z_variable(self, p0: Any) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.model.adjcoord_z_variable({repr(p0)})'''
        return self._session.cmd(cmd)

    def elt_defined_by(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.model.elt_defined_by({repr(p0)})'''
        return self._session.cmd(cmd)

    def elt_filter1_active(self, p0: str) -> int:
        """Model: elt_filter1_active

        """
        cmd = f'''ensight.model.elt_filter1_active({repr(p0)})'''
        return self._session.cmd(cmd)

    def elt_filter1_logicalop(self, p0: str) -> int:
        """Model: elt_filter1_logicalop

        """
        cmd = f'''ensight.model.elt_filter1_logicalop({repr(p0)})'''
        return self._session.cmd(cmd)

    def elt_filter1_testop(self, p0: str) -> int:
        """Model: elt_filter1_testop

        """
        cmd = f'''ensight.model.elt_filter1_testop({repr(p0)})'''
        return self._session.cmd(cmd)

    def elt_filter1_testvalue(self, p0: float) -> int:
        """Model: elt_filter1_testvalue

        """
        cmd = f'''ensight.model.elt_filter1_testvalue({repr(p0)})'''
        return self._session.cmd(cmd)

    def elt_filter1_testvarcomp(self, p0: str) -> int:
        """Model: elt_filter1_testvarcomp

        """
        cmd = f'''ensight.model.elt_filter1_testvarcomp({repr(p0)})'''
        return self._session.cmd(cmd)

    def elt_filter1_testvariable(self, args: Any) -> int:
        """Model: elt_filter1_testvariable

        """
        cmd = f'''ensight.model.elt_filter1_testvariable({repr(args)})'''
        return self._session.cmd(cmd)

    def elt_filter1_varcomp(self, p0: str) -> int:
        """Model: elt_filter1_varcomp

        """
        cmd = f'''ensight.model.elt_filter1_varcomp({repr(p0)})'''
        return self._session.cmd(cmd)

    def elt_filter1_variable(self, args: Any) -> int:
        """Model: elt_filter1_variable

        """
        cmd = f'''ensight.model.elt_filter1_variable({repr(args)})'''
        return self._session.cmd(cmd)

    def elt_filter2_active(self, p0: str) -> int:
        """Model: elt_filter2_active

        """
        cmd = f'''ensight.model.elt_filter2_active({repr(p0)})'''
        return self._session.cmd(cmd)

    def elt_filter2_logicalop(self, p0: str) -> int:
        """Model: elt_filter2_logicalop

        """
        cmd = f'''ensight.model.elt_filter2_logicalop({repr(p0)})'''
        return self._session.cmd(cmd)

    def elt_filter2_testop(self, p0: str) -> int:
        """Model: elt_filter2_testop

        """
        cmd = f'''ensight.model.elt_filter2_testop({repr(p0)})'''
        return self._session.cmd(cmd)

    def elt_filter2_testvalue(self, p0: float) -> int:
        """Model: elt_filter2_testvalue

        """
        cmd = f'''ensight.model.elt_filter2_testvalue({repr(p0)})'''
        return self._session.cmd(cmd)

    def elt_filter2_testvarcomp(self, p0: str) -> int:
        """Model: elt_filter2_testvarcomp

        """
        cmd = f'''ensight.model.elt_filter2_testvarcomp({repr(p0)})'''
        return self._session.cmd(cmd)

    def elt_filter2_testvariable(self, args: Any) -> int:
        """Model: elt_filter2_testvariable

        """
        cmd = f'''ensight.model.elt_filter2_testvariable({repr(args)})'''
        return self._session.cmd(cmd)

    def elt_filter2_varcomp(self, p0: str) -> int:
        """Model: elt_filter2_varcomp

        """
        cmd = f'''ensight.model.elt_filter2_varcomp({repr(p0)})'''
        return self._session.cmd(cmd)

    def elt_filter2_variable(self, args: Any) -> int:
        """Model: elt_filter2_variable

        """
        cmd = f'''ensight.model.elt_filter2_variable({repr(args)})'''
        return self._session.cmd(cmd)

    def elt_filter3_active(self, p0: str) -> int:
        """Model: elt_filter3_active

        """
        cmd = f'''ensight.model.elt_filter3_active({repr(p0)})'''
        return self._session.cmd(cmd)

    def elt_filter3_logicalop(self, p0: str) -> int:
        """Model: elt_filter3_logicalop

        """
        cmd = f'''ensight.model.elt_filter3_logicalop({repr(p0)})'''
        return self._session.cmd(cmd)

    def elt_filter3_testop(self, p0: str) -> int:
        """Model: elt_filter3_testop

        """
        cmd = f'''ensight.model.elt_filter3_testop({repr(p0)})'''
        return self._session.cmd(cmd)

    def elt_filter3_testvalue(self, p0: float) -> int:
        """Model: elt_filter3_testvalue

        """
        cmd = f'''ensight.model.elt_filter3_testvalue({repr(p0)})'''
        return self._session.cmd(cmd)

    def elt_filter3_testvarcomp(self, p0: str) -> int:
        """Model: elt_filter3_testvarcomp

        """
        cmd = f'''ensight.model.elt_filter3_testvarcomp({repr(p0)})'''
        return self._session.cmd(cmd)

    def elt_filter3_testvariable(self, args: Any) -> int:
        """Model: elt_filter3_testvariable

        """
        cmd = f'''ensight.model.elt_filter3_testvariable({repr(args)})'''
        return self._session.cmd(cmd)

    def elt_filter3_varcomp(self, p0: str) -> int:
        """Model: elt_filter3_varcomp

        """
        cmd = f'''ensight.model.elt_filter3_varcomp({repr(p0)})'''
        return self._session.cmd(cmd)

    def elt_filter3_variable(self, args: Any) -> int:
        """Model: elt_filter3_variable

        """
        cmd = f'''ensight.model.elt_filter3_variable({repr(args)})'''
        return self._session.cmd(cmd)

    def elt_filter4_active(self, p0: str) -> int:
        """Model: elt_filter4_active

        """
        cmd = f'''ensight.model.elt_filter4_active({repr(p0)})'''
        return self._session.cmd(cmd)

    def elt_filter4_logicalop(self, p0: str) -> int:
        """Model: elt_filter4_logicalop

        """
        cmd = f'''ensight.model.elt_filter4_logicalop({repr(p0)})'''
        return self._session.cmd(cmd)

    def elt_filter4_testop(self, p0: str) -> int:
        """Model: elt_filter4_testop

        """
        cmd = f'''ensight.model.elt_filter4_testop({repr(p0)})'''
        return self._session.cmd(cmd)

    def elt_filter4_testvalue(self, p0: float) -> int:
        """Model: elt_filter4_testvalue

        """
        cmd = f'''ensight.model.elt_filter4_testvalue({repr(p0)})'''
        return self._session.cmd(cmd)

    def elt_filter4_testvarcomp(self, p0: str) -> int:
        """Model: elt_filter4_testvarcomp

        """
        cmd = f'''ensight.model.elt_filter4_testvarcomp({repr(p0)})'''
        return self._session.cmd(cmd)

    def elt_filter4_testvariable(self, args: Any) -> int:
        """Model: elt_filter4_testvariable

        """
        cmd = f'''ensight.model.elt_filter4_testvariable({repr(args)})'''
        return self._session.cmd(cmd)

    def elt_filter4_varcomp(self, p0: str) -> int:
        """Model: elt_filter4_varcomp

        """
        cmd = f'''ensight.model.elt_filter4_varcomp({repr(p0)})'''
        return self._session.cmd(cmd)

    def elt_filter4_variable(self, args: Any) -> int:
        """Model: elt_filter4_variable

        """
        cmd = f'''ensight.model.elt_filter4_variable({repr(args)})'''
        return self._session.cmd(cmd)

    def elt_filter5_active(self, p0: str) -> int:
        """Model: elt_filter5_active

        """
        cmd = f'''ensight.model.elt_filter5_active({repr(p0)})'''
        return self._session.cmd(cmd)

    def elt_filter5_logicalop(self, p0: str) -> int:
        """Model: elt_filter5_logicalop

        """
        cmd = f'''ensight.model.elt_filter5_logicalop({repr(p0)})'''
        return self._session.cmd(cmd)

    def elt_filter5_testop(self, p0: str) -> int:
        """Model: elt_filter5_testop

        """
        cmd = f'''ensight.model.elt_filter5_testop({repr(p0)})'''
        return self._session.cmd(cmd)

    def elt_filter5_testvalue(self, p0: float) -> int:
        """Model: elt_filter5_testvalue

        """
        cmd = f'''ensight.model.elt_filter5_testvalue({repr(p0)})'''
        return self._session.cmd(cmd)

    def elt_filter5_testvarcomp(self, p0: str) -> int:
        """Model: elt_filter5_testvarcomp

        """
        cmd = f'''ensight.model.elt_filter5_testvarcomp({repr(p0)})'''
        return self._session.cmd(cmd)

    def elt_filter5_testvariable(self, args: Any) -> int:
        """Model: elt_filter5_testvariable

        """
        cmd = f'''ensight.model.elt_filter5_testvariable({repr(args)})'''
        return self._session.cmd(cmd)

    def elt_filter5_varcomp(self, p0: str) -> int:
        """Model: elt_filter5_varcomp

        """
        cmd = f'''ensight.model.elt_filter5_varcomp({repr(p0)})'''
        return self._session.cmd(cmd)

    def elt_filter5_variable(self, args: Any) -> int:
        """Model: elt_filter5_variable

        """
        cmd = f'''ensight.model.elt_filter5_variable({repr(args)})'''
        return self._session.cmd(cmd)

    def elt_filter6_active(self, p0: str) -> int:
        """Model: elt_filter6_active

        """
        cmd = f'''ensight.model.elt_filter6_active({repr(p0)})'''
        return self._session.cmd(cmd)

    def elt_filter6_logicalop(self, p0: str) -> int:
        """Model: elt_filter6_logicalop

        """
        cmd = f'''ensight.model.elt_filter6_logicalop({repr(p0)})'''
        return self._session.cmd(cmd)

    def elt_filter6_testop(self, p0: str) -> int:
        """Model: elt_filter6_testop

        """
        cmd = f'''ensight.model.elt_filter6_testop({repr(p0)})'''
        return self._session.cmd(cmd)

    def elt_filter6_testvalue(self, p0: float) -> int:
        """Model: elt_filter6_testvalue

        """
        cmd = f'''ensight.model.elt_filter6_testvalue({repr(p0)})'''
        return self._session.cmd(cmd)

    def elt_filter6_testvarcomp(self, p0: str) -> int:
        """Model: elt_filter6_testvarcomp

        """
        cmd = f'''ensight.model.elt_filter6_testvarcomp({repr(p0)})'''
        return self._session.cmd(cmd)

    def elt_filter6_testvariable(self, args: Any) -> int:
        """Model: elt_filter6_testvariable

        """
        cmd = f'''ensight.model.elt_filter6_testvariable({repr(args)})'''
        return self._session.cmd(cmd)

    def elt_filter6_varcomp(self, p0: str) -> int:
        """Model: elt_filter6_varcomp

        """
        cmd = f'''ensight.model.elt_filter6_varcomp({repr(p0)})'''
        return self._session.cmd(cmd)

    def elt_filter6_variable(self, args: Any) -> int:
        """Model: elt_filter6_variable

        """
        cmd = f'''ensight.model.elt_filter6_variable({repr(args)})'''
        return self._session.cmd(cmd)

    def ijk_axis(self, p0: str) -> int:
        """Toggles the visibility of an IJK axis attached to structured parts.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.part.select_begin(1)
                ensight.part.modify_begin()
                # WARNING: following line includes OBSOLETE call (ensight.model.ijk_axis).
                ensight.model.ijk_axis("ON")
                ensight.part.modify_end()
                ensight.part.modify_begin()
                # WARNING: following line includes OBSOLETE call (ensight.model.ijk_axis_scale).
                ensight.model.ijk_axis_scale(1.0000e+00)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.model.ijk_axis({repr(p0)})'''
        return self._session.cmd(cmd)

    def ijk_axis_scale(self, p0: float) -> int:
        """Scales an IJK axis attached to structured parts.
        
        Args:
            p0:
                'scale_value' scale factor
        
        Examples:
            ::
        
                ensight.part.select_begin(1)
                ensight.part.modify_begin()
                # WARNING: following line includes OBSOLETE call (ensight.model.ijk_axis).
                ensight.model.ijk_axis("ON")
                ensight.part.modify_end()
                ensight.part.modify_begin()
                # WARNING: following line includes OBSOLETE call (ensight.model.ijk_axis_scale).
                ensight.model.ijk_axis_scale(1.0000e+00)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.model.ijk_axis_scale({repr(p0)})'''
        return self._session.cmd(cmd)

    def noderangestep_i(self, p0: int, p1: int, p2: int) -> int:
        """Sets the IJK range and step for a structured part.
        
        | To speed interactive operations on structured data sets, only a portion of the model can be loaded.  At a later point the entire model can be loaded.
        
        Args:
            p0:
                'val1' minimum I, J, K coordinate
            p1:
                'val2' maximum I, J, K coordinate
            p2:
                'val3' I, J, K stride
        
        Examples:
            ::
        
                # partial load a structured Plot3D part
                ensight.data_partbuild.data_type("structured")
                ensight.data_partbuild.select_begin(1)
                ensight.data_partbuild.domain("all")
                ensight.data_partbuild.noderange_i(1,40)
                ensight.data_partbuild.noderange_j(1,63)
                ensight.data_partbuild.noderange_k(1,45)
                ensight.data_partbuild.nodestep(10,1,1)
                ensight.data_partbuild.nodedelta(0,0,0)
                ensight.data_partbuild.description("partial grid")
                ensight.data_partbuild.create()
                ensight.data_partbuild.end()
                ensight.part.select_all()
                ensight.part.modify_begin()
                # load every other i coordinate
                ensight.model.noderangestep_i(1,40,2)
                ensight.model.noderangestep_j(1,63,1)
                ensight.model.noderangestep_k(1,45,1)
                ensight.part.modify_end()
                ensight.part.modify_begin()
                # load all i coordinates
                ensight.model.noderangestep_i(1,80,1)
                ensight.model.noderangestep_j(1,63,1)
                ensight.model.noderangestep_k(1,45,1)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.model.noderangestep_i({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def noderangestep_j(self, p0: int, p1: int, p2: int) -> int:
        """Sets the IJK range and step for a structured part.
        
        | To speed interactive operations on structured data sets, only a portion of the model can be loaded.  At a later point the entire model can be loaded.
        
        Args:
            p0:
                'val1' minimum I, J, K coordinate
            p1:
                'val2' maximum I, J, K coordinate
            p2:
                'val3' I, J, K stride
        
        Examples:
            ::
        
                # partial load a structured Plot3D part
                ensight.data_partbuild.data_type("structured")
                ensight.data_partbuild.select_begin(1)
                ensight.data_partbuild.domain("all")
                ensight.data_partbuild.noderange_i(1,40)
                ensight.data_partbuild.noderange_j(1,63)
                ensight.data_partbuild.noderange_k(1,45)
                ensight.data_partbuild.nodestep(10,1,1)
                ensight.data_partbuild.nodedelta(0,0,0)
                ensight.data_partbuild.description("partial grid")
                ensight.data_partbuild.create()
                ensight.data_partbuild.end()
                ensight.part.select_all()
                ensight.part.modify_begin()
                # load every other i coordinate
                ensight.model.noderangestep_i(1,40,2)
                ensight.model.noderangestep_j(1,63,1)
                ensight.model.noderangestep_k(1,45,1)
                ensight.part.modify_end()
                ensight.part.modify_begin()
                # load all i coordinates
                ensight.model.noderangestep_i(1,80,1)
                ensight.model.noderangestep_j(1,63,1)
                ensight.model.noderangestep_k(1,45,1)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.model.noderangestep_j({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def noderangestep_k(self, p0: int, p1: int, p2: int) -> int:
        """Sets the IJK range and step for a structured part.
        
        | To speed interactive operations on structured data sets, only a portion of the model can be loaded.  At a later point the entire model can be loaded.
        
        Args:
            p0:
                'val1' minimum I, J, K coordinate
            p1:
                'val2' maximum I, J, K coordinate
            p2:
                'val3' I, J, K stride
        
        Examples:
            ::
        
                # partial load a structured Plot3D part
                ensight.data_partbuild.data_type("structured")
                ensight.data_partbuild.select_begin(1)
                ensight.data_partbuild.domain("all")
                ensight.data_partbuild.noderange_i(1,40)
                ensight.data_partbuild.noderange_j(1,63)
                ensight.data_partbuild.noderange_k(1,45)
                ensight.data_partbuild.nodestep(10,1,1)
                ensight.data_partbuild.nodedelta(0,0,0)
                ensight.data_partbuild.description("partial grid")
                ensight.data_partbuild.create()
                ensight.data_partbuild.end()
                ensight.part.select_all()
                ensight.part.modify_begin()
                # load every other i coordinate
                ensight.model.noderangestep_i(1,40,2)
                ensight.model.noderangestep_j(1,63,1)
                ensight.model.noderangestep_k(1,45,1)
                ensight.part.modify_end()
                ensight.part.modify_begin()
                # load all i coordinates
                ensight.model.noderangestep_i(1,80,1)
                ensight.model.noderangestep_j(1,63,1)
                ensight.model.noderangestep_k(1,45,1)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.model.noderangestep_k({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def select_default(self) -> int:
        """Sets default attribute values for model parts
        
        | model commands that follow this one set default values for new model parts loaded at a latter time during the current session.
        
        Examples:
            ::
        
                ensight.model.select_default()
                ensight.part.modify_begin()
                ensight.part.bounding_rep("points")
                ensight.part.modify_end()
                ensight.part.modify_begin()
                # WARNING: following line includes OBSOLETE call (ensight.model.ijk_axis).
                ensight.model.ijk_axis("ON")
                ensight.part.modify_end()
                ensight.data.binary_files_are("big_endian")
                ensight.data.format("plot3d")
                ensight.data.plot3diblank("OFF")
                ensight.data.plot3dmulti_zone("OFF")
                ensight.data.plot3dread_as("c_binary")
                ensight.data.plot3ddimension("3d")
                ensight.data.path("/usr/local/bin/ensight92/data/e7data/plot3d")
                ensight.data.geometry("shuttle.xyz")
                ensight.data.result("shuttle.q")
                ensight.data_partbuild.begin()
                ensight.data.read()
                ensight.data_partbuild.data_type("structured")
                ensight.data_partbuild.select_begin(1)
                ensight.data_partbuild.domain("all")
                ensight.data_partbuild.noderange_i(1,80)
                ensight.data_partbuild.noderange_j(1,63)
                ensight.data_partbuild.noderange_k(1,45)
                ensight.data_partbuild.nodestep(1,1,1)
                ensight.data_partbuild.nodedelta(0,0,0)
                ensight.data_partbuild.description("")
                ensight.data_partbuild.create()
                ensight.data_partbuild.end()
                ensight.view_transf.rotate(-2.848098,21.765417,0.000000)
                ensight.view_transf.function("global")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.model.select_default()'''
        return self._session.cmd(cmd)


class message_window:
    """Class wrapper for EnSight message_window module

    This class acts as a proxy for the EnSight Python module ensight.message_window
    """
    def __init__(self, session: Session):
        self._session = session

    def clear(self) -> int:
        """Clears the EnSight Message Window dialog
        
        Examples:
            ::
        
                ensight.message_window.clear()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.message_window.clear()'''
        return self._session.cmd(cmd)

    def display_error(self, p0: str) -> int:
        """Message_window: display_error

        """
        cmd = f'''ensight.message_window.display_error({repr(p0)})'''
        return self._session.cmd(cmd)

    def display_errorpopup(self, p0: str) -> int:
        """Message_window: display_errorpopup

        """
        cmd = f'''ensight.message_window.display_errorpopup({repr(p0)})'''
        return self._session.cmd(cmd)

    def display_information(self, p0: str) -> int:
        """Message_window: display_information

        """
        cmd = f'''ensight.message_window.display_information({repr(p0)})'''
        return self._session.cmd(cmd)

    def display_warning(self, p0: str) -> int:
        """Message_window: display_warning

        """
        cmd = f'''ensight.message_window.display_warning({repr(p0)})'''
        return self._session.cmd(cmd)

    def memory_snapshot(self, p0: str) -> int:
        """Message_window: memory_snapshot

        """
        cmd = f'''ensight.message_window.memory_snapshot({repr(p0)})'''
        return self._session.cmd(cmd)

    def query(self, args: Any) -> int:
        """Message_window: query

        """
        cmd = f'''ensight.message_window.query({repr(args)})'''
        return self._session.cmd(cmd)

    def save(self, p0: str) -> int:
        """Saves the contents of the EnSight Message Window dialog to a file.
        
        Args:
            p0:
                'filename' filename into which the contents of the message window is to be saved.
        
        Examples:
            ::
        
                ensight.message_window.save("/home/users/me/myfile.txt")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.message_window.save({repr(p0)})'''
        return self._session.cmd(cmd)


class material:
    """Class wrapper for EnSight material module

    This class acts as a proxy for the EnSight Python module ensight.material
    """
    def __init__(self, session: Session):
        self._session = session

    def begin(self) -> int:
        """Delimit the modifications for material part attributes.
        
        Examples:
            ::
        
                #
                # Select the parent part
                #
                ensight.part.select_begin(1)
                #
                ensight.material.begin()
                #
                # create a domain type material part
                #
                ensight.material.type("domain")
                ensight.material.subdivide("2")
                #
                # use the two materials shown
                #
                ensight.material.select_byname_begin("matl_02","matl_03")
                ensight.material.end()
                ensight.material.create()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.material.begin()'''
        return self._session.cmd(cmd)

    def create(self) -> int:
        """Create a material part with the currently defined attributes using the currently selected parts as parent parts.
        
        Examples:
            ::
        
                #
                # Select the parent part
                #
                ensight.part.select_begin(1)
                #
                ensight.material.begin()
                #
                # create a domain type material part
                #
                ensight.material.type("domain")
                ensight.material.subdivide("2")
                #
                # use the two materials shown
                #
                ensight.material.select_byname_begin("matl_02","matl_03")
                ensight.material.end()
                ensight.material.create()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.material.create()'''
        return self._session.cmd(cmd)

    def end(self) -> int:
        """Delimit the modifications for material part attributes.
        
        Examples:
            ::
        
                #
                # Select the parent part
                #
                ensight.part.select_begin(1)
                #
                ensight.material.begin()
                #
                # create a domain type material part
                #
                ensight.material.type("domain")
                ensight.material.subdivide("2")
                #
                # use the two materials shown
                #
                ensight.material.select_byname_begin("matl_02","matl_03")
                ensight.material.end()
                ensight.material.create()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.material.end()'''
        return self._session.cmd(cmd)

    def material(self, args: Any) -> int:
        """Material: material

        """
        cmd = f'''ensight.material.material({repr(args)})'''
        return self._session.cmd(cmd)

    def method(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.material.method({repr(p0)})'''
        return self._session.cmd(cmd)

    def normal(self, p0: Any) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.material.normal({repr(p0)})'''
        return self._session.cmd(cmd)

    def select_begin(self, *args, **kwargs) -> Any:
        """Material: select_begin

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.material.select_begin({arg_string})"
        return self._session.cmd(cmd)

    def select_byname_begin(self, *args, **kwargs) -> Any:
        """Delimit material name selection.
        
        Examples:
            ::
        
                #
                # Select the parent part
                #
                ensight.part.select_begin(1)
                #
                ensight.material.begin()
                #
                # create a domain type material part using materials matl_02 and matl_03
                #
                ensight.material.type("domain")
                ensight.material.subdivide("2")
                #
                # use the two materials shown
                #
                ensight.material.select_byname_begin("matl_02","matl_03")
                ensight.material.end()
                ensight.material.create()
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.material.select_byname_begin({arg_string})"
        return self._session.cmd(cmd)

    def select_byname_end(self) -> int:
        """Delimit material name selection.
        
        Examples:
            ::
        
                #
                # Select the parent part
                #
                ensight.part.select_begin(1)
                #
                ensight.material.begin()
                #
                # create a domain type material part using materials matl_02 and matl_03
                #
                ensight.material.type("domain")
                ensight.material.subdivide("2")
                #
                # use the two materials shown
                #
                ensight.material.select_byname_begin("matl_02","matl_03")
                ensight.material.end()
                ensight.material.create()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.material.select_byname_end()'''
        return self._session.cmd(cmd)

    def select_bynamesort_begin(self, args: Any) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.material.select_bynamesort_begin({repr(args)})'''
        return self._session.cmd(cmd)

    def select_bynamesort_end(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.material.select_bynamesort_end()'''
        return self._session.cmd(cmd)

    def select_default(self) -> int:
        """Sets the target to the default settings for subsequent attribute modifications.
        
        Examples:
            ::
        
                ensight.material.select_default()
                ensight.part.modify_begin()
                ensight.material.type("domain")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.material.select_default()'''
        return self._session.cmd(cmd)

    def subdivide(self, p0: str) -> int:
        """Set the accuracy of the resulting material part - higher values result in higher fidelity.
        
        Args:
            p0:
                'level'
        
                * 1
                * 2
                * 3
        
        Examples:
            ::
        
                #
                # Select the parent part
                #
                ensight.part.select_begin(1)
                #
                ensight.material.begin()
                #
                # create a domain type material part
                #
                ensight.material.type("domain")
                ensight.material.subdivide("2")
                #
                # use the two materials shown
                #
                ensight.material.select_byname_begin("matl_02","matl_03")
                ensight.material.end()
                ensight.material.create()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.material.subdivide({repr(p0)})'''
        return self._session.cmd(cmd)

    def type(self, p0: str) -> int:
        """Set the resulting material part to be a domain or interface through/between the material selected.
        
        Args:
            p0:
                'type'
        
                * domain
                * interface
        
        Examples:
            ::
        
                #
                # Select the parent part
                #
                ensight.part.select_begin(1)
                #
                ensight.material.begin()
                #
                # create a domain type material part
                #
                ensight.material.type("domain")
                ensight.material.subdivide("2")
                #
                # use the two materials shown
                #
                ensight.material.select_byname_begin("matl_02","matl_03")
                ensight.material.end()
                ensight.material.create()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.material.type({repr(p0)})'''
        return self._session.cmd(cmd)


class logo:
    """Class wrapper for EnSight logo module

    This class acts as a proxy for the EnSight Python module ensight.logo
    """
    def __init__(self, session: Session):
        self._session = session

    def delete(self) -> int:
        """Deletes the currently selected logo(s) in the graphics window.
        
        Examples:
            ::
        
                ensight.logo.select_begin(1,2,3)
                ensight.logo.delete()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.logo.delete()'''
        return self._session.cmd(cmd)

    def description(self, p0: str) -> int:
        """Logo: description

        """
        cmd = f'''ensight.logo.description({repr(p0)})'''
        return self._session.cmd(cmd)

    def deselect_all(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.logo.deselect_all()'''
        return self._session.cmd(cmd)

    def location_x(self, p0: float) -> int:
        """Specifies the x/y coordinate of the selected logo in the graphics window.
        
        | The lower left corner of the logo will be positioned at this point (x,y).
        
        Args:
            p0:
                'coord' A value of 0.0 indicates the left/bottom of the window, while a value of 1.0 indicates the right/top side
        
        Examples:
            ::
        
                ensight.logo.select_begin(1)
                ensight.logo.location_x(0.5)
                ensight.logo.location_y(0.5)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.logo.location_x({repr(p0)})'''
        return self._session.cmd(cmd)

    def location_y(self, p0: float) -> int:
        """Specifies the x/y coordinate of the selected logo in the graphics window.
        
        | The lower left corner of the logo will be positioned at this point (x,y).
        
        Args:
            p0:
                'coord' A value of 0.0 indicates the left/bottom of the window, while a value of 1.0 indicates the right/top side
        
        Examples:
            ::
        
                ensight.logo.select_begin(1)
                ensight.logo.location_x(0.5)
                ensight.logo.location_y(0.5)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.logo.location_y({repr(p0)})'''
        return self._session.cmd(cmd)

    def modify_begin(self) -> int:
        """These optional commands can be used to demarcate a series of logo: commands which apply to the same logo or logos, so that they can be executed at one time for better performance.
        
        Examples:
            ::
        
                ensight.logo.select_begin(1)
                ensight.logo.modify_begin()
                # WARNING: following line includes OBSOLETE call (ensight.logo.rgb).
                ensight.logo.rgb(1,0,0)
                ensight.logo.location_x(100)
                ensight.logo.location_y(20)
                ensight.logo.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.logo.modify_begin()'''
        return self._session.cmd(cmd)

    def modify_end(self) -> int:
        """These optional commands can be used to demarcate a series of logo: commands which apply to the same logo or logos, so that they can be executed at one time for better performance.
        
        Examples:
            ::
        
                ensight.logo.select_begin(1)
                ensight.logo.modify_begin()
                # WARNING: following line includes OBSOLETE call (ensight.logo.rgb).
                ensight.logo.rgb(1,0,0)
                ensight.logo.location_x(100)
                ensight.logo.location_y(20)
                ensight.logo.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.logo.modify_end()'''
        return self._session.cmd(cmd)

    def new_logo(self, p0: str) -> int:
        """Creates a new logo in the graphics window. 
        
        | The logo file can be any valid XPM file. The filename does not have to include an ".xpm" extension.
        
        Args:
            p0:
                'filename' path to the logo file
        
        Examples:
            ::
        
                ensight.logo.new_logo("/usr/tmp/mylogo.xpm")
                ensight.logo.location_x(0.5)
                ensight.logo.location_y(0.6)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.logo.new_logo({repr(p0)})'''
        return self._session.cmd(cmd)

    def new_or_mod_logo(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.logo.new_or_mod_logo({repr(p0)})'''
        return self._session.cmd(cmd)

    def normalized_width(self, p0: float) -> int:
        """Logo: normalized_width

        """
        cmd = f'''ensight.logo.normalized_width({repr(p0)})'''
        return self._session.cmd(cmd)

    def query_count(self, args: Any) -> int:
        """Logo: query_count

        """
        cmd = f'''ensight.logo.query_count({repr(args)})'''
        return self._session.cmd(cmd)

    def query_display_attributes(self, args: Any) -> int:
        """Logo: query_display_attributes

        """
        cmd = f'''ensight.logo.query_display_attributes({repr(args)})'''
        return self._session.cmd(cmd)

    def query_selected_objects(self, args: Any) -> int:
        """Logo: query_selected_objects

        """
        cmd = f'''ensight.logo.query_selected_objects({repr(args)})'''
        return self._session.cmd(cmd)

    def read(self, p0: str) -> int:
        """Logo: read

        """
        cmd = f'''ensight.logo.read({repr(p0)})'''
        return self._session.cmd(cmd)

    def rgb(self, p0: float, p1: float, p2: float) -> int:
        """Logo: rgb

        """
        cmd = f'''ensight.logo.rgb({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def scale(self, p0: float, p1: float) -> int:
        """Scales the selected logo up or down in x and y dimensions
        
        Args:
            p0:
                'x_val' Can be any value between 0 and infinity, with a value of one specifying no change, values less than one specifying shrinkage and values greater than one specifying expansion.
            p1:
                'y_val' Can be any value between 0 and infinity, with a value of one specifying no change, values less than one specifying shrinkage and values greater than one specifying expansion.
        
        Examples:
            ::
        
                ensight.logo.new_logo("/usr/tmp/mylogo.xpm")
                ensight.logo.location_x(0.5)
                ensight.logo.location_y(0.6)
                ensight.logo.scale(2.5,2)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.logo.scale({repr(p0)},{repr(p1)})'''
        return self._session.cmd(cmd)

    def select_all(self) -> int:
        """Logo: select_all

        """
        cmd = f'''ensight.logo.select_all()'''
        return self._session.cmd(cmd)

    def select_all_invisible(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.logo.select_all_invisible()'''
        return self._session.cmd(cmd)

    def select_all_visible(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.logo.select_all_visible()'''
        return self._session.cmd(cmd)

    def select_begin(self, *args, **kwargs) -> Any:
        """Selects one or more logos in the graphics window as the target for future logo: commands 
        
        | Using these commands is equivalent to selecting logos by clicking on them in the graphics window with the CTRL key held down.
        
        Args:
            p0:
                'indexN' up to a maximum of 10 values per line
        
        Examples:
            ::
        
                ensight.logo.select_begin(1,2)
                # WARNING: following line includes OBSOLETE call (ensight.logo.rgb).
                ensight.logo.rgb(1,0,0)
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.logo.select_begin({arg_string})"
        return self._session.cmd(cmd)

    def select_default(self) -> int:
        """Causes any following logo: commands to affect the default settings, rather than a particular logo.
        
        | All logo: commands following logo: select_default will affect default settings until a new logo is selected using logo: select_begin.
        
        Examples:
            ::
        
                ensight.logo.select_default()
                ensight.logo.visible("OFF")
                # WARNING: following line includes OBSOLETE call (ensight.logo.rgb).
                ensight.logo.rgb(1,0,0)
                ensight.logo.select_begin(1)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.logo.select_default()'''
        return self._session.cmd(cmd)

    def show_raytraced_image(self, p0: str) -> int:
        """Logo: show_raytraced_image

        """
        cmd = f'''ensight.logo.show_raytraced_image({repr(p0)})'''
        return self._session.cmd(cmd)

    def use_normalized_width(self, p0: str) -> int:
        """Logo: use_normalized_width

        """
        cmd = f'''ensight.logo.use_normalized_width({repr(p0)})'''
        return self._session.cmd(cmd)

    def visible(self, p0: str) -> int:
        """Controls the visibility of the selected logo in the graphics window. 
        
        |  Logos are visible by default.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.logo.select_begin(1)
                ensight.logo.visible("ON")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.logo.visible({repr(p0)})'''
        return self._session.cmd(cmd)


class line:
    """Class wrapper for EnSight line module

    This class acts as a proxy for the EnSight Python module ensight.line
    """
    def __init__(self, session: Session):
        self._session = session

    def arrowhead(self, p0: str) -> int:
        """Controls the display of arrowheads on the currently selected  line in the graphics window.
        
        Args:
            p0:
                'head_type'
        
                * can be any of the following values:
                * none
                * on_first_end
                * on_second_end
                * on_both_ends
        
        Examples:
            ::
        
                ensight.line.select_begin(1)
                ensight.line.arrowhead("on_first_end")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.line.arrowhead({repr(p0)})'''
        return self._session.cmd(cmd)

    def color(self, p0: int) -> int:
        """Line: color

        """
        cmd = f'''ensight.line.color({repr(p0)})'''
        return self._session.cmd(cmd)

    def delete(self) -> int:
        """Line: delete

        """
        cmd = f'''ensight.line.delete()'''
        return self._session.cmd(cmd)

    def description(self, p0: str) -> int:
        """Line: description

        """
        cmd = f'''ensight.line.description({repr(p0)})'''
        return self._session.cmd(cmd)

    def deselect_all(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.line.deselect_all()'''
        return self._session.cmd(cmd)

    def label_text_id(self, args: Any) -> int:
        """Line: label_text_id

        """
        cmd = f'''ensight.line.label_text_id({repr(args)})'''
        return self._session.cmd(cmd)

    def location_x(self, p0: float, p1: float) -> int:
        """Specifies the x/y coordinate of an endpoint for the selected line in the graphics window.
        
        Args:
            p0:
                'index' Must be either 1 or 2, depending on which endpoint is being specified.
            p1:
                'coord' Specifies the x/y coordinate. A value of 0.0 indicates the left/bottom side of the window, while a value of 1.0 indicates the right/top side.
        
        Examples:
            ::
        
                ensight.line.select_begin(1)
                # WARNING: following line includes OBSOLETE call (ensight.line.location_x).
                ensight.line.location_x(1,0.5)
                # WARNING: following line includes OBSOLETE call (ensight.line.location_y).
                ensight.line.location_y(1,0.6)
                # WARNING: following line includes OBSOLETE call (ensight.line.location_x).
                ensight.line.location_x(2,0.1)
                # WARNING: following line includes OBSOLETE call (ensight.line.location_y).
                ensight.line.location_y(2,0.3)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.line.location_x({repr(p0)},{repr(p1)})'''
        return self._session.cmd(cmd)

    def location_x_1(self, p0: float) -> int:
        """Line: location_x 1

        """
        cmd = f'''ensight.line.location_x_1({repr(p0)})'''
        return self._session.cmd(cmd)

    def location_x_2(self, p0: float) -> int:
        """Line: location_x 2

        """
        cmd = f'''ensight.line.location_x_2({repr(p0)})'''
        return self._session.cmd(cmd)

    def location_y(self, p0: float, p1: float) -> int:
        """Specifies the x/y coordinate of an endpoint for the selected line in the graphics window.
        
        Args:
            p0:
                'index' Must be either 1 or 2, depending on which endpoint is being specified.
            p1:
                'coord' Specifies the x/y coordinate. A value of 0.0 indicates the left/bottom side of the window, while a value of 1.0 indicates the right/top side.
        
        Examples:
            ::
        
                ensight.line.select_begin(1)
                # WARNING: following line includes OBSOLETE call (ensight.line.location_x).
                ensight.line.location_x(1,0.5)
                # WARNING: following line includes OBSOLETE call (ensight.line.location_y).
                ensight.line.location_y(1,0.6)
                # WARNING: following line includes OBSOLETE call (ensight.line.location_x).
                ensight.line.location_x(2,0.1)
                # WARNING: following line includes OBSOLETE call (ensight.line.location_y).
                ensight.line.location_y(2,0.3)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.line.location_y({repr(p0)},{repr(p1)})'''
        return self._session.cmd(cmd)

    def location_y_1(self, p0: float) -> int:
        """Line: location_y 1

        """
        cmd = f'''ensight.line.location_y_1({repr(p0)})'''
        return self._session.cmd(cmd)

    def location_y_2(self, p0: float) -> int:
        """Line: location_y 2

        """
        cmd = f'''ensight.line.location_y_2({repr(p0)})'''
        return self._session.cmd(cmd)

    def mix_rgb(self, p0: float, p1: float, p2: float, p3: float) -> int:
        """Line: mix_rgb

        """
        cmd = f'''ensight.line.mix_rgb({repr(p0)},{repr(p1)},{repr(p2)},{repr(p3)})'''
        return self._session.cmd(cmd)

    def modify_begin(self) -> int:
        """These optional commands can be used to demarcate a series of line: commands which apply to the same line or lines so that they can be executed at one time for better performance.
        
        Examples:
            ::
        
                ensight.line.select_begin(1)
                ensight.line.modify_begin()
                ensight.line.rgb(1,0,0)
                # WARNING: following line includes OBSOLETE call (ensight.line.location_x).
                ensight.line.location_x(1,100)
                # WARNING: following line includes OBSOLETE call (ensight.line.location_y).
                ensight.line.location_y(1,20)
                # WARNING: following line includes OBSOLETE call (ensight.line.location_x).
                ensight.line.location_x(2,10)
                # WARNING: following line includes OBSOLETE call (ensight.line.location_y).
                ensight.line.location_y(2,10)
                ensight.line.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.line.modify_begin()'''
        return self._session.cmd(cmd)

    def modify_end(self) -> int:
        """These optional commands can be used to demarcate a series of line: commands which apply to the same line or lines so that they can be executed at one time for better performance.
        
        Examples:
            ::
        
                ensight.line.select_begin(1)
                ensight.line.modify_begin()
                ensight.line.rgb(1,0,0)
                # WARNING: following line includes OBSOLETE call (ensight.line.location_x).
                ensight.line.location_x(1,100)
                # WARNING: following line includes OBSOLETE call (ensight.line.location_y).
                ensight.line.location_y(1,20)
                # WARNING: following line includes OBSOLETE call (ensight.line.location_x).
                ensight.line.location_x(2,10)
                # WARNING: following line includes OBSOLETE call (ensight.line.location_y).
                ensight.line.location_y(2,10)
                ensight.line.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.line.modify_end()'''
        return self._session.cmd(cmd)

    def new_line(self) -> int:
        """Creates a new line in the graphics window.
        
        Examples:
            ::
        
                ensight.line.new_line()
                # WARNING: following line includes OBSOLETE call (ensight.line.location_x).
                ensight.line.location_x(1,0.5)
                # WARNING: following line includes OBSOLETE call (ensight.line.location_y).
                ensight.line.location_y(1,0.6)
                # WARNING: following line includes OBSOLETE call (ensight.line.location_x).
                ensight.line.location_x(2,0.6)
                # WARNING: following line includes OBSOLETE call (ensight.line.location_y).
                ensight.line.location_y(2,0.5)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.line.new_line()'''
        return self._session.cmd(cmd)

    def new_or_mod_line(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.line.new_or_mod_line({repr(p0)})'''
        return self._session.cmd(cmd)

    def origin(self, p0: float, p1: float, p2: float, p3: float) -> int:
        """Line: origin

        """
        cmd = f'''ensight.line.origin({repr(p0)},{repr(p1)},{repr(p2)},{repr(p3)})'''
        return self._session.cmd(cmd)

    def origin_1(self, p0: float, p1: float, p2: float) -> int:
        """Line: origin 1

        """
        cmd = f'''ensight.line.origin_1({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def origin_2(self, p0: float, p1: float, p2: float) -> int:
        """Line: origin 2

        """
        cmd = f'''ensight.line.origin_2({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def origin_by(self, p0: str) -> int:
        """Line: origin_by

        """
        cmd = f'''ensight.line.origin_by({repr(p0)})'''
        return self._session.cmd(cmd)

    def origin_by_1(self, p0: str) -> int:
        """Line: origin_by 1

        """
        cmd = f'''ensight.line.origin_by_1({repr(p0)})'''
        return self._session.cmd(cmd)

    def origin_by_2(self, p0: str) -> int:
        """Line: origin_by 2

        """
        cmd = f'''ensight.line.origin_by_2({repr(p0)})'''
        return self._session.cmd(cmd)

    def origin_frame(self, p0: int) -> int:
        """Line: origin_frame

        """
        cmd = f'''ensight.line.origin_frame({repr(p0)})'''
        return self._session.cmd(cmd)

    def query_count(self, args: Any) -> int:
        """Line: query_count

        """
        cmd = f'''ensight.line.query_count({repr(args)})'''
        return self._session.cmd(cmd)

    def query_display_attributes(self, args: Any) -> int:
        """Line: query_display_attributes

        """
        cmd = f'''ensight.line.query_display_attributes({repr(args)})'''
        return self._session.cmd(cmd)

    def query_selected_objects(self, args: Any) -> int:
        """Line: query_selected_objects

        """
        cmd = f'''ensight.line.query_selected_objects({repr(args)})'''
        return self._session.cmd(cmd)

    def relative_viewport(self, p0: str) -> int:
        """Line: relative_viewport

        """
        cmd = f'''ensight.line.relative_viewport({repr(p0)})'''
        return self._session.cmd(cmd)

    def relative_viewport_1(self, p0: str) -> int:
        """Line: relative_viewport 1

        """
        cmd = f'''ensight.line.relative_viewport_1({repr(p0)})'''
        return self._session.cmd(cmd)

    def relative_viewport_2(self, p0: str) -> int:
        """Line: relative_viewport 2

        """
        cmd = f'''ensight.line.relative_viewport_2({repr(p0)})'''
        return self._session.cmd(cmd)

    def rgb(self, p0: float, p1: float, p2: float) -> int:
        """Specifies the RGB color value of the selected line(s) .
        
        Args:
            p0:
                'red_val' red, green, blue color components.  Must be between 0.0 and 1.0
            p1:
                'grn_val' red, green, blue color components.  Must be between 0.0 and 1.0
            p2:
                'blu_val' red, green, blue color components.  Must be between 0.0 and 1.0
        
        Examples:
            ::
        
                ensight.line.select_begin(1)
                ensight.line.rgb(1,0,0)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.line.rgb({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def select_all(self) -> int:
        """Selects all of the annotation lines as the target for future line: commands.
        
        Examples:
            ::
        
                ensight.line.select_all()
                ensight.line.delete()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.line.select_all()'''
        return self._session.cmd(cmd)

    def select_all_invisible(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.line.select_all_invisible()'''
        return self._session.cmd(cmd)

    def select_all_visible(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.line.select_all_visible()'''
        return self._session.cmd(cmd)

    def select_begin(self, *args, **kwargs) -> Any:
        """Selects one or more lines in the graphics window as the  target for future line: commands.
        
        | Using these commands is equivalent to selecting lines by clicking on them in the graphics window with the CTRL key held down.
        
        Args:
            p0:
                'indexN' up to a maximum of  10 values per line
        
        Examples:
            ::
        
                ensight.line.select_begin(1,2)
                ensight.line.rgb(1,0,0)
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.line.select_begin({arg_string})"
        return self._session.cmd(cmd)

    def select_default(self) -> int:
        """Causes any following line: commands to affect the default settings, rather than a particular line.
        
        | All line: commands following line: select_default will affect default settings until a new line is selected using line: select_begin/select_end.
        
        Examples:
            ::
        
                ensight.line.select_default()
                ensight.line.visible("OFF")
                ensight.line.rgb(1,0,0)
                ensight.line.select_begin(1)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.line.select_default()'''
        return self._session.cmd(cmd)

    def visible(self, p0: str) -> int:
        """Controls the visibility of the selected lines in the graphics window.
        
        | Lines are visible by default.
        
        Args:
            p0:
                'toggle'
        
                * ON 
                * OFF 
        
        Examples:
            ::
        
                ensight.line.select_begin(1)
                ensight.line.visible("ON")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.line.visible({repr(p0)})'''
        return self._session.cmd(cmd)

    def width(self, p0: int) -> int:
        """Sets the width of the currently selected line.
        
        Args:
            p0:
                'width' width (in pixels) can be any value from 1 to 4
        
        Examples:
            ::
        
                ensight.line.select_begin(1)
                ensight.line.width(2)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.line.width({repr(p0)})'''
        return self._session.cmd(cmd)


class lightsource:
    """Class wrapper for EnSight lightsource module

    This class acts as a proxy for the EnSight Python module ensight.lightsource
    """
    def __init__(self, session: Session):
        self._session = session

    def active(self, p0: str) -> int:
        """Lightsource: active

        """
        cmd = f'''ensight.lightsource.active({repr(p0)})'''
        return self._session.cmd(cmd)

    def casts_shadows(self, p0: str) -> int:
        """Lightsource: casts_shadows

        """
        cmd = f'''ensight.lightsource.casts_shadows({repr(p0)})'''
        return self._session.cmd(cmd)

    def centroid(self, p0: float, p1: float, p2: float) -> int:
        """Lightsource: centroid

        """
        cmd = f'''ensight.lightsource.centroid({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def direction_intersect(self, p0: float, p1: float, p2: float) -> int:
        """Lightsource: direction_intersect

        """
        cmd = f'''ensight.lightsource.direction_intersect({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def direction_lock(self, p0: str) -> int:
        """Lightsource: direction_lock

        """
        cmd = f'''ensight.lightsource.direction_lock({repr(p0)})'''
        return self._session.cmd(cmd)

    def direction_normal(self, p0: float, p1: float, p2: float) -> int:
        """Lightsource: direction_normal

        """
        cmd = f'''ensight.lightsource.direction_normal({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def environment_map_name(self, args: Any) -> int:
        """Lightsource: environment_map_name

        """
        cmd = f'''ensight.lightsource.environment_map_name({repr(args)})'''
        return self._session.cmd(cmd)

    def get_quad_fromplanetool(self, p0: int) -> int:
        """Lightsource: get_quad_fromplanetool

        """
        cmd = f'''ensight.lightsource.get_quad_fromplanetool({repr(p0)})'''
        return self._session.cmd(cmd)

    def glyph_size(self, p0: float) -> int:
        """Lightsource: glyph_size

        """
        cmd = f'''ensight.lightsource.glyph_size({repr(p0)})'''
        return self._session.cmd(cmd)

    def intensity(self, p0: float) -> int:
        """Lightsource: intensity

        """
        cmd = f'''ensight.lightsource.intensity({repr(p0)})'''
        return self._session.cmd(cmd)

    def location(self, p0: float, p1: float, p2: float) -> int:
        """Lightsource: location

        """
        cmd = f'''ensight.lightsource.location({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def modify_begin(self) -> int:
        """Lightsource: modify_begin

        """
        cmd = f'''ensight.lightsource.modify_begin()'''
        return self._session.cmd(cmd)

    def modify_end(self) -> int:
        """Lightsource: modify_end

        """
        cmd = f'''ensight.lightsource.modify_end()'''
        return self._session.cmd(cmd)

    def quad_size(self, p0: float, p1: float) -> int:
        """Lightsource: quad_size

        """
        cmd = f'''ensight.lightsource.quad_size({repr(p0)},{repr(p1)})'''
        return self._session.cmd(cmd)

    def quad_xdir(self, p0: float, p1: float, p2: float) -> int:
        """Lightsource: quad_xdir

        """
        cmd = f'''ensight.lightsource.quad_xdir({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def reset_envmap_rotation(self, args: Any) -> int:
        """Lightsource: reset_envmap_rotation

        """
        cmd = f'''ensight.lightsource.reset_envmap_rotation({repr(args)})'''
        return self._session.cmd(cmd)

    def reset_envmap_translation(self, args: Any) -> int:
        """Lightsource: reset_envmap_translation

        """
        cmd = f'''ensight.lightsource.reset_envmap_translation({repr(args)})'''
        return self._session.cmd(cmd)

    def rgb(self, p0: float, p1: float, p2: float) -> int:
        """Lightsource: rgb

        """
        cmd = f'''ensight.lightsource.rgb({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def rotate_envmap_x(self, p0: float) -> int:
        """Lightsource: rotate_envmap_x

        """
        cmd = f'''ensight.lightsource.rotate_envmap_x({repr(p0)})'''
        return self._session.cmd(cmd)

    def rotate_envmap_y(self, p0: float) -> int:
        """Lightsource: rotate_envmap_y

        """
        cmd = f'''ensight.lightsource.rotate_envmap_y({repr(p0)})'''
        return self._session.cmd(cmd)

    def rotate_envmap_z(self, p0: float) -> int:
        """Lightsource: rotate_envmap_z

        """
        cmd = f'''ensight.lightsource.rotate_envmap_z({repr(p0)})'''
        return self._session.cmd(cmd)

    def select_all(self) -> int:
        """Lightsource: select_all

        """
        cmd = f'''ensight.lightsource.select_all()'''
        return self._session.cmd(cmd)

    def select_begin(self, *args, **kwargs) -> Any:
        """Lightsource: select_begin

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.lightsource.select_begin({arg_string})"
        return self._session.cmd(cmd)

    def set_lights_bypreset(self, p0: str) -> int:
        """Lightsource: set_lights_bypreset

        """
        cmd = f'''ensight.lightsource.set_lights_bypreset({repr(p0)})'''
        return self._session.cmd(cmd)

    def set_planetool_fromquad(self, p0: int) -> int:
        """Lightsource: set_planetool_fromquad

        """
        cmd = f'''ensight.lightsource.set_planetool_fromquad({repr(p0)})'''
        return self._session.cmd(cmd)

    def spot_angle(self, p0: int) -> int:
        """Lightsource: spot_angle

        """
        cmd = f'''ensight.lightsource.spot_angle({repr(p0)})'''
        return self._session.cmd(cmd)

    def spot_falloff(self, args: Any) -> int:
        """Lightsource: spot_falloff

        """
        cmd = f'''ensight.lightsource.spot_falloff({repr(args)})'''
        return self._session.cmd(cmd)

    def transform_with_model(self, p0: str) -> int:
        """Lightsource: transform_with_model

        """
        cmd = f'''ensight.lightsource.transform_with_model({repr(p0)})'''
        return self._session.cmd(cmd)

    def translate_envmap_originx(self, p0: float) -> int:
        """Lightsource: translate_envmap_originx

        """
        cmd = f'''ensight.lightsource.translate_envmap_originx({repr(p0)})'''
        return self._session.cmd(cmd)

    def translate_envmap_originy(self, p0: float) -> int:
        """Lightsource: translate_envmap_originy

        """
        cmd = f'''ensight.lightsource.translate_envmap_originy({repr(p0)})'''
        return self._session.cmd(cmd)

    def translate_envmap_originz(self, p0: float) -> int:
        """Lightsource: translate_envmap_originz

        """
        cmd = f'''ensight.lightsource.translate_envmap_originz({repr(p0)})'''
        return self._session.cmd(cmd)

    def type(self, p0: str) -> int:
        """Lightsource: type

        """
        cmd = f'''ensight.lightsource.type({repr(p0)})'''
        return self._session.cmd(cmd)

    def visible(self, p0: str) -> int:
        """Lightsource: visible

        """
        cmd = f'''ensight.lightsource.visible({repr(p0)})'''
        return self._session.cmd(cmd)


class legend:
    """Class wrapper for EnSight legend module

    This class acts as a proxy for the EnSight Python module ensight.legend
    """
    def __init__(self, session: Session):
        self._session = session

    def description(self, p0: str) -> int:
        """Legend: description

        """
        cmd = f'''ensight.legend.description({repr(p0)})'''
        return self._session.cmd(cmd)

    def deselect_all(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.legend.deselect_all()'''
        return self._session.cmd(cmd)

    def format(self, p0: str) -> int:
        """Set the number format for legend labels.
        
        | If you are not familiar with the C language, any C language manual will have a description of valid number formats and how they affect the displayed appearance of a number.
        
        Args:
            p0:
                'number_format' This can be any valid C language number format, such as:
            p1:
                'number_format' %.2e
            p2:
                'number_format' %12.5e
            p3:
                'number_format' %f
            p4:
                'number_format' %g
            p5:
                'number_format' %.4f
        
        Examples:
            ::
        
                ensight.legend.select_palette_begin("pressure")
                ensight.legend.format("%.2e")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.legend.format({repr(p0)})'''
        return self._session.cmd(cmd)

    def get_mainvarlist_select(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.legend.get_mainvarlist_select()'''
        return self._session.cmd(cmd)

    def height(self, p0: float) -> int:
        """Set the height of the legend bar
        
        | The height is in terms of screen coordinates, which are 0.0 to 1.0 in both x and y directions. 
        
        Args:
            p0:
                'num' height of the legend bar
        
        Examples:
            ::
        
                ensight.legend.select_palette_begin("pressure")
                ensight.legend.location_x(2.1362e-01)
                ensight.legend.location_y(4.5270e-02)
                ensight.legend.width(5.7778e-02)
                ensight.legend.height(8.5655e-01)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.legend.height({repr(p0)})'''
        return self._session.cmd(cmd)

    def label_count(self, p0: int) -> int:
        """Legend: label_count

        """
        cmd = f'''ensight.legend.label_count({repr(p0)})'''
        return self._session.cmd(cmd)

    def location_x(self, p0: float) -> int:
        """Set the horizontal/vertical location of the legend on the screen.
        
        | The range of valid x/y screen position values is 0.0 to 1.0.
        
        Args:
            p0:
                'num' horizontal/vertical screen position of lower left of legend bar
        
        Examples:
            ::
        
                ensight.legend.select_palette_begin("pressure")
                ensight.legend.location_x(.2)
                ensight.legend.location_y(.05)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.legend.location_x({repr(p0)})'''
        return self._session.cmd(cmd)

    def location_y(self, p0: float) -> int:
        """Set the horizontal/vertical location of the legend on the screen.
        
        | The range of valid x/y screen position values is 0.0 to 1.0.
        
        Args:
            p0:
                'num' horizontal/vertical screen position of lower left of legend bar
        
        Examples:
            ::
        
                ensight.legend.select_palette_begin("pressure")
                ensight.legend.location_x(.2)
                ensight.legend.location_y(.05)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.legend.location_y({repr(p0)})'''
        return self._session.cmd(cmd)

    def modify_begin(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.legend.modify_begin()'''
        return self._session.cmd(cmd)

    def modify_end(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.legend.modify_end()'''
        return self._session.cmd(cmd)

    def orientation(self, p0: str) -> int:
        """Set the legend bar to be either vertical or horizontal.
        
        | The normal orientation is vertical.  If orientation is set to horizontal, be aware that width is now in the y-direction, height in the x-direction, and that label sizes become more important to avoid overlaps (even though it will attempt to alleviate this by alternating sides if needed).
        
        Args:
            p0:
                'layout'
        
                * vertical
                * horizontal
        
        Examples:
            ::
        
                ensight.legend.select_palette_begin("velocity")
                ensight.legend.visible("ON")
                ensight.legend.orientation("horizontal")
                ensight.legend.select_palette_begin("pressure")
                ensight.legend.orientation("vertical")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.legend.orientation({repr(p0)})'''
        return self._session.cmd(cmd)

    def query_count(self, args: Any) -> int:
        """Legend: query_count

        """
        cmd = f'''ensight.legend.query_count({repr(args)})'''
        return self._session.cmd(cmd)

    def query_display_attributes(self, args: Any) -> int:
        """Legend: query_display_attributes

        """
        cmd = f'''ensight.legend.query_display_attributes({repr(args)})'''
        return self._session.cmd(cmd)

    def query_selected_objects(self, args: Any) -> int:
        """Legend: query_selected_objects

        """
        cmd = f'''ensight.legend.query_selected_objects({repr(args)})'''
        return self._session.cmd(cmd)

    def relative_to(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.legend.relative_to({repr(p0)})'''
        return self._session.cmd(cmd)

    def relative_viewport(self, p0: int) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.legend.relative_viewport({repr(p0)})'''
        return self._session.cmd(cmd)

    def rgb(self, p0: float, p1: float, p2: float) -> int:
        """Legend: rgb

        """
        cmd = f'''ensight.legend.rgb({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def select_all(self) -> int:
        """Selects all legends that are currently visible, for which other attributes will be set or modified.
        
        | If any legends are currently visible, but not currently selected, this command will cause them to become selected. Thus, subsequent attribute modifications will apply to all visible legends.
        
        Examples:
            ::
        
                ensight.legend.select_all()
                ensight.legend.type("continuous")
                # WARNING: following line includes OBSOLETE call (ensight.legend.title).
                ensight.legend.title("below")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.legend.select_all()'''
        return self._session.cmd(cmd)

    def select_all_invisible(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.legend.select_all_invisible()'''
        return self._session.cmd(cmd)

    def select_all_visible(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.legend.select_all_visible()'''
        return self._session.cmd(cmd)

    def select_begin(self, *args, **kwargs) -> Any:
        """Legend: select_begin

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.legend.select_begin({arg_string})"
        return self._session.cmd(cmd)

    def select_default(self) -> int:
        """Sets the current legend selection to the default, so default attributes can be modified.
        
        | Any legend attributes set or modified after this command (and before another legend: select_palette_begin and legend: select_palette_end pair) will be applied to the "default" legend.  The default legend attributes will be applied for any subsequent legends which are made active (made visible for the first time).
        
        Examples:
            ::
        
                ensight.legend.select_default()
                ensight.legend.orientation("horizontal")
                # WARNING: following line includes OBSOLETE call (ensight.legend.title).
                ensight.legend.title("below")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.legend.select_default()'''
        return self._session.cmd(cmd)

    def select_palette_begin(self, args: Any) -> int:
        """Selection of legends, for which attributes will be set or modified.
        
        | The legends bracketed by these two commands are the ones to which subsequent legend commands will be applied.
        
        Args:
            p0:
                'palette_name' palette name
        
        Examples:
            ::
        
                ensight.legend.select_palette_begin("pressure","velocity")
                ensight.legend.visible("ON")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.legend.select_palette_begin({repr(args)})'''
        return self._session.cmd(cmd)

    def select_palette_end(self) -> int:
        """Selection of legends, for which attributes will be set or modified.
        
        | The legends bracketed by these two commands are the ones to which subsequent legend commands will be applied.
        
        Args:
            p0:
                'palette_name' palette name
        
        Examples:
            ::
        
                ensight.legend.select_palette_begin("pressure","velocity")
                ensight.legend.visible("ON")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.legend.select_palette_end()'''
        return self._session.cmd(cmd)

    def shadow_intensity(self, p0: float) -> int:
        """Legend: shadow_intensity

        """
        cmd = f'''ensight.legend.shadow_intensity({repr(p0)})'''
        return self._session.cmd(cmd)

    def shadow_offset(self, p0: int) -> int:
        """Legend: shadow_offset

        """
        cmd = f'''ensight.legend.shadow_offset({repr(p0)})'''
        return self._session.cmd(cmd)

    def show_background(self, p0: str) -> int:
        """Legend: show_background

        """
        cmd = f'''ensight.legend.show_background({repr(p0)})'''
        return self._session.cmd(cmd)

    def show_minmax_marker(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.legend.show_minmax_marker({repr(p0)})'''
        return self._session.cmd(cmd)

    def specify_label_count(self, p0: str) -> int:
        """Legend: specify_label_count

        """
        cmd = f'''ensight.legend.specify_label_count({repr(p0)})'''
        return self._session.cmd(cmd)

    def text_position(self, p0: str) -> int:
        """Set the visibility and location of legend labels in relation to the legend color bar.
        
        Args:
            p0:
                'location'
        
                * left
                * right
                * none
        
        Examples:
            ::
        
                ensight.legend.select_palette_begin("pressure")
                ensight.legend.text_position("left")
                ensight.legend.select_palette_begin("velocity")
                ensight.legend.text_position("right")
                ensight.legend.select_palette_begin("temperature")
                ensight.legend.text_position("none")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.legend.text_position({repr(p0)})'''
        return self._session.cmd(cmd)

    def text_rgb(self, p0: float, p1: float, p2: float) -> int:
        """Sets the color of the legend text for title and labels.
        
        Args:
            p0:
                'red_val' red, green, blue contributions of the color (0.0 to 1.0)
            p1:
                'grn_val' red, green, blue contributions of the color (0.0 to 1.0)
            p2:
                'blu_val' red, green, blue contributions of the color (0.0 to 1.0)
        
        Examples:
            ::
        
                ensight.legend.select_palette_begin("velocity")
                ensight.legend.text_size(35)
                ensight.legend.format("%.2f")
                ensight.legend.text_rgb(1.0000e+00,0.0000e+00,3.9608e-01)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.legend.text_rgb({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def text_size(self, p0: int) -> int:
        """Sets the size of font to use for legend title and labels.
        
        | This size is a relative size based on the graphics window. It will change appropriately as the graphics window changes.
        
        Args:
            p0:
                'size' font size to use
        
        Examples:
            ::
        
                ensight.legend.select_palette_begin("velocity")
                ensight.legend.text_size(35)
                ensight.legend.format("%.2f")
                ensight.legend.text_rgb(1.0000e+00,0.0000e+00,3.9608e-01)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.legend.text_size({repr(p0)})'''
        return self._session.cmd(cmd)

    def text_type(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.legend.text_type({repr(p0)})'''
        return self._session.cmd(cmd)

    def title(self, p0: str) -> int:
        """Legend: title

        """
        cmd = f'''ensight.legend.title({repr(p0)})'''
        return self._session.cmd(cmd)

    def title_location(self, p0: str) -> int:
        """Set the visibility and location of a legend title in relation to the legend color bar.
        
        Args:
            p0:
                'location'
        
                * above
                * below
                * none
        
        Examples:
            ::
        
                ensight.legend.select_palette_begin("pressure")
                ensight.legend.type("continuous")
                # WARNING: following line includes OBSOLETE call (ensight.legend.title).
                ensight.legend.title("below")
                ensight.legend.select_palette_begin("velocity")
                # WARNING: following line includes OBSOLETE call (ensight.legend.title).
                ensight.legend.title("none")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.legend.title_location({repr(p0)})'''
        return self._session.cmd(cmd)

    def title_name(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.legend.title_name({repr(p0)})'''
        return self._session.cmd(cmd)

    def type(self, p0: str) -> int:
        """Set the type of bar to use for color representation of legend values.
        
        | A continuous bar shows all the variations as one color changes to another, while a discrete bar shows the color at the levels only.
        
        Args:
            p0:
                'bar_type'
        
                * continuous
                * discrete
        
        Examples:
            ::
        
                ensight.legend.select_palette_begin("pressure")
                ensight.legend.type("discrete")
                ensight.legend.select_palette_begin("velocity")
                ensight.legend.type("continuous")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.legend.type({repr(p0)})'''
        return self._session.cmd(cmd)

    def visible(self, p0: str) -> int:
        """To turn the visibility of a legend on or off.
        
        | The command applies to the currently selected legend(s)
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.legend.select_palette_begin("pressure")
                ensight.legend.visible("ON")
                ensight.legend.select_palette_begin("velocity")
                ensight.legend.visible("OFF")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.legend.visible({repr(p0)})'''
        return self._session.cmd(cmd)

    def width(self, p0: float) -> int:
        """Set the width of the legend bar.
        
        | The width is in terms of screen coordinates, which are 0.0 to 1.0 in both x and y directions. 
        
        Args:
            p0:
                'num' width of the legend bar
        
        Examples:
            ::
        
                ensight.legend.select_palette_begin("pressure")
                ensight.legend.location_x(2.1362e-01)
                ensight.legend.location_y(4.5270e-02)
                ensight.legend.width(5.7778e-02)
                ensight.legend.height(8.5655e-01)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.legend.width({repr(p0)})'''
        return self._session.cmd(cmd)


class isos:
    """Class wrapper for EnSight isos module

    This class acts as a proxy for the EnSight Python module ensight.isos
    """
    def __init__(self, session: Session):
        self._session = session

    def anim_delta(self, p0: float) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.isos.anim_delta({repr(p0)})'''
        return self._session.cmd(cmd)

    def begin(self) -> int:
        """Delimit the modifications for iso-surface attributes
        
        | These commands are used to set the attributes for a isosurface part creation.
        
        Examples:
            ::
        
                ensight.isos.begin()
                ensight.isos.variable("temperature")
                ensight.isos.value(1.1)
                ensight.isos.type("isosurface")
                ensight.isos.end()
                ensight.isos.create()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.isos.begin()'''
        return self._session.cmd(cmd)

    def component(self, p0: float, p1: float, p2: float) -> int:
        """The isosurface algorithm works only on scalar variables.  For a vector, this command specifies how a scalar will be created from the vector.
        
        | The scale factors apply only if the isosurface variable is a vector.
        | Usually used with a scale factor of 0 or 1. in order to use only a component of a vector. 
        | A special condition exists when x_scale = y_scale = z_scale = 0, in which case the vector magnitude is used. 
        | The default is x_scale = y_scale = z_scale = 0.  
        
        Args:
            p0:
                'x_scale' factor to scale the x, y, z components of the vector
            p1:
                'y_scale' factor to scale the x, y, z components of the vector
            p2:
                'z_scale' factor to scale the x, y, z components of the vector
        
        Examples:
            ::
        
                ensight.part.select_begin(3)
                #
                # Use the y_component of the vector
                #
                ensight.part.modify_begin()
                ensight.isos.component(0,1,0)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.isos.component({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def constraint(self, p0: str) -> int:
        """Set the bounding condition for an isovolume.
        
        | Is used only when "isos: type" is set to isovolume.  
        
        Args:
            p0:
                'isovolume_bound'
        
                * low
                * high
                * band
        
        Examples:
            ::
        
                ensight.isos.begin()
                ensight.isos.variable("temperature")
                ensight.isos.type("isovolume")
                ensight.isos.constraint("band")
                ensight.isos.min(1.)
                ensight.isos.max(2.)
                ensight.isos.end()
                ensight.isos.create()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.isos.constraint({repr(p0)})'''
        return self._session.cmd(cmd)

    def create(self) -> int:
        """Create a isosurface part with the currently defined attributes using  the currently selected parts as parent parts.
        
        | The isosurface part is created using the currently selected parts as parents.  
        | The isosurface part is created using the currently set isosurface attributes.
        
        Examples:
            ::
        
                ensight.isos.begin()
                ensight.isos.variable("temperature")
                ensight.isos.type("isovolume")
                ensight.isos.constraint("band")
                ensight.isos.min(1.)
                ensight.isos.max(2.)
                ensight.isos.end()
                ensight.isos.create()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.isos.create()'''
        return self._session.cmd(cmd)

    def create_delta(self, p0: float) -> int:
        """Specify delta between isosurface instances.
        
        | Requires the use of the isos: number_to_create <instances> command in conjunction with this command.  
        
        Args:
            p0:
                'delta' the delta value between multiple instances of an isosurface.
        
        Examples:
            ::
        
                ensight.isos.begin()
                ensight.isos.variable("temperature")
                ensight.isos.type("isosurface")
                ensight.isos.create_delta(0.5)
                ensight.isos.number_to_create(10)
                ensight.isos.value(1.76)
                ensight.isos.end()
                ensight.isos.create()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.isos.create_delta({repr(p0)})'''
        return self._session.cmd(cmd)

    def end(self) -> int:
        """Delimit the modifications for iso-surface attributes
        
        | These commands are used to set the attributes for a isosurface part creation.
        
        Examples:
            ::
        
                ensight.isos.begin()
                ensight.isos.variable("temperature")
                ensight.isos.value(1.1)
                ensight.isos.type("isosurface")
                ensight.isos.end()
                ensight.isos.create()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.isos.end()'''
        return self._session.cmd(cmd)

    def interactive_auto_delta(self, p0: float) -> int:
        """Set the isosurface animation delta for use when surface is set to interactive mode via "isos: interactive_type auto/auto_cycle".
        
        | The currently selected part must be an isosurface part. Not used for isovolume parts.
        
        Args:
            p0:
                'delta' delta value that will be added to the isosurface value for each refresh of the screen
        
        Examples:
            ::
        
                ensight.part.select_begin(3)
                ensight.isos.interactive_type("auto")
                ensight.isos.interactive_rangemin(0.)
                ensight.isos.interactive_rangemax(5.)
                ensight.isos.interactive_auto_delta(.5)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.isos.interactive_auto_delta({repr(p0)})'''
        return self._session.cmd(cmd)

    def interactive_rangemax(self, p0: float) -> int:
        """Set the minimum/maximum isosurface value when isosurface is in an interactive mode.
        
        | The currently selected part must be an isosurface part.  Not used for isovolume parts.
        
        Args:
            p0:
                'min_range' minimum isosurface value when displaying interactive
            p1:
                'max_range' maximum isosurface value when displaying interactive
        
        Examples:
            ::
        
                ensight.part.select_begin(3)
                ensight.isos.interactive_type("auto")
                ensight.isos.interactive_rangemin(0.)
                ensight.isos.interactive_rangemax(5.)
                ensight.isos.interactive_auto_delta(.5)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.isos.interactive_rangemax({repr(p0)})'''
        return self._session.cmd(cmd)

    def interactive_rangemin(self, p0: float) -> int:
        """Set the minimum/maximum isosurface value when isosurface is in an interactive mode.
        
        | The currently selected part must be an isosurface part.  Not used for isovolume parts.
        
        Args:
            p0:
                'min_range' minimum isosurface value when displaying interactive
            p1:
                'max_range' maximum isosurface value when displaying interactive
        
        Examples:
            ::
        
                ensight.part.select_begin(3)
                ensight.isos.interactive_type("auto")
                ensight.isos.interactive_rangemin(0.)
                ensight.isos.interactive_rangemax(5.)
                ensight.isos.interactive_auto_delta(.5)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.isos.interactive_rangemin({repr(p0)})'''
        return self._session.cmd(cmd)

    def interactive_type(self, p0: str) -> int:
        """Specify the interactive setting for an isosurface.
        
        | The min and max values are constrained via the interactive_rangemin/max commands. Only isosurfaces can be in interactive mode (i.e., isovolumes cannot).
        
        Args:
            p0:
                'type'
        
                * off
                * manual
                * auto
                * auto_cycle
        
        Examples:
            ::
        
                ensight.part.select_begin(3)
                ensight.isos.interactive_type("auto")
                ensight.isos.interactive_rangemin(0.)
                ensight.isos.interactive_rangemax(5.)
                ensight.isos.interactive_auto_delta(.5)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.isos.interactive_type({repr(p0)})'''
        return self._session.cmd(cmd)

    def max(self, p0: float) -> int:
        """Set the min/max constraint values for an isovolume.
        
        | Is used only when "isos: type" is set to isovolume.  
        
        Args:
            p0:
                'min_value' minimum iso constraint
            p1:
                'max_value' maximum iso constraint
        
        Examples:
            ::
        
                ensight.isos.begin()
                ensight.isos.variable("temperature")
                ensight.isos.type("isovolume")
                ensight.isos.constraint("band")
                ensight.isos.min(1.)
                ensight.isos.max(2.)
                ensight.isos.end()
                ensight.isos.create()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.isos.max({repr(p0)})'''
        return self._session.cmd(cmd)

    def min(self, p0: float) -> int:
        """Set the min/max constraint values for an isovolume.
        
        | Is used only when "isos: type" is set to isovolume.  
        
        Args:
            p0:
                'min_value' minimum iso constraint
            p1:
                'max_value' maximum iso constraint
        
        Examples:
            ::
        
                ensight.isos.begin()
                ensight.isos.variable("temperature")
                ensight.isos.type("isovolume")
                ensight.isos.constraint("band")
                ensight.isos.min(1.)
                ensight.isos.max(2.)
                ensight.isos.end()
                ensight.isos.create()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.isos.min({repr(p0)})'''
        return self._session.cmd(cmd)

    def number_to_create(self, p0: int) -> int:
        """Specify the number of instances of an isosurface to create.
        
        | Requires the use of the isos: create_delta <delta> command in conjunction with this command.  
        
        Args:
            p0:
                'instances' number of instances to create.
        
        Examples:
            ::
        
                ensight.isos.begin()
                ensight.isos.variable("temperature")
                ensight.isos.type("isosurface")
                ensight.isos.create_delta(0.5)
                ensight.isos.number_to_create(10)
                ensight.isos.value(1.76)
                ensight.isos.end()
                ensight.isos.create()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.isos.number_to_create({repr(p0)})'''
        return self._session.cmd(cmd)

    def realtime_update(self, p0: float) -> int:
        """Isos: realtime_update

        """
        cmd = f'''ensight.isos.realtime_update({repr(p0)})'''
        return self._session.cmd(cmd)

    def select_default(self) -> int:
        """Sets the target to the default settings for subsequent attribute modifications.
        
        Examples:
            ::
        
                ensight.isos.select_default()
                ensight.part.modify_begin()
                ensight.isos.variable("temperature")
                ensight.isos.value(1.0)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.isos.select_default()'''
        return self._session.cmd(cmd)

    def type(self, p0: str) -> int:
        """Set the isosurface part to represent a surface or a volume.
        
        | The default is isosurface. 
        
        Args:
            p0:
                'iso_type'
        
                * isosurface
                * isovolume 
        
        Examples:
            ::
        
                ensight.isos.begin()
                ensight.isos.variable("temperature")
                ensight.isos.value(1.1)
                ensight.isos.type("isovolume")
                ensight.isos.constraint("band")
                ensight.isos.min(1.)
                ensight.isos.max(2.)
                ensight.isos.end()
                ensight.isos.create()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.isos.type({repr(p0)})'''
        return self._session.cmd(cmd)

    def value(self, p0: float) -> int:
        """Specify the isosurface value.
        
        | Is not used for isovolumes.
        | For a vector:  If the following is defined:
        | X_var = The vector X component
        | Y_var = The vector Y component
        | Z_var = The vector Z component
        | X_com = The X vector scale factor as specified with "isos: component"
        | Y_com = The Y vector scale factor as specified with "isos: component"
        | Z_com = The Z vector scale factor as specified with "isos: component"
        | then the isosurface (or line) created represents a uniform scalar value where
        |       X_var*X_com + Y_var*Y_com + Z_var*Z_com = iso_value,
        | except in the special case where X_com = Y_com = Z_com = 0. in which case the isosurface (or line) created represents a uniform scalar value where
        |       sqrt(X_var*X_var + Y_var*Y_var + Z_var*Z_var) = iso_value.
        
        Args:
            p0:
                'iso_value' iso value
        
        Examples:
            ::
        
                ensight.isos.begin()
                ensight.isos.variable("temperature")
                ensight.isos.value(1.1)
                ensight.isos.type("isosurface")
                ensight.isos.end()
                ensight.isos.create()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.isos.value({repr(p0)})'''
        return self._session.cmd(cmd)

    def var_type(self, p0: str) -> int:
        """Isos: var_type

        """
        cmd = f'''ensight.isos.var_type({repr(p0)})'''
        return self._session.cmd(cmd)

    def variable(self, p0: Any) -> int:
        """Set the isosurface variable.
        
        | A variable must be active before it can be used for isosurfaces.  
        
        Args:
            p0:
                'var_name' name of an active variable
        
        Examples:
            ::
        
                ensight.isos.begin()
                ensight.isos.variable("temperature")
                ensight.isos.value(1.1)
                ensight.isos.type("isosurface")
                ensight.isos.end()
                ensight.isos.create()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.isos.variable({repr(p0)})'''
        return self._session.cmd(cmd)


class help:
    """Class wrapper for EnSight help module

    This class acts as a proxy for the EnSight Python module ensight.help
    """
    def __init__(self, session: Session):
        self._session = session

    def document(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.help.document({repr(p0)})'''
        return self._session.cmd(cmd)

    def show_pdf_file(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.help.show_pdf_file({repr(p0)})'''
        return self._session.cmd(cmd)


class gauge:
    """Class wrapper for EnSight gauge module

    This class acts as a proxy for the EnSight Python module ensight.gauge
    """
    def __init__(self, session: Session):
        self._session = session

    def background(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.gauge.background({repr(p0)})'''
        return self._session.cmd(cmd)

    def background_rgb(self, p0: float, p1: float, p2: float) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.gauge.background_rgb({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def border(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.gauge.border({repr(p0)})'''
        return self._session.cmd(cmd)

    def delete(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.gauge.delete()'''
        return self._session.cmd(cmd)

    def description(self, p0: str) -> int:
        """Gauge: description

        """
        cmd = f'''ensight.gauge.description({repr(p0)})'''
        return self._session.cmd(cmd)

    def deselect_all(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.gauge.deselect_all()'''
        return self._session.cmd(cmd)

    def height(self, p0: float) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.gauge.height({repr(p0)})'''
        return self._session.cmd(cmd)

    def level_rgb(self, p0: float, p1: float, p2: float) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.gauge.level_rgb({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def location_x(self, p0: float) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.gauge.location_x({repr(p0)})'''
        return self._session.cmd(cmd)

    def location_y(self, p0: float) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.gauge.location_y({repr(p0)})'''
        return self._session.cmd(cmd)

    def maximum(self, p0: float) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.gauge.maximum({repr(p0)})'''
        return self._session.cmd(cmd)

    def minimum(self, p0: float) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.gauge.minimum({repr(p0)})'''
        return self._session.cmd(cmd)

    def modify_begin(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.gauge.modify_begin()'''
        return self._session.cmd(cmd)

    def modify_end(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.gauge.modify_end()'''
        return self._session.cmd(cmd)

    def new_gauge(self, p0: Any) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.gauge.new_gauge({repr(p0)})'''
        return self._session.cmd(cmd)

    def new_or_mod_gauge(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.gauge.new_or_mod_gauge({repr(p0)})'''
        return self._session.cmd(cmd)

    def orientation(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.gauge.orientation({repr(p0)})'''
        return self._session.cmd(cmd)

    def query_count(self, args: Any) -> int:
        """Gauge: query_count

        """
        cmd = f'''ensight.gauge.query_count({repr(args)})'''
        return self._session.cmd(cmd)

    def query_display_attributes(self, args: Any) -> int:
        """Gauge: query_display_attributes

        """
        cmd = f'''ensight.gauge.query_display_attributes({repr(args)})'''
        return self._session.cmd(cmd)

    def query_selected_objects(self, args: Any) -> int:
        """Gauge: query_selected_objects

        """
        cmd = f'''ensight.gauge.query_selected_objects({repr(args)})'''
        return self._session.cmd(cmd)

    def select_all(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.gauge.select_all()'''
        return self._session.cmd(cmd)

    def select_all_invisible(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.gauge.select_all_invisible()'''
        return self._session.cmd(cmd)

    def select_all_visible(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.gauge.select_all_visible()'''
        return self._session.cmd(cmd)

    def select_begin(self, *args, **kwargs) -> Any:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.gauge.select_begin({arg_string})"
        return self._session.cmd(cmd)

    def select_default(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.gauge.select_default()'''
        return self._session.cmd(cmd)

    def value(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.gauge.value({repr(p0)})'''
        return self._session.cmd(cmd)

    def value_decimal_places(self, p0: int) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.gauge.value_decimal_places({repr(p0)})'''
        return self._session.cmd(cmd)

    def value_format(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.gauge.value_format({repr(p0)})'''
        return self._session.cmd(cmd)

    def value_location(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.gauge.value_location({repr(p0)})'''
        return self._session.cmd(cmd)

    def value_rgb(self, p0: float, p1: float, p2: float) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.gauge.value_rgb({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def value_size(self, p0: int) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.gauge.value_size({repr(p0)})'''
        return self._session.cmd(cmd)

    def variable(self, p0: Any) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.gauge.variable({repr(p0)})'''
        return self._session.cmd(cmd)

    def visible(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.gauge.visible({repr(p0)})'''
        return self._session.cmd(cmd)

    def width(self, p0: float) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.gauge.width({repr(p0)})'''
        return self._session.cmd(cmd)


class function:
    """Class wrapper for EnSight function module

    This class acts as a proxy for the EnSight Python module ensight.function
    """
    def __init__(self, session: Session):
        self._session = session

    def add_band_at_value(self, *args, **kwargs) -> Any:
        """Function: add_band_at_value

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.function.add_band_at_value({arg_string})"
        return self._session.cmd(cmd)

    def add_bands_at_levels(self, *args, **kwargs) -> Any:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.function.add_bands_at_levels({arg_string})"
        return self._session.cmd(cmd)

    def add_bands_uniformly(self, *args, **kwargs) -> Any:
        """Function: add_bands_uniformly

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.function.add_bands_uniformly({arg_string})"
        return self._session.cmd(cmd)

    def add_knot(self, *args, **kwargs) -> Any:
        """Function: add_knot

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.function.add_knot({arg_string})"
        return self._session.cmd(cmd)

    def alpha_volume_scale(self, *args, **kwargs) -> Any:
        """Function: alpha_volume_scale

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.function.alpha_volume_scale({arg_string})"
        return self._session.cmd(cmd)

    def band_add_type(self, *args, **kwargs) -> Any:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.function.band_add_type({arg_string})"
        return self._session.cmd(cmd)

    def band_clear_all(self, *args, **kwargs) -> Any:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.function.band_clear_all({arg_string})"
        return self._session.cmd(cmd)

    def band_clear_last(self, *args, **kwargs) -> Any:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.function.band_clear_last({arg_string})"
        return self._session.cmd(cmd)

    def band_color(self, *args, **kwargs) -> Any:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.function.band_color({arg_string})"
        return self._session.cmd(cmd)

    def band_number_items(self, *args, **kwargs) -> Any:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.function.band_number_items({arg_string})"
        return self._session.cmd(cmd)

    def band_width(self, *args, **kwargs) -> Any:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.function.band_width({arg_string})"
        return self._session.cmd(cmd)

    def begin(self, *args, **kwargs) -> Any:
        """Function: begin

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.function.begin({arg_string})"
        return self._session.cmd(cmd)

    def color_space(self, *args, **kwargs) -> Any:
        """Function: color_space

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.function.color_space({arg_string})"
        return self._session.cmd(cmd)

    def copy_palette(self, *args, **kwargs) -> Any:
        """Function: copy_palette

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.function.copy_palette({arg_string})"
        return self._session.cmd(cmd)

    def copy_subpalette(self, *args, **kwargs) -> Any:
        """Function: copy_subpalette

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.function.copy_subpalette({arg_string})"
        return self._session.cmd(cmd)

    def create_palette(self, *args, **kwargs) -> Any:
        """Function: create_palette

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.function.create_palette({arg_string})"
        return self._session.cmd(cmd)

    def create_subpalette(self, *args, **kwargs) -> Any:
        """Function: create_subpalette

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.function.create_subpalette({arg_string})"
        return self._session.cmd(cmd)

    def degree(self, *args, **kwargs) -> Any:
        """Function: degree

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.function.degree({arg_string})"
        return self._session.cmd(cmd)

    def del_knot(self, *args, **kwargs) -> Any:
        """Function: del_knot

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.function.del_knot({arg_string})"
        return self._session.cmd(cmd)

    def delete_full_palet(self, *args, **kwargs) -> Any:
        """Function: delete_full_palet

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.function.delete_full_palet({arg_string})"
        return self._session.cmd(cmd)

    def delete_subpalette(self, *args, **kwargs) -> Any:
        """Function: delete_subpalette

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.function.delete_subpalette({arg_string})"
        return self._session.cmd(cmd)

    def description(self, *args, **kwargs) -> Any:
        """Function: description

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.function.description({arg_string})"
        return self._session.cmd(cmd)

    def display_undefined(self, *args, **kwargs) -> Any:
        """Selects how elements/nodes, at which variables are undefined, will be displayed.
        
        Args:
            p0:
                'option'
        
                * One of the following:
                * by_part_color
                * by_invisible
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.function.display_undefined({arg_string})"
        return self._session.cmd(cmd)

    def edit_level(self, *args, **kwargs) -> Any:
        """Sets the level in the palette for which value or color will be set/modified.
        
        | Each level has a value and a color associated with it.  Interpolations occur between the levels according to the type and scale used.
        
        Args:
            p0:
                'num' level number (1 based, with 1 being the lowest level)
        
        Examples:
            ::
        
                ensight.function.palette("N_temperature")
                ensight.function.modify_begin()
                ensight.function.number_of_levels(6)
                ensight.function.edit_level(2)
                ensight.function.value(9.6464e+00)
                ensight.function.edit_level(3)
                ensight.function.value(1.9283e+01)
                ensight.function.edit_level(4)
                ensight.function.value(2.8919e+01)
                ensight.function.edit_level(5)
                ensight.function.value(3.8556e+01)
                ensight.function.edit_level(6)
                ensight.function.value(4.8192e+01)
                ensight.function.edit_level(1)
                ensight.function.rgb(5.0000e-01,0.0000e+00,1.0000e+00)
                ensight.function.edit_level(2)
                ensight.function.rgb(0.0000e+00,0.0000e+00,1.0000e+00)
                ensight.function.edit_level(3)
                ensight.function.rgb(0.0000e+00,1.0000e+00,1.0000e+00)
                ensight.function.edit_level(4)
                ensight.function.rgb(0.0000e+00,1.0000e+00,0.0000e+00)
                ensight.function.edit_level(5)
                ensight.function.rgb(1.0000e+00,1.0000e+00,0.0000e+00)
                ensight.function.edit_level(6)
                ensight.function.rgb(1.0000e+00,0.0000e+00,0.0000e+00)
                ensight.function.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.function.edit_level({arg_string})"
        return self._session.cmd(cmd)

    def end(self, *args, **kwargs) -> Any:
        """Function: end

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.function.end({arg_string})"
        return self._session.cmd(cmd)

    def level(self, *args, **kwargs) -> Any:
        """Function: level

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.function.level({arg_string})"
        return self._session.cmd(cmd)

    def levels_lock(self, *args, **kwargs) -> Any:
        """Function: levels_lock

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.function.levels_lock({arg_string})"
        return self._session.cmd(cmd)

    def limit_fringes(self, *args, **kwargs) -> Any:
        """Selects how shaded elements above or below the min and max palette levels will be displayed. 
        
        Args:
            p0:
                'option'
        
                * One of the following:
                * No
                * by_part_color 
                * by_invisible
        
        Examples:
            ::
        
                ensight.function.palette("N_temperature")
                ensight.function.modify_begin()
                ensight.function.type("continuous")
                ensight.function.limit_fringes("by_invisible")
                ensight.function.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.function.limit_fringes({arg_string})"
        return self._session.cmd(cmd)

    def modify_begin(self, *args, **kwargs) -> Any:
        """Groups function attribute commands together before applying them.
        
        Args:
            p0:
                'function_commandN' any of the function commands which modify attributes
        
        Examples:
            ::
        
                ensight.function.palette("Stress")
                ensight.function.modify_begin()
                ensight.function.edit_level(1)
                ensight.function.rgb(1.0000e+00,0.0000e+00,0.0000e+00)
                ensight.function.edit_level(2)
                ensight.function.rgb(1.0000e+00,1.0000e+00,0.0000e+00)
                ensight.function.edit_level(3)
                ensight.function.rgb(0.0000e+00,1.0000e+00,0.0000e+00)
                ensight.function.edit_level(4)
                ensight.function.rgb(0.0000e+00,1.0000e+00,1.0000e+00)
                ensight.function.edit_level(5)
                ensight.function.rgb(0.0000e+00,0.0000e+00,1.0000e+00)
                ensight.function.edit_level(6)
                ensight.function.rgb(5.0000e-01,0.0000e+00,1.0000e+00)
                ensight.function.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.function.modify_begin({arg_string})"
        return self._session.cmd(cmd)

    def modify_end(self, *args, **kwargs) -> Any:
        """Groups function attribute commands together before applying them.
        
        Args:
            p0:
                'function_commandN' any of the function commands which modify attributes
        
        Examples:
            ::
        
                ensight.function.palette("Stress")
                ensight.function.modify_begin()
                ensight.function.edit_level(1)
                ensight.function.rgb(1.0000e+00,0.0000e+00,0.0000e+00)
                ensight.function.edit_level(2)
                ensight.function.rgb(1.0000e+00,1.0000e+00,0.0000e+00)
                ensight.function.edit_level(3)
                ensight.function.rgb(0.0000e+00,1.0000e+00,0.0000e+00)
                ensight.function.edit_level(4)
                ensight.function.rgb(0.0000e+00,1.0000e+00,1.0000e+00)
                ensight.function.edit_level(5)
                ensight.function.rgb(0.0000e+00,0.0000e+00,1.0000e+00)
                ensight.function.edit_level(6)
                ensight.function.rgb(5.0000e-01,0.0000e+00,1.0000e+00)
                ensight.function.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.function.modify_end({arg_string})"
        return self._session.cmd(cmd)

    def nlevels(self, *args, **kwargs) -> Any:
        """Function: nlevels

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.function.nlevels({arg_string})"
        return self._session.cmd(cmd)

    def node_lock(self, *args, **kwargs) -> Any:
        """Function: node_lock

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.function.node_lock({arg_string})"
        return self._session.cmd(cmd)

    def number_of_colors(self, *args, **kwargs) -> Any:
        """Function: #_of_colors

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.function.number_of_colors({arg_string})"
        return self._session.cmd(cmd)

    def number_of_levels(self, *args, **kwargs) -> Any:
        """Function: #_of_levels

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.function.number_of_levels({arg_string})"
        return self._session.cmd(cmd)

    def over_time(self, *args, **kwargs) -> Any:
        """Sets the option to include variable ranges over a time range on or off.
        
        | The minimum and maximum values of a variable's range, and thus the resulting palette levels will be based on the current time when a variable is activated, unless this command has been used.
        
        Args:
            p0:
                'toggle'
        
                * ON 
                * OFF
            p1:
                'beg_step' The beginning time step to consider for the time range.
            p2:
                'end_step' The ending time step to consider for the time range.
        
        Examples:
            ::
        
                ensight.function.palette("Stress")
                ensight.function.over_time("ON","0","16")
                ensight.function.palette("Displacement")
                ensight.function.over_time("OFF")
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.function.over_time({arg_string})"
        return self._session.cmd(cmd)

    def palette(self, *args, **kwargs) -> Any:
        """Selects the palette that will be modified.
        
        | Only one palette at a time can be modified.
        
        Args:
            p0:
                'palette_name' name of the palette (It will be the same as the variable, or variable component that it represents).
        
        Examples:
            ::
        
                ensight.function.palette("N_temperature")
                ensight.function.modify_begin()
                ensight.function.number_of_levels(4)
                ensight.function.edit_level(2)
                ensight.function.value(1.6064e+01)
                ensight.function.edit_level(3)
                ensight.function.value(3.2128e+01)
                ensight.function.edit_level(4)
                ensight.function.value(4.8192e+01)
                ensight.function.edit_level(2)
                ensight.function.rgb(0.0000e+00,1.0000e+00,6.6667e-01)
                ensight.function.edit_level(3)
                ensight.function.rgb(6.6667e-01,1.0000e+00,0.0000e+00)
                ensight.function.edit_level(4)
                ensight.function.rgb(1.0000e+00,0.0000e+00,0.0000e+00)
                ensight.function.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.function.palette({arg_string})"
        return self._session.cmd(cmd)

    def point(self, *args, **kwargs) -> Any:
        """Function: point

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.function.point({arg_string})"
        return self._session.cmd(cmd)

    def range(self, *args, **kwargs) -> Any:
        """Set the min and max range for a variable palette.
        
        Args:
            p0:
                'min' minimum value
            p1:
                'max' maximum value
        
        Examples:
            ::
        
                ensight.function.palette("temperature")
                ensight.function.range(0.0000e+00,9.6464e+00)
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.function.range({arg_string})"
        return self._session.cmd(cmd)

    def reset_range_time_chng(self, *args, **kwargs) -> Any:
        """Function: reset_range_time_chng

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.function.reset_range_time_chng({arg_string})"
        return self._session.cmd(cmd)

    def restore(self, *args, **kwargs) -> Any:
        """Restore a previously saved palette from a file.
        
        Args:
            p0:
                'palette_filename' name of the file containing a palette definition
        
        Examples:
            ::
        
                ensight.function.restore("/usr/tmp/mystress.pal")
                ensight.function.palette("Stress")
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.function.restore({arg_string})"
        return self._session.cmd(cmd)

    def restore_predefinedpal(self, *args, **kwargs) -> Any:
        """Restores predefined palettes that are in the user's default palette directory.
        
        | Predefined palettes reside in a user's ./palettes directory.
        
        Args:
            p0:
                'level_option'
        
                * One of the following:
                * use_new_levels
                * use_existing_levels
            p1:
                'palette_name' name of the predefined palette to restore
        
        Examples:
            ::
        
                ensight.function.restore_predefinedpal("use_new_levels","mypal")
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.function.restore_predefinedpal({arg_string})"
        return self._session.cmd(cmd)

    def rgb(self, *args, **kwargs) -> Any:
        """Function: rgb

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.function.rgb({arg_string})"
        return self._session.cmd(cmd)

    def save(self, *args, **kwargs) -> Any:
        """Save the palette for the currently selected variable.
        
        | A saved palette can later be restored.
        
        Args:
            p0:
                'palette_filename' name of the file containing a palette definition
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.function.save({arg_string})"
        return self._session.cmd(cmd)

    def save_all(self, *args, **kwargs) -> Any:
        """Save all palettes to a file.
        
        | Palettes saved in a file can later be restored.
        
        Args:
            p0:
                'palette_filename' name of the file containing palette definitions
        
        Examples:
            ::
        
                ensight.function.save_all("/usr/tmp/allmy.pal")
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.function.save_all({arg_string})"
        return self._session.cmd(cmd)

    def save_current_case(self, *args, **kwargs) -> Any:
        """Save palettes, of active variables of the currently selected case, to a file.
        
        | Palettes saved in a file can later be restored.
        | Note that this command is not generated by EnSight, but can be placed in a command file manually if desired.
        
        Args:
            p0:
                'palette_filename' name of the file containing palette definitions
        
        Examples:
            ::
        
                ensight.function.save_current_case("/usr/tmp/allmy.pal")
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.function.save_current_case({arg_string})"
        return self._session.cmd(cmd)

    def scale(self, *args, **kwargs) -> Any:
        """Sets the type of scale for value-separation of levels.
        
        Args:
            p0:
                'scale_type'
        
                * Can be one of the following types:
                * linear
                * quadratic
                * logarithmic
        
        Examples:
            ::
        
                ensight.function.palette("N_temperature")
                ensight.function.type("continuous")
                ensight.function.modify_begin()
                ensight.function.scale("quadratic")
                ensight.function.edit_level(2)
                ensight.function.value(1.9373e+00)
                ensight.function.edit_level(3)
                ensight.function.value(7.7191e+00)
                ensight.function.edit_level(4)
                ensight.function.value(1.7356e+01)
                ensight.function.edit_level(5)
                ensight.function.value(3.0846e+01)
                ensight.function.edit_level(6)
                ensight.function.value(4.8192e+01)
                ensight.function.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.function.scale({arg_string})"
        return self._session.cmd(cmd)

    def select_default(self, *args, **kwargs) -> Any:
        """Set palette selection to none, so that subsequent function attribute commands will apply to the default.
        
        Examples:
            ::
        
                ensight.function.select_default()
                ensight.function.number_of_levels(4)
                ensight.function.modify_begin()
                ensight.function.edit_level(1)
                ensight.function.value(1.0000e-02)
                ensight.function.edit_level(2)
                ensight.function.value(1.6071e+01)
                ensight.function.edit_level(3)
                ensight.function.value(3.2131e+01)
                ensight.function.edit_level(4)
                ensight.function.value(4.8192e+01)
                ensight.function.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.function.select_default({arg_string})"
        return self._session.cmd(cmd)

    def set_palette_to_minmax(self, *args, **kwargs) -> Any:
        """Set palette to the min/max of the variable. This allows the user to set the palette level values back to their original values or to newly computed min/max as may have been defined by the "over_time" toggle and it's associated commands.
        
        Examples:
            ::
        
                ensight.function.set_palette_to_minmax()
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.function.set_palette_to_minmax({arg_string})"
        return self._session.cmd(cmd)

    def set_palette_to_partminmax(self, *args, **kwargs) -> Any:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.function.set_palette_to_partminmax({arg_string})"
        return self._session.cmd(cmd)

    def set_palette_to_viewminmax(self, *args, **kwargs) -> Any:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.function.set_palette_to_viewminmax({arg_string})"
        return self._session.cmd(cmd)

    def tie_to_var(self, *args, **kwargs) -> Any:
        """Function: tie_to_var

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.function.tie_to_var({arg_string})"
        return self._session.cmd(cmd)

    def type(self, *args, **kwargs) -> Any:
        """Sets the type of color gradation that will be applied across elements.
        
        Args:
            p0:
                'type'
        
                * Can be one of the following types:
                * continuous
                * banded
                * constant
        
        Examples:
            ::
        
                ensight.function.palette("N_temperature")
                ensight.function.type("banded")
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.function.type({arg_string})"
        return self._session.cmd(cmd)

    def undefined_color(self, *args, **kwargs) -> Any:
        """Function: undefined_color

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.function.undefined_color({arg_string})"
        return self._session.cmd(cmd)

    def use_cont_for_elem_vars(self, *args, **kwargs) -> Any:
        """Function: use_cont_for_elem_vars

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.function.use_cont_for_elem_vars({arg_string})"
        return self._session.cmd(cmd)

    def use_subpal(self, *args, **kwargs) -> Any:
        """Function: use_subpal

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.function.use_subpal({arg_string})"
        return self._session.cmd(cmd)

    def value(self, *args, **kwargs) -> Any:
        """Sets the value to associate with a level in the palette.
        
        | Each level has a value and a color associated with it.  Interpolations occur between the levels according to the type and scale used.
        
        Args:
            p0:
                'var_value' variable value to assign to the level
        
        Examples:
            ::
        
                ensight.function.palette("N_temperature")
                ensight.function.modify_begin()
                ensight.function.number_of_levels(6)
                ensight.function.edit_level(2)
                ensight.function.value(9.6464e+00)
                ensight.function.edit_level(3)
                ensight.function.value(1.9283e+01)
                ensight.function.edit_level(4)
                ensight.function.value(2.8919e+01)
                ensight.function.edit_level(5)
                ensight.function.value(3.8556e+01)
                ensight.function.edit_level(6)
                ensight.function.value(4.8192e+01)
                ensight.function.edit_level(1)
                ensight.function.rgb(5.0000e-01,0.0000e+00,1.0000e+00)
                ensight.function.edit_level(2)
                ensight.function.rgb(0.0000e+00,0.0000e+00,1.0000e+00)
                ensight.function.edit_level(3)
                ensight.function.rgb(0.0000e+00,1.0000e+00,1.0000e+00)
                ensight.function.edit_level(4)
                ensight.function.rgb(0.0000e+00,1.0000e+00,0.0000e+00)
                ensight.function.edit_level(5)
                ensight.function.rgb(1.0000e+00,1.0000e+00,0.0000e+00)
                ensight.function.edit_level(6)
                ensight.function.rgb(1.0000e+00,0.0000e+00,0.0000e+00)
                ensight.function.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.function.value({arg_string})"
        return self._session.cmd(cmd)


class frame:
    """Class wrapper for EnSight frame module

    This class acts as a proxy for the EnSight Python module ensight.frame
    """
    def __init__(self, session: Session):
        self._session = session

    def assign(self, p0: int) -> int:
        """Assigns selected parts to the specified frame.
        
        | Before this command is issued, you need to have one (and one only) frame selected, as well as the parts you will be assigning to the frame.
        
        Args:
            p0:
                'num' frame to assign the selected parts to
        
        Examples:
            ::
        
                ensight.frame.create()
                ensight.frame.select_begin(1)
                ensight.part.select_begin(2)
                ensight.frame.assign(1)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.frame.assign({repr(p0)})'''
        return self._session.cmd(cmd)

    def begin(self) -> int:
        """Frame: begin

        """
        cmd = f'''ensight.frame.begin()'''
        return self._session.cmd(cmd)

    def copy(self) -> int:
        """Frame: copy

        """
        cmd = f'''ensight.frame.copy()'''
        return self._session.cmd(cmd)

    def create(self) -> int:
        """Creates a new frame.
        
        | The new frame will be created with the current default attributes. 
        
        Examples:
            ::
        
                ensight.frame.create()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.frame.create()'''
        return self._session.cmd(cmd)

    def delete(self) -> int:
        """Deletes selected frames.
        
        | Before this command is issued, you need to select the frames you want deleted.
        
        Examples:
            ::
        
                ensight.frame.select_begin(1,2)
                ensight.frame.delete()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.frame.delete()'''
        return self._session.cmd(cmd)

    def description(self, p0: str) -> int:
        """Frame: description

        """
        cmd = f'''ensight.frame.description({repr(p0)})'''
        return self._session.cmd(cmd)

    def end(self) -> int:
        """Frame: end

        """
        cmd = f'''ensight.frame.end()'''
        return self._session.cmd(cmd)

    def len_x(self, p0: float) -> int:
        """Sets the display length of the frame x, y, z axes.
        
        Args:
            p0:
                'len' length of the displayed frame axis (in model coordinates)
        
        Examples:
            ::
        
                ensight.frame.select_begin(1)
                ensight.frame.len_x(8.0000e-01)
                ensight.frame.len_y(8.3333e-01)
                ensight.frame.len_z(8.3333e-01)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.frame.len_x({repr(p0)})'''
        return self._session.cmd(cmd)

    def len_y(self, p0: float) -> int:
        """Sets the display length of the frame x, y, z axes.
        
        Args:
            p0:
                'len' length of the displayed frame axis (in model coordinates)
        
        Examples:
            ::
        
                ensight.frame.select_begin(1)
                ensight.frame.len_x(8.0000e-01)
                ensight.frame.len_y(8.3333e-01)
                ensight.frame.len_z(8.3333e-01)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.frame.len_y({repr(p0)})'''
        return self._session.cmd(cmd)

    def len_z(self, p0: float) -> int:
        """Sets the display length of the frame x, y, z axes.
        
        Args:
            p0:
                'len' length of the displayed frame axis (in model coordinates)
        
        Examples:
            ::
        
                ensight.frame.select_begin(1)
                ensight.frame.len_x(8.0000e-01)
                ensight.frame.len_y(8.3333e-01)
                ensight.frame.len_z(8.3333e-01)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.frame.len_z({repr(p0)})'''
        return self._session.cmd(cmd)

    def line_width(self, p0: int) -> int:
        """Sets the line width of the displayed frame axes.
        
        Args:
            p0:
                'width' number of pixels wide
        
        Examples:
            ::
        
                ensight.frame.select_begin(1)
                ensight.frame.line_width(3)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.frame.line_width({repr(p0)})'''
        return self._session.cmd(cmd)

    def mirror_x(self, p0: str) -> int:
        """Frame: mirror_x

        """
        cmd = f'''ensight.frame.mirror_x({repr(p0)})'''
        return self._session.cmd(cmd)

    def mirror_xy(self, p0: str) -> int:
        """Frame: mirror_xy

        """
        cmd = f'''ensight.frame.mirror_xy({repr(p0)})'''
        return self._session.cmd(cmd)

    def mirror_xyz(self, p0: str) -> int:
        """Frame: mirror_xyz

        """
        cmd = f'''ensight.frame.mirror_xyz({repr(p0)})'''
        return self._session.cmd(cmd)

    def mirror_xz(self, p0: str) -> int:
        """Frame: mirror_xz

        """
        cmd = f'''ensight.frame.mirror_xz({repr(p0)})'''
        return self._session.cmd(cmd)

    def mirror_y(self, p0: str) -> int:
        """Frame: mirror_y

        """
        cmd = f'''ensight.frame.mirror_y({repr(p0)})'''
        return self._session.cmd(cmd)

    def mirror_yz(self, p0: str) -> int:
        """Frame: mirror_yz

        """
        cmd = f'''ensight.frame.mirror_yz({repr(p0)})'''
        return self._session.cmd(cmd)

    def mirror_z(self, p0: str) -> int:
        """Frame: mirror_z

        """
        cmd = f'''ensight.frame.mirror_z({repr(p0)})'''
        return self._session.cmd(cmd)

    def modify_begin(self) -> int:
        """Grouping several frame attributes together that all need to be set before application.
        
        | Since modification of frame symmetry attributes typically need more than one attribute change before being able to properly perform the option, one typically should encase the attribute lines between frame: modify_begin and frame: modify_end commands.
        
        Args:
            p0:
                'frame_command' any of the attribute changing frame: commands
        
        Examples:
            ::
        
                ensight.frame.select_begin(1)
                ensight.frame.modify_begin()
                ensight.frame.symmetry_type("translational")
                ensight.frame.symmetry_use_file("OFF")
                ensight.frame.symmetry_tinstances(2)
                ensight.frame.symmetry_delta(1.0000e+00,0.0000e+00,0.0000e+00)
                ensight.frame.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.frame.modify_begin()'''
        return self._session.cmd(cmd)

    def modify_end(self) -> int:
        """Grouping several frame attributes together that all need to be set before application.
        
        | Since modification of frame symmetry attributes typically need more than one attribute change before being able to properly perform the option, one typically should encase the attribute lines between frame: modify_begin and frame: modify_end commands.
        
        Args:
            p0:
                'frame_command' any of the attribute changing frame: commands
        
        Examples:
            ::
        
                ensight.frame.select_begin(1)
                ensight.frame.modify_begin()
                ensight.frame.symmetry_type("translational")
                ensight.frame.symmetry_use_file("OFF")
                ensight.frame.symmetry_tinstances(2)
                ensight.frame.symmetry_delta(1.0000e+00,0.0000e+00,0.0000e+00)
                ensight.frame.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.frame.modify_end()'''
        return self._session.cmd(cmd)

    def number_of_labels_x(self, p0: int) -> int:
        """Frame: #_of_labels_x

        """
        cmd = f'''ensight.frame.number_of_labels_x({repr(p0)})'''
        return self._session.cmd(cmd)

    def number_of_labels_y(self, p0: int) -> int:
        """Frame: #_of_labels_y

        """
        cmd = f'''ensight.frame.number_of_labels_y({repr(p0)})'''
        return self._session.cmd(cmd)

    def number_of_labels_z(self, p0: int) -> int:
        """Frame: #_of_labels_z

        """
        cmd = f'''ensight.frame.number_of_labels_z({repr(p0)})'''
        return self._session.cmd(cmd)

    def orientation_x(self, p0: float, p1: float, p2: float) -> int:
        """Sets the orientation of the x, y, z axes of the frame.
        
        | Frame 0 is the model coordinate system. It is always cartesian and it cannot be modified.  Other frames are always defined in terms of this cartesian coordinate system using the "frame: origin" command and this command (and it's two other sister commands).
        
        Args:
            p0:
                'x_comp' x, y, z components of vector representing the frame axis.
            p1:
                'y_comp' x, y, z components of vector representing the frame axis.
            p2:
                'z_comp' x, y, z components of vector representing the frame axis.
        
        Examples:
            ::
        
                ensight.frame.select_begin(1)
                ensight.frame.origin(1.0000e+00,1.0000e+00,5.0000e-01)
                ensight.frame.orientation_x(1.0000e+00,0.0000e+00,0.0000e+00)
                ensight.frame.orientation_y(0.0000e+00,1.0000e+00,0.0000e+00)
                ensight.frame.orientation_z(0.0000e+00,0.0000e+00,1.0000e+00)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.frame.orientation_x({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def orientation_y(self, p0: float, p1: float, p2: float) -> int:
        """Sets the orientation of the x, y, z axes of the frame.
        
        | Frame 0 is the model coordinate system. It is always cartesian and it cannot be modified.  Other frames are always defined in terms of this cartesian coordinate system using the "frame: origin" command and this command (and it's two other sister commands).
        
        Args:
            p0:
                'x_comp' x, y, z components of vector representing the frame axis.
            p1:
                'y_comp' x, y, z components of vector representing the frame axis.
            p2:
                'z_comp' x, y, z components of vector representing the frame axis.
        
        Examples:
            ::
        
                ensight.frame.select_begin(1)
                ensight.frame.origin(1.0000e+00,1.0000e+00,5.0000e-01)
                ensight.frame.orientation_x(1.0000e+00,0.0000e+00,0.0000e+00)
                ensight.frame.orientation_y(0.0000e+00,1.0000e+00,0.0000e+00)
                ensight.frame.orientation_z(0.0000e+00,0.0000e+00,1.0000e+00)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.frame.orientation_y({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def orientation_z(self, p0: float, p1: float, p2: float) -> int:
        """Sets the orientation of the x, y, z axes of the frame.
        
        | Frame 0 is the model coordinate system. It is always cartesian and it cannot be modified.  Other frames are always defined in terms of this cartesian coordinate system using the "frame: origin" command and this command (and it's two other sister commands).
        
        Args:
            p0:
                'x_comp' x, y, z components of vector representing the frame axis.
            p1:
                'y_comp' x, y, z components of vector representing the frame axis.
            p2:
                'z_comp' x, y, z components of vector representing the frame axis.
        
        Examples:
            ::
        
                ensight.frame.select_begin(1)
                ensight.frame.origin(1.0000e+00,1.0000e+00,5.0000e-01)
                ensight.frame.orientation_x(1.0000e+00,0.0000e+00,0.0000e+00)
                ensight.frame.orientation_y(0.0000e+00,1.0000e+00,0.0000e+00)
                ensight.frame.orientation_z(0.0000e+00,0.0000e+00,1.0000e+00)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.frame.orientation_z({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def origin(self, p0: float, p1: float, p2: float) -> int:
        """Sets the location of the origin of a frame in model coordinates.
        
        | Frame 0 is the model coordinate system. It is always cartesian and cannot be moved.  Other frames are always defined in terms of this cartesian coordinate system using this command and the "frame: orientation" commands.
        
        Args:
            p0:
                'x_coord' model x, y, z coordinates of the origin of the frame
            p1:
                'y_coord' model x, y, z coordinates of the origin of the frame
            p2:
                'z_coord' model x, y, z coordinates of the origin of the frame
        
        Examples:
            ::
        
                ensight.frame.select_begin(1)
                ensight.frame.origin(1.0000e+00,1.0000e+00,5.0000e-01)
                ensight.frame.orientation_x(1.0000e+00,0.0000e+00,0.0000e+00)
                ensight.frame.orientation_y(0.0000e+00,1.0000e+00,0.0000e+00)
                ensight.frame.orientation_z(0.0000e+00,0.0000e+00,1.0000e+00)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.frame.origin({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def query_count(self, args: Any) -> int:
        """Frame: query_count

        """
        cmd = f'''ensight.frame.query_count({repr(args)})'''
        return self._session.cmd(cmd)

    def query_location(self, args: Any) -> int:
        """Frame: query_location

        """
        cmd = f'''ensight.frame.query_location({repr(args)})'''
        return self._session.cmd(cmd)

    def rgb(self, p0: float, p1: float, p2: float) -> int:
        """Sets the color of the axes and labels of the selected frame.
        
        Args:
            p0:
                'red_val'  red, green, and blue components between 0.0 and 1.0
            p1:
                'grn_val'  red, green, and blue components between 0.0 and 1.0
            p2:
                'blu_val'  red, green, and blue components between 0.0 and 1.0
        
        Examples:
            ::
        
                ensight.frame.select_begin(1)
                ensight.frame.rgb(1.0000e+00,0.0000e+00,3.9608e-01)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.frame.rgb({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def select_all(self) -> int:
        """Selection of all visible frames.
        
        | Can be used to select all visible frames that subsequent frame commands will apply to.
        
        Examples:
            ::
        
                ensight.frame.select_all()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.frame.select_all()'''
        return self._session.cmd(cmd)

    def select_begin(self, *args, **kwargs) -> Any:
        """Selection of frames.
        
        | These commands are needed to select frames before modifying any attributes, doing assignments, etc.
        
        Args:
            p0:
                'frameN' frame numbers
        
        Examples:
            ::
        
                ensight.frame.select_begin(1,2)
                ensight.frame.delete()
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.frame.select_begin({arg_string})"
        return self._session.cmd(cmd)

    def select_default(self) -> int:
        """Deselects all frames, such that subsequent frame attribute commands will modify default frame attributes.
        
        | When a new frame is created, it uses default attributes.  This command allows you to change the defaults. 
        
        Examples:
            ::
        
                ensight.frame.select_default()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.frame.select_default()'''
        return self._session.cmd(cmd)

    def symmetry_angle(self, p0: float) -> int:
        """Sets the angle between instances for rotational symmetry.
        
        | Since modification of frame symmetry attributes typically need more than one attribute change before being able to properly perform the option, one typically should encase the attribute lines between frame: modify_begin and frame: modify_end commands.
        
        Args:
            p0:
                'angle' angle, in degrees, between instances
        
        Examples:
            ::
        
                ensight.frame.select_begin(1)
                ensight.frame.modify_begin()
                ensight.frame.symmetry_type("rotational")
                ensight.frame.symmetry_angle(3.5000e+01)
                ensight.frame.symmetry_rinstances(2)
                ensight.frame.symmetry_use_file("OFF")
                ensight.frame.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.frame.symmetry_angle({repr(p0)})'''
        return self._session.cmd(cmd)

    def symmetry_axis(self, p0: str) -> int:
        """Sets the major axis to use for rotational symmetry.
        
        | Since modification of frame symmetry attributes typically need more than one attribute change before being able to properly perform the option, one typically should encase the attribute lines between frame: modify_begin and frame: modify_end commands.
        
        Args:
            p0:
                'axis' major axis:   x, y, or z
        
        Examples:
            ::
        
                ensight.frame.select_begin(1)
                ensight.frame.modify_begin()
                ensight.frame.symmetry_type("rotational")
                ensight.frame.symmetry_angle(3.5000e+01)
                ensight.frame.symmetry_rinstances(2)
                ensight.frame.symmetry_use_file("OFF")
                ensight.frame.symmetry_axis("y")
                ensight.frame.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.frame.symmetry_axis({repr(p0)})'''
        return self._session.cmd(cmd)

    def symmetry_delta(self, p0: float, p1: float, p2: float) -> int:
        """Sets the delta values in the xyz directions between instances for translational symmetry.
        
        | Since modification of frame symmetry attributes typically need more than one attribute change before being able to properly perform the option, one typically should encase the attribute lines between frame: modify_begin and frame: modify_end commands.
        
        Args:
            p0:
                'del_x' x, y, z delta values (in model coordinates) between instances
            p1:
                'del_y' x, y, z delta values (in model coordinates) between instances
            p2:
                'del_z' x, y, z delta values (in model coordinates) between instances
        
        Examples:
            ::
        
                ensight.frame.select_begin(1)
                ensight.frame.modify_begin()
                ensight.frame.symmetry_type("translational")
                ensight.frame.symmetry_use_file("OFF")
                ensight.frame.symmetry_tinstances(2)
                ensight.frame.symmetry_delta(1.0000e+00,0.0000e+00,0.0000e+00)
                ensight.frame.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.frame.symmetry_delta({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def symmetry_file(self, args: Any) -> int:
        """Sets the name of the periodic matchfile for the computational symmetry.
        
        | Since modification of frame symmetry attributes typically need more than one attribute change before being able to properly perform the option, one typically should encase the attribute lines between frame: modify_begin and frame: modify_end commands. 
        | If no matchfile is used, the rotational angle and number of instances (for rotational symmetry) or the translational deltas and number of instances (for translational symmetry) must be set in the user interface.  Also, node hashing will be done in an attempt to eliminate duplicate nodes at the boundaries of instances. If a matchfile is used, the matchfile must follow the prescribed format, which contains the angle or delta, and the list of paired nodes that match at the instance boundaries.  The number of instances still comes from the user interface.
        
        Args:
            p0:
                'filename' filename of periodic symmetry match file - should be a full path name.
        
        Examples:
            ::
        
                ensight.frame.select_begin(1)
                ensight.frame.modify_begin()
                ensight.frame.symmetry_type("rotational")
                ensight.frame.symmetry_rinstances(5)
                ensight.frame.symmetry_use_file("ON")
                ensight.frame.symmetry_file("/usr/tmp/model.trn_match")
                ensight.frame.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.frame.symmetry_file({repr(args)})'''
        return self._session.cmd(cmd)

    def symmetry_instances(self, p0: int) -> int:
        """Frame: symmetry_instances

        """
        cmd = f'''ensight.frame.symmetry_instances({repr(p0)})'''
        return self._session.cmd(cmd)

    def symmetry_mirror_x(self, p0: str) -> int:
        """Sets the flag for mirror symmetry in the x / y / z / xy / yz / xz / xyz directions.
        
        | Since modification of frame symmetry attributes typically need more than one attribute change before being able to properly perform the option, one typically should encase the attribute lines between frame: modify_begin and frame: modify_end commands.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.frame.select_begin(1)
                ensight.frame.modify_begin()
                ensight.frame.symmetry_type("mirror")
                ensight.frame.symmetry_mirror_x("ON")
                ensight.frame.symmetry_mirror_z("ON")
                ensight.frame.symmetry_mirror_y("ON")
                ensight.frame.symmetry_mirror_xy("OFF")
                ensight.frame.symmetry_mirror_yz("OFF")
                ensight.frame.symmetry_mirror_xz("OFF")
                ensight.frame.symmetry_mirror_xyz("OFF")
                ensight.frame.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.frame.symmetry_mirror_x({repr(p0)})'''
        return self._session.cmd(cmd)

    def symmetry_mirror_xy(self, p0: str) -> int:
        """Sets the flag for mirror symmetry in the x / y / z / xy / yz / xz / xyz directions.
        
        | Since modification of frame symmetry attributes typically need more than one attribute change before being able to properly perform the option, one typically should encase the attribute lines between frame: modify_begin and frame: modify_end commands.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.frame.select_begin(1)
                ensight.frame.modify_begin()
                ensight.frame.symmetry_type("mirror")
                ensight.frame.symmetry_mirror_x("ON")
                ensight.frame.symmetry_mirror_z("ON")
                ensight.frame.symmetry_mirror_y("ON")
                ensight.frame.symmetry_mirror_xy("OFF")
                ensight.frame.symmetry_mirror_yz("OFF")
                ensight.frame.symmetry_mirror_xz("OFF")
                ensight.frame.symmetry_mirror_xyz("OFF")
                ensight.frame.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.frame.symmetry_mirror_xy({repr(p0)})'''
        return self._session.cmd(cmd)

    def symmetry_mirror_xyz(self, p0: str) -> int:
        """Sets the flag for mirror symmetry in the x / y / z / xy / yz / xz / xyz directions.
        
        | Since modification of frame symmetry attributes typically need more than one attribute change before being able to properly perform the option, one typically should encase the attribute lines between frame: modify_begin and frame: modify_end commands.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.frame.select_begin(1)
                ensight.frame.modify_begin()
                ensight.frame.symmetry_type("mirror")
                ensight.frame.symmetry_mirror_x("ON")
                ensight.frame.symmetry_mirror_z("ON")
                ensight.frame.symmetry_mirror_y("ON")
                ensight.frame.symmetry_mirror_xy("OFF")
                ensight.frame.symmetry_mirror_yz("OFF")
                ensight.frame.symmetry_mirror_xz("OFF")
                ensight.frame.symmetry_mirror_xyz("OFF")
                ensight.frame.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.frame.symmetry_mirror_xyz({repr(p0)})'''
        return self._session.cmd(cmd)

    def symmetry_mirror_xz(self, p0: str) -> int:
        """Sets the flag for mirror symmetry in the x / y / z / xy / yz / xz / xyz directions.
        
        | Since modification of frame symmetry attributes typically need more than one attribute change before being able to properly perform the option, one typically should encase the attribute lines between frame: modify_begin and frame: modify_end commands.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.frame.select_begin(1)
                ensight.frame.modify_begin()
                ensight.frame.symmetry_type("mirror")
                ensight.frame.symmetry_mirror_x("ON")
                ensight.frame.symmetry_mirror_z("ON")
                ensight.frame.symmetry_mirror_y("ON")
                ensight.frame.symmetry_mirror_xy("OFF")
                ensight.frame.symmetry_mirror_yz("OFF")
                ensight.frame.symmetry_mirror_xz("OFF")
                ensight.frame.symmetry_mirror_xyz("OFF")
                ensight.frame.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.frame.symmetry_mirror_xz({repr(p0)})'''
        return self._session.cmd(cmd)

    def symmetry_mirror_y(self, p0: str) -> int:
        """Sets the flag for mirror symmetry in the x / y / z / xy / yz / xz / xyz directions.
        
        | Since modification of frame symmetry attributes typically need more than one attribute change before being able to properly perform the option, one typically should encase the attribute lines between frame: modify_begin and frame: modify_end commands.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.frame.select_begin(1)
                ensight.frame.modify_begin()
                ensight.frame.symmetry_type("mirror")
                ensight.frame.symmetry_mirror_x("ON")
                ensight.frame.symmetry_mirror_z("ON")
                ensight.frame.symmetry_mirror_y("ON")
                ensight.frame.symmetry_mirror_xy("OFF")
                ensight.frame.symmetry_mirror_yz("OFF")
                ensight.frame.symmetry_mirror_xz("OFF")
                ensight.frame.symmetry_mirror_xyz("OFF")
                ensight.frame.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.frame.symmetry_mirror_y({repr(p0)})'''
        return self._session.cmd(cmd)

    def symmetry_mirror_yz(self, p0: str) -> int:
        """Sets the flag for mirror symmetry in the x / y / z / xy / yz / xz / xyz directions.
        
        | Since modification of frame symmetry attributes typically need more than one attribute change before being able to properly perform the option, one typically should encase the attribute lines between frame: modify_begin and frame: modify_end commands.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.frame.select_begin(1)
                ensight.frame.modify_begin()
                ensight.frame.symmetry_type("mirror")
                ensight.frame.symmetry_mirror_x("ON")
                ensight.frame.symmetry_mirror_z("ON")
                ensight.frame.symmetry_mirror_y("ON")
                ensight.frame.symmetry_mirror_xy("OFF")
                ensight.frame.symmetry_mirror_yz("OFF")
                ensight.frame.symmetry_mirror_xz("OFF")
                ensight.frame.symmetry_mirror_xyz("OFF")
                ensight.frame.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.frame.symmetry_mirror_yz({repr(p0)})'''
        return self._session.cmd(cmd)

    def symmetry_mirror_z(self, p0: str) -> int:
        """Sets the flag for mirror symmetry in the x / y / z / xy / yz / xz / xyz directions.
        
        | Since modification of frame symmetry attributes typically need more than one attribute change before being able to properly perform the option, one typically should encase the attribute lines between frame: modify_begin and frame: modify_end commands.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.frame.select_begin(1)
                ensight.frame.modify_begin()
                ensight.frame.symmetry_type("mirror")
                ensight.frame.symmetry_mirror_x("ON")
                ensight.frame.symmetry_mirror_z("ON")
                ensight.frame.symmetry_mirror_y("ON")
                ensight.frame.symmetry_mirror_xy("OFF")
                ensight.frame.symmetry_mirror_yz("OFF")
                ensight.frame.symmetry_mirror_xz("OFF")
                ensight.frame.symmetry_mirror_xyz("OFF")
                ensight.frame.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.frame.symmetry_mirror_z({repr(p0)})'''
        return self._session.cmd(cmd)

    def symmetry_rinstances(self, p0: int) -> int:
        """Sets the number of instances for rotational symmetry.
        
        | Since modification of frame symmetry attributes typically need more than one attribute change before being able to properly perform the option, one typically should encase the attribute lines between frame: modify_begin and frame: modify_end commands.
        
        Args:
            p0:
                'num' number of instances
        
        Examples:
            ::
        
                ensight.frame.select_begin(1)
                ensight.frame.modify_begin()
                ensight.frame.symmetry_type("rotational")
                ensight.frame.symmetry_angle(3.5000e+01)
                ensight.frame.symmetry_rinstances(5)
                ensight.frame.symmetry_use_file("OFF")
                ensight.frame.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.frame.symmetry_rinstances({repr(p0)})'''
        return self._session.cmd(cmd)

    def symmetry_tinstances(self, p0: int) -> int:
        """Sets the number of instances for translational symmetry.
        
        | Since modification of frame symmetry attributes typically need more than one attribute change before being able to properly perform the option, one typically should encase the attribute lines between frame: modify_begin and frame: modify_end commands.
        
        Args:
            p0:
                'num' number of instances
        
        Examples:
            ::
        
                ensight.frame.select_begin(1)
                ensight.frame.modify_begin()
                ensight.frame.symmetry_type("translational")
                ensight.frame.symmetry_use_file("OFF")
                ensight.frame.symmetry_tinstances(2)
                ensight.frame.symmetry_delta(1.0000e+00,0.0000e+00,0.0000e+00)
                ensight.frame.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.frame.symmetry_tinstances({repr(p0)})'''
        return self._session.cmd(cmd)

    def symmetry_type(self, p0: str) -> int:
        """Sets the type of periodic symmetry to apply to parts attached to the frame.
        
        | Since modification of frame symmetry attributes typically need more than one attribute change before being able to properly perform the option, one typically should encase the attribute lines between frame: modify_begin and frame: modify_end commands.
        
        Args:
            p0:
                'options'
        
                * mirror
                * rotational
                * translational
                * non
        
        Examples:
            ::
        
                ensight.frame.select_begin(1)
                ensight.frame.modify_begin()
                ensight.frame.symmetry_type("rotational")
                ensight.frame.symmetry_angle(3.5000e+01)
                ensight.frame.symmetry_rinstances(2)
                ensight.frame.symmetry_use_file("OFF")
                ensight.frame.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.frame.symmetry_type({repr(p0)})'''
        return self._session.cmd(cmd)

    def symmetry_use_file(self, p0: str) -> int:
        """Sets whether a periodic matchfile will be used for specification of the rotational or translational symmetry.
        
        | Since modification of frame symmetry attributes typically need more than one attribute change before being able to properly perform the option, one typically should encase the attribute lines between frame: modify_begin and frame: modify_end commands. 
        | If no matchfile is used, the rotational angle and number of instances (for rotational symmetry) or the translational deltas and number of instances (for translational symmetry) must be set in the user interface.  Also, node hashing will be done in an attempt to eliminate duplicate nodes at the boundaries of instances. If a matchfile is used, the matchfile must follow the prescribed format, which contains the angle or delta, and the list of paired nodes that match at the instance boundaries.  The number of instances still comes from the user interface.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.frame.select_begin(1)
                ensight.frame.modify_begin()
                ensight.frame.symmetry_type("rotational")
                ensight.frame.symmetry_rinstances(5)
                ensight.frame.symmetry_use_file("ON")
                ensight.frame.symmetry_file("/usr/tmp/model.trn_match")
                ensight.frame.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.frame.symmetry_use_file({repr(p0)})'''
        return self._session.cmd(cmd)

    def type(self, p0: str) -> int:
        """Set the coordinate system type for the frame.
        
        Args:
            p0:
                'coord_system'
        
                * rectangular
                * cylindrical
                * spherical
        
        Examples:
            ::
        
                ensight.frame.select_begin(1)
                ensight.frame.type("cylindrical")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.frame.type({repr(p0)})'''
        return self._session.cmd(cmd)

    def visible(self, p0: str) -> int:
        """Set the frame axis visibility on or off
        
        Args:
            p0:
                'toggle'
        
                * ON 
                * OFF
        
        Examples:
            ::
        
                ensight.frame.select_begin(1)
                ensight.frame.visible("ON")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.frame.visible({repr(p0)})'''
        return self._session.cmd(cmd)

    def x_labels(self, p0: str) -> int:
        """Sets the visibility of labels along the frame x/y/z axis.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.frame.select_begin(1)
                ensight.frame.x_labels("ON")
                ensight.frame.y_labels("ON")
                ensight.frame.z_labels("ON")
                ensight.frame.number_of_labels_x(3)
                ensight.frame.number_of_labels_y(4)
                ensight.frame.number_of_labels_z(3)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.frame.x_labels({repr(p0)})'''
        return self._session.cmd(cmd)

    def y_labels(self, p0: str) -> int:
        """Sets the visibility of labels along the frame x/y/z axis.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.frame.select_begin(1)
                ensight.frame.x_labels("ON")
                ensight.frame.y_labels("ON")
                ensight.frame.z_labels("ON")
                ensight.frame.number_of_labels_x(3)
                ensight.frame.number_of_labels_y(4)
                ensight.frame.number_of_labels_z(3)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.frame.y_labels({repr(p0)})'''
        return self._session.cmd(cmd)

    def z_labels(self, p0: str) -> int:
        """Sets the visibility of labels along the frame x/y/z axis.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.frame.select_begin(1)
                ensight.frame.x_labels("ON")
                ensight.frame.y_labels("ON")
                ensight.frame.z_labels("ON")
                ensight.frame.number_of_labels_x(3)
                ensight.frame.number_of_labels_y(4)
                ensight.frame.number_of_labels_z(3)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.frame.z_labels({repr(p0)})'''
        return self._session.cmd(cmd)


class format:
    """Class wrapper for EnSight format module

    This class acts as a proxy for the EnSight Python module ensight.format
    """
    def __init__(self, session: Session):
        self._session = session

    def replace(self, p0: str) -> int:
        """Format: replace

        """
        cmd = f'''ensight.format.replace({repr(p0)})'''
        return self._session.cmd(cmd)

    def type(self, p0: str) -> int:
        """Format: type

        """
        cmd = f'''ensight.format.type({repr(p0)})'''
        return self._session.cmd(cmd)


class filterpart:
    """Class wrapper for EnSight filterpart module

    This class acts as a proxy for the EnSight Python module ensight.filterpart
    """
    def __init__(self, session: Session):
        self._session = session

    def begin(self) -> int:
        """Filterpart: begin

        """
        cmd = f'''ensight.filterpart.begin()'''
        return self._session.cmd(cmd)

    def create(self) -> int:
        """Filterpart: create

        """
        cmd = f'''ensight.filterpart.create()'''
        return self._session.cmd(cmd)

    def elt_filter1_active(self, p0: str) -> int:
        """Filterpart: elt_filter1_active

        """
        cmd = f'''ensight.filterpart.elt_filter1_active({repr(p0)})'''
        return self._session.cmd(cmd)

    def elt_filter1_testop(self, p0: str) -> int:
        """Filterpart: elt_filter1_testop

        """
        cmd = f'''ensight.filterpart.elt_filter1_testop({repr(p0)})'''
        return self._session.cmd(cmd)

    def elt_filter1_testvalue(self, p0: float) -> int:
        """Filterpart: elt_filter1_testvalue

        """
        cmd = f'''ensight.filterpart.elt_filter1_testvalue({repr(p0)})'''
        return self._session.cmd(cmd)

    def elt_filter1_testvarcomp(self, p0: str) -> int:
        """Filterpart: elt_filter1_testvarcomp

        """
        cmd = f'''ensight.filterpart.elt_filter1_testvarcomp({repr(p0)})'''
        return self._session.cmd(cmd)

    def elt_filter1_testvariable(self, args: Any) -> int:
        """Filterpart: elt_filter1_testvariable

        """
        cmd = f'''ensight.filterpart.elt_filter1_testvariable({repr(args)})'''
        return self._session.cmd(cmd)

    def elt_filter1_varcomp(self, p0: str) -> int:
        """Filterpart: elt_filter1_varcomp

        """
        cmd = f'''ensight.filterpart.elt_filter1_varcomp({repr(p0)})'''
        return self._session.cmd(cmd)

    def elt_filter1_variable(self, args: Any) -> int:
        """Filterpart: elt_filter1_variable

        """
        cmd = f'''ensight.filterpart.elt_filter1_variable({repr(args)})'''
        return self._session.cmd(cmd)

    def elt_filter2_active(self, p0: str) -> int:
        """Filterpart: elt_filter2_active

        """
        cmd = f'''ensight.filterpart.elt_filter2_active({repr(p0)})'''
        return self._session.cmd(cmd)

    def elt_filter2_testop(self, p0: str) -> int:
        """Filterpart: elt_filter2_testop

        """
        cmd = f'''ensight.filterpart.elt_filter2_testop({repr(p0)})'''
        return self._session.cmd(cmd)

    def elt_filter2_testvalue(self, p0: float) -> int:
        """Filterpart: elt_filter2_testvalue

        """
        cmd = f'''ensight.filterpart.elt_filter2_testvalue({repr(p0)})'''
        return self._session.cmd(cmd)

    def elt_filter2_testvarcomp(self, p0: str) -> int:
        """Filterpart: elt_filter2_testvarcomp

        """
        cmd = f'''ensight.filterpart.elt_filter2_testvarcomp({repr(p0)})'''
        return self._session.cmd(cmd)

    def elt_filter2_testvariable(self, args: Any) -> int:
        """Filterpart: elt_filter2_testvariable

        """
        cmd = f'''ensight.filterpart.elt_filter2_testvariable({repr(args)})'''
        return self._session.cmd(cmd)

    def elt_filter2_varcomp(self, p0: str) -> int:
        """Filterpart: elt_filter2_varcomp

        """
        cmd = f'''ensight.filterpart.elt_filter2_varcomp({repr(p0)})'''
        return self._session.cmd(cmd)

    def elt_filter2_variable(self, args: Any) -> int:
        """Filterpart: elt_filter2_variable

        """
        cmd = f'''ensight.filterpart.elt_filter2_variable({repr(args)})'''
        return self._session.cmd(cmd)

    def elt_filter3_active(self, p0: str) -> int:
        """Filterpart: elt_filter3_active

        """
        cmd = f'''ensight.filterpart.elt_filter3_active({repr(p0)})'''
        return self._session.cmd(cmd)

    def elt_filter3_testop(self, p0: str) -> int:
        """Filterpart: elt_filter3_testop

        """
        cmd = f'''ensight.filterpart.elt_filter3_testop({repr(p0)})'''
        return self._session.cmd(cmd)

    def elt_filter3_testvalue(self, p0: float) -> int:
        """Filterpart: elt_filter3_testvalue

        """
        cmd = f'''ensight.filterpart.elt_filter3_testvalue({repr(p0)})'''
        return self._session.cmd(cmd)

    def elt_filter3_testvarcomp(self, p0: str) -> int:
        """Filterpart: elt_filter3_testvarcomp

        """
        cmd = f'''ensight.filterpart.elt_filter3_testvarcomp({repr(p0)})'''
        return self._session.cmd(cmd)

    def elt_filter3_testvariable(self, args: Any) -> int:
        """Filterpart: elt_filter3_testvariable

        """
        cmd = f'''ensight.filterpart.elt_filter3_testvariable({repr(args)})'''
        return self._session.cmd(cmd)

    def elt_filter3_varcomp(self, p0: str) -> int:
        """Filterpart: elt_filter3_varcomp

        """
        cmd = f'''ensight.filterpart.elt_filter3_varcomp({repr(p0)})'''
        return self._session.cmd(cmd)

    def elt_filter3_variable(self, args: Any) -> int:
        """Filterpart: elt_filter3_variable

        """
        cmd = f'''ensight.filterpart.elt_filter3_variable({repr(args)})'''
        return self._session.cmd(cmd)

    def elt_filter4_active(self, p0: str) -> int:
        """Filterpart: elt_filter4_active

        """
        cmd = f'''ensight.filterpart.elt_filter4_active({repr(p0)})'''
        return self._session.cmd(cmd)

    def elt_filter4_testop(self, p0: str) -> int:
        """Filterpart: elt_filter4_testop

        """
        cmd = f'''ensight.filterpart.elt_filter4_testop({repr(p0)})'''
        return self._session.cmd(cmd)

    def elt_filter4_testvalue(self, p0: float) -> int:
        """Filterpart: elt_filter4_testvalue

        """
        cmd = f'''ensight.filterpart.elt_filter4_testvalue({repr(p0)})'''
        return self._session.cmd(cmd)

    def elt_filter4_testvarcomp(self, p0: str) -> int:
        """Filterpart: elt_filter4_testvarcomp

        """
        cmd = f'''ensight.filterpart.elt_filter4_testvarcomp({repr(p0)})'''
        return self._session.cmd(cmd)

    def elt_filter4_testvariable(self, args: Any) -> int:
        """Filterpart: elt_filter4_testvariable

        """
        cmd = f'''ensight.filterpart.elt_filter4_testvariable({repr(args)})'''
        return self._session.cmd(cmd)

    def elt_filter4_varcomp(self, p0: str) -> int:
        """Filterpart: elt_filter4_varcomp

        """
        cmd = f'''ensight.filterpart.elt_filter4_varcomp({repr(p0)})'''
        return self._session.cmd(cmd)

    def elt_filter4_variable(self, args: Any) -> int:
        """Filterpart: elt_filter4_variable

        """
        cmd = f'''ensight.filterpart.elt_filter4_variable({repr(args)})'''
        return self._session.cmd(cmd)

    def elt_filter5_active(self, p0: str) -> int:
        """Filterpart: elt_filter5_active

        """
        cmd = f'''ensight.filterpart.elt_filter5_active({repr(p0)})'''
        return self._session.cmd(cmd)

    def elt_filter5_testop(self, p0: str) -> int:
        """Filterpart: elt_filter5_testop

        """
        cmd = f'''ensight.filterpart.elt_filter5_testop({repr(p0)})'''
        return self._session.cmd(cmd)

    def elt_filter5_testvalue(self, p0: float) -> int:
        """Filterpart: elt_filter5_testvalue

        """
        cmd = f'''ensight.filterpart.elt_filter5_testvalue({repr(p0)})'''
        return self._session.cmd(cmd)

    def elt_filter5_testvarcomp(self, p0: str) -> int:
        """Filterpart: elt_filter5_testvarcomp

        """
        cmd = f'''ensight.filterpart.elt_filter5_testvarcomp({repr(p0)})'''
        return self._session.cmd(cmd)

    def elt_filter5_testvariable(self, args: Any) -> int:
        """Filterpart: elt_filter5_testvariable

        """
        cmd = f'''ensight.filterpart.elt_filter5_testvariable({repr(args)})'''
        return self._session.cmd(cmd)

    def elt_filter5_varcomp(self, p0: str) -> int:
        """Filterpart: elt_filter5_varcomp

        """
        cmd = f'''ensight.filterpart.elt_filter5_varcomp({repr(p0)})'''
        return self._session.cmd(cmd)

    def elt_filter5_variable(self, args: Any) -> int:
        """Filterpart: elt_filter5_variable

        """
        cmd = f'''ensight.filterpart.elt_filter5_variable({repr(args)})'''
        return self._session.cmd(cmd)

    def elt_filter6_active(self, p0: str) -> int:
        """Filterpart: elt_filter6_active

        """
        cmd = f'''ensight.filterpart.elt_filter6_active({repr(p0)})'''
        return self._session.cmd(cmd)

    def elt_filter6_testop(self, p0: str) -> int:
        """Filterpart: elt_filter6_testop

        """
        cmd = f'''ensight.filterpart.elt_filter6_testop({repr(p0)})'''
        return self._session.cmd(cmd)

    def elt_filter6_testvalue(self, p0: float) -> int:
        """Filterpart: elt_filter6_testvalue

        """
        cmd = f'''ensight.filterpart.elt_filter6_testvalue({repr(p0)})'''
        return self._session.cmd(cmd)

    def elt_filter6_testvarcomp(self, p0: str) -> int:
        """Filterpart: elt_filter6_testvarcomp

        """
        cmd = f'''ensight.filterpart.elt_filter6_testvarcomp({repr(p0)})'''
        return self._session.cmd(cmd)

    def elt_filter6_testvariable(self, args: Any) -> int:
        """Filterpart: elt_filter6_testvariable

        """
        cmd = f'''ensight.filterpart.elt_filter6_testvariable({repr(args)})'''
        return self._session.cmd(cmd)

    def elt_filter6_varcomp(self, p0: str) -> int:
        """Filterpart: elt_filter6_varcomp

        """
        cmd = f'''ensight.filterpart.elt_filter6_varcomp({repr(p0)})'''
        return self._session.cmd(cmd)

    def elt_filter6_variable(self, args: Any) -> int:
        """Filterpart: elt_filter6_variable

        """
        cmd = f'''ensight.filterpart.elt_filter6_variable({repr(args)})'''
        return self._session.cmd(cmd)

    def end(self) -> int:
        """Filterpart: end

        """
        cmd = f'''ensight.filterpart.end()'''
        return self._session.cmd(cmd)

    def select_default(self) -> int:
        """Filterpart: select_default

        """
        cmd = f'''ensight.filterpart.select_default()'''
        return self._session.cmd(cmd)


class file:
    """Class wrapper for EnSight file module

    This class acts as a proxy for the EnSight Python module ensight.file
    """
    def __init__(self, session: Session):
        self._session = session

    def animation_color_type(self, p0: str) -> int:
        """File: animation_color_type

        """
        cmd = f'''ensight.file.animation_color_type({repr(p0)})'''
        return self._session.cmd(cmd)

    def animation_file(self, p0: str) -> int:
        """Specify the name of the animation file when recording.
        
        Args:
            p0:
                'filename' the filename to use for the animation
        
        Examples:
            ::
        
                ensight.file.image_format("envideo")
                ensight.file.animation_file("/tmp/test_animation")
                ensight.file.animation_window_size("NTSC")
                ensight.file.animation_window_xy(640,480)
                ensight.file.animation_frames(20)
                ensight.file.animation_multiple_images("OFF")
                ensight.file.animation_reset_flipbook("ON")
                ensight.file.animation_reset_traces("OFF")
                ensight.file.animation_reset_time("ON")
                ensight.file.save_animation()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.file.animation_file({repr(p0)})'''
        return self._session.cmd(cmd)

    def animation_format(self, p0: str) -> int:
        """File: animation_format

        """
        cmd = f'''ensight.file.animation_format({repr(p0)})'''
        return self._session.cmd(cmd)

    def animation_format_options(self, p0: str) -> int:
        """File: animation_format_options

        """
        cmd = f'''ensight.file.animation_format_options({repr(p0)})'''
        return self._session.cmd(cmd)

    def animation_frame_rate(self, p0: float) -> int:
        """File: animation_frame_rate

        """
        cmd = f'''ensight.file.animation_frame_rate({repr(p0)})'''
        return self._session.cmd(cmd)

    def animation_frames(self, p0: int) -> int:
        """Specify the number of frames to save when recording an animation.
        
        Args:
            p0:
                'number_of' number of frames to save
        
        Examples:
            ::
        
                ensight.file.image_format("envideo")
                ensight.file.animation_file("/tmp/test_animation")
                ensight.file.animation_window_size("NTSC")
                ensight.file.animation_window_xy(640,480)
                ensight.file.animation_frames(20)
                ensight.file.animation_multiple_images("OFF")
                ensight.file.animation_reset_flipbook("ON")
                ensight.file.animation_reset_traces("OFF")
                ensight.file.animation_reset_time("ON")
                ensight.file.save_animation()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.file.animation_frames({repr(p0)})'''
        return self._session.cmd(cmd)

    def animation_gamma(self, p0: float) -> int:
        """File: animation_gamma

        """
        cmd = f'''ensight.file.animation_gamma({repr(p0)})'''
        return self._session.cmd(cmd)

    def animation_multiple_images(self, p0: str) -> int:
        """Specify whether to save multiple images when recording an animation (if you are displaying on multiple detached displays).
        
        | You will need to have specified multiple detached displays in order for this command to have any effect.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.file.image_format("envideo")
                ensight.file.animation_file("/tmp/test_animation")
                ensight.file.animation_window_size("NTSC")
                ensight.file.animation_window_xy(640,480)
                ensight.file.animation_frames(20)
                ensight.file.animation_multiple_images("OFF")
                ensight.file.animation_reset_flipbook("ON")
                ensight.file.animation_reset_traces("OFF")
                ensight.file.animation_reset_time("ON")
                ensight.file.save_animation()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.file.animation_multiple_images({repr(p0)})'''
        return self._session.cmd(cmd)

    def animation_numpasses(self, p0: int) -> int:
        """File: animation_numpasses

        """
        cmd = f'''ensight.file.animation_numpasses({repr(p0)})'''
        return self._session.cmd(cmd)

    def animation_play_flipbook(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.file.animation_play_flipbook({repr(p0)})'''
        return self._session.cmd(cmd)

    def animation_play_keyframe(self, p0: str) -> int:
        """File: animation_play_keyframe

        """
        cmd = f'''ensight.file.animation_play_keyframe({repr(p0)})'''
        return self._session.cmd(cmd)

    def animation_play_time(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.file.animation_play_time({repr(p0)})'''
        return self._session.cmd(cmd)

    def animation_raytrace_ext(self, p0: str) -> int:
        """File: animation_raytrace_ext

        """
        cmd = f'''ensight.file.animation_raytrace_ext({repr(p0)})'''
        return self._session.cmd(cmd)

    def animation_raytrace_it(self, p0: str) -> int:
        """File: animation_raytrace_it

        """
        cmd = f'''ensight.file.animation_raytrace_it({repr(p0)})'''
        return self._session.cmd(cmd)

    def animation_rend_offscreen(self, p0: str) -> int:
        """File: animation_rend_offscreen

        """
        cmd = f'''ensight.file.animation_rend_offscreen({repr(p0)})'''
        return self._session.cmd(cmd)

    def animation_reset_flipbook(self, p0: str) -> int:
        """Specify whether to reset the flipbook as the animation is saved.
        
        | None.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.file.image_format("envideo")
                ensight.file.animation_file("/tmp/test_animation")
                ensight.file.animation_window_size("NTSC")
                ensight.file.animation_window_xy(640,480)
                ensight.file.animation_frames(20)
                ensight.file.animation_multiple_images("OFF")
                ensight.file.animation_reset_flipbook("ON")
                ensight.file.animation_reset_traces("OFF")
                ensight.file.animation_reset_time("ON")
                ensight.file.save_animation()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.file.animation_reset_flipbook({repr(p0)})'''
        return self._session.cmd(cmd)

    def animation_reset_keyframe(self, p0: str) -> int:
        """File: animation_reset_keyframe

        """
        cmd = f'''ensight.file.animation_reset_keyframe({repr(p0)})'''
        return self._session.cmd(cmd)

    def animation_reset_time(self, p0: str) -> int:
        """Specify whether to reset the solution time as the animation is saved.
        
        | None.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.file.image_format("envideo")
                ensight.file.animation_file("/tmp/test_animation")
                ensight.file.animation_window_size("NTSC")
                ensight.file.animation_window_xy(640,480)
                ensight.file.animation_frames(20)
                ensight.file.animation_multiple_images("OFF")
                ensight.file.animation_reset_flipbook("ON")
                ensight.file.animation_reset_traces("OFF")
                ensight.file.animation_reset_time("ON")
                ensight.file.save_animation()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.file.animation_reset_time({repr(p0)})'''
        return self._session.cmd(cmd)

    def animation_reset_traces(self, p0: str) -> int:
        """Specify whether to reset the animated particle traces as the animation is saved.
        
        | None.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.file.image_format("envideo")
                ensight.file.animation_file("/tmp/test_animation")
                ensight.file.animation_window_size("NTSC")
                ensight.file.animation_window_xy(640,480)
                ensight.file.animation_frames(20)
                ensight.file.animation_multiple_images("OFF")
                ensight.file.animation_reset_flipbook("ON")
                ensight.file.animation_reset_traces("OFF")
                ensight.file.animation_reset_time("ON")
                ensight.file.save_animation()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.file.animation_reset_traces({repr(p0)})'''
        return self._session.cmd(cmd)

    def animation_saturation(self, p0: float) -> int:
        """File: animation_saturation

        """
        cmd = f'''ensight.file.animation_saturation({repr(p0)})'''
        return self._session.cmd(cmd)

    def animation_screen_tiling(self, p0: int, p1: int) -> int:
        """File: animation_screen_tiling

        """
        cmd = f'''ensight.file.animation_screen_tiling({repr(p0)},{repr(p1)})'''
        return self._session.cmd(cmd)

    def animation_start_number(self, p0: int) -> int:
        """File: animation_start_number

        """
        cmd = f'''ensight.file.animation_start_number({repr(p0)})'''
        return self._session.cmd(cmd)

    def animation_stereo(self, p0: str) -> int:
        """File: animation_stereo

        """
        cmd = f'''ensight.file.animation_stereo({repr(p0)})'''
        return self._session.cmd(cmd)

    def animation_window_size(self, p0: str) -> int:
        """Specify type (and thus in most cases the size) of the animation window to save when recording.
        
        | None.
        
        Args:
            p0:
                'type'
        
                * normal
                * full
                * detached display
                * user_defined
                * NTSC
                * PAL
                * HD720p
                * HD1080p
                * DVDNTSC
                * DVDPAL
        
        Examples:
            ::
        
                ensight.file.image_format("envideo")
                ensight.file.animation_file("/tmp/test_animation")
                ensight.file.animation_window_size("NTSC")
                ensight.file.animation_window_xy(640,480)
                ensight.file.animation_frames(20)
                ensight.file.animation_multiple_images("OFF")
                ensight.file.animation_reset_flipbook("ON")
                ensight.file.animation_reset_traces("OFF")
                ensight.file.animation_reset_time("ON")
                ensight.file.save_animation()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.file.animation_window_size({repr(p0)})'''
        return self._session.cmd(cmd)

    def animation_window_xy(self, p0: int, p1: int) -> int:
        """Specify resolution of the animation window to save - when using user_defined type.
        
        | Applicable only if file: animation_window_size is set to user_defined.
        
        Args:
            p0:
                'xres' window x resolution
            p1:
                'yres' window y resolution 
        
        Examples:
            ::
        
                ensight.file.image_format("envideo")
                ensight.file.animation_file("/tmp/test_animation")
                ensight.file.animation_window_size("user_defined")
                ensight.file.animation_window_xy(400,300)
                ensight.file.animation_frames(20)
                ensight.file.animation_multiple_images("OFF")
                ensight.file.animation_reset_flipbook("ON")
                ensight.file.animation_reset_traces("OFF")
                ensight.file.animation_reset_time("ON")
                ensight.file.save_animation()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.file.animation_window_xy({repr(p0)},{repr(p1)})'''
        return self._session.cmd(cmd)

    def context_restore_rescale(self, p0: str) -> int:
        """File: context_restore_rescale

        """
        cmd = f'''ensight.file.context_restore_rescale({repr(p0)})'''
        return self._session.cmd(cmd)

    def image_avi_type(self, p0: str) -> int:
        """File: image_avi_type

        """
        cmd = f'''ensight.file.image_avi_type({repr(p0)})'''
        return self._session.cmd(cmd)

    def image_bit_rate(self, p0: int) -> int:
        """File: image_bit_rate

        """
        cmd = f'''ensight.file.image_bit_rate({repr(p0)})'''
        return self._session.cmd(cmd)

    def image_color_type(self, p0: str) -> int:
        """Specify that the image will be printed in color or black and white
        
        | All formats support this parameter except TIFF and EnVideo
        
        Args:
            p0:
                'color_type'
        
                * color
                * black&white
        
        Examples:
            ::
        
                ensight.file.image_format("jpeg")
                ensight.file.image_color_type("black&white")
                ensight.file.image_file("/tmp/test_image")
                ensight.file.save_image()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.file.image_color_type({repr(p0)})'''
        return self._session.cmd(cmd)

    def image_convert(self, p0: str) -> int:
        """Change black backgrounds to white and change any white objects (geometry, plotters, annotations, etc.) to black.
        
        Args:
            p0:
                'toggle'
        
                * ON 
                * OFF
        
        Examples:
            ::
        
                ensight.file.image_format("sgi_rgb")
                ensight.file.image_file("/tmp/test_image")
                ensight.file.image_convert("ON")
                ensight.file.save_image()
                ensight.file.image_convert("OFF")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.file.image_convert({repr(p0)})'''
        return self._session.cmd(cmd)

    def image_encapsulated(self, p0: str) -> int:
        """Turn on/off encapsulation for postscript output
        
        | Encapsulation should only be used when the resulting image file will be used as part of another document.  Printers do not normally interpret encapsulated image files. 
        
        Args:
            p0:
                'toggle'
        
                * ON 
                * OFF
        
        Examples:
            ::
        
                ensight.file.image_format("postscript")
                ensight.file.image_color_type("black&white")
                ensight.file.image_file("/tmp/test_image")
                ensight.file.image_orientation("landscape")
                ensight.file.image_encapsulated("ON")
                ensight.file.save_image()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.file.image_encapsulated({repr(p0)})'''
        return self._session.cmd(cmd)

    def image_envideo_type(self, p0: str) -> int:
        """Set the envideo format compression scheme.
        
        | rle is a lossless compression scheme, though it produces larger files than jpeg.  If the compression scheme is jpeg, "file: image_quality" controls the jpeg compression/quality.
        
        Args:
            p0:
                'compression_type'
        
                * rle 
                * jpeg 
        
        Examples:
            ::
        
                ensight.file.image_format("envideo")
                ensight.file.image_envideo_type("jpeg")
                ensight.file.image_quality(80)
                ensight.file.image_file("/tmp/test_image")
                ensight.file.save_image()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.file.image_envideo_type({repr(p0)})'''
        return self._session.cmd(cmd)

    def image_file(self, p0: str) -> int:
        """Specify the filename to be used for image printing.
        
        | Must be specified before a "file: save_image" if "file: image_to_file" is ON.
        
        Args:
            p0:
                'filename' name of the image file to be saved
        
        Examples:
            ::
        
                ensight.file.image_format("jpeg")
                ensight.file.image_file("/tmp/test_image")
                ensight.file.save_image()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.file.image_file({repr(p0)})'''
        return self._session.cmd(cmd)

    def image_format(self, p0: str) -> int:
        """Specifies the file format to be used when an image is created.
        
        | If the image is saved to a disk file the filename is concatenated with an extension as follows:
        | bmp - .bmp							gif - .gif
        | jpeg -.jpg							mov - .mov
        | tiff -.tif							envideo -.evo
        | png - .png							mpeg -.mpg
        | postscript -.ps							avi - .avi
        | encapsulated ps -.eps							POVRAY -.pov & .inc  (requires gold license)
        | sgi -.rgb							
        
        Args:
            p0:
                'image_format'
        
                * The image format which must be one of:
                * bmp
                * jpeg
                * tiff
                * png
                * postscript
                * sgi
                * evo
                * evo
                * mpeg
                * gif
                * mov
                * avi
                * POVRAY
        
        Examples:
            ::
        
                ensight.file.image_format("jpeg")
                ensight.file.image_file("/tmp/test_image")
                ensight.file.save_image()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.file.image_format({repr(p0)})'''
        return self._session.cmd(cmd)

    def image_format_options(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.file.image_format_options({repr(p0)})'''
        return self._session.cmd(cmd)

    def image_frame_rate(self, p0: float) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.file.image_frame_rate({repr(p0)})'''
        return self._session.cmd(cmd)

    def image_gamma(self, p0: float) -> int:
        """Set gamma correction value for PCL image files.
        
        | Gamma corrects for monitor/printer non-linearities for color saturation/brightness.For example, without gamma correction, a full intensity red pixel will not be twice as bright as a half intensity pixel.  1.0 is the default and is used if not specified.
        
        Args:
            p0:
                'gamma_value' The range is dependent on the system.  Typically values are on the order 1<= gamma_value <=3.
        
        Examples:
            ::
        
                ensight.file.image_format("pcl")
                ensight.file.image_gamma(1.7)
                ensight.file.image_printer_model("DeskJet_1200c")
                ensight.file.image_file("/tmp/test_image")
                ensight.file.save_image()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.file.image_gamma({repr(p0)})'''
        return self._session.cmd(cmd)

    def image_mpeg_type(self, p0: str) -> int:
        """File: image_mpeg_type

        """
        cmd = f'''ensight.file.image_mpeg_type({repr(p0)})'''
        return self._session.cmd(cmd)

    def image_numpasses(self, p0: int) -> int:
        """Specify the number of rendering passes for anti-aliasing.  The higher the number of rendering passes the better the anti-aliasing but the longer it will take to render.  This parameter is independent of any possible anti-aliasing settings for the hardware, i.e., if the hardware is set for 4x antialiasing and this parameter is set to 2 you will still render two passes, each pass with 4x antialiasing.
        
        | There is no guarantee that if an image is rendered to an offscreen buffer that this buffer have the same hardware antialiasing depth available as the main graphics window.
        
        Args:
            p0:
                'value' The number of rendering passes
        
        Examples:
            ::
        
                ensight.file.image_numpasses(4)
                ensight.file.image_stereo("current")
                ensight.file.image_format("evo")
                ensight.file.image_file("/tmp/abc")
                ensight.file.save_image()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.file.image_numpasses({repr(p0)})'''
        return self._session.cmd(cmd)

    def image_orientation(self, p0: str) -> int:
        """Sets the image orientation for PCL and Postscript image formats
        
        | "portrait" is used if not specified.
        
        Args:
            p0:
                'orientation'
        
                * portrait
                * landscape
        
        Examples:
            ::
        
                ensight.file.image_format("postscript")
                ensight.file.image_color_type("black&white")
                ensight.file.image_file("/tmp/test_image")
                ensight.file.image_orientation("landscape")
                ensight.file.save_image()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.file.image_orientation({repr(p0)})'''
        return self._session.cmd(cmd)

    def image_plot_only(self, p0: str) -> int:
        """When printing an image will turn invisible everything except for plotters.
        
        | If turned ON, should be turned OFF after a "file: save_image"
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF 
        
        Examples:
            ::
        
                ensight.file.image_format("jpeg")
                ensight.file.image_quality(80)
                ensight.file.image_file("/tmp/test_image")
                ensight.file.image_plot_only("ON")
                ensight.file.save_image()
                ensight.file.image_plot_only("OFF")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.file.image_plot_only({repr(p0)})'''
        return self._session.cmd(cmd)

    def image_postscript_cull(self, p0: str) -> int:
        """For postscript format move-draw images turns on/off the removal of hidden geometry.
        
        | Culling hidden geometry can vastly improve printer performance and reduce file size.  However, processing time is significantly higher.
        | When OFF the geometry will be drawn from back to front.
        | The default is ON.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.file.image_format("postscript")
                ensight.file.image_postscript_type("move_draw")
                ensight.file.image_postscript_cull("OFF")
                ensight.file.image_file("/tmp/test_image")
                ensight.file.save_image()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.file.image_postscript_cull({repr(p0)})'''
        return self._session.cmd(cmd)

    def image_postscript_prev(self, p0: str) -> int:
        """Include a windows preview image in an encapsulated postscript (eps) file.
        
        | If a preview image is not included a EPS file will be shown as a grey rectangle in Windows applications.  Many applications which can normally read a EPS file will not be able to read one which includes a windows preview image.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.file.image_format("postscript")
                ensight.file.image_encapsulated("ON")
                ensight.file.image_postscript_prev("ON")
                ensight.file.image_file("/tmp/test_image")
                ensight.file.save_image()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.file.image_postscript_prev({repr(p0)})'''
        return self._session.cmd(cmd)

    def image_postscript_subd(self, p0: str) -> int:
        """For postscript format move-draw images turns on/off the subdivision of polygons for better shading.
        
        | The postscript format supports only a single color per polygon. Lighting and false color mapping will look poor unless the polygon is subdivided into smaller (single color) regions.  The default is ON.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.file.image_format("postscript")
                ensight.file.image_postscript_type("move_draw")
                ensight.file.image_postscript_subd("ON")
                ensight.file.image_file("/tmp/test_image")
                ensight.file.save_image()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.file.image_postscript_subd({repr(p0)})'''
        return self._session.cmd(cmd)

    def image_postscript_type(self, p0: str) -> int:
        """Set the postscript output to move-draw or bitmap.
        
        Args:
            p0:
                'ps_type'
        
                * move_draw
                * image_pixels
        
        Examples:
            ::
        
                ensight.file.image_format("postscript")
                ensight.file.image_file("/tmp/test_image")
                ensight.file.image_postscript_type("image_pixels")
                ensight.file.save_image()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.file.image_postscript_type({repr(p0)})'''
        return self._session.cmd(cmd)

    def image_printer_command(self, p0: str) -> int:
        """Specify the printer command to use when printing an image to a printer
        
        | You can print an image straight to a printer only if the printer can properly interpret the image file.  Many printers will, for example, properly print a postscript file.  Printing a PICT file, however, will usually result in multiple pages of non-printable characters.
        
        Args:
            p0:
                'command' printer command used to print the image
        
        Examples:
            ::
        
                ensight.file.image_format("postscript")
                ensight.file.image_to_file("OFF")
                ensight.file.image_to_printer("ON")
                ensight.file.image_printer_command("lpr -Pcolor")
                ensight.file.save_image()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.file.image_printer_command({repr(p0)})'''
        return self._session.cmd(cmd)

    def image_printer_model(self, p0: str) -> int:
        """Set the target printer for a PCL image file.
        
        Args:
            p0:
                'printer'
        
                * One of:
                * LaserJet
                * LaserJet_+
                * LaserJet_500+
                * Laser Jet_II
                * LaserJet_IIp
                * LaserJet_III
                * LaserJet_4
                * LaserJet_4L
                * DeskJet_500
                * DeskJet_500c
                * DeskJet_550
                * DeskJet_550c
                * DeskJet_1200c
        
        Examples:
            ::
        
                ensight.file.image_format("pcl")
                ensight.file.image_printer_model("DeskJet_1200c")
                ensight.file.image_file("/tmp/test_image")
                ensight.file.save_image()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.file.image_printer_model({repr(p0)})'''
        return self._session.cmd(cmd)

    def image_quality(self, p0: int) -> int:
        """Sets the quality for JPEG images.
        
        | JPEG is a lossy format, i.e., it trades off file size for quality. Normally a quality factor of around 80 will produce a file that will be on order 2X smaller than one produced with a quality factor set to 100 with negligible impact on quality. JPEG format is best used with shaded images
        
        Args:
            p0:
                'quality' 0 <= quality <= 100
            p1:
                'quality' 100 is the highest quality (no compression)
            p2:
                'quality' 0 is the lowest quality (highest compression)
        
        Examples:
            ::
        
                ensight.file.image_format("jpeg")
                ensight.file.image_quality(80)
                ensight.file.image_file("/tmp/test_image")
                ensight.file.save_image()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.file.image_quality({repr(p0)})'''
        return self._session.cmd(cmd)

    def image_raytrace_external(self, p0: str) -> int:
        """File: image_raytrace_external

        """
        cmd = f'''ensight.file.image_raytrace_external({repr(p0)})'''
        return self._session.cmd(cmd)

    def image_raytrace_it(self, p0: str) -> int:
        """File: image_raytrace_it

        """
        cmd = f'''ensight.file.image_raytrace_it({repr(p0)})'''
        return self._session.cmd(cmd)

    def image_rend_offscreen(self, p0: str) -> int:
        """File: image_rend_offscreen

        """
        cmd = f'''ensight.file.image_rend_offscreen({repr(p0)})'''
        return self._session.cmd(cmd)

    def image_saturation(self, p0: float) -> int:
        """Desaturate color when saving an image to disk or printer.
        
        | Desaturating images is especially useful when saving images to a format which will be played back on a television monitor as fully saturated colors have a tendency to "bleed". 1.0 is the default and is used if not specified.
        
        Args:
            p0:
                'sat_value' A value from 0 (black and white) to 1 (full color saturation)
        
        Examples:
            ::
        
                ensight.file.image_format("sgi_rgb")
                ensight.file.image_saturation(0.8)
                ensight.file.image_file("/tmp/test_image")
                ensight.file.save_image()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.file.image_saturation({repr(p0)})'''
        return self._session.cmd(cmd)

    def image_scale_factor(self, p0: float) -> int:
        """To scale a postscript image for the page size.
        
        Args:
            p0:
                'scale_value' a value from 0 to 1 specifying portion of the page to use for printing
        
        Examples:
            ::
        
                ensight.file.image_format("postscript")
                ensight.file.image_color_type("black&white")
                ensight.file.image_file("/tmp/test_image")
                ensight.file.image_orientation("landscape")
                ensight.file.image_scale_factor(.5)
                ensight.file.save_image()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.file.image_scale_factor({repr(p0)})'''
        return self._session.cmd(cmd)

    def image_screen_tiling(self, p0: int, p1: int) -> int:
        """Create a multi-tile image suitable for display via EnVideo to a multi-tile (i.e., powerwall) display device.
        
        | The total resolution is controlled via the image_window_xy command.  The resolution for each of the tiles is x/y resolution divided by the x_tiles/y_tiles parameter.
        
        Args:
            p0:
                'x_tiles' number of tiles in the x direction 
            p1:
                'y_tiles' number of tiles in the y direction
        
        Examples:
            ::
        
                ensight.file.image_numpasses(4)
                ensight.file.image_window_xy(3840,2048)
                ensight.file.image_screen_tiling(3,2)
                ensight.file.image_format("evo")
                ensight.file.image_file("/tmp/abc")
                ensight.file.save_image()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.file.image_screen_tiling({repr(p0)},{repr(p1)})'''
        return self._session.cmd(cmd)

    def image_stereo(self, p0: str) -> int:
        """Set stereo/mono output for the image file.
        
        Args:
            p0:
                'type'
        
                * current
                * mono
                * interleaved
                * redblue
                * bluered
                * redcyan
                * cyanred
        
        Examples:
            ::
        
                ensight.file.image_numpasses(4)
                ensight.file.image_stereo("redblue")
                ensight.file.image_format("evo")
                ensight.file.image_file("/tmp/abc")
                ensight.file.save_image()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.file.image_stereo({repr(p0)})'''
        return self._session.cmd(cmd)

    def image_to_file(self, p0: str) -> int:
        """Specifies if the image should be saved to a disk file.
        
        | If flag is set to OFF, the other choice, printing the image directly to a printer should be specified.  If ON the "file: image_file" command should be specified.  The default is ON, i.e., this command does not have to be specified if printing an image to a file.
        
        Args:
            p0:
                'toggle'
        
                * ON  
                * OFF
        
        Examples:
            ::
        
                ensight.file.image_format("jpeg")
                ensight.file.image_to_file("ON")
                ensight.file.image_file("/tmp/test_image")
                ensight.file.save_image()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.file.image_to_file({repr(p0)})'''
        return self._session.cmd(cmd)

    def image_to_printer(self, p0: str) -> int:
        """Specifies if the image should be printed directly to a printer.
        
        | If flag is set to OFF, the other choice, printing the image to a disk file should be specified.  If ON, the "file: image_printer_command" should be specified.
        
        Args:
            p0:
                'toggle'
        
                * ON  
                * OFF
        
        Examples:
            ::
        
                ensight.file.image_format("jpeg")
                ensight.file.image_to_file("OFF")
                ensight.file.image_to_printer("ON")
                ensight.file.image_printer_command("lpr -Pprinter")
                ensight.file.save_image()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.file.image_to_printer({repr(p0)})'''
        return self._session.cmd(cmd)

    def image_transparent_back(self, p0: str) -> int:
        """File: image_transparent_back

        """
        cmd = f'''ensight.file.image_transparent_back({repr(p0)})'''
        return self._session.cmd(cmd)

    def image_window_size(self, p0: str) -> int:
        """When printing image based images sets the window (and thus image) size.
        
        | When an image is saved a new window will be created of the size specified.  The default is normal.
        
        Args:
            p0:
                'window_sz'
        
                * normal
                * full
                * User_defined
                * detached_display
                * NTSC
                * PAL
                * HD720p
                * HD1080p
                * DVDNTSC
                * DVDPAL
        
        Examples:
            ::
        
                ensight.file.image_format("sgi_rgb")
                ensight.file.image_window_size("full")
                ensight.file.image_file("/tmp/test_image")
                ensight.file.save_image()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.file.image_window_size({repr(p0)})'''
        return self._session.cmd(cmd)

    def image_window_xy(self, p0: int, p1: int) -> int:
        """Sets the image width and height if the user has specified a user_defined image size.
        
        | For interactive processing width and height are limited to the size of the managed display area. For batch rendering width and height are limited to 15360 x 4096.
        | If the aspect ratio of EnSight's graphics area does not match the specified values the resulting image will not match what is currently displayed. To avoid this problem the specified aspect ratio (width/height) must match what is currently in use.  To find the currently in use values enter "test: size_of_window" in the command dialog.  The currently in use values will be printed in the EnSight shell window.
        
        Args:
            p0:
                'width' pixels in x direction
            p1:
                'height' pixels in y direction
        
        Examples:
            ::
        
                ensight.file.image_format("sgi_rgb")
                ensight.file.image_window_size("user_defined")
                ensight.file.image_window_xy(800,600)
                ensight.file.image_file("/tmp/test_image")
                ensight.file.save_image()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.file.image_window_xy({repr(p0)},{repr(p1)})'''
        return self._session.cmd(cmd)

    def raytracer(self, p0: str) -> int:
        """File: raytracer

        """
        cmd = f'''ensight.file.raytracer({repr(p0)})'''
        return self._session.cmd(cmd)

    def raytracer_options(self, p0: str) -> int:
        """File: raytracer_options

        """
        cmd = f'''ensight.file.raytracer_options({repr(p0)})'''
        return self._session.cmd(cmd)

    def restore_context(self, p0: str) -> int:
        """Restore a context file.
        
        | If a context file is restored before data is read the data used to create the context file is also restored together with the parts that existed at the time the context file was saved.
        | If a context file is restored after data is read but before parts are created the same parts that existed in the context file will be restored.
        | If a context file is restored after data and parts have been loaded, the context content is applied towards the loaded parts.  In this case the part names must match.  If part names do not match the user must manually match up the parts via a pop-up dialog.
        
        Args:
            p0:
                'filename' name of the context file to restore
        
        Examples:
            ::
        
                ensight.file.restore_context("/tmp/test.ctx")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.file.restore_context({repr(p0)})'''
        return self._session.cmd(cmd)

    def restore_full_backup(self, p0: str) -> int:
        """Restore an EnSight archive (restart) file.
        
        | The file specified must be located on the EnSight client machine.
        | The file specified contains the file names of the archive files for both the client and server machines.
        | When an EnSight archive file is restored, the EnSight command file used to generate the archive file is also restored.  The command file is named ensig********.restore and is usually located in /usr/tmp (UNIX) or the user's home directory (windows).  The restored command file contains the commands from the last EnSight session.  In the case where the session was started with an archive restore, the command file will not be complete.
        | Archive files are usually not compatible between major EnSight releases and are usually not portable between machines.  Should the restore of an archive fail, the user should consider using the command file mentioned above.
        
        Args:
            p0:
                'filename' name of the EnSight archive file
        
        Examples:
            ::
        
                ensight.file.restore_full_backup("/tmp/test.ar")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.file.restore_full_backup({repr(p0)})'''
        return self._session.cmd(cmd)

    def save_animation(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.file.save_animation()'''
        return self._session.cmd(cmd)

    def save_cmd_file(self, p0: str) -> int:
        """File: save_cmd_file

        """
        cmd = f'''ensight.file.save_cmd_file({repr(p0)})'''
        return self._session.cmd(cmd)

    def save_context(self, p0: str) -> int:
        """Save a context file.
        
        | A context file provides a data independent way to apply a visualization to a new dataset. 
        | The context file consists, at minimum, of a file containing the commands to recreate the visuals on the screen that existed at the time the context was saved. 
        | The filename is used as a root name as multiple files are saved including the palette, view, and keyframe animation state. 
        | Context files are not portable between big/little endian machines at this time.
        
        Args:
            p0:
                'filename' name of the context file
        
        Examples:
            ::
        
                ensight.file.save_context("/tmp/test.ctx")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.file.save_context({repr(p0)})'''
        return self._session.cmd(cmd)

    def save_context_type(self, p0: str) -> int:
        """Can specify the desired case to use, or all cases, when saving a context file. 
        
        Args:
            p0:
                'all_cases' A context file will be saved for each case
            p1:
                'current_case' A context file will be saved for the current case
        
        Examples:
            ::
        
                ensight.file.save_context_type("all_cases")
                ensight.file.save_context("myfile.ctx")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.file.save_context_type({repr(p0)})'''
        return self._session.cmd(cmd)

    def save_full_backup(self, p0: str) -> int:
        """Create an EnSight archive (restart) file.
        
        | Three files are actually written.  The file name specified contains the name of the other two files and is written on the EnSight client machine. Besides the file specified, one file is written on the EnSight client and server machines containing the archive information.  
        | Archive files are usually not compatible between major EnSight releases and are usually not portable between machines.
        
        Args:
            p0:
                'filename' name of the EnSight archive file
        
        Examples:
            ::
        
                ensight.file.save_full_backup("/tmp/test.ar")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.file.save_full_backup({repr(p0)})'''
        return self._session.cmd(cmd)

    def save_geometric_entities(self, p0: str) -> int:
        """File: save_geometric_entities

        """
        cmd = f'''ensight.file.save_geometric_entities({repr(p0)})'''
        return self._session.cmd(cmd)

    def save_image(self) -> int:
        """Save an image to a disk file.
        
        | Need to have specified the image file with the file: image_file <filename> command before invoking this command.
        
        Examples:
            ::
        
                ensight.file.image_format("jpeg")
                ensight.file.image_file("/tmp/test_image")
                ensight.file.save_image()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.file.save_image()'''
        return self._session.cmd(cmd)

    def save_multiple_images(self, p0: str) -> int:
        """Option to save a single image or multiple images for a flat-wall detached display.
        
        | When saving a flat-wall detached display, the user can choose to write one large image for the wall or one image per pipe from the dconfig file.  This option is only valid when the image size is detached_display.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.file.image_window_size("detached_display")
                ensight.file.save_multiple_images("ON")
                ensight.file.image_file("prefix")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.file.save_multiple_images({repr(p0)})'''
        return self._session.cmd(cmd)

    def save_scenario(self, p0: str) -> int:
        """File: save_scenario

        """
        cmd = f'''ensight.file.save_scenario({repr(p0)})'''
        return self._session.cmd(cmd)

    def save_scenario_file(self, p0: str) -> int:
        """Save a scenario file using all parts.
        
        | A scenario can be restored in EnLiten.
        | A scenario file contains information to completely restore the current visuals in EnLiten.
        | A scenario project contains additional information.
        
        Args:
            p0:
                'filename' name of the file to use for the scenario information
        
        Examples:
            ::
        
                ensight.file.save_scenario_file("/tmp/test_scenario_file")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.file.save_scenario_file({repr(p0)})'''
        return self._session.cmd(cmd)

    def save_scenario_fileslct(self, p0: str) -> int:
        """Save a scenario file using selected parts only.
        
        | A scenario can be restored in EnLiten.
        | A scenario file contains information to completely restore the current visuals in EnLiten.
        | A scenario project contains additional information.
        
        Args:
            p0:
                'filename' name of the file to use for the scenario information
        
        Examples:
            ::
        
                ensight.sendmesgoptions(version="8.23")
                ensight.part.select_all()
                ensight.file.scenario_format("enliten2")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.file.save_scenario_fileslct({repr(p0)})'''
        return self._session.cmd(cmd)

    def save_scenario_png_file(self, p0: str) -> int:
        """Creates an executable by name of <pathname> containing the CEI application Reveal along with the currently specified scenario file.  The executable is for the architecture specified by the 'file: save_scenario_png_format' command.
        
        | Commands associated with this command are:
        | file: save_scenario_png_format and 
        | file: save_scenario_fileslct.
        
        Args:
            p0:
                'pathname' executable file name
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.file.save_scenario_png_file({repr(p0)})'''
        return self._session.cmd(cmd)

    def save_scenario_png_format(self, p0: str) -> int:
        """Specifies the architecture for the 'file: save_scenario_png_format' command.  The architecture name depends upon which Reveal executables are installed on the computer running EnSight.  Architecture names match the subdirectory names found in $CEI_HOME/reveal21/machines/
        
        | Commands associated with this command are:
        | file: save_scenario_png_file and 
        | file: save_scenario_fileslct.
        
        Args:
            p0:
                'arch' architecture name
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.file.save_scenario_png_format({repr(p0)})'''
        return self._session.cmd(cmd)

    def save_scenario_project(self, p0: str) -> int:
        """Save a scenario project using all parts.
        
        | A scenario can be restored in EnLiten.  
        | A scenario file contains information to completely restore the current visuals in EnLiten.  
        | A scenario project contains a scenario file plus (a) a JPEG image file of what the project looks like, (b) a file containing the scenario description, and (c) an EnSight context file (can be multiple files). 
        | The scenario file and associated project files will be named using the directory_name as the root filename.
        
        Args:
            p0:
                'directory_name' name of the directory to save the scenario information
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.file.save_scenario_project({repr(p0)})'''
        return self._session.cmd(cmd)

    def save_scenario_projslct(self, p0: str) -> int:
        """Save a scenario project using selected parts only.
        
        | A scenario can be restored in EnLiten.  
        | A scenario file contains information to completely restore the current visuals in EnLiten.  
        | A scenario project contains a scenario file plus (a) a JPEG image file of what the project looks like, (b) a file containing the scenario description, and (c) an EnSight context file (can be multiple files). 
        | The scenario file and associated project files will be named using the directory_name as the root filename.
        
        Args:
            p0:
                'directory_name' name of the directory to save the scenario information
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.file.save_scenario_projslct({repr(p0)})'''
        return self._session.cmd(cmd)

    def save_scenario_view(self, p0: str, p1: str) -> int:
        """Save a view as part of an existing scenario file.
        
        Args:
            p0:
                'filename' name of the existing scenario file
            p1:
                'viewname' a description for the view
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.file.save_scenario_view({repr(p0)},{repr(p1)})'''
        return self._session.cmd(cmd)

    def save_scenario_which_parts(self, p0: str) -> int:
        """Save a view as part of an existing scenario file.
        
        | The following command is closely related:
        | file: save_scenario_fileslct
        | file: save_scenario_fileslct test.csf
        
        Args:
            p0:
                'option' all, visible, or selected
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.file.save_scenario_which_parts({repr(p0)})'''
        return self._session.cmd(cmd)

    def save_screen_to_clipboard(self, p0: str) -> int:
        """File: save_screen_to_clipboard

        """
        cmd = f'''ensight.file.save_screen_to_clipboard({repr(p0)})'''
        return self._session.cmd(cmd)

    def save_screen_to_file(self, p0: str) -> int:
        """File: save_screen_to_file

        """
        cmd = f'''ensight.file.save_screen_to_file({repr(p0)})'''
        return self._session.cmd(cmd)

    def scenario_desc_begin(self, args: Any) -> int:
        """Delimit the description for a scenario project.
        
        | A scenario project contains descriptions of the project suitable for inclusion in HTML documents.
        
        Examples:
            ::
        
                # WARNING: following line includes OBSOLETE call (ensight.variables.select_varname_begin).
                ensight.variables.select_varname_begin("pressure","velocity","variables: select_varname_end","file: save_scenario_fileslct ami.csf","file: save_scenario_png_format win32","file: save_scenario_png_file ami.csf","file: scenario_desc_begin","This project contains multiple studies from 2001")
                ensight.file.save_scenario_project("file  /tmp/test_project")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.file.scenario_desc_begin({repr(args)})'''
        return self._session.cmd(cmd)

    def scenario_desc_end(self, p0: str) -> int:
        """Delimit the description for a scenario project.
        
        | A scenario project contains descriptions of the project suitable for inclusion in HTML documents.
        
        Examples:
            ::
        
                ensight.file.scenario_desc_begin("This project contains multiple studies from 2001")
                ensight.file.save_scenario_project("file  /tmp/test_project")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.file.scenario_desc_end({repr(p0)})'''
        return self._session.cmd(cmd)

    def scenario_flipbook_anim(self, p0: str) -> int:
        """When a scenario file/project is saved will determine if flipbook animation (if defined) will be included.
        
        | The default is ON
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.file.scenario_flipbook_anim("ON")
                ensight.file.save_scenario_file("/tmp/test_scenario")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.file.scenario_flipbook_anim({repr(p0)})'''
        return self._session.cmd(cmd)

    def scenario_format(self, p0: str) -> int:
        """Sets the type of scenario format to use.
        
        Args:
            p0:
                'type'
        
                * enliten1
                * enliten2
        
        Examples:
            ::
        
                ensight.file.scenario_format("enliten1")
                ensight.file.save_scenario_file("/tmp/test_scenario.els")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.file.scenario_format({repr(p0)})'''
        return self._session.cmd(cmd)

    def scenario_keyframe_anim(self, p0: str) -> int:
        """When a scenario file/project is saved will determine if keyframe animation (if defined) will be included.
        
        | The default is ON.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.file.scenario_keyframe_anim("ON")
                ensight.file.save_scenario_file("/tmp/test_scenario")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.file.scenario_keyframe_anim({repr(p0)})'''
        return self._session.cmd(cmd)

    def scenario_simtime_anim(self, p0: float, p1: float, p2: float, p3: float) -> int:
        """File: scenario_simtime_anim

        """
        cmd = f'''ensight.file.scenario_simtime_anim({repr(p0)},{repr(p1)},{repr(p2)},{repr(p3)})'''
        return self._session.cmd(cmd)

    def scenario_steptime_anim(self, p0: float, p1: float, p2: float, p3: float) -> int:
        """File: scenario_steptime_anim

        """
        cmd = f'''ensight.file.scenario_steptime_anim({repr(p0)},{repr(p1)},{repr(p2)},{repr(p3)})'''
        return self._session.cmd(cmd)

    def scenario_trace_anim(self, p0: str) -> int:
        """When a scenario file/project is saved will determine if particle trace animation (if defined) will be included.
        
        | The default is ON.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.file.scenario_trace_anim("ON")
                ensight.file.save_scenario_file("/tmp/test_scenario")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.file.scenario_trace_anim({repr(p0)})'''
        return self._session.cmd(cmd)

    def scenario_transient_anim(self, p0: float, p1: float, p2: float, p3: float) -> int:
        """When a scenario csf file is saved, will determine if transient data (if available) will be included.
        
        | The default is ON.
        
        Args:
            p0:
                'toggle'
        
                * 1
                * 0
            p1:
                'start'
        
                * starting step number
            p2:
                'end'
        
                * ending step number
            p3:
                'stride'
        
                * step stride
        
        Examples:
            ::
        
                ensight.file.scenario_transient_anim(1,1,21,1)
                ensight.file.save_scenario_file("/tmp/test_scenario")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.file.scenario_transient_anim({repr(p0)},{repr(p1)},{repr(p2)},{repr(p3)})'''
        return self._session.cmd(cmd)

    def select_begin(self, *args, **kwargs) -> Any:
        """File: select_begin

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.file.select_begin({arg_string})"
        return self._session.cmd(cmd)


class extrude:
    """Class wrapper for EnSight extrude module

    This class acts as a proxy for the EnSight Python module ensight.extrude
    """
    def __init__(self, session: Session):
        self._session = session

    def axis(self, p0: float, p1: float, p2: float) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.extrude.axis({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def begin(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.extrude.begin()'''
        return self._session.cmd(cmd)

    def create(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.extrude.create()'''
        return self._session.cmd(cmd)

    def data01(self, args: Any) -> int:
        """Extrude: data01

        """
        cmd = f'''ensight.extrude.data01({repr(args)})'''
        return self._session.cmd(cmd)

    def data02(self, args: Any) -> int:
        """Extrude: data02

        """
        cmd = f'''ensight.extrude.data02({repr(args)})'''
        return self._session.cmd(cmd)

    def data03(self, args: Any) -> int:
        """Extrude: data03

        """
        cmd = f'''ensight.extrude.data03({repr(args)})'''
        return self._session.cmd(cmd)

    def direction_vector(self, p0: float, p1: float, p2: float) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.extrude.direction_vector({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def end(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.extrude.end()'''
        return self._session.cmd(cmd)

    def number_of_slices(self, p0: int) -> int:
        """Extrude: #_of_slices

        """
        cmd = f'''ensight.extrude.number_of_slices({repr(p0)})'''
        return self._session.cmd(cmd)

    def origin(self, p0: float, p1: float, p2: float) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.extrude.origin({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def origin_by_part_centroid(self, p0: str) -> int:
        """Extrude: origin_by_part_centroid

        """
        cmd = f'''ensight.extrude.origin_by_part_centroid({repr(p0)})'''
        return self._session.cmd(cmd)

    def part_byname(self, args: Any) -> int:
        """Extrude: part_byname

        """
        cmd = f'''ensight.extrude.part_byname({repr(args)})'''
        return self._session.cmd(cmd)

    def part_id(self, args: Any) -> int:
        """Extrude: part_id

        """
        cmd = f'''ensight.extrude.part_id({repr(args)})'''
        return self._session.cmd(cmd)

    def select_default(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.extrude.select_default()'''
        return self._session.cmd(cmd)

    def total_rotation(self, p0: float) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.extrude.total_rotation({repr(p0)})'''
        return self._session.cmd(cmd)

    def total_translation(self, p0: float) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.extrude.total_translation({repr(p0)})'''
        return self._session.cmd(cmd)

    def type(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.extrude.type({repr(p0)})'''
        return self._session.cmd(cmd)


class elevsurf:
    """Class wrapper for EnSight elevsurf module

    This class acts as a proxy for the EnSight Python module ensight.elevsurf
    """
    def __init__(self, session: Session):
        self._session = session

    def begin(self) -> int:
        """Delimit the modifications for elevated  surface. parts.
        
        | These commands are used to set the attributes for an elevated surface part creation.
        
        Examples:
            ::
        
                #
                # Select parent
                #
                ensight.part.select_begin(2)
                #
                # Set the attributes
                #
                ensight.elevsurf.begin()
                ensight.elevsurf.variable("N_temperature")
                ensight.elevsurf.offset(0.0000e+00)
                ensight.elevsurf.scale_factor(2.0750e-02)
                ensight.elevsurf.sidewall("ON")
                ensight.elevsurf.surface("ON")
                ensight.elevsurf.end()
                ensight.elevsurf.create()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.elevsurf.begin()'''
        return self._session.cmd(cmd)

    def component(self, p0: float, p1: float, p2: float) -> int:
        """Elevated surfaces are always created with a scalar.  If creation variable is a vector this command specifies how the scalar will be created.
        
        | If all the scale factors are set to 0.0, the magnitude of the vector will be used (this is the default).
        
        Args:
            p0:
                'x_scal ' scale factor to apply to the x, y, z components of the vector
            p1:
                'y_scal' scale factor to apply to the x, y, z components of the vector
            p2:
                'z_scal' scale factor to apply to the x, y, z components of the vector
        
        Examples:
            ::
        
                #
                # Select existing elevated surface part
                #
                ensight.part.select_begin(3)
                ensight.part.modify_begin()
                ensight.elevsurf.variable("N_velocity")
                #
                # Use x-component of the vector
                #
                ensight.elevsurf.component(1.0000e+00,0.0000e+00,0.0000e+00)
                ensight.elevsurf.scale_factor(9.9660e-01)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.elevsurf.component({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def create(self) -> int:
        """Create an elevated surface according to specified or default attributes.
        
        Examples:
            ::
        
                #
                # Select parent part
                #
                ensight.part.select_begin(2)
                ensight.elevsurf.begin()
                ensight.elevsurf.variable("N_temperature")
                ensight.elevsurf.offset(0.0000e+00)
                ensight.elevsurf.scale_factor(2.0750e-02)
                ensight.elevsurf.sidewall("ON")
                ensight.elevsurf.surface("ON")
                ensight.elevsurf.end()
                ensight.elevsurf.create()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.elevsurf.create()'''
        return self._session.cmd(cmd)

    def end(self) -> int:
        """Delimit the modifications for elevated  surface. parts.
        
        | These commands are used to set the attributes for an elevated surface part creation.
        
        Examples:
            ::
        
                #
                # Select parent
                #
                ensight.part.select_begin(2)
                #
                # Set the attributes
                #
                ensight.elevsurf.begin()
                ensight.elevsurf.variable("N_temperature")
                ensight.elevsurf.offset(0.0000e+00)
                ensight.elevsurf.scale_factor(2.0750e-02)
                ensight.elevsurf.sidewall("ON")
                ensight.elevsurf.surface("ON")
                ensight.elevsurf.end()
                ensight.elevsurf.create()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.elevsurf.end()'''
        return self._session.cmd(cmd)

    def offset(self, p0: float) -> int:
        """Specifies a value that is added to the variable values before the scale factor is applied.  Has the effect of moving the surface basis relative to the model.
        
        Args:
            p0:
                'offset_val' value that is applied to the variable values before scaling.
        
        Examples:
            ::
        
                #
                # Select existing elevated surface part
                #
                ensight.part.select_begin(3)
                ensight.part.modify_begin()
                ensight.elevsurf.variable("N_velocity")
                ensight.elevsurf.component(1.0000e+00,0.0000e+00,0.0000e+00)
                ensight.elevsurf.scale_factor(9.9660e-01)
                ensight.elevsurf.offset(1.5000e+00)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.elevsurf.offset({repr(p0)})'''
        return self._session.cmd(cmd)

    def offset_from_part(self, p0: int) -> int:
        """Elevsurf: offset_from_part

        """
        cmd = f'''ensight.elevsurf.offset_from_part({repr(p0)})'''
        return self._session.cmd(cmd)

    def offset_scale(self, p0: float) -> int:
        """Elevsurf: offset_scale

        """
        cmd = f'''ensight.elevsurf.offset_scale({repr(p0)})'''
        return self._session.cmd(cmd)

    def offset_vector(self, p0: float, p1: float, p2: float) -> int:
        """Elevsurf: offset_vector

        """
        cmd = f'''ensight.elevsurf.offset_vector({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def scale_factor(self, p0: float) -> int:
        """Specifies the scale factor to apply to the variable for the elevated surface.
        
        Args:
            p0:
                'scale' scale factor to apply to variable values
        
        Examples:
            ::
        
                #
                # Select existing elevated surface part
                #
                ensight.part.select_begin(3)
                ensight.part.modify_begin()
                ensight.elevsurf.variable("N_velocity")
                ensight.elevsurf.component(1.0000e+00,0.0000e+00,0.0000e+00)
                ensight.elevsurf.scale_factor(9.9660e-01)
                ensight.elevsurf.offset(1.5000e+00)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.elevsurf.scale_factor({repr(p0)})'''
        return self._session.cmd(cmd)

    def select_default(self) -> int:
        """Set elevated surface selection to none, so that subsequent elevated surface attribute commands will apply to the defaults.
        
        | The defaults are used for future elevated surface creations.
        
        Examples:
            ::
        
                ensight.elevsurf.select_default()
                ensight.part.modify_begin()
                ensight.elevsurf.scale_factor(3.0750e-02)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.elevsurf.select_default()'''
        return self._session.cmd(cmd)

    def sidewall(self, p0: str) -> int:
        """Specifies whether the elevated sidewalls will be created.
        
        | This command is used in conjunction with  "elevsurf: surface", to achieve the combinations of surface and sidewall, surface only, or sidewalls only.  
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                #
                # Select parent part
                #
                ensight.part.select_begin(2)
                ensight.elevsurf.begin()
                ensight.elevsurf.variable("N_temperature")
                ensight.elevsurf.offset(0.0000e+00)
                ensight.elevsurf.scale_factor(2.0750e-02)
                ensight.elevsurf.sidewall("ON")
                ensight.elevsurf.surface("ON")
                ensight.elevsurf.end()
                ensight.elevsurf.create()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.elevsurf.sidewall({repr(p0)})'''
        return self._session.cmd(cmd)

    def surface(self, p0: str) -> int:
        """Specifies whether the elevated surface itself will be displayed.
        
        | This command is used in conjunction with  "elevsurf: sidewall", to achieve the combinations of surface and sidewall, surface only, or sidewalls only.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                #
                # Select parent part
                #
                ensight.part.select_begin(2)
                ensight.elevsurf.begin()
                ensight.elevsurf.variable("N_temperature")
                ensight.elevsurf.offset(0.0000e+00)
                ensight.elevsurf.scale_factor(2.0750e-02)
                ensight.elevsurf.sidewall("ON")
                ensight.elevsurf.surface("ON")
                ensight.elevsurf.end()
                ensight.elevsurf.create()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.elevsurf.surface({repr(p0)})'''
        return self._session.cmd(cmd)

    def type(self, p0: str) -> int:
        """Elevsurf: type

        """
        cmd = f'''ensight.elevsurf.type({repr(p0)})'''
        return self._session.cmd(cmd)

    def use_surface_normals(self, p0: str) -> int:
        """Elevsurf: use_surface_normals

        """
        cmd = f'''ensight.elevsurf.use_surface_normals({repr(p0)})'''
        return self._session.cmd(cmd)

    def var_type(self, p0: str) -> int:
        """Elevsurf: var_type

        """
        cmd = f'''ensight.elevsurf.var_type({repr(p0)})'''
        return self._session.cmd(cmd)

    def variable(self, p0: Any) -> int:
        """Assigns the variable to use for the creation of an elevated surface.
        
        Args:
            p0:
                'variable_name' name of the variable to use
        
        Examples:
            ::
        
                #
                # Select parent part
                #
                ensight.part.select_begin(2)
                ensight.elevsurf.begin()
                ensight.elevsurf.variable("N_temperature")
                ensight.elevsurf.offset(0.0000e+00)
                ensight.elevsurf.scale_factor(2.0750e-02)
                ensight.elevsurf.sidewall("ON")
                ensight.elevsurf.surface("ON")
                ensight.elevsurf.end()
                ensight.elevsurf.create()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.elevsurf.variable({repr(p0)})'''
        return self._session.cmd(cmd)


class dpart:
    """Class wrapper for EnSight dpart module

    This class acts as a proxy for the EnSight Python module ensight.dpart
    """
    def __init__(self, session: Session):
        self._session = session

    def begin(self) -> int:
        """Dpart: begin

        """
        cmd = f'''ensight.dpart.begin()'''
        return self._session.cmd(cmd)

    def end(self) -> int:
        """Dpart: end

        """
        cmd = f'''ensight.dpart.end()'''
        return self._session.cmd(cmd)

    def select_default(self) -> int:
        """Dpart: select_default

        """
        cmd = f'''ensight.dpart.select_default()'''
        return self._session.cmd(cmd)


class dial:
    """Class wrapper for EnSight dial module

    This class acts as a proxy for the EnSight Python module ensight.dial
    """
    def __init__(self, session: Session):
        self._session = session

    def background(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.dial.background({repr(p0)})'''
        return self._session.cmd(cmd)

    def background_rgb(self, p0: float, p1: float, p2: float) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.dial.background_rgb({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def big_hand_range(self, p0: float) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.dial.big_hand_range({repr(p0)})'''
        return self._session.cmd(cmd)

    def big_hand_rgb(self, p0: float, p1: float, p2: float) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.dial.big_hand_rgb({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def border(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.dial.border({repr(p0)})'''
        return self._session.cmd(cmd)

    def delete(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.dial.delete()'''
        return self._session.cmd(cmd)

    def description(self, p0: str) -> int:
        """Dial: description

        """
        cmd = f'''ensight.dial.description({repr(p0)})'''
        return self._session.cmd(cmd)

    def deselect_all(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.dial.deselect_all()'''
        return self._session.cmd(cmd)

    def little_hand(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.dial.little_hand({repr(p0)})'''
        return self._session.cmd(cmd)

    def little_hand_range(self, p0: float) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.dial.little_hand_range({repr(p0)})'''
        return self._session.cmd(cmd)

    def little_hand_rgb(self, p0: float, p1: float, p2: float) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.dial.little_hand_rgb({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def location_x(self, p0: float) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.dial.location_x({repr(p0)})'''
        return self._session.cmd(cmd)

    def location_y(self, p0: float) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.dial.location_y({repr(p0)})'''
        return self._session.cmd(cmd)

    def minimum(self, p0: float) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.dial.minimum({repr(p0)})'''
        return self._session.cmd(cmd)

    def modify_begin(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.dial.modify_begin()'''
        return self._session.cmd(cmd)

    def modify_end(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.dial.modify_end()'''
        return self._session.cmd(cmd)

    def new_dial(self, p0: Any) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.dial.new_dial({repr(p0)})'''
        return self._session.cmd(cmd)

    def new_or_mod_dial(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.dial.new_or_mod_dial({repr(p0)})'''
        return self._session.cmd(cmd)

    def query_count(self, args: Any) -> int:
        """Dial: query_count

        """
        cmd = f'''ensight.dial.query_count({repr(args)})'''
        return self._session.cmd(cmd)

    def query_display_attributes(self, args: Any) -> int:
        """Dial: query_display_attributes

        """
        cmd = f'''ensight.dial.query_display_attributes({repr(args)})'''
        return self._session.cmd(cmd)

    def query_selected_objects(self, args: Any) -> int:
        """Dial: query_selected_objects

        """
        cmd = f'''ensight.dial.query_selected_objects({repr(args)})'''
        return self._session.cmd(cmd)

    def radius(self, p0: float) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.dial.radius({repr(p0)})'''
        return self._session.cmd(cmd)

    def select_all(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.dial.select_all()'''
        return self._session.cmd(cmd)

    def select_all_invisible(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.dial.select_all_invisible()'''
        return self._session.cmd(cmd)

    def select_all_visible(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.dial.select_all_visible()'''
        return self._session.cmd(cmd)

    def select_begin(self, *args, **kwargs) -> Any:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.dial.select_begin({arg_string})"
        return self._session.cmd(cmd)

    def select_default(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.dial.select_default()'''
        return self._session.cmd(cmd)

    def show_as(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.dial.show_as({repr(p0)})'''
        return self._session.cmd(cmd)

    def tick_marks(self, p0: int) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.dial.tick_marks({repr(p0)})'''
        return self._session.cmd(cmd)

    def value(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.dial.value({repr(p0)})'''
        return self._session.cmd(cmd)

    def value_decimal_places(self, p0: int) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.dial.value_decimal_places({repr(p0)})'''
        return self._session.cmd(cmd)

    def value_format(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.dial.value_format({repr(p0)})'''
        return self._session.cmd(cmd)

    def value_location(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.dial.value_location({repr(p0)})'''
        return self._session.cmd(cmd)

    def value_rgb(self, p0: float, p1: float, p2: float) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.dial.value_rgb({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def value_size(self, p0: int) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.dial.value_size({repr(p0)})'''
        return self._session.cmd(cmd)

    def variable(self, p0: Any) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.dial.variable({repr(p0)})'''
        return self._session.cmd(cmd)

    def visible(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.dial.visible({repr(p0)})'''
        return self._session.cmd(cmd)


class devsrf:
    """Class wrapper for EnSight devsrf module

    This class acts as a proxy for the EnSight Python module ensight.devsrf
    """
    def __init__(self, session: Session):
        self._session = session

    def axis(self, p0: float, p1: float, p2: float) -> int:
        """Specifies the direction of the axis of revolution, or longitudinal axis, of the revolved part.
        
        | This vector corresponds to the direction of the axis of revolution of the cylinder, cone, sphere, or revolution tool for any revolved surface created via these quadric tools.  Otherwise, this vector should be specified to coincide with the axis of revolution of the 2D parent part.
        | This is the longitudinal axis about which the nodes of the selected part(s) are mapped to the computational developing cylinder; which cylinder is subsequently unrolled yielding the developed (unrolled) surface.
        
        Args:
            p0:
                'dx' cartesian vector x, y, z components of the developing cylinder's longitudinal axis
            p1:
                'dy' cartesian vector x, y, z components of the developing cylinder's longitudinal axis
            p2:
                'dz' cartesian vector x, y, z components of the developing cylinder's longitudinal axis
        
        Examples:
            ::
        
                ensight.devsrf.select_default()
                ensight.part.modify_begin()
                ensight.devsrf.origin(5.0000e-01,5.0000e-01,0.0000e+00)
                ensight.devsrf.axis(0.0000e+00,0.0000e+00,1.0000e+00)
                ensight.devsrf.seam_vector(1.0000e+00,0.0000e+00,0.0000e+00)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.devsrf.axis({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def begin(self) -> int:
        """A wrapper command construct that contains the appropriate developed surface attribute commands used to create a (2D) developed surface part.
        
        Args:
            p0:
                'command list' appropriate devsrf commands that affect the creation of the developed surface part - see Example Usage below
        
        Examples:
            ::
        
                ensight.part.select_begin(2)
                ensight.devsrf.begin()
                ensight.devsrf.origin(5.0000e-01,5.0000e-01,0.0000e+00)
                ensight.devsrf.axis(0.0000e+00,0.0000e+00,1.0000e+00)
                ensight.devsrf.seam_vector(1.0000e+00,0.0000e+00,0.0000e+00)
                ensight.devsrf.end()
                ensight.devsrf.create()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.devsrf.begin()'''
        return self._session.cmd(cmd)

    def create(self) -> int:
        """Specifies the creation of a developed, or unrolled surface. This unrolls the selected 2D (parent) part into a flat2D developed part.
        
        | In the example below, the 2 in the 2D parent part 2 is unrolled into the 2D developed part 3.
        
        Examples:
            ::
        
                #
                # Align default settings according to parent part
                #
                ensight.part.select_begin(2)
                ensight.devsrf.select_default()
                ensight.part.modify_begin()
                ensight.devsrf.origin(5.0000e-01,5.0000e-01,0.0000e+00)
                ensight.devsrf.axis(0.0000e+00,0.0000e+00,1.0000e+00)
                ensight.devsrf.seam_vector(1.0000e+00,0.0000e+00,0.0000e+00)
                ensight.part.modify_end()
                #
                # Create developed part 3 from parent part 2
                #
                ensight.part.select_begin(2)
                ensight.devsrf.begin()
                ensight.devsrf.origin(5.0000e-01,5.0000e-01,0.0000e+00)
                ensight.devsrf.axis(0.0000e+00,0.0000e+00,1.0000e+00)
                ensight.devsrf.seam_vector(1.0000e+00,0.0000e+00,0.0000e+00)
                ensight.devsrf.end()
                ensight.devsrf.create()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.devsrf.create()'''
        return self._session.cmd(cmd)

    def create_noviewport(self) -> int:
        """Devsrf: create_noviewport

        """
        cmd = f'''ensight.devsrf.create_noviewport()'''
        return self._session.cmd(cmd)

    def end(self) -> int:
        """A wrapper command construct that contains the appropriate developed surface attribute commands used to create a (2D) developed surface part.
        
        Args:
            p0:
                'command list' appropriate devsrf commands that affect the creation of the developed surface part - see Example Usage below
        
        Examples:
            ::
        
                ensight.part.select_begin(2)
                ensight.devsrf.begin()
                ensight.devsrf.origin(5.0000e-01,5.0000e-01,0.0000e+00)
                ensight.devsrf.axis(0.0000e+00,0.0000e+00,1.0000e+00)
                ensight.devsrf.seam_vector(1.0000e+00,0.0000e+00,0.0000e+00)
                ensight.devsrf.end()
                ensight.devsrf.create()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.devsrf.end()'''
        return self._session.cmd(cmd)

    def origin(self, p0: float, p1: float, p2: float) -> int:
        """Specifies an origin which lies on the axis of revolution, or the longitudinal axis of the developing cylinder.
        
        | This point corresponds to the origin of the cylinder, cone, sphere, or revolution tool for any revolved surface created via these quadric tools.  Otherwise, this point locates the axis of revolution of the 2D parent part.
        
        Args:
            p0:
                'x_comp' x, y, z components of the origin of the developing cylinder (located on the longitudinal axis) in model coordinates
            p1:
                'y_comp' x, y, z components of the origin of the developing cylinder (located on the longitudinal axis) in model coordinates
            p2:
                'z_comp' x, y, z components of the origin of the developing cylinder (located on the longitudinal axis) in model coordinates
        
        Examples:
            ::
        
                #
                # Modify the default
                #
                ensight.devsrf.select_default()
                ensight.part.modify_begin()
                ensight.devsrf.origin(5.0000e-01,5.0000e-01,0.0000e+00)
                ensight.devsrf.axis(0.0000e+00,0.0000e+00,1.0000e+00)
                ensight.devsrf.seam_vector(1.0000e+00,0.0000e+00,0.0000e+00)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.devsrf.origin({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def part(self, p0: int) -> int:
        """Devsrf: part

        """
        cmd = f'''ensight.devsrf.part({repr(p0)})'''
        return self._session.cmd(cmd)

    def projection(self, p0: str) -> int:
        """Specifies the type of coordinate projection, or mapping, that the developed surface part represents.
        
        | The meridianal component is defined as m = SQRT(r^2 + z^2).
        | The default projection is (theta,z).
        
        Args:
            p0:
                'type'
        
                * Includes the following types of coordinate projections, or mapping, in (abscissa, ordinate) frame of reference:
                * r,z
                * theta,z
                * m,theta
                * m,r
                * theta,r
        
        Examples:
            ::
        
                ensight.part.select_begin(3)
                ensight.part.modify_begin()
                ensight.devsrf.projection("m,theta")
                ensight.part.modify_end()
                ensight.viewport.select_begin(1)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.devsrf.projection({repr(p0)})'''
        return self._session.cmd(cmd)

    def scale_factor(self, p0: float) -> int:
        """Devsrf: scale_factor

        """
        cmd = f'''ensight.devsrf.scale_factor({repr(p0)})'''
        return self._session.cmd(cmd)

    def scale_factor_u(self, p0: float) -> int:
        """Specifies the scale factor applied to the abscissa/ordinate component of the projection type of the developed part.
        
        | Default scale factor for both u and v is 1.
        
        Args:
            p0:
                'factor' scale factor applied to the abscissa/ordinate of the developed surface projection
        
        Examples:
            ::
        
                ensight.part.select_begin(1)
                ensight.part.modify_begin()
                ensight.devsrf.scale_factor_u(5.0000e-01)
                ensight.devsrf.scale_factor_v(2.0000e+00)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.devsrf.scale_factor_u({repr(p0)})'''
        return self._session.cmd(cmd)

    def scale_factor_v(self, p0: float) -> int:
        """Specifies the scale factor applied to the abscissa/ordinate component of the projection type of the developed part.
        
        | Default scale factor for both u and v is 1.
        
        Args:
            p0:
                'factor' scale factor applied to the abscissa/ordinate of the developed surface projection
        
        Examples:
            ::
        
                ensight.part.select_begin(1)
                ensight.part.modify_begin()
                ensight.devsrf.scale_factor_u(5.0000e-01)
                ensight.devsrf.scale_factor_v(2.0000e+00)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.devsrf.scale_factor_v({repr(p0)})'''
        return self._session.cmd(cmd)

    def seam_vector(self, p0: float, p1: float, p2: float) -> int:
        """Specifies the vector perpendicular to the axis of revolution which points in the direction of the seam line.
        
        | This vector does not specify the actual direction of the seam line by which the surface is split.  Rather it indirectly specifies the location of the seam line via defining a vector perpendicular to and emanating from the axis of revolution which points to the seam (and thus, is consequently perpendicular to the seam).
        
        Args:
            p0:
                'x_comp' cartesian x, y, z vector components of a vector perpendicular to and starting from the axis of revolution and pointing to the seam line
            p1:
                'y_comp' cartesian x, y, z vector components of a vector perpendicular to and starting from the axis of revolution and pointing to the seam line
            p2:
                'z_comp' cartesian x, y, z vector components of a vector perpendicular to and starting from the axis of revolution and pointing to the seam line
        
        Examples:
            ::
        
                #
                # Modify the default
                #
                ensight.devsrf.select_default()
                ensight.part.modify_begin()
                ensight.devsrf.origin(5.0000e-01,5.0000e-01,0.0000e+00)
                ensight.devsrf.axis(0.0000e+00,0.0000e+00,1.0000e+00)
                ensight.devsrf.seam_vector(1.0000e+00,0.0000e+00,0.0000e+00)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.devsrf.seam_vector({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def select_default(self) -> int:
        """Specifies the default origin, axis (of rotation), and seam vector to align according to the longitudinal axis of the selected part.
        
        | This command facilitates a method for the origin, axis, and seam vector to inherit the position and direction of the longitudinal axis of the 2D parent part.
        
        Examples:
            ::
        
                ensight.devsrf.select_default()
                ensight.part.modify_begin()
                ensight.devsrf.origin(5.0000e-01,5.0000e-01,0.0000e+00)
                ensight.devsrf.axis(0.0000e+00,0.0000e+00,1.0000e+00)
                ensight.devsrf.seam_vector(1.0000e+00,0.0000e+00,0.0000e+00)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.devsrf.select_default()'''
        return self._session.cmd(cmd)


class define:
    """Class wrapper for EnSight define module

    This class acts as a proxy for the EnSight Python module ensight.define
    """
    def __init__(self, session: Session):
        self._session = session

    def delete(self) -> int:
        """Define: delete

        """
        cmd = f'''ensight.define.delete()'''
        return self._session.cmd(cmd)

    def description(self, p0: str) -> int:
        """Define: description

        """
        cmd = f'''ensight.define.description({repr(p0)})'''
        return self._session.cmd(cmd)

    def deselect_all(self) -> int:
        """Define: deselect_all

        """
        cmd = f'''ensight.define.deselect_all()'''
        return self._session.cmd(cmd)

    def location_x(self, p0: float) -> int:
        """Define: location_x

        """
        cmd = f'''ensight.define.location_x({repr(p0)})'''
        return self._session.cmd(cmd)

    def location_y(self, p0: float) -> int:
        """Define: location_y

        """
        cmd = f'''ensight.define.location_y({repr(p0)})'''
        return self._session.cmd(cmd)

    def modify_begin(self) -> int:
        """Define: modify_begin

        """
        cmd = f'''ensight.define.modify_begin()'''
        return self._session.cmd(cmd)

    def modify_end(self) -> int:
        """Define: modify_end

        """
        cmd = f'''ensight.define.modify_end()'''
        return self._session.cmd(cmd)

    def new_logo(self, p0: str) -> int:
        """Define: new_logo

        """
        cmd = f'''ensight.define.new_logo({repr(p0)})'''
        return self._session.cmd(cmd)

    def new_or_mod_logo(self, p0: str) -> int:
        """Define: new_or_mod_logo

        """
        cmd = f'''ensight.define.new_or_mod_logo({repr(p0)})'''
        return self._session.cmd(cmd)

    def normalized_width(self, p0: float) -> int:
        """Define: normalized_width

        """
        cmd = f'''ensight.define.normalized_width({repr(p0)})'''
        return self._session.cmd(cmd)

    def query_count(self, args: Any) -> int:
        """Define: query_count

        """
        cmd = f'''ensight.define.query_count({repr(args)})'''
        return self._session.cmd(cmd)

    def query_display_attributes(self, args: Any) -> int:
        """Define: query_display_attributes

        """
        cmd = f'''ensight.define.query_display_attributes({repr(args)})'''
        return self._session.cmd(cmd)

    def query_selected_objects(self, args: Any) -> int:
        """Define: query_selected_objects

        """
        cmd = f'''ensight.define.query_selected_objects({repr(args)})'''
        return self._session.cmd(cmd)

    def read(self, p0: str) -> int:
        """Define: read

        """
        cmd = f'''ensight.define.read({repr(p0)})'''
        return self._session.cmd(cmd)

    def rgb(self, p0: float, p1: float, p2: float) -> int:
        """Define: rgb

        """
        cmd = f'''ensight.define.rgb({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def scale(self, p0: float, p1: float) -> int:
        """Define: scale

        """
        cmd = f'''ensight.define.scale({repr(p0)},{repr(p1)})'''
        return self._session.cmd(cmd)

    def select_all(self) -> int:
        """Define: select_all

        """
        cmd = f'''ensight.define.select_all()'''
        return self._session.cmd(cmd)

    def select_all_invisible(self) -> int:
        """Define: select_all_invisible

        """
        cmd = f'''ensight.define.select_all_invisible()'''
        return self._session.cmd(cmd)

    def select_all_visible(self) -> int:
        """Define: select_all_visible

        """
        cmd = f'''ensight.define.select_all_visible()'''
        return self._session.cmd(cmd)

    def select_begin(self, *args, **kwargs) -> Any:
        """Define: select_begin

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.define.select_begin({arg_string})"
        return self._session.cmd(cmd)

    def select_default(self) -> int:
        """Define: select_default

        """
        cmd = f'''ensight.define.select_default()'''
        return self._session.cmd(cmd)

    def show_raytraced_image(self, p0: str) -> int:
        """Define: show_raytraced_image

        """
        cmd = f'''ensight.define.show_raytraced_image({repr(p0)})'''
        return self._session.cmd(cmd)

    def use_normalized_width(self, p0: str) -> int:
        """Define: use_normalized_width

        """
        cmd = f'''ensight.define.use_normalized_width({repr(p0)})'''
        return self._session.cmd(cmd)

    def visible(self, p0: str) -> int:
        """Define: visible

        """
        cmd = f'''ensight.define.visible({repr(p0)})'''
        return self._session.cmd(cmd)


class data_partbuild:
    """Class wrapper for EnSight data_partbuild module

    This class acts as a proxy for the EnSight Python module ensight.data_partbuild
    """
    def __init__(self, session: Session):
        self._session = session

    def begin(self) -> int:
        """Delineates commands issued while using the Data Part Builder dialogs.
        
        | These commands exist for memory management reasons. While doing part building it is often necessary to have information in memory that will only be used during the part building process. Thus, the begin indicates the need for this memory, and the end indicates that such memory could be freed for other purposes.  All data formats that use the Data Part Builder method use this command (n3s, estet, mpgs4, plot3d, userd, ensight formats, etc).
        
        Args:
            p0:
                'commands' valid command language for part building (can be one or many)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.data_partbuild.begin()'''
        return self._session.cmd(cmd)

    def create(self) -> int:
        """Causes the part to be built according to previously defined attributes or defaults.
        
        | All data formats that use the Data Part Builder method use this command (n3s, estet, mpgs4, plot3d, userd, ensight formats, etc).
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.data_partbuild.create()'''
        return self._session.cmd(cmd)

    def create_iblank(self) -> int:
        """Causes unstructured part(s) to be built from structured part(s) according to iblanking values available.
        
        | All data formats that have structured iblanking use this command (estet, plot3d, EnSight6, EnSight Gold, some userd formats, etc). It is required that a structured part be selected as parent before this command.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.data_partbuild.create_iblank()'''
        return self._session.cmd(cmd)

    def data_type(self, p0: str) -> int:
        """For those formats that contain both structured and unstructured data (EnSight6, EnSight Gold, and some user defined formats), this command indicates which type to create.
        
        Args:
            p0:
                'type'
        
                * unstructured
                * structured
        
        Examples:
            ::
        
                ensight.data_partbuild.begin()
                # 
                # Doing an unstructured ensight part 
                # 
                ensight.data_partbuild.data_type("unstructured")
                # 
                # Selecting the first part in the 
                # unstructured part building list 
                # 
                ensight.data_partbuild.select_begin(1)
                # 
                # Naming it "my_unstructured_part" 
                # and creating it 
                # 
                ensight.data_partbuild.description("my_unstructured_part")
                ensight.data_partbuild.create()
                # 
                # Now doing a structured ensight part 
                # 
                ensight.data_partbuild.data_type("structured")
                # 
                # Selecting the first part in the 
                # structured part building list 
                # (Note this is not the same part as the 
                # unstructured one selected above) 
                # 
                ensight.data_partbuild.select_begin(1)
                # 
                # Setting ijk ranges, step_by, delta values, etc. 
                # and creating it. 
                # 
                ensight.data_partbuild.domain("all")
                ensight.data_partbuild.noderange_i(1,3)
                ensight.data_partbuild.noderange_j(1,3)
                ensight.data_partbuild.noderange_k(1,3)
                ensight.data_partbuild.nodestep(1,1,1)
                ensight.data_partbuild.nodedelta(0,0,0)
                ensight.data_partbuild.description("my_structured_part")
                ensight.data_partbuild.create()
                ensight.data_partbuild.end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.data_partbuild.data_type({repr(p0)})'''
        return self._session.cmd(cmd)

    def description(self, p0: str) -> int:
        """Specifies the textual description for a part.
        
        Args:
            p0:
                'desc' description for the part (it is what is displayed in the user interface)
        
        Examples:
            ::
        
                ensight.data_partbuild.begin()
                # 
                # Doing an unstructured ensight part 
                # 
                ensight.data_partbuild.data_type("unstructured")
                # 
                # Selecting the first part in the 
                # unstructured part building list 
                # 
                ensight.data_partbuild.select_begin(1)
                # 
                # Naming it "my_unstructured_part" 
                # and creating it 
                # 
                ensight.data_partbuild.description("my_unstructured_part")
                ensight.data_partbuild.create()
                # 
                # Now doing a structured ensight part 
                # 
                ensight.data_partbuild.data_type("structured")
                # 
                # Selecting the first part in the 
                # structured part building list 
                # (Note this is not the same part as the 
                # unstructured one selected above) 
                # 
                ensight.data_partbuild.select_begin(1)
                # 
                # Setting ijk ranges, step_by, delta values, etc. 
                # and creating it. 
                # 
                ensight.data_partbuild.domain("all")
                ensight.data_partbuild.noderange_i(1,3)
                ensight.data_partbuild.noderange_j(1,3)
                ensight.data_partbuild.noderange_k(1,3)
                ensight.data_partbuild.nodestep(1,1,1)
                ensight.data_partbuild.nodedelta(0,0,0)
                ensight.data_partbuild.description("my_structured_part")
                ensight.data_partbuild.create()
                ensight.data_partbuild.end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.data_partbuild.description({repr(p0)})'''
        return self._session.cmd(cmd)

    def domain(self, p0: str) -> int:
        """Specify the iblanking domain to use for EnSight6, EnSight Gold and User-defined models that have structured iblanked data.
        
        Args:
            p0:
                'option'
        
                * inside
                * outside
                * all
        
        Examples:
            ::
        
                ensight.data_partbuild.begin()
                # 
                # Now doing a structured ensight part 
                # 
                ensight.data_partbuild.data_type("structured")
                # 
                # Selecting the first part in the 
                # structured part building list 
                # 
                ensight.data_partbuild.select_begin(1)
                # 
                # Setting ijk ranges, step_by, delta values, etc. 
                # and creating it. Note the domain used. 
                # 
                ensight.data_partbuild.domain("inside")
                ensight.data_partbuild.noderange_i(1,3)
                ensight.data_partbuild.noderange_j(1,3)
                ensight.data_partbuild.noderange_k(1,3)
                ensight.data_partbuild.nodestep(1,1,1)
                ensight.data_partbuild.nodedelta(0,0,0)
                ensight.data_partbuild.description("my_inside_part")
                ensight.data_partbuild.create()
                ensight.data_partbuild.end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.data_partbuild.domain({repr(p0)})'''
        return self._session.cmd(cmd)

    def end(self) -> int:
        """Delineates commands issued while using the Data Part Builder dialogs.
        
        | These commands exist for memory management reasons. While doing part building it is often necessary to have information in memory that will only be used during the part building process. Thus, the begin indicates the need for this memory, and the end indicates that such memory could be freed for other purposes.  All data formats that use the Data Part Builder method use this command (n3s, estet, mpgs4, plot3d, userd, ensight formats, etc).
        
        Args:
            p0:
                'commands' valid command language for part building (can be one or many)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.data_partbuild.end()'''
        return self._session.cmd(cmd)

    def group(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.data_partbuild.group({repr(p0)})'''
        return self._session.cmd(cmd)

    def iblank_type(self, p0: str) -> int:
        """Selects the iblanking type to use when creating unstructured parts from the iblanking of structured parts. 
        
        | All data formats that have structured iblanking use this command (estet, plot3d, EnSight6, EnSight Gold, some userd formats, etc). This process requires that a structured part be selected as parent.
        
        Args:
            p0:
                'desc' description for the iblanking type that is provided to the part building process. (varies for each data format)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.data_partbuild.iblank_type({repr(p0)})'''
        return self._session.cmd(cmd)

    def mpgsload(self, p0: str) -> int:
        """Specifies the option to use when reading an mpgs data file.  All parts will be read.  This option controls which parts will be loaded to the client..
        
        Args:
            p0:
                'option'
        
                * all_parts
                * part1_only
                * all_but_part1
                * no_parts
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.data_partbuild.mpgsload({repr(p0)})'''
        return self._session.cmd(cmd)

    def nodedelta(self, p0: float, p1: float, p2: float) -> int:
        """Specify ijk delta value to use when creating more than one ijk surface from the same ijk block. Only one of the deltas may be non-zero.
        
        | This command is used for EnSight6, EnSight Gold, and User-Defined data formats.
        
        Args:
            p0:
                'i_del' I, J, K direction delta values
            p1:
                'j_del' I, J, K direction delta values
            p2:
                'k_del' I, J, K direction delta values
        
        Examples:
            ::
        
                ensight.data_partbuild.begin()
                # 
                # Now doing a structured ensight part 
                # 
                ensight.data_partbuild.data_type("structured")
                # 
                # Selecting the first part in the 
                # structured part building list 
                # 
                ensight.data_partbuild.select_begin(1)
                # 
                # Setting ijk ranges, step_by, delta values, etc. 
                # and creating it. Note the nodedelta and noderange 
                # combination used 
                # 
                ensight.data_partbuild.domain("inside")
                ensight.data_partbuild.noderange_i(1,30)
                ensight.data_partbuild.noderange_j(1,1)
                ensight.data_partbuild.noderange_k(1,30)
                ensight.data_partbuild.nodestep(1,1,1)
                ensight.data_partbuild.nodedelta(0,3,0)
                ensight.data_partbuild.description("multi_jslice_part")
                ensight.data_partbuild.create()
                ensight.data_partbuild.end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.data_partbuild.nodedelta({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def noderange_i(self, p0: float, p1: float) -> int:
        """Specify i, j, or k range values to use when creating a part.
        
        | This command is used for EnSight6, EnSight Gold, and User-Defined data formats.
        
        Args:
            p0:
                'beg' I, J, or K range beginning node plane
            p1:
                'end' I, J, or K range ending node plane
        
        Examples:
            ::
        
                ensight.data_partbuild.begin()
                # 
                # Now doing a structured ensight part 
                # 
                ensight.data_partbuild.data_type("structured")
                # 
                # Selecting the first part in the 
                # structured part building list 
                # 
                ensight.data_partbuild.select_begin(1)
                # 
                # Setting ijk ranges, step_by, delta values, etc. 
                # and creating it. Note the nodedelta and noderange 
                # combination used 
                # 
                ensight.data_partbuild.domain("inside")
                ensight.data_partbuild.noderange_i(1,30)
                ensight.data_partbuild.noderange_j(1,1)
                ensight.data_partbuild.noderange_k(1,30)
                ensight.data_partbuild.nodestep(1,1,1)
                ensight.data_partbuild.nodedelta(0,3,0)
                ensight.data_partbuild.description("multi_jslice_part")
                ensight.data_partbuild.create()
                ensight.data_partbuild.end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.data_partbuild.noderange_i({repr(p0)},{repr(p1)})'''
        return self._session.cmd(cmd)

    def noderange_j(self, p0: float, p1: float) -> int:
        """Specify i, j, or k range values to use when creating a part.
        
        | This command is used for EnSight6, EnSight Gold, and User-Defined data formats.
        
        Args:
            p0:
                'beg' I, J, or K range beginning node plane
            p1:
                'end' I, J, or K range ending node plane
        
        Examples:
            ::
        
                ensight.data_partbuild.begin()
                # 
                # Now doing a structured ensight part 
                # 
                ensight.data_partbuild.data_type("structured")
                # 
                # Selecting the first part in the 
                # structured part building list 
                # 
                ensight.data_partbuild.select_begin(1)
                # 
                # Setting ijk ranges, step_by, delta values, etc. 
                # and creating it. Note the nodedelta and noderange 
                # combination used 
                # 
                ensight.data_partbuild.domain("inside")
                ensight.data_partbuild.noderange_i(1,30)
                ensight.data_partbuild.noderange_j(1,1)
                ensight.data_partbuild.noderange_k(1,30)
                ensight.data_partbuild.nodestep(1,1,1)
                ensight.data_partbuild.nodedelta(0,3,0)
                ensight.data_partbuild.description("multi_jslice_part")
                ensight.data_partbuild.create()
                ensight.data_partbuild.end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.data_partbuild.noderange_j({repr(p0)},{repr(p1)})'''
        return self._session.cmd(cmd)

    def noderange_k(self, p0: float, p1: float) -> int:
        """Specify i, j, or k range values to use when creating a part.
        
        | This command is used for EnSight6, EnSight Gold, and User-Defined data formats.
        
        Args:
            p0:
                'beg' I, J, or K range beginning node plane
            p1:
                'end' I, J, or K range ending node plane
        
        Examples:
            ::
        
                ensight.data_partbuild.begin()
                # 
                # Now doing a structured ensight part 
                # 
                ensight.data_partbuild.data_type("structured")
                # 
                # Selecting the first part in the 
                # structured part building list 
                # 
                ensight.data_partbuild.select_begin(1)
                # 
                # Setting ijk ranges, step_by, delta values, etc. 
                # and creating it. Note the nodedelta and noderange 
                # combination used 
                # 
                ensight.data_partbuild.domain("inside")
                ensight.data_partbuild.noderange_i(1,30)
                ensight.data_partbuild.noderange_j(1,1)
                ensight.data_partbuild.noderange_k(1,30)
                ensight.data_partbuild.nodestep(1,1,1)
                ensight.data_partbuild.nodedelta(0,3,0)
                ensight.data_partbuild.description("multi_jslice_part")
                ensight.data_partbuild.create()
                ensight.data_partbuild.end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.data_partbuild.noderange_k({repr(p0)},{repr(p1)})'''
        return self._session.cmd(cmd)

    def nodestep(self, p0: float, p1: float, p2: float) -> int:
        """Specify i, j, k step-by values to use in creating a structured part. Values greater than 1 will cause original cells to be combined appropriately into larger elements - producing a coarser grid. 
        
        | This command is used for EnSight6, EnSight Gold, and User-Defined data formats. This is used when a coarser approximation of the original data is desired. Typically this reduction in the apparent resolution of the model is desired in order to be able to reasonably display very large models.
        
        Args:
            p0:
                'i_step' step-by value for the I, J, K directions
            p1:
                'j_step' step-by value for the I, J, K directions
            p2:
                'k_step' step-by value for the I, J, K directions
        
        Examples:
            ::
        
                # 
                # This example causes the i and j directions to have cells 
                # that are made up of 4 original cells each. However, in 
                # the k direction, the original thickness is retained. 
                # 
                ensight.data_partbuild.begin()
                ensight.data_partbuild.domain("all")
                ensight.data_partbuild.description("coarse_in_ij_part")
                ensight.data_partbuild.noderange_i(1,39)
                ensight.data_partbuild.noderange_j(1,15)
                ensight.data_partbuild.noderange_k(1,28)
                ensight.data_partbuild.nodestep(2,2,1)
                ensight.data_partbuild.nodedelta(0,0,0)
                ensight.data_partbuild.create()
                ensight.data_partbuild.end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.data_partbuild.nodestep({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def plot3d_version(self, p0: float) -> int:
        """Data_partbuild: plot3d_version

        """
        cmd = f'''ensight.data_partbuild.plot3d_version({repr(p0)})'''
        return self._session.cmd(cmd)

    def plot3ddelta(self, p0: float, p1: float, p2: float) -> int:
        """Data_partbuild: plot3ddelta

        """
        cmd = f'''ensight.data_partbuild.plot3ddelta({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def plot3ddomain(self, p0: str) -> int:
        """Data_partbuild: plot3ddomain

        """
        cmd = f'''ensight.data_partbuild.plot3ddomain({repr(p0)})'''
        return self._session.cmd(cmd)

    def plot3dnoderange_i(self, p0: float, p1: float) -> int:
        """Data_partbuild: plot3dnoderange_i

        """
        cmd = f'''ensight.data_partbuild.plot3dnoderange_i({repr(p0)},{repr(p1)})'''
        return self._session.cmd(cmd)

    def plot3dnoderange_j(self, p0: float, p1: float) -> int:
        """Data_partbuild: plot3dnoderange_j

        """
        cmd = f'''ensight.data_partbuild.plot3dnoderange_j({repr(p0)},{repr(p1)})'''
        return self._session.cmd(cmd)

    def plot3dnoderange_k(self, p0: float, p1: float) -> int:
        """Data_partbuild: plot3dnoderange_k

        """
        cmd = f'''ensight.data_partbuild.plot3dnoderange_k({repr(p0)},{repr(p1)})'''
        return self._session.cmd(cmd)

    def plot3dselect_zone_begin(self, *args, **kwargs) -> Any:
        """Data_partbuild: plot3dselect_zone_begin

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.data_partbuild.plot3dselect_zone_begin({arg_string})"
        return self._session.cmd(cmd)

    def plot3dstep(self, p0: float, p1: float, p2: float) -> int:
        """Data_partbuild: plot3dstep

        """
        cmd = f'''ensight.data_partbuild.plot3dstep({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def select_all(self) -> int:
        """Select all parts, from the part build lists, to use in the part build process.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.data_partbuild.select_all()'''
        return self._session.cmd(cmd)

    def select_begin(self, *args, **kwargs) -> Any:
        """Specify parts, from the part build lists, to use in the part build process.
        
        | These commands are used by all iblanked structured formats when doing create_iblank process. They are also used by EnSight6, EnSight Gold, and User-Defined formats when selecting parent parts.
        
        Args:
            p0:
                'partN' number of the part in the list of available parts in the model data file(s)
        
        Examples:
            ::
        
                ensight.data_partbuild.begin()
                # 
                # Doing a structured ensight part 
                # 
                ensight.data_partbuild.data_type("structured")
                # 
                # Selecting the first part in the 
                # structured part building list 
                # 
                ensight.data_partbuild.select_begin(1)
                # 
                # Setting ijk ranges, step_by, delta values, etc. 
                # and creating it. 
                # 
                ensight.data_partbuild.domain("inside")
                ensight.data_partbuild.noderange_i(1,3)
                ensight.data_partbuild.noderange_j(1,3)
                ensight.data_partbuild.noderange_k(1,3)
                ensight.data_partbuild.nodestep(1,1,1)
                ensight.data_partbuild.nodedelta(0,0,0)
                ensight.data_partbuild.description("my_inside_part")
                ensight.data_partbuild.create()
                ensight.data_partbuild.end()
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.data_partbuild.select_begin({arg_string})"
        return self._session.cmd(cmd)

    def select_byexpr_begin(self, args: Any) -> int:
        """Specify parts using an exprepresson, from the part build lists .
        
        | This command is never written out automatically to a command file.  This command can only be added to a command file manually by editing it.
        | The string must be enclosed by quotes.
        | There can be more than one per line separated by spaces.
        | The total line limit is based on normal maximum command size.
        
        Args:
            p0:
                'desc' A quoted string with optional asterisk(s) used to match partnames
        
        Examples:
            ::
        
                # Read all parts with an 'e' in their name
                # as well as parts starting with 'f'
                # 
                ensight.data_partbuild.select_byexpr_begin("*e*","f*")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.data_partbuild.select_byexpr_begin({repr(args)})'''
        return self._session.cmd(cmd)

    def select_byexpr_end(self) -> int:
        """Specify parts using an exprepresson, from the part build lists .
        
        | This command is never written out automatically to a command file.  This command can only be added to a command file manually by editing it.
        | The string must be enclosed by quotes.
        | There can be more than one per line separated by spaces.
        | The total line limit is based on normal maximum command size.
        
        Args:
            p0:
                'desc' A quoted string with optional asterisk(s) used to match partnames
        
        Examples:
            ::
        
                # Read all parts with an 'e' in their name
                # as well as parts starting with 'f'
                # 
                ensight.data_partbuild.select_byexpr_begin("*e*","f*")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.data_partbuild.select_byexpr_end()'''
        return self._session.cmd(cmd)

    def select_byname_begin(self, *args, **kwargs) -> Any:
        """Specify parts using an exprepresson, from the part build lists .
        
        | This command is never written out automatically to a command file.  This command can only be added to a command file manually by editing it.
        | The string must be enclosed by quotes.
        | There can be more than one per line separated by spaces.
        | The total line limit is based on normal maximum command size.
        
        Args:
            p0:
                'desc' A quoted string used to exactly match partnames
        
        Examples:
            ::
        
                # Read two parts exactly matching names below
                # 
                ensight.data_partbuild.select_byname_begin("left square","right square")
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.data_partbuild.select_byname_begin({arg_string})"
        return self._session.cmd(cmd)

    def select_byname_end(self) -> int:
        """Specify parts using an exprepresson, from the part build lists .
        
        | This command is never written out automatically to a command file.  This command can only be added to a command file manually by editing it.
        | The string must be enclosed by quotes.
        | There can be more than one per line separated by spaces.
        | The total line limit is based on normal maximum command size.
        
        Args:
            p0:
                'desc' A quoted string used to exactly match partnames
        
        Examples:
            ::
        
                # Read two parts exactly matching names below
                # 
                ensight.data_partbuild.select_byname_begin("left square","right square")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.data_partbuild.select_byname_end()'''
        return self._session.cmd(cmd)


class data:
    """Class wrapper for EnSight data module

    This class acts as a proxy for the EnSight Python module ensight.data
    """
    def __init__(self, session: Session):
        self._session = session

    def add(self, p0: str) -> int:
        """Adds a new case and reads the given filename via the extension-to-reader mapping file (ensight_reader_extension.map).
        
        Args:
            p0:
                'filename' file name of the first file as mapped in the extension-to-reader mapping file.
        
        Examples:
            ::
        
                ensight.data.add("/home/users/joe/project1/crash.geo")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.data.add({repr(p0)})'''
        return self._session.cmd(cmd)

    def binary_files_are(self, p0: str) -> int:
        """Sets the byte (endian) order for binary geometry, result, and measured data files.
        
        | EnSight assumes that the geometry, result, and measured data files are of the same byte order.
        | Must be specified before a "data: read" command.
        
        Args:
            p0:
                'endian_order'
        
                * The endian order for the binary files and must be one of:
                * little_endian
                * big_endian
                * native
        
        Examples:
            ::
        
                ensight.sendmesgoptions(version="8.20")
                ensight.data.binary_files_are("big_endian")
                ensight.data.format("ensight")
                ensight.data.path("/usr/tmp")
                ensight.data.geometry("ski_c.geo")
                ensight.data.result("ski_c.res")
                ensight.data.read()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.data.binary_files_are({repr(p0)})'''
        return self._session.cmd(cmd)

    def boundary(self, p0: str) -> int:
        """Specify the name for the boundary file.  Boundary files provide a way to externally specify the ijk extents of bounding surfaces, etc. for structured data.  The resultant is an unstructured part.
        
        | The filename is concatenated with the path defined via the "data: path" command.
        | Since the boundary file depends on the structured block/zone definitions in the geometry file, the use of a boundary file requires the specification of a geometry file with structured data as well. For EnSight case format, the boundary file is contained within the casefile and this command is not needed.  It must be used for other structured data formats - such as PLOT3D.
        | When specified, unstructured parts can be created according to the boundary file definitions in the unstructured portion of the Data Part Loader dialog.
        
        Args:
            p0:
                'filename' boundary file name
        
        Examples:
            ::
        
                ensight.data.binary_files_are("big_endian")
                ensight.data.format("plot3d")
                ensight.data.plot3diblank("OFF")
                ensight.data.plot3dmulti_zone("ON")
                ensight.data.plot3dread_as("ascii")
                ensight.data.plot3ddimension("3d")
                ensight.data.path("/usr/tmp")
                ensight.data.geometry("single.grid")
                ensight.data.boundary("single.bnd")
                ensight.data.result("single.q")
                ensight.data.read()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.data.boundary({repr(p0)})'''
        return self._session.cmd(cmd)

    def format(self, p0: str) -> int:
        """Set the format type for the geometry and result files.  (Note that for Server of Servers, the format of this line changes slightly. The term casesos is added before the format_type.)
        
        Args:
            p0:
                'format_type'
        
                * The format type which must be one of the following (or the name of a user defined reader): 
                * ensight
                * plot3d
                * fidap
                * n3s
                * estet
                * mpgs4
                * movie
                * fluent
                * ansys
                * abaqus
                * case
                * fast-unstructured
                * overflow
                * casesos
        
        Examples:
            ::
        
                #
                # Read a datafile in case format and load a part from it.
                #
                ensight.data.binary_files_are("big_endian")
                ensight.data.format("case")
                ensight.data.path("/usr/tmp")
                ensight.data.geometry("cube.case")
                ensight.data.read()
                ensight.data_partbuild.begin()
                ensight.data_partbuild.data_type("unstructured")
                ensight.data_partbuild.select_begin(1)
                ensight.data_partbuild.create()
                ensight.data_partbuild.end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.data.format({repr(p0)})'''
        return self._session.cmd(cmd)

    def geometry(self, p0: str) -> int:
        """Set the name for the file containing geometric information.
        
        | The filename is concatenated with the path defined via the "data: path" command.
        | The meaning of "geometry" is different depending on the data format.  For example, if the format is CASE, the "geometry" file is the case file, while if the format is ANSYS, the file refers to the ANSYS result file.
        
        Args:
            p0:
                'filename' geometry file name
        
        Examples:
            ::
        
                ensight.data.binary_files_are("big_endian")
                ensight.data.format("case")
                ensight.data.geometry("cube.case")
                ensight.data.read()
                ensight.data_partbuild.begin()
                ensight.data_partbuild.data_type("unstructured")
                ensight.data_partbuild.select_begin(1)
                ensight.data_partbuild.create()
                ensight.data_partbuild.end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.data.geometry({repr(p0)})'''
        return self._session.cmd(cmd)

    def mcfile_begin(self, args: Any) -> int:
        """Data: mcfile_begin

        """
        cmd = f'''ensight.data.mcfile_begin({repr(args)})'''
        return self._session.cmd(cmd)

    def mcfile_end(self) -> int:
        """Data: mcfile_end

        """
        cmd = f'''ensight.data.mcfile_end()'''
        return self._session.cmd(cmd)

    def mcfile_generate(self, p0: str) -> int:
        """Data: mcfile_generate

        """
        cmd = f'''ensight.data.mcfile_generate({repr(p0)})'''
        return self._session.cmd(cmd)

    def mcfile_name(self, p0: str) -> int:
        """Data: mcfile_name

        """
        cmd = f'''ensight.data.mcfile_name({repr(p0)})'''
        return self._session.cmd(cmd)

    def measured(self, p0: str) -> int:
        """Specify the name for the measured particle file.
        
        | The filename is concatenated with the path defined via the "data: path" command.
        | It is not possible to read a measured file without also specifying a geometry file, or having specified a geometry file previously. 
        | When specified, the part containing the measured particle data will be generated upon a "data: read" command, i.e., this part type will not be shown in the various part loaders.
        
        Args:
            p0:
                'filename' measured file name
        
        Examples:
            ::
        
                # Read a geometry file and a measured particle file and create a part.
                ensight.data.format("ensight")
                ensight.data.path("/usr/tmp")
                ensight.data.geometry("cube.geom")
                ensight.data.measured("cube.mres")
                ensight.data.start_time(1)
                ensight.data.read()
                ensight.data_partbuild.begin()
                ensight.data_partbuild.data_type("unstructured")
                ensight.data_partbuild.select_begin(1)
                ensight.data_partbuild.create()
                ensight.data_partbuild.end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.data.measured({repr(p0)})'''
        return self._session.cmd(cmd)

    def multiple_case_read(self, p0: str) -> int:
        """Data: multiple_case_read

        """
        cmd = f'''ensight.data.multiple_case_read({repr(p0)})'''
        return self._session.cmd(cmd)

    def native_binary(self, p0: str) -> int:
        """Data: native_binary

        """
        cmd = f'''ensight.data.native_binary({repr(p0)})'''
        return self._session.cmd(cmd)

    def new_static_done(self, p0: int) -> int:
        """Informs the client that the static data files have been modified.
        
        Args:
            p0:
                'num'
        
                * 0
                * 1
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.data.new_static_done({repr(p0)})'''
        return self._session.cmd(cmd)

    def new_static_ready(self) -> int:
        """Informs the client that the static data files are about to be modified.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.data.new_static_ready()'''
        return self._session.cmd(cmd)

    def new_time(self, p0: float) -> int:
        """Informs client that a new transient time step is available
        
        | Each time the command is called, its value must be increasing.
        
        Args:
            p0:
                'time' simulation time
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.data.new_time({repr(p0)})'''
        return self._session.cmd(cmd)

    def new_transient_time(self, p0: float) -> int:
        """Informs client of last transient time step available
        
        | Each time the command is called, its value must be increasing.
        
        Args:
            p0:
                'time' simulation time
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.data.new_transient_time({repr(p0)})'''
        return self._session.cmd(cmd)

    def newviewport_on_add(self, p0: str) -> int:
        """Data: newviewport_on_add

        """
        cmd = f'''ensight.data.newviewport_on_add({repr(p0)})'''
        return self._session.cmd(cmd)

    def path(self, p0: str) -> int:
        """Specify the directory under which the data files are located.
        
        | The path can be fully or partially qualified.  All (geometry, result, and measured) file names are post concatenated with the path given to arrive at the full file name.
        
        Args:
            p0:
                'data_path' path to the data files
        
        Examples:
            ::
        
                # Read a data file located in /usr/tmp and load a part from it.
                ensight.data.binary_files_are("big_endian")
                ensight.data.format("case")
                ensight.data.path("/usr/tmp")
                ensight.data.geometry("cube.case")
                ensight.data.read()
                ensight.data_partbuild.begin()
                ensight.data_partbuild.data_type("unstructured")
                ensight.data_partbuild.select_begin(1)
                ensight.data_partbuild.create()
                ensight.data_partbuild.end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.data.path({repr(p0)})'''
        return self._session.cmd(cmd)

    def plot3ddimension(self, p0: str) -> int:
        """When the format is plot3d, specifies the dimensionality of the data.
        
        | EnSight attempts to determine the dimensionality of plot3d data, if this command is not given. 
        | It must be specified before a "data: read" command is given.
        
        Args:
            p0:
                'dimension'
        
                * The dimensionality of the data and must be one of:
                * 1d
                * 2d
                * 3d
        
        Examples:
            ::
        
                #
                # Read a 3D plot3d file and extract a part.
                #
                ensight.data.format("plot3d")
                ensight.data.plot3diblank("OFF")
                ensight.data.plot3dmulti_zone("OFF")
                ensight.data.plot3dread_as("c_binary")
                ensight.data.plot3ddimension("3d")
                ensight.data.path("/usr/tmp")
                ensight.data.geometry("shuttle.xyz")
                ensight.data.result("shuttle.q")
                ensight.data.read()
                ensight.data_partbuild.begin()
                ensight.data_partbuild.data_type("structured")
                ensight.data_partbuild.select_begin(1)
                ensight.data_partbuild.domain("all")
                ensight.data_partbuild.noderange_i(1,52)
                ensight.data_partbuild.noderange_j(1,63)
                ensight.data_partbuild.noderange_k(1,1)
                ensight.data_partbuild.nodestep(1,1,1)
                ensight.data_partbuild.nodedelta(0,0,0)
                ensight.data_partbuild.create()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.data.plot3ddimension({repr(p0)})'''
        return self._session.cmd(cmd)

    def plot3diblank(self, p0: str) -> int:
        """When the format is plot3d, specifies the iblanking value for the geometry file.
        
        | Must be specified before a "data: read" command is given.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                #
                # Read a plot3d file with no iblanking and extract a part.
                #
                ensight.data.format("plot3d")
                ensight.data.plot3diblank("OFF")
                ensight.data.plot3dmulti_zone("OFF")
                ensight.data.plot3dread_as("c_binary")
                ensight.data.plot3ddimension("3d")
                ensight.data.path("/usr/tmp")
                ensight.data.geometry("shuttle.xyz")
                ensight.data.result("shuttle.q")
                ensight.data.read()
                ensight.data_partbuild.begin()
                ensight.data_partbuild.data_type("structured")
                ensight.data_partbuild.select_begin(1)
                ensight.data_partbuild.domain("all")
                ensight.data_partbuild.noderange_i(1,52)
                ensight.data_partbuild.noderange_j(1,63)
                ensight.data_partbuild.noderange_k(1,1)
                ensight.data_partbuild.nodestep(1,1,1)
                ensight.data_partbuild.nodedelta(0,0,0)
                ensight.data_partbuild.create()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.data.plot3diblank({repr(p0)})'''
        return self._session.cmd(cmd)

    def plot3dmulti_zone(self, p0: str) -> int:
        """When the format is plot3d, specifies that the file is single or multi zone.
        
        | EnSight will attempt to determine if the file is single or multi-zone if this command is not specified. 
        | Must be specified before a "data: read" command is given.
        
        Args:
            p0:
                'toggle'
        
                * ON 
                * OFF
        
        Examples:
            ::
        
                #
                # Read a single zone plot3d file and extract a part.
                #
                ensight.data.format("plot3d")
                ensight.data.plot3diblank("OFF")
                ensight.data.plot3dmulti_zone("OFF")
                ensight.data.plot3dread_as("c_binary")
                ensight.data.plot3ddimension("3d")
                ensight.data.path("/usr/tmp")
                ensight.data.geometry("shuttle.xyz")
                ensight.data.result("shuttle.q")
                ensight.data.read()
                ensight.data_partbuild.begin()
                ensight.data_partbuild.data_type("structured")
                ensight.data_partbuild.select_begin(1)
                ensight.data_partbuild.domain("all")
                ensight.data_partbuild.noderange_i(1,52)
                ensight.data_partbuild.noderange_j(1,63)
                ensight.data_partbuild.noderange_k(1,1)
                ensight.data_partbuild.nodestep(1,1,1)
                ensight.data_partbuild.nodedelta(0,0,0)
                ensight.data_partbuild.create()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.data.plot3dmulti_zone({repr(p0)})'''
        return self._session.cmd(cmd)

    def plot3dread_as(self, p0: str) -> int:
        """When the format is plot3d, specifies how the file is formatted.
        
        | If the user does not specify, EnSight will attempt to determine the binary nature of the data files. 
        | It must be specified before a "data: read" command is given. 
        | All files (geometry, result, and measured) must be of the same binary nature.
        
        Args:
            p0:
                'binary_flag'
        
                * The format flag which must be on of:
                * ascii
                * c_binary
                * fortran_binary
        
        Examples:
            ::
        
                #
                # Read a c binary plot3d file and extract a part.
                #
                ensight.data.format("plot3d")
                ensight.data.plot3diblank("OFF")
                ensight.data.plot3dmulti_zone("OFF")
                ensight.data.plot3dread_as("c_binary")
                ensight.data.plot3ddimension("3d")
                ensight.data.path("/usr/tmp")
                ensight.data.geometry("shuttle.xyz")
                ensight.data.result("shuttle.q")
                ensight.data.read()
                ensight.data_partbuild.begin()
                ensight.data_partbuild.data_type("structured")
                ensight.data_partbuild.select_begin(1)
                ensight.data_partbuild.domain("all")
                ensight.data_partbuild.noderange_i(1,52)
                ensight.data_partbuild.noderange_j(1,63)
                ensight.data_partbuild.noderange_k(1,1)
                ensight.data_partbuild.nodestep(1,1,1)
                ensight.data_partbuild.nodedelta(0,0,0)
                ensight.data_partbuild.create()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.data.plot3dread_as({repr(p0)})'''
        return self._session.cmd(cmd)

    def read(self) -> int:
        """Read the geometry, result, and/or measured data files.
        
        | The geometry and/or result and/or measured data file names must be set before making this call.
        
        Examples:
            ::
        
                #
                # Read a geometry and associated result file and create a part.
                #
                ensight.data.format("ensight")
                ensight.data.path("/usr/tmp")
                ensight.data.geometry("cube.geom")
                ensight.data.result("cube.res")
                ensight.data.read()
                ensight.data_partbuild.begin()
                ensight.data_partbuild.data_type("unstructured")
                ensight.data_partbuild.select_begin(1)
                ensight.data_partbuild.create()
                ensight.data_partbuild.end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.data.read()'''
        return self._session.cmd(cmd)

    def read_all(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.data.read_all()'''
        return self._session.cmd(cmd)

    def read_gui(self) -> int:
        """Data: read_gui

        """
        cmd = f'''ensight.data.read_gui()'''
        return self._session.cmd(cmd)

    def reader_option(self, p0: str) -> int:
        """Set user defined reader (UDR) optional flag.  The availability of the options depends on the user defined reader.
        
        | Available only for user defined readers, and then only for those readers that define one or more options.
        
        Args:
            p0:
                'option' Name of the option and any data that describes the option state
        
        Examples:
            ::
        
                ensight.data.format("LS-DYNA3D_2.04")
                ensight.data.reader_option("'Enable Failed Elems' ON")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.data.reader_option({repr(p0)})'''
        return self._session.cmd(cmd)

    def replace(self, p0: str) -> int:
        """Replaces the current case and reads the given filename via the extension-to-reader mapping file (ensight_reader_extension.map).
        
        Args:
            p0:
                'filename' file name of the first file as mapped in the extension-to-reader mapping file.
        
        Examples:
            ::
        
                ensight.data.replace("/home/users/joe/project2/frame.case")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.data.replace({repr(p0)})'''
        return self._session.cmd(cmd)

    def resource(self, p0: str) -> int:
        """Sets the resource file name that will be passed to the EnSigtht SOS for reading and processing.
        
        Args:
            p0:
                'pathname' resource file name.
        
        Examples:
            ::
        
                ensight.data.binary_files_are("big_endian")
                ensight.data.format("case")
                ensight.data.shift_time(1.000000,0.000000,0.000000)
                ensight.data.resource("/usr/tmp/localhost.res")
                ensight.data.sos_pass_wildcards("YES")
                ensight.data.sos_auto_distrib("dont")
                ensight.data.replace("/usr/local/CEI/ensight92/data/ami/ami.case")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.data.resource({repr(p0)})'''
        return self._session.cmd(cmd)

    def result(self, p0: str) -> int:
        """Set the name for the file containing result information.
        
        | The usage of a result file depends on the data format.  For some formats the result file is not necessary, while for others the result file either directly contains result information or may be another file containing information pointing to the various files that may exist.
        | The filename is concatenated with the path defined via the "data: path" command. 
        | It is not possible to read a result file without also specifying a geometry file, or having specified a geometry file previously.
        
        Args:
            p0:
                'filename' result file name
        
        Examples:
            ::
        
                #
                # Read a geometry and result file,
                # create a part,
                # rotate the scene,
                # and color the part by a variable
                #
                ensight.data.format("ensight")
                ensight.data.path("/usr/tmp")
                ensight.data.geometry("cube.geom")
                ensight.data.result("cube.res")
                ensight.data.read()
                ensight.data_partbuild.begin()
                ensight.data_partbuild.data_type("unstructured")
                ensight.data_partbuild.select_begin(1)
                ensight.data_partbuild.create()
                ensight.data_partbuild.end()
                ensight.view_transf.rotate(-91.339279,2.611849,0.000000)
                ensight.view_transf.rotate(18.749998,42.660221,0.000000)
                ensight.variables.activate("temperature")
                ensight.part.select_all()
                ensight.part.modify_begin()
                ensight.part.colorby_palette("temperature")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.data.result({repr(p0)})'''
        return self._session.cmd(cmd)

    def select_case_begin(self) -> int:
        """Data: select_case_begin

        """
        cmd = f'''ensight.data.select_case_begin()'''
        return self._session.cmd(cmd)

    def select_case_end(self) -> int:
        """Data: select_case_end

        """
        cmd = f'''ensight.data.select_case_end()'''
        return self._session.cmd(cmd)

    def shift_time(self, p0: float, p1: float, p2: float) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.data.shift_time({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def sos_auto_distrib(self, p0: str) -> int:
        """When using EnSight SOS data can be automatically decomposed by either the EnSight server or by User Defined Readers which implement this capability (e.g. Silo, ExodusII, CTH).  This command indicates which component will be responsible for decomposition.
        
        Args:
            p0:
                'value'
        
                * dont
                * server
                * reader
        
        Examples:
            ::
        
                ensight.data.binary_files_are("big_endian")
                ensight.data.format("case")
                ensight.data.shift_time(1.000000,0.000000,0.000000)
                ensight.data.resource("/usr/tmp/localhost.res")
                ensight.data.sos_pass_wildcards("NO")
                ensight.data.sos_auto_distrib("server")
                ensight.data.replace("/usr/tmp/decomposed_data.*.case")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.data.sos_auto_distrib({repr(p0)})'''
        return self._session.cmd(cmd)

    def sos_decompose_type(self, p0: str) -> int:
        """Data: sos_decompose_type

        """
        cmd = f'''ensight.data.sos_decompose_type({repr(p0)})'''
        return self._session.cmd(cmd)

    def sos_pass_wildcards(self, p0: int) -> int:
        """Depending upon which data format is selected for use with SOS and with EnSight resources, a file name may contain wild card symbols ('*').  If so, the SOS can enumerate all files that match the wild carding and pass one file per EnSight server; alternatively, it can pass the wild carded name on to each server where it (typically the User Defined Reader) expands wild carded name (such as with the CTH UDR).
        
        Args:
            p0:
                'toggle'
        
                * YES - pass the wild card symbol ('*') to the server for evaluation.
                * NO - don't pass the wild card symbol to the server; SOS will evaluate it.
        
        Examples:
            ::
        
                ensight.data.binary_files_are("big_endian")
                ensight.data.format("case")
                ensight.data.shift_time(1.000000,0.000000,0.000000)
                ensight.data.resource("/usr/tmp/localhost.res")
                ensight.data.sos_pass_wildcards("NO")
                ensight.data.sos_auto_distrib("server")
                ensight.data.replace("/usr/tmp/decomposed_data.*.case #")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.data.sos_pass_wildcards({repr(p0)})'''
        return self._session.cmd(cmd)

    def start_time(self, p0: int) -> int:
        """When reading transient data load the timestep indicated as the initial time step.
        
        | It is not possible to specify a fractional timestep.
        | The value specified is a step number, not a time value.
        
        Args:
            p0:
                'step_number' timestep to use for the initial data load. Values range from 1 (the first timestep) to N where N is the total number of timesteps supplied.
        
        Examples:
            ::
        
                #
                # Read a geometry file and a measured particle file
                # at the first timestep, then create a part.
                #
                ensight.data.format("ensight")
                ensight.data.path("/usr/tmp")
                ensight.data.geometry("cube.geom")
                ensight.data.measured("cube.mres")
                ensight.data.start_time(1)
                ensight.data.read()
                ensight.data_partbuild.begin()
                ensight.data_partbuild.data_type("unstructured")
                ensight.data_partbuild.select_begin(1)
                ensight.data_partbuild.create()
                ensight.data_partbuild.end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.data.start_time({repr(p0)})'''
        return self._session.cmd(cmd)


class curve:
    """Class wrapper for EnSight curve module

    This class acts as a proxy for the EnSight Python module ensight.curve
    """
    def __init__(self, session: Session):
        self._session = session

    def assign(self, *args, **kwargs) -> Any:
        """Assign a selected curve to the selected plot.
        
        | String description not needed if assigning a new curve to an existing plot.
        
        Args:
            p0:
                'option'
        
                * rescale
                * no_rescale
            p1:
                'description' description of the plotter
        
        Examples:
            ::
        
                ensight.curve.select_begin(0)
                ensight.curve.assign("rescale","Velocity","vs.","Distance","for","part",2)
                ensight.plot.select_begin(0)
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.curve.assign({arg_string})"
        return self._session.cmd(cmd)

    def assign_to_y_axis(self, p0: str) -> int:
        """Curve: assign_to_y_axis

        """
        cmd = f'''ensight.curve.assign_to_y_axis({repr(p0)})'''
        return self._session.cmd(cmd)

    def delete(self) -> int:
        """Delete the selected curve(s).
        
        Examples:
            ::
        
                ensight.curve.select_begin(0)
                ensight.curve.delete()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.curve.delete()'''
        return self._session.cmd(cmd)

    def desc(self, p0: str) -> int:
        """Specify curve description.
        
        Args:
            p0:
                'description' description of the selected curve
        
        Examples:
            ::
        
                ensight.curve.select_begin(0)
                ensight.curve.desc("Velocity vs. Distance for part 2")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.curve.desc({repr(p0)})'''
        return self._session.cmd(cmd)

    def legend_title(self, p0: str) -> int:
        """Curve: legend_title

        """
        cmd = f'''ensight.curve.legend_title({repr(p0)})'''
        return self._session.cmd(cmd)

    def line_style(self, p0: str) -> int:
        """Specifies the line style to use for the selected curves.
        
        | Only works when line_type is connect_dots.
        
        Args:
            p0:
                'option'
        
                * solid
                * dotted
                * dash
        
        Examples:
            ::
        
                ensight.curve.select_begin(1)
                ensight.curve.line_type("connect_dots")
                ensight.curve.line_style("dotted")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.curve.line_style({repr(p0)})'''
        return self._session.cmd(cmd)

    def line_type(self, p0: str) -> int:
        """Specifies the line type to use for the selected curves.
        
        Args:
            p0:
                'option'
        
                * none
                * connect_dots
                * smooth
        
        Examples:
            ::
        
                ensight.curve.select_begin(1)
                ensight.curve.line_type("none")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.curve.line_type({repr(p0)})'''
        return self._session.cmd(cmd)

    def line_width(self, p0: int) -> int:
        """Specify the (pixel) line width of the selected curve(s).
        
        Args:
            p0:
                'width' pixel line width of 1, 2 (default), 3, or 4.
        
        Examples:
            ::
        
                ensight.curve.select_begin(1)
                ensight.curve.line_width(3)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.curve.line_width({repr(p0)})'''
        return self._session.cmd(cmd)

    def load(self, p0: str) -> int:
        """Load the specified (saved) curve file.
        
        | See the curve file formats under "curve: save". 
        
        Args:
            p0:
                'filename' file (path and) name of the saved curve file
        
        Examples:
            ::
        
                ensight.curve.select_begin(2)
                ensight.curve.load("Curve0")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.curve.load({repr(p0)})'''
        return self._session.cmd(cmd)

    def marker(self, p0: str) -> int:
        """Specify the type of marker in which to represent the points of the selected curve(s).
        
        Args:
            p0:
                'option'
        
                * none
                * dot
                * circle
                * triangle
                * square
        
        Examples:
            ::
        
                ensight.curve.select_begin(0,1)
                ensight.curve.marker("circle")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.curve.marker({repr(p0)})'''
        return self._session.cmd(cmd)

    def marker_scale(self, p0: float) -> int:
        """Specify the size of the marker type which represents the points of the selected curve(s).
        
        Args:
            p0:
                'size' size of the curve point markers (default = 1.)
        
        Examples:
            ::
        
                ensight.curve.select_begin(0,1)
                ensight.curve.marker_scale(2.0000e+00)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.curve.marker_scale({repr(p0)})'''
        return self._session.cmd(cmd)

    def normalize_x(self, p0: str) -> int:
        """Specify whether to normalize the abscissa range of the selected curve(s) to the interval I[0.,1.].
        
        | This means to divide all abscissa coordinates of the curve by the maximum abscissa coordinate value.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.curve.select_begin(0,1)
                ensight.curve.normalize_x("ON")
                ensight.curve.normalize_y("OFF")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.curve.normalize_x({repr(p0)})'''
        return self._session.cmd(cmd)

    def normalize_y(self, p0: str) -> int:
        """Specify whether to normalize the abscissa range of the selected curve(s) to the interval I[0.,1.].
        
        | This means to divide all abscissa coordinates of the curve by the maximum abscissa coordinate value.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.curve.select_begin(0,1)
                ensight.curve.normalize_x("ON")
                ensight.curve.normalize_y("OFF")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.curve.normalize_y({repr(p0)})'''
        return self._session.cmd(cmd)

    def offset(self, p0: float, p1: float) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.curve.offset({repr(p0)},{repr(p1)})'''
        return self._session.cmd(cmd)

    def query_count(self, args: Any) -> int:
        """Curve: query_count

        """
        cmd = f'''ensight.curve.query_count({repr(args)})'''
        return self._session.cmd(cmd)

    def query_display_attributes(self, args: Any) -> int:
        """Curve: query_display_attributes

        """
        cmd = f'''ensight.curve.query_display_attributes({repr(args)})'''
        return self._session.cmd(cmd)

    def query_objects_atwindowxy(self, args: Any) -> int:
        """Curve: query_objects_atwindowxy

        """
        cmd = f'''ensight.curve.query_objects_atwindowxy({repr(args)})'''
        return self._session.cmd(cmd)

    def rgb(self, p0: float, p1: float, p2: float) -> int:
        """Specify the color of the selected curve(s) via red, green, and blue component values.
        
        Args:
            p0:
                'red_val' red, green, blue component of color (0 to 1.)
            p1:
                'grn_val' red, green, blue component of color (0 to 1.)
            p2:
                'blu_val' red, green, blue component of color (0 to 1.)
        
        Examples:
            ::
        
                #
                # Set the curve color to cyan
                #
                ensight.curve.select_begin(1)
                ensight.curve.rgb(0.0000e+00,1.0000e+00,1.0000e+00)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.curve.rgb({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def save(self, p0: str, p1: str) -> int:
        """Specify how to save the selected curve(s) data to a file.
        
        | formatted - curve data saved in the following format:
        | velocity vs. Distance for line tool
        |   Distance       Value           X             Y             Z
        |  0.00000e+00   5.56944e-01  -1.84272e+00   5.00623e-01   1.02349e+00
        |  1.16535e+00   5.06148e-01  -6.77367e-01   5.00623e-01   1.02349e+00
        |  2.33070e+00   4.33805e-02   4.87984e-01   5.00623e-01   1.02349e+00
        |  3.49605e+00   3.41879e-01   1.65334e+00   5.00623e-01   1.02349e+00
        |  4.66140e+00   5.29504e-01   2.81869e+00   5.00623e-01   1.02349e+00
        | Minimum value overall
        | At Point =  4.87984e-01  5.00623e-01  1.02349e+00, 
        | Dist. =  2.33070e+00, Value = 4.33805e-02
        | Maximum value overall
        | At Point = -1.84272e+00  5.00623e-01  1.02349e+00, 
        | Dist. =  0.00000e+00, Value = 5.56944e-01
        | xy_data   - curve data saved in the following (x,y) format for importing into a spreadsheets:
        | velocity vs. Distance for line tool
        | Distance
        | velocity
        | 1
        | 5
        | 0 0.556944
        | 1.16535 0.506148
        | 2.3307 0.0433805
        | 3.49605 0.341879
        | 4.6614 0.529504
        
        Args:
            p0:
                'type'
        
                * formatted
                * xy_data
            p1:
                'filename' name of the file in which to save the curve points
        
        Examples:
            ::
        
                ensight.curve.select_begin(0)
                ensight.curve.save("xy_data","Curve0")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.curve.save({repr(p0)},{repr(p1)})'''
        return self._session.cmd(cmd)

    def scale(self, p0: float, p1: float) -> int:
        """Scales the x and y query by the values given.
        
        | Only scales the curve visually, does not modify the query information.
        
        Args:
            p0:
                'x_scale' query x scale factor
            p1:
                'y_scale' query y scale factor
        
        Examples:
            ::
        
                ensight.curve.select_begin(1)
                ensight.curve.scale(60.0,1.)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.curve.scale({repr(p0)},{repr(p1)})'''
        return self._session.cmd(cmd)

    def select_all(self) -> int:
        """Select all curves for subsequent operations.
        
        Examples:
            ::
        
                ensight.curve.select_all()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.curve.select_all()'''
        return self._session.cmd(cmd)

    def select_begin(self, *args, **kwargs) -> Any:
        """Curve(s) selection construct for subsequent curve operation.
        
        | Parameters
        | none
        | Curve ids to be selected must be specified between curve: select_begin and curve: select_end.
        
        Examples:
            ::
        
                ensight.curve.select_begin(0)
                ensight.curve.assign("rescale","Velocity","vs.","Distance","for","part",2)
                ensight.plot.select_begin(0)
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.curve.select_begin({arg_string})"
        return self._session.cmd(cmd)

    def select_default(self) -> int:
        """Specify the default curve to be selected - or unselect all curves.
        
        | This is used to set the default (unselected) curve attributes.
        
        Examples:
            ::
        
                ensight.curve.select_default()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.curve.select_default()'''
        return self._session.cmd(cmd)

    def select_lastcreated(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.curve.select_lastcreated()'''
        return self._session.cmd(cmd)

    def smooth_subpoints(self, p0: float) -> int:
        """Specify the number of smooth subpoints to use between curve points of the selected curve.
        
        | The curve line type must be smooth.
        
        Args:
            p0:
                'num' number of subpoints in which to display the smoothed line type between curve points (default is 3)
        
        Examples:
            ::
        
                ensight.curve.select_begin(1)
                ensight.curve.line_type("smooth")
                ensight.curve.smooth_subpoints(4.0000e+00)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.curve.smooth_subpoints({repr(p0)})'''
        return self._session.cmd(cmd)

    def visible(self, p0: str) -> int:
        """Toggle the selected curve(s) visibility.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.curve.select_begin(1)
                ensight.curve.visible("OFF")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.curve.visible({repr(p0)})'''
        return self._session.cmd(cmd)


class ReportServer:
    """Class wrapper for EnSight ReportServer module

    This class acts as a proxy for the EnSight Python module ensight.core.nexus.ReportServer
    """
    def __init__(self, session: Session):
        self._session = session

    def create_local_database(self, *args, **kwargs) -> Any:
        """

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportServer.create_local_database({arg_string})"
        return self._session.cmd(cmd)

    def cur_server(self, *args, **kwargs) -> Any:
        """

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportServer.cur_server({arg_string})"
        return self._session.cmd(cmd)

    def del_objects(self, *args, **kwargs) -> Any:
        """

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportServer.del_objects({arg_string})"
        return self._session.cmd(cmd)

    def get_URL(self, *args, **kwargs) -> Any:
        """

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportServer.get_URL({arg_string})"
        return self._session.cmd(cmd)

    def get_password(self, *args, **kwargs) -> Any:
        """

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportServer.get_password({arg_string})"
        return self._session.cmd(cmd)

    def get_report_URL(self, *args, **kwargs) -> Any:
        """

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportServer.get_report_URL({arg_string})"
        return self._session.cmd(cmd)

    def get_server(self, *args, **kwargs) -> Any:
        """

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportServer.get_server({arg_string})"
        return self._session.cmd(cmd)

    def get_server_name(self, *args, **kwargs) -> Any:
        """

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportServer.get_server_name({arg_string})"
        return self._session.cmd(cmd)

    def get_session_URL(self, *args, **kwargs) -> Any:
        """

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportServer.get_session_URL({arg_string})"
        return self._session.cmd(cmd)

    def get_username(self, *args, **kwargs) -> Any:
        """

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportServer.get_username({arg_string})"
        return self._session.cmd(cmd)

    def launch_local_server(self, *args, **kwargs) -> Any:
        """

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportServer.launch_local_server({arg_string})"
        return self._session.cmd(cmd)

    def put_object(self, *args, **kwargs) -> Any:
        """

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportServer.put_object({arg_string})"
        return self._session.cmd(cmd)

    def put_objects(self, *args, **kwargs) -> Any:
        """

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportServer.put_objects({arg_string})"
        return self._session.cmd(cmd)

    def set_URL(self, *args, **kwargs) -> Any:
        """

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportServer.set_URL({arg_string})"
        return self._session.cmd(cmd)

    def set_password(self, *args, **kwargs) -> Any:
        """

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportServer.set_password({arg_string})"
        return self._session.cmd(cmd)

    def set_username(self, *args, **kwargs) -> Any:
        """

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportServer.set_username({arg_string})"
        return self._session.cmd(cmd)

    def stop_local_server(self, *args, **kwargs) -> Any:
        """

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportServer.stop_local_server({arg_string})"
        return self._session.cmd(cmd)

    def valid_database(self, *args, **kwargs) -> Any:
        """

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportServer.valid_database({arg_string})"
        return self._session.cmd(cmd)

    def validate(self, *args, **kwargs) -> Any:
        """

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportServer.validate({arg_string})"
        return self._session.cmd(cmd)


class ReportItemSourceInterface:
    """Class wrapper for EnSight ReportItemSourceInterface module

    This class acts as a proxy for the EnSight Python module ensight.core.nexus.ReportItemSourceInterface
    """
    def __init__(self, session: Session):
        self._session = session

    def createItem(self, *args, **kwargs) -> Any:
        """

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportItemSourceInterface.createItem({arg_string})"
        return self._session.cmd(cmd)

    def createReportItem(self, *args, **kwargs) -> Any:
        """

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportItemSourceInterface.createReportItem({arg_string})"
        return self._session.cmd(cmd)

    def createReportTemplate(self, *args, **kwargs) -> Any:
        """

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportItemSourceInterface.createReportTemplate({arg_string})"
        return self._session.cmd(cmd)

    def cur_dataset(self, *args, **kwargs) -> Any:
        """

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportItemSourceInterface.cur_dataset({arg_string})"
        return self._session.cmd(cmd)

    def cur_session(self, *args, **kwargs) -> Any:
        """

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportItemSourceInterface.cur_session({arg_string})"
        return self._session.cmd(cmd)

    def dirtyCurrentReport(self, *args, **kwargs) -> Any:
        """

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportItemSourceInterface.dirtyCurrentReport({arg_string})"
        return self._session.cmd(cmd)

    def dirtySessionDataset(self, *args, **kwargs) -> Any:
        """

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportItemSourceInterface.dirtySessionDataset({arg_string})"
        return self._session.cmd(cmd)

    def getDataset(self, *args, **kwargs) -> Any:
        """

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportItemSourceInterface.getDataset({arg_string})"
        return self._session.cmd(cmd)

    def getIcon(self, *args, **kwargs) -> Any:
        """

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportItemSourceInterface.getIcon({arg_string})"
        return self._session.cmd(cmd)

    def getIconData(self, *args, **kwargs) -> Any:
        """

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportItemSourceInterface.getIconData({arg_string})"
        return self._session.cmd(cmd)

    def getReportItemSequenceNumber(self, *args, **kwargs) -> Any:
        """

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportItemSourceInterface.getReportItemSequenceNumber({arg_string})"
        return self._session.cmd(cmd)

    def getSession(self, *args, **kwargs) -> Any:
        """

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportItemSourceInterface.getSession({arg_string})"
        return self._session.cmd(cmd)

    def getSourceParamEditWidget(self, *args, **kwargs) -> Any:
        """

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportItemSourceInterface.getSourceParamEditWidget({arg_string})"
        return self._session.cmd(cmd)

    def get_guid(self, *args, **kwargs) -> Any:
        """

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportItemSourceInterface.get_guid({arg_string})"
        return self._session.cmd(cmd)

    def get_name(self, *args, **kwargs) -> Any:
        """

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportItemSourceInterface.get_name({arg_string})"
        return self._session.cmd(cmd)

    def get_params(self, *args, **kwargs) -> Any:
        """

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportItemSourceInterface.get_params({arg_string})"
        return self._session.cmd(cmd)

    def get_parent_extension_name(self, *args, **kwargs) -> Any:
        """

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportItemSourceInterface.get_parent_extension_name({arg_string})"
        return self._session.cmd(cmd)

    def get_tags(self, *args, **kwargs) -> Any:
        """

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportItemSourceInterface.get_tags({arg_string})"
        return self._session.cmd(cmd)

    def modalUpdateSourceParams(self, *args, **kwargs) -> Any:
        """

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportItemSourceInterface.modalUpdateSourceParams({arg_string})"
        return self._session.cmd(cmd)

    def recordSourceItems(self, *args, **kwargs) -> Any:
        """

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportItemSourceInterface.recordSourceItems({arg_string})"
        return self._session.cmd(cmd)

    def recordSourceTemplate(self, *args, **kwargs) -> Any:
        """

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportItemSourceInterface.recordSourceTemplate({arg_string})"
        return self._session.cmd(cmd)

    def resetReportItemSequenceNumber(self, *args, **kwargs) -> Any:
        """

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportItemSourceInterface.resetReportItemSequenceNumber({arg_string})"
        return self._session.cmd(cmd)

    def saveItem(self, *args, **kwargs) -> Any:
        """

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportItemSourceInterface.saveItem({arg_string})"
        return self._session.cmd(cmd)

    def saveReportItems(self, *args, **kwargs) -> Any:
        """

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportItemSourceInterface.saveReportItems({arg_string})"
        return self._session.cmd(cmd)

    def saveReportTemplates(self, *args, **kwargs) -> Any:
        """

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportItemSourceInterface.saveReportTemplates({arg_string})"
        return self._session.cmd(cmd)

    def set_guid(self, *args, **kwargs) -> Any:
        """

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportItemSourceInterface.set_guid({arg_string})"
        return self._session.cmd(cmd)

    def set_name(self, *args, **kwargs) -> Any:
        """

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportItemSourceInterface.set_name({arg_string})"
        return self._session.cmd(cmd)

    def set_params(self, *args, **kwargs) -> Any:
        """

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportItemSourceInterface.set_params({arg_string})"
        return self._session.cmd(cmd)

    def set_tags(self, *args, **kwargs) -> Any:
        """

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportItemSourceInterface.set_tags({arg_string})"
        return self._session.cmd(cmd)

    def translate(self, *args, **kwargs) -> Any:
        """

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportItemSourceInterface.translate({arg_string})"
        return self._session.cmd(cmd)

    def updateSourceParams(self, *args, **kwargs) -> Any:
        """

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportItemSourceInterface.updateSourceParams({arg_string})"
        return self._session.cmd(cmd)

    def validateServer(self, *args, **kwargs) -> Any:
        """

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportItemSourceInterface.validateServer({arg_string})"
        return self._session.cmd(cmd)


class ReportItem:
    """Class wrapper for EnSight ReportItem module

    This class acts as a proxy for the EnSight Python module ensight.core.nexus.ReportItem
    """
    def __init__(self, session: Session):
        self._session = session

    def add_quotes(self, *args, **kwargs) -> Any:
        """

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportItem.add_quotes({arg_string})"
        return self._session.cmd(cmd)

    def add_tag(self, *args, **kwargs) -> Any:
        """

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportItem.add_tag({arg_string})"
        return self._session.cmd(cmd)

    def categories(self, *args, **kwargs) -> Any:
        """Set() -> new empty set object
        set(iterable) -> new set object
        
        Build an unordered collection of unique elements.

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportItem.categories({arg_string})"
        return self._session.cmd(cmd)

    def get_tags(self, *args, **kwargs) -> Any:
        """

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportItem.get_tags({arg_string})"
        return self._session.cmd(cmd)

    def get_url_data(self, *args, **kwargs) -> Any:
        """

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportItem.get_url_data({arg_string})"
        return self._session.cmd(cmd)

    def get_url_file(self, *args, **kwargs) -> Any:
        """

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportItem.get_url_file({arg_string})"
        return self._session.cmd(cmd)

    def is_file_protocol(self, *args, **kwargs) -> Any:
        """

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportItem.is_file_protocol({arg_string})"
        return self._session.cmd(cmd)

    def max_tag_length(self, *args, **kwargs) -> Any:
        """Int([x]) -> integer
        int(x, base=10) -> integer
        
        Convert a number or string to an integer, or return 0 if no arguments
        are given.  If x is a number, return x.__int__().  For floating-point
        numbers, this truncates towards zero.
        
        If x is not a number or if base is given, then x must be a string,
        bytes, or bytearray instance representing an integer literal in the
        given base.  The literal can be preceded by '+' or '-' and be surrounded
        by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
        Base 0 means to interpret the base from the string as an integer literal.
        >>> int('0b100', base=0)
        4

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportItem.max_tag_length({arg_string})"
        return self._session.cmd(cmd)

    def parse_query(self, *args, **kwargs) -> Any:
        """

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportItem.parse_query({arg_string})"
        return self._session.cmd(cmd)

    def rebuild_tags(self, *args, **kwargs) -> Any:
        """

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportItem.rebuild_tags({arg_string})"
        return self._session.cmd(cmd)

    def rem_tag(self, *args, **kwargs) -> Any:
        """

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportItem.rem_tag({arg_string})"
        return self._session.cmd(cmd)

    def set_guid(self, *args, **kwargs) -> Any:
        """

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportItem.set_guid({arg_string})"
        return self._session.cmd(cmd)

    def set_payload(self, *args, **kwargs) -> Any:
        """

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportItem.set_payload({arg_string})"
        return self._session.cmd(cmd)

    def set_payload_animation(self, *args, **kwargs) -> Any:
        """

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportItem.set_payload_animation({arg_string})"
        return self._session.cmd(cmd)

    def set_payload_file(self, *args, **kwargs) -> Any:
        """

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportItem.set_payload_file({arg_string})"
        return self._session.cmd(cmd)

    def set_payload_html(self, *args, **kwargs) -> Any:
        """

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportItem.set_payload_html({arg_string})"
        return self._session.cmd(cmd)

    def set_payload_image(self, *args, **kwargs) -> Any:
        """

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportItem.set_payload_image({arg_string})"
        return self._session.cmd(cmd)

    def set_payload_none(self, *args, **kwargs) -> Any:
        """

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportItem.set_payload_none({arg_string})"
        return self._session.cmd(cmd)

    def set_payload_scene(self, *args, **kwargs) -> Any:
        """

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportItem.set_payload_scene({arg_string})"
        return self._session.cmd(cmd)

    def set_payload_scene_capture(self, *args, **kwargs) -> Any:
        """

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportItem.set_payload_scene_capture({arg_string})"
        return self._session.cmd(cmd)

    def set_payload_string(self, *args, **kwargs) -> Any:
        """

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportItem.set_payload_string({arg_string})"
        return self._session.cmd(cmd)

    def set_payload_table(self, *args, **kwargs) -> Any:
        """

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportItem.set_payload_table({arg_string})"
        return self._session.cmd(cmd)

    def set_payload_table_values(self, *args, **kwargs) -> Any:
        """

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportItem.set_payload_table_values({arg_string})"
        return self._session.cmd(cmd)

    def set_payload_tree(self, *args, **kwargs) -> Any:
        """

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportItem.set_payload_tree({arg_string})"
        return self._session.cmd(cmd)

    def set_tags(self, *args, **kwargs) -> Any:
        """

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportItem.set_tags({arg_string})"
        return self._session.cmd(cmd)

    def type_anim(self, *args, **kwargs) -> Any:
        """Str(object='') -> str
        str(bytes_or_buffer[, encoding[, errors]]) -> str
        
        Create a new string object from the given object. If encoding or
        errors is specified, then the object must expose a data buffer
        that will be decoded using the given encoding and error handler.
        Otherwise, returns the result of object.__str__() (if defined)
        or repr(object).
        encoding defaults to sys.getdefaultencoding().
        errors defaults to 'strict'.

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportItem.type_anim({arg_string})"
        return self._session.cmd(cmd)

    def type_file(self, *args, **kwargs) -> Any:
        """Str(object='') -> str
        str(bytes_or_buffer[, encoding[, errors]]) -> str
        
        Create a new string object from the given object. If encoding or
        errors is specified, then the object must expose a data buffer
        that will be decoded using the given encoding and error handler.
        Otherwise, returns the result of object.__str__() (if defined)
        or repr(object).
        encoding defaults to sys.getdefaultencoding().
        errors defaults to 'strict'.

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportItem.type_file({arg_string})"
        return self._session.cmd(cmd)

    def type_html(self, *args, **kwargs) -> Any:
        """Str(object='') -> str
        str(bytes_or_buffer[, encoding[, errors]]) -> str
        
        Create a new string object from the given object. If encoding or
        errors is specified, then the object must expose a data buffer
        that will be decoded using the given encoding and error handler.
        Otherwise, returns the result of object.__str__() (if defined)
        or repr(object).
        encoding defaults to sys.getdefaultencoding().
        errors defaults to 'strict'.

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportItem.type_html({arg_string})"
        return self._session.cmd(cmd)

    def type_img(self, *args, **kwargs) -> Any:
        """Str(object='') -> str
        str(bytes_or_buffer[, encoding[, errors]]) -> str
        
        Create a new string object from the given object. If encoding or
        errors is specified, then the object must expose a data buffer
        that will be decoded using the given encoding and error handler.
        Otherwise, returns the result of object.__str__() (if defined)
        or repr(object).
        encoding defaults to sys.getdefaultencoding().
        errors defaults to 'strict'.

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportItem.type_img({arg_string})"
        return self._session.cmd(cmd)

    def type_none(self, *args, **kwargs) -> Any:
        """Str(object='') -> str
        str(bytes_or_buffer[, encoding[, errors]]) -> str
        
        Create a new string object from the given object. If encoding or
        errors is specified, then the object must expose a data buffer
        that will be decoded using the given encoding and error handler.
        Otherwise, returns the result of object.__str__() (if defined)
        or repr(object).
        encoding defaults to sys.getdefaultencoding().
        errors defaults to 'strict'.

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportItem.type_none({arg_string})"
        return self._session.cmd(cmd)

    def type_scn(self, *args, **kwargs) -> Any:
        """Str(object='') -> str
        str(bytes_or_buffer[, encoding[, errors]]) -> str
        
        Create a new string object from the given object. If encoding or
        errors is specified, then the object must expose a data buffer
        that will be decoded using the given encoding and error handler.
        Otherwise, returns the result of object.__str__() (if defined)
        or repr(object).
        encoding defaults to sys.getdefaultencoding().
        errors defaults to 'strict'.

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportItem.type_scn({arg_string})"
        return self._session.cmd(cmd)

    def type_str(self, *args, **kwargs) -> Any:
        """Str(object='') -> str
        str(bytes_or_buffer[, encoding[, errors]]) -> str
        
        Create a new string object from the given object. If encoding or
        errors is specified, then the object must expose a data buffer
        that will be decoded using the given encoding and error handler.
        Otherwise, returns the result of object.__str__() (if defined)
        or repr(object).
        encoding defaults to sys.getdefaultencoding().
        errors defaults to 'strict'.

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportItem.type_str({arg_string})"
        return self._session.cmd(cmd)

    def type_tbl(self, *args, **kwargs) -> Any:
        """Str(object='') -> str
        str(bytes_or_buffer[, encoding[, errors]]) -> str
        
        Create a new string object from the given object. If encoding or
        errors is specified, then the object must expose a data buffer
        that will be decoded using the given encoding and error handler.
        Otherwise, returns the result of object.__str__() (if defined)
        or repr(object).
        encoding defaults to sys.getdefaultencoding().
        errors defaults to 'strict'.

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportItem.type_tbl({arg_string})"
        return self._session.cmd(cmd)

    def type_tree(self, *args, **kwargs) -> Any:
        """Str(object='') -> str
        str(bytes_or_buffer[, encoding[, errors]]) -> str
        
        Create a new string object from the given object. If encoding or
        errors is specified, then the object must expose a data buffer
        that will be decoded using the given encoding and error handler.
        Otherwise, returns the result of object.__str__() (if defined)
        or repr(object).
        encoding defaults to sys.getdefaultencoding().
        errors defaults to 'strict'.

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportItem.type_tree({arg_string})"
        return self._session.cmd(cmd)

    def validate_table(self, *args, **kwargs) -> Any:
        """

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportItem.validate_table({arg_string})"
        return self._session.cmd(cmd)

    def validate_tree(self, *args, **kwargs) -> Any:
        """

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportItem.validate_tree({arg_string})"
        return self._session.cmd(cmd)


class ReportExtensionBaseClass:
    """Class wrapper for EnSight ReportExtensionBaseClass module

    This class acts as a proxy for the EnSight Python module ensight.core.nexus.ReportExtensionBaseClass
    """
    def __init__(self, session: Session):
        self._session = session

    def getReportItemSourceInstance(self, *args, **kwargs) -> Any:
        """

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportExtensionBaseClass.getReportItemSourceInstance({arg_string})"
        return self._session.cmd(cmd)


class ReportDataset:
    """Class wrapper for EnSight ReportDataset module

    This class acts as a proxy for the EnSight Python module ensight.core.nexus.ReportDataset
    """
    def __init__(self, session: Session):
        self._session = session

    def get_REST_object(self, *args, **kwargs) -> Any:
        """

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportDataset.get_REST_object({arg_string})"
        return self._session.cmd(cmd)

    def set_tags(self, *args, **kwargs) -> Any:
        """

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportDataset.set_tags({arg_string})"
        return self._session.cmd(cmd)

    def update(self, *args, **kwargs) -> Any:
        """

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.core.nexus.ReportDataset.update({arg_string})"
        return self._session.cmd(cmd)


class nexus:
    """Class wrapper for EnSight nexus module

    This class acts as a proxy for the EnSight Python module ensight.core.nexus

    Attributes:
        ReportDataset:
            EnSight module instance class

        ReportExtensionBaseClass:
            EnSight module instance class

        ReportItem:
            EnSight module instance class

        ReportItemSourceInterface:
            EnSight module instance class

        ReportServer:
            EnSight module instance class


    """
    def __init__(self, session: Session):
        self._session = session
        self.ReportDataset: 'ReportDataset' = ReportDataset(self._session)
        self.ReportExtensionBaseClass: 'ReportExtensionBaseClass' = ReportExtensionBaseClass(self._session)
        self.ReportItem: 'ReportItem' = ReportItem(self._session)
        self.ReportItemSourceInterface: 'ReportItemSourceInterface' = ReportItemSourceInterface(self._session)
        self.ReportServer: 'ReportServer' = ReportServer(self._session)


class core:
    """Class wrapper for EnSight core module

    This class acts as a proxy for the EnSight Python module ensight.core

    Attributes:
        nexus:
            EnSight module instance class


    """
    def __init__(self, session: Session):
        self._session = session
        self.nexus: 'nexus' = nexus(self._session)


class contour:
    """Class wrapper for EnSight contour module

    This class acts as a proxy for the EnSight Python module ensight.contour
    """
    def __init__(self, session: Session):
        self._session = session

    def add_custom_label(self, p0: float, p1: float, p2: float) -> int:
        """Contour: add_custom_label

        """
        cmd = f'''ensight.contour.add_custom_label({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def begin(self) -> int:
        """Delimit the modifications for contour attributes.
        
        Examples:
            ::
        
                ensight.part.select_begin(2)
                ensight.contour.begin()
                ensight.contour.variable("temperature")
                ensight.contour.end()
                ensight.contour.create()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.contour.begin()'''
        return self._session.cmd(cmd)

    def component(self, p0: str) -> int:
        """If contouring by a vector specifies component or magnitude.
        
        | If not specified "magnitude" is used. 
        
        Args:
            p0:
                'vector_component'
        
                * One of the following:
                * x
                * y
                * z
                * magnitude
        
        Examples:
            ::
        
                #
                # Create contours of the x-component
                # of velocity on part 2
                #
                ensight.part.select_begin(2)
                ensight.contour.begin()
                ensight.contour.variable("velocity")
                ensight.contour.component("x")
                ensight.contour.end()
                ensight.contour.create()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.contour.component({repr(p0)})'''
        return self._session.cmd(cmd)

    def create(self) -> int:
        """Create a contour part with the currently defined attributes using the currently selected parts as parent parts.
        
        | The contour part is created using the currently selected parts as the parent part.
        | The contour part is created using the currently set contour attributes.
        
        Examples:
            ::
        
                ensight.part.select_begin(2)
                ensight.contour.begin()
                ensight.contour.variable("temperature")
                ensight.contour.end()
                ensight.contour.create()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.contour.create()'''
        return self._session.cmd(cmd)

    def delete_all_custom_labels(self) -> int:
        """Contour: delete_all_custom_labels

        """
        cmd = f'''ensight.contour.delete_all_custom_labels()'''
        return self._session.cmd(cmd)

    def delete_custom_label(self, p0: float, p1: float, p2: float) -> int:
        """Contour: delete_custom_label

        """
        cmd = f'''ensight.contour.delete_custom_label({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def display_offset(self, p0: float) -> int:
        """Translate the contour geometry in the surface normal direction by <offset> units.
        
        | Useful option when displaying contour parts on top of shaded objects in order to lift the contour line objects closer to the user to properly view them.
        | Works only if the surface normals are consistent.
        | Positive values are offsets in the surface normal direction while negative values are offsets in the opposite direction.
        
        Args:
            p0:
                'offset' number of units in world coordinates to translate the contour information
        
        Examples:
            ::
        
                #
                # Create a contour part of velocity magnitude
                # displaying it offset from the surface by .01 in the
                # negative surface normal direction
                #
                ensight.part.select_begin(2)
                ensight.contour.begin()
                ensight.contour.variable("velocity")
                ensight.contour.display_offset(-.01)
                ensight.contour.end()
                ensight.contour.create()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.contour.display_offset({repr(p0)})'''
        return self._session.cmd(cmd)

    def distribution(self, p0: str) -> int:
        """Specifies the minimum and maximum contour levels when contours are not tied to the variable palette.
        
        | Only used when "contour: sync_to_palette OFF"
        
        Args:
            p0:
                'distribution'
        
                * linear
                * logarithmic
                * quadratic
        
        Examples:
            ::
        
                #
                # Create contours on part 2
                #
                ensight.part.select_begin(2)
                ensight.contour.begin()
                ensight.contour.variable("temperature")
                ensight.contour.sync_to_palette("OFF")
                #
                # create 8 contours from 0 to 4.5 using a quadratic distribution
                #
                ensight.contour.distribution("quadratic")
                ensight.contour.range(0.,4.5)
                ensight.contour.levels(8)
                # 
                # turn on labels spaced every 2 units
                # using a floating point representation with 2 decimal places
                #
                ensight.contour.label_visible("ON")
                ensight.contour.label_spacing(2.0)
                ensight.contour.label_format("floating_point")
                ensight.contour.label_decimal_places(2)
                ensight.contour.end()
                ensight.contour.create()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.contour.distribution({repr(p0)})'''
        return self._session.cmd(cmd)

    def end(self) -> int:
        """Delimit the modifications for contour attributes.
        
        Examples:
            ::
        
                ensight.part.select_begin(2)
                ensight.contour.begin()
                ensight.contour.variable("temperature")
                ensight.contour.end()
                ensight.contour.create()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.contour.end()'''
        return self._session.cmd(cmd)

    def label_auto_visible(self, p0: str) -> int:
        """Contour: label_auto_visible

        """
        cmd = f'''ensight.contour.label_auto_visible({repr(p0)})'''
        return self._session.cmd(cmd)

    def label_custom_visible(self, p0: str) -> int:
        """Contour: label_custom_visible

        """
        cmd = f'''ensight.contour.label_custom_visible({repr(p0)})'''
        return self._session.cmd(cmd)

    def label_decimal_places(self, p0: int) -> int:
        """Specify the number of decimal places to use for contour labels.
        
        | Used only if labels are visible
        
        Args:
            p0:
                'num' The number of decimal places
        
        Examples:
            ::
        
                #
                # Create contours on part 2
                #
                ensight.part.select_begin(2)
                ensight.contour.begin()
                ensight.contour.variable("temperature")
                ensight.contour.sync_to_palette("OFF")
                #
                # create 8 contours from 0 to 4.5 using a quadratic distribution
                #
                ensight.contour.distribution("quadratic")
                ensight.contour.range(0.,4.5)
                ensight.contour.levels(8)
                # 
                # turn on labels spaced every 2 units
                # using a floating point representation with 2 decimal places
                #
                ensight.contour.levels_visible("ON")
                ensight.contour.label_visible("ON")
                ensight.contour.label_spacing(2.0)
                ensight.contour.label_format("floating_point")
                ensight.contour.label_decimal_places(2)
                ensight.contour.end()
                ensight.contour.create()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.contour.label_decimal_places({repr(p0)})'''
        return self._session.cmd(cmd)

    def label_format(self, p0: str) -> int:
        """Specify the format for contour labels.
        
        Args:
            p0:
                'format'
        
                * floating_point
                * exponential
        
        Examples:
            ::
        
                #
                # Create contours on part 2
                #
                ensight.part.select_begin(2)
                ensight.contour.begin()
                ensight.contour.variable("temperature")
                ensight.contour.sync_to_palette("OFF")
                #
                # create 8 contours from 0 to 4.5 using a quadratic distribution
                #
                ensight.contour.distribution("quadratic")
                ensight.contour.range(0.,4.5)
                ensight.contour.levels(8)
                # 
                # turn on labels spaced every 2 units
                # using a floating point representation with 2 decimal places
                #
                ensight.contour.levels_visible("ON")
                ensight.contour.label_visible("ON")
                ensight.contour.label_spacing(2.0)
                ensight.contour.label_format("floating_point")
                ensight.contour.label_decimal_places(2)
                ensight.contour.end()
                ensight.contour.create()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.contour.label_format({repr(p0)})'''
        return self._session.cmd(cmd)

    def label_orientation(self, p0: str) -> int:
        """Contour: label_orientation

        """
        cmd = f'''ensight.contour.label_orientation({repr(p0)})'''
        return self._session.cmd(cmd)

    def label_rgb(self, p0: float, p1: float, p2: float) -> int:
        """Set the color for contour labels.
        
        Args:
            p0:
                'red_val' red, green, blue components of color (0 to 1.)
            p1:
                'grn_val' red, green, blue components of color (0 to 1.)
            p2:
                'blu_val' red, green, blue components of color (0 to 1.)
        
        Examples:
            ::
        
                #
                # Modify an existing contour part to
                # have red labels
                #
                ensight.part.select_begin(3)
                ensight.part.modify_begin()
                ensight.contour.label_visible("ON")
                ensight.contour.label_rgb(1.,0.,0.)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.contour.label_rgb({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def label_size(self, p0: int) -> int:
        """Contour: label_size

        """
        cmd = f'''ensight.contour.label_size({repr(p0)})'''
        return self._session.cmd(cmd)

    def label_spacing(self, p0: float) -> int:
        """Control the spacing of contour labels
        
        | The labels will be spaced approximately the value specified.
        
        Args:
            p0:
                'distance' distance between labels
        
        Examples:
            ::
        
                #
                # Modify an existing contour part to have
                # labels .5 units apart
                #
                ensight.part.select_begin(3)
                ensight.part.modify_begin()
                ensight.contour.label_visible("ON")
                ensight.contour.label_spacing(.5)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.contour.label_spacing({repr(p0)})'''
        return self._session.cmd(cmd)

    def label_visible(self, p0: str) -> int:
        """Turn labels on or off for contour parts.
        
        | The contour labels are shown as integer values indicating the contour level which corresponds to the color palette level.
        | Level 1 is the lowest level for the color palette.
        | Subcontours are not labeled.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                #
                # Modify an existing contour part to show labels
                #
                ensight.part.select_begin(3)
                ensight.part.modify_begin()
                ensight.contour.label_visible("ON")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.contour.label_visible({repr(p0)})'''
        return self._session.cmd(cmd)

    def levels(self, p0: int) -> int:
        """Specifies how many contour levels are created between the min and max values.
        
        | Only used when "contour: sync_to_palette OFF"
        
        Args:
            p0:
                'num_levels' The number of contour levels to create
        
        Examples:
            ::
        
                #
                # Create contours on part 2
                #
                ensight.part.select_begin(2)
                ensight.contour.begin()
                ensight.contour.variable("temperature")
                ensight.contour.sync_to_palette("OFF")
                #
                # create 8 contours from 0 to 4.5 using a quadratic distribution
                #
                ensight.contour.distribution("quadratic")
                ensight.contour.range(0.,4.5)
                ensight.contour.levels(8)
                # 
                # turn on labels spaced every 2 units
                # using a floating point representation with 2 decimal places
                #
                ensight.contour.label_visible("ON")
                ensight.contour.label_spacing(2.0)
                ensight.contour.label_format("floating_point")
                ensight.contour.label_decimal_places(2)
                ensight.contour.end()
                ensight.contour.create()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.contour.levels({repr(p0)})'''
        return self._session.cmd(cmd)

    def levels_visible(self, p0: str) -> int:
        """Specifies the visibility of the contour levels created between the min and max values.
        
        | Only used when "contour: sync_to_palette OFF"
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                #
                # Create contours on part 2
                #
                ensight.part.select_begin(2)
                ensight.contour.begin()
                ensight.contour.variable("temperature")
                ensight.contour.sync_to_palette("OFF")
                #
                # create 8 contours from 0 to 4.5 using a quadratic distribution
                #
                ensight.contour.distribution("quadratic")
                ensight.contour.range(0.,4.5)
                ensight.contour.levels(8)
                # 
                # turn on labels spaced every 2 units
                # using a floating point representation with 2 decimal places
                #
                ensight.contour.levels_visible("ON")
                ensight.contour.label_visible("ON")
                ensight.contour.label_spacing(2.0)
                ensight.contour.label_format("floating_point")
                ensight.contour.label_decimal_places(2)
                ensight.contour.end()
                ensight.contour.create()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.contour.levels_visible({repr(p0)})'''
        return self._session.cmd(cmd)

    def palette(self, args: Any) -> int:
        """Contour: palette

        """
        cmd = f'''ensight.contour.palette({repr(args)})'''
        return self._session.cmd(cmd)

    def range(self, p0: float, p1: float) -> int:
        """Specifies the minimum and maximum contour levels when contours are not tied to the variable palette.
        
        | Only used when "contour: sync_to_palette OFF"
        
        Args:
            p0:
                'min' The minimum contour value
            p1:
                'max' The maximum contour value
        
        Examples:
            ::
        
                #
                # Create contours on part 2
                #
                ensight.part.select_begin(2)
                ensight.contour.begin()
                ensight.contour.variable("temperature")
                ensight.contour.sync_to_palette("OFF")
                #
                # create 8 contours from 0 to 4.5 using a quadratic distribution
                #
                ensight.contour.distribution("quadratic")
                ensight.contour.range(0.,4.5)
                ensight.contour.levels(8)
                # 
                # turn on labels spaced every 2 units
                # using a floating point representation with 2 decimal places
                #
                ensight.contour.label_visible("ON")
                ensight.contour.label_spacing(2.0)
                ensight.contour.label_format("floating_point")
                ensight.contour.label_decimal_places(2)
                ensight.contour.end()
                ensight.contour.create()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.contour.range({repr(p0)},{repr(p1)})'''
        return self._session.cmd(cmd)

    def select_default(self) -> int:
        """Sets the target to the default settings for subsequent attribute modifications.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.contour.select_default()'''
        return self._session.cmd(cmd)

    def subcontours(self, p0: int) -> int:
        """Contour: subcontours

        """
        cmd = f'''ensight.contour.subcontours({repr(p0)})'''
        return self._session.cmd(cmd)

    def sublevels(self, p0: int) -> int:
        """Add a specified number of contours distributed between the main contour levels.
        
        Args:
            p0:
                'num' Number of contours to create between the main contour levels.
        
        Examples:
            ::
        
                #
                # Create contours on part 2
                #
                ensight.part.select_begin(2)
                ensight.contour.begin()
                ensight.contour.variable("temperature")
                ensight.contour.sync_to_palette("OFF")
                #
                # create 8 contours from 0 to 4.5 using a quadratic distribution
                #
                ensight.contour.distribution("quadratic")
                ensight.contour.range(0.,4.5)
                ensight.contour.levels(8)
                # 
                # turn off the visibility of the main contours and turn
                # subcontours on - make 2 subcontours between each of the 8 levels.
                #
                ensight.contour.levels_visible("OFF")
                ensight.contour.sublevels_visible("ON")
                ensight.contour.sublevels(2)
                ensight.contour.end()
                ensight.contour.create()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.contour.sublevels({repr(p0)})'''
        return self._session.cmd(cmd)

    def sublevels_visible(self, p0: str) -> int:
        """Specifies the visibility of the contour sub-levels created between the min and max values.
        
        | Only used when "contour: sync_to_palette OFF"
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                #
                # Create contours on part 2
                #
                ensight.part.select_begin(2)
                ensight.contour.begin()
                ensight.contour.variable("temperature")
                ensight.contour.sync_to_palette("OFF")
                #
                # create 8 contours from 0 to 4.5 using a quadratic distribution
                #
                ensight.contour.distribution("quadratic")
                ensight.contour.range(0.,4.5)
                ensight.contour.levels(8)
                # 
                # turn off the visibility of the main contours and turn
                # subcontours on
                #
                ensight.contour.levels_visible("OFF")
                ensight.contour.sublevels_visible("ON")
                ensight.contour.sublevels(2)
                ensight.contour.end()
                ensight.contour.create()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.contour.sublevels_visible({repr(p0)})'''
        return self._session.cmd(cmd)

    def sync_to_palette(self, p0: str) -> int:
        """Specifies contour part creation to be tied to the variable palette or by user input.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                #
                # Create contours on part 2
                #
                ensight.part.select_begin(2)
                ensight.contour.begin()
                ensight.contour.variable("temperature")
                ensight.contour.sync_to_palette("OFF")
                #
                # create 8 contours from 0 to 4.5 using a quadratic distribution
                #
                ensight.contour.distribution("quadratic")
                ensight.contour.range(0.,4.5)
                ensight.contour.levels(8)
                # 
                # turn on labels spaced every 2 units
                # using a floating point representation with 2 decimal places
                #
                ensight.contour.label_visible("ON")
                ensight.contour.label_spacing(2.0)
                ensight.contour.label_format("floating_point")
                ensight.contour.label_decimal_places(2)
                ensight.contour.end()
                ensight.contour.create()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.contour.sync_to_palette({repr(p0)})'''
        return self._session.cmd(cmd)

    def var_type(self, p0: str) -> int:
        """Contour: var_type

        """
        cmd = f'''ensight.contour.var_type({repr(p0)})'''
        return self._session.cmd(cmd)

    def variable(self, p0: Any) -> int:
        """Use this variable for creating a contour part.
        
        | The variable must be active before the contour part can be created. 
        
        Args:
            p0:
                'var_name' create contours from this variable
        
        Examples:
            ::
        
                #
                # Create contours of velocity magnitude of part 2
                #
                ensight.part.select_begin(2)
                ensight.contour.begin()
                ensight.contour.variable("velocity")
                ensight.contour.end()
                ensight.contour.create()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.contour.variable({repr(p0)})'''
        return self._session.cmd(cmd)


class context_restore:
    """Class wrapper for EnSight context_restore module

    This class acts as a proxy for the EnSight Python module ensight.context_restore
    """
    def __init__(self, session: Session):
        self._session = session

    def begin(self) -> int:
        """Context_restore: begin

        """
        cmd = f'''ensight.context_restore.begin()'''
        return self._session.cmd(cmd)

    def component(self, p0: float, p1: float, p2: float) -> int:
        """Context_restore: component

        """
        cmd = f'''ensight.context_restore.component({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def create(self) -> int:
        """Context_restore: create

        """
        cmd = f'''ensight.context_restore.create()'''
        return self._session.cmd(cmd)

    def end(self) -> int:
        """Context_restore: end

        """
        cmd = f'''ensight.context_restore.end()'''
        return self._session.cmd(cmd)

    def offset(self, p0: float) -> int:
        """Context_restore: offset

        """
        cmd = f'''ensight.context_restore.offset({repr(p0)})'''
        return self._session.cmd(cmd)

    def offset_from_part(self, p0: int) -> int:
        """Context_restore: offset_from_part

        """
        cmd = f'''ensight.context_restore.offset_from_part({repr(p0)})'''
        return self._session.cmd(cmd)

    def offset_scale(self, p0: float) -> int:
        """Context_restore: offset_scale

        """
        cmd = f'''ensight.context_restore.offset_scale({repr(p0)})'''
        return self._session.cmd(cmd)

    def offset_vector(self, p0: float, p1: float, p2: float) -> int:
        """Context_restore: offset_vector

        """
        cmd = f'''ensight.context_restore.offset_vector({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def scale_factor(self, p0: float) -> int:
        """Context_restore: scale_factor

        """
        cmd = f'''ensight.context_restore.scale_factor({repr(p0)})'''
        return self._session.cmd(cmd)

    def select_default(self) -> int:
        """Context_restore: select_default

        """
        cmd = f'''ensight.context_restore.select_default()'''
        return self._session.cmd(cmd)

    def sidewall(self, p0: str) -> int:
        """Context_restore: sidewall

        """
        cmd = f'''ensight.context_restore.sidewall({repr(p0)})'''
        return self._session.cmd(cmd)

    def surface(self, p0: str) -> int:
        """Context_restore: surface

        """
        cmd = f'''ensight.context_restore.surface({repr(p0)})'''
        return self._session.cmd(cmd)

    def type(self, p0: str) -> int:
        """Context_restore: type

        """
        cmd = f'''ensight.context_restore.type({repr(p0)})'''
        return self._session.cmd(cmd)

    def use_surface_normals(self, p0: str) -> int:
        """Context_restore: use_surface_normals

        """
        cmd = f'''ensight.context_restore.use_surface_normals({repr(p0)})'''
        return self._session.cmd(cmd)

    def var_type(self, p0: str) -> int:
        """Context_restore: var_type

        """
        cmd = f'''ensight.context_restore.var_type({repr(p0)})'''
        return self._session.cmd(cmd)

    def variable(self, p0: Any) -> int:
        """Context_restore: variable

        """
        cmd = f'''ensight.context_restore.variable({repr(p0)})'''
        return self._session.cmd(cmd)


class connect:
    """Class wrapper for EnSight connect module

    This class acts as a proxy for the EnSight Python module ensight.connect
    """
    def __init__(self, session: Session):
        self._session = session

    def backend(self) -> int:
        """Indicates that the following 'connect:' commands will apply to new server connections.
        
        | To change the default server connection settings, use the 'connect: default' command.
        
        Examples:
            ::
        
                # WARNING: following line includes OBSOLETE call (ensight.connect.backend).
                ensight.connect.backend()
                ensight.connect.machine("localhost")
                ensight.connect.executable(".server")
                ensight.connect.directory("")
                ensight.connect.type("auto")
                ensight.connect.connect()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.connect.backend()'''
        return self._session.cmd(cmd)

    def connect(self) -> int:
        """Cause the client to wait for a connection to the EnSight server.
        
        | The client will try to start the server if an auto connection is specified.
        | The client will wait and listen for a connection from the  server.  By default it will listen on TCP port 1106.  This port number can be modified with the '-ports #' argument to the client and server.
        
        Examples:
            ::
        
                # WARNING: following line includes OBSOLETE call (ensight.connect.backend).
                ensight.connect.backend()
                ensight.connect.machine("localhost")
                ensight.connect.executable(".server")
                ensight.connect.directory("")
                ensight.connect.type("auto")
                ensight.connect.connect()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.connect.connect()'''
        return self._session.cmd(cmd)

    def default(self) -> int:
        """Indicates that the following 'connect:' commands will change the EnSight defaults for future sessions.
        
        | To temporarily change server connection settings, use the 'connect: backend' command.
        
        Examples:
            ::
        
                ensight.connect.default()
                ensight.connect.machine("localhost")
                ensight.connect.executable(".server")
                ensight.connect.directory("/tmp")
                ensight.connect.type("auto")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.connect.default()'''
        return self._session.cmd(cmd)

    def directory(self, p0: str) -> int:
        """Specifies the directory shown in the Data Reader dialog.
        
        Args:
            p0:
                'pathname' name of the directory
        
        Examples:
            ::
        
                # Show the /tmp director on 'slim' in the Data Reader dialog
                # WARNING: following line includes OBSOLETE call (ensight.connect.backend).
                ensight.connect.backend()
                ensight.connect.machine("slim")
                ensight.connect.executable(".server")
                ensight.connect.directory("/tmp")
                ensight.connect.type("auto")
                ensight.connect.connect()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.connect.directory({repr(p0)})'''
        return self._session.cmd(cmd)

    def executable(self, p0: str) -> int:
        """Specifies the file name of the EnSight server for automatic connections initiated by the client.
        
        | The filename can be a complete pathname to the server otherwise the server executable must be found in your default path on the  host running the server.
        
        Args:
            p0:
                'filename' name of the server
        
        Examples:
            ::
        
                # use server found in /usr/local/bin/
                # WARNING: following line includes OBSOLETE call (ensight.connect.backend).
                ensight.connect.backend()
                ensight.connect.machine("slim")
                ensight.connect.executable("/usr/local/bin/.server")
                ensight.connect.directory("/tmp")
                ensight.connect.type("auto")
                ensight.connect.connect()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.connect.executable({repr(p0)})'''
        return self._session.cmd(cmd)

    def login_id(self, p0: str) -> int:
        """Specifies a different user name to use on the computer where the server will run.
        
        | For auto connections the client will try to start the server on a remote computer using the 'rsh' command.  If a user name is specified, it will be used as part of the rsh command. In lieu of the rsh command, a different command can be used as specified by the '-rsh command' argument to the client.
        
        Args:
            p0:
                'username' login name
        
        Examples:
            ::
        
                # log in to host slim as user 'joe'
                # WARNING: following line includes OBSOLETE call (ensight.connect.backend).
                ensight.connect.backend()
                ensight.connect.machine("slim")
                ensight.connect.login_id("joe")
                ensight.connect.executable(".server")
                ensight.connect.directory("")
                ensight.connect.type("auto")
                ensight.connect.connect()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.connect.login_id({repr(p0)})'''
        return self._session.cmd(cmd)

    def machine(self, p0: str) -> int:
        """Specifies the hostname where EnSight server should be run for automatic connections initiated by the client.
        
        | The name specified must be an Internet accessible hostname or IP address.  You must be able to rlogin (or ssh) into this machine.
        
        Args:
            p0:
                'hostname' name of the computer where the server should run
        
        Examples:
            ::
        
                # use an auto connection to host 'slim'
                # WARNING: following line includes OBSOLETE call (ensight.connect.backend).
                ensight.connect.backend()
                ensight.connect.machine("slim")
                ensight.connect.executable(".server")
                ensight.connect.directory("/tmp")
                ensight.connect.type("auto")
                ensight.connect.connect()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.connect.machine({repr(p0)})'''
        return self._session.cmd(cmd)

    def plotter(self) -> int:
        """Connect: plotter

        """
        cmd = f'''ensight.connect.plotter()'''
        return self._session.cmd(cmd)

    def port(self, p0: int) -> int:
        """Connect: port

        """
        cmd = f'''ensight.connect.port({repr(p0)})'''
        return self._session.cmd(cmd)

    def ports(self, p0: int) -> int:
        """Connect: ports

        """
        cmd = f'''ensight.connect.ports({repr(p0)})'''
        return self._session.cmd(cmd)

    def type(self, p0: str) -> int:
        """Specifies whether the EnSight server should be started by the client or by the user.
        
        Args:
            p0:
                'method'
        
                * auto
                * manual
        
        Examples:
            ::
        
                # use a manual connection
                # WARNING: following line includes OBSOLETE call (ensight.connect.backend).
                ensight.connect.backend()
                ensight.connect.type("manual")
                ensight.connect.connect()
        
            ::
        
                # use an auto connection
                # WARNING: following line includes OBSOLETE call (ensight.connect.backend).
                ensight.connect.backend()
                ensight.connect.machine("slim")
                ensight.connect.executable(".server")
                ensight.connect.directory("/tmp")
                ensight.connect.type("auto")
                ensight.connect.connect()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.connect.type({repr(p0)})'''
        return self._session.cmd(cmd)


class command:
    """Class wrapper for EnSight command module

    This class acts as a proxy for the EnSight Python module ensight.command
    """
    def __init__(self, session: Session):
        self._session = session

    def _print(self, p0: str) -> int:
        """Command: print

        """
        cmd = f'''ensight.command._print({repr(p0)})'''
        return self._session.cmd(cmd)

    def delay(self, p0: int) -> int:
        """Causes a delay between each command while playing commands from a command file.
        
        | This command is useful for slowing down the playback speed of command files. It is typically used when playing command files for demos.
        
        Args:
            p0:
                'value' time in seconds
        
        Examples:
            ::
        
                ensight.command.delay_refresh("OFF")
                ensight.command.delay(2)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.command.delay({repr(p0)})'''
        return self._session.cmd(cmd)

    def delay_guirefresh(self, p0: str) -> int:
        """Command: delay_guirefresh

        """
        cmd = f'''ensight.command.delay_guirefresh({repr(p0)})'''
        return self._session.cmd(cmd)

    def delay_refresh(self, p0: str) -> int:
        """Causes a delay between each command while playing commands from a command file.
        
        | If delay refresh is on, the graphics are not redrawn after each command. 
        | Playback of command files can be sped up toggling on delay_refresh at the beginning of the command file and then off towards the end (i.e. just before recording of an animation).
        | It is advantageous to use this technique for batch animations.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                #
                # Save time by not drawing the image after each command 
                #
                ensight.command.delay_refresh("ON")
                # 
                # Other commands to set up the animation 
                # 
                # restore graphics updates 
                #
                ensight.command.delay_refresh("OFF")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.command.delay_refresh({repr(p0)})'''
        return self._session.cmd(cmd)

    def embed_cmd(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.command.embed_cmd({repr(p0)})'''
        return self._session.cmd(cmd)

    def macro_path(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.command.macro_path({repr(p0)})'''
        return self._session.cmd(cmd)

    def mouse(self, p0: str) -> int:
        """Command: mouse

        """
        cmd = f'''ensight.command.mouse({repr(p0)})'''
        return self._session.cmd(cmd)

    def part_selection_by(self, p0: str) -> int:
        """Determines if command language will record part selections by name or by number as it appears in the part list.
        
        | This setting is typically controlled in the Preference dialog.  Creating command files that reference names instead of numbers may be more portable if the names used in the data files are relatively generic.
        
        Args:
            p0:
                'method'
        
                * number
                * name
        
        Examples:
            ::
        
                #
                # Turn visibility of part
                # number 2 off
                #
                ensight.command.part_selection_by("number")
                ensight.part.select_begin(2)
                ensight.part.modify_begin()
                ensight.part.visible("OFF")
                ensight.part.modify_end()
                ensight.command.part_selection_by("name")
                #
                # Turn visibility of part named "external flow field"
                # off
                #
                # WARNING: following line includes OBSOLETE call (ensight.part.select_partname_begin).
                ensight.part.select_partname_begin("external flow field")
                ensight.part.modify_begin()
                ensight.part.visible("ON")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.command.part_selection_by({repr(p0)})'''
        return self._session.cmd(cmd)

    def reload_macros(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.command.reload_macros()'''
        return self._session.cmd(cmd)

    def show_cmds(self) -> int:
        """Command: show_cmds

        """
        cmd = f'''ensight.command.show_cmds()'''
        return self._session.cmd(cmd)

    def testbatchglobal(self, p0: str) -> int:
        """Command: testbatchglobal

        """
        cmd = f'''ensight.command.testbatchglobal({repr(p0)})'''
        return self._session.cmd(cmd)


class collab:
    """Class wrapper for EnSight collab module

    This class acts as a proxy for the EnSight Python module ensight.collab
    """
    def __init__(self, session: Session):
        self._session = session


class clip:
    """Class wrapper for EnSight clip module

    This class acts as a proxy for the EnSight Python module ensight.clip
    """
    def __init__(self, session: Session):
        self._session = session

    def angle(self, *args, **kwargs) -> Any:
        """Set the angle for a cone clip.
        
        Args:
            p0:
                'cone_angle' the cone angle in degrees
        
        Examples:
            ::
        
                #
                # Select the parent part
                #
                ensight.part.select_begin(1)
                ensight.clip.begin()
                ensight.clip.domain("intersect")
                ensight.clip.tool("cone")
                ensight.clip.origin(0,0,0)
                ensight.clip.axis(1,0,0)
                #
                # Set the cone to 20 degrees
                #
                ensight.clip.angle(20.)
                ensight.clip.end()
                ensight.clip.create()
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.angle({arg_string})"
        return self._session.cmd(cmd)

    def axis(self, *args, **kwargs) -> Any:
        """Set the direction vector for quadric and revolution clips.
        
        | The origin together with the axis defines the location and orientation of the quadric and revolution tools.
        | The origin and axis define the point and axis about which a 1D part is revolved.
        
        Args:
            p0:
                'x_comp' x, y, z components of the direction vector
            p1:
                'y_comp' x, y, z components of the direction vector
            p2:
                'z_comp' x, y, z components of the direction vector
        
        Examples:
            ::
        
                #
                # Select the parent part
                #
                ensight.part.select_begin(1)
                ensight.clip.begin()
                ensight.clip.domain("intersect")
                ensight.clip.tool("cylinder")
                ensight.clip.origin(0,0,0)
                #
                # Set the cone axis to lie along the x axis
                #
                ensight.clip.axis(1,0,0)
                ensight.clip.radius(.5)
                ensight.clip.end()
                ensight.clip.create()
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.axis({arg_string})"
        return self._session.cmd(cmd)

    def axis_point_1(self, *args, **kwargs) -> Any:
        """Clip: axis_point 1

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.axis_point_1({arg_string})"
        return self._session.cmd(cmd)

    def axis_point_2(self, *args, **kwargs) -> Any:
        """Clip: axis_point 2

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.axis_point_2({arg_string})"
        return self._session.cmd(cmd)

    def axis_x(self, *args, **kwargs) -> Any:
        """Clip: axis x

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.axis_x({arg_string})"
        return self._session.cmd(cmd)

    def axis_y(self, *args, **kwargs) -> Any:
        """Clip: axis y

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.axis_y({arg_string})"
        return self._session.cmd(cmd)

    def axis_z(self, *args, **kwargs) -> Any:
        """Clip: axis z

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.axis_z({arg_string})"
        return self._session.cmd(cmd)

    def begin(self, *args, **kwargs) -> Any:
        """Delimit the modifications for clip attributes.
        
        | These commands are used to set the attributes for a clip part creation.
        
        Examples:
            ::
        
                ensight.clip.begin()
                #
                # Change attributes
                #
                ensight.clip.domain("inside")
                ensight.clip.tool("plane")
                ensight.clip.plane(1,-1,-1,0)
                ensight.clip.plane(2,1,-1,0)
                ensight.clip.plane(3,1,1,0)
                #
                # End change attributes
                #
                ensight.clip.end()
                ensight.clip.create()
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.begin({arg_string})"
        return self._session.cmd(cmd)

    def box_axis(self, *args, **kwargs) -> Any:
        """Specify the direction vectors for a box clip.
        
        | The direction vectors are in reference to the parent part frame.
        
        Args:
            p0:
                'axis'
        
                * x
                * y
                * z
            p1:
                'x_vector' The x component of the direction vector
            p2:
                'y_vector' The y component of the direction vector
            p3:
                'z_vector' The z component of the direction vector
        
        Examples:
            ::
        
                #
                # Select a parent part
                #
                ensight.part.select_begin(2)
                ensight.clip.begin()
                #
                # Create a xyz box clip with the box aligned with the
                # global axis system and with an origin -.75, -.75, -.25
                # The box sides are of length 1., 1.5, 2.
                #
                ensight.clip.tool("xyz_box")
                ensight.clip.box_origin(-7.500000e-01,-7.500000e-01,-2.500000e-01)
                ensight.clip.box_axis("x",1.000000e+00,0.000000e+00,0.000000e+00)
                ensight.clip.box_axis("y",0.000000e+00,1.000000e+00,0.000000e+00)
                ensight.clip.box_axis("z",0.000000e+00,0.000000e+00,1.000000e+00)
                ensight.clip.box_length(1.000000e+00,1.500000e+00,2.000000e+00)
                ensight.clip.domain("intersect")
                ensight.clip.end()
                ensight.clip.create()
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.box_axis({arg_string})"
        return self._session.cmd(cmd)

    def box_length(self, *args, **kwargs) -> Any:
        """Specify the size of the box clip in the x, y, and z directions
        
        | The lengths are in relation to the box axis directions.
        
        Args:
            p0:
                'x_len' The length of box clip in the x direction
            p1:
                'y_len' The length of box clip in the y direction
            p2:
                'z_len' The length of box clip in the z direction
        
        Examples:
            ::
        
                #
                # Select a parent part
                #
                ensight.part.select_begin(2)
                ensight.clip.begin()
                #
                # Create a xyz box clip with the box aligned with the
                # global axis system and with an origin -.75, -.75, -.25
                # The box sides are of length 1., 1.5, 2.
                #
                ensight.clip.tool("xyz_box")
                ensight.clip.box_origin(-7.500000e-01,-7.500000e-01,-2.500000e-01)
                ensight.clip.box_axis("x",1.000000e+00,0.000000e+00,0.000000e+00)
                ensight.clip.box_axis("y",0.000000e+00,1.000000e+00,0.000000e+00)
                ensight.clip.box_axis("z",0.000000e+00,0.000000e+00,1.000000e+00)
                ensight.clip.box_length(1.000000e+00,1.500000e+00,2.000000e+00)
                ensight.clip.domain("intersect")
                ensight.clip.end()
                ensight.clip.create()
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.box_length({arg_string})"
        return self._session.cmd(cmd)

    def box_max(self, *args, **kwargs) -> Any:
        """Clip: box_max

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.box_max({arg_string})"
        return self._session.cmd(cmd)

    def box_min(self, *args, **kwargs) -> Any:
        """Clip: box_min

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.box_min({arg_string})"
        return self._session.cmd(cmd)

    def box_origin(self, *args, **kwargs) -> Any:
        """Specify the origin of the box clip in reference to the parent part frame
        
        | The origin is in reference to the parent part frame.
        
        Args:
            p0:
                'x_ori' The x-origin of the box clip
            p1:
                'y_ori' The y-origin of the box clip
            p2:
                'z_ori' The z-origin of the box clip
        
        Examples:
            ::
        
                #
                # Select a parent part
                #
                ensight.part.select_begin(2)
                ensight.clip.begin()
                #
                # Create a xyz box clip with the box aligned with the
                # global axis system and with an origin -.75, -.75, -.25
                # The box sides are of length 1., 1.5, 2.
                #
                ensight.clip.tool("xyz_box")
                ensight.clip.box_origin(-7.500000e-01,-7.500000e-01,-2.500000e-01)
                ensight.clip.box_axis("x",1.000000e+00,0.000000e+00,0.000000e+00)
                ensight.clip.box_axis("y",0.000000e+00,1.000000e+00,0.000000e+00)
                ensight.clip.box_axis("z",0.000000e+00,0.000000e+00,1.000000e+00)
                ensight.clip.box_length(1.000000e+00,1.500000e+00,2.000000e+00)
                ensight.clip.domain("intersect")
                ensight.clip.end()
                ensight.clip.create()
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.box_origin({arg_string})"
        return self._session.cmd(cmd)

    def create(self, *args, **kwargs) -> Any:
        """Create a clip part with the currently defined attributes using the currently selected parts as parents. 
        
        | The clip part is created using the currently selected parts as parents.  The clip part is created using the currently set clip attributes.
        
        Examples:
            ::
        
                #
                # Select a parent part
                #
                ensight.part.select_begin(2)
                ensight.clip.begin()
                ensight.clip.domain("inside")
                ensight.clip.tool("cylinder")
                ensight.clip.origin(-1.,0,1.)
                ensight.clip.axis(1,0,0)
                ensight.clip.radius(.75)
                ensight.clip.end()
                ensight.clip.create()
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.create({arg_string})"
        return self._session.cmd(cmd)

    def create_delta(self, *args, **kwargs) -> Any:
        """Specify the delta offset when multiple clip instances will be created.
        
        | For XYZ clips, this is a float value in the direction chosen for the XYZ clip.  For Plane clips, this is a float value in the plane z direction.  For IJK clips, this is should be a whole number representing the number of I, J, or K planes.
        | Requires the use of the clip: number_to_create <instances> command in conjunction with this command.
        
        Args:
            p0:
                'delta' the delta value to apply to each instance of multiple clips.
        
        Examples:
            ::
        
                #
                # Select a parent part
                #
                ensight.part.select_begin(2)
                ensight.clip.begin()
                #
                # Create a clip at y=1.5 and 4 additional instances at .5 delta
                #
                ensight.clip.value(1.5)
                ensight.clip.create_delta(0.5)
                ensight.clip.number_to_create(5)
                ensight.clip.domain("intersect")
                ensight.clip.tool("xyz")
                ensight.clip.mesh_plane("Y")
                ensight.clip.end()
                ensight.clip.create()
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.create_delta({arg_string})"
        return self._session.cmd(cmd)

    def delta(self, *args, **kwargs) -> Any:
        """Set a delta transform for use with the keyframe animator.
        
        | Applies only to line and plane clip types.
        
        Args:
            p0:
                'dx' amount to translate in x direction for each animation frame
            p1:
                'dy' amount to translate in y direction for each animation frame
            p2:
                'dz' amount to translate in z direction for each animation frame
        
        Examples:
            ::
        
                #
                # Select an existing clip part
                #
                ensight.part.select_begin(3)
                ensight.part.modify_begin()
                #
                # Increment the clip position by 0.2 in the x-direction
                #
                ensight.clip.delta(.2,0,0)
                ensight.part.modify_end()
                ensight.anim_keyframe.keyframing("ON")
                ensight.anim_keyframe.create_keyframe()
                ensight.anim_keyframe.create_keyframe()
                ensight.anim_keyframe.run()
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.delta({arg_string})"
        return self._session.cmd(cmd)

    def dimension2(self, *args, **kwargs) -> Any:
        """Specify the minimum/maximum range for the non-constant I/J/K extract.
        
        | For an I/J/K extract the user specifies that he wants to create a part of constant I, J, or K and an extract value.  These parameters specify the range for the non-constant plane.  
        
        Args:
            p0:
                'min' minimum plane value integer
            p1:
                'max' maximum plane value integer
        
        Examples:
            ::
        
                #
                # Select an existing I plane
                # extract an modify the J range = 10 to 60
                # and the K range to be 1 to 45
                #
                ensight.part.select_begin(3)
                ensight.part.modify_begin()
                ensight.clip.dimension2(10,60)
                ensight.clip.dimension3(1,45)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.dimension2({arg_string})"
        return self._session.cmd(cmd)

    def dimension2_step(self, *args, **kwargs) -> Any:
        """Specify the step increment for the non-constant I/J/K extract.
        
        | For an I/J/K extract the user specifies that he wants to create a part of constant I, J, or K and a extract value.  These parameters specify the step increment for the non-constant plane.  
        
        Args:
            p0:
                'step' step value
        
        Examples:
            ::
        
                #
                # Select an existing I plane extract
                # and modify the J step by factor
                # to 2
        
            ::
        
                ensight.part.select_begin(3)
                ensight.part.modify_begin()
                ensight.clip.dimension2(10,60)
                ensight.clip.dimension2_step(2)
                ensight.clip.dimension3(1,45)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.dimension2_step({arg_string})"
        return self._session.cmd(cmd)

    def dimension3(self, *args, **kwargs) -> Any:
        """Specify the minimum/maximum range for the non-constant I/J/K extract.
        
        | For an I/J/K extract the user specifies that he wants to create a part of constant I, J, or K and an extract value.  These parameters specify the range for the non-constant plane.  
        
        Args:
            p0:
                'min' minimum plane value integer
            p1:
                'max' maximum plane value integer
        
        Examples:
            ::
        
                #
                # Select an existing I plane
                # extract an modify the J range = 10 to 60
                # and the K range to be 1 to 45
                #
                ensight.part.select_begin(3)
                ensight.part.modify_begin()
                ensight.clip.dimension2(10,60)
                ensight.clip.dimension3(1,45)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.dimension3({arg_string})"
        return self._session.cmd(cmd)

    def dimension3_step(self, *args, **kwargs) -> Any:
        """Specify the step increment for the non-constant I/J/K extract.
        
        | For an I/J/K extract the user specifies that he wants to create a part of constant I, J, or K and a extract value.  These parameters specify the step increment for the non-constant plane.  
        
        Args:
            p0:
                'step' step value
        
        Examples:
            ::
        
                #
                # Select an existing I plane extract
                # and modify the J step by factor
                # to 2
        
            ::
        
                ensight.part.select_begin(3)
                ensight.part.modify_begin()
                ensight.clip.dimension2(10,60)
                ensight.clip.dimension2_step(2)
                ensight.clip.dimension3(1,45)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.dimension3_step({arg_string})"
        return self._session.cmd(cmd)

    def domain(self, *args, **kwargs) -> Any:
        """Specify what type of clip will be created.
        
        | Intersect applies to all tools except XYZ Box.
        | Inside/outside/in_out apply to all tools except XYZ, IJK, and Line. 
        | When domain is set to inside/outside/in_out the parent parts will be made invisible.
        | The default is intersect.
        
        Args:
            p0:
                'domain'
        
                * intersect
                * inside
                * outside
                * in_out
                * crinkly
        
        Examples:
            ::
        
                #
                # Select the part
                #
                ensight.part.select_begin(2)
                ensight.clip.begin()
                #
                # Create a new part inside the
                # cylinder tool
                #
                ensight.clip.domain("inside")
                ensight.clip.tool("cylinder")
                ensight.clip.origin(-1.,0,1.)
                ensight.clip.axis(1,0,0)
                ensight.clip.radius(.75)
                ensight.clip.end()
                ensight.clip.create()
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.domain({arg_string})"
        return self._session.cmd(cmd)

    def end(self, *args, **kwargs) -> Any:
        """Delimit the modifications for clip attributes.
        
        | These commands are used to set the attributes for a clip part creation.
        
        Examples:
            ::
        
                ensight.clip.begin()
                #
                # Change attributes
                #
                ensight.clip.domain("inside")
                ensight.clip.tool("plane")
                ensight.clip.plane(1,-1,-1,0)
                ensight.clip.plane(2,1,-1,0)
                ensight.clip.plane(3,1,1,0)
                #
                # End change attributes
                #
                ensight.clip.end()
                ensight.clip.create()
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.end({arg_string})"
        return self._session.cmd(cmd)

    def end_point(self, *args, **kwargs) -> Any:
        """Clip: end_point

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.end_point({arg_string})"
        return self._session.cmd(cmd)

    def extents(self, *args, **kwargs) -> Any:
        """Set the clip extents to infinite or finite.
        
        | Grid type clips are always assumed to be finite.
        
        Args:
            p0:
                'extent'
        
                * finite
                * infinite
        
        Examples:
            ::
        
                #
                # Select the parent part
                #
                ensight.part.select_begin(2)
                ensight.clip.begin()
                #
                # Create a finite clip plane
                #
                ensight.clip.tool("plane")
                ensight.clip.domain("intersect")
                ensight.clip.extents("finite")
                ensight.clip.plane(1,-1,-1,0)
                ensight.clip.plane(2,1,-1,0)
                ensight.clip.plane(3,1,1,0)
                ensight.clip.end()
                ensight.clip.create()
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.extents({arg_string})"
        return self._session.cmd(cmd)

    def general_equation(self, *args, **kwargs) -> Any:
        """Clip to a specified quadric equation of the form
        
        | Ax^2 + By^2 + Cz^2 + Dxy + Eyz + Fxz + Gx + Hy + Iz = J
        
        Args:
            p0:
                'A' The coefficient of the x^2 term
            p1:
                'B' The coefficient of the y^2 term
            p2:
                'C' The coefficient of the z^2 term
            p3:
                'D' The coefficient of the xy term
            p4:
                'E' The coefficient of the yz term
            p5:
                'F' The coefficient of the xz term
            p6:
                'G' The coefficient of the x term
            p7:
                'H' The coefficient of the y term
            p8:
                'I' The coefficient of the z term
            p9:
                'J' The constant term
        
        Examples:
            ::
        
                #
                # Select the parent part
                #
                ensight.part.select_begin(1)
                ensight.clip.begin()
                #
                # Create a clip of the form
                # x^2 + y^2 + z^2 = .5
                #
                ensight.clip.domain("intersect")
                ensight.clip.tool("general_quadric")
                ensight.clip.general_equation(1,1,1,0,0,0,0,0,0,.5)
                ensight.clip.end()
                ensight.clip.create()
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.general_equation({arg_string})"
        return self._session.cmd(cmd)

    def grid_pts(self, *args, **kwargs) -> Any:
        """Set the number of sample points for a planar grid clip.
        
        Args:
            p0:
                'x_pts' number of points to sample along the x plane tool direction
            p1:
                'y_pts' number of points to sample along the y plane  tool direction
        
        Examples:
            ::
        
                #
                # Modify an existing
                # grid clip part
                #
                ensight.part.select_begin(3)
                ensight.part.modify_begin()
                ensight.clip.grid_pts(10,12)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.grid_pts({arg_string})"
        return self._session.cmd(cmd)

    def ijk_axis(self, *args, **kwargs) -> Any:
        """Display an axis system for a IJK extract.
        
        | Is only valid for I/J/K plane clips.
        
        Args:
            p0:
                'toggle'
        
                * ON  
                * OFF
        
        Examples:
            ::
        
                #
                # Turn on an axis showing the 
                # IJK layout of an existing
                # clip part
                #
                ensight.part.select_begin(3)
                ensight.part.modify_begin()
                ensight.clip.ijk_axis("ON")
                ensight.clip.ijk_scale(1.5)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.ijk_axis({arg_string})"
        return self._session.cmd(cmd)

    def ijk_scale(self, *args, **kwargs) -> Any:
        """Specify the length of the IJK axis for IJK extracts.
        
        | Is only valid for I/J/K plane clips.
        
        Args:
            p0:
                'scale' length of the axis in world coordinates
        
        Examples:
            ::
        
                ensight.part.select_begin(3)
                ensight.part.modify_begin()
                ensight.clip.ijk_axis("ON")
                ensight.clip.ijk_scale(1.5)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.ijk_scale({arg_string})"
        return self._session.cmd(cmd)

    def increment(self, *args, **kwargs) -> Any:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.increment({arg_string})"
        return self._session.cmd(cmd)

    def length(self, *args, **kwargs) -> Any:
        """Clip: length

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.length({arg_string})"
        return self._session.cmd(cmd)

    def line(self, *args, **kwargs) -> Any:
        """Set an end point for a clip line.
        
        | Two end points are necessary to properly define the line location. 
        
        Args:
            p0:
                'end'
        
                * 1 or 2, to set specified line end point
            p1:
                'x_coord' x coordinate of end point
            p2:
                'y_coord' y coordinate of end point
            p3:
                'z_coord' z coordinate of end point
        
        Examples:
            ::
        
                #
                # Select a parent part
                #
                ensight.part.select_begin(2)
                ensight.clip.begin()
                #
                # Create a line clip from
                # {-1, -1, 0} to {1, -1, 0} with
                # 25 evenly spaced points
                #
                ensight.clip.tool("line")
                ensight.clip.pts_on_line(25)
                ensight.clip.line(1,-1,-1,0)
                ensight.clip.line(2,1,-1,0)
                ensight.clip.end()
                ensight.clip.create()
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.line({arg_string})"
        return self._session.cmd(cmd)

    def line_1(self, *args, **kwargs) -> Any:
        """Clip: line 1

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.line_1({arg_string})"
        return self._session.cmd(cmd)

    def line_2(self, *args, **kwargs) -> Any:
        """Clip: line 2

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.line_2({arg_string})"
        return self._session.cmd(cmd)

    def line_nodeid(self, *args, **kwargs) -> Any:
        """Create a clip line defined by the two node ids given.  If the node ids move (transient problem) the clip part must continue to follow the node ids defined.
        
        Args:
            p0:
                'id1' the node ids defining the clip line
            p1:
                'id2' the node ids defining the clip line
        
        Examples:
            ::
        
                #
                # Select the parent part
                #
                ensight.part.select_begin(2)
                ensight.clip.begin()
                #
                # Create a finite clip line using two nodes
                #
                ensight.clip.select_default()
                ensight.part.modify_begin()
                ensight.clip.type("mesh")
                ensight.clip.domain("intersect")
                ensight.clip.extents("infinite")
                ensight.clip.tool("line")
                ensight.clip.line_nodeid(2016,3040)
                ensight.part.modify_end()
                ensight.clip.create()
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.line_nodeid({arg_string})"
        return self._session.cmd(cmd)

    def mesh_plane(self, *args, **kwargs) -> Any:
        """Set the plane for XYZ or IJK clips
        
        | IJK clips can only be created on block structured parts.
        
        Args:
            p0:
                'plane'
        
                * X - Clip of constant X
                * Y - Clip of constant Y
                * Z - Clip of constant Z
                * I - Clip of constant I
                * J - Clip of constant J
                * K - Clip of constant K
                * R - Clip of constant radius
                * T - Clip of constant theta angle (in degrees)
        
        Examples:
            ::
        
                #
                # Select a parent part
                #
                ensight.part.select_begin(2)
                ensight.clip.begin()
                #
                # Create a clip at y=1.5
                #
                ensight.clip.value(1.5)
                ensight.clip.domain("intersect")
                ensight.clip.tool("xyz")
                ensight.clip.mesh_plane("Y")
                ensight.clip.end()
                ensight.clip.create()
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.mesh_plane({arg_string})"
        return self._session.cmd(cmd)

    def number_to_create(self, *args, **kwargs) -> Any:
        """Specify the number of clips, at the specified delta, to create.
        
        | This applies to XYZ and Plane clips, as well as IJK clips on block structured parts.
        | Requires the use of the clip: create_delta <delta> command in conjunction with this command.
        
        Args:
            p0:
                'instances' number of clip instances to create
        
        Examples:
            ::
        
                #
                # Select a parent part
                #
                ensight.part.select_begin(2)
                ensight.clip.begin()
                #
                # Create a clip at y=1.5 and 4 additional instances at .5 delta
                #
                ensight.clip.value(1.5)
                ensight.clip.create_delta(0.5)
                ensight.clip.number_to_create(5)
                ensight.clip.domain("intersect")
                ensight.clip.tool("xyz")
                ensight.clip.mesh_plane("Y")
                ensight.clip.end()
                ensight.clip.create()
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.number_to_create({arg_string})"
        return self._session.cmd(cmd)

    def origin(self, *args, **kwargs) -> Any:
        """Set origin for quadric and revolution clips.
        
        | The origin together with the axis defines the location and orientation of the quadric and revolution tools.
        | The origin and axis define the point and axis about which a 1D part is revolved.
        
        Args:
            p0:
                'x_coord' x, y, z coordinates of origin
            p1:
                'y_coord' x, y, z coordinates of origin
            p2:
                'z_coord' x, y, z coordinates of origin
        
        Examples:
            ::
        
                #
                # Select the parent part
                #
                ensight.part.select_begin(1)
                ensight.clip.begin()
                #
                # Create a cylinder clip
                # defined by the origin at {0. 0. 0}
                # a direction vector of {1, 0, 0}
                # and a radius of 0,5
                #
                ensight.clip.domain("intersect")
                ensight.clip.tool("cylinder")
                ensight.clip.origin(0,0,0)
                ensight.clip.axis(1,0,0)
                ensight.clip.radius(.5)
                ensight.clip.end()
                ensight.clip.create()
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.origin({arg_string})"
        return self._session.cmd(cmd)

    def plane(self, *args, **kwargs) -> Any:
        """Set a corner for a clip plane.
        
        | Three corners are necessary to properly define the plane location.
        
        Args:
            p0:
                'corner'
        
                * 1, 2 or 3, to set specified plane corner
            p1:
                'x_coord' x, y, z coordinates of corner
            p2:
                'y_coord' x, y, z coordinates of corner
            p3:
                'z_coord' x, y, z coordinates of corner
        
        Examples:
            ::
        
                #
                # Select the parent part
                #
                ensight.part.select_begin(2)
                ensight.clip.begin()
                #
                # Create a finite clip plane
                # with corners as defined
                #
                ensight.clip.tool("plane")
                ensight.clip.extents("finite")
                ensight.clip.plane(1,-1,-1,0)
                ensight.clip.plane(2,1,-1,0)
                ensight.clip.plane(3,1,1,0)
                ensight.clip.end()
                ensight.clip.create()
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.plane({arg_string})"
        return self._session.cmd(cmd)

    def plane_1(self, *args, **kwargs) -> Any:
        """Clip: plane 1

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.plane_1({arg_string})"
        return self._session.cmd(cmd)

    def plane_2(self, *args, **kwargs) -> Any:
        """Clip: plane 2

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.plane_2({arg_string})"
        return self._session.cmd(cmd)

    def plane_3(self, *args, **kwargs) -> Any:
        """Clip: plane 3

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.plane_3({arg_string})"
        return self._session.cmd(cmd)

    def plane_nodeid(self, *args, **kwargs) -> Any:
        """Create a clip plane defined by the three node ids given.  If the node ids move (transient problem) the clip part must continue to follow the node ids defined.
        
        Args:
            p0:
                'id1' the node ids defining the clip plane
            p1:
                'id2' the node ids defining the clip plane
            p2:
                'id3' the node ids defining the clip plane
        
        Examples:
            ::
        
                #
                # Select the parent part
                #
                ensight.part.select_begin(2)
                ensight.clip.begin()
                #
                # Create a finite clip plane
                #
                ensight.clip.select_default()
                ensight.part.modify_begin()
                ensight.clip.type("mesh")
                ensight.clip.domain("intersect")
                ensight.clip.extents("infinite")
                ensight.clip.tool("plane")
                ensight.clip.plane_nodeid(2016,3040,3025)
                ensight.part.modify_end()
                ensight.clip.create()
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.plane_nodeid({arg_string})"
        return self._session.cmd(cmd)

    def plane_showsplineqia(self, *args, **kwargs) -> Any:
        """Clip: plane_showsplineqia

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.plane_showsplineqia({arg_string})"
        return self._session.cmd(cmd)

    def point(self, *args, **kwargs) -> Any:
        """Defines points for the surface of revolution.
        
        | There can be at most 10 points in the surface of revolution.
        | Is only used when "clip: tool" is set to "revolution".
        
        Args:
            p0:
                'pt_num' point number
            p1:
                'location' location along the line
            p2:
                'radius' radius at the point location
        
        Examples:
            ::
        
                #
                # Select the parent part
                #
                ensight.part.select_begin(2)
                ensight.clip.begin()
                #
                # Create a clip using a tool
                # of revolution with origin at
                # {.5, .5, 0} and lined up with
                # the x-axis
                #
                ensight.clip.domain("intersect")
                ensight.clip.revolution_points(5)
                ensight.clip.tool("revolution")
                ensight.clip.origin(.5,.5,0)
                ensight.clip.axis(1,0,0)
                ensight.clip.point(1,-1,.5)
                ensight.clip.point(2,0,.7)
                ensight.clip.point(3,1,.5)
                ensight.clip.end()
                ensight.clip.create()
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.point({arg_string})"
        return self._session.cmd(cmd)

    def point_distance(self, *args, **kwargs) -> Any:
        """Clip: point_distance

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.point_distance({arg_string})"
        return self._session.cmd(cmd)

    def point_distance_1(self, *args, **kwargs) -> Any:
        """Clip: point_distance 1

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.point_distance_1({arg_string})"
        return self._session.cmd(cmd)

    def point_distance_10(self, *args, **kwargs) -> Any:
        """Clip: point_distance 10

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.point_distance_10({arg_string})"
        return self._session.cmd(cmd)

    def point_distance_2(self, *args, **kwargs) -> Any:
        """Clip: point_distance 2

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.point_distance_2({arg_string})"
        return self._session.cmd(cmd)

    def point_distance_3(self, *args, **kwargs) -> Any:
        """Clip: point_distance 3

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.point_distance_3({arg_string})"
        return self._session.cmd(cmd)

    def point_distance_4(self, *args, **kwargs) -> Any:
        """Clip: point_distance 4

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.point_distance_4({arg_string})"
        return self._session.cmd(cmd)

    def point_distance_5(self, *args, **kwargs) -> Any:
        """Clip: point_distance 5

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.point_distance_5({arg_string})"
        return self._session.cmd(cmd)

    def point_distance_6(self, *args, **kwargs) -> Any:
        """Clip: point_distance 6

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.point_distance_6({arg_string})"
        return self._session.cmd(cmd)

    def point_distance_7(self, *args, **kwargs) -> Any:
        """Clip: point_distance 7

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.point_distance_7({arg_string})"
        return self._session.cmd(cmd)

    def point_distance_8(self, *args, **kwargs) -> Any:
        """Clip: point_distance 8

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.point_distance_8({arg_string})"
        return self._session.cmd(cmd)

    def point_distance_9(self, *args, **kwargs) -> Any:
        """Clip: point_distance 9

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.point_distance_9({arg_string})"
        return self._session.cmd(cmd)

    def point_radii(self, *args, **kwargs) -> Any:
        """Clip: point_radii

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.point_radii({arg_string})"
        return self._session.cmd(cmd)

    def point_radii_1(self, *args, **kwargs) -> Any:
        """Clip: point_radii 1

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.point_radii_1({arg_string})"
        return self._session.cmd(cmd)

    def point_radii_10(self, *args, **kwargs) -> Any:
        """Clip: point_radii 10

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.point_radii_10({arg_string})"
        return self._session.cmd(cmd)

    def point_radii_2(self, *args, **kwargs) -> Any:
        """Clip: point_radii 2

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.point_radii_2({arg_string})"
        return self._session.cmd(cmd)

    def point_radii_3(self, *args, **kwargs) -> Any:
        """Clip: point_radii 3

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.point_radii_3({arg_string})"
        return self._session.cmd(cmd)

    def point_radii_4(self, *args, **kwargs) -> Any:
        """Clip: point_radii 4

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.point_radii_4({arg_string})"
        return self._session.cmd(cmd)

    def point_radii_5(self, *args, **kwargs) -> Any:
        """Clip: point_radii 5

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.point_radii_5({arg_string})"
        return self._session.cmd(cmd)

    def point_radii_6(self, *args, **kwargs) -> Any:
        """Clip: point_radii 6

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.point_radii_6({arg_string})"
        return self._session.cmd(cmd)

    def point_radii_7(self, *args, **kwargs) -> Any:
        """Clip: point_radii 7

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.point_radii_7({arg_string})"
        return self._session.cmd(cmd)

    def point_radii_8(self, *args, **kwargs) -> Any:
        """Clip: point_radii 8

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.point_radii_8({arg_string})"
        return self._session.cmd(cmd)

    def point_radii_9(self, *args, **kwargs) -> Any:
        """Clip: point_radii 9

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.point_radii_9({arg_string})"
        return self._session.cmd(cmd)

    def points(self, *args, **kwargs) -> Any:
        """Clip: points

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.points({arg_string})"
        return self._session.cmd(cmd)

    def pts_on_line(self, *args, **kwargs) -> Any:
        """Set the number of sample points for a line clip.
        
        Args:
            p0:
                'line_pts' number of linearly spaced sample points for the line clip
        
        Examples:
            ::
        
                #
                # Select an existing line clip
                # and set the number of
                # sample points to 20
                #
                ensight.part.select_begin(3)
                ensight.part.modify_begin()
                ensight.clip.pts_on_line(20)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.pts_on_line({arg_string})"
        return self._session.cmd(cmd)

    def pts_on_spline(self, *args, **kwargs) -> Any:
        """Clip: pts_on_spline

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.pts_on_spline({arg_string})"
        return self._session.cmd(cmd)

    def radius(self, *args, **kwargs) -> Any:
        """Set the radius for a sphere or cylinder clip.
        
        Args:
            p0:
                'value' radius for the sphere or cylinder clip
        
        Examples:
            ::
        
                #
                # Select the parent part
                #
                ensight.part.select_begin(1)
                ensight.clip.begin()
                #
                # Create a cylinder clip of
                # radius=0.5 with origin and
                # axis as shown
                #
                ensight.clip.domain("intersect")
                ensight.clip.tool("cylinder")
                ensight.clip.origin(0,0,0)
                ensight.clip.axis(1,0,0)
                ensight.clip.radius(.5)
                ensight.clip.end()
                ensight.clip.create()
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.radius({arg_string})"
        return self._session.cmd(cmd)

    def revolution_points(self, *args, **kwargs) -> Any:
        """Set the number of points used in the tool of revolution for clipping.
        
        Args:
            p0:
                'number' number of points used for the revolution tool
        
        Examples:
            ::
        
                #
                # Select the parent part
                #
                ensight.part.select_begin(2)
                ensight.clip.begin()
                #
                # Create a clip of revolution
                # with five defined points
                #
                ensight.clip.domain("intersect")
                ensight.clip.revolution_points(5.0000e+00)
                ensight.clip.tool("revolution")
                ensight.clip.origin(5.0000e-01,5.0000e-01,1.0000e+00)
                ensight.clip.axis(1.0000e+00,0.0000e+00,0.0000e+00)
                ensight.clip.point(1,-1.2500e+00,5.0000e-01)
                ensight.clip.point(2,-6.2500e-01,5.0000e-01)
                ensight.clip.point(3,0.0000e+00,1.0000e+00)
                ensight.clip.point(4,6.2500e-01,5.0000e-01)
                ensight.clip.point(5,1.2500e+00,5.0000e-01)
                ensight.clip.end()
                ensight.clip.create()
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.revolution_points({arg_string})"
        return self._session.cmd(cmd)

    def revolve_part(self, *args, **kwargs) -> Any:
        """Clip by revolving a 1D part about an axis.
        
        | The end points for the 1D part are effectively extended to infinity during the clip.
        | The part is revolved around the defined origin and axis.
        
        Args:
            p0:
                'part_id' part ID number to revolve
        
        Examples:
            ::
        
                #
                # Select an existing clip part
                #
                ensight.part.select_begin(3)
                ensight.part.modify_begin()
                #
                # Revolve 1D part 4
                # about an axis
                #
                ensight.clip.tool("1d_part")
                ensight.clip.revolve_part(4)
                ensight.clip.origin(-2.4838e-01,-2.3340e-01,1.8757e+00)
                ensight.clip.axis(0.0000e+00,1.0000e+00,0.0000e+00)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.revolve_part({arg_string})"
        return self._session.cmd(cmd)

    def revolve_partbyname(self, *args, **kwargs) -> Any:
        """Clip by revolving a 1D part about an axis.
        
        | This command is functionally the same as "clip: revolve_part" except it takes a part name as the argument instead of a part id.
        | The end points for the 1D part are effectively extended to infinity during the clip. 
        | The part is revolved around the defined origin and axis.
        
        Args:
            p0:
                'part_name' part name to revolve
        
        Examples:
            ::
        
                #
                # Select an existing clip part
                #
                ensight.part.select_begin(3)
                ensight.part.modify_begin()
                #
                # Revolve part "clip line" about an axis
                #
                ensight.clip.tool("1d_part")
                ensight.clip.revolve_part("clip","line")
                ensight.clip.origin(-2.4838e-01,-2.3340e-01,1.8757e+00)
                ensight.clip.axis(0.0000e+00,1.0000e+00,0.0000e+00)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.revolve_partbyname({arg_string})"
        return self._session.cmd(cmd)

    def rtz_axis(self, *args, **kwargs) -> Any:
        """Specify the axis to be used for RTZ clips. Theta is about this axis.
        
        | The axis is in reference to the frame associated with the parent part(s).
        
        Args:
            p0:
                'axis'
        
                * X  
                * Y
                * Z
        
        Examples:
            ::
        
                #
                # Select a parent part
                #
                ensight.part.select_begin(2)
                ensight.clip.begin()
                #
                # Create a Z RTZ clip about the Z axis at Z=0.
                #
                ensight.clip.tool("rtz")
                ensight.clip.rtz_axis("Z")
                ensight.clip.value(0.)
                ensight.clip.domain("intersect")
                ensight.clip.mesh_plane("Z")
                ensight.clip.end()
                ensight.clip.create()
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.rtz_axis({arg_string})"
        return self._session.cmd(cmd)

    def sample(self, *args, **kwargs) -> Any:
        """Clip: sample

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.sample({arg_string})"
        return self._session.cmd(cmd)

    def sample_step(self, *args, **kwargs) -> Any:
        """Clip: sample_step

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.sample_step({arg_string})"
        return self._session.cmd(cmd)

    def select_default(self, *args, **kwargs) -> Any:
        """Sets the target to the default settings for subsequent attribute modifications.
        
        Examples:
            ::
        
                #
                # Set the default clip tool to cylinder
                #
                ensight.clip.select_default()
                ensight.part.modify_begin()
                ensight.clip.tool("cylinder")
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.select_default({arg_string})"
        return self._session.cmd(cmd)

    def slider_range_ijk(self, *args, **kwargs) -> Any:
        """Set the I, J, or K range through which an IJK clip part will be modified when in interactive mode, whether using the slider in Manual mode or in Auto or Auto Cycle mode.
        
        | Is only used for interactive clips.
        
        Args:
            p0:
                'beg_ijk' beginning I, J, or K plane of range.
            p1:
                'end_ijk' ending I, J, or K plane of range.
        
        Examples:
            ::
        
                #
                # Set the slider ijk range for an
                # existing IJK clip plane to be within 5 and 35
                #
                ensight.part.select_begin(2)
                ensight.part.modify_begin()
                ensight.clip.tool("ijk")
                ensight.clip.slider_range_ijk(5,35)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.slider_range_ijk({arg_string})"
        return self._session.cmd(cmd)

    def slider_step(self, *args, **kwargs) -> Any:
        """Set the value that a X/Y/Z clip part is modified when in interactive mode and the user interface less/greater buttons are selected.
        
        | A negative step value is used when the less button is selected while a positive step value is used when the greater button is selected.
        | Is only used for interactive clips.
        
        Args:
            p0:
                'step_increment' step increment of slider
        
        Examples:
            ::
        
                #
                # Set the step increment for an
                # existing clip plane to 1.0
                #
                ensight.part.select_begin(3)
                ensight.part.modify_begin()
                ensight.clip.tool("xyz")
                ensight.clip.slider_step(1.0)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.slider_step({arg_string})"
        return self._session.cmd(cmd)

    def slider_step_ijk(self, *args, **kwargs) -> Any:
        """Set the value that an IJK clip part is modified when in interactive mode and the user interface less/greater buttons are selected.
        
        | A negative step value is used when the less button is selected while a positive step value is used when the greater button is selected.
        | Is only used for interactive clips.
        
        Args:
            p0:
                'step_increment' step increment of slider
        
        Examples:
            ::
        
                #
                # Set the step increment for an
                # existing IJK clip plane to 3
                #
                ensight.part.select_begin(2)
                ensight.part.modify_begin()
                ensight.clip.tool("ijk")
                ensight.clip.slider_step_ijk(3)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.slider_step_ijk({arg_string})"
        return self._session.cmd(cmd)

    def slider_x(self, *args, **kwargs) -> Any:
        """Set the min/max X/Y/Z extents in the user interface for a clip of constant X/Y/Z.
        
        | Is only used for interactive clips.
        
        Args:
            p0:
                'min_value' minimum slider value
            p1:
                'max_value' maximum slider value
        
        Examples:
            ::
        
                #
                # Set the min/max slider value for
                # a clip of constant X
                #
                ensight.part.select_begin(3)
                ensight.part.modify_begin()
                ensight.clip.slider_x(-1,4)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.slider_x({arg_string})"
        return self._session.cmd(cmd)

    def slider_y(self, *args, **kwargs) -> Any:
        """Set the min/max X/Y/Z extents in the user interface for a clip of constant X/Y/Z.
        
        | Is only used for interactive clips.
        
        Args:
            p0:
                'min_value' minimum slider value
            p1:
                'max_value' maximum slider value
        
        Examples:
            ::
        
                #
                # Set the min/max slider value for
                # a clip of constant X
                #
                ensight.part.select_begin(3)
                ensight.part.modify_begin()
                ensight.clip.slider_x(-1,4)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.slider_y({arg_string})"
        return self._session.cmd(cmd)

    def slider_z(self, *args, **kwargs) -> Any:
        """Set the min/max X/Y/Z extents in the user interface for a clip of constant X/Y/Z.
        
        | Is only used for interactive clips.
        
        Args:
            p0:
                'min_value' minimum slider value
            p1:
                'max_value' maximum slider value
        
        Examples:
            ::
        
                #
                # Set the min/max slider value for
                # a clip of constant X
                #
                ensight.part.select_begin(3)
                ensight.part.modify_begin()
                ensight.clip.slider_x(-1,4)
                ensight.part.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.slider_z({arg_string})"
        return self._session.cmd(cmd)

    def spline_id(self, *args, **kwargs) -> Any:
        """Clip: spline_id

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.spline_id({arg_string})"
        return self._session.cmd(cmd)

    def spline_location(self, *args, **kwargs) -> Any:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.spline_location({arg_string})"
        return self._session.cmd(cmd)

    def spline_name(self, *args, **kwargs) -> Any:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.spline_name({arg_string})"
        return self._session.cmd(cmd)

    def tool(self, *args, **kwargs) -> Any:
        """Set the clipping tool.
        
        | ijk extract can only occur using a single parent part.
        
        Args:
            p0:
                'tool_type'
        
                * 1d_part
                * cone
                * cylinder
                * general_quadric
                * ijk  
                * line
                * plane
                * revolution
                * rtz
                * sphere
                * xyz
                * xyz_box
        
        Examples:
            ::
        
                #
                # Select the parent part
                #
                ensight.part.select_begin(2)
                ensight.clip.begin()
                ensight.clip.domain("inside")
                ensight.clip.tool("cylinder")
                ensight.clip.origin(-1.,0,1.)
                ensight.clip.axis(1,0,0)
                ensight.clip.radius(.75)
                ensight.clip.end()
                ensight.clip.create()
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.tool({arg_string})"
        return self._session.cmd(cmd)

    def type(self, *args, **kwargs) -> Any:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.type({arg_string})"
        return self._session.cmd(cmd)

    def update_to_newtoollocation(self, *args, **kwargs) -> Any:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.update_to_newtoollocation({arg_string})"
        return self._session.cmd(cmd)

    def value(self, *args, **kwargs) -> Any:
        """Specify the constant plane value for XYZ or IJK clips.
        
        | For IJK clips the plane_value must be an integer.
        
        Args:
            p0:
                'plane_value' value for the plane
        
        Examples:
            ::
        
                #
                # Select the parent part
                #
                ensight.part.select_begin(2)
                ensight.clip.begin()
                #
                # Create a clip of y=1.5
                #
                ensight.clip.value(1.5)
                ensight.clip.domain("intersect")
                ensight.clip.tool("xyz")
                ensight.clip.mesh_plane("Y")
                ensight.clip.end()
                ensight.clip.create()
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.value({arg_string})"
        return self._session.cmd(cmd)

    def x_max_infinite(self, *args, **kwargs) -> Any:
        """Clip: x_max_infinite

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.x_max_infinite({arg_string})"
        return self._session.cmd(cmd)

    def x_min_infinite(self, *args, **kwargs) -> Any:
        """Clip: x_min_infinite

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.x_min_infinite({arg_string})"
        return self._session.cmd(cmd)

    def y_max_infinite(self, *args, **kwargs) -> Any:
        """Clip: y_max_infinite

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.y_max_infinite({arg_string})"
        return self._session.cmd(cmd)

    def y_min_infinite(self, *args, **kwargs) -> Any:
        """Clip: y_min_infinite

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.y_min_infinite({arg_string})"
        return self._session.cmd(cmd)

    def z_max_infinite(self, *args, **kwargs) -> Any:
        """Clip: z_max_infinite

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.z_max_infinite({arg_string})"
        return self._session.cmd(cmd)

    def z_min_infinite(self, *args, **kwargs) -> Any:
        """Clip: z_min_infinite

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.clip.z_min_infinite({arg_string})"
        return self._session.cmd(cmd)


class case:
    """Class wrapper for EnSight case module

    This class acts as a proxy for the EnSight Python module ensight.case
    """
    def __init__(self, session: Session):
        self._session = session

    def add(self, p0: str) -> int:
        """Add another case dataset to your current EnSight session.
        
        | By default the new case names are called "Case #" where the # is the next available case # - 1 based.
        
        Args:
            p0:
                'case_id' id of the new case (see Notes below)
        
        Examples:
            ::
        
                ensight.case.create_viewport("ON")
                ensight.case.apply_context("OFF")
                ensight.case.reflect_model_in("'none'")
                ensight.case.add("Case 2")
                ensight.case.select("Case 2")
                ensight.viewport.select_begin(1)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.case.add({repr(p0)})'''
        return self._session.cmd(cmd)

    def apply_context(self, p0: str) -> int:
        """Specify whether to apply context from the initial case when adding another new case.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.case.create_viewport("ON")
                ensight.case.apply_context("ON")
                ensight.case.reflect_model_in("'none'")
                ensight.case.add("Case 2")
                ensight.case.select("Case 2")
                ensight.viewport.select_begin(1)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.case.apply_context({repr(p0)})'''
        return self._session.cmd(cmd)

    def case_linking(self, p0: str) -> int:
        """Case: case_linking

        """
        cmd = f'''ensight.case.case_linking({repr(p0)})'''
        return self._session.cmd(cmd)

    def case_linking_labels(self, p0: str) -> int:
        """Case: case_linking_labels

        """
        cmd = f'''ensight.case.case_linking_labels({repr(p0)})'''
        return self._session.cmd(cmd)

    def create_viewport(self, p0: str) -> int:
        """Specify whether to create another viewport in which to display the new case when adding a new case.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.case.create_viewport("ON")
                ensight.case.apply_context("OFF")
                ensight.case.reflect_model_in("'none'")
                ensight.case.add("Case 2")
                ensight.case.select("Case 2")
                ensight.viewport.select_begin(1)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.case.create_viewport({repr(p0)})'''
        return self._session.cmd(cmd)

    def delete(self, p0: str) -> int:
        """Delete the currently selected case dataset from your current EnSight session.
        
        | By default the new case names are called "Case #" where the # is the next available case # - 1 based.
        
        Args:
            p0:
                'case_id' id of the new case (see Notes below)
        
        Examples:
            ::
        
                #
                # select case 2 for deletion
                #
                ensight.case.select("2")
                #
                # delete case 2
                #
                ensight.case.delete("2")
                #
                # select case 1 as current, or default
                #
                ensight.case.select("1")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.case.delete({repr(p0)})'''
        return self._session.cmd(cmd)

    def limit_list_percase(self, p0: str) -> int:
        """Case: limit_list_percase

        """
        cmd = f'''ensight.case.limit_list_percase({repr(p0)})'''
        return self._session.cmd(cmd)

    def link_modelparts_byname(self, p0: str) -> int:
        """Case: link_modelparts_byname

        """
        cmd = f'''ensight.case.link_modelparts_byname({repr(p0)})'''
        return self._session.cmd(cmd)

    def linked(self, p0: str) -> int:
        """Case: linked

        """
        cmd = f'''ensight.case.linked({repr(p0)})'''
        return self._session.cmd(cmd)

    def reflect_model_in(self, p0: str) -> int:
        """Specify whether to apply a mirror transform when adding a new case.
        
        | The reflection transform occurs about the point specifies via the "reflect_model_origin" command.
        
        Args:
            p0:
                'option' Includes the following options:
            p1:
                'option' 'none'
            p2:
                'option' 'X'
            p3:
                'option' 'Y'
            p4:
                'option' 'Z'
            p5:
                'option' 'X''Y'
        
        Examples:
            ::
        
                ensight.case.create_viewport("ON")
                ensight.case.apply_context("OFF")
                ensight.case.reflect_model_in("'Z'")
                ensight.case.add("Case 2")
                ensight.case.select("Case 2")
                ensight.viewport.select_begin(1)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.case.reflect_model_in({repr(p0)})'''
        return self._session.cmd(cmd)

    def reflect_model_origin(self, p0: float, p1: float, p2: float) -> int:
        """Specify the model origin about which to reflect the newly added case
        
        | Default origin is 0., 0., 0.
        | Used with the "reflect_model_in" command.
        
        Args:
            p0:
                'x_comp' x component of the origin (in model coordinates) about which to reflect the new case dataset
            p1:
                'y_comp' y component of the origin (in model coordinates) about which to reflect the new case dataset
            p2:
                'z_comp' z component of the origin (in model coordinates) about which to reflect the new case dataset
        
        Examples:
            ::
        
                ensight.case.create_viewport("ON")
                ensight.case.apply_context("OFF")
                ensight.case.reflect_model_in("'X'")
                ensight.case.reflect_model_in("1.0000e+00 0.0000e+00 0.0000e+00")
                ensight.case.add("Case 2")
                ensight.case.select("Case 2")
                ensight.viewport.select_begin(1)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.case.reflect_model_origin({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def rename(self, p0: str, p1: str) -> int:
        """Case: rename

        """
        cmd = f'''ensight.case.rename({repr(p0)},{repr(p1)})'''
        return self._session.cmd(cmd)

    def replace(self, p0: str, p1: str) -> int:
        """Replace the current selected case dataset with another case dataset.
        
        | By default the new case names are called "Case #" where the # is the next available case # - 1 based.
        
        Args:
            p0:
                'old_value' name of the case to be replaced
            p1:
                'new_value' name (id) of the case replacing the old string value
        
        Examples:
            ::
        
                #
                # select 2nd case
                #
                ensight.case.select("Case 2")
                #
                # replace 2nd case w/2nd case
                #
                ensight.case.replace("Case 2")
                #
                # select 2nd case 'Case 2'
                #
                ensight.case.select("Case 2")
        
            ::
        
                #
                # select 2nd case
                #
                ensight.case.select("Case 2")
                #
                # replace 2nd case w/3rd case
                #
                ensight.case.replace("Case 2","Case 3")
                #
                # select 2nd case
                #
                ensight.case.select("Case 3")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.case.replace({repr(p0)},{repr(p1)})'''
        return self._session.cmd(cmd)

    def select(self, p0: str) -> int:
        """Specify current (active) case.
        
        | Many operations depend on the active case, such as dataset queries.
        
        Args:
            p0:
                'case_id' id of the active case
        
        Examples:
            ::
        
                ensight.case.select("Case 2")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.case.select({repr(p0)})'''
        return self._session.cmd(cmd)

    def sft_brightness(self, p0: float) -> int:
        """Case: sft_brightness

        """
        cmd = f'''ensight.case.sft_brightness({repr(p0)})'''
        return self._session.cmd(cmd)

    def sft_contrast(self, p0: str) -> int:
        """Case: sft_contrast

        """
        cmd = f'''ensight.case.sft_contrast({repr(p0)})'''
        return self._session.cmd(cmd)

    def sft_density(self, p0: float) -> int:
        """Case: sft_density

        """
        cmd = f'''ensight.case.sft_density({repr(p0)})'''
        return self._session.cmd(cmd)

    def sft_length(self, p0: float) -> int:
        """Case: sft_length

        """
        cmd = f'''ensight.case.sft_length({repr(p0)})'''
        return self._session.cmd(cmd)

    def sft_norm_length(self, p0: float) -> int:
        """Case: sft_norm_length

        """
        cmd = f'''ensight.case.sft_norm_length({repr(p0)})'''
        return self._session.cmd(cmd)

    def sft_norm_step(self, p0: float) -> int:
        """Case: sft_norm_step

        """
        cmd = f'''ensight.case.sft_norm_step({repr(p0)})'''
        return self._session.cmd(cmd)

    def sft_normalize_vector(self, p0: str) -> int:
        """Case: sft_normalize_vector

        """
        cmd = f'''ensight.case.sft_normalize_vector({repr(p0)})'''
        return self._session.cmd(cmd)

    def sft_step(self, p0: float) -> int:
        """Case: sft_step

        """
        cmd = f'''ensight.case.sft_step({repr(p0)})'''
        return self._session.cmd(cmd)

    def sft_variable(self, p0: Any) -> int:
        """Case: sft_variable

        """
        cmd = f'''ensight.case.sft_variable({repr(p0)})'''
        return self._session.cmd(cmd)

    def timeline_controller(self, p0: str) -> int:
        """Case: timeline_controller

        """
        cmd = f'''ensight.case.timeline_controller({repr(p0)})'''
        return self._session.cmd(cmd)

    def timeline_sync(self, p0: str, p1: str) -> int:
        """Case: timeline_sync

        """
        cmd = f'''ensight.case.timeline_sync({repr(p0)},{repr(p1)})'''
        return self._session.cmd(cmd)

    def update_with_timechange(self, p0: str) -> int:
        """Case: update_with_timechange

        """
        cmd = f'''ensight.case.update_with_timechange({repr(p0)})'''
        return self._session.cmd(cmd)

    def viewports(self, p0: str) -> int:
        """Specify which viewport in which to display the data from a case.
        
        | The active case is modified (see "case: select").
        
        Args:
            p0:
                'vp#' viewport integer # in I[1,N] which correspond to the respective viewports in which case data is to be displayed. N is the number of active viewports.
        
        Examples:
            ::
        
                #
                # Preliminary setup (for reference) - given two viewports
                #
                ensight.viewport.select_begin(0)
                ensight.view_transf.function("global")
                ensight.viewport.viewport_layout("two_horizontal")
                ensight.viewport.select_begin(1)
                #
                # Displaying a case in both viewports
                #
                ensight.case.viewports("1 2")
                #
                # Displaying a case in only the first viewport
                ensight.case.viewports("case  1")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.case.viewports({repr(p0)})'''
        return self._session.cmd(cmd)


class boundarylayer:
    """Class wrapper for EnSight boundarylayer module

    This class acts as a proxy for the EnSight Python module ensight.boundarylayer
    """
    def __init__(self, session: Session):
        self._session = session

    def create_update(self) -> int:
        """Specify to create or update the boundary-layer variables on the selected 2D part(s).
        
        Examples:
            ::
        
                ensight.part.select_begin(2)
                ensight.boundarylayer.create_update()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.boundarylayer.create_update()'''
        return self._session.cmd(cmd)

    def density(self, p0: Any) -> int:
        """Specify the density variable to use in creating/updating the boundary-layer variables.
        
        | This variable gets assigned automatically if the variable name "Density" exists.  Since the computation of separation and attachment lines depend on velocity, either the velocity variable must be defined or both the density and momentum variables must be defined to obtain the velocity variable.
        
        Args:
            p0:
                'variable_name' name of the density variable (the default name "none" means to use nothing)
        
        Examples:
            ::
        
                ensight.boundarylayer.modify_begin()
                ensight.boundarylayer.density("Density")
                ensight.boundarylayer.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.boundarylayer.density({repr(p0)})'''
        return self._session.cmd(cmd)

    def determine_velocity_by(self, p0: str) -> int:
        """Specify how to assign the velocity just outside the boundary layer in calculating the boundary-layer variables.
        
        Args:
            p0:
                'option'
        
                * convergence_criteria 
                * distance_from_surface
                * velocity_magnitude
        
        Examples:
            ::
        
                ensight.boundarylayer.determine_velocity_by("distance_from_surface")
                ensight.boundarylayer.normal_distance(1.0000e-03)
                ensight.part.select_begin(2)
                ensight.boundarylayer.create_update()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.boundarylayer.determine_velocity_by({repr(p0)})'''
        return self._session.cmd(cmd)

    def dynamic_viscosity(self, args: Any) -> int:
        """Specify the dynamic viscosity constant value or variable name to use in creating/updating the boundary-layer variables.
        
        | The <value> can be multiple types depending on variable definition. This variable is required to compute the fluid shear stress of the fluid for the skin-friction coefficient variable.
        
        Args:
            p0:
                'value' the scalar field variable name for the dynamic viscosity
            p1:
                'value' a constant value (default = 1.8300e-05) for the dynamic viscosity
        
        Examples:
            ::
        
                ensight.boundarylayer.modify_begin()
                ensight.boundarylayer.dynamic_viscosity(1.8300e-05)
                ensight.boundarylayer.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.boundarylayer.dynamic_viscosity({repr(args)})'''
        return self._session.cmd(cmd)

    def freestream_density(self, args: Any) -> int:
        """Specify the freestream density constant value to use in creating/updating the boundary-layer variables.
        
        | This variable is required to compute the skin-friction coefficient variable.
        
        Args:
            p0:
                'density_value' constant value (default = 1.) for the freestream density
        
        Examples:
            ::
        
                ensight.boundarylayer.modify_begin()
                ensight.boundarylayer.freestream_density(9.0000e-01)
                ensight.boundarylayer.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.boundarylayer.freestream_density({repr(args)})'''
        return self._session.cmd(cmd)

    def freestream_velocity(self, args: Any) -> int:
        """Specify the freestream velocity constant value to use in creating/updating the boundary-layer variables.
        
        | This variable is required to compute the skin-friction coefficient variable.
        
        Args:
            p0:
                'velocity_value' a constant value (default = 1.) for the freestream velocity
        
        Examples:
            ::
        
                ensight.boundarylayer.modify_begin()
                ensight.boundarylayer.freestream_velocity(8.8500e-01)
                ensight.boundarylayer.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.boundarylayer.freestream_velocity({repr(args)})'''
        return self._session.cmd(cmd)

    def max_procsteps(self, p0: int, p1: int) -> int:
        """Boundarylayer: max_procsteps

        """
        cmd = f'''ensight.boundarylayer.max_procsteps({repr(p0)},{repr(p1)})'''
        return self._session.cmd(cmd)

    def modify_begin(self) -> int:
        """Specify the execute construct within which to define a dependent variable used in computing the boundary-layer variables.
        
        Args:
            p0:
                'command' boundary layer variable command to define or update
        
        Examples:
            ::
        
                ensight.boundarylayer.modify_begin()
                ensight.boundarylayer.freestream_velocity(8.8500e-01)
                ensight.boundarylayer.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.boundarylayer.modify_begin()'''
        return self._session.cmd(cmd)

    def modify_end(self) -> int:
        """Specify the execute construct within which to define a dependent variable used in computing the boundary-layer variables.
        
        Args:
            p0:
                'command' boundary layer variable command to define or update
        
        Examples:
            ::
        
                ensight.boundarylayer.modify_begin()
                ensight.boundarylayer.freestream_velocity(8.8500e-01)
                ensight.boundarylayer.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.boundarylayer.modify_end()'''
        return self._session.cmd(cmd)

    def momentum(self, p0: Any) -> int:
        """Specify the momentum variable to use in creating/updating the boundary-layer variables.
        
        | This variable gets assigned automatically if the variable name <momentum> exists. Since the computation of boundary-layer variables depend on velocity, either the velocity variable must be defined or both the density and momentum variables must be defined to obtain the velocity variable.
        
        Args:
            p0:
                'variable_name' name of the momentum variable (the default name <none> means to use nothing)
        
        Examples:
            ::
        
                ensight.boundarylayer.modify_begin()
                ensight.boundarylayer.momentum("none")
                ensight.boundarylayer.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.boundarylayer.momentum({repr(p0)})'''
        return self._session.cmd(cmd)

    def normal_distance(self, p0: float) -> int:
        """Specify the distance normal from the surface in which to determine the velocity just outside the boundary layer in order to compute the boundary-layer variables at each node on the surface.
        
        | Only used for the boundarylayer: determine_velocity_by distance_from_surface option.
        
        Args:
            p0:
                'distance_value' distance from the surface at which to compute the velocity just outside the boundary layer
        
        Examples:
            ::
        
                ensight.boundarylayer.determine_velocity_by("distance_from_surface")
                ensight.boundarylayer.normal_distance(1.0000e+00)
                ensight.part.select_begin(2)
                ensight.boundarylayer.create_update()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.boundarylayer.normal_distance({repr(p0)})'''
        return self._session.cmd(cmd)

    def velocity(self, p0: Any) -> int:
        """Specify the velocity variable to use in creating/updating the boundary-layer variables.
        
        | This variable gets assigned automatically if the variable name <Velocity> exists. Since the computation of boundary-layer variables depend on velocity, either the velocity variable must be defined or both the density and momentum variables must be defined to obtain the velocity variable.
        
        Args:
            p0:
                'variable_name' name of the velocity variable (the default name <none> means to use nothing)
        
        Examples:
            ::
        
                ensight.boundarylayer.modify_begin()
                ensight.boundarylayer.velocity("Velocity")
                ensight.boundarylayer.modify_end()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.boundarylayer.velocity({repr(p0)})'''
        return self._session.cmd(cmd)

    def velocity_magnitude(self, p0: float) -> int:
        """Specify the velocity magnitude normal at which to determine the velocity just outside the boundary layer in order to compute the boundary-layer variables at each node on the surface.
        
        | Only used for the boundarylayer: determine_velocity_by distance_from_surface option.
        
        Args:
            p0:
                'velocity_value' velocity magnitude at which to assign the velocity just outside the boundary layer
        
        Examples:
            ::
        
                ensight.boundarylayer.determine_velocity_by("velocity_magnitude")
                ensight.boundarylayer.velocity_magnitude(1.0000e+00)
                ensight.part.select_begin(2)
                ensight.boundarylayer.create_update()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.boundarylayer.velocity_magnitude({repr(p0)})'''
        return self._session.cmd(cmd)


class auxgeom:
    """Class wrapper for EnSight auxgeom module

    This class acts as a proxy for the EnSight Python module ensight.auxgeom
    """
    def __init__(self, session: Session):
        self._session = session

    def begin(self) -> int:
        """Auxgeom: begin

        """
        cmd = f'''ensight.auxgeom.begin()'''
        return self._session.cmd(cmd)

    def create(self) -> int:
        """Auxgeom: create

        """
        cmd = f'''ensight.auxgeom.create()'''
        return self._session.cmd(cmd)

    def end(self) -> int:
        """Auxgeom: end

        """
        cmd = f'''ensight.auxgeom.end()'''
        return self._session.cmd(cmd)

    def mesh_resolution(self, p0: int) -> int:
        """Auxgeom: mesh_resolution

        """
        cmd = f'''ensight.auxgeom.mesh_resolution({repr(p0)})'''
        return self._session.cmd(cmd)

    def normals_point(self, p0: str) -> int:
        """Auxgeom: normals_point

        """
        cmd = f'''ensight.auxgeom.normals_point({repr(p0)})'''
        return self._session.cmd(cmd)

    def origin(self, p0: float, p1: float, p2: float) -> int:
        """Auxgeom: origin

        """
        cmd = f'''ensight.auxgeom.origin({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def select_default(self) -> int:
        """Auxgeom: select_default

        """
        cmd = f'''ensight.auxgeom.select_default()'''
        return self._session.cmd(cmd)

    def show_outline(self, p0: str) -> int:
        """Auxgeom: show_outline

        """
        cmd = f'''ensight.auxgeom.show_outline({repr(p0)})'''
        return self._session.cmd(cmd)

    def show_plane_xmax(self, p0: str) -> int:
        """Auxgeom: show_plane_xmax

        """
        cmd = f'''ensight.auxgeom.show_plane_xmax({repr(p0)})'''
        return self._session.cmd(cmd)

    def show_plane_xmin(self, p0: str) -> int:
        """Auxgeom: show_plane_xmin

        """
        cmd = f'''ensight.auxgeom.show_plane_xmin({repr(p0)})'''
        return self._session.cmd(cmd)

    def show_plane_ymax(self, p0: str) -> int:
        """Auxgeom: show_plane_ymax

        """
        cmd = f'''ensight.auxgeom.show_plane_ymax({repr(p0)})'''
        return self._session.cmd(cmd)

    def show_plane_ymin(self, p0: str) -> int:
        """Auxgeom: show_plane_ymin

        """
        cmd = f'''ensight.auxgeom.show_plane_ymin({repr(p0)})'''
        return self._session.cmd(cmd)

    def show_plane_zmax(self, p0: str) -> int:
        """Auxgeom: show_plane_zmax

        """
        cmd = f'''ensight.auxgeom.show_plane_zmax({repr(p0)})'''
        return self._session.cmd(cmd)

    def show_plane_zmin(self, p0: str) -> int:
        """Auxgeom: show_plane_zmin

        """
        cmd = f'''ensight.auxgeom.show_plane_zmin({repr(p0)})'''
        return self._session.cmd(cmd)

    def size(self, p0: float, p1: float, p2: float) -> int:
        """Auxgeom: size

        """
        cmd = f'''ensight.auxgeom.size({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def type(self, p0: str) -> int:
        """Auxgeom: type

        """
        cmd = f'''ensight.auxgeom.type({repr(p0)})'''
        return self._session.cmd(cmd)

    def use_doublesided_walls(self, p0: str) -> int:
        """Auxgeom: use_doublesided_walls

        """
        cmd = f'''ensight.auxgeom.use_doublesided_walls({repr(p0)})'''
        return self._session.cmd(cmd)

    def wall_thickness(self, p0: float) -> int:
        """Auxgeom: wall_thickness

        """
        cmd = f'''ensight.auxgeom.wall_thickness({repr(p0)})'''
        return self._session.cmd(cmd)


class arrow:
    """Class wrapper for EnSight arrow module

    This class acts as a proxy for the EnSight Python module ensight.arrow
    """
    def __init__(self, session: Session):
        self._session = session

    def annotation_text_id(self, p0: int) -> int:
        """Arrow: annotation_text_id

        """
        cmd = f'''ensight.arrow.annotation_text_id({repr(p0)})'''
        return self._session.cmd(cmd)

    def append_locationvalue(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.arrow.append_locationvalue({repr(p0)})'''
        return self._session.cmd(cmd)

    def append_probe_value(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.arrow.append_probe_value({repr(p0)})'''
        return self._session.cmd(cmd)

    def delete(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.arrow.delete()'''
        return self._session.cmd(cmd)

    def description(self, p0: str) -> int:
        """Arrow: description

        """
        cmd = f'''ensight.arrow.description({repr(p0)})'''
        return self._session.cmd(cmd)

    def deselect_all(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.arrow.deselect_all()'''
        return self._session.cmd(cmd)

    def label_offset(self, p0: float) -> int:
        """Specifies the distance the label is offset from the end of the selected 3D arrow(s).
        
        Args:
            p0:
                'distance' distance the label is offset from the end of the arrow
        
        Examples:
            ::
        
                ensight.arrow.new_arrow()
                ensight.arrow.select_begin(0)
                ensight.arrow.label_text("Label")
                ensight.arrow.visible("ON")
                ensight.arrow.origin_by("XYZ")
                ensight.arrow.location(0.000000e+000,0.000000e+000,2.000000e+000)
                ensight.arrow.normal(0.000000e+000,0.000000e+000,-1.000000e+000)
                ensight.arrow.offset(5.000000e-001)
                ensight.arrow.size(1.500000e+000)
                ensight.arrow.radius(1.250000e-001)
                ensight.arrow.tip_length(3.000000e-001)
                ensight.arrow.tip_radius(2.250000e+000)
                ensight.arrow.rgb(1.000000e+000,1.000000e+000,0.000000e+000)
                ensight.arrow.light_shin(9.000000e+000)
                ensight.arrow.light_h_int(4.700000e-001)
                ensight.arrow.light_diff(2.100000e-001)
                ensight.arrow.label_rgb(0.000000e+000,1.000000e+000,0.000000e+000)
                ensight.arrow.label_size(3.600000e+001)
                ensight.arrow.label_offset(.5)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.arrow.label_offset({repr(p0)})'''
        return self._session.cmd(cmd)

    def label_rgb(self, p0: float, p1: float, p2: float) -> int:
        """Specifies the rgb components of the color of the label of the selected 3D arrow(s).
        
        Args:
            p0:
                'red_val' red, green, blue components of the color (0.0 to 1.0)
            p1:
                'grn_val' red, green, blue components of the color (0.0 to 1.0)
            p2:
                'blu_val' red, green, blue components of the color (0.0 to 1.0)
        
        Examples:
            ::
        
                ensight.arrow.new_arrow()
                ensight.arrow.select_begin(0)
                ensight.arrow.label_text("Label")
                ensight.arrow.visible("ON")
                ensight.arrow.origin_by("XYZ")
                ensight.arrow.location(0.000000e+000,0.000000e+000,2.000000e+000)
                ensight.arrow.normal(0.000000e+000,0.000000e+000,-1.000000e+000)
                ensight.arrow.offset(5.000000e-001)
                ensight.arrow.size(1.500000e+000)
                ensight.arrow.radius(1.250000e-001)
                ensight.arrow.tip_length(3.000000e-001)
                ensight.arrow.tip_radius(2.250000e+000)
                ensight.arrow.rgb(1.000000e+000,1.000000e+000,0.000000e+000)
                ensight.arrow.light_shin(9.000000e+000)
                ensight.arrow.light_h_int(4.700000e-001)
                ensight.arrow.light_diff(2.100000e-001)
                ensight.arrow.label_rgb(0.000000e+000,1.000000e+000,0.000000e+000)
                ensight.arrow.label_size(3.600000e+001)
                ensight.arrow.label_offset(.5)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.arrow.label_rgb({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def label_size(self, p0: int) -> int:
        """Specifies the font size of the label of the selected 3D arrow(s).
        
        Args:
            p0:
                'size' font size for the arrow label
        
        Examples:
            ::
        
                ensight.arrow.new_arrow()
                ensight.arrow.select_begin(0)
                ensight.arrow.label_text("Label")
                ensight.arrow.visible("ON")
                ensight.arrow.origin_by("XYZ")
                ensight.arrow.location(0.000000e+000,0.000000e+000,2.000000e+000)
                ensight.arrow.normal(0.000000e+000,0.000000e+000,-1.000000e+000)
                ensight.arrow.offset(5.000000e-001)
                ensight.arrow.size(1.500000e+000)
                ensight.arrow.radius(1.250000e-001)
                ensight.arrow.tip_length(3.000000e-001)
                ensight.arrow.tip_radius(2.250000e+000)
                ensight.arrow.rgb(1.000000e+000,1.000000e+000,0.000000e+000)
                ensight.arrow.light_shin(9.000000e+000)
                ensight.arrow.light_h_int(4.700000e-001)
                ensight.arrow.light_diff(2.100000e-001)
                ensight.arrow.label_rgb(0.000000e+000,1.000000e+000,0.000000e+000)
                ensight.arrow.label_size(3.600000e+001)
                ensight.arrow.label_offset(.5)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.arrow.label_size({repr(p0)})'''
        return self._session.cmd(cmd)

    def label_text(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.arrow.label_text({repr(p0)})'''
        return self._session.cmd(cmd)

    def light_diff(self, p0: float) -> int:
        """Specifies the diffused light factor of the selected 3D arrow(s).
        
        Args:
            p0:
                'value' diffused light factor (0.0 to 1.0)
        
        Examples:
            ::
        
                ensight.arrow.new_arrow()
                ensight.arrow.select_begin(0)
                ensight.arrow.label_text("Label")
                ensight.arrow.visible("ON")
                ensight.arrow.origin_by("XYZ")
                ensight.arrow.location(0.000000e+000,0.000000e+000,2.000000e+000)
                ensight.arrow.normal(0.000000e+000,0.000000e+000,-1.000000e+000)
                ensight.arrow.offset(5.000000e-001)
                ensight.arrow.size(1.500000e+000)
                ensight.arrow.radius(1.250000e-001)
                ensight.arrow.tip_length(3.000000e-001)
                ensight.arrow.tip_radius(2.250000e+000)
                ensight.arrow.rgb(1.000000e+000,1.000000e+000,0.000000e+000)
                ensight.arrow.light_shin(9.000000e+000)
                ensight.arrow.light_h_int(4.700000e-001)
                ensight.arrow.light_diff(2.100000e-001)
                ensight.arrow.label_rgb(0.000000e+000,1.000000e+000,0.000000e+000)
                ensight.arrow.label_size(3.600000e+001)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.arrow.light_diff({repr(p0)})'''
        return self._session.cmd(cmd)

    def light_h_int(self, p0: float) -> int:
        """Specifies the highlight intensity of the selected 3D arrow(s).
        
        Args:
            p0:
                'intensity' highlight intensity, must be within the range of 0.0 to 1.0
        
        Examples:
            ::
        
                ensight.arrow.new_arrow()
                ensight.arrow.select_begin(0)
                ensight.arrow.label_text("Label")
                ensight.arrow.visible("ON")
                ensight.arrow.origin_by("XYZ")
                ensight.arrow.location(0.000000e+000,0.000000e+000,2.000000e+000)
                ensight.arrow.normal(0.000000e+000,0.000000e+000,-1.000000e+000)
                ensight.arrow.offset(5.000000e-001)
                ensight.arrow.size(1.500000e+000)
                ensight.arrow.radius(1.250000e-001)
                ensight.arrow.tip_length(3.000000e-001)
                ensight.arrow.tip_radius(2.250000e+000)
                ensight.arrow.rgb(1.000000e+000,1.000000e+000,0.000000e+000)
                ensight.arrow.light_shin(9.000000e+000)
                ensight.arrow.light_h_int(4.700000e-001)
                ensight.arrow.light_diff(2.100000e-001)
                ensight.arrow.label_rgb(0.000000e+000,1.000000e+000,0.000000e+000)
                ensight.arrow.label_size(3.600000e+001)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.arrow.light_h_int({repr(p0)})'''
        return self._session.cmd(cmd)

    def light_shin(self, p0: float) -> int:
        """Specifies the highlight shininess of the selected 3D arrow(s).
        
        Args:
            p0:
                'shiny' "shinyness" value, must be within the range of 1.0 to 100.0 . Lower values specify less shine
        
        Examples:
            ::
        
                ensight.arrow.new_arrow()
                ensight.arrow.select_begin(0)
                ensight.arrow.label_text("Label")
                ensight.arrow.visible("ON")
                ensight.arrow.origin_by("XYZ")
                ensight.arrow.location(0.000000e+000,0.000000e+000,2.000000e+000)
                ensight.arrow.normal(0.000000e+000,0.000000e+000,-1.000000e+000)
                ensight.arrow.offset(5.000000e-001)
                ensight.arrow.size(1.500000e+000)
                ensight.arrow.radius(1.250000e-001)
                ensight.arrow.tip_length(3.000000e-001)
                ensight.arrow.tip_radius(2.250000e+000)
                ensight.arrow.rgb(1.000000e+000,1.000000e+000,0.000000e+000)
                ensight.arrow.light_shin(9.000000e+000)
                ensight.arrow.light_h_int(4.700000e-001)
                ensight.arrow.light_diff(2.100000e-001)
                ensight.arrow.label_rgb(0.000000e+000,1.000000e+000,0.000000e+000)
                ensight.arrow.label_size(3.600000e+001)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.arrow.light_shin({repr(p0)})'''
        return self._session.cmd(cmd)

    def location(self, p0: float, p1: float, p2: float) -> int:
        """Specifies the x,y,z coordinate location of the tip of the selected 3D arrow(s).
        
        Args:
            p0:
                'x_tip' x coordinate of the tip of the selected 3D arrow(s)
            p1:
                'y_tip' y coordinate of the tip of the selected 3D arrow(s)
            p2:
                'z_tip' z coordinate of the tip of the selected 3D arrow(s)
        
        Examples:
            ::
        
                ensight.arrow.new_arrow()
                ensight.arrow.select_begin(0)
                ensight.arrow.label_text("Label")
                ensight.arrow.visible("ON")
                ensight.arrow.origin_by("XYZ")
                ensight.arrow.location(0.000000e+000,0.000000e+000,2.000000e+000)
                ensight.arrow.normal(0.000000e+000,0.000000e+000,-1.000000e+000)
                ensight.arrow.offset(5.000000e-001)
                ensight.arrow.size(1.500000e+000)
                ensight.arrow.radius(1.250000e-001)
                ensight.arrow.tip_length(3.000000e-001)
                ensight.arrow.tip_radius(2.250000e+000)
                ensight.arrow.rgb(1.000000e+000,1.000000e+000,0.000000e+000)
                ensight.arrow.light_shin(9.000000e+000)
                ensight.arrow.light_h_int(4.700000e-001)
                ensight.arrow.light_diff(2.100000e-001)
                ensight.arrow.label_rgb(0.000000e+000,1.000000e+000,0.000000e+000)
                ensight.arrow.label_size(3.600000e+001)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.arrow.location({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def modify_begin(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.arrow.modify_begin()'''
        return self._session.cmd(cmd)

    def modify_end(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.arrow.modify_end()'''
        return self._session.cmd(cmd)

    def new_arrow(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.arrow.new_arrow()'''
        return self._session.cmd(cmd)

    def new_or_mod_arrow(self, p0: int) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.arrow.new_or_mod_arrow({repr(p0)})'''
        return self._session.cmd(cmd)

    def normal(self, p0: float, p1: float, p2: float) -> int:
        """Specifies the x,y,z components of the selected 3D arrow(s).
        
        Args:
            p0:
                'x_comp' x component of the selected 3D arrow(s)
            p1:
                'y_comp' y component of the selected 3D arrow(s)
            p2:
                'z_comp' z component of the selected 3D arrow(s)
        
        Examples:
            ::
        
                ensight.arrow.new_arrow()
                ensight.arrow.select_begin(0)
                ensight.arrow.label_text("Label")
                ensight.arrow.visible("ON")
                ensight.arrow.origin_by("XYZ")
                ensight.arrow.location(0.000000e+000,0.000000e+000,2.000000e+000)
                ensight.arrow.normal(0.000000e+000,0.000000e+000,-1.000000e+000)
                ensight.arrow.offset(5.000000e-001)
                ensight.arrow.size(1.500000e+000)
                ensight.arrow.radius(1.250000e-001)
                ensight.arrow.tip_length(3.000000e-001)
                ensight.arrow.tip_radius(2.250000e+000)
                ensight.arrow.rgb(1.000000e+000,1.000000e+000,0.000000e+000)
                ensight.arrow.light_shin(9.000000e+000)
                ensight.arrow.light_h_int(4.700000e-001)
                ensight.arrow.light_diff(2.100000e-001)
                ensight.arrow.label_rgb(0.000000e+000,1.000000e+000,0.000000e+000)
                ensight.arrow.label_size(3.600000e+001)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.arrow.normal({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def offset(self, p0: float) -> int:
        """Specifies the radius of the tip of the selected 3D arrow(s).
        
        | The value is in model coordinates.
        
        Args:
            p0:
                'value' distance from tip to the arrow origin for the selected 3D arrow(s)
        
        Examples:
            ::
        
                ensight.arrow.new_arrow()
                ensight.arrow.select_begin(0)
                ensight.arrow.label_text("Label")
                ensight.arrow.visible("ON")
                ensight.arrow.origin_by("XYZ")
                ensight.arrow.location(0.000000e+000,0.000000e+000,2.000000e+000)
                ensight.arrow.normal(0.000000e+000,0.000000e+000,-1.000000e+000)
                ensight.arrow.offset(5.000000e-001)
                ensight.arrow.size(1.500000e+000)
                ensight.arrow.radius(1.250000e-001)
                ensight.arrow.tip_length(3.000000e-001)
                ensight.arrow.tip_radius(2.250000e+000)
                ensight.arrow.rgb(1.000000e+000,1.000000e+000,0.000000e+000)
                ensight.arrow.light_shin(9.000000e+000)
                ensight.arrow.light_h_int(4.700000e-001)
                ensight.arrow.light_diff(2.100000e-001)
                ensight.arrow.label_rgb(0.000000e+000,1.000000e+000,0.000000e+000)
                ensight.arrow.label_size(3.600000e+001)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.arrow.offset({repr(p0)})'''
        return self._session.cmd(cmd)

    def orient_flip(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.arrow.orient_flip()'''
        return self._session.cmd(cmd)

    def orient_normal(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.arrow.orient_normal()'''
        return self._session.cmd(cmd)

    def orient_x(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.arrow.orient_x()'''
        return self._session.cmd(cmd)

    def orient_y(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.arrow.orient_y()'''
        return self._session.cmd(cmd)

    def orient_z(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.arrow.orient_z()'''
        return self._session.cmd(cmd)

    def origin_by(self, p0: str) -> int:
        """Arrow: origin_by

        """
        cmd = f'''ensight.arrow.origin_by({repr(p0)})'''
        return self._session.cmd(cmd)

    def probe_number(self, p0: int) -> int:
        """Specifies the probe number to use in setting the origin by interactive probe query for the selected 3D arrow(s).
        
        Args:
            p0:
                'num' probe number (0 to number of probes-1)
        
        Examples:
            ::
        
                ensight.arrow.new_arrow()
                ensight.arrow.select_begin(0)
                ensight.arrow.label_text("Label")
                ensight.arrow.visible("ON")
                ensight.arrow.origin_by("XYZ")
                ensight.arrow.location(0.000000e+000,0.000000e+000,2.000000e+000)
                ensight.arrow.normal(0.000000e+000,0.000000e+000,-1.000000e+000)
                ensight.arrow.offset(5.000000e-001)
                ensight.arrow.size(1.500000e+000)
                ensight.arrow.radius(1.250000e-001)
                ensight.arrow.tip_length(3.000000e-001)
                ensight.arrow.tip_radius(2.250000e+000)
                ensight.arrow.rgb(1.000000e+000,1.000000e+000,0.000000e+000)
                ensight.arrow.light_shin(9.000000e+000)
                ensight.arrow.light_h_int(4.700000e-001)
                ensight.arrow.light_diff(2.100000e-001)
                ensight.arrow.label_rgb(0.000000e+000,1.000000e+000,0.000000e+000)
                ensight.arrow.label_size(3.600000e+001)
                ensight.arrow.label_offset(.5)
                ensight.arrow.viewport_vis("off",1)
                ensight.arrow.viewport_vis("on",0)
                ensight.variables.activate("temperature")
                ensight.query_interact.select_varname_begin("temperature")
                ensight.view_transf.function("global")
                ensight.query_interact.query("surface")
                ensight.query_interact.create(0.615213,0.242925)
                ensight.arrow.origin_by("probe_query")
                ensight.arrow.probe_number(0)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.arrow.probe_number({repr(p0)})'''
        return self._session.cmd(cmd)

    def query_count(self, args: Any) -> int:
        """Arrow: query_count

        """
        cmd = f'''ensight.arrow.query_count({repr(args)})'''
        return self._session.cmd(cmd)

    def query_display_attributes(self, args: Any) -> int:
        """Arrow: query_display_attributes

        """
        cmd = f'''ensight.arrow.query_display_attributes({repr(args)})'''
        return self._session.cmd(cmd)

    def query_label_text(self, args: Any) -> int:
        """Arrow: query_label_text

        """
        cmd = f'''ensight.arrow.query_label_text({repr(args)})'''
        return self._session.cmd(cmd)

    def query_selected_objects(self, args: Any) -> int:
        """Arrow: query_selected_objects

        """
        cmd = f'''ensight.arrow.query_selected_objects({repr(args)})'''
        return self._session.cmd(cmd)

    def radius(self, p0: float) -> int:
        """Specifies the radius of the shaft of the selected 3D arrow(s).
        
        | The value is in model coordinates.
        
        Args:
            p0:
                'value' radius of the shaft of the selected 3D arrow(s)
        
        Examples:
            ::
        
                ensight.arrow.new_arrow()
                ensight.arrow.select_begin(0)
                ensight.arrow.label_text("Label")
                ensight.arrow.visible("ON")
                ensight.arrow.origin_by("XYZ")
                ensight.arrow.location(0.000000e+000,0.000000e+000,2.000000e+000)
                ensight.arrow.normal(0.000000e+000,0.000000e+000,-1.000000e+000)
                ensight.arrow.offset(5.000000e-001)
                ensight.arrow.size(1.500000e+000)
                ensight.arrow.radius(1.250000e-001)
                ensight.arrow.tip_length(3.000000e-001)
                ensight.arrow.tip_radius(2.250000e+000)
                ensight.arrow.rgb(1.000000e+000,1.000000e+000,0.000000e+000)
                ensight.arrow.light_shin(9.000000e+000)
                ensight.arrow.light_h_int(4.700000e-001)
                ensight.arrow.light_diff(2.100000e-001)
                ensight.arrow.label_rgb(0.000000e+000,1.000000e+000,0.000000e+000)
                ensight.arrow.label_size(3.600000e+001)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.arrow.radius({repr(p0)})'''
        return self._session.cmd(cmd)

    def rgb(self, p0: float, p1: float, p2: float) -> int:
        """Specifies the color of the selected 3D arrow(s).
        
        Args:
            p0:
                'red_val' red, green, blue components of the color (0.0 to 1.0)
            p1:
                'grn_val' red, green, blue components of the color (0.0 to 1.0)
            p2:
                'blu_val' red, green, blue components of the color (0.0 to 1.0)
        
        Examples:
            ::
        
                ensight.arrow.new_arrow()
                ensight.arrow.select_begin(0)
                ensight.arrow.label_text("Label")
                ensight.arrow.visible("ON")
                ensight.arrow.origin_by("XYZ")
                ensight.arrow.location(0.000000e+000,0.000000e+000,2.000000e+000)
                ensight.arrow.normal(0.000000e+000,0.000000e+000,-1.000000e+000)
                ensight.arrow.offset(5.000000e-001)
                ensight.arrow.size(1.500000e+000)
                ensight.arrow.radius(1.250000e-001)
                ensight.arrow.tip_length(3.000000e-001)
                ensight.arrow.tip_radius(2.250000e+000)
                ensight.arrow.rgb(1.000000e+000,1.000000e+000,0.000000e+000)
                ensight.arrow.light_shin(9.000000e+000)
                ensight.arrow.light_h_int(4.700000e-001)
                ensight.arrow.light_diff(2.100000e-001)
                ensight.arrow.label_rgb(0.000000e+000,1.000000e+000,0.000000e+000)
                ensight.arrow.label_size(3.600000e+001)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.arrow.rgb({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def scale_by_locationvalue(self, p0: str) -> int:
        """Arrow: scale_by_locationvalue

        """
        cmd = f'''ensight.arrow.scale_by_locationvalue({repr(p0)})'''
        return self._session.cmd(cmd)

    def scale_by_probe(self, p0: str) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.arrow.scale_by_probe({repr(p0)})'''
        return self._session.cmd(cmd)

    def scale_max_factor(self, p0: float) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.arrow.scale_max_factor({repr(p0)})'''
        return self._session.cmd(cmd)

    def scale_max_value(self, p0: float) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.arrow.scale_max_value({repr(p0)})'''
        return self._session.cmd(cmd)

    def scale_min_factor(self, p0: float) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.arrow.scale_min_factor({repr(p0)})'''
        return self._session.cmd(cmd)

    def scale_min_value(self, p0: float) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.arrow.scale_min_value({repr(p0)})'''
        return self._session.cmd(cmd)

    def select_all(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.arrow.select_all()'''
        return self._session.cmd(cmd)

    def select_all_forces(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.arrow.select_all_forces()'''
        return self._session.cmd(cmd)

    def select_all_invisible(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.arrow.select_all_invisible()'''
        return self._session.cmd(cmd)

    def select_all_moments(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.arrow.select_all_moments()'''
        return self._session.cmd(cmd)

    def select_all_visible(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.arrow.select_all_visible()'''
        return self._session.cmd(cmd)

    def select_begin(self, *args, **kwargs) -> Any:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.arrow.select_begin({arg_string})"
        return self._session.cmd(cmd)

    def select_default(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.arrow.select_default()'''
        return self._session.cmd(cmd)

    def select_forces_begin(self, args: Any) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.arrow.select_forces_begin({repr(args)})'''
        return self._session.cmd(cmd)

    def select_forces_end(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.arrow.select_forces_end()'''
        return self._session.cmd(cmd)

    def select_moments_begin(self, args: Any) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.arrow.select_moments_begin({repr(args)})'''
        return self._session.cmd(cmd)

    def select_moments_end(self) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.arrow.select_moments_end()'''
        return self._session.cmd(cmd)

    def size(self, p0: float) -> int:
        """Specifies the length of the selected 3D arrow(s).
        
        | The length is in model coordinates.
        
        Args:
            p0:
                'length' length of the selected 3D arrow(s)
        
        Examples:
            ::
        
                ensight.arrow.new_arrow()
                ensight.arrow.select_begin(0)
                ensight.arrow.label_text("Label")
                ensight.arrow.visible("ON")
                ensight.arrow.origin_by("XYZ")
                ensight.arrow.location(0.000000e+000,0.000000e+000,2.000000e+000)
                ensight.arrow.normal(0.000000e+000,0.000000e+000,-1.000000e+000)
                ensight.arrow.offset(5.000000e-001)
                ensight.arrow.size(1.500000e+000)
                ensight.arrow.radius(1.250000e-001)
                ensight.arrow.tip_length(3.000000e-001)
                ensight.arrow.tip_radius(2.250000e+000)
                ensight.arrow.rgb(1.000000e+000,1.000000e+000,0.000000e+000)
                ensight.arrow.light_shin(9.000000e+000)
                ensight.arrow.light_h_int(4.700000e-001)
                ensight.arrow.light_diff(2.100000e-001)
                ensight.arrow.label_rgb(0.000000e+000,1.000000e+000,0.000000e+000)
                ensight.arrow.label_size(3.600000e+001)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.arrow.size({repr(p0)})'''
        return self._session.cmd(cmd)

    def snap_to_element(self, p0: int) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.arrow.snap_to_element({repr(p0)})'''
        return self._session.cmd(cmd)

    def snap_to_node(self, p0: int) -> int:
        """This command has not yet been documented.
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.arrow.snap_to_node({repr(p0)})'''
        return self._session.cmd(cmd)

    def tip_length(self, p0: float) -> int:
        """Specifies the length of the tip of the selected 3D arrow(s).
        
        | The value is in model coordinates.
        
        Args:
            p0:
                'value' length of the tip of the selected 3D arrow(s)
        
        Examples:
            ::
        
                ensight.arrow.new_arrow()
                ensight.arrow.select_begin(0)
                ensight.arrow.label_text("Label")
                ensight.arrow.visible("ON")
                ensight.arrow.origin_by("XYZ")
                ensight.arrow.location(0.000000e+000,0.000000e+000,2.000000e+000)
                ensight.arrow.normal(0.000000e+000,0.000000e+000,-1.000000e+000)
                ensight.arrow.offset(5.000000e-001)
                ensight.arrow.size(1.500000e+000)
                ensight.arrow.radius(1.250000e-001)
                ensight.arrow.tip_length(3.000000e-001)
                ensight.arrow.tip_radius(2.250000e+000)
                ensight.arrow.rgb(1.000000e+000,1.000000e+000,0.000000e+000)
                ensight.arrow.light_shin(9.000000e+000)
                ensight.arrow.light_h_int(4.700000e-001)
                ensight.arrow.light_diff(2.100000e-001)
                ensight.arrow.label_rgb(0.000000e+000,1.000000e+000,0.000000e+000)
                ensight.arrow.label_size(3.600000e+001)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.arrow.tip_length({repr(p0)})'''
        return self._session.cmd(cmd)

    def tip_radius(self, p0: float) -> int:
        """Specifies the radius of the tip of the selected 3D arrow(s).
        
        | The value is in model coordinates.
        
        Args:
            p0:
                'value' radius of the tip of the selected 3D arrow(s)
        
        Examples:
            ::
        
                ensight.arrow.new_arrow()
                ensight.arrow.select_begin(0)
                ensight.arrow.label_text("Label")
                ensight.arrow.visible("ON")
                ensight.arrow.origin_by("XYZ")
                ensight.arrow.location(0.000000e+000,0.000000e+000,2.000000e+000)
                ensight.arrow.normal(0.000000e+000,0.000000e+000,-1.000000e+000)
                ensight.arrow.offset(5.000000e-001)
                ensight.arrow.size(1.500000e+000)
                ensight.arrow.radius(1.250000e-001)
                ensight.arrow.tip_length(3.000000e-001)
                ensight.arrow.tip_radius(2.250000e+000)
                ensight.arrow.rgb(1.000000e+000,1.000000e+000,0.000000e+000)
                ensight.arrow.light_shin(9.000000e+000)
                ensight.arrow.light_h_int(4.700000e-001)
                ensight.arrow.light_diff(2.100000e-001)
                ensight.arrow.label_rgb(0.000000e+000,1.000000e+000,0.000000e+000)
                ensight.arrow.label_size(3.600000e+001)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.arrow.tip_radius({repr(p0)})'''
        return self._session.cmd(cmd)

    def use_annotation_text(self, p0: str) -> int:
        """Arrow: use_annotation_text

        """
        cmd = f'''ensight.arrow.use_annotation_text({repr(p0)})'''
        return self._session.cmd(cmd)

    def viewport_vis(self, *args, **kwargs) -> Any:
        """Arrow: viewport_vis

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.arrow.viewport_vis({arg_string})"
        return self._session.cmd(cmd)

    def visible(self, p0: str) -> int:
        """Toggles visibility of the selected 3D arrow(s) off or on.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.arrow.new_arrow()
                ensight.arrow.select_begin(0)
                ensight.arrow.label_text("Label")
                ensight.arrow.visible("ON")
                ensight.arrow.origin_by("XYZ")
                ensight.arrow.location(0.000000e+000,0.000000e+000,2.000000e+000)
                ensight.arrow.normal(0.000000e+000,0.000000e+000,-1.000000e+000)
                ensight.arrow.offset(5.000000e-001)
                ensight.arrow.size(1.500000e+000)
                ensight.arrow.radius(1.250000e-001)
                ensight.arrow.tip_length(3.000000e-001)
                ensight.arrow.tip_radius(2.250000e+000)
                ensight.arrow.rgb(1.000000e+000,1.000000e+000,0.000000e+000)
                ensight.arrow.light_shin(9.000000e+000)
                ensight.arrow.light_h_int(4.700000e-001)
                ensight.arrow.light_diff(2.100000e-001)
                ensight.arrow.label_rgb(0.000000e+000,1.000000e+000,0.000000e+000)
                ensight.arrow.label_size(3.600000e+001)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.arrow.visible({repr(p0)})'''
        return self._session.cmd(cmd)


class annotation:
    """Class wrapper for EnSight annotation module

    This class acts as a proxy for the EnSight Python module ensight.annotation
    """
    def __init__(self, session: Session):
        self._session = session

    def _3d_label_size(self, p0: int) -> int:
        """Annotation: 3d_label_size

        """
        cmd = f'''ensight.annotation._3d_label_size({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_global(self, p0: str) -> int:
        """Turns the global axis triad on or off.
        
        | The global axis' origin is located at the centroid of the visible geometry. Its location is recomputed when the viewport is re initialized. The global axis will have 'G' at its origin to distinguish it from other axes.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.annotation.axis_global("ON")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.annotation.axis_global({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_local(self, p0: str) -> int:
        """Toggles the global attribute controlling local frame visibility.
        
        | Local coordinate frames are visible only if their axis visibility attribute are on AND the global toggle described here is ON.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.frame.create()
                ensight.frame.select_begin(1)
                ensight.annotation.axis_local("ON")
                ensight.frame.x_labels("ON")
                ensight.frame.len_x(1.0000e+03)
                ensight.frame.len_y(7.4565e+02)
                ensight.frame.len_z(7.4565e+02)
                ensight.frame.rgb(0.0000e+00,0.0000e+00,1.0000e+00)
                ensight.frame.visible("ON")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.annotation.axis_local({repr(p0)})'''
        return self._session.cmd(cmd)

    def axis_model(self, p0: str) -> int:
        """Turns the model axis triad on or off.
        
        | The model axis' origin is fixed in the lower left corner of the viewport. It is intended to be a simple indicator of which way the X, Y, and Z axes lie.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.annotation.axis_model("ON")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.annotation.axis_model({repr(p0)})'''
        return self._session.cmd(cmd)

    def deselect_all(self) -> int:
        """Deselects all annotations.
        
        Examples:
            ::
        
                ensight.text.new_text("A Test")
                ensight.text.select_begin(0)
                ensight.text.new_text("A Second Test")
                ensight.text.select_begin(1)
                ensight.text.select_all()
                ensight.text.select_begin(0,1)
                ensight.annotation.deselect_all()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.annotation.deselect_all()'''
        return self._session.cmd(cmd)

    def element_labeling(self, p0: str) -> int:
        """Turns element labels on or off globally.
        
        | Element labels for individual parts can be toggled on or off; however, for any labels to be visible, the global setting must be on. A threshold can also be enabled to limit the range of visible labels.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.annotation.element_labeling("ON")
                ensight.view_transf.function("global")
                # WARNING: following line includes OBSOLETE call (ensight.part.select_partname_begin).
                ensight.part.select_partname_begin("(CASE:Case 1)Subset of parts: 2")
                ensight.part.modify_begin()
                ensight.part.entity_label_elt("ON")
                ensight.part.modify_end()
                ensight.view_transf.function("global")
                ensight.annot_entlbl.node_thresholds("high")
                ensight.annot_entlbl.node_threshold_low(1)
                ensight.annot_entlbl.node_threshold_high(10)
                ensight.annot_entlbl.node_rgb(0.000000,0.000000,1.000000)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.annotation.element_labeling({repr(p0)})'''
        return self._session.cmd(cmd)

    def legend(self, p0: str) -> int:
        """Toggles visibility of all visible legends.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.legend.select_palette_begin("pressure")
                ensight.legend.visible("ON")
                ensight.legend.select_palette_begin("velocity")
                ensight.legend.visible("ON")
                ensight.legend.select_palette_begin("pressure")
                ensight.legend.select_palette_begin("pressure")
                ensight.legend.location_x(3.2353e-01)
                ensight.legend.location_y(5.3681e-02)
                ensight.legend.select_palette_begin("pressure")
                ensight.annotation.legend("off")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.annotation.legend({repr(p0)})'''
        return self._session.cmd(cmd)

    def node_labeling(self, p0: str) -> int:
        """Turns node labels on or off globally.
        
        | Node labels for individual parts can be toggled on or off; however, for any labels to be visible, the global setting must be on. A threshold can also be enabled to limit the range of visible labels.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.annotation.node_labeling("ON")
                ensight.view_transf.function("global")
                ensight.view_transf.function("global")
                ensight.part.modify_begin()
                ensight.part.entity_label_node("ON")
                ensight.part.modify_end()
                ensight.view_transf.function("global")
                ensight.annot_entlbl.element_thresholds("band")
                ensight.annot_entlbl.element_threshold_low(10)
                ensight.annot_entlbl.element_threshold_high(20)
                ensight.annot_entlbl.element_rgb(0.000000,1.000000,0.000000)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.annotation.node_labeling({repr(p0)})'''
        return self._session.cmd(cmd)

    def pick_mode(self) -> int:
        """Sets how 3D arrows are placed when using pick to do so.
        
        | 3D arrows can be placed using picking while in annotation mode.
        
        Args:
            p0:
                'option'
        
                * origin_exact
                * origin_closestnode
                * origin_exactwithnormal
                * origin_closestwithnormal
        
        Examples:
            ::
        
                # WARNING: following line includes OBSOLETE call (ensight.annotation.pick_mode).
                ensight.annotation.pick_mode("origin_closestnode")
                ensight.arrow.select_begin(0)
                ensight.arrow.location(2.009204e+000,1.154697e+000,2.000000e+000)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.annotation.pick_mode()'''
        return self._session.cmd(cmd)

    def text_display(self, p0: str) -> int:
        """Toggles the visibility of all text, line, and logo annotations.
        
        | This command does not affect the visibility of legends.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.text.new_text("My Test Data")
                # turn off all annotations
                ensight.annotation.text_display("OFF")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.annotation.text_display({repr(p0)})'''
        return self._session.cmd(cmd)

    def text_dynamic(self, p0: str) -> int:
        """Annotation: text_dynamic

        """
        cmd = f'''ensight.annotation.text_dynamic({repr(p0)})'''
        return self._session.cmd(cmd)


class annot_entlbl:
    """Class wrapper for EnSight annot_entlbl module

    This class acts as a proxy for the EnSight Python module ensight.annot_entlbl
    """
    def __init__(self, session: Session):
        self._session = session

    def element_rgb(self, p0: float, p1: float, p2: float) -> int:
        """Sets the color of element id labels.
        
        | This is a normal rgb color triple.  The effect of this command is global - namely, all element labels are affected.
        
        Args:
            p0:
                'red_val' red, green, blue component of the color (0.0 to 1.0)
            p1:
                'grn_val' red, green, blue component of the color (0.0 to 1.0)
            p2:
                'blu_val' red, green, blue component of the color (0.0 to 1.0)
        
        Examples:
            ::
        
                ensight.annot_entlbl.element_rgb(1.000000,0.400000,0.800000)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.annot_entlbl.element_rgb({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def element_threshold_high(self, p0: float) -> int:
        """Sets the high/low threshold value for element label filtering.
        
        | The threshold high/low value is used according to the filter method set in the annot_entlbl: element_thresholds associated command.
        
        Args:
            p0:
                'element_id' high/low threshold element id
        
        Examples:
            ::
        
                ensight.annot_entlbl.element_thresholds("band")
                ensight.annot_entlbl.element_threshold_low(30)
                ensight.annot_entlbl.element_threshold_high(1200)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.annot_entlbl.element_threshold_high({repr(p0)})'''
        return self._session.cmd(cmd)

    def element_threshold_low(self, p0: float) -> int:
        """Sets the high/low threshold value for element label filtering.
        
        | The threshold high/low value is used according to the filter method set in the annot_entlbl: element_thresholds associated command.
        
        Args:
            p0:
                'element_id' high/low threshold element id
        
        Examples:
            ::
        
                ensight.annot_entlbl.element_thresholds("band")
                ensight.annot_entlbl.element_threshold_low(30)
                ensight.annot_entlbl.element_threshold_high(1200)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.annot_entlbl.element_threshold_low({repr(p0)})'''
        return self._session.cmd(cmd)

    def element_thresholds(self, p0: str) -> int:
        """Sets method to use for filtering element labels.
        
        | This command sets the method.  The threshold low and high values are set in associated commands
        
        Args:
            p0:
                'filter_setting'
        
                * low
                * high
                * band
                * low_high
                * none
        
        Examples:
            ::
        
                ensight.annot_entlbl.element_thresholds("band")
                ensight.annot_entlbl.element_threshold_low(30)
                ensight.annot_entlbl.element_threshold_high(1200)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.annot_entlbl.element_thresholds({repr(p0)})'''
        return self._session.cmd(cmd)

    def node_rgb(self, p0: float, p1: float, p2: float) -> int:
        """Sets the color of node id labels.
        
        | This is a normal rgb color triple.  The effect of this command is global - namely, all node labels are affected.
        
        Args:
            p0:
                'red_val' red, green, blue components of the color (0.0 to 1.0)
            p1:
                'grn_val' red, green, blue components of the color (0.0 to 1.0)
            p2:
                'blu_val' red, green, blue components of the color (0.0 to 1.0)
        
        Examples:
            ::
        
                ensight.annot_entlbl.node_rgb(0.000000,1.000000,0.800000)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.annot_entlbl.node_rgb({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def node_threshold_high(self, p0: float) -> int:
        """Sets the high/low threshold value for node label filtering.
        
        | The threshold high/low value is used according to the filter method set in the annot_entlbl: node_thresholds associated command.
        
        Args:
            p0:
                'node_id' high/low threshold node id
        
        Examples:
            ::
        
                ensight.annot_entlbl.node_thresholds("low_high")
                ensight.annot_entlbl.node_threshold_low(2)
                ensight.annot_entlbl.node_threshold_high(20)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.annot_entlbl.node_threshold_high({repr(p0)})'''
        return self._session.cmd(cmd)

    def node_threshold_low(self, p0: float) -> int:
        """Sets the high/low threshold value for node label filtering.
        
        | The threshold high/low value is used according to the filter method set in the annot_entlbl: node_thresholds associated command.
        
        Args:
            p0:
                'node_id' high/low threshold node id
        
        Examples:
            ::
        
                ensight.annot_entlbl.node_thresholds("low_high")
                ensight.annot_entlbl.node_threshold_low(2)
                ensight.annot_entlbl.node_threshold_high(20)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.annot_entlbl.node_threshold_low({repr(p0)})'''
        return self._session.cmd(cmd)

    def node_thresholds(self, p0: str) -> int:
        """Sets method to use for filtering node labels.
        
        | This command sets the method.  The threshold low and high values are set in associated commands
        
        Args:
            p0:
                'filter_setting'
        
                * low
                * high
                * band
                * low_high
                * none
        
        Examples:
            ::
        
                ensight.annot_entlbl.node_thresholds("low_high")
                ensight.annot_entlbl.node_threshold_low(2)
                ensight.annot_entlbl.node_threshold_high(20)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.annot_entlbl.node_thresholds({repr(p0)})'''
        return self._session.cmd(cmd)

    def part_rgb(self, p0: float, p1: float, p2: float) -> int:
        """Annot_entlbl: part_rgb

        """
        cmd = f'''ensight.annot_entlbl.part_rgb({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)


class annot_backgr:
    """Class wrapper for EnSight annot_backgr module

    This class acts as a proxy for the EnSight Python module ensight.annot_backgr
    """
    def __init__(self, session: Session):
        self._session = session

    def begin(self) -> int:
        """Annot_backgr: begin

        """
        cmd = f'''ensight.annot_backgr.begin()'''
        return self._session.cmd(cmd)

    def blended_color(self) -> int:
        """Annot_backgr: blended_color

        """
        cmd = f'''ensight.annot_backgr.blended_color()'''
        return self._session.cmd(cmd)

    def constant_color(self) -> int:
        """Annot_backgr: constant_color

        """
        cmd = f'''ensight.annot_backgr.constant_color()'''
        return self._session.cmd(cmd)

    def edit_level(self, p0: int) -> int:
        """Annot_backgr: edit_level

        """
        cmd = f'''ensight.annot_backgr.edit_level({repr(p0)})'''
        return self._session.cmd(cmd)

    def end(self) -> int:
        """Annot_backgr: end

        """
        cmd = f'''ensight.annot_backgr.end()'''
        return self._session.cmd(cmd)

    def number_of_levels(self, p0: int) -> int:
        """Annot_backgr: #_of_levels

        """
        cmd = f'''ensight.annot_backgr.number_of_levels({repr(p0)})'''
        return self._session.cmd(cmd)

    def position(self, p0: float) -> int:
        """Annot_backgr: position

        """
        cmd = f'''ensight.annot_backgr.position({repr(p0)})'''
        return self._session.cmd(cmd)

    def rgb(self, p0: float, p1: float, p2: float) -> int:
        """Annot_backgr: rgb

        """
        cmd = f'''ensight.annot_backgr.rgb({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)


class anim_traces:
    """Class wrapper for EnSight anim_traces module

    This class acts as a proxy for the EnSight Python module ensight.anim_traces
    """
    def __init__(self, session: Session):
        self._session = session

    def color_by(self, p0: str) -> int:
        """Specify the option by which to color the animated traces on the selected part(s).
        
        | The color of the constant_color option is specified by the "anim_traces: RGB" command. 
        
        Args:
            p0:
                'option' constant_color
            p1:
                'option' calculated_color
        
        Examples:
            ::
        
                # 
                # Select the particle trace part(s) to animate 
                # 
                ensight.part.select_begin(2)
                # 
                # Toggle off the visibility of the selected particle trace part(s), and 
                # animate them. 
                # 
                ensight.part.modify_begin()
                ensight.part.visible("OFF")
                ensight.ptrace.animate("ON")
                ensight.part.modify_end()
                # 
                # Color by constant color of magenta 
                # 
                ensight.anim_traces.color_by("constant_color")
                ensight.anim_traces.rgb(1.0000e+00,0.0000e+00,1.0000e+00)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_traces.color_by({repr(p0)})'''
        return self._session.cmd(cmd)

    def delta_time(self, p0: float) -> int:
        """Specify how fast (the speed) the animated traces move for the selected particle trace part(s).
        
        | This parameter is not applicable when using "anim_traces: sync_to_transient ON", and displaying transient data through flipbook or keyframe animation. 
        
        Args:
            p0:
                'time_value' the time that the traces are incremented by between display frames
        
        Examples:
            ::
        
                # 
                # Select the particle trace part(s) to animate 
                # 
                ensight.part.select_begin(2)
                # 
                # Toggle off the visibility of the selected particle trace part(s), and 
                # animate them. 
                # 
                ensight.part.modify_begin()
                ensight.part.visible("OFF")
                ensight.ptrace.animate("ON")
                ensight.part.modify_end()
                # 
                # Specify a delta time 
                # 
                ensight.anim_traces.delta_time(1.0000e-05)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_traces.delta_time({repr(p0)})'''
        return self._session.cmd(cmd)

    def head_detail(self, p0: float) -> int:
        """Specifies the detail-level of the head representation of all animated traces of the selected particle trace part(s).
        
        | Not applicable when head type is none.  Higher detail levels take longer to draw; thus, slowing performance.
        
        Args:
            p0:
                'detail_value' The detail-level of the head of all animated traces in range I[2,10] with 10 being the most detailed (default = 3.). The higher the detail level, the rounder the sphere head
        
        Examples:
            ::
        
                # 
                # Select the particle trace part(s) to animate 
                # 
                ensight.part.select_begin(2)
                # 
                # Toggle off the visibility of the selected particle trace part(s), and 
                # animate them. 
                # 
                ensight.part.modify_begin()
                ensight.part.visible("OFF")
                ensight.ptrace.animate("ON")
                ensight.part.modify_end()
                # 
                # Toggle animated trace segment head type to spheres 
                # 
                ensight.anim_traces.head_type("sphere")
                ensight.anim_traces.head_detail("4.0000+e00")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_traces.head_detail({repr(p0)})'''
        return self._session.cmd(cmd)

    def head_scale(self, p0: float) -> int:
        """Specify the scaling factor for the head size.
        
        | Not applicable when head type is none.
        | If head_size_by is constant, the scale factor is the diameter of the sphere.  If head_size_by is set to a scalar or vector the factor scales the variable selected.
        
        Args:
            p0:
                'scale_value' scale factor to apply to the head size. 
        
        Examples:
            ::
        
                # 
                # Select the particle trace part(s) to animate 
                # 
                ensight.part.select_begin(2)
                # 
                # Toggle off the visibility of the selected particle trace part(s), and 
                # animate them. 
                # 
                ensight.part.modify_begin()
                ensight.part.visible("OFF")
                ensight.ptrace.animate("ON")
                ensight.part.modify_end()
                # 
                # Toggle animated trace segment head type to spheres 
                # 
                ensight.anim_traces.head_type("sphere")
                ensight.anim_traces.head_scale(1.0000e-01)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_traces.head_scale({repr(p0)})'''
        return self._session.cmd(cmd)

    def head_size_by(self, p0: str) -> int:
        """Specify which variable type to use to size the head of each animated trace segment of the selected particle trace part(s).
        
        | Not applicable when head type is none. The head size is determined by multiplying the scale factor (anim_traces: head_scale) by the specified variable (anim_traces: head_variable) value.
        
        Args:
            p0:
                'option' constant
            p1:
                'option' scalar
            p2:
                'option' vector_mag
            p3:
                'option' vector_xcomp
            p4:
                'option' vector_ycomp
            p5:
                'option' vector_zcomp
        
        Examples:
            ::
        
                # 
                # Select the particle trace part(s) to animate 
                # 
                ensight.part.select_begin(2)
                # 
                # Toggle off the visibility of the selected particle trace part(s), and 
                # animate them. 
                # 
                ensight.part.modify_begin()
                ensight.part.visible("OFF")
                ensight.ptrace.animate("ON")
                ensight.part.modify_end()
                # 
                # Toggle animated trace segment head type to spheres 
                # and size by velocity magnitude 
                # 
                ensight.anim_traces.head_type("sphere")
                ensight.anim_traces.head_size_by("vector_mag")
                ensight.anim_traces.head_variable("Velocity")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_traces.head_size_by({repr(p0)})'''
        return self._session.cmd(cmd)

    def head_type(self, p0: str) -> int:
        """Specify the type of head for each animated trace segment for the selected particle trace part(s).
        
        | The following commands help control the size of the sphere at the head of each animated particle trace.
        |     anim_traces: head_detail
        |     anim_traces: head_scale
        |   anim_traces: head_size_by
        
        Args:
            p0:
                'option' none
            p1:
                'option' arrow
            p2:
                'option' sphere
        
        Examples:
            ::
        
                # 
                # Select the particle trace part(s) to animate 
                # 
                ensight.part.select_begin(2)
                # 
                # Toggle off the visibility of the selected particle trace part(s), and 
                # animate them. 
                # 
                ensight.part.modify_begin()
                ensight.part.visible("OFF")
                ensight.ptrace.animate("ON")
                ensight.part.modify_end()
                # 
                # Toggle animated trace segment head type to spheres 
                # 
                ensight.anim_traces.head_type("sphere")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_traces.head_type({repr(p0)})'''
        return self._session.cmd(cmd)

    def head_variable(self, args: Any) -> int:
        """Specify the variable to use in scaling the head of the animated trace segments of the selected particle trace part(s).
        
        | Not applicable for "anim_traces: head_sized_by constant". The scale factor (anim_traces: head_scale) will be applied to the value of the specified variable at the location of the head of the animated trace. Variable must be active.
        
        Args:
            p0:
                'variable_name' variable name to use in scaling the heads of the animated trace segments
        
        Examples:
            ::
        
                # 
                # Select the particle trace part(s) to animate 
                # 
                ensight.part.select_begin(2)
                # 
                # Toggle off the visibility of the selected particle trace part(s), and 
                # animate them. 
                # 
                ensight.part.modify_begin()
                ensight.part.visible("OFF")
                ensight.ptrace.animate("ON")
                ensight.part.modify_end()
                # 
                # Toggle animated trace segment head type to spheres 
                # and size by velocity magnitude 
                # 
                ensight.anim_traces.head_type("sphere")
                ensight.anim_traces.head_size_by("vector_mag")
                ensight.anim_traces.head_variable("Velocity")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_traces.head_variable({repr(args)})'''
        return self._session.cmd(cmd)

    def line_width(self, p0: float) -> int:
        """Specify line width of the animated trace segments for the selected particle trace part(s).
        
        Args:
            p0:
                'width_value' width of the animated trace line segments (default = 2)
        
        Examples:
            ::
        
                # 
                # Select the particle trace part(s) to animate 
                # 
                ensight.part.select_begin(2)
                # 
                # Toggle off the visibility of the selected particle trace part(s), and 
                # animate them. 
                # 
                ensight.part.modify_begin()
                ensight.part.visible("OFF")
                ensight.ptrace.animate("ON")
                ensight.part.modify_end()
                # 
                # Specify line width to be 3 
                # 
                ensight.anim_traces.line_width(3.0000e+01)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_traces.line_width({repr(p0)})'''
        return self._session.cmd(cmd)

    def max_time(self, p0: float) -> int:
        """Specify the maximum particle duration.
        
        | Used in conjunction with "anim_traces: set_max_time ON". 
        
        Args:
            p0:
                'time_value' time at which to end the animated trace
        
        Examples:
            ::
        
                # 
                # Select the particle trace part(s) to animate 
                # 
                ensight.part.select_begin(2)
                # 
                # Toggle off the visibility of the selected particle trace part(s), and 
                # animate them. 
                # 
                ensight.part.modify_begin()
                ensight.part.visible("OFF")
                ensight.ptrace.animate("ON")
                ensight.part.modify_end()
                # 
                # End trace animation at .5 
                # 
                ensight.anim_traces.set_max_time("ON")
                ensight.anim_traces.max_time(5.0000e-01)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_traces.max_time({repr(p0)})'''
        return self._session.cmd(cmd)

    def multiple_pulses(self, p0: str) -> int:
        """Toggles on/off multiple emission of animated traces for the selected particle trace part(s).
        
        | Not applicable to pathlines. The pulse interval is controlled via the "anim_traces: pulse_interval" command.
        | When ON, will start a set of animated traces every <time_value> time units (as specified via the "pulse_interval" command).
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                # 
                # Select the particle trace part(s) to animate 
                # 
                ensight.part.select_begin(2)
                # 
                # Toggle off the visibility of the selected particle trace part(s), and 
                # animate them. 
                # 
                ensight.part.modify_begin()
                ensight.part.visible("OFF")
                ensight.ptrace.animate("ON")
                ensight.part.modify_end()
                # 
                # Toggle on multiple animated trace pulses 
                # 
                ensight.anim_traces.multiple_pulses("ON")
                ensight.anim_traces.pulse_interval(1.0000e-03)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_traces.multiple_pulses({repr(p0)})'''
        return self._session.cmd(cmd)

    def particle_time(self, p0: float) -> int:
        """Specify the time duration (length) of the animated trace segments.
        
        | The particle trace length parameter scales the length of all animated traces at all times.
        | The animated trace segments will be short when speed is low and long when speed is high.
        
        Args:
            p0:
                'time_value' length in units of time of the animated trace segment
        
        Examples:
            ::
        
                # 
                # Select the particle trace part(s) to animate 
                # 
                ensight.part.select_begin(2)
                # 
                # Toggle off the visibility of the selected particle trace part(s), and 
                # animate them. 
                # 
                ensight.part.modify_begin()
                ensight.part.visible("OFF")
                ensight.ptrace.animate("ON")
                ensight.part.modify_end()
                # 
                # Specify a animated trace length 
                # 
                ensight.anim_traces.particle_time(1.0000e-04)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_traces.particle_time({repr(p0)})'''
        return self._session.cmd(cmd)

    def pulse_interval(self, p0: float) -> int:
        """Specifies the time delay when using multiple animated trace pulses;
        
        | Not applicable when "anim_traces: multiple_pulses OFF".
        
        Args:
            p0:
                'time_value' time delay interval between trace pulses
        
        Examples:
            ::
        
                # 
                # Select the particle trace part(s) to animate 
                # 
                ensight.part.select_begin(2)
                # 
                # Toggle off the visibility of the selected particle trace part(s), and 
                # animate them. 
                # 
                ensight.part.modify_begin()
                ensight.part.visible("OFF")
                ensight.ptrace.animate("ON")
                ensight.part.modify_end()
                # 
                # Toggle on multiple animated trace pulses 
                # 
                ensight.anim_traces.multiple_pulses("ON")
                ensight.anim_traces.pulse_interval(1.0000e-03)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_traces.pulse_interval({repr(p0)})'''
        return self._session.cmd(cmd)

    def rgb(self, p0: float, p1: float, p2: float) -> int:
        """Anim_traces: rgb

        """
        cmd = f'''ensight.anim_traces.rgb({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def set_max_time(self, p0: str) -> int:
        """Toggles on/off the maximum lifetime for all animated traces.
        
        | Used in conjunction with "anim_traces: max_time".
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                # 
                # Select the particle trace part(s) to animate 
                # 
                ensight.part.select_begin(2)
                # 
                # Toggle off the visibility of the selected particle trace part(s), and 
                # animate them. 
                # 
                ensight.part.modify_begin()
                ensight.part.visible("OFF")
                ensight.ptrace.animate("ON")
                ensight.part.modify_end()
                # 
                # End trace animation at simulation time .5 
                # 
                ensight.anim_traces.set_max_time("ON")
                ensight.anim_traces.max_time(5.0000e-01)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_traces.set_max_time({repr(p0)})'''
        return self._session.cmd(cmd)

    def start_time(self, p0: float) -> int:
        """Specifies the time value to start the particle animation.
        
        Args:
            p0:
                'time_value' time at which to begin the animated traces
        
        Examples:
            ::
        
                # 
                # Select the particle trace part(s) to animate 
                # 
                ensight.part.select_begin(2)
                # 
                # Toggle off the visibility of the selected particle trace part(s), and 
                # animate them. 
                # 
                ensight.part.modify_begin()
                ensight.part.visible("OFF")
                ensight.ptrace.animate("ON")
                ensight.part.modify_end()
                # 
                # Start animated traces at .1 rather than 0. 
                # 
                ensight.anim_traces.start_time(1.0000e-01)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_traces.start_time({repr(p0)})'''
        return self._session.cmd(cmd)

    def sync_to_transient(self, p0: str) -> int:
        """Toggles on/off synchronization of animated tracer position to solution time of transient data.
        
        | Only applicable with transient data cases. (See "solution_time: current_step" and "solution_time: update_to_current".)
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                # 
                # Set the 
                # 
                ensight.solution_time.current_step(4.0000e+01)
                ensight.solution_time.update_to_current()
                # 
                # Select the particle trace part(s) to animate 
                # 
                ensight.part.select_begin(2)
                # 
                # Toggle off the visibility of the selected particle trace part(s), and 
                # animate them. 
                # 
                ensight.part.modify_begin()
                ensight.part.visible("OFF")
                ensight.ptrace.animate("ON")
                ensight.part.modify_end()
                # 
                # Toggle off synchronization with transient data 
                # 
                ensight.anim_traces.sync_to_transient("OFF")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_traces.sync_to_transient({repr(p0)})'''
        return self._session.cmd(cmd)


class anim_screens:
    """Class wrapper for EnSight anim_screens module

    This class acts as a proxy for the EnSight Python module ensight.anim_screens
    """
    def __init__(self, session: Session):
        self._session = session

    def save_multiple_images(self, p0: str) -> int:
        """Option to save a single image or multiple images from a flat-wall detached display.
        
        | When saving a flat-wall detached display, the user can choose to write one large image for the wall or one image per pipe from the dconfig file. This option is only valid when the animation size is detached_display.
        
        Args:
            p0:
                'size'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.anim_keyframe.create_keyframe()
                ensight.view_transf.rotate(-4.500000e+01,7.500000e+01,0.000000e+00)
                ensight.anim_keyframe.create_keyframe()
                ensight.anim_screens.type("detached_display")
                ensight.anim_screens.save_multiple_images("ON")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_screens.save_multiple_images({repr(p0)})'''
        return self._session.cmd(cmd)

    def type(self, p0: str) -> int:
        """Specifies the size of the graphics window to use during keyframe animation playback.
        
        | The NTSC window size is 640x480 and corresponds to the size used by US video recording equipment.  The PAL window size is 720x576.  It is used by most foreign recording equipment. NTSC and PAL sizes have their window origins in the lower left corner of the monitor.  user_defined windows can be located anywhere on the monitor.
        
        Args:
            p0:
                'size'
        
                * detached_display
                * full
                * normal
                * NTSC
                * PAL
                * user_defined
                * HD720p
                * HD1080p
                * DVDNTSC
                * DVDPAL
        
        Examples:
            ::
        
                #
                # This plays a keyframe animation in a 320x200 window.
                #
                ensight.anim_keyframe.keyframing("ON")
                ensight.anim_keyframe.create_keyframe()
                ensight.view_transf.zoom(0.561365)
                ensight.anim_keyframe.create_keyframe()
                ensight.anim_screens.type("user_defined")
                ensight.anim_screens.x_min(0)
                ensight.anim_screens.x_max(319)
                ensight.anim_screens.y_min(0)
                ensight.anim_screens.y_max(199)
                ensight.anim_keyframe.run()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_screens.type({repr(p0)})'''
        return self._session.cmd(cmd)

    def x_max(self, p0: int) -> int:
        """Specifies the right x/y coordinate of the keyframe animation window during playback.
        
        | The range is 0 to maximum graphics resolution - 1.
        
        Args:
            p0:
                'coord' screen coordinate of the left (x_min), right (x_max), bottom (y_min) and top (y_max)
        
        Examples:
            ::
        
                #
                # This plays a keyframe animation in a 320x200 window.
                #
                ensight.anim_keyframe.keyframing("ON")
                ensight.anim_keyframe.create_keyframe()
                ensight.view_transf.zoom(0.561365)
                ensight.anim_keyframe.create_keyframe()
                ensight.anim_screens.type("user_defined")
                ensight.anim_screens.x_min(0)
                ensight.anim_screens.x_max(319)
                ensight.anim_screens.y_min(0)
                ensight.anim_screens.y_max(199)
                ensight.anim_keyframe.run()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_screens.x_max({repr(p0)})'''
        return self._session.cmd(cmd)

    def x_min(self, p0: int) -> int:
        """Specifies the right x/y coordinate of the keyframe animation window during playback.
        
        | The range is 0 to maximum graphics resolution - 1.
        
        Args:
            p0:
                'coord' screen coordinate of the left (x_min), right (x_max), bottom (y_min) and top (y_max)
        
        Examples:
            ::
        
                #
                # This plays a keyframe animation in a 320x200 window.
                #
                ensight.anim_keyframe.keyframing("ON")
                ensight.anim_keyframe.create_keyframe()
                ensight.view_transf.zoom(0.561365)
                ensight.anim_keyframe.create_keyframe()
                ensight.anim_screens.type("user_defined")
                ensight.anim_screens.x_min(0)
                ensight.anim_screens.x_max(319)
                ensight.anim_screens.y_min(0)
                ensight.anim_screens.y_max(199)
                ensight.anim_keyframe.run()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_screens.x_min({repr(p0)})'''
        return self._session.cmd(cmd)

    def y_max(self, p0: int) -> int:
        """Specifies the right x/y coordinate of the keyframe animation window during playback.
        
        | The range is 0 to maximum graphics resolution - 1.
        
        Args:
            p0:
                'coord' screen coordinate of the left (x_min), right (x_max), bottom (y_min) and top (y_max)
        
        Examples:
            ::
        
                #
                # This plays a keyframe animation in a 320x200 window.
                #
                ensight.anim_keyframe.keyframing("ON")
                ensight.anim_keyframe.create_keyframe()
                ensight.view_transf.zoom(0.561365)
                ensight.anim_keyframe.create_keyframe()
                ensight.anim_screens.type("user_defined")
                ensight.anim_screens.x_min(0)
                ensight.anim_screens.x_max(319)
                ensight.anim_screens.y_min(0)
                ensight.anim_screens.y_max(199)
                ensight.anim_keyframe.run()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_screens.y_max({repr(p0)})'''
        return self._session.cmd(cmd)

    def y_min(self, p0: int) -> int:
        """Specifies the right x/y coordinate of the keyframe animation window during playback.
        
        | The range is 0 to maximum graphics resolution - 1.
        
        Args:
            p0:
                'coord' screen coordinate of the left (x_min), right (x_max), bottom (y_min) and top (y_max)
        
        Examples:
            ::
        
                #
                # This plays a keyframe animation in a 320x200 window.
                #
                ensight.anim_keyframe.keyframing("ON")
                ensight.anim_keyframe.create_keyframe()
                ensight.view_transf.zoom(0.561365)
                ensight.anim_keyframe.create_keyframe()
                ensight.anim_screens.type("user_defined")
                ensight.anim_screens.x_min(0)
                ensight.anim_screens.x_max(319)
                ensight.anim_screens.y_min(0)
                ensight.anim_screens.y_max(199)
                ensight.anim_keyframe.run()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_screens.y_min({repr(p0)})'''
        return self._session.cmd(cmd)


class anim_recorders:
    """Class wrapper for EnSight anim_recorders module

    This class acts as a proxy for the EnSight Python module ensight.anim_recorders
    """
    def __init__(self, session: Session):
        self._session = session

    def file_number(self, p0: str) -> int:
        """Anim_recorders: file_number

        """
        cmd = f'''ensight.anim_recorders.file_number({repr(p0)})'''
        return self._session.cmd(cmd)

    def file_prefix(self, p0: str) -> int:
        """Specifies the external file name to use for keyframe animation recording.
        
        | The filename can also include an optional directory path. The name is a prefix.  A suffix will automatically be added that is based on the animation file format (e.g. '.evo' for EnVideo files)
        | If a single image format is specified (i.e. PostScript), then a four digit sequence number will be added between the prefix and suffix.
        
        Args:
            p0:
                'filename' animation file name prefix
        
        Examples:
            ::
        
                ensight.anim_keyframe.keyframing("ON")
                ensight.anim_keyframe.create_keyframe()
                ensight.view_transf.rotate(0.0,90.0,0.0)
                ensight.anim_keyframe.create_keyframe()
                ensight.file.image_format("envideo")
                # record envideo file to /tmp/my_animation.evo
                ensight.anim_recorders.file_prefix("/tmp/my_animation")
                ensight.anim_recorders.record("ON")
                ensight.anim_keyframe.run()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_recorders.file_prefix({repr(p0)})'''
        return self._session.cmd(cmd)

    def hold(self, p0: int, p1: int) -> int:
        """Anim_recorders: hold

        """
        cmd = f'''ensight.anim_recorders.hold({repr(p0)},{repr(p1)})'''
        return self._session.cmd(cmd)

    def record(self, p0: str) -> int:
        """Records the keyframe animation to an external file(s).
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.anim_keyframe.keyframing("ON")
                ensight.anim_keyframe.create_keyframe()
                ensight.view_transf.rotate(0.0,90.0,0.0)
                ensight.anim_keyframe.create_keyframe()
                ensight.file.image_format("envideo")
                ensight.anim_recorders.file_prefix("./my_animation")
                ensight.anim_recorders.record("ON")
                ensight.anim_keyframe.run()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_recorders.record({repr(p0)})'''
        return self._session.cmd(cmd)

    def render_offscreen(self, p0: str) -> int:
        """Specifies using hardware assisted offscreen rendering for keyframe animation on platforms that support it.
        
        | This depends on an OpenGL feature called pbuffers.  It is currently supported on SGI platforms.  However, due to bugs in SGI's implementation, it can be problematic.  You may need to try different video formats (i.e., use ircombine) to get pbuffer rendering to work correctly.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.anim_keyframe.keyframing("ON")
                ensight.anim_keyframe.create_keyframe()
                ensight.view_transf.rotate(0.0,90.0,0.0)
                ensight.anim_keyframe.create_keyframe()
                ensight.file.image_format("envideo")
                ensight.anim_recorders.file_prefix("./my_animation")
                ensight.anim_recorders.record("ON")
                ensight.anim_recorders.render_offscreen("ON")
                ensight.anim_keyframe.run()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_recorders.render_offscreen({repr(p0)})'''
        return self._session.cmd(cmd)

    def type(self, p0: str) -> int:
        """Anim_recorders: type

        """
        cmd = f'''ensight.anim_recorders.type({repr(p0)})'''
        return self._session.cmd(cmd)


class anim_quick:
    """Class wrapper for EnSight anim_quick module

    This class acts as a proxy for the EnSight Python module ensight.anim_quick
    """
    def __init__(self, session: Session):
        self._session = session

    def accelerate_first(self, p0: str) -> int:
        """Controls the acceleration for the first/last keyframes created for quick animations.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                #
                # turn on keyframe animation
                #
                ensight.anim_keyframe.keyframing("ON")
                #
                # move the camera to the right one half revolution
                #
                ensight.anim_quick.fly_around("ON")
                ensight.anim_quick.fly_direction("right")
                ensight.anim_quick.fly_revolutions(0.5)
                #
                # accelerate at the first keyframe but not at the last
                #
                ensight.anim_quick.accelerate_first("ON")
                ensight.anim_quick.accelerate_last("OFF")
                #
                # create a total of 125 frames 
                # 
                ensight.anim_quick.total_frames(125)
                ensight.anim_quick.create_keyframes()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_quick.accelerate_first({repr(p0)})'''
        return self._session.cmd(cmd)

    def accelerate_last(self, p0: str) -> int:
        """Controls the acceleration for the first/last keyframes created for quick animations.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                #
                # turn on keyframe animation
                #
                ensight.anim_keyframe.keyframing("ON")
                #
                # move the camera to the right one half revolution
                #
                ensight.anim_quick.fly_around("ON")
                ensight.anim_quick.fly_direction("right")
                ensight.anim_quick.fly_revolutions(0.5)
                #
                # accelerate at the first keyframe but not at the last
                #
                ensight.anim_quick.accelerate_first("ON")
                ensight.anim_quick.accelerate_last("OFF")
                #
                # create a total of 125 frames 
                # 
                ensight.anim_quick.total_frames(125)
                ensight.anim_quick.create_keyframes()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_quick.accelerate_last({repr(p0)})'''
        return self._session.cmd(cmd)

    def create_keyframes(self) -> int:
        """Creates the keyframes for the quick_animation setup.
        
        Examples:
            ::
        
                #
                # turn on keyframe animation
                #
                ensight.anim_keyframe.keyframing("ON")
                #
                # create an exploded view about 2,0,0 in the x direction.
                # The exploded distance is set to 200 units
                #
                ensight.anim_quick.explode_view("ON")
                ensight.anim_quick.explode_origin(2,0,0)
                ensight.anim_quick.explode_direction("x")
                ensight.anim_quick.explode_distance(200)
                #
                # while rotating the scene about the x axis 2 revolutions positive direction
                #
                ensight.anim_quick.rotate_objects("ON")
                ensight.anim_quick.rotate_direction("x positively")
                ensight.anim_quick.rotate_revolutions("x",2.000000)
                #
                # accelerate at the first keyframe but not at the last
                #
                ensight.anim_quick.accelerate_first("ON")
                ensight.anim_quick.accelerate_last("OFF")
                #
                # create a total of 125 frames 
                # 
                ensight.anim_quick.total_frames(125)
                ensight.anim_quick.create_keyframes()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_quick.create_keyframes()'''
        return self._session.cmd(cmd)

    def explode_direction(self, p0: str) -> int:
        """Sets up an exploded view quick animation.
        
        Args:
            p0:
                'direction'
        
                * x
                * y
                * z
                * xyz
                * radial
        
        Examples:
            ::
        
                #
                # turn on keyframe animation
                #
                ensight.anim_keyframe.keyframing("ON")
                #
                # create an exploded view about 2,0,0 in the x direction.
                # The exploded distance is set to 200 units
                #
                ensight.anim_quick.explode_view("ON")
                ensight.anim_quick.explode_origin(2,0,0)
                ensight.anim_quick.explode_direction("x")
                ensight.anim_quick.explode_distance(200)
                #
                # while rotating the scene about the x axis 2 revolutions positive direction
                #
                ensight.anim_quick.rotate_objects("ON")
                ensight.anim_quick.rotate_direction("x positively")
                ensight.anim_quick.rotate_revolutions("x",2.000000)
                #
                # accelerate at the first keyframe but not at the last
                #
                ensight.anim_quick.accelerate_first("ON")
                ensight.anim_quick.accelerate_last("OFF")
                #
                # create a total of 125 frames 
                # 
                ensight.anim_quick.total_frames(125)
                ensight.anim_quick.create_keyframes()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_quick.explode_direction({repr(p0)})'''
        return self._session.cmd(cmd)

    def explode_distance(self, p0: float) -> int:
        """Sets the exploded view distance.
        
        Args:
            p0:
                'distance' the maximum distance a part will be moved
        
        Examples:
            ::
        
                #
                # turn on keyframe animation
                #
                ensight.anim_keyframe.keyframing("ON")
                #
                # create an exploded view about 2,0,0 in the x direction.
                # The exploded distance is set to 200 units
                #
                ensight.anim_quick.explode_view("ON")
                ensight.anim_quick.explode_origin(2,0,0)
                ensight.anim_quick.explode_direction("x")
                ensight.anim_quick.explode_distance(200)
                #
                # while rotating the scene about the x axis 2 revolutions positive direction
                #
                ensight.anim_quick.rotate_objects("ON")
                ensight.anim_quick.rotate_direction("x positively")
                ensight.anim_quick.rotate_revolutions("x",2.000000)
                #
                # accelerate at the first keyframe but not at the last
                #
                ensight.anim_quick.accelerate_first("ON")
                ensight.anim_quick.accelerate_last("OFF")
                #
                # create a total of 125 frames 
                # 
                ensight.anim_quick.total_frames(125)
                ensight.anim_quick.create_keyframes()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_quick.explode_distance({repr(p0)})'''
        return self._session.cmd(cmd)

    def explode_origin(self, p0: float, p1: float, p2: float) -> int:
        """Sets the exploded view origin.
        
        Args:
            p0:
                'x_ori' x coordinate of the explode origin
            p1:
                'y_ori' y coordinate of the explode origin
            p2:
                'z_ori' z coordinate of the explode origin
        
        Examples:
            ::
        
                #
                # turn on keyframe animation
                #
                ensight.anim_keyframe.keyframing("ON")
                #
                # create an exploded view about 2,0,0 in the x direction.
                # The exploded distance is set to 200 units
                #
                ensight.anim_quick.explode_view("ON")
                ensight.anim_quick.explode_origin(2,0,0)
                ensight.anim_quick.explode_direction("x")
                ensight.anim_quick.explode_distance(200)
                #
                # while rotating the scene about the x axis 2 revolutions positive direction
                #
                ensight.anim_quick.rotate_objects("ON")
                ensight.anim_quick.rotate_direction("x positively")
                ensight.anim_quick.rotate_revolutions("x",2.000000)
                #
                # accelerate at the first keyframe but not at the last
                #
                ensight.anim_quick.accelerate_first("ON")
                ensight.anim_quick.accelerate_last("OFF")
                #
                # create a total of 125 frames 
                # 
                ensight.anim_quick.total_frames(125)
                ensight.anim_quick.create_keyframes()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_quick.explode_origin({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def explode_view(self, p0: str) -> int:
        """Sets up an exploded view quick animation.
        
        | The exploded view is not added until a "anim_quick: create_keyframes" command.
        | The exploded view can be used in combination with "rotate_objects" and "explode_view"
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                #
                # turn on keyframe animation
                #
                ensight.anim_keyframe.keyframing("ON")
                #
                # create an exploded view about 2,0,0 in the x direction.
                # The exploded distance is set to 200 units
                #
                ensight.anim_quick.explode_view("ON")
                ensight.anim_quick.explode_origin(2,0,0)
                ensight.anim_quick.explode_direction("x")
                ensight.anim_quick.explode_distance(200)
                #
                # while rotating the scene about the x axis 2 revolutions positive direction
                #
                ensight.anim_quick.rotate_objects("ON")
                ensight.anim_quick.rotate_direction("x positively")
                ensight.anim_quick.rotate_revolutions("x",2.000000)
                #
                # accelerate at the first keyframe but not at the last
                #
                ensight.anim_quick.accelerate_first("ON")
                ensight.anim_quick.accelerate_last("OFF")
                #
                # create a total of 125 frames 
                # 
                ensight.anim_quick.total_frames(125)
                ensight.anim_quick.create_keyframes()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_quick.explode_view({repr(p0)})'''
        return self._session.cmd(cmd)

    def fly_around(self, p0: str) -> int:
        """Sets up a fly-around quick animation.
        
        | The fly-around is not added until a "anim_quick: create_keyframes" command.
        | The fly-around can be used in combination with "rotate_objects" and "explode_view"
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                #
                # turn on keyframe animation
                #
                ensight.anim_keyframe.keyframing("ON")
                #
                # move the camera to the right one half revolution
                #
                ensight.anim_quick.fly_around("ON")
                ensight.anim_quick.fly_direction("right")
                ensight.anim_quick.fly_revolutions(0.5)
                #
                # accelerate at the first keyframe but not at the last
                #
                ensight.anim_quick.accelerate_first("ON")
                ensight.anim_quick.accelerate_last("OFF")
                #
                # create a total of 125 frames 
                # 
                ensight.anim_quick.total_frames(125)
                ensight.anim_quick.create_keyframes()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_quick.fly_around({repr(p0)})'''
        return self._session.cmd(cmd)

    def fly_direction(self, p0: str) -> int:
        """Sets up the direction for a fly-around animation.
        
        | A fly-around moves the look-from position in an arc.
        
        Args:
            p0:
                'direction'
        
                * right
                * left
        
        Examples:
            ::
        
                #
                # turn on keyframe animation
                #
                ensight.anim_keyframe.keyframing("ON")
                #
                # move the camera to the right one half revolution
                #
                ensight.anim_quick.fly_around("ON")
                ensight.anim_quick.fly_direction("right")
                ensight.anim_quick.fly_revolutions(0.5)
                #
                # accelerate at the first keyframe but not at the last
                #
                ensight.anim_quick.accelerate_first("ON")
                ensight.anim_quick.accelerate_last("OFF")
                #
                # create a total of 125 frames 
                # 
                ensight.anim_quick.total_frames(125)
                ensight.anim_quick.create_keyframes()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_quick.fly_direction({repr(p0)})'''
        return self._session.cmd(cmd)

    def fly_revolutions(self, p0: float) -> int:
        """Sets the number of revolutions for the fly-around quick animation.
        
        Args:
            p0:
                'many_revs' The number of revolutions to add
        
        Examples:
            ::
        
                #
                # turn on keyframe animation
                #
                ensight.anim_keyframe.keyframing("ON")
                #
                # move the camera to the right one half revolution
                #
                ensight.anim_quick.fly_around("ON")
                ensight.anim_quick.fly_direction("right")
                ensight.anim_quick.fly_revolutions(0.5)
                #
                # accelerate at the first keyframe but not at the last
                #
                ensight.anim_quick.accelerate_first("ON")
                ensight.anim_quick.accelerate_last("OFF")
                #
                # create a total of 125 frames 
                # 
                ensight.anim_quick.total_frames(125)
                ensight.anim_quick.create_keyframes()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_quick.fly_revolutions({repr(p0)})'''
        return self._session.cmd(cmd)

    def rotate_direction(self, p0: str) -> int:
        """Specifies the direction of the rotation.
        
        Args:
            p0:
                'axis'
        
                * x
                * y
                * z
            p1:
                'direction'
        
                * positively
                * negatively
        
        Examples:
            ::
        
                #
                # turn on keyframe animation
                #
                ensight.anim_keyframe.keyframing("ON")
                #
                # move the camera to the right one half revolution
                #
                ensight.anim_quick.fly_around("ON")
                ensight.anim_quick.fly_direction("right")
                ensight.anim_quick.fly_revolutions(0.5)
                #
                # while rotating the scene about the x axis 2 revolutions negative direction
                #
                ensight.anim_quick.rotate_objects("ON")
                ensight.anim_quick.rotate_direction("x negatively")
                ensight.anim_quick.rotate_revolutions("x",2.000000)
                #
                # accelerate at the first keyframe but not at the last
                #
                ensight.anim_quick.accelerate_first("ON")
                ensight.anim_quick.accelerate_last("OFF")
                #
                # create a total of 125 frames 
                # 
                ensight.anim_quick.total_frames(125)
                ensight.anim_quick.create_keyframes()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_quick.rotate_direction({repr(p0)})'''
        return self._session.cmd(cmd)

    def rotate_objects(self, p0: str) -> int:
        """Sets up a scene rotation for quick animation.
        
        | The rotation is not added until a "anim_quick: create_keyframes" command.
        | The rotation can be used in combination with "fly_around" and "explode_view"
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                #
                # turn on keyframe animation
                #
                ensight.anim_keyframe.keyframing("ON")
                #
                # move the camera to the right one half revolution
                #
                ensight.anim_quick.fly_around("ON")
                ensight.anim_quick.fly_direction("right")
                ensight.anim_quick.fly_revolutions(0.5)
                #
                # while rotating the scene about the x axis 2 revolutions negative direction
                #
                ensight.anim_quick.rotate_objects("ON")
                ensight.anim_quick.rotate_direction("x negatively")
                ensight.anim_quick.rotate_revolutions("x",2.000000)
                #
                # accelerate at the first keyframe but not at the last
                #
                ensight.anim_quick.accelerate_first("ON")
                ensight.anim_quick.accelerate_last("OFF")
                #
                # create a total of 125 frames 
                # 
                ensight.anim_quick.total_frames(125)
                ensight.anim_quick.create_keyframes()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_quick.rotate_objects({repr(p0)})'''
        return self._session.cmd(cmd)

    def rotate_revolutions(self, p0: float) -> int:
        """Sets the number of revolutions for rotate_objects quick animation.
        
        Args:
            p0:
                'many_revs' The number of revolutions to add
        
        Examples:
            ::
        
                #
                # turn on keyframe animation
                #
                ensight.anim_keyframe.keyframing("ON")
                #
                # move the camera to the right one half revolution
                #
                ensight.anim_quick.fly_around("ON")
                ensight.anim_quick.fly_direction("right")
                ensight.anim_quick.fly_revolutions(0.5)
                #
                # while rotating the scene about the x axis 2 revolutions negative direction
                #
                ensight.anim_quick.rotate_objects("ON")
                ensight.anim_quick.rotate_direction("x negatively")
                ensight.anim_quick.rotate_revolutions("x",2.000000)
                #
                # accelerate at the first keyframe but not at the last
                #
                ensight.anim_quick.accelerate_first("ON")
                ensight.anim_quick.accelerate_last("OFF")
                #
                # create a total of 125 frames 
                # 
                ensight.anim_quick.total_frames(125)
                ensight.anim_quick.create_keyframes()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_quick.rotate_revolutions({repr(p0)})'''
        return self._session.cmd(cmd)

    def total_frames(self, p0: int) -> int:
        """Sets the total number of frames (keyframes plus subframes) to be created when a "anim_quick: create_keyframes" command is executed.
        
        Args:
            p0:
                'num_frames' The total number of frames that will be created
        
        Examples:
            ::
        
                #
                # turn on keyframe animation
                #
                ensight.anim_keyframe.keyframing("ON")
                #
                # move the camera to the right one half revolution
                #
                ensight.anim_quick.fly_around("ON")
                ensight.anim_quick.fly_direction("right")
                ensight.anim_quick.fly_revolutions(0.5)
                #
                # accelerate at the first keyframe but not at the last
                #
                ensight.anim_quick.accelerate_first("ON")
                ensight.anim_quick.accelerate_last("OFF")
                #
                # create a total of 125 frames 
                # 
                ensight.anim_quick.total_frames(125)
                ensight.anim_quick.create_keyframes()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_quick.total_frames({repr(p0)})'''
        return self._session.cmd(cmd)


class anim_keyframe:
    """Class wrapper for EnSight anim_keyframe module

    This class acts as a proxy for the EnSight Python module ensight.anim_keyframe
    """
    def __init__(self, session: Session):
        self._session = session

    def acceleration(self, p0: str, p1: str) -> int:
        """Toggle acceleration into/out of a keyframe.
        
        Args:
            p0:
                'keyframe' The keyframe number to apply the acceleration
            p1:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.anim_keyframe.keyframing("ON")
                ensight.anim_keyframe.create_keyframe()
                ensight.view_transf.rotate(20,30,5)
                ensight.view_transf.translate(5,0,0)
                ensight.anim_keyframe.create_keyframe()
                #
                # accelerate out of keyframe 1
                #
                ensight.anim_keyframe.acceleration("1","ON")
                ensight.anim_keyframe.use_spline("ON")
                #
                # deaccelerate into keyframe 2
                #
                ensight.anim_keyframe.acceleration("2","ON")
                ensight.anim_keyframe.run()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_keyframe.acceleration({repr(p0)},{repr(p1)})'''
        return self._session.cmd(cmd)

    def animate_transparency(self, p0: str) -> int:
        """Toggles use of animated transparency.
        
        | This command can be turned on at any time during keyframe recording.  If it is on, any transparency modifications made to parts during keyframe specification will be animated during playback.  This can be used to create video effects such as fades.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.anim_keyframe.keyframing("ON")
                ensight.anim_keyframe.create_keyframe()
                # WARNING: following line includes OBSOLETE call (ensight.part.select_partname_begin).
                ensight.part.select_partname_begin("(CASE:Case 1)Isosurface part")
                ensight.part.modify_begin()
                # WARNING: following line includes OBSOLETE call (ensight.part.opaqueness).
                ensight.part.opaqueness(0.0)
                ensight.part.modify_end()
                ensight.anim_keyframe.create_keyframe()
                ensight.part.modify_begin()
                # WARNING: following line includes OBSOLETE call (ensight.part.opaqueness).
                ensight.part.opaqueness(1.0)
                ensight.part.modify_end()
                ensight.anim_keyframe.create_keyframe()
                ensight.anim_keyframe.animate_transparency("ON")
                ensight.anim_keyframe.run()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_keyframe.animate_transparency({repr(p0)})'''
        return self._session.cmd(cmd)

    def begin_simtime(self, p0: float) -> int:
        """Sets the starting simulation time value to use during transient keyframe animations.
        
        | The beginning/ending time step must be a valid value from the simulation.  An interpolated value cannot be used.
        
        Args:
            p0:
                'time_value' beginning/ending simulation time
        
        Examples:
            ::
        
                ensight.anim_keyframe.keyframing("ON")
                ensight.anim_keyframe.create_keyframe()
                ensight.view_transf.zoom(0.561365)
                ensight.anim_keyframe.create_keyframe()
                ensight.anim_keyframe.use_transient_data("ON")
                ensight.anim_keyframe.specify_time_as("simulation")
                ensight.anim_keyframe.begin_simtime(4.7000e-02)
                ensight.anim_keyframe.end_simtime(1.1750e-01)
                ensight.anim_keyframe.step_simtime(2.0000e-02)
                ensight.anim_keyframe.run()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_keyframe.begin_simtime({repr(p0)})'''
        return self._session.cmd(cmd)

    def begin_time_step(self, p0: int) -> int:
        """Sets the starting/ending time step to use during transient keyframe animations.
        
        Args:
            p0:
                'step_value' beginning/ending time step
        
        Examples:
            ::
        
                ensight.anim_keyframe.use_transient_data("ON")
                ensight.anim_keyframe.step_by(2.0000e+00)
                ensight.anim_keyframe.cycle("ON")
                ensight.anim_keyframe.begin_time_step(2)
                ensight.anim_keyframe.end_time_step(15)
                ensight.anim_keyframe.specify_time_as("step")
                ensight.anim_keyframe.run()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_keyframe.begin_time_step({repr(p0)})'''
        return self._session.cmd(cmd)

    def command(self, p0: int, p1: int) -> int:
        """Specifies a command to execute for at a particular keyframe.
        
        | During animation playback, when keyframe 'key' is encountered, its commands, if any, will be executed.  Up to five commands can be specified for a specific keyframe.  If more than five commands are needed, consider using the "play: file.cmd" command to play an external command file.   The command string format is the same for any command.  Also, consider using the "shell: external_app" command to execute an external application during animation.
        
        Args:
            p0:
                'key_num' specifies the keyframe
            p1:
                'cmd_num' specifies the command number
            p2:
                'command' specifies the command to execute
        
        Examples:
            ::
        
                ensight.anim_keyframe.keyframing("ON")
                ensight.anim_keyframe.create_keyframe()
                ensight.view_transf.zoom(0.561365)
                ensight.anim_keyframe.create_keyframe()
                ensight.view_transf.zoom(0.561365)
                ensight.anim_keyframe.create_keyframe()
                ensight.anim_keyframe.command(1,1,"view:","full_screen","on")
                ensight.anim_keyframe.command(1,2,"view:","hidden_surface","on")
                ensight.anim_keyframe.command(2,1,"play:","/usr/tmp/ensight_cmds.cmd")
                ensight.anim_keyframe.run()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_keyframe.command({repr(p0)},{repr(p1)})'''
        return self._session.cmd(cmd)

    def create_keyframe(self) -> int:
        """Records the current set of transformations/attributes as a keyframe.
        
        Examples:
            ::
        
                ensight.anim_keyframe.keyframing("ON")
                ensight.anim_keyframe.create_keyframe()
                ensight.view_transf.zoom(0.561365)
                ensight.anim_keyframe.create_keyframe()
                ensight.anim_keyframe.sub_frames(1,2,30)
                ensight.anim_keyframe.run()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_keyframe.create_keyframe()'''
        return self._session.cmd(cmd)

    def cycle(self, p0: str) -> int:
        """Toggles whether transient data will cycle during the keyframe animation.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.anim_keyframe.use_transient_data("ON")
                ensight.anim_keyframe.step_by(2.0000e+00)
                ensight.anim_keyframe.cycle("ON")
                ensight.anim_keyframe.begin_time_step(2)
                ensight.anim_keyframe.end_time_step(15)
                ensight.anim_keyframe.specify_time_as("step")
                ensight.anim_keyframe.run()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_keyframe.cycle({repr(p0)})'''
        return self._session.cmd(cmd)

    def delete_back_to(self, p0: int) -> int:
        """Deletes keyframes back to, but not including, the keyframe specified.
        
        Args:
            p0:
                'keyframe_num' keyframe to delete back to
        
        Examples:
            ::
        
                ensight.anim_keyframe.keyframing("ON")
                ensight.anim_keyframe.create_keyframe()
                ensight.view_transf.zoom(1.5)
                ensight.anim_keyframe.create_keyframe()
                ensight.view_transf.zoom(5.0)
                ensight.anim_keyframe.create_keyframe()
                ensight.anim_keyframe.delete_back_to(2)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_keyframe.delete_back_to({repr(p0)})'''
        return self._session.cmd(cmd)

    def end_simtime(self, p0: float) -> int:
        """Sets the starting simulation time value to use during transient keyframe animations.
        
        | The beginning/ending time step must be a valid value from the simulation.  An interpolated value cannot be used.
        
        Args:
            p0:
                'time_value' beginning/ending simulation time
        
        Examples:
            ::
        
                ensight.anim_keyframe.keyframing("ON")
                ensight.anim_keyframe.create_keyframe()
                ensight.view_transf.zoom(0.561365)
                ensight.anim_keyframe.create_keyframe()
                ensight.anim_keyframe.use_transient_data("ON")
                ensight.anim_keyframe.specify_time_as("simulation")
                ensight.anim_keyframe.begin_simtime(4.7000e-02)
                ensight.anim_keyframe.end_simtime(1.1750e-01)
                ensight.anim_keyframe.step_simtime(2.0000e-02)
                ensight.anim_keyframe.run()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_keyframe.end_simtime({repr(p0)})'''
        return self._session.cmd(cmd)

    def end_time_step(self, p0: int) -> int:
        """Sets the starting/ending time step to use during transient keyframe animations.
        
        Args:
            p0:
                'step_value' beginning/ending time step
        
        Examples:
            ::
        
                ensight.anim_keyframe.use_transient_data("ON")
                ensight.anim_keyframe.step_by(2.0000e+00)
                ensight.anim_keyframe.cycle("ON")
                ensight.anim_keyframe.begin_time_step(2)
                ensight.anim_keyframe.end_time_step(15)
                ensight.anim_keyframe.specify_time_as("step")
                ensight.anim_keyframe.run()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_keyframe.end_time_step({repr(p0)})'''
        return self._session.cmd(cmd)

    def hidden_line(self, args: Any) -> int:
        """Anim_keyframe: hidden_line

        """
        cmd = f'''ensight.anim_keyframe.hidden_line({repr(args)})'''
        return self._session.cmd(cmd)

    def hold(self, p0: int, p1: int) -> int:
        """Sets the number of frames to display for a keyframe.
        
        Args:
            p0:
                'keyframe' keyframe to control
            p1:
                'num_frames' display this many frames
        
        Examples:
            ::
        
                ensight.anim_keyframe.keyframing("ON")
                ensight.anim_keyframe.create_keyframe()
                ensight.view_transf.rotate(-84.910713,-3.917774,0.000000)
                ensight.view_transf.function("global")
                ensight.view_transf.rotate(13.660716,39.395405,0.000000)
                ensight.view_transf.function("global")
                ensight.anim_keyframe.create_keyframe()
                ensight.anim_keyframe.hold(1,10)
                ensight.anim_keyframe.run()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_keyframe.hold({repr(p0)},{repr(p1)})'''
        return self._session.cmd(cmd)

    def jump_to_frame(self, p0: int, p1: int) -> int:
        """Anim_keyframe: jump_to_frame

        """
        cmd = f'''ensight.anim_keyframe.jump_to_frame({repr(p0)},{repr(p1)})'''
        return self._session.cmd(cmd)

    def keyframing(self, p0: str) -> int:
        """Toggles keyframe animation recording.
        
        | Toggling off keyframe animation will delete the previously saved keyframes.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.anim_keyframe.keyframing("ON")
                ensight.anim_keyframe.create_keyframe()
                ensight.view_transf.rotate(28.489212,79.540230,0.000000)
                ensight.anim_keyframe.create_keyframe()
                ensight.anim_keyframe.run()
                ensight.anim_keyframe.keyframing("OFF")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_keyframe.keyframing({repr(p0)})'''
        return self._session.cmd(cmd)

    def play_backward(self) -> int:
        """Anim_keyframe: play_backward

        """
        cmd = f'''ensight.anim_keyframe.play_backward()'''
        return self._session.cmd(cmd)

    def play_forward(self) -> int:
        """Anim_keyframe: play_forward

        """
        cmd = f'''ensight.anim_keyframe.play_forward()'''
        return self._session.cmd(cmd)

    def play_style(self) -> int:
        """Anim_keyframe: play_style

        """
        cmd = f'''ensight.anim_keyframe.play_style()'''
        return self._session.cmd(cmd)

    def restore(self, p0: str) -> int:
        """Restores/saves keyframe animation data from/to a file.
        
        Args:
            p0:
                'filename' file name to use
        
        Examples:
            ::
        
                ensight.anim_keyframe.save("./my_anim")
                ensight.anim_keyframe.restore("./my_anim")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_keyframe.restore({repr(p0)})'''
        return self._session.cmd(cmd)

    def run(self) -> int:
        """Plays the keyframe animation.
        
        Examples:
            ::
        
                ensight.anim_keyframe.keyframing("ON")
                ensight.anim_keyframe.create_keyframe()
                ensight.view_transf.zoom(0.561365)
                ensight.anim_keyframe.create_keyframe()
                ensight.anim_keyframe.sub_frames(1,2,30)
                ensight.anim_keyframe.run()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_keyframe.run()'''
        return self._session.cmd(cmd)

    def run_from(self, p0: int) -> int:
        """Sets the first/last keyframe to use for playback.
        
        | When creating an animation with many keyframes, it is often helpful to play back a smaller range of keyframes instead of the entire animation. The value must be between 1 and the number of keyframes.  The "run_from" frame must be less than or equal to the "run_to' frame.
        
        Args:
            p0:
                'keyframe_num' beginning/ending keyframe
        
        Examples:
            ::
        
                ensight.anim_keyframe.run_from(2)
                ensight.anim_keyframe.run_to(3)
                ensight.anim_keyframe.run()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_keyframe.run_from({repr(p0)})'''
        return self._session.cmd(cmd)

    def run_from_subframe(self, p0: int) -> int:
        """Anim_keyframe: run_from_subframe

        """
        cmd = f'''ensight.anim_keyframe.run_from_subframe({repr(p0)})'''
        return self._session.cmd(cmd)

    def run_to(self, p0: int) -> int:
        """Sets the first/last keyframe to use for playback.
        
        | When creating an animation with many keyframes, it is often helpful to play back a smaller range of keyframes instead of the entire animation. The value must be between 1 and the number of keyframes.  The "run_from" frame must be less than or equal to the "run_to' frame.
        
        Args:
            p0:
                'keyframe_num' beginning/ending keyframe
        
        Examples:
            ::
        
                ensight.anim_keyframe.run_from(2)
                ensight.anim_keyframe.run_to(3)
                ensight.anim_keyframe.run()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_keyframe.run_to({repr(p0)})'''
        return self._session.cmd(cmd)

    def save(self, p0: str) -> int:
        """Restores/saves keyframe animation data from/to a file.
        
        Args:
            p0:
                'filename' file name to use
        
        Examples:
            ::
        
                ensight.anim_keyframe.save("./my_anim")
                ensight.anim_keyframe.restore("./my_anim")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_keyframe.save({repr(p0)})'''
        return self._session.cmd(cmd)

    def select_all_timesteps(self) -> int:
        """Selects all timesteps for the transient portion of the run.  It is the same as setting the transient start step to the beginning and the transient end step to the end.
        
        Examples:
            ::
        
                ensight.anim_keyframe.keyframing("ON")
                ensight.anim_keyframe.create_keyframe()
                ensight.anim_keyframe.create_keyframe()
                ensight.anim_keyframe.use_transient_data("ON")
                ensight.anim_keyframe.select_all_timesteps()
                ensight.anim_keyframe.run()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_keyframe.select_all_timesteps()'''
        return self._session.cmd(cmd)

    def shortpath_interpolation(self, p0: str) -> int:
        """Anim_keyframe: shortpath_interpolation

        """
        cmd = f'''ensight.anim_keyframe.shortpath_interpolation({repr(p0)})'''
        return self._session.cmd(cmd)

    def specify_step_by(self, p0: str) -> int:
        """Anim_keyframe: specify_step_by

        """
        cmd = f'''ensight.anim_keyframe.specify_step_by({repr(p0)})'''
        return self._session.cmd(cmd)

    def specify_time_as(self, p0: str) -> int:
        """Specifies whether time values during transient data animations use simulation time or time step number.
        
        Args:
            p0:
                'method'
        
                * simulation
                * step
        
        Examples:
            ::
        
                ensight.anim_keyframe.use_transient_data("ON")
                ensight.anim_keyframe.specify_time_as("step")
                ensight.anim_keyframe.step_by(2.0000e+00)
                ensight.anim_keyframe.cycle("ON")
                ensight.anim_keyframe.begin_time_step(2)
                ensight.anim_keyframe.end_time_step(15)
                ensight.anim_keyframe.run()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_keyframe.specify_time_as({repr(p0)})'''
        return self._session.cmd(cmd)

    def step_backward(self) -> int:
        """Anim_keyframe: step_backward

        """
        cmd = f'''ensight.anim_keyframe.step_backward()'''
        return self._session.cmd(cmd)

    def step_by(self, p0: float) -> int:
        """Specifies the time increment for transient data during keyframe animations.
        
        | For each frame of the animation, the time step will be incremented by this value.  If needed and possible, interpolation will be used.
        
        Args:
            p0:
                'increment' time step increment
        
        Examples:
            ::
        
                ensight.anim_keyframe.use_transient_data("ON")
                ensight.anim_keyframe.specify_time_as("step")
                ensight.anim_keyframe.step_by(2.0000e+00)
                ensight.anim_keyframe.begin_time_step(2)
                ensight.anim_keyframe.end_time_step(15)
                ensight.anim_keyframe.run()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_keyframe.step_by({repr(p0)})'''
        return self._session.cmd(cmd)

    def step_forward(self) -> int:
        """Anim_keyframe: step_forward

        """
        cmd = f'''ensight.anim_keyframe.step_forward()'''
        return self._session.cmd(cmd)

    def step_simtime(self, p0: float) -> int:
        """Sets the simulation time increment to use during transient keyframe animations.
        
        | For each frame in the animation, simulation time will increment by this value.  If needed and possible, interpolation will be used.
        
        Args:
            p0:
                'increment' simulation time increment
        
        Examples:
            ::
        
                ensight.anim_keyframe.keyframing("ON")
                ensight.anim_keyframe.create_keyframe()
                ensight.view_transf.zoom(0.561365)
                ensight.anim_keyframe.create_keyframe()
                ensight.anim_keyframe.use_transient_data("ON")
                ensight.anim_keyframe.cycle("ON")
                ensight.anim_keyframe.specify_time_as("simulation")
                ensight.anim_keyframe.begin_simtime(4.7000e-02)
                ensight.anim_keyframe.end_simtime(1.1750e-01)
                ensight.anim_keyframe.step_simtime(2.0000e-02)
                ensight.anim_keyframe.run()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_keyframe.step_simtime({repr(p0)})'''
        return self._session.cmd(cmd)

    def stop(self) -> int:
        """Anim_keyframe: stop

        """
        cmd = f'''ensight.anim_keyframe.stop()'''
        return self._session.cmd(cmd)

    def sub_frames(self, p0: int, p1: int, p2: int) -> int:
        """Sets the number of in-between frames between keyframes key1 and key2.
        
        | key1 and key2 must be consecutively keyframes.
        
        Args:
            p0:
                'key1' specifies the starting keyframe
            p1:
                'key2' specifies the ending keyframe (must be key1 + 1)
            p2:
                'subframes' specifies the number of in-between frames between key1 and key2
        
        Examples:
            ::
        
                ensight.anim_keyframe.keyframing("ON")
                ensight.anim_keyframe.create_keyframe()
                ensight.view_transf.zoom(0.561365)
                ensight.anim_keyframe.create_keyframe()
                ensight.anim_keyframe.sub_frames(1,2,30)
                ensight.anim_keyframe.run()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_keyframe.sub_frames({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def timeline_arrive_type(self, p0: str) -> int:
        """Specifies the action to be taken when the min/max time is encountered.
        
        | Only used if "anim_keyframe: timeline_specify_incr" is ON
        
        Args:
            p0:
                'action'
        
                * swing
                * loop
        
        Examples:
            ::
        
                #
                # turn on keyframing and create 4 keyframes 
                #
                ensight.anim_keyframe.keyframing("ON")
                ensight.anim_keyframe.create_keyframe()
                ensight.anim_keyframe.create_keyframe()
                ensight.anim_keyframe.create_keyframe()
                ensight.anim_keyframe.create_keyframe()
                #
                # transient data (and timelines) will be used during the animation
                #
                ensight.anim_keyframe.use_transient_data("ON")
                #
                # 
                ensight.anim_keyframe.timeline_select(1)
                #
                # the first timeline goes from keyframe 2 to 3 (i.e, no transient
                # data is used for keyframe 1 to 2)
                #
                ensight.anim_keyframe.timeline_start_keyframe(2)
                ensight.anim_keyframe.timeline_end_keyframe(3)
                #
                # At keyframe 2 the "Begin" (as defined in the solution time dialog)
                # time is used.  At keyframe 3 the "End" time is used.
                #
                ensight.anim_keyframe.timeline_start_type("use_begin")
                ensight.anim_keyframe.timeline_end_type("use_end")
                #
                # Create a new timeline and select it for editing
                #
                ensight.anim_keyframe.timeline_new()
                ensight.anim_keyframe.timeline_select(2)
                #
                # This timeline goes from keyframe 3 to 4
                #
                ensight.anim_keyframe.timeline_start_keyframe(3)
                ensight.anim_keyframe.timeline_end_keyframe(4)
                #
                # At keyframe 3 the current time will be used (which will
                # be the "End" time since the first timeline ends with this time
                # We do not specify the time at keyframe 4 but rather increment time
                # by 1.4 unit for each frame.  If we arrive at the begin/end time we will
                # "swing"
                #
                ensight.anim_keyframe.timeline_start_type("use_current")
                ensight.anim_keyframe.timeline_specify_incr("ON")
                ensight.anim_keyframe.timeline_time_increment(1.4)
                ensight.anim_keyframe.timeline_arrive_type("swing")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_keyframe.timeline_arrive_type({repr(p0)})'''
        return self._session.cmd(cmd)

    def timeline_delete(self, p0: int) -> int:
        """Delete a timeline.
        
        Args:
            p0:
                'timeline' timeline number to delete
        
        Examples:
            ::
        
                #
                # turn on keyframing and create 4 keyframes 
                #
                ensight.anim_keyframe.keyframing("ON")
                ensight.anim_keyframe.create_keyframe()
                ensight.anim_keyframe.create_keyframe()
                ensight.anim_keyframe.create_keyframe()
                ensight.anim_keyframe.create_keyframe()
                #
                # transient data (and timelines) will be used during the animation
                #
                ensight.anim_keyframe.use_transient_data("ON")
                #
                # 
                ensight.anim_keyframe.timeline_new()
                ensight.anim_keyframe.timeline_select(2)
                #
                # This timeline goes from keyframe 3 to 4
                #
                ensight.anim_keyframe.timeline_start_keyframe(3)
                ensight.anim_keyframe.timeline_end_keyframe(4)
                #
                # delete the first timeline
                #
                ensight.anim_keyframe.timeline_delete(1)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_keyframe.timeline_delete({repr(p0)})'''
        return self._session.cmd(cmd)

    def timeline_end_keyframe(self, p0: int) -> int:
        """Sets the begin/end keyframes for the timeline.
        
        Args:
            p0:
                'keyframe_num' beginning/ending keyframe for the timeline
        
        Examples:
            ::
        
                #
                # turn on keyframing and create 4 keyframes 
                #
                ensight.anim_keyframe.keyframing("ON")
                ensight.anim_keyframe.create_keyframe()
                ensight.anim_keyframe.create_keyframe()
                ensight.anim_keyframe.create_keyframe()
                ensight.anim_keyframe.create_keyframe()
                #
                # transient data (and timelines) will be used during the animation
                #
                ensight.anim_keyframe.use_transient_data("ON")
                #
                # 
                ensight.anim_keyframe.timeline_select(1)
                #
                # the first timeline goes from keyframe 2 to 3 (i.e, no transient
                # data is used for keyframe 1 to 2)
                #
                ensight.anim_keyframe.timeline_start_keyframe(2)
                ensight.anim_keyframe.timeline_end_keyframe(3)
                #
                # At keyframe 2 the "Begin" (as defined in the solution time dialog)
                # time is used.  At keyframe 3 the "End" time is used.
                #
                ensight.anim_keyframe.timeline_start_type("use_begin")
                ensight.anim_keyframe.timeline_end_type("use_end")
                #
                # Create a new timeline and select it for editing
                #
                ensight.anim_keyframe.timeline_new()
                ensight.anim_keyframe.timeline_select(2)
                #
                # This timeline goes from keyframe 3 to 4
                #
                ensight.anim_keyframe.timeline_start_keyframe(3)
                ensight.anim_keyframe.timeline_end_keyframe(4)
                #
                # At keyframe 3 the current time will be used (which will
                # be the "End" time since the first timeline ends with this time
                # We do not specify the time at keyframe 4 but rather increment time
                # by 1. unit for each frame.  If we arrive at the begin/end time we will
                # "swing"
                #
                ensight.anim_keyframe.timeline_start_type("use_current")
                ensight.anim_keyframe.timeline_specify_incr("ON")
                ensight.anim_keyframe.timeline_step_increment(1.)
                ensight.anim_keyframe.timeline_arrive_type("swing")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_keyframe.timeline_end_keyframe({repr(p0)})'''
        return self._session.cmd(cmd)

    def timeline_end_step(self, p0: float) -> int:
        """Sets the start/end timeline step value if being specified.
        
        | Only used if "anim_keyframe: timeline_start/end_type specify" is also set.
        
        Args:
            p0:
                'time_value' The time value (step) for the start/end of the timeline
        
        Examples:
            ::
        
                #
                # turn on keyframing and create 4 keyframes 
                #
                ensight.anim_keyframe.keyframing("ON")
                ensight.anim_keyframe.create_keyframe()
                ensight.anim_keyframe.create_keyframe()
                ensight.anim_keyframe.create_keyframe()
                ensight.anim_keyframe.create_keyframe()
                #
                # transient data (and timelines) will be used during the animation
                #
                ensight.anim_keyframe.use_transient_data("ON")
                #
                # 
                ensight.anim_keyframe.timeline_select(1)
                #
                # the first timeline goes from keyframe 2 to 3 (i.e, no transient
                # data is used for keyframe 1 to 2)
                #
                ensight.anim_keyframe.timeline_start_keyframe(2)
                ensight.anim_keyframe.timeline_end_keyframe(3)
                #
                # At keyframe 2 the "Begin" (as defined in the solution time dialog)
                # time is used.  At keyframe 3 the "End" time is used.
                #
                ensight.anim_keyframe.timeline_start_type("use_begin")
                ensight.anim_keyframe.timeline_end_type("use_end")
                #
                # Create a new timeline and select it for editing
                #
                ensight.anim_keyframe.timeline_new()
                ensight.anim_keyframe.timeline_select(2)
                #
                # This timeline goes from keyframe 3 to 4
                #
                ensight.anim_keyframe.timeline_start_keyframe(3)
                ensight.anim_keyframe.timeline_end_keyframe(4)
                #
                # At keyframe 3 the current time will be used (which will
                # be the "End" time since the first timeline ends with this time
                # At keyframe 4 we set time step to 4.
                #
                ensight.anim_keyframe.timeline_start_type("use_current")
                ensight.anim_keyframe.timeline_end_type("specify")
                ensight.anim_keyframe.timeline_end_time(4.)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_keyframe.timeline_end_step({repr(p0)})'''
        return self._session.cmd(cmd)

    def timeline_end_time(self, p0: float) -> int:
        """Sets the start/end timeline value if being specified.
        
        | Only used if "anim_keyframe: timeline_start/end_type specify" is also set.
        
        Args:
            p0:
                'time_value' The time value (simulation) for the start/end of the timeline
        
        Examples:
            ::
        
                #
                # turn on keyframing and create 4 keyframes 
                #
                ensight.anim_keyframe.keyframing("ON")
                ensight.anim_keyframe.create_keyframe()
                ensight.anim_keyframe.create_keyframe()
                ensight.anim_keyframe.create_keyframe()
                ensight.anim_keyframe.create_keyframe()
                #
                # transient data (and timelines) will be used during the animation
                #
                ensight.anim_keyframe.use_transient_data("ON")
                #
                # 
                ensight.anim_keyframe.timeline_select(1)
                #
                # the first timeline goes from keyframe 2 to 3 (i.e, no transient
                # data is used for keyframe 1 to 2)
                #
                ensight.anim_keyframe.timeline_start_keyframe(2)
                ensight.anim_keyframe.timeline_end_keyframe(3)
                #
                # At keyframe 2 the "Begin" (as defined in the solution time dialog)
                # time is used.  At keyframe 3 the "End" time is used.
                #
                ensight.anim_keyframe.timeline_start_type("use_begin")
                ensight.anim_keyframe.timeline_end_type("use_end")
                #
                # Create a new timeline and select it for editing
                #
                ensight.anim_keyframe.timeline_new()
                ensight.anim_keyframe.timeline_select(2)
                #
                # This timeline goes from keyframe 3 to 4
                #
                ensight.anim_keyframe.timeline_start_keyframe(3)
                ensight.anim_keyframe.timeline_end_keyframe(4)
                #
                # At keyframe 3 the current time will be used (which will
                # be the "End" time since the first timeline ends with this time
                # At keyframe 4 we set time to be 40.
                #
                ensight.anim_keyframe.timeline_start_type("use_current")
                ensight.anim_keyframe.timeline_end_type("specify")
                ensight.anim_keyframe.timeline_end_time(40.)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_keyframe.timeline_end_time({repr(p0)})'''
        return self._session.cmd(cmd)

    def timeline_end_type(self, p0: str) -> int:
        """Sets the begin/end time for the timeline.
        
        Args:
            p0:
                'time_option'
        
                * use_begin
                * use_end
                * use_current
                * specify
        
        Examples:
            ::
        
                #
                # turn on keyframing and create 4 keyframes 
                #
                ensight.anim_keyframe.keyframing("ON")
                ensight.anim_keyframe.create_keyframe()
                ensight.anim_keyframe.create_keyframe()
                ensight.anim_keyframe.create_keyframe()
                ensight.anim_keyframe.create_keyframe()
                #
                # transient data (and timelines) will be used during the animation
                #
                ensight.anim_keyframe.use_transient_data("ON")
                #
                # 
                ensight.anim_keyframe.timeline_select(1)
                #
                # the first timeline goes from keyframe 2 to 3 (i.e, no transient
                # data is used for keyframe 1 to 2)
                #
                ensight.anim_keyframe.timeline_start_keyframe(2)
                ensight.anim_keyframe.timeline_end_keyframe(3)
                #
                # At keyframe 2 the "Begin" (as defined in the solution time dialog)
                # time is used.  At keyframe 3 the "End" time is used.
                #
                ensight.anim_keyframe.timeline_start_type("use_begin")
                ensight.anim_keyframe.timeline_end_type("use_end")
                #
                # Create a new timeline and select it for editing
                #
                ensight.anim_keyframe.timeline_new()
                ensight.anim_keyframe.timeline_select(2)
                #
                # This timeline goes from keyframe 3 to 4
                #
                ensight.anim_keyframe.timeline_start_keyframe(3)
                ensight.anim_keyframe.timeline_end_keyframe(4)
                #
                # At keyframe 3 the current time will be used (which will
                # be the "End" time since the first timeline ends with this time
                # We do not specify the time at keyframe 4 but rather increment time
                # by 1. unit for each frame.  If we arrive at the begin/end time we will
                # "swing"
                #
                ensight.anim_keyframe.timeline_start_type("use_current")
                ensight.anim_keyframe.timeline_specify_incr("ON")
                ensight.anim_keyframe.timeline_step_increment(1.)
                ensight.anim_keyframe.timeline_arrive_type("swing")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_keyframe.timeline_end_type({repr(p0)})'''
        return self._session.cmd(cmd)

    def timeline_new(self) -> int:
        """Create a new timeline.
        
        | Is only possible if the previous (if exists) timeline does not completely span the available keyframes
        
        Examples:
            ::
        
                #
                # turn on keyframing and create 4 keyframes 
                #
                ensight.anim_keyframe.keyframing("ON")
                ensight.anim_keyframe.create_keyframe()
                ensight.anim_keyframe.create_keyframe()
                ensight.anim_keyframe.create_keyframe()
                ensight.anim_keyframe.create_keyframe()
                #
                # transient data (and timelines) will be used during the animation
                #
                ensight.anim_keyframe.use_transient_data("ON")
                #
                # 
                ensight.anim_keyframe.timeline_select(1)
                #
                # the first timeline goes from keyframe 2 to 3 (i.e, no transient
                # data is used for keyframe 1 to 2)
                #
                ensight.anim_keyframe.timeline_start_keyframe(2)
                ensight.anim_keyframe.timeline_end_keyframe(3)
                #
                # At keyframe 2 the "Begin" (as defined in the solution time dialog)
                # time is used.  At keyframe 3 the "End" time is used.
                #
                ensight.anim_keyframe.timeline_start_type("use_begin")
                ensight.anim_keyframe.timeline_end_type("use_end")
                #
                # Create a new timeline and select it for editing
                #
                ensight.anim_keyframe.timeline_new()
                ensight.anim_keyframe.timeline_select(2)
                #
                # This timeline goes from keyframe 3 to 4
                #
                ensight.anim_keyframe.timeline_start_keyframe(3)
                ensight.anim_keyframe.timeline_end_keyframe(4)
                #
                # At keyframe 3 the current time will be used (which will
                # be the "End" time since the first timeline ends with this time
                # We do not specify the time at keyframe 4 but rather increment time
                # by 1.4 unit for each frame.  If we arrive at the begin/end time we will
                # "swing"
                #
                ensight.anim_keyframe.timeline_start_type("use_current")
                ensight.anim_keyframe.timeline_specify_incr("ON")
                ensight.anim_keyframe.timeline_time_increment(1.4)
                ensight.anim_keyframe.timeline_arrive_type("swing")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_keyframe.timeline_new()'''
        return self._session.cmd(cmd)

    def timeline_select(self, p0: int) -> int:
        """Selects an existing timeline for editing.
        
        Args:
            p0:
                'timeline' existing timeline to edit
        
        Examples:
            ::
        
                #
                # turn on keyframing and create 4 keyframes 
                #
                ensight.anim_keyframe.keyframing("ON")
                ensight.anim_keyframe.create_keyframe()
                ensight.anim_keyframe.create_keyframe()
                ensight.anim_keyframe.create_keyframe()
                ensight.anim_keyframe.create_keyframe()
                #
                # transient data (and timelines) will be used during the animation
                #
                ensight.anim_keyframe.use_transient_data("ON")
                #
                # 
                ensight.anim_keyframe.timeline_select(1)
                #
                # the first timeline goes from keyframe 2 to 3 (i.e, no transient
                # data is used for keyframe 1 to 2)
                #
                ensight.anim_keyframe.timeline_start_keyframe(2)
                ensight.anim_keyframe.timeline_end_keyframe(3)
                #
                # At keyframe 2 the "Begin" (as defined in the solution time dialog)
                # time is used.  At keyframe 3 the "End" time is used.
                #
                ensight.anim_keyframe.timeline_start_type("use_begin")
                ensight.anim_keyframe.timeline_end_type("use_end")
                #
                # Create a new timeline and select it for editing
                #
                ensight.anim_keyframe.timeline_new()
                ensight.anim_keyframe.timeline_select(2)
                #
                # This timeline goes from keyframe 3 to 4
                #
                ensight.anim_keyframe.timeline_start_keyframe(3)
                ensight.anim_keyframe.timeline_end_keyframe(4)
                #
                # At keyframe 3 the current time will be used (which will
                # be the "End" time since the first timeline ends with this time
                # We do not specify the time at keyframe 4 but rather increment time
                # by 1. unit for each frame.  If we arrive at the begin/end time we will
                # "swing"
                #
                ensight.anim_keyframe.timeline_start_type("use_current")
                ensight.anim_keyframe.timeline_specify_incr("ON")
                ensight.anim_keyframe.timeline_step_increment(1.)
                ensight.anim_keyframe.timeline_arrive_type("swing")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_keyframe.timeline_select({repr(p0)})'''
        return self._session.cmd(cmd)

    def timeline_specify_incr(self, p0: str) -> int:
        """When ON specifies that a time increment is to be used for the selected timeline.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                #
                # turn on keyframing and create 4 keyframes 
                #
                ensight.anim_keyframe.keyframing("ON")
                ensight.anim_keyframe.create_keyframe()
                ensight.anim_keyframe.create_keyframe()
                ensight.anim_keyframe.create_keyframe()
                ensight.anim_keyframe.create_keyframe()
                #
                # transient data (and timelines) will be used during the animation
                #
                ensight.anim_keyframe.use_transient_data("ON")
                #
                # 
                ensight.anim_keyframe.timeline_select(1)
                #
                # the first timeline goes from keyframe 2 to 3 (i.e, no transient
                # data is used for keyframe 1 to 2)
                #
                ensight.anim_keyframe.timeline_start_keyframe(2)
                ensight.anim_keyframe.timeline_end_keyframe(3)
                #
                # At keyframe 2 the "Begin" (as defined in the solution time dialog)
                # time is used.  At keyframe 3 the "End" time is used.
                #
                ensight.anim_keyframe.timeline_start_type("use_begin")
                ensight.anim_keyframe.timeline_end_type("use_end")
                #
                # Create a new timeline and select it for editing
                #
                ensight.anim_keyframe.timeline_new()
                ensight.anim_keyframe.timeline_select(2)
                #
                # This timeline goes from keyframe 3 to 4
                #
                ensight.anim_keyframe.timeline_start_keyframe(3)
                ensight.anim_keyframe.timeline_end_keyframe(4)
                #
                # At keyframe 3 the current time will be used (which will
                # be the "End" time since the first timeline ends with this time
                # We do not specify the time at keyframe 4 but rather increment time
                # by 1. unit for each frame.  If we arrive at the begin/end time we will
                # "swing"
                #
                ensight.anim_keyframe.timeline_start_type("use_current")
                ensight.anim_keyframe.timeline_specify_incr("ON")
                ensight.anim_keyframe.timeline_step_increment(1.)
                ensight.anim_keyframe.timeline_arrive_type("swing")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_keyframe.timeline_specify_incr({repr(p0)})'''
        return self._session.cmd(cmd)

    def timeline_start_keyframe(self, p0: int) -> int:
        """Sets the begin/end keyframes for the timeline.
        
        Args:
            p0:
                'keyframe_num' beginning/ending keyframe for the timeline
        
        Examples:
            ::
        
                #
                # turn on keyframing and create 4 keyframes 
                #
                ensight.anim_keyframe.keyframing("ON")
                ensight.anim_keyframe.create_keyframe()
                ensight.anim_keyframe.create_keyframe()
                ensight.anim_keyframe.create_keyframe()
                ensight.anim_keyframe.create_keyframe()
                #
                # transient data (and timelines) will be used during the animation
                #
                ensight.anim_keyframe.use_transient_data("ON")
                #
                # 
                ensight.anim_keyframe.timeline_select(1)
                #
                # the first timeline goes from keyframe 2 to 3 (i.e, no transient
                # data is used for keyframe 1 to 2)
                #
                ensight.anim_keyframe.timeline_start_keyframe(2)
                ensight.anim_keyframe.timeline_end_keyframe(3)
                #
                # At keyframe 2 the "Begin" (as defined in the solution time dialog)
                # time is used.  At keyframe 3 the "End" time is used.
                #
                ensight.anim_keyframe.timeline_start_type("use_begin")
                ensight.anim_keyframe.timeline_end_type("use_end")
                #
                # Create a new timeline and select it for editing
                #
                ensight.anim_keyframe.timeline_new()
                ensight.anim_keyframe.timeline_select(2)
                #
                # This timeline goes from keyframe 3 to 4
                #
                ensight.anim_keyframe.timeline_start_keyframe(3)
                ensight.anim_keyframe.timeline_end_keyframe(4)
                #
                # At keyframe 3 the current time will be used (which will
                # be the "End" time since the first timeline ends with this time
                # We do not specify the time at keyframe 4 but rather increment time
                # by 1. unit for each frame.  If we arrive at the begin/end time we will
                # "swing"
                #
                ensight.anim_keyframe.timeline_start_type("use_current")
                ensight.anim_keyframe.timeline_specify_incr("ON")
                ensight.anim_keyframe.timeline_step_increment(1.)
                ensight.anim_keyframe.timeline_arrive_type("swing")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_keyframe.timeline_start_keyframe({repr(p0)})'''
        return self._session.cmd(cmd)

    def timeline_start_step(self, p0: float) -> int:
        """Sets the start/end timeline step value if being specified.
        
        | Only used if "anim_keyframe: timeline_start/end_type specify" is also set.
        
        Args:
            p0:
                'time_value' The time value (step) for the start/end of the timeline
        
        Examples:
            ::
        
                #
                # turn on keyframing and create 4 keyframes 
                #
                ensight.anim_keyframe.keyframing("ON")
                ensight.anim_keyframe.create_keyframe()
                ensight.anim_keyframe.create_keyframe()
                ensight.anim_keyframe.create_keyframe()
                ensight.anim_keyframe.create_keyframe()
                #
                # transient data (and timelines) will be used during the animation
                #
                ensight.anim_keyframe.use_transient_data("ON")
                #
                # 
                ensight.anim_keyframe.timeline_select(1)
                #
                # the first timeline goes from keyframe 2 to 3 (i.e, no transient
                # data is used for keyframe 1 to 2)
                #
                ensight.anim_keyframe.timeline_start_keyframe(2)
                ensight.anim_keyframe.timeline_end_keyframe(3)
                #
                # At keyframe 2 the "Begin" (as defined in the solution time dialog)
                # time is used.  At keyframe 3 the "End" time is used.
                #
                ensight.anim_keyframe.timeline_start_type("use_begin")
                ensight.anim_keyframe.timeline_end_type("use_end")
                #
                # Create a new timeline and select it for editing
                #
                ensight.anim_keyframe.timeline_new()
                ensight.anim_keyframe.timeline_select(2)
                #
                # This timeline goes from keyframe 3 to 4
                #
                ensight.anim_keyframe.timeline_start_keyframe(3)
                ensight.anim_keyframe.timeline_end_keyframe(4)
                #
                # At keyframe 3 the current time will be used (which will
                # be the "End" time since the first timeline ends with this time
                # At keyframe 4 we set time step to 4.
                #
                ensight.anim_keyframe.timeline_start_type("use_current")
                ensight.anim_keyframe.timeline_end_type("specify")
                ensight.anim_keyframe.timeline_end_time(4.)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_keyframe.timeline_start_step({repr(p0)})'''
        return self._session.cmd(cmd)

    def timeline_start_time(self, p0: float) -> int:
        """Sets the start/end timeline value if being specified.
        
        | Only used if "anim_keyframe: timeline_start/end_type specify" is also set.
        
        Args:
            p0:
                'time_value' The time value (simulation) for the start/end of the timeline
        
        Examples:
            ::
        
                #
                # turn on keyframing and create 4 keyframes 
                #
                ensight.anim_keyframe.keyframing("ON")
                ensight.anim_keyframe.create_keyframe()
                ensight.anim_keyframe.create_keyframe()
                ensight.anim_keyframe.create_keyframe()
                ensight.anim_keyframe.create_keyframe()
                #
                # transient data (and timelines) will be used during the animation
                #
                ensight.anim_keyframe.use_transient_data("ON")
                #
                # 
                ensight.anim_keyframe.timeline_select(1)
                #
                # the first timeline goes from keyframe 2 to 3 (i.e, no transient
                # data is used for keyframe 1 to 2)
                #
                ensight.anim_keyframe.timeline_start_keyframe(2)
                ensight.anim_keyframe.timeline_end_keyframe(3)
                #
                # At keyframe 2 the "Begin" (as defined in the solution time dialog)
                # time is used.  At keyframe 3 the "End" time is used.
                #
                ensight.anim_keyframe.timeline_start_type("use_begin")
                ensight.anim_keyframe.timeline_end_type("use_end")
                #
                # Create a new timeline and select it for editing
                #
                ensight.anim_keyframe.timeline_new()
                ensight.anim_keyframe.timeline_select(2)
                #
                # This timeline goes from keyframe 3 to 4
                #
                ensight.anim_keyframe.timeline_start_keyframe(3)
                ensight.anim_keyframe.timeline_end_keyframe(4)
                #
                # At keyframe 3 the current time will be used (which will
                # be the "End" time since the first timeline ends with this time
                # At keyframe 4 we set time to be 40.
                #
                ensight.anim_keyframe.timeline_start_type("use_current")
                ensight.anim_keyframe.timeline_end_type("specify")
                ensight.anim_keyframe.timeline_end_time(40.)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_keyframe.timeline_start_time({repr(p0)})'''
        return self._session.cmd(cmd)

    def timeline_start_type(self, p0: str) -> int:
        """Sets the begin/end time for the timeline.
        
        Args:
            p0:
                'time_option'
        
                * use_begin
                * use_end
                * use_current
                * specify
        
        Examples:
            ::
        
                #
                # turn on keyframing and create 4 keyframes 
                #
                ensight.anim_keyframe.keyframing("ON")
                ensight.anim_keyframe.create_keyframe()
                ensight.anim_keyframe.create_keyframe()
                ensight.anim_keyframe.create_keyframe()
                ensight.anim_keyframe.create_keyframe()
                #
                # transient data (and timelines) will be used during the animation
                #
                ensight.anim_keyframe.use_transient_data("ON")
                #
                # 
                ensight.anim_keyframe.timeline_select(1)
                #
                # the first timeline goes from keyframe 2 to 3 (i.e, no transient
                # data is used for keyframe 1 to 2)
                #
                ensight.anim_keyframe.timeline_start_keyframe(2)
                ensight.anim_keyframe.timeline_end_keyframe(3)
                #
                # At keyframe 2 the "Begin" (as defined in the solution time dialog)
                # time is used.  At keyframe 3 the "End" time is used.
                #
                ensight.anim_keyframe.timeline_start_type("use_begin")
                ensight.anim_keyframe.timeline_end_type("use_end")
                #
                # Create a new timeline and select it for editing
                #
                ensight.anim_keyframe.timeline_new()
                ensight.anim_keyframe.timeline_select(2)
                #
                # This timeline goes from keyframe 3 to 4
                #
                ensight.anim_keyframe.timeline_start_keyframe(3)
                ensight.anim_keyframe.timeline_end_keyframe(4)
                #
                # At keyframe 3 the current time will be used (which will
                # be the "End" time since the first timeline ends with this time
                # We do not specify the time at keyframe 4 but rather increment time
                # by 1. unit for each frame.  If we arrive at the begin/end time we will
                # "swing"
                #
                ensight.anim_keyframe.timeline_start_type("use_current")
                ensight.anim_keyframe.timeline_specify_incr("ON")
                ensight.anim_keyframe.timeline_step_increment(1.)
                ensight.anim_keyframe.timeline_arrive_type("swing")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_keyframe.timeline_start_type({repr(p0)})'''
        return self._session.cmd(cmd)

    def timeline_step_increment(self, p0: float) -> int:
        """Specifies the time step increment when timeline_specify_incr is ON.
        
        | Only used if "anim_keyframe: timeline_specify_incr" is ON
        | See "anim_keyframe: timeline_time_increment" to specify the time increment in time units instead of step units.
        
        Args:
            p0:
                'delta_step' The time step increment between frames during the timeline
        
        Examples:
            ::
        
                #
                # turn on keyframing and create 4 keyframes 
                #
                ensight.anim_keyframe.keyframing("ON")
                ensight.anim_keyframe.create_keyframe()
                ensight.anim_keyframe.create_keyframe()
                ensight.anim_keyframe.create_keyframe()
                ensight.anim_keyframe.create_keyframe()
                #
                # transient data (and timelines) will be used during the animation
                #
                ensight.anim_keyframe.use_transient_data("ON")
                #
                # 
                ensight.anim_keyframe.timeline_select(1)
                #
                # the first timeline goes from keyframe 2 to 3 (i.e, no transient
                # data is used for keyframe 1 to 2)
                #
                ensight.anim_keyframe.timeline_start_keyframe(2)
                ensight.anim_keyframe.timeline_end_keyframe(3)
                #
                # At keyframe 2 the "Begin" (as defined in the solution time dialog)
                # time is used.  At keyframe 3 the "End" time is used.
                #
                ensight.anim_keyframe.timeline_start_type("use_begin")
                ensight.anim_keyframe.timeline_end_type("use_end")
                #
                # Create a new timeline and select it for editing
                #
                ensight.anim_keyframe.timeline_new()
                ensight.anim_keyframe.timeline_select(2)
                #
                # This timeline goes from keyframe 3 to 4
                #
                ensight.anim_keyframe.timeline_start_keyframe(3)
                ensight.anim_keyframe.timeline_end_keyframe(4)
                #
                # At keyframe 3 the current time will be used (which will
                # be the "End" time since the first timeline ends with this time
                # We do not specify the time at keyframe 4 but rather increment time
                # by 1. unit for each frame.  If we arrive at the begin/end time we will
                # "swing"
                #
                ensight.anim_keyframe.timeline_start_type("use_current")
                ensight.anim_keyframe.timeline_specify_incr("ON")
                ensight.anim_keyframe.timeline_step_increment(1.)
                ensight.anim_keyframe.timeline_arrive_type("swing")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_keyframe.timeline_step_increment({repr(p0)})'''
        return self._session.cmd(cmd)

    def timeline_time_increment(self, p0: float) -> int:
        """Specifies the time increment when timeline_specify_incr is ON.
        
        | Only used if "anim_keyframe: timeline_specify_incr" is ON
        | See "anim_keyframe: timeline_time_increment" to specify the time increment in step units instead of time units.
        
        Args:
            p0:
                'delta_time' The time increment between frames during the timeline
        
        Examples:
            ::
        
                #
                # turn on keyframing and create 4 keyframes 
                #
                ensight.anim_keyframe.keyframing("ON")
                ensight.anim_keyframe.create_keyframe()
                ensight.anim_keyframe.create_keyframe()
                ensight.anim_keyframe.create_keyframe()
                ensight.anim_keyframe.create_keyframe()
                #
                # transient data (and timelines) will be used during the animation
                #
                ensight.anim_keyframe.use_transient_data("ON")
                #
                # 
                ensight.anim_keyframe.timeline_select(1)
                #
                # the first timeline goes from keyframe 2 to 3 (i.e, no transient
                # data is used for keyframe 1 to 2)
                #
                ensight.anim_keyframe.timeline_start_keyframe(2)
                ensight.anim_keyframe.timeline_end_keyframe(3)
                #
                # At keyframe 2 the "Begin" (as defined in the solution time dialog)
                # time is used.  At keyframe 3 the "End" time is used.
                #
                ensight.anim_keyframe.timeline_start_type("use_begin")
                ensight.anim_keyframe.timeline_end_type("use_end")
                #
                # Create a new timeline and select it for editing
                #
                ensight.anim_keyframe.timeline_new()
                ensight.anim_keyframe.timeline_select(2)
                #
                # This timeline goes from keyframe 3 to 4
                #
                ensight.anim_keyframe.timeline_start_keyframe(3)
                ensight.anim_keyframe.timeline_end_keyframe(4)
                #
                # At keyframe 3 the current time will be used (which will
                # be the "End" time since the first timeline ends with this time
                # We do not specify the time at keyframe 4 but rather increment time
                # by 1.4 unit for each frame.  If we arrive at the begin/end time we will
                # "swing"
                #
                ensight.anim_keyframe.timeline_start_type("use_current")
                ensight.anim_keyframe.timeline_specify_incr("ON")
                ensight.anim_keyframe.timeline_time_increment(1.4)
                ensight.anim_keyframe.timeline_arrive_type("swing")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_keyframe.timeline_time_increment({repr(p0)})'''
        return self._session.cmd(cmd)

    def use_interactive_parts(self, p0: str) -> int:
        """Toggles use of animated isosurfaces or clip planes.
        
        | This command can be turned on at any time during keyframe recording.  If it is on, any isosurfaces or clips that were interactively changed during recording will be animated.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.anim_keyframe.keyframing("ON")
                ensight.anim_keyframe.create_keyframe()
                # WARNING: following line includes OBSOLETE call (ensight.part.select_partname_begin).
                ensight.part.select_partname_begin("(CASE:Case 1)Isosurface part")
                ensight.part.modify_begin()
                ensight.isos.value(9.9000e-01)
                ensight.part.modify_end()
                ensight.anim_keyframe.create_keyframe()
                ensight.anim_keyframe.use_interactive_parts("ON")
                ensight.anim_keyframe.run()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_keyframe.use_interactive_parts({repr(p0)})'''
        return self._session.cmd(cmd)

    def use_spline(self, p0: str) -> int:
        """Enable spline interpolation for keyframe animation translations and look at/from changes.
        
        | You must have more than 2 keyframes for spline interpolation.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.anim_keyframe.keyframing("ON")
                ensight.anim_keyframe.create_keyframe()
                ensight.view_transf.translate(5,0,0)
                ensight.anim_keyframe.create_keyframe()
                ensight.view_transf.translate(0,5,0)
                ensight.anim_keyframe.create_keyframe()
                ensight.anim_keyframe.use_spline("ON")
                ensight.anim_keyframe.acceleration("3","ON")
                ensight.anim_keyframe.run()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_keyframe.use_spline({repr(p0)})'''
        return self._session.cmd(cmd)

    def use_transient_data(self, p0: str) -> int:
        """Toggles whether transient data will be used during the keyframe animation.
        
        | When using transient data, each frame (keyframes and in-betweens) will use the next transient time value.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.anim_keyframe.use_transient_data("ON")
                ensight.anim_keyframe.specify_time_as("step")
                ensight.anim_keyframe.step_by(2.0000e+00)
                ensight.anim_keyframe.begin_time_step(2)
                ensight.anim_keyframe.end_time_step(15)
                ensight.anim_keyframe.run()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_keyframe.use_transient_data({repr(p0)})'''
        return self._session.cmd(cmd)


class anim_flipbook:
    """Class wrapper for EnSight anim_flipbook module

    This class acts as a proxy for the EnSight Python module ensight.anim_flipbook
    """
    def __init__(self, session: Session):
        self._session = session

    def NoCommand(self, args: Any) -> int:
        """Anim_flipbook: NoCommand

        """
        cmd = f'''ensight.anim_flipbook.NoCommand({repr(args)})'''
        return self._session.cmd(cmd)

    def begin_simtime(self, p0: float) -> int:
        """Specify a beginning simulation time value to start the flipbook animation.
        
        | Not applicable if dataset is not transient.
        | Used only if  "anim_flipbook: specify_time_as simulation" has been specified.
        
        Args:
            p0:
                'time_value' beginning simulation time value (which must correspond to the same simulation time at a time step)
        
        Examples:
            ::
        
                #
                # Specify a transient_data flipbook 
                #
                ensight.anim_flipbook.load_type("transient_data")
                #
                # Set begin/end solution timestep values
                #
                ensight.solution_time.show_as("time")
                #
                # Set begin/end flipbook time info
                #
                ensight.anim_flipbook.step_simtime(1.0000e+00)
                ensight.anim_flipbook.specify_time_as("simulation")
                ensight.anim_flipbook.begin_simtime(3.4900e+02)
                ensight.anim_flipbook.end_simtime(3.6900e+02)
                #
                # Load flipbook
                #
                ensight.anim_flipbook.load()
                #
                # Run loaded flipbook
                #
                ensight.anim_flipbook.run_type("auto")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_flipbook.begin_simtime({repr(p0)})'''
        return self._session.cmd(cmd)

    def begin_time_step(self, p0: int) -> int:
        """Specify a beginning time step value to start the flipbook animation.
        
        | Not applicable if dataset is not transient.
        | Used only if "anim_flipbook: specify_time_as step" has been specified.
        
        Args:
            p0:
                'step_value' beginning time step value in the range of 0 to n - 1, where
        
        Examples:
            ::
        
                #
                # Specify a transient_data flipbook 
                #
                ensight.anim_flipbook.load_type("transient_data")
                #
                # Set begin/end solution timestep values
                #
                ensight.solution_time.begin_step(30)
                ensight.solution_time.end_step(50)
                ensight.solution_time.show_as("step")
                #
                # Set begin/end flipbook time info
                #
                # Note: both step and simtime commands are reset
                #       because solution time commands were set above
                #
                ensight.anim_flipbook.specify_time_as("step")
                ensight.anim_flipbook.step_by(1.0000e+00)
                ensight.anim_flipbook.begin_time_step(30)
                ensight.anim_flipbook.end_time_step(50)
                #
                # Load flipbook
                #
                ensight.anim_flipbook.load()
                #
                # Run loaded flipbook
                #
                ensight.anim_flipbook.run_type("auto")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_flipbook.begin_time_step({repr(p0)})'''
        return self._session.cmd(cmd)

    def cycle(self, p0: str) -> int:
        """Specify the automatic playback sequence of the flipbook.
        
        | Not applicable if flipbook has not been loaded.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.anim_flipbook.cycle("ON")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_flipbook.cycle({repr(p0)})'''
        return self._session.cmd(cmd)

    def delete_all_pages(self) -> int:
        """Specify to delete the currently loaded flipbook.
        
        | Not applicable if flipbook has not been loaded.
        
        Examples:
            ::
        
                ensight.anim_flipbook.delete_all_pages()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_flipbook.delete_all_pages()'''
        return self._session.cmd(cmd)

    def delete_gpucache(self) -> int:
        """Anim_flipbook: delete_gpucache

        """
        cmd = f'''ensight.anim_flipbook.delete_gpucache()'''
        return self._session.cmd(cmd)

    def display_speed(self, p0: float) -> int:
        """Specifies the playback-speed factor, or the display speed at which the flipbook animates.
        
        | Not applicable if flipbook has not been loaded.
        
        Args:
            p0:
                'speed_value' set the display speed value in the range [0.,1.] where 1. is the fastest speed (of your hardware) and 0. is stopped (a still page)
        
        Examples:
            ::
        
                #
                # Halve the display speed
                #
                ensight.anim_flipbook.display_speed(0.500000)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_flipbook.display_speed({repr(p0)})'''
        return self._session.cmd(cmd)

    def dynamic_line(self, p0: float, p1: float, p2: float, p3: float, p4: float, p5: float, p6: float, p7: float) -> int:
        """Specify dynamic flipbook animation of the selected 1d-clip line part. 
        
        | Only used for flipbook animations of interactive clip line parts.
        | Must be bracketed by "anim_flipbook: interactive_part start" and "anim_flipbook: interactive_part end".
        
        Args:
            p0:
                'part' a valid GUI part number, for a line clip
            p1:
                'end' 1 - beginning line position
            p2:
                'end' 2 - ending line position
            p3:
                'X0' X coordinate of first end point of specified line position
            p4:
                'YO' Y coordinate of first end point of specified line position
            p5:
                'ZO' Z coordinate of first end point of specified line position
            p6:
                'Xn' Y coordinate of second end point of specified line position
            p7:
                'Yn' X coordinate of second end point of specified line position
            p8:
                'Zn' Z coordinate of second end point of specified line position
        
        Examples:
            ::
        
                #
                # Create the line clip part from the parent field
                #
                ensight.part.select_all()
                ensight.clip.begin()
                ensight.clip.domain("intersect")
                ensight.clip.tool("line")
                ensight.clip.line(1,5.8348e-01,1.3165e+00,1.2670e+00)
                ensight.clip.line(2,3.0835e+00,1.3165e+00,1.2670e+00)
                ensight.clip.end()
                ensight.clip.create()
                ensight.part.select_begin(2)
                #
                # Load and animate the clip-line part 
                # between the 1st and 2nd dynamic_line positions.
                #
                ensight.anim_flipbook.interactive_part("start")
                ensight.tools.line("ON")
                ensight.part.select_begin(2)
                ensight.view_transf.function("line")
                ensight.view_transf.translate(1.33481,0.816460,0.266963)
                ensight.view_transf.function("global")
                ensight.anim_flipbook.dynamic_line(2,1,-0.750000,0.500000,1.000000,0.583581,1.316460,1.266963)
                ensight.anim_flipbook.dynamic_line(2,2,1.750000,0.500000,1.000000,3.083481,1.316460,1.266963)
                ensight.anim_flipbook.interactive_part("stop")
                ensight.anim_flipbook.number_to_create(10)
                ensight.anim_flipbook.load()
                ensight.anim_flipbook.run_type("auto")
                ensight.tools.line("OFF")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_flipbook.dynamic_line({repr(p0)},{repr(p1)},{repr(p2)},{repr(p3)},{repr(p4)},{repr(p5)},{repr(p6)},{repr(p7)})'''
        return self._session.cmd(cmd)

    def dynamic_plane(self, p0: float, p1: float, p2: float, p3: float, p4: float, p5: float, p6: float, p7: float) -> int:
        """Specify dynamic flipbook animation of the selected 2d-clip plane part. 
        
        | Used for flipbook animations of interactive isosurface, ijk-clip, and xyz-clip parts. Only applicable between commands: 
        | 	      anim_flipbook: interactive_part start
        |       anim_flipbook: interactive_part stop
        
        Args:
            p0:
                'part' GUI part number of the 2D-clip plane part to be animated
            p1:
                'cid' corner id (1, 2, 3, or 4) of the plane tool
            p2:
                'XO' initial x coordinate of the specified corner of the plane
            p3:
                'YO' initial y coordinate of the specified corner of the plane
            p4:
                'ZO' initial z coordinate of the specified corner of the plane
            p5:
                'Xn' final x coordinate of the specified corner of the plane
            p6:
                'Yn' final y coordinate of the specified corner of the plane
            p7:
                'Zn' final z coordinate of the specified corner of the plane
        
        Examples:
            ::
        
                #
                # From the flow field part (number 1),
                # create the 2D-clip plane part (number 2)
                # and color it by temperature.
                #
                ensight.part.select_begin(1)
                ensight.clip.begin()
                ensight.clip.domain("intersect")
                ensight.clip.tool("plane")
                ensight.clip.plane(1,-7.5000e-01,-7.5000e-01,1.0000e+00)
                ensight.clip.plane(2,1.7500e+00,-7.5000e-01,1.0000e+00)
                ensight.clip.plane(3,1.7500e+00,1.7500e+00,1.0000e+00)
                ensight.clip.end()
                ensight.clip.create()
                ensight.part.select_begin(2)
                ensight.part.modify_begin()
                ensight.part.colorby_palette("temperature")
                ensight.part.modify_end()
                #
                # Specify interactive flipbook animation
                # of the 2D-clip part.
                #
                ensight.anim_flipbook.interactive_part("start")
                ensight.tools.plane("line")
                ensight.view_transf.function("plane")
                ensight.view_transf.action("translate")
                ensight.view_transf.translate(0.0000e+00,0.0000e+00,1.0000e+00)
                ensight.part.select_begin(2)
                ensight.part.modify_begin()
                ensight.clip.plane(1,-7.5000e-01,-7.5000e-01,2.0000e+00)
                ensight.clip.plane(2,1.7500e+00,-7.5000e-01,2.0000e+00)
                ensight.clip.plane(3,1.7500e+00,1.7500e+00,2.0000e+00)
                ensight.part.modify_end()
                ensight.tools.plane("line")
                ensight.tools.plane("line")
                ensight.view_transf.function("global")
                ensight.view_transf.function("global")
                #
                # Track the dynamic position of the four corners 
                # of the clip plane tool.
                #
                ensight.anim_flipbook.dynamic_plane(2,1,-0.750000,-0.750000,1.000000,-0.750000,-0.750000,2.000000)
                ensight.anim_flipbook.dynamic_plane(2,2,1.750000,-0.750000,1.000000,1.750000,-0.750000,2.000000)
                ensight.anim_flipbook.dynamic_plane(2,3,1.750000,1.750000,1.000000,1.750000,1.750000,2.000000)
                ensight.anim_flipbook.dynamic_plane(2,4,-0.750000,1.750000,1.000000,-0.750000,1.750000,2.000000)
                ensight.anim_flipbook.move_dynamic_plane(2,5,0.000000,0.000000,1.000000)
                ensight.anim_flipbook.interactive_part("stop")
                #
                ensight.anim_flipbook.number_to_create(10)
                ensight.anim_flipbook.load()
                ensight.tools.plane("OFF")
                ensight.anim_flipbook.run_type("auto")
                ensight.anim_flipbook.run_type("off")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_flipbook.dynamic_plane({repr(p0)},{repr(p1)},{repr(p2)},{repr(p3)},{repr(p4)},{repr(p5)},{repr(p6)},{repr(p7)})'''
        return self._session.cmd(cmd)

    def dynamic_value(self, p0: float, p1: float, p2: float) -> int:
        """Specify dynamic flipbook animation of the selected isosurface, xyz-clip, or ijk-clip part, within the appropriate specified dynamic ranges.
        
        | Used for flipbook animations of interactive isosurface, ijk-clip, and xyz-clip parts. Only applicable between commands: 
        | 	      anim_flipbook: interactive_part start
        |       anim_flipbook: interactive_part stop
        
        Args:
            p0:
                'part' GUI part number of the part to be animated
            p1:
                'start_value' the starting dynamic value of the animation
            p2:
                'end_value' final dynamic value of the animation,  i.e. the ending isosurface value; x, y, or z clip value; or  i, j, or k value of the respective isosurface, xyz clip, or ijk clip part
        
        Examples:
            ::
        
                #
                # (Note: A clip part has already been generated via the
                #        XYZ clip part feature and colored by a variable.)
                #
                # Update the 2D clip part clip at 
                #
                ensight.part.select_begin(2)
                ensight.part.modify_begin()
                ensight.clip.mesh_plane("X")
                ensight.clip.tool("xyz")
                ensight.clip.value(1.000000)
                ensight.part.modify_end()
                #
                # Specify type of flipbook
                #
                ensight.anim_flipbook.load_type("create_data")
                #
                # Setup interactive flipbooking of the clip part number 2
                # from values 1. to 3.
                #
                ensight.anim_flipbook.interactive_part("start")
                ensight.part.select_begin(2)
                ensight.part.modify_begin()
                ensight.clip.value(3.000000)
                ensight.part.modify_end()
                ensight.anim_flipbook.dynamic_value(2,1.000000,3.000000)
                ensight.anim_flipbook.interactive_part("stop")
                #
                # Load 10 flipbook pages
                #
                ensight.anim_flipbook.number_to_create(10)
                ensight.anim_flipbook.load()
                #
                # Run loaded flipbook pages
                #
                ensight.anim_flipbook.run_type("auto")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_flipbook.dynamic_value({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def end_simtime(self, p0: float) -> int:
        """Specify an ending simulation time value to start the flipbook animation.
        
        | Not applicable if dataset is not transient. An ending simulation time must correspond to the simulation time of a time step. 
        | Used only if "anim_flipbook: specify_time_as step" has been specified.
        
        Args:
            p0:
                'time_value' ending simulation time value (which must correspond to the  simulation time at a time step)
        
        Examples:
            ::
        
                #
                # Specify a transient_data flipbook 
                #
                ensight.anim_flipbook.load_type("transient_data")
                #
                # Set begin/end solution timestep values
                #
                ensight.solution_time.begin_step(30)
                ensight.solution_time.end_step(50)
                ensight.solution_time.show_as("time")
                #
                # Set begin/end flipbook time info
                #
                ensight.anim_flipbook.step_simtime(1.0000e+00)
                ensight.anim_flipbook.specify_time_as("simulation")
                ensight.anim_flipbook.begin_simtime(3.4900e+02)
                ensight.anim_flipbook.end_simtime(3.6900e+02)
                #
                # Load flipbook
                #
                ensight.anim_flipbook.load()
                #
                # Run loaded flipbook
                #
                ensight.anim_flipbook.run_type("auto")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_flipbook.end_simtime({repr(p0)})'''
        return self._session.cmd(cmd)

    def end_time_step(self, p0: int) -> int:
        """Specify an ending time step value to start the flipbook animation.
        
        | Not applicable if dataset is not transient. 
        | Used only if "anim_flipbook: specify_time_as step" has been specified.
        
        Args:
            p0:
                'step_value' ending time step value in the range of 0 to n - 1, where
        
        Examples:
            ::
        
                #
                # Specify a transient_data flipbook 
                #
                ensight.anim_flipbook.load_type("transient_data")
                #
                # Set begin/end solution timestep values
                #
                ensight.solution_time.begin_step(30)
                ensight.solution_time.end_step(50)
                ensight.solution_time.show_as("step")
                #
                # Set begin/end flipbook time info
                #
                # Note: both step and simtime commands are reset
                #       because solution time commands were set above
                #
                ensight.anim_flipbook.step_by(1.0000e+00)
                ensight.anim_flipbook.specify_time_as("step")
                ensight.anim_flipbook.begin_time_step(30)
                ensight.anim_flipbook.end_time_step(50)
                #
                # Load flipbook
                #
                ensight.anim_flipbook.load()
                #
                # Run loaded flipbook
                #
                ensight.anim_flipbook.run_type("auto")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_flipbook.end_time_step({repr(p0)})'''
        return self._session.cmd(cmd)

    def interactive_part(self, p0: str) -> int:
        """Specify the start and stop of the recording of interactive movement of any specified isosurface or clip parts during a flipbook load. 
        
        | Currently this operation only works for interactive manipulation of isosurface and 2D clip parts.  Used in conjunction with the following commands:
        |     part: select_begin
        |     part: select_end
        |     part: modify_begin
        |     part: modify_end
        |     anim_flipbook: dynamic_value
        |     anim_flipbook: dynamic_line
        |     anim_flipbook: dynamic_plane
        |     anim_flipbook: dynamic_plane
        |     anim_flipbook: move_dynamic_plane 
        
        Args:
            p0:
                'option' start
            p1:
                'option' stop
        
        Examples:
            ::
        
                #
                # (Note: A clip part has already been generated via the
                #        XYZ clip part feature and colored by a variable.)
                #
                # Update the 2D clip part clip at 
                #
                ensight.part.select_begin(2)
                ensight.part.modify_begin()
                ensight.clip.mesh_plane("X")
                ensight.clip.tool("xyz")
                ensight.clip.value(1.000000)
                ensight.part.modify_end()
                #
                # Specify type of flipbook
                #
                ensight.anim_flipbook.load_type("create_data")
                #
                # Setup interactive flipbooking of the clip part
                #
                ensight.anim_flipbook.interactive_part("start")
                ensight.part.select_begin(2)
                ensight.part.modify_begin()
                ensight.clip.value(3.000000)
                ensight.part.modify_end()
                ensight.anim_flipbook.dynamic_value(2,1.000000,3.000000)
                ensight.anim_flipbook.interactive_part("stop")
                #
                # Load 10 flipbook pages
                #
                ensight.anim_flipbook.number_to_create(10)
                ensight.anim_flipbook.load()
                #
                # Run loaded flipbook pages
                #
                ensight.anim_flipbook.run_type("auto")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_flipbook.interactive_part({repr(p0)})'''
        return self._session.cmd(cmd)

    def load(self) -> int:
        """Specify the loading of the flipbook pages, according to the selected part(s) and specified flipbook options.
        
        Examples:
            ::
        
                #
                # Note: transient dataset w/83 time steps...
                #
                # Specify a transient_data flipbook 
                #
                ensight.anim_flipbook.load_type("transient_data")
                #
                # Specify page increment
                #
                ensight.anim_flipbook.step_by(1.0000e+01)
                #
                # Set begin/end flipbook time info
                #
                ensight.anim_flipbook.begin_time_step(0)
                ensight.anim_flipbook.end_time_step(83)
                ensight.anim_flipbook.specify_time_as("step")
                #
                # Load flipbook pages {0,10,20,30,40,50,60,70,80}
                #
                ensight.anim_flipbook.load()
                #
                # Run loaded flipbook
                #
                ensight.anim_flipbook.run_type("auto")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_flipbook.load()'''
        return self._session.cmd(cmd)

    def load_as(self, p0: str) -> int:
        """Specify whether to load the flipbook as graphic objects or images.
        
        | Since graphic_images record the image on the screen, make sure there is no overlaying dialog or image overlapping the main graphics window.
        
        Args:
            p0:
                'option' graphic_objects
            p1:
                'option' graphic_images
        
        Examples:
            ::
        
                ensight.anim_flipbook.load_as("graphic_images")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_flipbook.load_as({repr(p0)})'''
        return self._session.cmd(cmd)

    def load_type(self, p0: str) -> int:
        """Specifies the type of flipbook animation to load.
        
        Args:
            p0:
                'option' transient_data
            p1:
                'option' mode_shapes
            p2:
                'option' create_data
            p3:
                'option' linear_load 
        
        Examples:
            ::
        
                #
                # Example of <transient_data>
                #
                # Note: transient dataset w/83 time steps...
                #
                # Specify a transient_data flipbook 
                #
                ensight.anim_flipbook.load_type("transient_data")
                #
                # Specify page increment
                #
                ensight.anim_flipbook.step_by(1.0000e+01)
                #
                # Set begin/end flipbook time info
                #
                ensight.anim_flipbook.begin_time_step(0)
                ensight.anim_flipbook.end_time_step(83)
                ensight.anim_flipbook.specify_time_as("step")
                #
                # Load flipbook pages {0,10,20,30,40,50,60,70,80}
                #
                ensight.anim_flipbook.load()
                #
                # Run loaded flipbook
                #
                ensight.anim_flipbook.run_type("auto")
        
            ::
        
                #
                # Example of <create_data>
                #
                # (Note: A clip part has already been generated via the
                #        XYZ clip part feature and colored by a variable.)
                #
                # Update the 2D clip part clip at 
                #
                ensight.part.select_begin(2)
                ensight.part.modify_begin()
                ensight.clip.mesh_plane("X")
                ensight.clip.tool("xyz")
                ensight.clip.value(1.000000)
                ensight.part.modify_end()
                #
                # Specify type of flipbook
                #
                ensight.anim_flipbook.load_type("create_data")
                #
                # Setup interactive flipbooking of the clip part
                #
                ensight.anim_flipbook.interactive_part("start")
                ensight.part.select_begin(2)
                ensight.part.modify_begin()
                ensight.clip.value(3.000000)
                ensight.part.modify_end()
                ensight.anim_flipbook.dynamic_value(2,1.000000,3.000000)
                ensight.anim_flipbook.interactive_part("stop")
                #
                # Load 10 flipbook pages
                #
                ensight.anim_flipbook.number_to_create(10)
                ensight.anim_flipbook.load()
                #
                # Run loaded flipbook pages
                #
                ensight.anim_flipbook.run_type("auto")
        
            ::
        
                #
                # Example of <mode_shapes>
                #
                # Note:  Prior to animating modes shapes ... activate and 
                #        displace displacement vector variable on selected parts.
                # 
                ensight.variables.activate("3D_Displacement")
                ensight.part.select_all()
                ensight.part.modify_begin()
                ensight.part.displace_by("3D_Displacement")
                ensight.part.modify_end()
                #
                #
                #
                ensight.anim_flipbook.load_type("mode_shapes")
                ensight.anim_flipbook.number_to_create(10)
                ensight.anim_flipbook.load()
                ensight.anim_flipbook.run_type("auto")
        
            ::
        
                #
                # Followed by example of <linear_load>
                #
                # Delete current flipbook
                #
                ensight.anim_flipbook.delete_all_pages()
                #
                # Load and run 10 linear_load flipbook pages
                #
                ensight.anim_flipbook.load_type("linear_load")
                ensight.anim_flipbook.number_to_create(10)
                ensight.anim_flipbook.load()
                ensight.anim_flipbook.run_type("auto")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_flipbook.load_type({repr(p0)})'''
        return self._session.cmd(cmd)

    def move_dynamic_plane(self, p0: float, p1: float, p2: float, p3: float, p4: float) -> int:
        """Specify the vector in which the 2d-clip plane part is to be transformed.
        
        | Only currently applicable for "anim_flipbook: dynamic_plane" commands, i.e. for flipbook animations of interactive clip parts via the plane tool.
        
        Args:
            p0:
                'part' GUI part number of the part to be animated
            p1:
                'transform' 1 - rotation transformation
            p2:
                'dx' x-component of the direction vector for the transformation to follow
            p3:
                'dy' y-component of the direction vector for the transformation to follow
            p4:
                'dz' z-component of the direction vector for the transformation to follow
        
        Examples:
            ::
        
                #
                # From the flow field part (number 1),
                # create the 2D-clip plane part (number 2)
                # and color it by temperature.
                #
                ensight.part.select_begin(1)
                ensight.clip.begin()
                ensight.clip.domain("intersect")
                ensight.clip.tool("plane")
                ensight.clip.plane(1,-7.5000e-01,-7.5000e-01,1.0000e+00)
                ensight.clip.plane(2,1.7500e+00,-7.5000e-01,1.0000e+00)
                ensight.clip.plane(3,1.7500e+00,1.7500e+00,1.0000e+00)
                ensight.clip.end()
                ensight.clip.create()
                ensight.part.select_begin(2)
                ensight.part.modify_begin()
                ensight.part.colorby_palette("temperature")
                ensight.part.modify_end()
                #
                # Specify interactive flipbook animation
                # of the 2D-clip part.
                #
                ensight.anim_flipbook.interactive_part("start")
                ensight.tools.plane("line")
                ensight.view_transf.function("plane")
                ensight.view_transf.action("translate")
                ensight.view_transf.translate(0.0000e+00,0.0000e+00,1.0000e+00)
                ensight.part.select_begin(2)
                ensight.part.modify_begin()
                ensight.clip.plane(1,-7.5000e-01,-7.5000e-01,2.0000e+00)
                ensight.clip.plane(2,1.7500e+00,-7.5000e-01,2.0000e+00)
                ensight.clip.plane(3,1.7500e+00,1.7500e+00,2.0000e+00)
                ensight.part.modify_end()
                ensight.tools.plane("line")
                ensight.tools.plane("line")
                ensight.view_transf.function("global")
                ensight.view_transf.function("global")
                #
                # Track the dynamic position of the four corners 
                # of the clip plane tool.
                #
                ensight.anim_flipbook.dynamic_plane(2,1,-0.750000,-0.750000,1.000000,-0.750000,-0.750000,2.000000)
                ensight.anim_flipbook.dynamic_plane(2,2,1.750000,-0.750000,1.000000,1.750000,-0.750000,2.000000)
                ensight.anim_flipbook.dynamic_plane(2,3,1.750000,1.750000,1.000000,1.750000,1.750000,2.000000)
                ensight.anim_flipbook.dynamic_plane(2,4,-0.750000,1.750000,1.000000,-0.750000,1.750000,2.000000)
                #
                # Indicate the 2d-clip plane's translation
                #
                ensight.anim_flipbook.move_dynamic_plane(2,5,0.000000,0.000000,1.000000)
                ensight.anim_flipbook.interactive_part("stop")
                #
                ensight.anim_flipbook.number_to_create(10)
                ensight.anim_flipbook.load()
                ensight.tools.plane("OFF")
                ensight.anim_flipbook.run_type("auto")
                ensight.anim_flipbook.run_type("off")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_flipbook.move_dynamic_plane({repr(p0)},{repr(p1)},{repr(p2)},{repr(p3)},{repr(p4)})'''
        return self._session.cmd(cmd)

    def number_to_create(self, p0: int) -> int:
        """Specify the number of pages to create in the flipbook animation.
        
        Args:
            p0:
                'number' (positive) number of pages to create
        
        Examples:
            ::
        
                #
                # (Note: A clip part has already been generated via the
                #        XYZ clip part feature and colored by a variable.)
                #
                # Update the 2D clip part clip at 
                #
                ensight.part.select_begin(2)
                ensight.part.modify_begin()
                ensight.clip.mesh_plane("X")
                ensight.clip.tool("xyz")
                ensight.clip.value(1.000000)
                ensight.part.modify_end()
                #
                # Specify type of flipbook
                #
                ensight.anim_flipbook.load_type("create_data")
                #
                # Setup interactive flipbooking of the clip part
                #
                ensight.anim_flipbook.interactive_part("start")
                ensight.part.select_begin(2)
                ensight.part.modify_begin()
                ensight.clip.value(3.000000)
                ensight.part.modify_end()
                ensight.anim_flipbook.dynamic_value(2,1.000000,3.000000)
                ensight.anim_flipbook.interactive_part("stop")
                #
                # Load 10 flipbook pages
                #
                ensight.anim_flipbook.number_to_create(10)
                ensight.anim_flipbook.load()
                #
                # Run loaded flipbook pages
                #
                ensight.anim_flipbook.run_type("auto")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_flipbook.number_to_create({repr(p0)})'''
        return self._session.cmd(cmd)

    def page(self, p0: float) -> int:
        """Specify which page of the flipbook animation to display.
        
        | Only applicable with run_type set to step.
        
        Args:
            p0:
                'page_value' page value of the flipbook animation to display, value must must be given in the appropriate corresponding increment
        
        Examples:
            ::
        
                ensight.anim_flipbook.run_type("step")
                ensight.anim_flipbook.page(1.000000)
                ensight.anim_flipbook.page(2.000000)
                ensight.anim_flipbook.page(3.000000)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_flipbook.page({repr(p0)})'''
        return self._session.cmd(cmd)

    def play_backward(self) -> int:
        """Specify that the flipbook is to be played backward/forward.
        
        Examples:
            ::
        
                #
                # Note: transient dataset w/83 time steps...
                #
                # Specify a transient_data flipbook 
                #
                ensight.anim_flipbook.load_type("transient_data")
                #
                # Specify page increment
                #
                ensight.anim_flipbook.step_by(1.0000e+01)
                #
                # Set begin/end flipbook time info
                #
                ensight.anim_flipbook.begin_time_step(0)
                ensight.anim_flipbook.end_time_step(83)
                ensight.anim_flipbook.specify_time_as("step")
                #
                # Load flipbook pages {0,10,20,30,40,50,60,70,80}
                #
                ensight.anim_flipbook.load()
                #
                # Run loaded flipbook
                #
                ensight.anim_flipbook.play_backward()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_flipbook.play_backward()'''
        return self._session.cmd(cmd)

    def play_forward(self) -> int:
        """Specify that the flipbook is to be played backward/forward.
        
        Examples:
            ::
        
                #
                # Note: transient dataset w/83 time steps...
                #
                # Specify a transient_data flipbook 
                #
                ensight.anim_flipbook.load_type("transient_data")
                #
                # Specify page increment
                #
                ensight.anim_flipbook.step_by(1.0000e+01)
                #
                # Set begin/end flipbook time info
                #
                ensight.anim_flipbook.begin_time_step(0)
                ensight.anim_flipbook.end_time_step(83)
                ensight.anim_flipbook.specify_time_as("step")
                #
                # Load flipbook pages {0,10,20,30,40,50,60,70,80}
                #
                ensight.anim_flipbook.load()
                #
                # Run loaded flipbook
                #
                ensight.anim_flipbook.play_backward()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_flipbook.play_forward()'''
        return self._session.cmd(cmd)

    def play_style(self) -> int:
        """Anim_flipbook: play_style

        """
        cmd = f'''ensight.anim_flipbook.play_style()'''
        return self._session.cmd(cmd)

    def query_attributes(self, args: Any) -> int:
        """Anim_flipbook: query_attributes

        """
        cmd = f'''ensight.anim_flipbook.query_attributes({repr(args)})'''
        return self._session.cmd(cmd)

    def query_loaded(self, args: Any) -> int:
        """Anim_flipbook: query_loaded

        """
        cmd = f'''ensight.anim_flipbook.query_loaded({repr(args)})'''
        return self._session.cmd(cmd)

    def query_running(self, args: Any) -> int:
        """Anim_flipbook: query_running

        """
        cmd = f'''ensight.anim_flipbook.query_running({repr(args)})'''
        return self._session.cmd(cmd)

    def regen_all_pages(self, p0: str) -> int:
        """Toggle indicating whether to regenerate existing flipbook pages when loading a flipbook.
        
        | No need to regenerate all pages if extending the number of time steps or filling-in skipped time steps.
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                ensight.anim_flipbook.regen_all_pages("OFF")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_flipbook.regen_all_pages({repr(p0)})'''
        return self._session.cmd(cmd)

    def restore_images(self, p0: str) -> int:
        """Anim_flipbook: restore_images

        """
        cmd = f'''ensight.anim_flipbook.restore_images({repr(p0)})'''
        return self._session.cmd(cmd)

    def run(self, p0: str) -> int:
        """Anim_flipbook: run

        """
        cmd = f'''ensight.anim_flipbook.run({repr(p0)})'''
        return self._session.cmd(cmd)

    def run_type(self, p0: str) -> int:
        """Specify how to play the flipbook animation.
        
        Args:
            p0:
                'option' auto
            p1:
                'option' step
            p2:
                'option' off
        
        Examples:
            ::
        
                ensight.anim_flipbook.run_type("auto")
        
            ::
        
                ensight.anim_flipbook.run_type("step")
                ensight.anim_flipbook.page(1.000000)
                ensight.anim_flipbook.page(2.000000)
                ensight.anim_flipbook.page(3.000000)
        
            ::
        
                ensight.anim_flipbook.run_type("off")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_flipbook.run_type({repr(p0)})'''
        return self._session.cmd(cmd)

    def save_images(self, p0: str) -> int:
        """Specify the file name prefix into which each flipbook animation page (or each image) will be recorded.
        
        | Each page image will be saved into a file of the form "fileprefix_ipage.ext" where "filename_prefix" is the path and name of the file, "ipage" is the corresponding page number, and "ext" is the appropriate image format extension name.
        
        Args:
            p0:
                'filename_prefix' file name prefix of the recorded media
        
        Examples:
            ::
        
                #
                # Set the recording image format to sgi RGB
                #
                ensight.file.image_format("sgi_rgb")
                #
                # Record each page of the flipbook of main graphics window size
                # into a file named "demo_ipage.rgb" where "ipage" is the page 
                # number of the animation.
                #
                ensight.anim_flipbook.save_win_type("normal")
                ensight.anim_flipbook.save_images("demo")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_flipbook.save_images({repr(p0)})'''
        return self._session.cmd(cmd)

    def save_multiple_images(self, p0: str) -> int:
        """When recording an animation flipbook with a detached display this option will save a file for each display if on.  If off will save a single file.
        
        | When saving a flat-wall detached display, the user can choose to write one large image for the wall or one image per pipe from the dconfig file.  Only used if the anim_flipbook: save_win_type is set to "detached_display".
        
        Args:
            p0:
                'toggle'
        
                * ON
                * OFF
        
        Examples:
            ::
        
                #
                # Set the recording image format to be envideo
                #
                ensight.file.image_format("envideo")
                #
                # Record flipbook images from the detached display
                #
                ensight.anim_flipbook.save_win_type("detached_display")
                ensight.anim_flipbook.save_multiple_images("ON")
                ensight.anim_flipbook.save_images("/tmp/test_movie")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_flipbook.save_multiple_images({repr(p0)})'''
        return self._session.cmd(cmd)

    def save_win_size(self, p0: int, p1: int) -> int:
        """Specify the x and y window dimensions of the flipbook animation images.
        
        | Only applicable with command option  "anim_flipbook: save_win_type user_defined".
        
        Args:
            p0:
                'x_size' x window size, or width of the window, in screen coordinates
            p1:
                'y_size' y window size, or height of the window, in screen coordinates
        
        Examples:
            ::
        
                #
                # Set the recording image format to sgi RGB
                #
                ensight.file.image_format("sgi_rgb")
                #
                # Record each page of the flipbook of main graphics window size
                # into a file named "demo_ipage.rgb" where "ipage" is the page 
                # number of the animation.
                #
                ensight.anim_flipbook.save_win_type("user_defined")
                ensight.anim_flipbook.save_win_size(320,240)
                ensight.anim_flipbook.save_images("demo")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_flipbook.save_win_size({repr(p0)},{repr(p1)})'''
        return self._session.cmd(cmd)

    def save_win_type(self, p0: str) -> int:
        """Specify the size of the window/image into which to play/record the flipbook animation.
        
        Args:
            p0:
                'type'
        
                * normal
                * full
                * detached display
                * user_defined
                * NTSC
                * PAL
                * HD720p
                * HD1080p
                * DVDNTSC
                * DVDPAL
        
        Examples:
            ::
        
                #
                # Set the recording image format to sgi RGB
                #
                ensight.file.image_format("sgi_rgb")
                #
                # Record each page of the flipbook of main graphics window size
                # into a file named "demo_ipage.rgb" where "ipage" is the page 
                # number of the animation.
                #
                ensight.anim_flipbook.save_win_type("user_defined")
                ensight.anim_flipbook.save_win_size(320,240)
                ensight.anim_flipbook.save_images("demo")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_flipbook.save_win_type({repr(p0)})'''
        return self._session.cmd(cmd)

    def select_all_timesteps(self) -> int:
        """When loading a flipbook load all timesteps that exist.
        
        | This command is useful in batch scripts since you do not need to know how many timesteps exist.  The command is not generated by interactive use of EnSight.
        
        Examples:
            ::
        
                ensight.anim_flipbook.select_all_timesteps()
                ensight.anim_flipbook.load()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_flipbook.select_all_timesteps()'''
        return self._session.cmd(cmd)

    def show_from_page(self, p0: float) -> int:
        """Specify the starting page from which to run the flipbook animation.
        
        | This page value must not be greater than the "anim_flipbook: show_to_page" value.
        
        Args:
            p0:
                'page_value' a page value which lies within the range of loaded pages
        
        Examples:
            ::
        
                #
                # Preliminary flipbook animation of 21 time steps
                #
                ensight.anim_flipbook.begin_time_step(30)
                ensight.anim_flipbook.end_time_step(50)
                ensight.anim_flipbook.specify_time_as("step")
                ensight.anim_flipbook.load()
                ensight.anim_flipbook.run_type("auto")
                #
                # Reduce flipbook animation to 16 time steps
                #
                ensight.anim_flipbook.show_from_page(35)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_flipbook.show_from_page({repr(p0)})'''
        return self._session.cmd(cmd)

    def show_to_page(self, p0: float) -> int:
        """Specify the ending page to which to run the flipbook animation.
        
        | This page value must not be less than the "anim_flipbook: show_from_page" value.
        
        Args:
            p0:
                'page_value' A page value which lies within the range of loaded pages
        
        Examples:
            ::
        
                #
                # Preliminary flipbook animation of 21 time steps
                #
                ensight.anim_flipbook.begin_time_step(30)
                ensight.anim_flipbook.end_time_step(50)
                ensight.anim_flipbook.specify_time_as("step")
                ensight.anim_flipbook.load()
                ensight.anim_flipbook.run_type("auto")
                #
                # Reduce flipbook animation to 11 time steps
                #
                ensight.anim_flipbook.show_from_page(35)
                ensight.anim_flipbook.show_to_page(45)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_flipbook.show_to_page({repr(p0)})'''
        return self._session.cmd(cmd)

    def specify_time_as(self, p0: str) -> int:
        """Specify the paging units for the flipbook animation.
        
        | Not applicable if not transient data.
        | The default is "step"
        
        Args:
            p0:
                'option' simulation
            p1:
                'option' step
        
        Examples:
            ::
        
                #
                # Change time sequence from time step to simulation time
                #
                ensight.solution_time.show_as("time")
                #
                # Set begin/end flipbook time info
                #
                ensight.anim_flipbook.specify_time_as("simulation")
                ensight.anim_flipbook.begin_simtime(3.5400e+02)
                ensight.anim_flipbook.end_simtime(3.6900e+02)
                ensight.anim_flipbook.load()
                ensight.anim_flipbook.run_type("auto")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_flipbook.specify_time_as({repr(p0)})'''
        return self._session.cmd(cmd)

    def step_backward(self) -> int:
        """Step back/forward one frame of a flipbook.
        
        | This command is not generated by the EnSight GUI, but is intended for use with batch or context operations where the time of the first step could vary from model to model.
        
        Examples:
            ::
        
                #
                # Note: transient dataset w/83 time steps...
                #
                # Specify a transient_data flipbook 
                #
                ensight.anim_flipbook.load_type("transient_data")
                #
                # Specify page increment
                #
                ensight.anim_flipbook.step_by(1.0000e+01)
                #
                # Set begin/end flipbook time info
                #
                ensight.anim_flipbook.begin_time_step(0)
                ensight.anim_flipbook.end_time_step(83)
                ensight.anim_flipbook.specify_time_as("step")
                #
                # Load flipbook pages {0,10,20,30,40,50,60,70,80}
                #
                ensight.anim_flipbook.load()
                #
                # Run loaded flipbook
                #
                ensight.anim_flipbook.play_backward()
                ensight.anim_flipbook.stop()
                ensight.anim_flipbook.step_backward()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_flipbook.step_backward()'''
        return self._session.cmd(cmd)

    def step_by(self, p0: float) -> int:
        """Specify the time step increment by which to run the transient_data flipbook animation.
        
        | Not applicable if not transient data. Only pages contained in the valid time-step range will be generated. 
        
        Args:
            p0:
                'step_increment' increment value in time-step units that preferably lies within the range set by the
        
        Examples:
            ::
        
                #
                # Note: transient dataset w/83 time steps...
                #
                # Specify a transient_data flipbook 
                #
                ensight.anim_flipbook.load_type("transient_data")
                #
                # Specify page increment
                #
                ensight.anim_flipbook.step_by(1.0000e+01)
                #
                # Set begin/end flipbook time info
                #
                ensight.anim_flipbook.begin_time_step(0)
                ensight.anim_flipbook.end_time_step(83)
                ensight.anim_flipbook.specify_time_as("step")
                #
                # Load and run flipbook pages {0,10,20,30,40,50,60,70,80}
                #
                ensight.anim_flipbook.load()
                ensight.anim_flipbook.run_type("auto")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_flipbook.step_by({repr(p0)})'''
        return self._session.cmd(cmd)

    def step_forward(self) -> int:
        """Step back/forward one frame of a flipbook.
        
        | This command is not generated by the EnSight GUI, but is intended for use with batch or context operations where the time of the first step could vary from model to model.
        
        Examples:
            ::
        
                #
                # Note: transient dataset w/83 time steps...
                #
                # Specify a transient_data flipbook 
                #
                ensight.anim_flipbook.load_type("transient_data")
                #
                # Specify page increment
                #
                ensight.anim_flipbook.step_by(1.0000e+01)
                #
                # Set begin/end flipbook time info
                #
                ensight.anim_flipbook.begin_time_step(0)
                ensight.anim_flipbook.end_time_step(83)
                ensight.anim_flipbook.specify_time_as("step")
                #
                # Load flipbook pages {0,10,20,30,40,50,60,70,80}
                #
                ensight.anim_flipbook.load()
                #
                # Run loaded flipbook
                #
                ensight.anim_flipbook.play_backward()
                ensight.anim_flipbook.stop()
                ensight.anim_flipbook.step_backward()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_flipbook.step_forward()'''
        return self._session.cmd(cmd)

    def step_increment(self, p0: float) -> int:
        """Anim_flipbook: step_increment

        """
        cmd = f'''ensight.anim_flipbook.step_increment({repr(p0)})'''
        return self._session.cmd(cmd)

    def step_simtime(self, p0: float) -> int:
        """Specify the simulation-time increment by which to run the transient_data flipbook animation.
        
        | Not applicable if not transient data. Only pages contained in the valid simulation-time range will be generated. 
        
        Args:
            p0:
                'time_value' increment value in simulation-time units that preferably lies within the range set by the
        
        Examples:
            ::
        
                #
                # Specify time and flipbook sequencing as simulation time
                #
                ensight.solution_time.show_as("time")
                ensight.anim_flipbook.specify_time_as("simulation")
                #
                # Specify time increment
                #
                ensight.anim_flipbook.step_simtime(2.0000e+00)
                #
                # Load and run transient data flipbook
                #
                ensight.anim_flipbook.begin_simtime(3.5400e+02)
                ensight.anim_flipbook.end_simtime(3.6400e+02)
                #
                # Load and run flipbook pages with t=354.0,356.0,358.0,360.0,362.0,364.0
                #
                ensight.anim_flipbook.load()
                ensight.anim_flipbook.run_type("auto")
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_flipbook.step_simtime({repr(p0)})'''
        return self._session.cmd(cmd)

    def stop(self) -> int:
        """Stop playing a flipbook.
        
        Examples:
            ::
        
                #
                # Note: transient dataset w/83 time steps...
                #
                # Specify a transient_data flipbook 
                #
                ensight.anim_flipbook.load_type("transient_data")
                #
                # Specify page increment
                #
                ensight.anim_flipbook.step_by(1.0000e+01)
                #
                # Set begin/end flipbook time info
                #
                ensight.anim_flipbook.begin_time_step(0)
                ensight.anim_flipbook.end_time_step(83)
                ensight.anim_flipbook.specify_time_as("step")
                #
                # Load flipbook pages {0,10,20,30,40,50,60,70,80}
                #
                ensight.anim_flipbook.load()
                #
                # Run loaded flipbook
                #
                ensight.anim_flipbook.play_backward()
                ensight.anim_flipbook.stop()
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_flipbook.stop()'''
        return self._session.cmd(cmd)

    def time(self, p0: float) -> int:
        """Specify which page of the flipbook animation to display.
        
        | Only applicable with run_type is set to step.
        
        Args:
            p0:
                'time_value' simulation-time value that corresponds to a loaded page
        
        Examples:
            ::
        
                #
                # Manually display 3 pages of the animated flipbook sequences
                # that correspond to the simulation time values of 1.1, 2.1, and 3.1.
                #
                ensight.anim_flipbook.run_type("step")
                ensight.anim_flipbook.time(1.100000)
                ensight.anim_flipbook.time(1.200000)
                ensight.anim_flipbook.time(1.300000)
        
        Returns:
            zero on success, non-zero on error

        """
        cmd = f'''ensight.anim_flipbook.time({repr(p0)})'''
        return self._session.cmd(cmd)

    def use_gpucache(self, p0: str) -> int:
        """Anim_flipbook: use_gpucache

        """
        cmd = f'''ensight.anim_flipbook.use_gpucache({repr(p0)})'''
        return self._session.cmd(cmd)


class anim:
    """Class wrapper for EnSight anim module

    This class acts as a proxy for the EnSight Python module ensight.anim
    """
    def __init__(self, session: Session):
        self._session = session

    def delete(self) -> int:
        """Anim: delete

        """
        cmd = f'''ensight.anim.delete()'''
        return self._session.cmd(cmd)

    def description(self, p0: str) -> int:
        """Anim: description

        """
        cmd = f'''ensight.anim.description({repr(p0)})'''
        return self._session.cmd(cmd)

    def deselect_all(self) -> int:
        """Anim: deselect_all

        """
        cmd = f'''ensight.anim.deselect_all()'''
        return self._session.cmd(cmd)

    def location_x(self, p0: float) -> int:
        """Anim: location_x

        """
        cmd = f'''ensight.anim.location_x({repr(p0)})'''
        return self._session.cmd(cmd)

    def location_y(self, p0: float) -> int:
        """Anim: location_y

        """
        cmd = f'''ensight.anim.location_y({repr(p0)})'''
        return self._session.cmd(cmd)

    def modify_begin(self) -> int:
        """Anim: modify_begin

        """
        cmd = f'''ensight.anim.modify_begin()'''
        return self._session.cmd(cmd)

    def modify_end(self) -> int:
        """Anim: modify_end

        """
        cmd = f'''ensight.anim.modify_end()'''
        return self._session.cmd(cmd)

    def new_logo(self, p0: str) -> int:
        """Anim: new_logo

        """
        cmd = f'''ensight.anim.new_logo({repr(p0)})'''
        return self._session.cmd(cmd)

    def new_or_mod_logo(self, p0: str) -> int:
        """Anim: new_or_mod_logo

        """
        cmd = f'''ensight.anim.new_or_mod_logo({repr(p0)})'''
        return self._session.cmd(cmd)

    def normalized_width(self, p0: float) -> int:
        """Anim: normalized_width

        """
        cmd = f'''ensight.anim.normalized_width({repr(p0)})'''
        return self._session.cmd(cmd)

    def query_count(self, args: Any) -> int:
        """Anim: query_count

        """
        cmd = f'''ensight.anim.query_count({repr(args)})'''
        return self._session.cmd(cmd)

    def query_display_attributes(self, args: Any) -> int:
        """Anim: query_display_attributes

        """
        cmd = f'''ensight.anim.query_display_attributes({repr(args)})'''
        return self._session.cmd(cmd)

    def query_selected_objects(self, args: Any) -> int:
        """Anim: query_selected_objects

        """
        cmd = f'''ensight.anim.query_selected_objects({repr(args)})'''
        return self._session.cmd(cmd)

    def read(self, p0: str) -> int:
        """Anim: read

        """
        cmd = f'''ensight.anim.read({repr(p0)})'''
        return self._session.cmd(cmd)

    def rgb(self, p0: float, p1: float, p2: float) -> int:
        """Anim: rgb

        """
        cmd = f'''ensight.anim.rgb({repr(p0)},{repr(p1)},{repr(p2)})'''
        return self._session.cmd(cmd)

    def scale(self, p0: float, p1: float) -> int:
        """Anim: scale

        """
        cmd = f'''ensight.anim.scale({repr(p0)},{repr(p1)})'''
        return self._session.cmd(cmd)

    def select_all(self) -> int:
        """Anim: select_all

        """
        cmd = f'''ensight.anim.select_all()'''
        return self._session.cmd(cmd)

    def select_all_invisible(self) -> int:
        """Anim: select_all_invisible

        """
        cmd = f'''ensight.anim.select_all_invisible()'''
        return self._session.cmd(cmd)

    def select_all_visible(self) -> int:
        """Anim: select_all_visible

        """
        cmd = f'''ensight.anim.select_all_visible()'''
        return self._session.cmd(cmd)

    def select_begin(self, *args, **kwargs) -> Any:
        """Anim: select_begin

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.anim.select_begin({arg_string})"
        return self._session.cmd(cmd)

    def select_default(self) -> int:
        """Anim: select_default

        """
        cmd = f'''ensight.anim.select_default()'''
        return self._session.cmd(cmd)

    def show_raytraced_image(self, p0: str) -> int:
        """Anim: show_raytraced_image

        """
        cmd = f'''ensight.anim.show_raytraced_image({repr(p0)})'''
        return self._session.cmd(cmd)

    def use_normalized_width(self, p0: str) -> int:
        """Anim: use_normalized_width

        """
        cmd = f'''ensight.anim.use_normalized_width({repr(p0)})'''
        return self._session.cmd(cmd)

    def visible(self, p0: str) -> int:
        """Anim: visible

        """
        cmd = f'''ensight.anim.visible({repr(p0)})'''
        return self._session.cmd(cmd)


class ensight:
    """Class wrapper for EnSight ensight module

    This class acts as a proxy for the EnSight Python module ensight

    Attributes:
        ANNOT_ARROW (int):
            Instance specific constant

        ANNOT_DIAL (int):
            Instance specific constant

        ANNOT_GAUGE (int):
            Instance specific constant

        ANNOT_LEGEND (int):
            Instance specific constant

        ANNOT_LINE (int):
            Instance specific constant

        ANNOT_LOGO (int):
            Instance specific constant

        ANNOT_SHAPE (int):
            Instance specific constant

        ANNOT_TEXT (int):
            Instance specific constant

        ARROW_COUNT (str):
            Instance specific constant

        ARROW_DISPLAY_ATTRIBUTES (str):
            Instance specific constant

        ARROW_LABEL_TEXT (str):
            Instance specific constant

        ARROW_SELECTED_OBJECTS (str):
            Instance specific constant

        BUILDINFO (str):
            Instance specific constant

        CMDLANG_VERSION (str):
            Instance specific constant

        CMDLANG_VERSION_FLT (str):
            Instance specific constant

        CORE_TS_XML (str):
            Instance specific constant

        CVF_2D_STAGE (int):
            Instance specific constant

        CVF_3D_ARROW (int):
            Instance specific constant

        CVF_3D_STAGE (int):
            Instance specific constant

        CVF_ANNOT (int):
            Instance specific constant

        CVF_AXIS_TRIAD (int):
            Instance specific constant

        CVF_BOX_TOOL (int):
            Instance specific constant

        CVF_CAMERA_TOOL (int):
            Instance specific constant

        CVF_CONE_TOOL (int):
            Instance specific constant

        CVF_CURSOR_TOOL (int):
            Instance specific constant

        CVF_CYLINDER_TOOL (int):
            Instance specific constant

        CVF_DIAL_ANNOT (int):
            Instance specific constant

        CVF_ELEMENT_BLANK (int):
            Instance specific constant

        CVF_EVENT_LOCAT_END1 (int):
            Instance specific constant

        CVF_EVENT_LOCAT_END2 (int):
            Instance specific constant

        CVF_EVENT_LOCAT_LOWER_LEFT (int):
            Instance specific constant

        CVF_EVENT_LOCAT_LOWER_RIGHT (int):
            Instance specific constant

        CVF_EVENT_LOCAT_MID (int):
            Instance specific constant

        CVF_EVENT_LOCAT_RADIUS (int):
            Instance specific constant

        CVF_EVENT_LOCAT_UPPER_LEFT (int):
            Instance specific constant

        CVF_EVENT_LOCAT_UPPER_RIGHT (int):
            Instance specific constant

        CVF_EVENT_LOCAT_XAXIS (int):
            Instance specific constant

        CVF_EVENT_LOCAT_YAXIS (int):
            Instance specific constant

        CVF_EVENT_LOCAT_ZAXIS (int):
            Instance specific constant

        CVF_FRAME (int):
            Instance specific constant

        CVF_GAUGE_ANNOT (int):
            Instance specific constant

        CVF_HUM (int):
            Instance specific constant

        CVF_IQ_QUERY_PROBE (int):
            Instance specific constant

        CVF_LEGEND (int):
            Instance specific constant

        CVF_LINE_ANNOT (int):
            Instance specific constant

        CVF_LINE_TOOL (int):
            Instance specific constant

        CVF_LOGO_ANNOT (int):
            Instance specific constant

        CVF_PALETTE_BANDS (int):
            Instance specific constant

        CVF_PART (int):
            Instance specific constant

        CVF_PART_CONTOUR_LABEL (int):
            Instance specific constant

        CVF_PICK_UNKNOWN (int):
            Instance specific constant

        CVF_PLANE_TOOL (int):
            Instance specific constant

        CVF_PLOTTER (int):
            Instance specific constant

        CVF_POLYLINE (int):
            Instance specific constant

        CVF_QUERY (int):
            Instance specific constant

        CVF_QUERY_MARKER (int):
            Instance specific constant

        CVF_REALTIME_TRACES (int):
            Instance specific constant

        CVF_REVO_TOOL (int):
            Instance specific constant

        CVF_SELECTION_TOOL (int):
            Instance specific constant

        CVF_SHAPE_ANNOT (int):
            Instance specific constant

        CVF_SPHERE_TOOL (int):
            Instance specific constant

        CVF_TEXT_ANNOT (int):
            Instance specific constant

        CVF_TRANSFORM (int):
            Instance specific constant

        CVF_TRANSFORM_LOCAL (int):
            Instance specific constant

        CVF_TRANSFORM_MODE (int):
            Instance specific constant

        CVF_TRANSFORM_PICK (int):
            Instance specific constant

        CVF_USERDEF_TOOL (int):
            Instance specific constant

        CVF_VARIABLE (int):
            Instance specific constant

        CVF_VIEWPORT (int):
            Instance specific constant

        DATARATES (str):
            Instance specific constant

        DATASET (str):
            Instance specific constant

        DIALOG_INFO_ANIMSAVE (str):
            Instance specific constant

        DIALOG_INFO_IMAGESAVE (str):
            Instance specific constant

        DIAL_COUNT (str):
            Instance specific constant

        DIAL_DISPLAY_ATTRIBUTES (str):
            Instance specific constant

        DIAL_SELECTED_OBJECTS (str):
            Instance specific constant

        DISPLAY_MATERIALS_INFO (str):
            Instance specific constant

        DR_FRAME_STATS (str):
            Instance specific constant

        DR_INFO (str):
            Instance specific constant

        ENS_BUTTON_LEFT (int):
            Instance specific constant

        ENS_BUTTON_MIDDLE (int):
            Instance specific constant

        ENS_BUTTON_RIGHT (int):
            Instance specific constant

        ENS_BUTTON_WHEEL (int):
            Instance specific constant

        ENS_EVENT_6D_BUTTON_DOWN (int):
            Instance specific constant

        ENS_EVENT_6D_BUTTON_UP (int):
            Instance specific constant

        ENS_EVENT_6D_MOTION (int):
            Instance specific constant

        ENS_EVENT_6D_VALUATOR (int):
            Instance specific constant

        ENS_EVENT_ALL (int):
            Instance specific constant

        ENS_EVENT_CASE (int):
            Instance specific constant

        ENS_EVENT_CTOR (int):
            Instance specific constant

        ENS_EVENT_CURRENT (int):
            Instance specific constant

        ENS_EVENT_DRAWABLE_ENTER (int):
            Instance specific constant

        ENS_EVENT_DRAWABLE_EXPOSE (int):
            Instance specific constant

        ENS_EVENT_DRAWABLE_FOCUSIN (int):
            Instance specific constant

        ENS_EVENT_DRAWABLE_FOCUSOUT (int):
            Instance specific constant

        ENS_EVENT_DRAWABLE_HIDE (int):
            Instance specific constant

        ENS_EVENT_DRAWABLE_LEAVE (int):
            Instance specific constant

        ENS_EVENT_DRAWABLE_RESIZE (int):
            Instance specific constant

        ENS_EVENT_DRAWABLE_RESTORE (int):
            Instance specific constant

        ENS_EVENT_DRAWABLE_SAVE (int):
            Instance specific constant

        ENS_EVENT_DRAWABLE_SHOW (int):
            Instance specific constant

        ENS_EVENT_DSG_PROGRESS (int):
            Instance specific constant

        ENS_EVENT_DTOR (int):
            Instance specific constant

        ENS_EVENT_HIDE (int):
            Instance specific constant

        ENS_EVENT_KEY_DOWN (int):
            Instance specific constant

        ENS_EVENT_KEY_UP (int):
            Instance specific constant

        ENS_EVENT_MOUSE_BUTTON_DOWN (int):
            Instance specific constant

        ENS_EVENT_MOUSE_BUTTON_UP (int):
            Instance specific constant

        ENS_EVENT_MOUSE_DOUBLE_CLICK (int):
            Instance specific constant

        ENS_EVENT_MOUSE_MOTION (int):
            Instance specific constant

        ENS_EVENT_NEW_TIME (int):
            Instance specific constant

        ENS_EVENT_PART (int):
            Instance specific constant

        ENS_EVENT_PARTSELECT (int):
            Instance specific constant

        ENS_EVENT_POSTCOMMAND (int):
            Instance specific constant

        ENS_EVENT_POSTRENDER (int):
            Instance specific constant

        ENS_EVENT_PRECOMMAND (int):
            Instance specific constant

        ENS_EVENT_PRERENDER (int):
            Instance specific constant

        ENS_EVENT_PYTHON (int):
            Instance specific constant

        ENS_EVENT_QUERY (int):
            Instance specific constant

        ENS_EVENT_QUERY_DATA (int):
            Instance specific constant

        ENS_EVENT_QUERY_PROBE (int):
            Instance specific constant

        ENS_EVENT_QUERY_SCALARS (int):
            Instance specific constant

        ENS_EVENT_QUIT (int):
            Instance specific constant

        ENS_EVENT_RENAME (int):
            Instance specific constant

        ENS_EVENT_SHOW (int):
            Instance specific constant

        ENS_EVENT_SOLUTION_TIME (int):
            Instance specific constant

        ENS_EVENT_TIMEOUT (int):
            Instance specific constant

        ENS_EVENT_VARIABLE (int):
            Instance specific constant

        ENS_EVENT_WHEEL_MOTION (int):
            Instance specific constant

        ENS_EVENT_WINDOW (int):
            Instance specific constant

        ENS_EVENT_WINDOW_PLOTTER (int):
            Instance specific constant

        ENS_MODIFIER_ALT (int):
            Instance specific constant

        ENS_MODIFIER_CTRL (int):
            Instance specific constant

        ENS_MODIFIER_SHIFT (int):
            Instance specific constant

        FEEDBACK_CURSOR (int):
            Instance specific constant

        FEEDBACK_MESSAGE (int):
            Instance specific constant

        FLIPBOOK_ATTRIBUTES (str):
            Instance specific constant

        FLIPBOOK_INFORMATION (str):
            Instance specific constant

        FLIPBOOK_LOADED (str):
            Instance specific constant

        FLIPBOOK_RUNNING (str):
            Instance specific constant

        FRAME_COUNT (str):
            Instance specific constant

        FRAME_LOCATION (str):
            Instance specific constant

        FSI_TRACE_LIMIT (str):
            Instance specific constant

        FULLSCREEN (str):
            Instance specific constant

        GAUGE_COUNT (str):
            Instance specific constant

        GAUGE_DISPLAY_ATTRIBUTES (str):
            Instance specific constant

        GAUGE_SELECTED_OBJECTS (str):
            Instance specific constant

        GLCONFIG (str):
            Instance specific constant

        LEGEND_COUNT (str):
            Instance specific constant

        LEGEND_DISPLAY_ATTRIBUTES (str):
            Instance specific constant

        LEGEND_SELECTED_OBJECTS (str):
            Instance specific constant

        LINE_COUNT (str):
            Instance specific constant

        LINE_DISPLAY_ATTRIBUTES (str):
            Instance specific constant

        LINE_SELECTED_OBJECTS (str):
            Instance specific constant

        LOGO_COUNT (str):
            Instance specific constant

        LOGO_DISPLAY_ATTRIBUTES (str):
            Instance specific constant

        LOGO_SELECTED_OBJECTS (str):
            Instance specific constant

        MESSAGES (str):
            Instance specific constant

        MOUSE_ACTION_NONE (int):
            Instance specific constant

        MOUSE_BTN_ALL (int):
            Instance specific constant

        MOUSE_BTN_LEFT (int):
            Instance specific constant

        MOUSE_BTN_LEFT_MIDDLE (int):
            Instance specific constant

        MOUSE_BTN_LEFT_RIGHT (int):
            Instance specific constant

        MOUSE_BTN_MIDDLE (int):
            Instance specific constant

        MOUSE_BTN_RIGHT (int):
            Instance specific constant

        MOUSE_BTN_RIGHT_MIDDLE (int):
            Instance specific constant

        MOUSE_NORMAL_ACTION (int):
            Instance specific constant

        MOUSE_PICK_ACTION (int):
            Instance specific constant

        MOUSE_PICK_BLANK_ELEMENTS (int):
            Instance specific constant

        MOUSE_PICK_CURSOR (int):
            Instance specific constant

        MOUSE_PICK_PART (int):
            Instance specific constant

        MOUSE_PICK_PART_OPTIONS (int):
            Instance specific constant

        MOUSE_PICK_TRANSFORM_CENTER (int):
            Instance specific constant

        MOUSE_ROTATE (int):
            Instance specific constant

        MOUSE_SELECT_TOOL (int):
            Instance specific constant

        MOUSE_TRANSLATE (int):
            Instance specific constant

        MOUSE_USER_DEFINED (int):
            Instance specific constant

        MOUSE_ZOOM (int):
            Instance specific constant

        MOUSE_ZOOMBAND (int):
            Instance specific constant

        PARTS_WITH_SCALARVALUE (str):
            Instance specific constant

        PART_AUX_GEOM (int):
            Instance specific constant

        PART_AXI_SYMMETRIC (int):
            Instance specific constant

        PART_BUILT_UP (int):
            Instance specific constant

        PART_CLIP_PLANE (int):
            Instance specific constant

        PART_CONTOUR (int):
            Instance specific constant

        PART_DEVELOPED_SURFACE (int):
            Instance specific constant

        PART_DISCRETE_PARTICLE (int):
            Instance specific constant

        PART_DISPLAY_ATTRIBUTES (str):
            Instance specific constant

        PART_ELEMENT_PICKEDBYWINXY (str):
            Instance specific constant

        PART_ELEMENT_PICKEDBYWORLDXYZ (str):
            Instance specific constant

        PART_ELEVATED_SURFACE (int):
            Instance specific constant

        PART_FILTER_PART (int):
            Instance specific constant

        PART_FRAME (int):
            Instance specific constant

        PART_FX_SEP_ATT (int):
            Instance specific constant

        PART_FX_SHOCK (int):
            Instance specific constant

        PART_FX_VORTEX_CORE (int):
            Instance specific constant

        PART_ISO_SURFACE (int):
            Instance specific constant

        PART_ISO_VOLUME (int):
            Instance specific constant

        PART_MATERIAL_INTERFACE (int):
            Instance specific constant

        PART_MODEL (int):
            Instance specific constant

        PART_MODEL_BOUNDARY (int):
            Instance specific constant

        PART_MODEL_CUT (int):
            Instance specific constant

        PART_MODEL_EXTRACT (int):
            Instance specific constant

        PART_MODEL_MERGE (int):
            Instance specific constant

        PART_MULT (int):
            Instance specific constant

        PART_NODE_PICKEDBYWINXY (str):
            Instance specific constant

        PART_NODE_PICKEDBYWORLDXYZ (str):
            Instance specific constant

        PART_OBJECTS (str):
            Instance specific constant

        PART_PARTICLE_TRACE (int):
            Instance specific constant

        PART_PICKED (str):
            Instance specific constant

        PART_POINT (int):
            Instance specific constant

        PART_PROFILE (int):
            Instance specific constant

        PART_SELECTED_OBJECTS (str):
            Instance specific constant

        PART_TENSOR_GLYPH (int):
            Instance specific constant

        PART_VECTOR_ARROW (int):
            Instance specific constant

        PART_VOF (int):
            Instance specific constant

        PICK_BLANK_ELEMENTS (int):
            Instance specific constant

        PICK_CAMERA_DIRECTION_NODE (int):
            Instance specific constant

        PICK_CAMERA_DIRECTION_XYZ (int):
            Instance specific constant

        PICK_CAMERA_LOCATION_NODE (int):
            Instance specific constant

        PICK_CAMERA_LOCATION_XYZ (int):
            Instance specific constant

        PICK_CENTER_VIEW (int):
            Instance specific constant

        PICK_CENTER_VIEW_PLUS_NORMAL (int):
            Instance specific constant

        PICK_CYLINDER (int):
            Instance specific constant

        PICK_ELEMENT_TYPE_ALL (int):
            Instance specific constant

        PICK_ELEMENT_TYPE_BAR (int):
            Instance specific constant

        PICK_ELEMENT_TYPE_PNT (int):
            Instance specific constant

        PICK_ELEMENT_TYPE_QUAD (int):
            Instance specific constant

        PICK_ELEMENT_TYPE_TRIA (int):
            Instance specific constant

        PICK_FRAME_ORIGIN (int):
            Instance specific constant

        PICK_LINE (int):
            Instance specific constant

        PICK_LINE_NODEIDS (int):
            Instance specific constant

        PICK_LINE_SURFACE_NORMAL (int):
            Instance specific constant

        PICK_LOOKAT (int):
            Instance specific constant

        PICK_PALETTE_BAND (int):
            Instance specific constant

        PICK_PART (int):
            Instance specific constant

        PICK_PLANE (int):
            Instance specific constant

        PICK_PLANE2PT (int):
            Instance specific constant

        PICK_PLANE_NODEIDS (int):
            Instance specific constant

        PICK_PLANE_NORMAL (int):
            Instance specific constant

        PICK_PLANE_ORIGIN (int):
            Instance specific constant

        PICK_PLANE_ORIGIN_AND_NORMAL (int):
            Instance specific constant

        PICK_POINT (int):
            Instance specific constant

        PICK_POLYLINE_POINT (int):
            Instance specific constant

        PICK_POLYLINE_POINT_PART_CENTER (int):
            Instance specific constant

        PICK_SIMULATE_MENU (int):
            Instance specific constant

        PICK_TRANSFORM_CENTER (int):
            Instance specific constant

        PLOT_COUNT (str):
            Instance specific constant

        PLOT_DISPLAY_ATTRIBUTES (str):
            Instance specific constant

        PLOT_PICKED (str):
            Instance specific constant

        POS_CLAMP_NONE (int):
            Instance specific constant

        POS_CLAMP_SCREEN (int):
            Instance specific constant

        POS_CLAMP_SCREEN_STRONG (int):
            Instance specific constant

        POS_TGT_CURSOR (int):
            Instance specific constant

        POS_TGT_CURSORSCN (int):
            Instance specific constant

        POS_TGT_MAINWIN (int):
            Instance specific constant

        POS_TGT_MAINWINSCN (int):
            Instance specific constant

        POS_TGT_NONE (int):
            Instance specific constant

        POS_TGT_PRIMARYSCN (int):
            Instance specific constant

        POS_TGT_WIDGET (int):
            Instance specific constant

        POS_TGT_WIDGETSCN (int):
            Instance specific constant

        PREFERENCESPATH (str):
            Instance specific constant

        QUERY_COUNT (str):
            Instance specific constant

        QUERY_CREATE_ATTRIBUTES (str):
            Instance specific constant

        QUERY_DATA (str):
            Instance specific constant

        QUERY_DISPLAY_ATTRIBUTES (str):
            Instance specific constant

        QUERY_PICKED (str):
            Instance specific constant

        QUERY_PROBE_ATTRIBUTES (str):
            Instance specific constant

        QUERY_PROBE_COUNT (str):
            Instance specific constant

        QUERY_PROBE_DATA (str):
            Instance specific constant

        QUERY_PROBE_OUTPUT (str):
            Instance specific constant

        SCALAR_VARIABLE_PICK (str):
            Instance specific constant

        SENDMESG_DISPLAY (str):
            Instance specific constant

        SENDMESG_FEEDBACK (str):
            Instance specific constant

        SENDMESG_NOEXEC (str):
            Instance specific constant

        SENDMESG_RAISE (str):
            Instance specific constant

        SENDMESG_RECORD (str):
            Instance specific constant

        SHAPE_COUNT (str):
            Instance specific constant

        SHAPE_DISPLAY_ATTRIBUTES (str):
            Instance specific constant

        SHAPE_SELECTED_OBJECTS (str):
            Instance specific constant

        SPLINE_COUNT (str):
            Instance specific constant

        SPLINE_DATA (str):
            Instance specific constant

        SYMBOLGLYPHTABLE (str):
            Instance specific constant

        SYSINFO (str):
            Instance specific constant

        TESTHOOK (str):
            Instance specific constant

        TEXTURE_BORDER_COLOR (str):
            Instance specific constant

        TEXTURE_COUNT (str):
            Instance specific constant

        TEXTURE_IMAGE (str):
            Instance specific constant

        TEXT_COUNT (str):
            Instance specific constant

        TEXT_DISPLAY_ATTRIBUTES (str):
            Instance specific constant

        TEXT_DISPLAY_TEXT (str):
            Instance specific constant

        TEXT_SELECTED_OBJECTS (str):
            Instance specific constant

        TIMEVALS (str):
            Instance specific constant

        TOOL_BOX (int):
            Instance specific constant

        TOOL_CONE (int):
            Instance specific constant

        TOOL_CURSOR (int):
            Instance specific constant

        TOOL_CYLINDER (int):
            Instance specific constant

        TOOL_LINE (int):
            Instance specific constant

        TOOL_PARAMS (str):
            Instance specific constant

        TOOL_PLANE (int):
            Instance specific constant

        TOOL_REVOLUTION (int):
            Instance specific constant

        TOOL_SPHERE (int):
            Instance specific constant

        TRANSFORMATION_CENTER_OF (str):
            Instance specific constant

        TRANSFORMATION_COMPOSITE_MATRIX (str):
            Instance specific constant

        TRANSFORMATION_LOOKAT_POSITION (str):
            Instance specific constant

        TRANSFORMATION_LOOKFROM_POSITION (str):
            Instance specific constant

        TRANSFORMATION_PERANG (str):
            Instance specific constant

        TRANSFORMATION_PROJ_MATRIX (str):
            Instance specific constant

        TRANSFORMATION_ROTATE_MATRIX (str):
            Instance specific constant

        TRANSFORMATION_SCALE_MATRIX (str):
            Instance specific constant

        TRANSFORMATION_TRANSLATE_MATRIX (str):
            Instance specific constant

        TRANSFORMATION_ZCLIP_LOCATIONS (str):
            Instance specific constant

        UNIQUE_ID (str):
            Instance specific constant

        Undefined (float):
            Instance specific constant

        VARIABLE_HISTOGRAM (str):
            Instance specific constant

        VARIABLE_INFORMATION (str):
            Instance specific constant

        VARIABLE_OBJECTS (str):
            Instance specific constant

        VARIABLE_PALETTE (str):
            Instance specific constant

        VIEWPORT_COUNT (str):
            Instance specific constant

        VIEWPORT_DISPLAY_ATTRIBUTES (str):
            Instance specific constant

        VIEWPORT_LOCATION (str):
            Instance specific constant

        VIEWPORT_PICKED (str):
            Instance specific constant

        VIEWPORT_SIZE (str):
            Instance specific constant

        VIEW_MODE (str):
            Instance specific constant

        WINDOW_DEPTH_VALUES (str):
            Instance specific constant

        WINDOW_MOUSECURRENT_INFO (str):
            Instance specific constant

        WINDOW_MOUSELASTPRESS_INFO (str):
            Instance specific constant

        WINDOW_RGBA_VALUES (str):
            Instance specific constant

        WINDOW_SIZE (str):
            Instance specific constant

        anim:
            EnSight module instance class

        anim_flipbook:
            EnSight module instance class

        anim_keyframe:
            EnSight module instance class

        anim_quick:
            EnSight module instance class

        anim_recorders:
            EnSight module instance class

        anim_screens:
            EnSight module instance class

        anim_traces:
            EnSight module instance class

        annot_backgr:
            EnSight module instance class

        annot_entlbl:
            EnSight module instance class

        annotation:
            EnSight module instance class

        argv (list):
            Instance specific constant

        arrow:
            EnSight module instance class

        auxgeom:
            EnSight module instance class

        boundarylayer:
            EnSight module instance class

        case:
            EnSight module instance class

        clip:
            EnSight module instance class

        collab:
            EnSight module instance class

        command:
            EnSight module instance class

        connect:
            EnSight module instance class

        context_restore:
            EnSight module instance class

        contour:
            EnSight module instance class

        core:
            EnSight module instance class

        curve:
            EnSight module instance class

        data:
            EnSight module instance class

        data_partbuild:
            EnSight module instance class

        define:
            EnSight module instance class

        devsrf:
            EnSight module instance class

        dial:
            EnSight module instance class

        dpart:
            EnSight module instance class

        elevsurf:
            EnSight module instance class

        extrude:
            EnSight module instance class

        file:
            EnSight module instance class

        filterpart:
            EnSight module instance class

        format:
            EnSight module instance class

        frame:
            EnSight module instance class

        function:
            EnSight module instance class

        gauge:
            EnSight module instance class

        help:
            EnSight module instance class

        isos:
            EnSight module instance class

        legend:
            EnSight module instance class

        lightsource:
            EnSight module instance class

        line:
            EnSight module instance class

        logo:
            EnSight module instance class

        material:
            EnSight module instance class

        message_window:
            EnSight module instance class

        model:
            EnSight module instance class

        nplot:
            EnSight module instance class

        nvc:
            EnSight module instance class

        objs:
            EnSight module instance class

        part:
            EnSight module instance class

        plot:
            EnSight module instance class

        pointpart:
            EnSight module instance class

        prefs:
            EnSight module instance class

        profile:
            EnSight module instance class

        ptrace:
            EnSight module instance class

        ptrace_emitr:
            EnSight module instance class

        query_ent_var:
            EnSight module instance class

        query_interact:
            EnSight module instance class

        savegeom:
            EnSight module instance class

        scene:
            EnSight module instance class

        sepattach:
            EnSight module instance class

        set_tdata:
            EnSight module instance class

        set_visenv:
            EnSight module instance class

        shape:
            EnSight module instance class

        shell:
            EnSight module instance class

        shock:
            EnSight module instance class

        show_info:
            EnSight module instance class

        solution_time:
            EnSight module instance class

        species:
            EnSight module instance class

        subset:
            EnSight module instance class

        tensor:
            EnSight module instance class

        text:
            EnSight module instance class

        texture:
            EnSight module instance class

        tools:
            EnSight module instance class

        user:
            EnSight module instance class

        varextcfd:
            EnSight module instance class

        variables:
            EnSight module instance class

        vctarrow:
            EnSight module instance class

        view:
            EnSight module instance class

        view_transf:
            EnSight module instance class

        viewport:
            EnSight module instance class

        viewport_axis:
            EnSight module instance class

        viewport_bounds:
            EnSight module instance class

        views:
            EnSight module instance class

        vof:
            EnSight module instance class

        vortexcore:
            EnSight module instance class


    """
    def __init__(self, session: Session):
        self._session = session
        self.utils = UtilsNameSpace()
        self.ANNOT_ARROW: int = 5
        self.ANNOT_DIAL: int = 6
        self.ANNOT_GAUGE: int = 7
        self.ANNOT_LEGEND: int = 3
        self.ANNOT_LINE: int = 1
        self.ANNOT_LOGO: int = 2
        self.ANNOT_SHAPE: int = 8
        self.ANNOT_TEXT: int = 0
        self.ARROW_COUNT: str = 'ARROW_COUNT'
        self.ARROW_DISPLAY_ATTRIBUTES: str = 'ARROW_DISPLAY_ATTRIBUTES'
        self.ARROW_LABEL_TEXT: str = 'ARROW_LABEL_TEXT'
        self.ARROW_SELECTED_OBJECTS: str = 'ARROW_SELECTED_OBJECTS'
        self.BUILDINFO: str = 'BUILDINFO'
        self.CMDLANG_VERSION: str = 'CMDLANG_VERSION'
        self.CMDLANG_VERSION_FLT: str = 'CMDLANG_VERSION_FLT'
        self.CORE_TS_XML: str = 'CORE_TS_XML'
        self.CVF_2D_STAGE: int = 42
        self.CVF_3D_ARROW: int = 26
        self.CVF_3D_STAGE: int = 43
        self.CVF_ANNOT: int = 24
        self.CVF_AXIS_TRIAD: int = 41
        self.CVF_BOX_TOOL: int = 9
        self.CVF_CAMERA_TOOL: int = 20
        self.CVF_CONE_TOOL: int = 6
        self.CVF_CURSOR_TOOL: int = 2
        self.CVF_CYLINDER_TOOL: int = 5
        self.CVF_DIAL_ANNOT: int = 28
        self.CVF_ELEMENT_BLANK: int = 17
        self.CVF_EVENT_LOCAT_END1: int = 0
        self.CVF_EVENT_LOCAT_END2: int = 1
        self.CVF_EVENT_LOCAT_LOWER_LEFT: int = 8
        self.CVF_EVENT_LOCAT_LOWER_RIGHT: int = 9
        self.CVF_EVENT_LOCAT_MID: int = 2
        self.CVF_EVENT_LOCAT_RADIUS: int = 10
        self.CVF_EVENT_LOCAT_UPPER_LEFT: int = 6
        self.CVF_EVENT_LOCAT_UPPER_RIGHT: int = 7
        self.CVF_EVENT_LOCAT_XAXIS: int = 3
        self.CVF_EVENT_LOCAT_YAXIS: int = 4
        self.CVF_EVENT_LOCAT_ZAXIS: int = 5
        self.CVF_FRAME: int = 1
        self.CVF_GAUGE_ANNOT: int = 29
        self.CVF_HUM: int = 14
        self.CVF_IQ_QUERY_PROBE: int = 33
        self.CVF_LEGEND: int = 32
        self.CVF_LINE_ANNOT: int = 27
        self.CVF_LINE_TOOL: int = 3
        self.CVF_LOGO_ANNOT: int = 30
        self.CVF_PALETTE_BANDS: int = 19
        self.CVF_PART: int = 0
        self.CVF_PART_CONTOUR_LABEL: int = 38
        self.CVF_PICK_UNKNOWN: int = -1
        self.CVF_PLANE_TOOL: int = 4
        self.CVF_PLOTTER: int = 22
        self.CVF_POLYLINE: int = 21
        self.CVF_QUERY: int = 23
        self.CVF_QUERY_MARKER: int = 34
        self.CVF_REALTIME_TRACES: int = 16
        self.CVF_REVO_TOOL: int = 8
        self.CVF_SELECTION_TOOL: int = 18
        self.CVF_SHAPE_ANNOT: int = 31
        self.CVF_SPHERE_TOOL: int = 7
        self.CVF_TEXT_ANNOT: int = 25
        self.CVF_TRANSFORM: int = 10
        self.CVF_TRANSFORM_LOCAL: int = 11
        self.CVF_TRANSFORM_MODE: int = 12
        self.CVF_TRANSFORM_PICK: int = 15
        self.CVF_USERDEF_TOOL: int = 36
        self.CVF_VARIABLE: int = 35
        self.CVF_VIEWPORT: int = 13
        self.DATARATES: str = 'DATARATES'
        self.DATASET: str = 'DATASET'
        self.DIALOG_INFO_ANIMSAVE: str = 'DIALOG_INFO_ANIMSAVE'
        self.DIALOG_INFO_IMAGESAVE: str = 'DIALOG_INFO_IMAGESAVE'
        self.DIAL_COUNT: str = 'DIAL_COUNT'
        self.DIAL_DISPLAY_ATTRIBUTES: str = 'DIAL_DISPLAY_ATTRIBUTES'
        self.DIAL_SELECTED_OBJECTS: str = 'DIAL_SELECTED_OBJECTS'
        self.DISPLAY_MATERIALS_INFO: str = 'DISPLAY_MATERIALS_INFO'
        self.DR_FRAME_STATS: str = 'DR_FRAME_STATS'
        self.DR_INFO: str = 'DR_INFO'
        self.ENS_BUTTON_LEFT: int = 1
        self.ENS_BUTTON_MIDDLE: int = 2
        self.ENS_BUTTON_RIGHT: int = 4
        self.ENS_BUTTON_WHEEL: int = 128
        self.ENS_EVENT_6D_BUTTON_DOWN: int = 302
        self.ENS_EVENT_6D_BUTTON_UP: int = 303
        self.ENS_EVENT_6D_MOTION: int = 301
        self.ENS_EVENT_6D_VALUATOR: int = 304
        self.ENS_EVENT_ALL: int = 0
        self.ENS_EVENT_CASE: int = 10
        self.ENS_EVENT_CTOR: int = 0
        self.ENS_EVENT_CURRENT: int = 2
        self.ENS_EVENT_DRAWABLE_ENTER: int = 409
        self.ENS_EVENT_DRAWABLE_EXPOSE: int = 402
        self.ENS_EVENT_DRAWABLE_FOCUSIN: int = 407
        self.ENS_EVENT_DRAWABLE_FOCUSOUT: int = 408
        self.ENS_EVENT_DRAWABLE_HIDE: int = 405
        self.ENS_EVENT_DRAWABLE_LEAVE: int = 410
        self.ENS_EVENT_DRAWABLE_RESIZE: int = 401
        self.ENS_EVENT_DRAWABLE_RESTORE: int = 412
        self.ENS_EVENT_DRAWABLE_SAVE: int = 411
        self.ENS_EVENT_DRAWABLE_SHOW: int = 404
        self.ENS_EVENT_DSG_PROGRESS: int = 14
        self.ENS_EVENT_DTOR: int = 1
        self.ENS_EVENT_HIDE: int = 4
        self.ENS_EVENT_KEY_DOWN: int = 200
        self.ENS_EVENT_KEY_UP: int = 201
        self.ENS_EVENT_MOUSE_BUTTON_DOWN: int = 100
        self.ENS_EVENT_MOUSE_BUTTON_UP: int = 101
        self.ENS_EVENT_MOUSE_DOUBLE_CLICK: int = 102
        self.ENS_EVENT_MOUSE_MOTION: int = 103
        self.ENS_EVENT_NEW_TIME: int = 13
        self.ENS_EVENT_PART: int = 8
        self.ENS_EVENT_PARTSELECT: int = 5
        self.ENS_EVENT_POSTCOMMAND: int = 7
        self.ENS_EVENT_POSTRENDER: int = 4
        self.ENS_EVENT_PRECOMMAND: int = 6
        self.ENS_EVENT_PRERENDER: int = 3
        self.ENS_EVENT_PYTHON: int = 8193
        self.ENS_EVENT_QUERY: int = 11
        self.ENS_EVENT_QUERY_DATA: int = 2
        self.ENS_EVENT_QUERY_PROBE: int = 1
        self.ENS_EVENT_QUERY_SCALARS: int = 0
        self.ENS_EVENT_QUIT: int = 1
        self.ENS_EVENT_RENAME: int = 3
        self.ENS_EVENT_SHOW: int = 5
        self.ENS_EVENT_SOLUTION_TIME: int = 2
        self.ENS_EVENT_TIMEOUT: int = 8192
        self.ENS_EVENT_VARIABLE: int = 9
        self.ENS_EVENT_WHEEL_MOTION: int = 150
        self.ENS_EVENT_WINDOW: int = 12
        self.ENS_EVENT_WINDOW_PLOTTER: int = 1
        self.ENS_MODIFIER_ALT: int = 4
        self.ENS_MODIFIER_CTRL: int = 1
        self.ENS_MODIFIER_SHIFT: int = 2
        self.FEEDBACK_CURSOR: int = 1
        self.FEEDBACK_MESSAGE: int = 2
        self.FLIPBOOK_ATTRIBUTES: str = 'FLIPBOOK_ATTRIBUTES'
        self.FLIPBOOK_INFORMATION: str = 'FLIPBOOK_INFORMATION'
        self.FLIPBOOK_LOADED: str = 'FLIPBOOK_LOADED'
        self.FLIPBOOK_RUNNING: str = 'FLIPBOOK_RUNNING'
        self.FRAME_COUNT: str = 'FRAME_COUNT'
        self.FRAME_LOCATION: str = 'FRAME_LOCATION'
        self.FSI_TRACE_LIMIT: str = 'FSI_TRACE_LIMIT'
        self.FULLSCREEN: str = 'FULLSCREEN'
        self.GAUGE_COUNT: str = 'GAUGE_COUNT'
        self.GAUGE_DISPLAY_ATTRIBUTES: str = 'GAUGE_DISPLAY_ATTRIBUTES'
        self.GAUGE_SELECTED_OBJECTS: str = 'GAUGE_SELECTED_OBJECTS'
        self.GLCONFIG: str = 'GLCONFIG'
        self.LEGEND_COUNT: str = 'LEGEND_COUNT'
        self.LEGEND_DISPLAY_ATTRIBUTES: str = 'LEGEND_DISPLAY_ATTRIBUTES'
        self.LEGEND_SELECTED_OBJECTS: str = 'LEGEND_SELECTED_OBJECTS'
        self.LINE_COUNT: str = 'LINE_COUNT'
        self.LINE_DISPLAY_ATTRIBUTES: str = 'LINE_DISPLAY_ATTRIBUTES'
        self.LINE_SELECTED_OBJECTS: str = 'LINE_SELECTED_OBJECTS'
        self.LOGO_COUNT: str = 'LOGO_COUNT'
        self.LOGO_DISPLAY_ATTRIBUTES: str = 'LOGO_DISPLAY_ATTRIBUTES'
        self.LOGO_SELECTED_OBJECTS: str = 'LOGO_SELECTED_OBJECTS'
        self.MESSAGES: str = 'MESSAGES'
        self.MOUSE_ACTION_NONE: int = 13
        self.MOUSE_BTN_ALL: int = 7
        self.MOUSE_BTN_LEFT: int = 4
        self.MOUSE_BTN_LEFT_MIDDLE: int = 6
        self.MOUSE_BTN_LEFT_RIGHT: int = 5
        self.MOUSE_BTN_MIDDLE: int = 2
        self.MOUSE_BTN_RIGHT: int = 1
        self.MOUSE_BTN_RIGHT_MIDDLE: int = 3
        self.MOUSE_NORMAL_ACTION: int = 10
        self.MOUSE_PICK_ACTION: int = 11
        self.MOUSE_PICK_BLANK_ELEMENTS: int = 9
        self.MOUSE_PICK_CURSOR: int = 7
        self.MOUSE_PICK_PART: int = 5
        self.MOUSE_PICK_PART_OPTIONS: int = 12
        self.MOUSE_PICK_TRANSFORM_CENTER: int = 6
        self.MOUSE_ROTATE: int = 0
        self.MOUSE_SELECT_TOOL: int = 4
        self.MOUSE_TRANSLATE: int = 1
        self.MOUSE_USER_DEFINED: int = 14
        self.MOUSE_ZOOM: int = 2
        self.MOUSE_ZOOMBAND: int = 3
        self.PARTS_WITH_SCALARVALUE: str = 'PARTS_WITH_SCALARVALUE'
        self.PART_AUX_GEOM: int = 25
        self.PART_AXI_SYMMETRIC: int = 22
        self.PART_BUILT_UP: int = 15
        self.PART_CLIP_PLANE: int = 1
        self.PART_CONTOUR: int = 2
        self.PART_DEVELOPED_SURFACE: int = 10
        self.PART_DISCRETE_PARTICLE: int = 3
        self.PART_DISPLAY_ATTRIBUTES: str = 'PART_DISPLAY_ATTRIBUTES'
        self.PART_ELEMENT_PICKEDBYWINXY: str = 'PART_ELEMENT_PICKEDBYWINXY'
        self.PART_ELEMENT_PICKEDBYWORLDXYZ: str = 'PART_ELEMENT_PICKEDBYWORLDXYZ'
        self.PART_ELEVATED_SURFACE: int = 9
        self.PART_FILTER_PART: int = 26
        self.PART_FRAME: int = 4
        self.PART_FX_SEP_ATT: int = 19
        self.PART_FX_SHOCK: int = 18
        self.PART_FX_VORTEX_CORE: int = 17
        self.PART_ISO_SURFACE: int = 5
        self.PART_ISO_VOLUME: int = 14
        self.PART_MATERIAL_INTERFACE: int = 20
        self.PART_MODEL: int = 0
        self.PART_MODEL_BOUNDARY: int = 13
        self.PART_MODEL_CUT: int = 12
        self.PART_MODEL_EXTRACT: int = 11
        self.PART_MODEL_MERGE: int = 23
        self.PART_MULT: int = 27
        self.PART_NODE_PICKEDBYWINXY: str = 'PART_NODE_PICKEDBYWINXY'
        self.PART_NODE_PICKEDBYWORLDXYZ: str = 'PART_NODE_PICKEDBYWORLDXYZ'
        self.PART_OBJECTS: str = 'PART_OBJECTS'
        self.PART_PARTICLE_TRACE: int = 6
        self.PART_PICKED: str = 'PART_PICKED'
        self.PART_POINT: int = 21
        self.PART_PROFILE: int = 7
        self.PART_SELECTED_OBJECTS: str = 'PART_SELECTED_OBJECTS'
        self.PART_TENSOR_GLYPH: int = 16
        self.PART_VECTOR_ARROW: int = 8
        self.PART_VOF: int = 24
        self.PICK_BLANK_ELEMENTS: int = 10
        self.PICK_CAMERA_DIRECTION_NODE: int = 19
        self.PICK_CAMERA_DIRECTION_XYZ: int = 18
        self.PICK_CAMERA_LOCATION_NODE: int = 17
        self.PICK_CAMERA_LOCATION_XYZ: int = 16
        self.PICK_CENTER_VIEW: int = 30
        self.PICK_CENTER_VIEW_PLUS_NORMAL: int = 31
        self.PICK_CYLINDER: int = 23
        self.PICK_ELEMENT_TYPE_ALL: int = 0
        self.PICK_ELEMENT_TYPE_BAR: int = 3
        self.PICK_ELEMENT_TYPE_PNT: int = 4
        self.PICK_ELEMENT_TYPE_QUAD: int = 1
        self.PICK_ELEMENT_TYPE_TRIA: int = 2
        self.PICK_FRAME_ORIGIN: int = 21
        self.PICK_LINE: int = 3
        self.PICK_LINE_NODEIDS: int = 12
        self.PICK_LINE_SURFACE_NORMAL: int = 13
        self.PICK_LOOKAT: int = 5
        self.PICK_PALETTE_BAND: int = 14
        self.PICK_PART: int = 1
        self.PICK_PLANE: int = 2
        self.PICK_PLANE2PT: int = 6
        self.PICK_PLANE_NODEIDS: int = 11
        self.PICK_PLANE_NORMAL: int = 9
        self.PICK_PLANE_ORIGIN: int = 8
        self.PICK_PLANE_ORIGIN_AND_NORMAL: int = 22
        self.PICK_POINT: int = 4
        self.PICK_POLYLINE_POINT: int = 15
        self.PICK_POLYLINE_POINT_PART_CENTER: int = 20
        self.PICK_SIMULATE_MENU: int = 35
        self.PICK_TRANSFORM_CENTER: int = 7
        self.PLOT_COUNT: str = 'PLOT_COUNT'
        self.PLOT_DISPLAY_ATTRIBUTES: str = 'PLOT_DISPLAY_ATTRIBUTES'
        self.PLOT_PICKED: str = 'PLOT_PICKED'
        self.POS_CLAMP_NONE: int = 0
        self.POS_CLAMP_SCREEN: int = 1
        self.POS_CLAMP_SCREEN_STRONG: int = 2
        self.POS_TGT_CURSOR: int = 1
        self.POS_TGT_CURSORSCN: int = 3
        self.POS_TGT_MAINWIN: int = 0
        self.POS_TGT_MAINWINSCN: int = 5
        self.POS_TGT_NONE: int = 7
        self.POS_TGT_PRIMARYSCN: int = 2
        self.POS_TGT_WIDGET: int = 6
        self.POS_TGT_WIDGETSCN: int = 4
        self.PREFERENCESPATH: str = 'PREFERENCESPATH'
        self.QUERY_COUNT: str = 'QUERY_COUNT'
        self.QUERY_CREATE_ATTRIBUTES: str = 'QUERY_CREATE_ATTRIBUTES'
        self.QUERY_DATA: str = 'QUERY_DATA'
        self.QUERY_DISPLAY_ATTRIBUTES: str = 'QUERY_DISPLAY_ATTRIBUTES'
        self.QUERY_PICKED: str = 'QUERY_PICKED'
        self.QUERY_PROBE_ATTRIBUTES: str = 'QUERY_PROBE_ATTRIBUTES'
        self.QUERY_PROBE_COUNT: str = 'QUERY_PROBE_COUNT'
        self.QUERY_PROBE_DATA: str = 'QUERY_PROBE_DATA'
        self.QUERY_PROBE_OUTPUT: str = 'QUERY_PROBE_OUTPUT'
        self.SCALAR_VARIABLE_PICK: str = 'SCALAR_VARIABLE_PICK'
        self.SENDMESG_DISPLAY: str = 'SENDMESG_DISPLAY'
        self.SENDMESG_FEEDBACK: str = 'SENDMESG_FEEDBACK'
        self.SENDMESG_NOEXEC: str = 'SENDMESG_NOEXEC'
        self.SENDMESG_RAISE: str = 'SENDMESG_RAISE'
        self.SENDMESG_RECORD: str = 'SENDMESG_RECORD'
        self.SHAPE_COUNT: str = 'SHAPE_COUNT'
        self.SHAPE_DISPLAY_ATTRIBUTES: str = 'SHAPE_DISPLAY_ATTRIBUTES'
        self.SHAPE_SELECTED_OBJECTS: str = 'SHAPE_SELECTED_OBJECTS'
        self.SPLINE_COUNT: str = 'SPLINE_COUNT'
        self.SPLINE_DATA: str = 'SPLINE_DATA'
        self.SYMBOLGLYPHTABLE: str = 'SYMBOLGLYPHTABLE'
        self.SYSINFO: str = 'SYSINFO'
        self.TESTHOOK: str = 'TESTHOOK'
        self.TEXTURE_BORDER_COLOR: str = 'TEXTURE_BORDER_COLOR'
        self.TEXTURE_COUNT: str = 'TEXTURE_COUNT'
        self.TEXTURE_IMAGE: str = 'TEXTURE_IMAGE'
        self.TEXT_COUNT: str = 'TEXT_COUNT'
        self.TEXT_DISPLAY_ATTRIBUTES: str = 'TEXT_DISPLAY_ATTRIBUTES'
        self.TEXT_DISPLAY_TEXT: str = 'TEXT_DISPLAY_TEXT'
        self.TEXT_SELECTED_OBJECTS: str = 'TEXT_SELECTED_OBJECTS'
        self.TIMEVALS: str = 'TIMEVALS'
        self.TOOL_BOX: int = 3
        self.TOOL_CONE: int = 5
        self.TOOL_CURSOR: int = 0
        self.TOOL_CYLINDER: int = 4
        self.TOOL_LINE: int = 1
        self.TOOL_PARAMS: str = 'TOOL_PARAMS'
        self.TOOL_PLANE: int = 2
        self.TOOL_REVOLUTION: int = 7
        self.TOOL_SPHERE: int = 6
        self.TRANSFORMATION_CENTER_OF: str = 'TRANSFORMATION_CENTER_OF'
        self.TRANSFORMATION_COMPOSITE_MATRIX: str = 'TRANSFORMATION_COMPOSITE_MATRIX'
        self.TRANSFORMATION_LOOKAT_POSITION: str = 'TRANSFORMATION_LOOKAT_POSITION'
        self.TRANSFORMATION_LOOKFROM_POSITION: str = 'TRANSFORMATION_LOOKFROM_POSITION'
        self.TRANSFORMATION_PERANG: str = 'TRANSFORMATION_PERANG'
        self.TRANSFORMATION_PROJ_MATRIX: str = 'TRANSFORMATION_PROJ_MATRIX'
        self.TRANSFORMATION_ROTATE_MATRIX: str = 'TRANSFORMATION_ROTATE_MATRIX'
        self.TRANSFORMATION_SCALE_MATRIX: str = 'TRANSFORMATION_SCALE_MATRIX'
        self.TRANSFORMATION_TRANSLATE_MATRIX: str = 'TRANSFORMATION_TRANSLATE_MATRIX'
        self.TRANSFORMATION_ZCLIP_LOCATIONS: str = 'TRANSFORMATION_ZCLIP_LOCATIONS'
        self.UNIQUE_ID: str = 'UNIQUE_ID'
        self.Undefined: float = -1.2345000022229158e-10
        self.VARIABLE_HISTOGRAM: str = 'VARIABLE_HISTOGRAM'
        self.VARIABLE_INFORMATION: str = 'VARIABLE_INFORMATION'
        self.VARIABLE_OBJECTS: str = 'VARIABLE_OBJECTS'
        self.VARIABLE_PALETTE: str = 'VARIABLE_PALETTE'
        self.VIEWPORT_COUNT: str = 'VIEWPORT_COUNT'
        self.VIEWPORT_DISPLAY_ATTRIBUTES: str = 'VIEWPORT_DISPLAY_ATTRIBUTES'
        self.VIEWPORT_LOCATION: str = 'VIEWPORT_LOCATION'
        self.VIEWPORT_PICKED: str = 'VIEWPORT_PICKED'
        self.VIEWPORT_SIZE: str = 'VIEWPORT_SIZE'
        self.VIEW_MODE: str = 'VIEW_MODE'
        self.WINDOW_DEPTH_VALUES: str = 'WINDOW_DEPTH_VALUES'
        self.WINDOW_MOUSECURRENT_INFO: str = 'WINDOW_MOUSECURRENT_INFO'
        self.WINDOW_MOUSELASTPRESS_INFO: str = 'WINDOW_MOUSELASTPRESS_INFO'
        self.WINDOW_RGBA_VALUES: str = 'WINDOW_RGBA_VALUES'
        self.WINDOW_SIZE: str = 'WINDOW_SIZE'
        self.anim: 'anim' = anim(self._session)
        self.anim_flipbook: 'anim_flipbook' = anim_flipbook(self._session)
        self.anim_keyframe: 'anim_keyframe' = anim_keyframe(self._session)
        self.anim_quick: 'anim_quick' = anim_quick(self._session)
        self.anim_recorders: 'anim_recorders' = anim_recorders(self._session)
        self.anim_screens: 'anim_screens' = anim_screens(self._session)
        self.anim_traces: 'anim_traces' = anim_traces(self._session)
        self.annot_backgr: 'annot_backgr' = annot_backgr(self._session)
        self.annot_entlbl: 'annot_entlbl' = annot_entlbl(self._session)
        self.annotation: 'annotation' = annotation(self._session)
        self.argv: list
        self.arrow: 'arrow' = arrow(self._session)
        self.auxgeom: 'auxgeom' = auxgeom(self._session)
        self.boundarylayer: 'boundarylayer' = boundarylayer(self._session)
        self.case: 'case' = case(self._session)
        self.clip: 'clip' = clip(self._session)
        self.collab: 'collab' = collab(self._session)
        self.command: 'command' = command(self._session)
        self.connect: 'connect' = connect(self._session)
        self.context_restore: 'context_restore' = context_restore(self._session)
        self.contour: 'contour' = contour(self._session)
        self.core: 'core' = core(self._session)
        self.curve: 'curve' = curve(self._session)
        self.data: 'data' = data(self._session)
        self.data_partbuild: 'data_partbuild' = data_partbuild(self._session)
        self.define: 'define' = define(self._session)
        self.devsrf: 'devsrf' = devsrf(self._session)
        self.dial: 'dial' = dial(self._session)
        self.dpart: 'dpart' = dpart(self._session)
        self.elevsurf: 'elevsurf' = elevsurf(self._session)
        self.extrude: 'extrude' = extrude(self._session)
        self.file: 'file' = file(self._session)
        self.filterpart: 'filterpart' = filterpart(self._session)
        self.format: 'format' = format(self._session)
        self.frame: 'frame' = frame(self._session)
        self.function: 'function' = function(self._session)
        self.gauge: 'gauge' = gauge(self._session)
        self.help: 'help' = help(self._session)
        self.isos: 'isos' = isos(self._session)
        self.legend: 'legend' = legend(self._session)
        self.lightsource: 'lightsource' = lightsource(self._session)
        self.line: 'line' = line(self._session)
        self.logo: 'logo' = logo(self._session)
        self.material: 'material' = material(self._session)
        self.message_window: 'message_window' = message_window(self._session)
        self.model: 'model' = model(self._session)
        self.nplot: 'nplot' = nplot(self._session)
        self.nvc: 'nvc' = nvc(self._session)
        self.objs: 'objs' = objs(self._session)
        self.part: 'part' = part(self._session)
        self.plot: 'plot' = plot(self._session)
        self.pointpart: 'pointpart' = pointpart(self._session)
        self.prefs: 'prefs' = prefs(self._session)
        self.profile: 'profile' = profile(self._session)
        self.ptrace: 'ptrace' = ptrace(self._session)
        self.ptrace_emitr: 'ptrace_emitr' = ptrace_emitr(self._session)
        self.query_ent_var: 'query_ent_var' = query_ent_var(self._session)
        self.query_interact: 'query_interact' = query_interact(self._session)
        self.savegeom: 'savegeom' = savegeom(self._session)
        self.scene: 'scene' = scene(self._session)
        self.sepattach: 'sepattach' = sepattach(self._session)
        self.set_tdata: 'set_tdata' = set_tdata(self._session)
        self.set_visenv: 'set_visenv' = set_visenv(self._session)
        self.shape: 'shape' = shape(self._session)
        self.shell: 'shell' = shell(self._session)
        self.shock: 'shock' = shock(self._session)
        self.show_info: 'show_info' = show_info(self._session)
        self.solution_time: 'solution_time' = solution_time(self._session)
        self.species: 'species' = species(self._session)
        self.subset: 'subset' = subset(self._session)
        self.tensor: 'tensor' = tensor(self._session)
        self.text: 'text' = text(self._session)
        self.texture: 'texture' = texture(self._session)
        self.tools: 'tools' = tools(self._session)
        self.user: 'user' = user(self._session)
        self.varextcfd: 'varextcfd' = varextcfd(self._session)
        self.variables: 'variables' = variables(self._session)
        self.vctarrow: 'vctarrow' = vctarrow(self._session)
        self.view: 'view' = view(self._session)
        self.view_transf: 'view_transf' = view_transf(self._session)
        self.viewport: 'viewport' = viewport(self._session)
        self.viewport_axis: 'viewport_axis' = viewport_axis(self._session)
        self.viewport_bounds: 'viewport_bounds' = viewport_bounds(self._session)
        self.views: 'views' = views(self._session)
        self.vof: 'vof' = vof(self._session)
        self.vortexcore: 'vortexcore' = vortexcore(self._session)

    def ENS_stdio(self, *args, **kwargs) -> Any:
        """Object to redirect EnsPy stdio <should not be called by users>

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.ENS_stdio({arg_string})"
        return self._session.cmd(cmd)

    def addcallback(self, *args, **kwargs) -> Any:
        """Add an event callback to EnSight

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.addcallback({arg_string})"
        return self._session.cmd(cmd)

    def batch(self, ) -> int:
        """Detect if EnSight is running in batch mode
        
        
        Returns:
            If EnSight is running in batch mode, this function returns 1.

        """
        arg_list: List[str] = []
        arg_string = ",".join(arg_list)
        cmd = f"ensight.batch({arg_string})"
        return self._session.cmd(cmd)

    def case_replace(self, *args, **kwargs) -> Any:
        """Initiate case replace in the EnSight core

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.case_replace({arg_string})"
        return self._session.cmd(cmd)

    def checkabort(self, *args, **kwargs) -> Any:
        """Check to see if a Python abort has been requested

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.checkabort({arg_string})"
        return self._session.cmd(cmd)

    def color_components_for_mattype(self, *args, **kwargs) -> Any:
        """Returns int containing allowed component flags for a surface material, check by (retval | enums.AMBIENT_COMPONENT etc)

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.color_components_for_mattype({arg_string})"
        return self._session.cmd(cmd)

    def command_enshell(self, *args, **kwargs) -> Any:
        """Send a command to the enshell network

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.command_enshell({arg_string})"
        return self._session.cmd(cmd)

    def connect_enshell(self, *args, **kwargs) -> Any:
        """Connect to a enshell instance

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.connect_enshell({arg_string})"
        return self._session.cmd(cmd)

    def disconnect_enshell(self, *args, **kwargs) -> Any:
        """Kill the current connection to enshell

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.disconnect_enshell({arg_string})"
        return self._session.cmd(cmd)

    def dsg_close_stream(self, *args, **kwargs) -> Any:
        """Delete a DSG stream

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.dsg_close_stream({arg_string})"
        return self._session.cmd(cmd)

    def dsg_new_stream(self, *args, **kwargs) -> Any:
        """Create a new DSG stream ID

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.dsg_new_stream({arg_string})"
        return self._session.cmd(cmd)

    def dsg_save_update(self, *args, **kwargs) -> Any:
        """Perform a stream update and write a geometry file

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.dsg_save_update({arg_string})"
        return self._session.cmd(cmd)

    def eep_execfile(self, *args, **kwargs) -> Any:
        """Execute and EEP file.  First arg is the filename(required).  Second arg is the zip file passwd(optional).

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.eep_execfile({arg_string})"
        return self._session.cmd(cmd)

    def ensvariable(self, varname: str) -> Tuple[Any, int, int]:
        """This method will query EnSight command language variable values and
        return a tuple containing the value, its type and the scope it was
        found in (similar to the command language $ functionality), allowing
        access to variables defined directly in command language or computed
        constants. The function returns None if the variable cannot be found.
        
        Args:
            varname:
                The name of the command language variable to query
        
        Returns:
            A tuple of the form: ``(value, type, scope)``.   ``type`` will be
            0 if the value is an integer, 1 if the value is a float and 2 if
            the value is a string. The ``scope`` is an integer that specifies
            where the variable was found.  -2 if the variable is in the enscl
            namespace (for example, ensight.ensvariable(enscl.FOO)).  -1 if the
            variable is an EnSight constant variable (file, case or computed variable).
            0 if the variable is global in the command language interpreter
            (for example, $globalint BAR) or is a special command language
            variable like: APPTOTALTIMESTEPS. A positive integer if the variable
            is local in the command language interpreter.  The number is the depth
            in the interpreter stack where the value is defined.

        """
        arg_list: List[str] = []
        arg_list.append(varname.__repr__())
        arg_string = ",".join(arg_list)
        cmd = f"ensight.ensvariable({arg_string})"
        return self._session.cmd(cmd)

    def exit(self) -> int:
        """Terminate the EnSight instance::
        
            ensight.exit(code: int) -> None
        
        
        Args:
            code:
                The exit code reported by the process termination.

        """
        cmd = f'''ensight.exit()'''
        return self._session.cmd(cmd)

    def expandPartGroup(self, *args, **kwargs) -> Any:
        """Expand a part group

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.expandPartGroup({arg_string})"
        return self._session.cmd(cmd)

    def fprintf(self, *args, **kwargs) -> Any:
        """Print string directly to STDERR when build DEBUG, otherwise NOP.

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.fprintf({arg_string})"
        return self._session.cmd(cmd)

    def idle(self, yield_cpu: bool = False) -> None:
        """Execute EnSight idle processing
        
        
        Call the EnSight idle processing loop a single time.  It is used in closed
        Python loops where EnSight idle processing (animation, gRPC, etc) needs to
        be allowed to take place.
        
        
        Args:
            yield_cpu:
                If True, the call will give up the cpu time slice when executing
                the idle loop.  It can help reduce cpu utilization while polling.

        """
        arg_list: List[str] = []
        arg_list.append(f"yield_cpu={yield_cpu.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.idle({arg_string})"
        return self._session.cmd(cmd)

    def int_feature(self, *args, **kwargs) -> Any:
        """Internal EnSight function <should not be called by users>

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.int_feature({arg_string})"
        return self._session.cmd(cmd)

    def int_help(self, *args, **kwargs) -> Any:
        """Internal EnSight function <should not be called by users>

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.int_help({arg_string})"
        return self._session.cmd(cmd)

    def int_message(self, *args, **kwargs) -> Any:
        """Internal EnSight function <should not be called by users>

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.int_message({arg_string})"
        return self._session.cmd(cmd)

    def makecolorswatch(self, *args, **kwargs) -> Any:
        """Create a color swatch pixmap

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.makecolorswatch({arg_string})"
        return self._session.cmd(cmd)

    def makeraytracedcolorswatch(self, *args, **kwargs) -> Any:
        """Create a raytraced color swatch pixmap

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.makeraytracedcolorswatch({arg_string})"
        return self._session.cmd(cmd)

    def modify(self, *args, **kwargs) -> Any:
        """Modify the state of various EnSight objects

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.modify({arg_string})"
        return self._session.cmd(cmd)

    def parts_showing(self, *args, **kwargs) -> Any:
        """Return a list of parts showing in the viewport

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.parts_showing({arg_string})"
        return self._session.cmd(cmd)

    def pick_points(self, *args, **kwargs) -> Any:
        """Pick nearest visible nodes or elements

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.pick_points({arg_string})"
        return self._session.cmd(cmd)

    def play(self, *args, **kwargs) -> Any:
        """Play a command or Python file

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.play({arg_string})"
        return self._session.cmd(cmd)

    def qtparent(self, *args, **kwargs) -> Any:
        """Get the PyQt object to be used as a toplevel widget parent

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.qtparent({arg_string})"
        return self._session.cmd(cmd)

    def qtparent_int(self, *args, **kwargs) -> Any:
        """Internal EnSight function <should not be called by users>

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.qtparent_int({arg_string})"
        return self._session.cmd(cmd)

    def qtposition(self, *args, **kwargs) -> Any:
        """Reposition a widget relative to other widgets or the screen

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.qtposition({arg_string})"
        return self._session.cmd(cmd)

    def qtwinflags(self, *args, **kwargs) -> Any:
        """Get the PyQt window flags to be used with a toplevel widget

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.qtwinflags({arg_string})"
        return self._session.cmd(cmd)

    def query(self, *args, **kwargs) -> Any:
        """Query the state of various EnSight objects

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.query({arg_string})"
        return self._session.cmd(cmd)

    def query_cases(self, *args, **kwargs) -> Any:
        """Query case information

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.query_cases({arg_string})"
        return self._session.cmd(cmd)

    def query_elems(self, *args, **kwargs) -> Any:
        """Query element values on the server

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.query_elems({arg_string})"
        return self._session.cmd(cmd)

    def query_event(self, *args, **kwargs) -> Any:
        """Query the currently dispatching events to see if more are coming.

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.query_event({arg_string})"
        return self._session.cmd(cmd)

    def query_nodes(self, *args, **kwargs) -> Any:
        """Query node values on the server

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.query_nodes({arg_string})"
        return self._session.cmd(cmd)

    def query_parts(self, *args, **kwargs) -> Any:
        """Query part information on the server

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.query_parts({arg_string})"
        return self._session.cmd(cmd)

    def query_pixelbuffer(self, x: int, y: int, x2: int = 2147483647, y2: int = 2147483647, parts_only: int = 0,            deep_part_check: int = 0) -> List[Any]:
        """Find the EnSight objects under a point or for all the points in a rectangle.
        
        This method allows the caller to probe the rendered pixel buffer and determine
        which EnSight objects are visible at a point or within a rectangle of pixels.
        The x and y coordinates within the rendering window must be specified in pixels.
        ``0, 0`` is the lower left corner of the window.
        ``ensight.objs.core.WINDOWSIZE[0]-1, ensight.objs.core.WINDOWSIZE[1]-1`` is the
        upper-rightmost pixel.
        Specifying a rectangle of pixels is done by including x2 and y2 keyword arguments.
        Note that 2147483647 is treated as "undefined" for x2 and y2.
        
        
        The method can work in two ways, "Object mode" or "Part mode".  Object mode is selected
        by only passing the x and y single pick point and no other options. In this mode, the
        returned value is a list of lists. For example::
        
            [[partobj, [x,y,z]], [partobj, [x,y,z]], [annotobj, [x,y,z]]]
        
        
        For a part, the x,y,z coordinates are the location on the part in model space.
        For a 2D object like an annotation, x and y are the normalized screen coordinates and z is
        the normalized front clip plane.  Note, this operation can be slow if a rectangle is specified.
        
        
        Part mode is selected by specifying ``parts_only=1`` or ``deep_part_check=1``.  In part mode,
        the return value is a simple list of ENS_PART objects. This is normally done by interrogating the
        rendered pixels for the target parts.  If deep_part_check is 1, it is computed by intersecting
        the geometry with the point or rectangle.  This can pick parts hidden behind other parts.
        
        
        Args:
            x:
                The x position of the pixel to query (or a corner if x2 and y2 are specified).
            y:
                The y position of the pixel to query (or a corner if x2 and y2 are specified).
            x2:
                The x position of the other corner of the rectangle to query.
            y2:
                The y position of the other corner of the rectangle to query.
            parts_only:
                If set to 1, only x2 and y2 cannot be specified and the return value will be
                restricted to ENS_PART objects only.  Note: no x,y,z location will be
                included in the return value if the option is selected.
            deep_part_check:
                If set to 1, the returned set of ENS_PART objects will not be limited to the first
                part object hit in depth.  Use this option if you want to return parts that might
                be occluded by parts that are closer to the viewer.  Note: no x,y,z location will be
                included in the return value if the option is selected.
        
        Returns:
            A list of objects that would be intersected by passing rays from the viewer though the
            selected pixel or block of pixels.  The return value may or may not include the x,y,z
            coordinates (in data space) of the intersection.

        """
        arg_list: List[str] = []
        arg_list.append(x.__repr__())
        arg_list.append(y.__repr__())
        arg_list.append(f"x2={x2.__repr__()}")
        arg_list.append(f"y2={y2.__repr__()}")
        arg_list.append(f"parts_only={parts_only.__repr__()}")
        arg_list.append(f"deep_part_check={deep_part_check.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.query_pixelbuffer({arg_string})"
        return self._session.cmd(cmd)

    def query_points(self, *args, **kwargs) -> Any:
        """This function is a basic variable and mesh query mechanism::
        
            ensight.query_points(points: List[List[float, float, float],
                                 parts: Any = None,
                                 variables: List[int] = None,
                                 time: float = -1e9) -> List[Any]
        
        
        Args:
            points:
                A list of points to query (a Python list of 3 value python lists).
                An example would be: ``[ [1,2,0], [2,4,2] ]`` for two points. The function
                will perform a query at each point in the list.
            parts:
                If no parts are specified, the currently selected parts will be used.
                Otherwise, parts may be set to the string "all" to search all parts or
                it may be a list of parts.  In the list, the values can be part names,
                part numbers or part objects. For example: ``parts=["mesh","field",8]``
                will include the parts named mesh, field and part number 8 in the query.
            variables:
                If present, variables should be a Python list variable that may include
                any mixture of string names, variable numbers or variable objects for
                all the variables that should be included in the query. For
                example: ``variables=["velocity","pressure",2]`` will include output
                for the variables named velocity, pressure and variable number 2 in the query.
            time:
                If not present, the query will be for the current time value in EnSight.
                The caller can also specify a specific time value using this keyword.
        
        Return:
            The return value is a list of output lists. One list for each input point.
            If no variables are specified, the query will be about the mesh structure
            and the list for each point will appear as::
        
                [part_number, structuredpart_flag, closest_node, element_id]
        
        
            The values are the part number the point was found in, a flag that is non-zero
            if the part is structured, the node id of the node closest to the point and
            the element id of the element that contains the point. If a list of variables
            is specified, the returned value will be a list of lists, one for each
            variable. If the input variables were "pressure" and "velocity" (a
            scalar and a vector), the output (per point) would be::
        
                [ [pressure_value], [velocity_x, velocity_y, velocity_z] ]

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.query_points({arg_string})"
        return self._session.cmd(cmd)

    def query_trace_paths(self, *args, **kwargs) -> Any:
        """Query particle trace paths

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.query_trace_paths({arg_string})"
        return self._session.cmd(cmd)

    def query_xy_create(self, title: str, xtitle: str, ytitle: str,                            data: List[List[float]],                            segments: Optional[list] = None, filename: str = "",                            record: int = 0, xvariable: Optional["ENS_VAR"] = None,                            yvariable: Optional["ENS_VAR"] = None,                            case: Optional["ENS_CASE"] = None) -> int:
        """Create an ENS_QUERY instance
        
        Create a new "file" XY query object.
        
        
        Args:
            title:
                The title string for the query.
            xtitle:
                The title for the X axis
            ytitle:
                The title for the Y axis
            data:
                A list of XY list values.
            segments:
                This is an array of point counts.  After every count point, there will
                be a "break" in the plotted query line.
            filename:
                The filename to be associated with this query.  Note: this is just for
                reference, the file is not read.
            record:
                If set to 1, this operation will be recorded into command language.
            xvariable:
                If set to an ENS_VAR object, that object will define the units for the X axis.
            yvariable:
                If set to an ENS_VAR object, that object will define the units for the Y axis.
            case:
                If set to an ENS_CASE object, that object will define the unit system for the query.
        
        Returns:
            The index of the created query.   The INDEX attribute of the ENS_QUERY object
            will have this value.
        
        
        Example:
            ::
        
                data = [[1, 1], [2, 4], [3, 9]]
                qidx = ensight.query_xy_create("New Data", "X Axis", "Y Axis", data)
                query_object = max(ensight.objs.core.QUERIES)

        """
        arg_list: List[str] = []
        arg_list.append(title.__repr__())
        arg_list.append(xtitle.__repr__())
        arg_list.append(ytitle.__repr__())
        arg_list.append(data.__repr__())
        arg_list.append(f"segments={segments.__repr__()}")
        arg_list.append(f"filename={filename.__repr__()}")
        arg_list.append(f"record={record.__repr__()}")
        arg_list.append(f"xvariable={xvariable.__repr__()}")
        arg_list.append(f"yvariable={yvariable.__repr__()}")
        arg_list.append(f"case={case.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.query_xy_create({arg_string})"
        return self._session.cmd(cmd)

    def query_xy_update(self, id: int, data: List[List[float]], segments: Optional[list] = None) -> int:
        """Update the data values in a query
        
        Update the data values of a "file" XY query.
        
        
        Args:
            id:
                The INDEX attribute for the ENS_QUERY object to be updated.
            data:
                A list of XY list values.
            segments:
                This is an array of point counts.  After every count point, there will
                be a "break" in the plotted query line.
        
        Returns:
            The query index id that was updated or a negative number on an error.
        
        
        Example:
            ::
        
                data = [[1, 1], [2, 4], [3, 9]]
                qidx = ensight.query_xy_create("New Data", "X Axis", "Y Axis", data)
                query_object = max(ensight.objs.core.QUERIES)
                data = [[1, 0.5], [2, 3.5], [3, 8.5], [4, 15.5]]
                err = ensight.query_xy_create(query_object.INDEX, data)

        """
        arg_list: List[str] = []
        arg_list.append(id.__repr__())
        arg_list.append(data.__repr__())
        arg_list.append(f"segments={segments.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.query_xy_update({arg_string})"
        return self._session.cmd(cmd)

    def refresh(self, force: int = 0) -> None:
        """Refresh the EnSight rendering window
        
        
        Cause the EnSight rendering window to update.
        
        
        Args:
            force:
                By default, the redraw will only occur if the scene is dirty.  If force
                is set to 1, the scene will be forcibly redrawn.

        """
        arg_list: List[str] = []
        arg_list.append(f"force={force.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.refresh({arg_string})"
        return self._session.cmd(cmd)

    def register_cmd(self, *args, **kwargs) -> Any:
        """Internal EnSight function <should not be called by users>

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.register_cmd({arg_string})"
        return self._session.cmd(cmd)

    def remap_cmdlang_name(self, *args, **kwargs) -> Any:
        """Remap a command language verb to a valid Python verb

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.remap_cmdlang_name({arg_string})"
        return self._session.cmd(cmd)

    def removecallback(self, *args, **kwargs) -> Any:
        """Remove an event callback from EnSight

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.removecallback({arg_string})"
        return self._session.cmd(cmd)

    def render(self, *args, **kwargs) -> Any:
        """Render image at arbitrary resolution

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.render({arg_string})"
        return self._session.cmd(cmd)

    def reparent(self, *args, **kwargs) -> Any:
        """Function to stack a PyQt top level Window inside of the application window tree.

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.reparent({arg_string})"
        return self._session.cmd(cmd)

    def replace_case(self, *args, **kwargs) -> Any:
        """Initiate case replace in the EnSight core

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.replace_case({arg_string})"
        return self._session.cmd(cmd)

    def save_command_file(self, *args, **kwargs) -> Any:
        """Save commands from the current session to the given filename

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.save_command_file({arg_string})"
        return self._session.cmd(cmd)

    def scalar_variable_pick_begin(self, *args, **kwargs) -> Any:
        """Begin scalar variable part selection mode

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.scalar_variable_pick_begin({arg_string})"
        return self._session.cmd(cmd)

    def scalar_variable_pick_end(self, *args, **kwargs) -> Any:
        """End scalar variable part selection mode

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.scalar_variable_pick_end({arg_string})"
        return self._session.cmd(cmd)

    def sendevent(self, *args, **kwargs) -> Any:
        """Send a Python object as an event to other Python event listeners.

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.sendevent({arg_string})"
        return self._session.cmd(cmd)

    def sendmesg(self, command: Union[str, tuple], record: int = 0, display: int = 0, exception: int = 0, noexec: int = 0) -> int:
        """Executes one or more command language commands
        
        The method can be passed a single string or a tuple of strings.  In the latter case, all the
        strings in the tuple will be executed. For example:
        
        .. code-block:: python
        
            ensight.sendmesg(("shell: echo A", "shell: echo B"))
        
        
        executes two command language commands. The sendmesg() function provides keywords to control
        the display and recording of the individual commands it executes. By default, commands are
        executed, but not recorded in the session command log. Explicitly setting any keywords
        will override the defaults set by the sendmesgoptions() method.
        
        Args:
            record:
                If set to 1, commands will be logged to the EnSight command journal.
            display:
                If set to 1, commands will echo the command text to the EnSight console.
            exception:
                If set to 1, and a command results in an error, a Python runtime exception
                will be raised.
            noexec:
                If set to 1, allow the record and display operations to run as selected, but
                actual execution of the command is suppressed.
        
        Returns:
            0 if no error and a -1 if error.

        """
        arg_list: List[str] = []
        arg_list.append(command.__repr__())
        arg_list.append(f"record={record.__repr__()}")
        arg_list.append(f"display={display.__repr__()}")
        arg_list.append(f"exception={exception.__repr__()}")
        arg_list.append(f"noexec={noexec.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.sendmesg({arg_string})"
        return self._session.cmd(cmd)

    def sendmesgoptions(self, record: int = 0, display: int = 0, exception: int = 0, noexec: int = 0) -> None:
        """Control the operation of EnSight native API and sendmesg() calls
        
        This method sets the default values for the exception, record, display and noexec keywords in
        the ensight.sendmesg() method and the EnSight native Python API.
        
        For example:
        
        .. code-block:: python
        
            session.ensight.sendmesgoptions(record=1, display=1)
            session.ensight.sendmesg("shell: echo A")
        
        
        results in the shell: command being both logged and printed. The commands:
        
        .. code-block:: python
        
            ensight.sendmesgoptions(record=1, display=1)
            ensight.sendmesg("shell: echo A", record=0)
        
        
        results in the shell: command being printed, but not recorded.
        
        
        Args:
            record:
                If set to 1, commands will be logged to the EnSight command journal.
            display:
                If set to 1, commands will echo the commands text to the EnSight console.
            exception:
                If set to 1, and a command results in an error, a Python runtime exception
                will be raised.
            noexec:
                If set to 1, allow the record and display operations to run as selected, but
                actual execution of the command is suppressed.

        """
        arg_list: List[str] = []
        arg_list.append(f"record={record.__repr__()}")
        arg_list.append(f"display={display.__repr__()}")
        arg_list.append(f"exception={exception.__repr__()}")
        arg_list.append(f"noexec={noexec.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.sendmesgoptions({arg_string})"
        return self._session.cmd(cmd)

    def setLpartMode(self, *args, **kwargs) -> Any:
        """Set the didplay mode for Lparts

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.setLpartMode({arg_string})"
        return self._session.cmd(cmd)

    def transfFeedbackRefresh(self, *args, **kwargs) -> Any:
        """Refresh feedback GUI for tool changes

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.transfFeedbackRefresh({arg_string})"
        return self._session.cmd(cmd)

    def update_userdefined_material(self, *args, **kwargs) -> Any:
        """Adds/removes/updates a user-defined material.

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.update_userdefined_material({arg_string})"
        return self._session.cmd(cmd)

    def usageLog(self, *args, **kwargs) -> Any:
        """Log feature usage

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.usageLog({arg_string})"
        return self._session.cmd(cmd)

    def using_enshell(self, *args, **kwargs) -> Any:
        """Returns non-zero if application is connected to a enshell

        """
        arg_list: List[str] = []
        for arg in args:
            arg_list.append(arg.__repr__())
        for key, value in kwargs.items():
            arg_list.append(f"{key}={value.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.using_enshell({arg_string})"
        return self._session.cmd(cmd)

    def version(self, element: str = "") -> Any:
        """EnSight version information
        
        Return EnSight version information.
        
        Args:
            element:
                The specific value to return is selected by the element argument. If no element name is
                specified, the return value will be a list in the form:
        
                    ['22.2.0(a)', 'Standard', 'win64', 'C:\\Program Files (x86)\\CEI', '22.2.0(a)', None,
                    {'lmtype': 'ANSYS', 'customer': '1', 'host': 'HOSTNAME', 'username': 'USER',
                    'keypath': 'Ansys'}, '222', 'Qt', '222']
        
                Valid (non-empty) element strings include:
                    * 'version-full' - EnSight version display string, for example: '2022 R1'
                    * 'numeric' - EnSight version broken down as a list of integers and a single string in the form: [year, release, patch, beta]. For example: [2022, 1, 0, 'Beta']
                    * 'year' - Year portion of the 'numeric' list (e.g. 2022)
                    * 'rel' - Release portion of the 'numeric' list (e.g. 1)
                    * 'patch' - Patch number portion of the 'numeric' list (e.g. 0)
                    * 'suffix' - Suffix number used internally for naming files/directories/etc (e.g. 221)
                    * 'customer' - Customer name from the licensing system (both flex and SLiM)
                    * 'company' - Company name from the licensing system
                    * 'product' - The current name of the EnSight product: 'EnSight', 'EnVision', etc
                    * 'mode' - License type: "batch", "HPC", "Standard", etc
                    * 'license' - Same as 'mode'
                    * 'flavor' - Same as 'mode'
                    * 'arch' - System architecture: 'linux_2.6_64', 'win64', etc
                    * 'CEI_HOME' - Base installation directory
                    * 'home' - Same as 'CEI_HOME'
                    * 'lmtype' - License manage name: "ANSYS", "SLiM" or "FSI"
                    * 'haveServer' - Boolean that will be True if a server or an SOS is connected
                    * 'haveSOS' - Boolean that will be True if an SOS is connected
                    * 'username' - User name the license is checked out to
                    * 'hostname' - Host name of the system EnSight is running on
                    * 'verbose' - The current output verbosity level as an integer
        
        Returns:
            The queried value

        """
        arg_list: List[str] = []
        arg_list.append(f"element={element.__repr__()}")
        arg_string = ",".join(arg_list)
        cmd = f"ensight.version({arg_string})"
        return self._session.cmd(cmd)


