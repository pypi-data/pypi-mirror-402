# coding: utf-8

"""
"""


from __future__ import absolute_import

import io
import json
import logging
import os
import re
import ssl
import urllib3

# python 2 and python 3 compatibility library
import six

# NOTE: This file is auto generated by the swagger code generator program.
# Do not edit the class manually.

try:
    import requests
    from requests_toolbelt import MultipartEncoder
except ImportError:
    raise ImportError('Swagger python client requires requests and requests toolbelt.')

from . import util


logger = logging.getLogger(__name__)


CONNECT_TIMEOUT = int(os.getenv('FLYWHEEL_SDK_CONNECT_TIMEOUT', 10))
REQUEST_TIMEOUT = int(os.getenv('FLYWHEEL_SDK_REQUEST_TIMEOUT', 60))

# Retry logic
# Total number of times to retry requests that fail due to transient HTTP errors
TOTAL_RETRIES = int(os.getenv('FLYWHEEL_SDK_TOTAL_RETRIES', 7))
# Backoff factor--after the initial instant retry, the client will start waiting for
# {backoff factor} * (2 ** ({number of previous retries})) seconds before each retry
# So the second retry will happen after waiting for 2 * {backoff_factor} seconds
BACKOFF_FACTOR = float(os.getenv('FLYWHEEL_SDK_BACKOFF_FACTOR', 7.5 / 4)) / 2

class RESTResponse(io.IOBase):

    def __init__(self, resp):
        super(RESTResponse, self).__init__()

        self.requests_response = resp
        self.status = resp.status_code
        self.reason = resp.reason
        self.data = resp.content

    def getheaders(self):
        """Returns a dictionary of the response headers."""
        return self.requests_response.headers

    def getheader(self, name, default=None):
        """Returns a given response header."""
        return self.requests_response.headers.get(name, default)


class RESTClientObject(object):
    def __init__(self, configuration, pools_size=4, maxsize=None,
        request_timeout=None, connect_timeout=None):
        self.request_timeout = request_timeout
        self.connect_timeout = connect_timeout
        self.session = requests.Session()

        self.request_counts = {}

        # cert_reqs
        if configuration.ssl_ca_cert:
            self.session.verify = configuration.ssl_ca_cert
        else:
            self.session.verify = configuration.verify_ssl

        util.set_verify_ssl(self.session)

        # retry lower-level connection errors and transient http errors
        # ref https://urllib3.readthedocs.io/en/latest/reference/urllib3.util.html#urllib3.util.retry.Retry
        transient_http_errors = {
            429,  # too many requests (TODO add transparent signed-URL support)
            502,  # bad gateway
            503,  # service unavailable
            504,  # gateway timeout
        }
        retry_methods = {"HEAD", "GET", "PUT", "DELETE", "OPTIONS", "TRACE", "PATCH"}
        # retries at 0.0s, 1.875s, 3.75s, 7.5s, 15s, 30s, 60s after the request by default
        # sleeptime is 0 on 1st retry, then backoff * 2^(retry-1)
        retry = urllib3.util.Retry(total=TOTAL_RETRIES,
                                   backoff_factor=BACKOFF_FACTOR,
                                   status_forcelist=transient_http_errors,
                                   allowed_methods=retry_methods)
        adapter = requests.adapters.HTTPAdapter(max_retries=retry)
        self.session.mount('http://', adapter)
        self.session.mount('https://', adapter)

        self.session.hooks['response'].append(self.response_hook)

        # TODO: Setup connection pool?

    @staticmethod
    def _prepare_for_multipart(fields):
        new_fields = list()
        for field_name, value in fields:
            if field_name == "metadata" and not isinstance(value, str):
                new_fields.append((field_name, json.dumps(value)))
            else:
                new_fields.append((field_name, value))
        return new_fields

    def response_hook(self, resp, *args, **kwargs):
        if not (200 <= resp.status_code <= 399):
            raise ApiException(http_resp=resp)

    def request(self, method, url, query_params=None, headers=None,
                body=None, post_params=None, _preload_content=True,
                _request_timeout=None):
        """Perform requests.

        :param method: http request method
        :param url: http request url
        :param query_params: query parameters in the url
        :param headers: http request headers
        :param body: request json body, for `application/json`
        :param post_params: request post parameters,
                            `application/x-www-form-urlencoded`
                            and `multipart/form-data`
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                            be returned without reading/decoding response
                            data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                            number provided, it will be total request
                            timeout. It can also be a pair (tuple) of
                            (connection, read) timeouts.
        """

        method = method.upper()
        assert method in ['GET', 'HEAD', 'DELETE', 'POST', 'PUT',
                          'PATCH', 'OPTIONS']

        if post_params and body:
            raise ValueError(
                "body parameter cannot be used with post_params parameter."
            )

        post_params = post_params or {}
        headers = headers or {}
        # Highest priority when passed into method via kwargs
        # Second priority when passed into Client()
        # Lowest priority env variables.
        if not _request_timeout:
            _request_timeout = (
                self.connect_timeout or int(os.getenv('FLYWHEEL_SDK_CONNECT_TIMEOUT', 10)),
                self.request_timeout or int(os.getenv('FLYWHEEL_SDK_REQUEST_TIMEOUT', 60)),
            )

        if 'Content-Type' not in headers:
            headers['Content-Type'] = 'application/json'

        stream = not _preload_content

        urls = self.request_counts.setdefault(method, {})
        if url in self.request_counts[method]:
            urls[url] += 1
        else:
            urls[url] = 1

        if method in ['POST', 'PUT', 'PATCH', 'OPTIONS', 'DELETE']:
            if re.search('json', headers['Content-Type'], re.IGNORECASE):
                request_body = None
                if body is not None:
                    request_body = json.dumps(body)
                r = self.session.request(method, url,
                    params=query_params,
                    data=request_body,
                    stream=stream,
                    timeout=_request_timeout,
                    headers=headers)
            elif headers['Content-Type'] == 'application/x-www-form-urlencoded':  # noqa: E501
                r = self.session.request(method, url,
                    params=query_params,
                    data=post_params,
                    stream=stream,
                    timeout=_request_timeout,
                    headers=headers)
            elif headers['Content-Type'] == 'multipart/form-data':
                m = MultipartEncoder(self._prepare_for_multipart(post_params))
                headers['Content-Type'] = m.content_type
                r = self.session.request(method, url,
                    params=query_params,
                    data=m,
                    stream=stream,
                    timeout=_request_timeout,
                    headers=headers)
            # Pass a `string` parameter directly in the body to support
            # other content types than Json when `body` argument is
            # provided in serialized form
            elif isinstance(body, str):
                r = self.session.request(method, url,
                    params=query_params,
                    data=body,
                    stream=stream,
                    timeout=_request_timeout,
                    headers=headers)
            else:
                # Cannot generate the request from given parameters
                msg = """Cannot prepare a request message for provided
                    arguments. Please check that your arguments match
                    declared content type."""
                raise ApiException(status=0, reason=msg)
        # For `GET`, `HEAD`
        else:
            r = self.session.request(method, url,
                params=query_params,
                stream=stream,
                timeout=_request_timeout,
                headers=headers)

        if _preload_content:
            r = RESTResponse(r)

            # In the python 3, the response.data is bytes.
            # we need to decode it to string.
            if six.PY3:
                r.data = r.data.decode('utf8')

            # log response body
            logger.debug("response body: %s", r.data)

        return r

    def GET(self, url, headers=None, query_params=None, _preload_content=True,
            _request_timeout=None):
        return self.request("GET", url,
                            headers=headers,
                            _preload_content=_preload_content,
                            _request_timeout=_request_timeout,
                            query_params=query_params)

    def HEAD(self, url, headers=None, query_params=None, _preload_content=True,
             _request_timeout=None):
        return self.request("HEAD", url,
                            headers=headers,
                            _preload_content=_preload_content,
                            _request_timeout=_request_timeout,
                            query_params=query_params)

    def OPTIONS(self, url, headers=None, query_params=None, post_params=None,
                body=None, _preload_content=True, _request_timeout=None):
        return self.request("OPTIONS", url,
                            headers=headers,
                            query_params=query_params,
                            post_params=post_params,
                            _preload_content=_preload_content,
                            _request_timeout=_request_timeout,
                            body=body)

    def DELETE(self, url, headers=None, query_params=None, body=None,
               _preload_content=True, _request_timeout=None):
        return self.request("DELETE", url,
                            headers=headers,
                            query_params=query_params,
                            _preload_content=_preload_content,
                            _request_timeout=_request_timeout,
                            body=body)

    def POST(self, url, headers=None, query_params=None, post_params=None,
             body=None, _preload_content=True, _request_timeout=None):
        return self.request("POST", url,
                            headers=headers,
                            query_params=query_params,
                            post_params=post_params,
                            _preload_content=_preload_content,
                            _request_timeout=_request_timeout,
                            body=body)

    def PUT(self, url, headers=None, query_params=None, post_params=None,
            body=None, _preload_content=True, _request_timeout=None):
        return self.request("PUT", url,
                            headers=headers,
                            query_params=query_params,
                            post_params=post_params,
                            _preload_content=_preload_content,
                            _request_timeout=_request_timeout,
                            body=body)

    def PATCH(self, url, headers=None, query_params=None, post_params=None,
              body=None, _preload_content=True, _request_timeout=None):
        return self.request("PATCH", url,
                            headers=headers,
                            query_params=query_params,
                            post_params=post_params,
                            _preload_content=_preload_content,
                            _request_timeout=_request_timeout,
                            body=body)


class ApiException(Exception):

    def __init__(self, status=None, reason=None, http_resp=None):
        super(ApiException, self).__init__()

        self.detail = None

        if http_resp is not None:
            self.status = http_resp.status_code
            self.reason = http_resp.reason

            # Convert body to text
            try:
                if six.PY3:
                    self.body = http_resp.content.decode('utf8')
                else:
                    self.body = http_resp.content
            except: # pylint: disable=W0702
                self.body = None

            # Extract detailed message
            if self.body:
                try:
                    response = json.loads(self.body)
                    self.reason = response.get('message')
                    self.detail = response.get('detail')
                except: #pylint: disable=W0702
                    pass

            self.headers = http_resp.headers
        else:
            self.status = status
            self.reason = reason
            self.body = None
            self.headers = None

    def __str__(self):
        """Custom error messages for exception"""
        error_message = "({0}) Reason: {1}".format(self.status, self.reason)

        if self.detail:
            error_message += "\nDetail: {0}".format(self.detail)

        return error_message
